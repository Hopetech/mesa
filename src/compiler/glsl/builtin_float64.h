ir_function_signature *
fabs64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000B);
   body.emit(assign(r000B, bit_and(swizzle_y(r000B), body.constant(2147483647u)), 0x02));

   body.emit(ret(r000B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
is_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000C);
   ir_expression *const r000D = lshift(swizzle_y(r000C), body.constant(int(1)));
   ir_expression *const r000E = lequal(body.constant(4292870144u), r000D);
   ir_expression *const r000F = nequal(swizzle_x(r000C), body.constant(0u));
   ir_expression *const r0010 = bit_and(swizzle_y(r000C), body.constant(1048575u));
   ir_expression *const r0011 = nequal(r0010, body.constant(0u));
   ir_expression *const r0012 = logic_or(r000F, r0011);
   ir_expression *const r0013 = logic_and(r000E, r0012);
   body.emit(ret(r0013));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fneg64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0014 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0014);
   ir_variable *const r0015 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r0017 = lshift(swizzle_y(r0014), body.constant(int(1)));
   ir_expression *const r0018 = lequal(body.constant(4292870144u), r0017);
   ir_expression *const r0019 = nequal(swizzle_x(r0014), body.constant(0u));
   ir_expression *const r001A = bit_and(swizzle_y(r0014), body.constant(1048575u));
   ir_expression *const r001B = nequal(r001A, body.constant(0u));
   ir_expression *const r001C = logic_or(r0019, r001B);
   ir_expression *const r001D = logic_and(r0018, r001C);
   ir_if *f0016 = new(mem_ctx) ir_if(operand(r001D).val);
   exec_list *const f0016_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0016->then_instructions;

      body.emit(assign(r0015, r0014, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0016->else_instructions;

      body.emit(assign(r0014, bit_xor(swizzle_y(r0014), body.constant(2147483648u)), 0x02));

      body.emit(assign(r0015, r0014, 0x03));


   body.instructions = f0016_parent_instructions;
   body.emit(f0016);

   /* END IF */

   body.emit(ret(r0015));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64FracLo(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r001E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r001E);
   ir_swizzle *const r001F = swizzle_x(r001E);
   body.emit(ret(r001F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64FracHi(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0020 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0020);
   ir_expression *const r0021 = bit_and(swizzle_y(r0020), body.constant(1048575u));
   body.emit(ret(r0021));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0022 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0022);
   ir_expression *const r0023 = rshift(swizzle_y(r0022), body.constant(int(20)));
   ir_expression *const r0024 = bit_and(r0023, body.constant(2047u));
   ir_expression *const r0025 = expr(ir_unop_u2i, r0024);
   body.emit(ret(r0025));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
feq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0026 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0026);
   ir_variable *const r0027 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0027);
   ir_variable *const r0028 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0029 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0029);
   ir_variable *const r002A = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r002A);
   ir_expression *const r002B = rshift(swizzle_y(r0026), body.constant(int(20)));
   ir_expression *const r002C = bit_and(r002B, body.constant(2047u));
   ir_expression *const r002D = expr(ir_unop_u2i, r002C);
   ir_expression *const r002E = equal(r002D, body.constant(int(2047)));
   ir_expression *const r002F = bit_and(swizzle_y(r0026), body.constant(1048575u));
   ir_expression *const r0030 = bit_or(r002F, swizzle_x(r0026));
   ir_expression *const r0031 = nequal(r0030, body.constant(0u));
   body.emit(assign(r002A, logic_and(r002E, r0031), 0x01));

   ir_expression *const r0032 = rshift(swizzle_y(r0027), body.constant(int(20)));
   ir_expression *const r0033 = bit_and(r0032, body.constant(2047u));
   ir_expression *const r0034 = expr(ir_unop_u2i, r0033);
   ir_expression *const r0035 = equal(r0034, body.constant(int(2047)));
   ir_expression *const r0036 = bit_and(swizzle_y(r0027), body.constant(1048575u));
   ir_expression *const r0037 = bit_or(r0036, swizzle_x(r0027));
   ir_expression *const r0038 = nequal(r0037, body.constant(0u));
   body.emit(assign(r0029, logic_and(r0035, r0038), 0x01));

   /* IF CONDITION */
   ir_expression *const r003A = logic_or(r002A, r0029);
   ir_if *f0039 = new(mem_ctx) ir_if(operand(r003A).val);
   exec_list *const f0039_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0039->then_instructions;

      body.emit(assign(r0028, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0039->else_instructions;

      ir_expression *const r003B = equal(swizzle_x(r0026), swizzle_x(r0027));
      ir_expression *const r003C = equal(swizzle_y(r0026), swizzle_y(r0027));
      ir_expression *const r003D = equal(swizzle_x(r0026), body.constant(0u));
      ir_expression *const r003E = bit_or(swizzle_y(r0026), swizzle_y(r0027));
      ir_expression *const r003F = lshift(r003E, body.constant(int(1)));
      ir_expression *const r0040 = equal(r003F, body.constant(0u));
      ir_expression *const r0041 = logic_and(r003D, r0040);
      ir_expression *const r0042 = logic_or(r003C, r0041);
      body.emit(assign(r0028, logic_and(r003B, r0042), 0x01));


   body.instructions = f0039_parent_instructions;
   body.emit(f0039);

   /* END IF */

   body.emit(ret(r0028));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0043 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0043);
   ir_expression *const r0044 = rshift(swizzle_y(r0043), body.constant(int(31)));
   body.emit(ret(r0044));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
le64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0045 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0045);
   ir_variable *const r0046 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0046);
   ir_variable *const r0047 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0047);
   ir_variable *const r0048 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0048);
   ir_expression *const r0049 = less(r0045, r0047);
   ir_expression *const r004A = equal(r0045, r0047);
   ir_expression *const r004B = lequal(r0046, r0048);
   ir_expression *const r004C = logic_and(r004A, r004B);
   ir_expression *const r004D = logic_or(r0049, r004C);
   body.emit(ret(r004D));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fle64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r004E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r004E);
   ir_variable *const r004F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r004F);
   ir_variable *const r0050 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0051 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0051);
   ir_variable *const r0052 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0052);
   ir_expression *const r0053 = rshift(swizzle_y(r004E), body.constant(int(20)));
   ir_expression *const r0054 = bit_and(r0053, body.constant(2047u));
   ir_expression *const r0055 = expr(ir_unop_u2i, r0054);
   ir_expression *const r0056 = equal(r0055, body.constant(int(2047)));
   ir_expression *const r0057 = bit_and(swizzle_y(r004E), body.constant(1048575u));
   ir_expression *const r0058 = bit_or(r0057, swizzle_x(r004E));
   ir_expression *const r0059 = nequal(r0058, body.constant(0u));
   body.emit(assign(r0052, logic_and(r0056, r0059), 0x01));

   ir_expression *const r005A = rshift(swizzle_y(r004F), body.constant(int(20)));
   ir_expression *const r005B = bit_and(r005A, body.constant(2047u));
   ir_expression *const r005C = expr(ir_unop_u2i, r005B);
   ir_expression *const r005D = equal(r005C, body.constant(int(2047)));
   ir_expression *const r005E = bit_and(swizzle_y(r004F), body.constant(1048575u));
   ir_expression *const r005F = bit_or(r005E, swizzle_x(r004F));
   ir_expression *const r0060 = nequal(r005F, body.constant(0u));
   body.emit(assign(r0051, logic_and(r005D, r0060), 0x01));

   /* IF CONDITION */
   ir_expression *const r0062 = logic_or(r0052, r0051);
   ir_if *f0061 = new(mem_ctx) ir_if(operand(r0062).val);
   exec_list *const f0061_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0061->then_instructions;

      body.emit(assign(r0050, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0061->else_instructions;

      ir_variable *const r0063 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0063, rshift(swizzle_y(r004E), body.constant(int(31))), 0x01));

      ir_variable *const r0064 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0064, rshift(swizzle_y(r004F), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0066 = nequal(r0063, r0064);
      ir_if *f0065 = new(mem_ctx) ir_if(operand(r0066).val);
      exec_list *const f0065_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0065->then_instructions;

         ir_expression *const r0067 = nequal(r0063, body.constant(0u));
         ir_expression *const r0068 = bit_or(swizzle_y(r004E), swizzle_y(r004F));
         ir_expression *const r0069 = lshift(r0068, body.constant(int(1)));
         ir_expression *const r006A = bit_or(r0069, swizzle_x(r004E));
         ir_expression *const r006B = bit_or(r006A, swizzle_x(r004F));
         ir_expression *const r006C = equal(r006B, body.constant(0u));
         body.emit(assign(r0050, logic_or(r0067, r006C), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0065->else_instructions;

         ir_variable *const r006D = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r006F = nequal(r0063, body.constant(0u));
         ir_if *f006E = new(mem_ctx) ir_if(operand(r006F).val);
         exec_list *const f006E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f006E->then_instructions;

            ir_expression *const r0070 = less(swizzle_y(r004F), swizzle_y(r004E));
            ir_expression *const r0071 = equal(swizzle_y(r004F), swizzle_y(r004E));
            ir_expression *const r0072 = lequal(swizzle_x(r004F), swizzle_x(r004E));
            ir_expression *const r0073 = logic_and(r0071, r0072);
            body.emit(assign(r006D, logic_or(r0070, r0073), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f006E->else_instructions;

            ir_expression *const r0074 = less(swizzle_y(r004E), swizzle_y(r004F));
            ir_expression *const r0075 = equal(swizzle_y(r004E), swizzle_y(r004F));
            ir_expression *const r0076 = lequal(swizzle_x(r004E), swizzle_x(r004F));
            ir_expression *const r0077 = logic_and(r0075, r0076);
            body.emit(assign(r006D, logic_or(r0074, r0077), 0x01));


         body.instructions = f006E_parent_instructions;
         body.emit(f006E);

         /* END IF */

         body.emit(assign(r0050, r006D, 0x01));


      body.instructions = f0065_parent_instructions;
      body.emit(f0065);

      /* END IF */


   body.instructions = f0061_parent_instructions;
   body.emit(f0061);

   /* END IF */

   body.emit(ret(r0050));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
lt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0078 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0078);
   ir_variable *const r0079 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0079);
   ir_variable *const r007A = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r007A);
   ir_variable *const r007B = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r007B);
   ir_expression *const r007C = less(r0078, r007A);
   ir_expression *const r007D = equal(r0078, r007A);
   ir_expression *const r007E = less(r0079, r007B);
   ir_expression *const r007F = logic_and(r007D, r007E);
   ir_expression *const r0080 = logic_or(r007C, r007F);
   body.emit(ret(r0080));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
flt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0081 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0081);
   ir_variable *const r0082 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0082);
   ir_variable *const r0083 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0084 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0084);
   ir_variable *const r0085 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0085);
   ir_expression *const r0086 = rshift(swizzle_y(r0081), body.constant(int(20)));
   ir_expression *const r0087 = bit_and(r0086, body.constant(2047u));
   ir_expression *const r0088 = expr(ir_unop_u2i, r0087);
   ir_expression *const r0089 = equal(r0088, body.constant(int(2047)));
   ir_expression *const r008A = bit_and(swizzle_y(r0081), body.constant(1048575u));
   ir_expression *const r008B = bit_or(r008A, swizzle_x(r0081));
   ir_expression *const r008C = nequal(r008B, body.constant(0u));
   body.emit(assign(r0085, logic_and(r0089, r008C), 0x01));

   ir_expression *const r008D = rshift(swizzle_y(r0082), body.constant(int(20)));
   ir_expression *const r008E = bit_and(r008D, body.constant(2047u));
   ir_expression *const r008F = expr(ir_unop_u2i, r008E);
   ir_expression *const r0090 = equal(r008F, body.constant(int(2047)));
   ir_expression *const r0091 = bit_and(swizzle_y(r0082), body.constant(1048575u));
   ir_expression *const r0092 = bit_or(r0091, swizzle_x(r0082));
   ir_expression *const r0093 = nequal(r0092, body.constant(0u));
   body.emit(assign(r0084, logic_and(r0090, r0093), 0x01));

   /* IF CONDITION */
   ir_expression *const r0095 = logic_or(r0085, r0084);
   ir_if *f0094 = new(mem_ctx) ir_if(operand(r0095).val);
   exec_list *const f0094_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0094->then_instructions;

      body.emit(assign(r0083, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0094->else_instructions;

      ir_variable *const r0096 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0096, rshift(swizzle_y(r0081), body.constant(int(31))), 0x01));

      ir_variable *const r0097 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0097, rshift(swizzle_y(r0082), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0099 = nequal(r0096, r0097);
      ir_if *f0098 = new(mem_ctx) ir_if(operand(r0099).val);
      exec_list *const f0098_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0098->then_instructions;

         ir_expression *const r009A = nequal(r0096, body.constant(0u));
         ir_expression *const r009B = bit_or(swizzle_y(r0081), swizzle_y(r0082));
         ir_expression *const r009C = lshift(r009B, body.constant(int(1)));
         ir_expression *const r009D = bit_or(r009C, swizzle_x(r0081));
         ir_expression *const r009E = bit_or(r009D, swizzle_x(r0082));
         ir_expression *const r009F = nequal(r009E, body.constant(0u));
         body.emit(assign(r0083, logic_and(r009A, r009F), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0098->else_instructions;

         ir_variable *const r00A0 = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r00A2 = nequal(r0096, body.constant(0u));
         ir_if *f00A1 = new(mem_ctx) ir_if(operand(r00A2).val);
         exec_list *const f00A1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00A1->then_instructions;

            ir_expression *const r00A3 = less(swizzle_y(r0082), swizzle_y(r0081));
            ir_expression *const r00A4 = equal(swizzle_y(r0082), swizzle_y(r0081));
            ir_expression *const r00A5 = less(swizzle_x(r0082), swizzle_x(r0081));
            ir_expression *const r00A6 = logic_and(r00A4, r00A5);
            body.emit(assign(r00A0, logic_or(r00A3, r00A6), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00A1->else_instructions;

            ir_expression *const r00A7 = less(swizzle_y(r0081), swizzle_y(r0082));
            ir_expression *const r00A8 = equal(swizzle_y(r0081), swizzle_y(r0082));
            ir_expression *const r00A9 = less(swizzle_x(r0081), swizzle_x(r0082));
            ir_expression *const r00AA = logic_and(r00A8, r00A9);
            body.emit(assign(r00A0, logic_or(r00A7, r00AA), 0x01));


         body.instructions = f00A1_parent_instructions;
         body.emit(f00A1);

         /* END IF */

         body.emit(assign(r0083, r00A0, 0x01));


      body.instructions = f0098_parent_instructions;
      body.emit(f0098);

      /* END IF */


   body.instructions = f0094_parent_instructions;
   body.emit(f0094);

   /* END IF */

   body.emit(ret(r0083));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00AB);
   ir_variable *const r00AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00AC);
   ir_variable *const r00AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00AD);
   ir_variable *const r00AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00AE);
   ir_variable *const r00AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00AF);
   ir_variable *const r00B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00B0);
   ir_variable *const r00B1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r00B1, add(r00AC, r00AE), 0x01));

   body.emit(assign(r00B0, r00B1, 0x01));

   ir_expression *const r00B2 = add(r00AB, r00AD);
   ir_expression *const r00B3 = less(r00B1, r00AC);
   ir_expression *const r00B4 = expr(ir_unop_b2i, r00B3);
   ir_expression *const r00B5 = expr(ir_unop_i2u, r00B4);
   body.emit(assign(r00AF, add(r00B2, r00B5), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00B6);
   ir_variable *const r00B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00B7);
   ir_variable *const r00B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00B8);
   ir_variable *const r00B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00B9);
   ir_variable *const r00BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00BA);
   ir_variable *const r00BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00BB);
   body.emit(assign(r00BB, sub(r00B7, r00B9), 0x01));

   ir_expression *const r00BC = sub(r00B6, r00B8);
   ir_expression *const r00BD = less(r00B7, r00B9);
   ir_expression *const r00BE = expr(ir_unop_b2i, r00BD);
   ir_expression *const r00BF = expr(ir_unop_i2u, r00BE);
   body.emit(assign(r00BA, sub(r00BC, r00BF), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
eq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00C0);
   ir_variable *const r00C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00C1);
   ir_variable *const r00C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00C2);
   ir_variable *const r00C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00C3);
   ir_expression *const r00C4 = equal(r00C0, r00C2);
   ir_expression *const r00C5 = equal(r00C1, r00C3);
   ir_expression *const r00C6 = logic_and(r00C4, r00C5);
   body.emit(ret(r00C6));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
float64_is_signaling_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r00C7);
   ir_expression *const r00C8 = rshift(swizzle_y(r00C7), body.constant(int(19)));
   ir_expression *const r00C9 = bit_and(r00C8, body.constant(4095u));
   ir_expression *const r00CA = equal(r00C9, body.constant(4094u));
   ir_expression *const r00CB = nequal(swizzle_x(r00C7), body.constant(0u));
   ir_expression *const r00CC = bit_and(swizzle_y(r00C7), body.constant(524287u));
   ir_expression *const r00CD = nequal(r00CC, body.constant(0u));
   ir_expression *const r00CE = logic_or(r00CB, r00CD);
   ir_expression *const r00CF = logic_and(r00CA, r00CE);
   body.emit(ret(r00CF));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00D0);
   ir_variable *const r00D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00D1);
   ir_variable *const r00D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00D2);
   ir_variable *const r00D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D3);
   ir_variable *const r00D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D4);
   ir_variable *const r00D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00D5);
   ir_variable *const r00D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00D6);
   ir_variable *const r00D7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r00D8 = neg(r00D2);
   body.emit(assign(r00D7, bit_and(r00D8, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r00DA = equal(r00D2, body.constant(int(0)));
   ir_if *f00D9 = new(mem_ctx) ir_if(operand(r00DA).val);
   exec_list *const f00D9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f00D9->then_instructions;

      body.emit(assign(r00D5, r00D1, 0x01));

      body.emit(assign(r00D6, r00D0, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f00D9->else_instructions;

      /* IF CONDITION */
      ir_expression *const r00DC = less(r00D2, body.constant(int(32)));
      ir_if *f00DB = new(mem_ctx) ir_if(operand(r00DC).val);
      exec_list *const f00DB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f00DB->then_instructions;

         ir_expression *const r00DD = lshift(r00D0, r00D7);
         ir_expression *const r00DE = rshift(r00D1, r00D2);
         ir_expression *const r00DF = bit_or(r00DD, r00DE);
         ir_expression *const r00E0 = lshift(r00D1, r00D7);
         ir_expression *const r00E1 = nequal(r00E0, body.constant(0u));
         ir_expression *const r00E2 = expr(ir_unop_b2i, r00E1);
         ir_expression *const r00E3 = expr(ir_unop_i2u, r00E2);
         body.emit(assign(r00D5, bit_or(r00DF, r00E3), 0x01));

         body.emit(assign(r00D6, rshift(r00D0, r00D2), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f00DB->else_instructions;

         /* IF CONDITION */
         ir_expression *const r00E5 = equal(r00D2, body.constant(int(32)));
         ir_if *f00E4 = new(mem_ctx) ir_if(operand(r00E5).val);
         exec_list *const f00E4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00E4->then_instructions;

            ir_expression *const r00E6 = nequal(r00D1, body.constant(0u));
            ir_expression *const r00E7 = expr(ir_unop_b2i, r00E6);
            ir_expression *const r00E8 = expr(ir_unop_i2u, r00E7);
            body.emit(assign(r00D5, bit_or(r00D0, r00E8), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00E4->else_instructions;

            /* IF CONDITION */
            ir_expression *const r00EA = less(r00D2, body.constant(int(64)));
            ir_if *f00E9 = new(mem_ctx) ir_if(operand(r00EA).val);
            exec_list *const f00E9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f00E9->then_instructions;

               ir_expression *const r00EB = bit_and(r00D2, body.constant(int(31)));
               ir_expression *const r00EC = rshift(r00D0, r00EB);
               ir_expression *const r00ED = lshift(r00D0, r00D7);
               ir_expression *const r00EE = bit_or(r00ED, r00D1);
               ir_expression *const r00EF = nequal(r00EE, body.constant(0u));
               ir_expression *const r00F0 = expr(ir_unop_b2i, r00EF);
               ir_expression *const r00F1 = expr(ir_unop_i2u, r00F0);
               body.emit(assign(r00D5, bit_or(r00EC, r00F1), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f00E9->else_instructions;

               ir_expression *const r00F2 = bit_or(r00D0, r00D1);
               ir_expression *const r00F3 = nequal(r00F2, body.constant(0u));
               ir_expression *const r00F4 = expr(ir_unop_b2i, r00F3);
               body.emit(assign(r00D5, expr(ir_unop_i2u, r00F4), 0x01));


            body.instructions = f00E9_parent_instructions;
            body.emit(f00E9);

            /* END IF */


         body.instructions = f00E4_parent_instructions;
         body.emit(f00E4);

         /* END IF */

         body.emit(assign(r00D6, body.constant(0u), 0x01));


      body.instructions = f00DB_parent_instructions;
      body.emit(f00DB);

      /* END IF */


   body.instructions = f00D9_parent_instructions;
   body.emit(f00D9);

   /* END IF */

   body.emit(assign(r00D4, r00D5, 0x01));

   body.emit(assign(r00D3, r00D6, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64ExtraRightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00F5);
   ir_variable *const r00F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00F6);
   ir_variable *const r00F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r00F7);
   ir_variable *const r00F8 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00F8);
   ir_variable *const r00F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F9);
   ir_variable *const r00FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00FA);
   ir_variable *const r00FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00FB);
   ir_variable *const r00FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
   body.emit(r00FC);
   ir_variable *const r00FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00FD);
   ir_variable *const r00FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00FE);
   ir_variable *const r00FF = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r0100 = neg(r00F8);
   body.emit(assign(r00FF, bit_and(r0100, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0102 = equal(r00F8, body.constant(int(0)));
   ir_if *f0101 = new(mem_ctx) ir_if(operand(r0102).val);
   exec_list *const f0101_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0101->then_instructions;

      body.emit(assign(r00FC, r00F7, 0x01));

      body.emit(assign(r00FD, r00F6, 0x01));

      body.emit(assign(r00FE, r00F5, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0101->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0104 = less(r00F8, body.constant(int(32)));
      ir_if *f0103 = new(mem_ctx) ir_if(operand(r0104).val);
      exec_list *const f0103_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0103->then_instructions;

         body.emit(assign(r00FC, lshift(r00F6, r00FF), 0x01));

         ir_expression *const r0105 = lshift(r00F5, r00FF);
         ir_expression *const r0106 = rshift(r00F6, r00F8);
         body.emit(assign(r00FD, bit_or(r0105, r0106), 0x01));

         body.emit(assign(r00FE, rshift(r00F5, r00F8), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0103->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0108 = equal(r00F8, body.constant(int(32)));
         ir_if *f0107 = new(mem_ctx) ir_if(operand(r0108).val);
         exec_list *const f0107_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0107->then_instructions;

            body.emit(assign(r00FC, r00F6, 0x01));

            body.emit(assign(r00FD, r00F5, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0107->else_instructions;

            body.emit(assign(r00F7, bit_or(r00F7, r00F6), 0x01));

            /* IF CONDITION */
            ir_expression *const r010A = less(r00F8, body.constant(int(64)));
            ir_if *f0109 = new(mem_ctx) ir_if(operand(r010A).val);
            exec_list *const f0109_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0109->then_instructions;

               body.emit(assign(r00FC, lshift(r00F5, r00FF), 0x01));

               ir_expression *const r010B = bit_and(r00F8, body.constant(int(31)));
               body.emit(assign(r00FD, rshift(r00F5, r010B), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0109->else_instructions;

               ir_variable *const r010C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r010E = equal(r00F8, body.constant(int(64)));
               ir_if *f010D = new(mem_ctx) ir_if(operand(r010E).val);
               exec_list *const f010D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f010D->then_instructions;

                  body.emit(assign(r010C, r00F5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f010D->else_instructions;

                  ir_expression *const r010F = nequal(r00F5, body.constant(0u));
                  ir_expression *const r0110 = expr(ir_unop_b2i, r010F);
                  body.emit(assign(r010C, expr(ir_unop_i2u, r0110), 0x01));


               body.instructions = f010D_parent_instructions;
               body.emit(f010D);

               /* END IF */

               body.emit(assign(r00FC, r010C, 0x01));

               body.emit(assign(r00FD, body.constant(0u), 0x01));


            body.instructions = f0109_parent_instructions;
            body.emit(f0109);

            /* END IF */


         body.instructions = f0107_parent_instructions;
         body.emit(f0107);

         /* END IF */

         body.emit(assign(r00FE, body.constant(0u), 0x01));


      body.instructions = f0103_parent_instructions;
      body.emit(f0103);

      /* END IF */

      ir_expression *const r0111 = nequal(r00F7, body.constant(0u));
      ir_expression *const r0112 = expr(ir_unop_b2i, r0111);
      ir_expression *const r0113 = expr(ir_unop_i2u, r0112);
      body.emit(assign(r00FC, bit_or(r00FC, r0113), 0x01));


   body.instructions = f0101_parent_instructions;
   body.emit(f0101);

   /* END IF */

   body.emit(assign(r00FB, r00FC, 0x01));

   body.emit(assign(r00FA, r00FD, 0x01));

   body.emit(assign(r00F9, r00FE, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shortShift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0114 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0114);
   ir_variable *const r0115 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0115);
   ir_variable *const r0116 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r0116);
   ir_variable *const r0117 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0117);
   ir_variable *const r0118 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0118);
   body.emit(assign(r0118, lshift(r0115, r0116), 0x01));

   ir_variable *const r0119 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r011B = equal(r0116, body.constant(int(0)));
   ir_if *f011A = new(mem_ctx) ir_if(operand(r011B).val);
   exec_list *const f011A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f011A->then_instructions;

      body.emit(assign(r0119, r0114, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f011A->else_instructions;

      ir_expression *const r011C = lshift(r0114, r0116);
      ir_expression *const r011D = neg(r0116);
      ir_expression *const r011E = bit_and(r011D, body.constant(int(31)));
      ir_expression *const r011F = rshift(r0115, r011E);
      body.emit(assign(r0119, bit_or(r011C, r011F), 0x01));


   body.instructions = f011A_parent_instructions;
   body.emit(f011A);

   /* END IF */

   body.emit(assign(r0117, r0119, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0120 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0120);
   ir_variable *const r0121 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0121);
   ir_variable *const r0122 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0122);
   ir_variable *const r0123 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0123);
   ir_variable *const r0124 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
   body.emit(r0124);
   ir_expression *const r0125 = lshift(r0120, body.constant(int(31)));
   ir_expression *const r0126 = expr(ir_unop_i2u, r0121);
   ir_expression *const r0127 = lshift(r0126, body.constant(int(20)));
   ir_expression *const r0128 = add(r0125, r0127);
   body.emit(assign(r0124, add(r0128, r0122), 0x02));

   body.emit(assign(r0124, r0123, 0x01));

   body.emit(ret(r0124));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0129 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0129);
   ir_variable *const r012A = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r012A);
   ir_variable *const r012B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r012B);
   ir_variable *const r012C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r012C);
   ir_variable *const r012D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_function_in);
   sig_parameters.push_tail(r012D);
   ir_variable *const r012E = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r012E, body.constant(true), 0x01));

   ir_variable *const r012F = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0130 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r0130);
   ir_expression *const r0131 = expr(ir_unop_u2i, r012D);
   body.emit(assign(r0130, less(r0131, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0133 = lequal(body.constant(int(2045)), r012A);
   ir_if *f0132 = new(mem_ctx) ir_if(operand(r0133).val);
   exec_list *const f0132_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0132->then_instructions;

      ir_variable *const r0134 = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r0136 = less(body.constant(int(2045)), r012A);
      ir_if *f0135 = new(mem_ctx) ir_if(operand(r0136).val);
      exec_list *const f0135_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0135->then_instructions;

         body.emit(assign(r0134, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0135->else_instructions;

         ir_variable *const r0137 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r0139 = equal(r012A, body.constant(int(2045)));
         ir_if *f0138 = new(mem_ctx) ir_if(operand(r0139).val);
         exec_list *const f0138_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0138->then_instructions;

            ir_expression *const r013A = equal(body.constant(2097151u), r012B);
            ir_expression *const r013B = equal(body.constant(4294967295u), r012C);
            body.emit(assign(r0137, logic_and(r013A, r013B), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0138->else_instructions;

            body.emit(assign(r0137, body.constant(false), 0x01));


         body.instructions = f0138_parent_instructions;
         body.emit(f0138);

         /* END IF */

         body.emit(assign(r0134, logic_and(r0137, r0130), 0x01));


      body.instructions = f0135_parent_instructions;
      body.emit(f0135);

      /* END IF */

      /* IF CONDITION */
      ir_if *f013C = new(mem_ctx) ir_if(operand(r0134).val);
      exec_list *const f013C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f013C->then_instructions;

         ir_variable *const r013D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r013D);
         ir_expression *const r013E = lshift(r0129, body.constant(int(31)));
         body.emit(assign(r013D, add(r013E, body.constant(2146435072u)), 0x02));

         body.emit(assign(r013D, body.constant(0u), 0x01));

         body.emit(assign(r012F, r013D, 0x03));

         body.emit(assign(r012E, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f013C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0140 = less(r012A, body.constant(int(0)));
         ir_if *f013F = new(mem_ctx) ir_if(operand(r0140).val);
         exec_list *const f013F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f013F->then_instructions;

            ir_variable *const r0141 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r0141, r012D, 0x01));

            ir_variable *const r0142 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r0142, neg(r012A), 0x01));

            ir_variable *const r0143 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0143);
            ir_variable *const r0144 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0144);
            ir_variable *const r0145 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0145);
            ir_variable *const r0146 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0147 = neg(r0142);
            body.emit(assign(r0146, bit_and(r0147, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0149 = equal(r0142, body.constant(int(0)));
            ir_if *f0148 = new(mem_ctx) ir_if(operand(r0149).val);
            exec_list *const f0148_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0148->then_instructions;

               body.emit(assign(r0143, r012D, 0x01));

               body.emit(assign(r0144, r012C, 0x01));

               body.emit(assign(r0145, r012B, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0148->else_instructions;

               /* IF CONDITION */
               ir_expression *const r014B = less(r0142, body.constant(int(32)));
               ir_if *f014A = new(mem_ctx) ir_if(operand(r014B).val);
               exec_list *const f014A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f014A->then_instructions;

                  body.emit(assign(r0143, lshift(r012C, r0146), 0x01));

                  ir_expression *const r014C = lshift(r012B, r0146);
                  ir_expression *const r014D = rshift(r012C, r0142);
                  body.emit(assign(r0144, bit_or(r014C, r014D), 0x01));

                  body.emit(assign(r0145, rshift(r012B, r0142), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f014A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r014F = equal(r0142, body.constant(int(32)));
                  ir_if *f014E = new(mem_ctx) ir_if(operand(r014F).val);
                  exec_list *const f014E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f014E->then_instructions;

                     body.emit(assign(r0143, r012C, 0x01));

                     body.emit(assign(r0144, r012B, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f014E->else_instructions;

                     body.emit(assign(r0141, bit_or(r012D, r012C), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0151 = less(r0142, body.constant(int(64)));
                     ir_if *f0150 = new(mem_ctx) ir_if(operand(r0151).val);
                     exec_list *const f0150_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0150->then_instructions;

                        body.emit(assign(r0143, lshift(r012B, r0146), 0x01));

                        ir_expression *const r0152 = bit_and(r0142, body.constant(int(31)));
                        body.emit(assign(r0144, rshift(r012B, r0152), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0150->else_instructions;

                        ir_variable *const r0153 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0155 = equal(r0142, body.constant(int(64)));
                        ir_if *f0154 = new(mem_ctx) ir_if(operand(r0155).val);
                        exec_list *const f0154_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0154->then_instructions;

                           body.emit(assign(r0153, r012B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0154->else_instructions;

                           ir_expression *const r0156 = nequal(r012B, body.constant(0u));
                           ir_expression *const r0157 = expr(ir_unop_b2i, r0156);
                           body.emit(assign(r0153, expr(ir_unop_i2u, r0157), 0x01));


                        body.instructions = f0154_parent_instructions;
                        body.emit(f0154);

                        /* END IF */

                        body.emit(assign(r0143, r0153, 0x01));

                        body.emit(assign(r0144, body.constant(0u), 0x01));


                     body.instructions = f0150_parent_instructions;
                     body.emit(f0150);

                     /* END IF */


                  body.instructions = f014E_parent_instructions;
                  body.emit(f014E);

                  /* END IF */

                  body.emit(assign(r0145, body.constant(0u), 0x01));


               body.instructions = f014A_parent_instructions;
               body.emit(f014A);

               /* END IF */

               ir_expression *const r0158 = nequal(r0141, body.constant(0u));
               ir_expression *const r0159 = expr(ir_unop_b2i, r0158);
               ir_expression *const r015A = expr(ir_unop_i2u, r0159);
               body.emit(assign(r0143, bit_or(r0143, r015A), 0x01));


            body.instructions = f0148_parent_instructions;
            body.emit(f0148);

            /* END IF */

            body.emit(assign(r012B, r0145, 0x01));

            body.emit(assign(r012C, r0144, 0x01));

            body.emit(assign(r012D, r0143, 0x01));

            body.emit(assign(r012A, body.constant(int(0)), 0x01));

            body.emit(assign(r0130, less(r0143, body.constant(0u)), 0x01));


         body.instructions = f013F_parent_instructions;
         body.emit(f013F);

         /* END IF */


      body.instructions = f013C_parent_instructions;
      body.emit(f013C);

      /* END IF */


   body.instructions = f0132_parent_instructions;
   body.emit(f0132);

   /* END IF */

   /* IF CONDITION */
   ir_if *f015B = new(mem_ctx) ir_if(operand(r012E).val);
   exec_list *const f015B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f015B->then_instructions;

      /* IF CONDITION */
      ir_if *f015C = new(mem_ctx) ir_if(operand(r0130).val);
      exec_list *const f015C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f015C->then_instructions;

         ir_variable *const r015D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r015D, add(r012C, body.constant(1u)), 0x01));

         ir_expression *const r015E = less(r015D, r012C);
         ir_expression *const r015F = expr(ir_unop_b2i, r015E);
         ir_expression *const r0160 = expr(ir_unop_i2u, r015F);
         body.emit(assign(r012B, add(r012B, r0160), 0x01));

         ir_expression *const r0161 = equal(r012D, body.constant(0u));
         ir_expression *const r0162 = expr(ir_unop_b2i, r0161);
         ir_expression *const r0163 = expr(ir_unop_i2u, r0162);
         ir_expression *const r0164 = add(r012D, r0163);
         ir_expression *const r0165 = bit_and(r0164, body.constant(1u));
         ir_expression *const r0166 = expr(ir_unop_bit_not, r0165);
         body.emit(assign(r012C, bit_and(r015D, r0166), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f015C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0168 = bit_or(r012B, r012C);
         ir_expression *const r0169 = equal(r0168, body.constant(0u));
         ir_if *f0167 = new(mem_ctx) ir_if(operand(r0169).val);
         exec_list *const f0167_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0167->then_instructions;

            body.emit(assign(r012A, body.constant(int(0)), 0x01));


         body.instructions = f0167_parent_instructions;
         body.emit(f0167);

         /* END IF */


      body.instructions = f015C_parent_instructions;
      body.emit(f015C);

      /* END IF */

      ir_variable *const r016A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r016A);
      ir_expression *const r016B = lshift(r0129, body.constant(int(31)));
      ir_expression *const r016C = expr(ir_unop_i2u, r012A);
      ir_expression *const r016D = lshift(r016C, body.constant(int(20)));
      ir_expression *const r016E = add(r016B, r016D);
      body.emit(assign(r016A, add(r016E, r012B), 0x02));

      body.emit(assign(r016A, r012C, 0x01));

      body.emit(assign(r012F, r016A, 0x03));

      body.emit(assign(r012E, body.constant(false), 0x01));


   body.instructions = f015B_parent_instructions;
   body.emit(f015B);

   /* END IF */

   body.emit(ret(r012F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
countLeadingZeros32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r016F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r016F);
   ir_variable *const r0170 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r0171 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0171);
   /* IF CONDITION */
   ir_expression *const r0173 = equal(r016F, body.constant(0u));
   ir_if *f0172 = new(mem_ctx) ir_if(operand(r0173).val);
   exec_list *const f0172_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0172->then_instructions;

      body.emit(assign(r0170, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0172->else_instructions;

      body.emit(assign(r0171, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0175 = bit_and(r016F, body.constant(4294901760u));
      ir_expression *const r0176 = equal(r0175, body.constant(0u));
      ir_if *f0174 = new(mem_ctx) ir_if(operand(r0176).val);
      exec_list *const f0174_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0174->then_instructions;

         body.emit(assign(r0171, body.constant(int(16)), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(16))), 0x01));


      body.instructions = f0174_parent_instructions;
      body.emit(f0174);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0178 = bit_and(r016F, body.constant(4278190080u));
      ir_expression *const r0179 = equal(r0178, body.constant(0u));
      ir_if *f0177 = new(mem_ctx) ir_if(operand(r0179).val);
      exec_list *const f0177_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0177->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(8))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(8))), 0x01));


      body.instructions = f0177_parent_instructions;
      body.emit(f0177);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017B = bit_and(r016F, body.constant(4026531840u));
      ir_expression *const r017C = equal(r017B, body.constant(0u));
      ir_if *f017A = new(mem_ctx) ir_if(operand(r017C).val);
      exec_list *const f017A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017A->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(4))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(4))), 0x01));


      body.instructions = f017A_parent_instructions;
      body.emit(f017A);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017E = bit_and(r016F, body.constant(3221225472u));
      ir_expression *const r017F = equal(r017E, body.constant(0u));
      ir_if *f017D = new(mem_ctx) ir_if(operand(r017F).val);
      exec_list *const f017D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017D->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(2))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(2))), 0x01));


      body.instructions = f017D_parent_instructions;
      body.emit(f017D);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0181 = bit_and(r016F, body.constant(2147483648u));
      ir_expression *const r0182 = equal(r0181, body.constant(0u));
      ir_if *f0180 = new(mem_ctx) ir_if(operand(r0182).val);
      exec_list *const f0180_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0180->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(1))), 0x01));


      body.instructions = f0180_parent_instructions;
      body.emit(f0180);

      /* END IF */

      body.emit(assign(r0170, r0171, 0x01));


   body.instructions = f0172_parent_instructions;
   body.emit(f0172);

   /* END IF */

   body.emit(ret(r0170));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeRoundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0183 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0183);
   ir_variable *const r0184 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0184);
   ir_variable *const r0185 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0185);
   ir_variable *const r0186 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0186);
   ir_variable *const r0187 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0187);
   ir_variable *const r0188 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0188);
   /* IF CONDITION */
   ir_expression *const r018A = equal(r0185, body.constant(0u));
   ir_if *f0189 = new(mem_ctx) ir_if(operand(r018A).val);
   exec_list *const f0189_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0189->then_instructions;

      body.emit(assign(r0185, r0186, 0x01));

      body.emit(assign(r0186, body.constant(0u), 0x01));

      body.emit(assign(r0184, add(r0184, body.constant(int(-32))), 0x01));


   body.instructions = f0189_parent_instructions;
   body.emit(f0189);

   /* END IF */

   ir_variable *const r018B = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r018B, r0185, 0x01));

   ir_variable *const r018C = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r018D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r018D);
   /* IF CONDITION */
   ir_expression *const r018F = equal(r0185, body.constant(0u));
   ir_if *f018E = new(mem_ctx) ir_if(operand(r018F).val);
   exec_list *const f018E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f018E->then_instructions;

      body.emit(assign(r018C, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f018E->else_instructions;

      body.emit(assign(r018D, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0191 = bit_and(r0185, body.constant(4294901760u));
      ir_expression *const r0192 = equal(r0191, body.constant(0u));
      ir_if *f0190 = new(mem_ctx) ir_if(operand(r0192).val);
      exec_list *const f0190_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0190->then_instructions;

         body.emit(assign(r018D, body.constant(int(16)), 0x01));

         body.emit(assign(r018B, lshift(r0185, body.constant(int(16))), 0x01));


      body.instructions = f0190_parent_instructions;
      body.emit(f0190);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0194 = bit_and(r018B, body.constant(4278190080u));
      ir_expression *const r0195 = equal(r0194, body.constant(0u));
      ir_if *f0193 = new(mem_ctx) ir_if(operand(r0195).val);
      exec_list *const f0193_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0193->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(8))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(8))), 0x01));


      body.instructions = f0193_parent_instructions;
      body.emit(f0193);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0197 = bit_and(r018B, body.constant(4026531840u));
      ir_expression *const r0198 = equal(r0197, body.constant(0u));
      ir_if *f0196 = new(mem_ctx) ir_if(operand(r0198).val);
      exec_list *const f0196_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0196->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(4))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(4))), 0x01));


      body.instructions = f0196_parent_instructions;
      body.emit(f0196);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019A = bit_and(r018B, body.constant(3221225472u));
      ir_expression *const r019B = equal(r019A, body.constant(0u));
      ir_if *f0199 = new(mem_ctx) ir_if(operand(r019B).val);
      exec_list *const f0199_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0199->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(2))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(2))), 0x01));


      body.instructions = f0199_parent_instructions;
      body.emit(f0199);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019D = bit_and(r018B, body.constant(2147483648u));
      ir_expression *const r019E = equal(r019D, body.constant(0u));
      ir_if *f019C = new(mem_ctx) ir_if(operand(r019E).val);
      exec_list *const f019C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f019C->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(1))), 0x01));


      body.instructions = f019C_parent_instructions;
      body.emit(f019C);

      /* END IF */

      body.emit(assign(r018C, r018D, 0x01));


   body.instructions = f018E_parent_instructions;
   body.emit(f018E);

   /* END IF */

   body.emit(assign(r0188, add(r018C, body.constant(int(-11))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01A0 = lequal(body.constant(int(0)), r0188);
   ir_if *f019F = new(mem_ctx) ir_if(operand(r01A0).val);
   exec_list *const f019F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f019F->then_instructions;

      body.emit(assign(r0187, body.constant(0u), 0x01));

      ir_variable *const r01A1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r01A1, lshift(r0186, r0188), 0x01));

      ir_variable *const r01A2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r01A4 = equal(r0188, body.constant(int(0)));
      ir_if *f01A3 = new(mem_ctx) ir_if(operand(r01A4).val);
      exec_list *const f01A3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01A3->then_instructions;

         body.emit(assign(r01A2, r0185, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01A3->else_instructions;

         ir_expression *const r01A5 = lshift(r0185, r0188);
         ir_expression *const r01A6 = neg(r0188);
         ir_expression *const r01A7 = bit_and(r01A6, body.constant(int(31)));
         ir_expression *const r01A8 = rshift(r0186, r01A7);
         body.emit(assign(r01A2, bit_or(r01A5, r01A8), 0x01));


      body.instructions = f01A3_parent_instructions;
      body.emit(f01A3);

      /* END IF */

      body.emit(assign(r0185, r01A2, 0x01));

      body.emit(assign(r0186, r01A1, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f019F->else_instructions;

      ir_variable *const r01A9 = body.make_temp(glsl_type::uint_type, "a2");
      body.emit(assign(r01A9, body.constant(0u), 0x01));

      ir_variable *const r01AA = body.make_temp(glsl_type::int_type, "count");
      body.emit(assign(r01AA, neg(r0188), 0x01));

      ir_variable *const r01AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
      body.emit(r01AB);
      ir_variable *const r01AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r01AC);
      ir_variable *const r01AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r01AD);
      ir_variable *const r01AE = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r01AF = neg(r01AA);
      body.emit(assign(r01AE, bit_and(r01AF, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r01B1 = equal(r01AA, body.constant(int(0)));
      ir_if *f01B0 = new(mem_ctx) ir_if(operand(r01B1).val);
      exec_list *const f01B0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01B0->then_instructions;

         body.emit(assign(r01AB, r01A9, 0x01));

         body.emit(assign(r01AC, r0186, 0x01));

         body.emit(assign(r01AD, r0185, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01B0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01B3 = less(r01AA, body.constant(int(32)));
         ir_if *f01B2 = new(mem_ctx) ir_if(operand(r01B3).val);
         exec_list *const f01B2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01B2->then_instructions;

            body.emit(assign(r01AB, lshift(r0186, r01AE), 0x01));

            ir_expression *const r01B4 = lshift(r0185, r01AE);
            ir_expression *const r01B5 = rshift(r0186, r01AA);
            body.emit(assign(r01AC, bit_or(r01B4, r01B5), 0x01));

            body.emit(assign(r01AD, rshift(r0185, r01AA), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01B2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r01B7 = equal(r01AA, body.constant(int(32)));
            ir_if *f01B6 = new(mem_ctx) ir_if(operand(r01B7).val);
            exec_list *const f01B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01B6->then_instructions;

               body.emit(assign(r01AB, r0186, 0x01));

               body.emit(assign(r01AC, r0185, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01B6->else_instructions;

               body.emit(assign(r01A9, bit_or(body.constant(0u), r0186), 0x01));

               /* IF CONDITION */
               ir_expression *const r01B9 = less(r01AA, body.constant(int(64)));
               ir_if *f01B8 = new(mem_ctx) ir_if(operand(r01B9).val);
               exec_list *const f01B8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01B8->then_instructions;

                  body.emit(assign(r01AB, lshift(r0185, r01AE), 0x01));

                  ir_expression *const r01BA = bit_and(r01AA, body.constant(int(31)));
                  body.emit(assign(r01AC, rshift(r0185, r01BA), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01B8->else_instructions;

                  ir_variable *const r01BB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r01BD = equal(r01AA, body.constant(int(64)));
                  ir_if *f01BC = new(mem_ctx) ir_if(operand(r01BD).val);
                  exec_list *const f01BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01BC->then_instructions;

                     body.emit(assign(r01BB, r0185, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01BC->else_instructions;

                     ir_expression *const r01BE = nequal(r0185, body.constant(0u));
                     ir_expression *const r01BF = expr(ir_unop_b2i, r01BE);
                     body.emit(assign(r01BB, expr(ir_unop_i2u, r01BF), 0x01));


                  body.instructions = f01BC_parent_instructions;
                  body.emit(f01BC);

                  /* END IF */

                  body.emit(assign(r01AB, r01BB, 0x01));

                  body.emit(assign(r01AC, body.constant(0u), 0x01));


               body.instructions = f01B8_parent_instructions;
               body.emit(f01B8);

               /* END IF */


            body.instructions = f01B6_parent_instructions;
            body.emit(f01B6);

            /* END IF */

            body.emit(assign(r01AD, body.constant(0u), 0x01));


         body.instructions = f01B2_parent_instructions;
         body.emit(f01B2);

         /* END IF */

         ir_expression *const r01C0 = nequal(r01A9, body.constant(0u));
         ir_expression *const r01C1 = expr(ir_unop_b2i, r01C0);
         ir_expression *const r01C2 = expr(ir_unop_i2u, r01C1);
         body.emit(assign(r01AB, bit_or(r01AB, r01C2), 0x01));


      body.instructions = f01B0_parent_instructions;
      body.emit(f01B0);

      /* END IF */

      body.emit(assign(r0185, r01AD, 0x01));

      body.emit(assign(r0186, r01AC, 0x01));

      body.emit(assign(r0187, r01AB, 0x01));


   body.instructions = f019F_parent_instructions;
   body.emit(f019F);

   /* END IF */

   body.emit(assign(r0184, sub(r0184, r0188), 0x01));

   ir_variable *const r01C3 = body.make_temp(glsl_type::int_type, "zExp");
   body.emit(assign(r01C3, r0184, 0x01));

   ir_variable *const r01C4 = body.make_temp(glsl_type::uint_type, "zFrac0");
   body.emit(assign(r01C4, r0185, 0x01));

   ir_variable *const r01C5 = body.make_temp(glsl_type::uint_type, "zFrac1");
   body.emit(assign(r01C5, r0186, 0x01));

   ir_variable *const r01C6 = body.make_temp(glsl_type::uint_type, "zFrac2");
   body.emit(assign(r01C6, r0187, 0x01));

   ir_variable *const r01C7 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r01C7, body.constant(true), 0x01));

   ir_variable *const r01C8 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r01C9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r01C9);
   ir_expression *const r01CA = expr(ir_unop_u2i, r0187);
   body.emit(assign(r01C9, less(r01CA, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01CC = lequal(body.constant(int(2045)), r0184);
   ir_if *f01CB = new(mem_ctx) ir_if(operand(r01CC).val);
   exec_list *const f01CB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01CB->then_instructions;

      ir_variable *const r01CD = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r01CF = less(body.constant(int(2045)), r0184);
      ir_if *f01CE = new(mem_ctx) ir_if(operand(r01CF).val);
      exec_list *const f01CE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01CE->then_instructions;

         body.emit(assign(r01CD, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01CE->else_instructions;

         ir_variable *const r01D0 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r01D2 = equal(r0184, body.constant(int(2045)));
         ir_if *f01D1 = new(mem_ctx) ir_if(operand(r01D2).val);
         exec_list *const f01D1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D1->then_instructions;

            ir_expression *const r01D3 = equal(body.constant(2097151u), r0185);
            ir_expression *const r01D4 = equal(body.constant(4294967295u), r0186);
            body.emit(assign(r01D0, logic_and(r01D3, r01D4), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01D1->else_instructions;

            body.emit(assign(r01D0, body.constant(false), 0x01));


         body.instructions = f01D1_parent_instructions;
         body.emit(f01D1);

         /* END IF */

         body.emit(assign(r01CD, logic_and(r01D0, r01C9), 0x01));


      body.instructions = f01CE_parent_instructions;
      body.emit(f01CE);

      /* END IF */

      /* IF CONDITION */
      ir_if *f01D5 = new(mem_ctx) ir_if(operand(r01CD).val);
      exec_list *const f01D5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01D5->then_instructions;

         ir_variable *const r01D6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r01D6);
         ir_expression *const r01D7 = lshift(r0183, body.constant(int(31)));
         body.emit(assign(r01D6, add(r01D7, body.constant(2146435072u)), 0x02));

         body.emit(assign(r01D6, body.constant(0u), 0x01));

         body.emit(assign(r01C8, r01D6, 0x03));

         body.emit(assign(r01C7, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01D5->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01D9 = less(r0184, body.constant(int(0)));
         ir_if *f01D8 = new(mem_ctx) ir_if(operand(r01D9).val);
         exec_list *const f01D8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D8->then_instructions;

            ir_variable *const r01DA = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r01DA, r0187, 0x01));

            ir_variable *const r01DB = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r01DB, neg(r0184), 0x01));

            ir_variable *const r01DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r01DC);
            ir_variable *const r01DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r01DD);
            ir_variable *const r01DE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r01DE);
            ir_variable *const r01DF = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r01E0 = neg(r01DB);
            body.emit(assign(r01DF, bit_and(r01E0, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r01E2 = equal(r01DB, body.constant(int(0)));
            ir_if *f01E1 = new(mem_ctx) ir_if(operand(r01E2).val);
            exec_list *const f01E1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01E1->then_instructions;

               body.emit(assign(r01DC, r0187, 0x01));

               body.emit(assign(r01DD, r0186, 0x01));

               body.emit(assign(r01DE, r0185, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01E1->else_instructions;

               /* IF CONDITION */
               ir_expression *const r01E4 = less(r01DB, body.constant(int(32)));
               ir_if *f01E3 = new(mem_ctx) ir_if(operand(r01E4).val);
               exec_list *const f01E3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01E3->then_instructions;

                  body.emit(assign(r01DC, lshift(r0186, r01DF), 0x01));

                  ir_expression *const r01E5 = lshift(r0185, r01DF);
                  ir_expression *const r01E6 = rshift(r0186, r01DB);
                  body.emit(assign(r01DD, bit_or(r01E5, r01E6), 0x01));

                  body.emit(assign(r01DE, rshift(r0185, r01DB), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01E3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r01E8 = equal(r01DB, body.constant(int(32)));
                  ir_if *f01E7 = new(mem_ctx) ir_if(operand(r01E8).val);
                  exec_list *const f01E7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01E7->then_instructions;

                     body.emit(assign(r01DC, r0186, 0x01));

                     body.emit(assign(r01DD, r0185, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01E7->else_instructions;

                     body.emit(assign(r01DA, bit_or(r0187, r0186), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r01EA = less(r01DB, body.constant(int(64)));
                     ir_if *f01E9 = new(mem_ctx) ir_if(operand(r01EA).val);
                     exec_list *const f01E9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f01E9->then_instructions;

                        body.emit(assign(r01DC, lshift(r0185, r01DF), 0x01));

                        ir_expression *const r01EB = bit_and(r01DB, body.constant(int(31)));
                        body.emit(assign(r01DD, rshift(r0185, r01EB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f01E9->else_instructions;

                        ir_variable *const r01EC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r01EE = equal(r01DB, body.constant(int(64)));
                        ir_if *f01ED = new(mem_ctx) ir_if(operand(r01EE).val);
                        exec_list *const f01ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f01ED->then_instructions;

                           body.emit(assign(r01EC, r0185, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f01ED->else_instructions;

                           ir_expression *const r01EF = nequal(r0185, body.constant(0u));
                           ir_expression *const r01F0 = expr(ir_unop_b2i, r01EF);
                           body.emit(assign(r01EC, expr(ir_unop_i2u, r01F0), 0x01));


                        body.instructions = f01ED_parent_instructions;
                        body.emit(f01ED);

                        /* END IF */

                        body.emit(assign(r01DC, r01EC, 0x01));

                        body.emit(assign(r01DD, body.constant(0u), 0x01));


                     body.instructions = f01E9_parent_instructions;
                     body.emit(f01E9);

                     /* END IF */


                  body.instructions = f01E7_parent_instructions;
                  body.emit(f01E7);

                  /* END IF */

                  body.emit(assign(r01DE, body.constant(0u), 0x01));


               body.instructions = f01E3_parent_instructions;
               body.emit(f01E3);

               /* END IF */

               ir_expression *const r01F1 = nequal(r01DA, body.constant(0u));
               ir_expression *const r01F2 = expr(ir_unop_b2i, r01F1);
               ir_expression *const r01F3 = expr(ir_unop_i2u, r01F2);
               body.emit(assign(r01DC, bit_or(r01DC, r01F3), 0x01));


            body.instructions = f01E1_parent_instructions;
            body.emit(f01E1);

            /* END IF */

            body.emit(assign(r01C4, r01DE, 0x01));

            body.emit(assign(r01C5, r01DD, 0x01));

            body.emit(assign(r01C6, r01DC, 0x01));

            body.emit(assign(r01C3, body.constant(int(0)), 0x01));

            body.emit(assign(r01C9, less(r01DC, body.constant(0u)), 0x01));


         body.instructions = f01D8_parent_instructions;
         body.emit(f01D8);

         /* END IF */


      body.instructions = f01D5_parent_instructions;
      body.emit(f01D5);

      /* END IF */


   body.instructions = f01CB_parent_instructions;
   body.emit(f01CB);

   /* END IF */

   /* IF CONDITION */
   ir_if *f01F4 = new(mem_ctx) ir_if(operand(r01C7).val);
   exec_list *const f01F4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01F4->then_instructions;

      /* IF CONDITION */
      ir_if *f01F5 = new(mem_ctx) ir_if(operand(r01C9).val);
      exec_list *const f01F5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01F5->then_instructions;

         ir_variable *const r01F6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r01F6, add(r01C5, body.constant(1u)), 0x01));

         ir_expression *const r01F7 = less(r01F6, r01C5);
         ir_expression *const r01F8 = expr(ir_unop_b2i, r01F7);
         ir_expression *const r01F9 = expr(ir_unop_i2u, r01F8);
         body.emit(assign(r01C4, add(r01C4, r01F9), 0x01));

         ir_expression *const r01FA = equal(r01C6, body.constant(0u));
         ir_expression *const r01FB = expr(ir_unop_b2i, r01FA);
         ir_expression *const r01FC = expr(ir_unop_i2u, r01FB);
         ir_expression *const r01FD = add(r01C6, r01FC);
         ir_expression *const r01FE = bit_and(r01FD, body.constant(1u));
         ir_expression *const r01FF = expr(ir_unop_bit_not, r01FE);
         body.emit(assign(r01C5, bit_and(r01F6, r01FF), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01F5->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0201 = bit_or(r01C4, r01C5);
         ir_expression *const r0202 = equal(r0201, body.constant(0u));
         ir_if *f0200 = new(mem_ctx) ir_if(operand(r0202).val);
         exec_list *const f0200_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0200->then_instructions;

            body.emit(assign(r01C3, body.constant(int(0)), 0x01));


         body.instructions = f0200_parent_instructions;
         body.emit(f0200);

         /* END IF */


      body.instructions = f01F5_parent_instructions;
      body.emit(f01F5);

      /* END IF */

      ir_variable *const r0203 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r0203);
      ir_expression *const r0204 = lshift(r0183, body.constant(int(31)));
      ir_expression *const r0205 = expr(ir_unop_i2u, r01C3);
      ir_expression *const r0206 = lshift(r0205, body.constant(int(20)));
      ir_expression *const r0207 = add(r0204, r0206);
      body.emit(assign(r0203, add(r0207, r01C4), 0x02));

      body.emit(assign(r0203, r01C5, 0x01));

      body.emit(assign(r01C8, r0203, 0x03));

      body.emit(assign(r01C7, body.constant(false), 0x01));


   body.instructions = f01F4_parent_instructions;
   body.emit(f01F4);

   /* END IF */

   body.emit(ret(r01C8));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
propagateFloat64NaN(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0208 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0208);
   ir_variable *const r0209 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0209);
   ir_variable *const r020A = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r020B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r020C = lshift(swizzle_y(r0208), body.constant(int(1)));
   ir_expression *const r020D = lequal(body.constant(4292870144u), r020C);
   ir_expression *const r020E = nequal(swizzle_x(r0208), body.constant(0u));
   ir_expression *const r020F = bit_and(swizzle_y(r0208), body.constant(1048575u));
   ir_expression *const r0210 = nequal(r020F, body.constant(0u));
   ir_expression *const r0211 = logic_or(r020E, r0210);
   body.emit(assign(r020B, logic_and(r020D, r0211), 0x01));

   ir_variable *const r0212 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
   ir_expression *const r0213 = rshift(swizzle_y(r0208), body.constant(int(19)));
   ir_expression *const r0214 = bit_and(r0213, body.constant(4095u));
   ir_expression *const r0215 = equal(r0214, body.constant(4094u));
   ir_expression *const r0216 = nequal(swizzle_x(r0208), body.constant(0u));
   ir_expression *const r0217 = bit_and(swizzle_y(r0208), body.constant(524287u));
   ir_expression *const r0218 = nequal(r0217, body.constant(0u));
   ir_expression *const r0219 = logic_or(r0216, r0218);
   body.emit(assign(r0212, logic_and(r0215, r0219), 0x01));

   ir_variable *const r021A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r021B = lshift(swizzle_y(r0209), body.constant(int(1)));
   ir_expression *const r021C = lequal(body.constant(4292870144u), r021B);
   ir_expression *const r021D = nequal(swizzle_x(r0209), body.constant(0u));
   ir_expression *const r021E = bit_and(swizzle_y(r0209), body.constant(1048575u));
   ir_expression *const r021F = nequal(r021E, body.constant(0u));
   ir_expression *const r0220 = logic_or(r021D, r021F);
   body.emit(assign(r021A, logic_and(r021C, r0220), 0x01));

   body.emit(assign(r0208, bit_or(swizzle_y(r0208), body.constant(524288u)), 0x02));

   body.emit(assign(r0209, bit_or(swizzle_y(r0209), body.constant(524288u)), 0x02));

   /* IF CONDITION */
   ir_if *f0221 = new(mem_ctx) ir_if(operand(r020B).val);
   exec_list *const f0221_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0221->then_instructions;

      ir_variable *const r0222 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r0224 = logic_and(r0212, r021A);
      ir_if *f0223 = new(mem_ctx) ir_if(operand(r0224).val);
      exec_list *const f0223_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0223->then_instructions;

         body.emit(assign(r0222, r0209, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0223->else_instructions;

         body.emit(assign(r0222, r0208, 0x03));


      body.instructions = f0223_parent_instructions;
      body.emit(f0223);

      /* END IF */

      body.emit(assign(r020A, r0222, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0221->else_instructions;

      body.emit(assign(r020A, r0209, 0x03));


   body.instructions = f0221_parent_instructions;
   body.emit(f0221);

   /* END IF */

   body.emit(ret(r020A));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
addFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0225 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0225);
   ir_variable *const r0226 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0226);
   ir_variable *const r0227 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0227);
   ir_variable *const r0228 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r0228, body.constant(true), 0x01));

   ir_variable *const r0229 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r022A = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r022A);
   ir_variable *const r022B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r022B);
   ir_variable *const r022C = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r022C);
   ir_variable *const r022D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r022D);
   ir_variable *const r022E = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r022E);
   ir_variable *const r022F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r022F);
   ir_variable *const r0230 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0230);
   ir_variable *const r0231 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r0231);
   body.emit(assign(r0231, body.constant(0u), 0x01));

   body.emit(assign(r0230, body.constant(0u), 0x01));

   ir_variable *const r0232 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0232, swizzle_x(r0225), 0x01));

   body.emit(assign(r022E, r0232, 0x01));

   ir_variable *const r0233 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0233, bit_and(swizzle_y(r0225), body.constant(1048575u)), 0x01));

   body.emit(assign(r022D, r0233, 0x01));

   ir_variable *const r0234 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0234, swizzle_x(r0226), 0x01));

   body.emit(assign(r022C, r0234, 0x01));

   ir_variable *const r0235 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0235, bit_and(swizzle_y(r0226), body.constant(1048575u)), 0x01));

   body.emit(assign(r022B, r0235, 0x01));

   ir_variable *const r0236 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0237 = rshift(swizzle_y(r0225), body.constant(int(20)));
   ir_expression *const r0238 = bit_and(r0237, body.constant(2047u));
   body.emit(assign(r0236, expr(ir_unop_u2i, r0238), 0x01));

   ir_variable *const r0239 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r023A = rshift(swizzle_y(r0226), body.constant(int(20)));
   ir_expression *const r023B = bit_and(r023A, body.constant(2047u));
   body.emit(assign(r0239, expr(ir_unop_u2i, r023B), 0x01));

   ir_variable *const r023C = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r023C, sub(r0236, r0239), 0x01));

   body.emit(assign(r022A, r023C, 0x01));

   /* IF CONDITION */
   ir_expression *const r023E = less(body.constant(int(0)), r023C);
   ir_if *f023D = new(mem_ctx) ir_if(operand(r023E).val);
   exec_list *const f023D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f023D->then_instructions;

      /* IF CONDITION */
      ir_expression *const r0240 = equal(r0236, body.constant(int(2047)));
      ir_if *f023F = new(mem_ctx) ir_if(operand(r0240).val);
      exec_list *const f023F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f023F->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0242 = bit_or(r0233, swizzle_x(r0225));
         ir_expression *const r0243 = nequal(r0242, body.constant(0u));
         ir_if *f0241 = new(mem_ctx) ir_if(operand(r0243).val);
         exec_list *const f0241_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0241->then_instructions;

            ir_variable *const r0244 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r0244, swizzle_x(r0225), 0x01));

            ir_variable *const r0245 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r0245, swizzle_x(r0226), 0x01));

            ir_variable *const r0246 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0247 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r0248 = rshift(swizzle_y(r0225), body.constant(int(19)));
            ir_expression *const r0249 = bit_and(r0248, body.constant(4095u));
            ir_expression *const r024A = equal(r0249, body.constant(4094u));
            ir_expression *const r024B = nequal(swizzle_x(r0225), body.constant(0u));
            ir_expression *const r024C = bit_and(swizzle_y(r0225), body.constant(524287u));
            ir_expression *const r024D = nequal(r024C, body.constant(0u));
            ir_expression *const r024E = logic_or(r024B, r024D);
            body.emit(assign(r0247, logic_and(r024A, r024E), 0x01));

            ir_variable *const r024F = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0250 = lshift(swizzle_y(r0226), body.constant(int(1)));
            ir_expression *const r0251 = lequal(body.constant(4292870144u), r0250);
            ir_expression *const r0252 = nequal(swizzle_x(r0226), body.constant(0u));
            ir_expression *const r0253 = bit_and(swizzle_y(r0226), body.constant(1048575u));
            ir_expression *const r0254 = nequal(r0253, body.constant(0u));
            ir_expression *const r0255 = logic_or(r0252, r0254);
            body.emit(assign(r024F, logic_and(r0251, r0255), 0x01));

            body.emit(assign(r0244, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

            body.emit(assign(r0245, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0257 = lshift(swizzle_y(r0225), body.constant(int(1)));
            ir_expression *const r0258 = lequal(body.constant(4292870144u), r0257);
            ir_expression *const r0259 = nequal(swizzle_x(r0225), body.constant(0u));
            ir_expression *const r025A = bit_and(swizzle_y(r0225), body.constant(1048575u));
            ir_expression *const r025B = nequal(r025A, body.constant(0u));
            ir_expression *const r025C = logic_or(r0259, r025B);
            ir_expression *const r025D = logic_and(r0258, r025C);
            ir_if *f0256 = new(mem_ctx) ir_if(operand(r025D).val);
            exec_list *const f0256_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0256->then_instructions;

               ir_variable *const r025E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0260 = logic_and(r0247, r024F);
               ir_if *f025F = new(mem_ctx) ir_if(operand(r0260).val);
               exec_list *const f025F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f025F->then_instructions;

                  body.emit(assign(r025E, r0245, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f025F->else_instructions;

                  body.emit(assign(r025E, r0244, 0x03));


               body.instructions = f025F_parent_instructions;
               body.emit(f025F);

               /* END IF */

               body.emit(assign(r0246, r025E, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0256->else_instructions;

               body.emit(assign(r0246, r0245, 0x03));


            body.instructions = f0256_parent_instructions;
            body.emit(f0256);

            /* END IF */

            body.emit(assign(r0229, r0246, 0x03));

            body.emit(assign(r0228, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0241->else_instructions;

            body.emit(assign(r0229, r0225, 0x03));

            body.emit(assign(r0228, body.constant(false), 0x01));


         body.instructions = f0241_parent_instructions;
         body.emit(f0241);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f023F->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0262 = equal(r0239, body.constant(int(0)));
         ir_if *f0261 = new(mem_ctx) ir_if(operand(r0262).val);
         exec_list *const f0261_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0261->then_instructions;

            body.emit(assign(r022A, add(r023C, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0261->else_instructions;

            body.emit(assign(r022B, bit_or(r0235, body.constant(1048576u)), 0x01));


         body.instructions = f0261_parent_instructions;
         body.emit(f0261);

         /* END IF */

         ir_variable *const r0263 = body.make_temp(glsl_type::uint_type, "a2");
         body.emit(assign(r0263, body.constant(0u), 0x01));

         ir_variable *const r0264 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0264);
         ir_variable *const r0265 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0265);
         ir_variable *const r0266 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0266);
         ir_variable *const r0267 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0268 = neg(r022A);
         body.emit(assign(r0267, bit_and(r0268, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r026A = equal(r022A, body.constant(int(0)));
         ir_if *f0269 = new(mem_ctx) ir_if(operand(r026A).val);
         exec_list *const f0269_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0269->then_instructions;

            body.emit(assign(r0264, r0263, 0x01));

            body.emit(assign(r0265, r0234, 0x01));

            body.emit(assign(r0266, r022B, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0269->else_instructions;

            /* IF CONDITION */
            ir_expression *const r026C = less(r022A, body.constant(int(32)));
            ir_if *f026B = new(mem_ctx) ir_if(operand(r026C).val);
            exec_list *const f026B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f026B->then_instructions;

               body.emit(assign(r0264, lshift(swizzle_x(r0226), r0267), 0x01));

               ir_expression *const r026D = lshift(r022B, r0267);
               ir_expression *const r026E = rshift(swizzle_x(r0226), r022A);
               body.emit(assign(r0265, bit_or(r026D, r026E), 0x01));

               body.emit(assign(r0266, rshift(r022B, r022A), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f026B->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0270 = equal(r022A, body.constant(int(32)));
               ir_if *f026F = new(mem_ctx) ir_if(operand(r0270).val);
               exec_list *const f026F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f026F->then_instructions;

                  body.emit(assign(r0264, r0234, 0x01));

                  body.emit(assign(r0265, r022B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f026F->else_instructions;

                  body.emit(assign(r0263, bit_or(body.constant(0u), swizzle_x(r0226)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0272 = less(r022A, body.constant(int(64)));
                  ir_if *f0271 = new(mem_ctx) ir_if(operand(r0272).val);
                  exec_list *const f0271_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0271->then_instructions;

                     body.emit(assign(r0264, lshift(r022B, r0267), 0x01));

                     ir_expression *const r0273 = bit_and(r022A, body.constant(int(31)));
                     body.emit(assign(r0265, rshift(r022B, r0273), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0271->else_instructions;

                     ir_variable *const r0274 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0276 = equal(r022A, body.constant(int(64)));
                     ir_if *f0275 = new(mem_ctx) ir_if(operand(r0276).val);
                     exec_list *const f0275_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0275->then_instructions;

                        body.emit(assign(r0274, r022B, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0275->else_instructions;

                        ir_expression *const r0277 = nequal(r022B, body.constant(0u));
                        ir_expression *const r0278 = expr(ir_unop_b2i, r0277);
                        body.emit(assign(r0274, expr(ir_unop_i2u, r0278), 0x01));


                     body.instructions = f0275_parent_instructions;
                     body.emit(f0275);

                     /* END IF */

                     body.emit(assign(r0264, r0274, 0x01));

                     body.emit(assign(r0265, body.constant(0u), 0x01));


                  body.instructions = f0271_parent_instructions;
                  body.emit(f0271);

                  /* END IF */


               body.instructions = f026F_parent_instructions;
               body.emit(f026F);

               /* END IF */

               body.emit(assign(r0266, body.constant(0u), 0x01));


            body.instructions = f026B_parent_instructions;
            body.emit(f026B);

            /* END IF */

            ir_expression *const r0279 = nequal(r0263, body.constant(0u));
            ir_expression *const r027A = expr(ir_unop_b2i, r0279);
            ir_expression *const r027B = expr(ir_unop_i2u, r027A);
            body.emit(assign(r0264, bit_or(r0264, r027B), 0x01));


         body.instructions = f0269_parent_instructions;
         body.emit(f0269);

         /* END IF */

         body.emit(assign(r022B, r0266, 0x01));

         body.emit(assign(r022C, r0265, 0x01));

         body.emit(assign(r0230, r0264, 0x01));

         body.emit(assign(r022F, r0236, 0x01));


      body.instructions = f023F_parent_instructions;
      body.emit(f023F);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f023D->else_instructions;

      /* IF CONDITION */
      ir_expression *const r027D = less(r022A, body.constant(int(0)));
      ir_if *f027C = new(mem_ctx) ir_if(operand(r027D).val);
      exec_list *const f027C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f027C->then_instructions;

         /* IF CONDITION */
         ir_expression *const r027F = equal(r0239, body.constant(int(2047)));
         ir_if *f027E = new(mem_ctx) ir_if(operand(r027F).val);
         exec_list *const f027E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f027E->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0281 = bit_or(r022B, r022C);
            ir_expression *const r0282 = nequal(r0281, body.constant(0u));
            ir_if *f0280 = new(mem_ctx) ir_if(operand(r0282).val);
            exec_list *const f0280_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0280->then_instructions;

               ir_variable *const r0283 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0283, swizzle_x(r0225), 0x01));

               ir_variable *const r0284 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0284, swizzle_x(r0226), 0x01));

               ir_variable *const r0285 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0286 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0287 = rshift(swizzle_y(r0225), body.constant(int(19)));
               ir_expression *const r0288 = bit_and(r0287, body.constant(4095u));
               ir_expression *const r0289 = equal(r0288, body.constant(4094u));
               ir_expression *const r028A = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r028B = bit_and(swizzle_y(r0225), body.constant(524287u));
               ir_expression *const r028C = nequal(r028B, body.constant(0u));
               ir_expression *const r028D = logic_or(r028A, r028C);
               body.emit(assign(r0286, logic_and(r0289, r028D), 0x01));

               ir_variable *const r028E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r028F = lshift(swizzle_y(r0226), body.constant(int(1)));
               ir_expression *const r0290 = lequal(body.constant(4292870144u), r028F);
               ir_expression *const r0291 = nequal(swizzle_x(r0226), body.constant(0u));
               ir_expression *const r0292 = bit_and(swizzle_y(r0226), body.constant(1048575u));
               ir_expression *const r0293 = nequal(r0292, body.constant(0u));
               ir_expression *const r0294 = logic_or(r0291, r0293);
               body.emit(assign(r028E, logic_and(r0290, r0294), 0x01));

               body.emit(assign(r0283, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

               body.emit(assign(r0284, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0296 = lshift(swizzle_y(r0225), body.constant(int(1)));
               ir_expression *const r0297 = lequal(body.constant(4292870144u), r0296);
               ir_expression *const r0298 = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r0299 = bit_and(swizzle_y(r0225), body.constant(1048575u));
               ir_expression *const r029A = nequal(r0299, body.constant(0u));
               ir_expression *const r029B = logic_or(r0298, r029A);
               ir_expression *const r029C = logic_and(r0297, r029B);
               ir_if *f0295 = new(mem_ctx) ir_if(operand(r029C).val);
               exec_list *const f0295_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0295->then_instructions;

                  ir_variable *const r029D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r029F = logic_and(r0286, r028E);
                  ir_if *f029E = new(mem_ctx) ir_if(operand(r029F).val);
                  exec_list *const f029E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f029E->then_instructions;

                     body.emit(assign(r029D, r0284, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f029E->else_instructions;

                     body.emit(assign(r029D, r0283, 0x03));


                  body.instructions = f029E_parent_instructions;
                  body.emit(f029E);

                  /* END IF */

                  body.emit(assign(r0285, r029D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0295->else_instructions;

                  body.emit(assign(r0285, r0284, 0x03));


               body.instructions = f0295_parent_instructions;
               body.emit(f0295);

               /* END IF */

               body.emit(assign(r0229, r0285, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0280->else_instructions;

               ir_variable *const r02A0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02A0);
               ir_expression *const r02A1 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r02A0, add(r02A1, body.constant(2146435072u)), 0x02));

               body.emit(assign(r02A0, body.constant(0u), 0x01));

               body.emit(assign(r0229, r02A0, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f0280_parent_instructions;
            body.emit(f0280);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f027E->else_instructions;

            /* IF CONDITION */
            ir_expression *const r02A3 = equal(r0236, body.constant(int(0)));
            ir_if *f02A2 = new(mem_ctx) ir_if(operand(r02A3).val);
            exec_list *const f02A2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02A2->then_instructions;

               body.emit(assign(r022A, add(r022A, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02A2->else_instructions;

               body.emit(assign(r022D, bit_or(r0233, body.constant(1048576u)), 0x01));


            body.instructions = f02A2_parent_instructions;
            body.emit(f02A2);

            /* END IF */

            ir_variable *const r02A4 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r02A4, body.constant(0u), 0x01));

            ir_variable *const r02A5 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r02A5, neg(r022A), 0x01));

            ir_variable *const r02A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r02A6);
            ir_variable *const r02A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r02A7);
            ir_variable *const r02A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r02A8);
            ir_variable *const r02A9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r02AA = neg(r02A5);
            body.emit(assign(r02A9, bit_and(r02AA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r02AC = equal(r02A5, body.constant(int(0)));
            ir_if *f02AB = new(mem_ctx) ir_if(operand(r02AC).val);
            exec_list *const f02AB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02AB->then_instructions;

               body.emit(assign(r02A6, r02A4, 0x01));

               body.emit(assign(r02A7, r0232, 0x01));

               body.emit(assign(r02A8, r022D, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02AB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r02AE = less(r02A5, body.constant(int(32)));
               ir_if *f02AD = new(mem_ctx) ir_if(operand(r02AE).val);
               exec_list *const f02AD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02AD->then_instructions;

                  body.emit(assign(r02A6, lshift(swizzle_x(r0225), r02A9), 0x01));

                  ir_expression *const r02AF = lshift(r022D, r02A9);
                  ir_expression *const r02B0 = rshift(swizzle_x(r0225), r02A5);
                  body.emit(assign(r02A7, bit_or(r02AF, r02B0), 0x01));

                  body.emit(assign(r02A8, rshift(r022D, r02A5), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02AD->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r02B2 = equal(r02A5, body.constant(int(32)));
                  ir_if *f02B1 = new(mem_ctx) ir_if(operand(r02B2).val);
                  exec_list *const f02B1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02B1->then_instructions;

                     body.emit(assign(r02A6, r0232, 0x01));

                     body.emit(assign(r02A7, r022D, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02B1->else_instructions;

                     body.emit(assign(r02A4, bit_or(body.constant(0u), swizzle_x(r0225)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r02B4 = less(r02A5, body.constant(int(64)));
                     ir_if *f02B3 = new(mem_ctx) ir_if(operand(r02B4).val);
                     exec_list *const f02B3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02B3->then_instructions;

                        body.emit(assign(r02A6, lshift(r022D, r02A9), 0x01));

                        ir_expression *const r02B5 = bit_and(r02A5, body.constant(int(31)));
                        body.emit(assign(r02A7, rshift(r022D, r02B5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02B3->else_instructions;

                        ir_variable *const r02B6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r02B8 = equal(r02A5, body.constant(int(64)));
                        ir_if *f02B7 = new(mem_ctx) ir_if(operand(r02B8).val);
                        exec_list *const f02B7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f02B7->then_instructions;

                           body.emit(assign(r02B6, r022D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f02B7->else_instructions;

                           ir_expression *const r02B9 = nequal(r022D, body.constant(0u));
                           ir_expression *const r02BA = expr(ir_unop_b2i, r02B9);
                           body.emit(assign(r02B6, expr(ir_unop_i2u, r02BA), 0x01));


                        body.instructions = f02B7_parent_instructions;
                        body.emit(f02B7);

                        /* END IF */

                        body.emit(assign(r02A6, r02B6, 0x01));

                        body.emit(assign(r02A7, body.constant(0u), 0x01));


                     body.instructions = f02B3_parent_instructions;
                     body.emit(f02B3);

                     /* END IF */


                  body.instructions = f02B1_parent_instructions;
                  body.emit(f02B1);

                  /* END IF */

                  body.emit(assign(r02A8, body.constant(0u), 0x01));


               body.instructions = f02AD_parent_instructions;
               body.emit(f02AD);

               /* END IF */

               ir_expression *const r02BB = nequal(r02A4, body.constant(0u));
               ir_expression *const r02BC = expr(ir_unop_b2i, r02BB);
               ir_expression *const r02BD = expr(ir_unop_i2u, r02BC);
               body.emit(assign(r02A6, bit_or(r02A6, r02BD), 0x01));


            body.instructions = f02AB_parent_instructions;
            body.emit(f02AB);

            /* END IF */

            body.emit(assign(r022D, r02A8, 0x01));

            body.emit(assign(r022E, r02A7, 0x01));

            body.emit(assign(r0230, r02A6, 0x01));

            body.emit(assign(r022F, r0239, 0x01));


         body.instructions = f027E_parent_instructions;
         body.emit(f027E);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f027C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r02BF = equal(r0236, body.constant(int(2047)));
         ir_if *f02BE = new(mem_ctx) ir_if(operand(r02BF).val);
         exec_list *const f02BE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f02BE->then_instructions;

            /* IF CONDITION */
            ir_expression *const r02C1 = bit_or(r022D, r022E);
            ir_expression *const r02C2 = bit_or(r022B, r022C);
            ir_expression *const r02C3 = bit_or(r02C1, r02C2);
            ir_expression *const r02C4 = nequal(r02C3, body.constant(0u));
            ir_if *f02C0 = new(mem_ctx) ir_if(operand(r02C4).val);
            exec_list *const f02C0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02C0->then_instructions;

               ir_variable *const r02C5 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r02C5, swizzle_x(r0225), 0x01));

               ir_variable *const r02C6 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r02C6, swizzle_x(r0226), 0x01));

               ir_variable *const r02C7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02C8 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r02C9 = rshift(swizzle_y(r0225), body.constant(int(19)));
               ir_expression *const r02CA = bit_and(r02C9, body.constant(4095u));
               ir_expression *const r02CB = equal(r02CA, body.constant(4094u));
               ir_expression *const r02CC = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r02CD = bit_and(swizzle_y(r0225), body.constant(524287u));
               ir_expression *const r02CE = nequal(r02CD, body.constant(0u));
               ir_expression *const r02CF = logic_or(r02CC, r02CE);
               body.emit(assign(r02C8, logic_and(r02CB, r02CF), 0x01));

               ir_variable *const r02D0 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r02D1 = lshift(swizzle_y(r0226), body.constant(int(1)));
               ir_expression *const r02D2 = lequal(body.constant(4292870144u), r02D1);
               ir_expression *const r02D3 = nequal(swizzle_x(r0226), body.constant(0u));
               ir_expression *const r02D4 = bit_and(swizzle_y(r0226), body.constant(1048575u));
               ir_expression *const r02D5 = nequal(r02D4, body.constant(0u));
               ir_expression *const r02D6 = logic_or(r02D3, r02D5);
               body.emit(assign(r02D0, logic_and(r02D2, r02D6), 0x01));

               body.emit(assign(r02C5, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

               body.emit(assign(r02C6, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r02D8 = lshift(swizzle_y(r0225), body.constant(int(1)));
               ir_expression *const r02D9 = lequal(body.constant(4292870144u), r02D8);
               ir_expression *const r02DA = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r02DB = bit_and(swizzle_y(r0225), body.constant(1048575u));
               ir_expression *const r02DC = nequal(r02DB, body.constant(0u));
               ir_expression *const r02DD = logic_or(r02DA, r02DC);
               ir_expression *const r02DE = logic_and(r02D9, r02DD);
               ir_if *f02D7 = new(mem_ctx) ir_if(operand(r02DE).val);
               exec_list *const f02D7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02D7->then_instructions;

                  ir_variable *const r02DF = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02E1 = logic_and(r02C8, r02D0);
                  ir_if *f02E0 = new(mem_ctx) ir_if(operand(r02E1).val);
                  exec_list *const f02E0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02E0->then_instructions;

                     body.emit(assign(r02DF, r02C6, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02E0->else_instructions;

                     body.emit(assign(r02DF, r02C5, 0x03));


                  body.instructions = f02E0_parent_instructions;
                  body.emit(f02E0);

                  /* END IF */

                  body.emit(assign(r02C7, r02DF, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02D7->else_instructions;

                  body.emit(assign(r02C7, r02C6, 0x03));


               body.instructions = f02D7_parent_instructions;
               body.emit(f02D7);

               /* END IF */

               body.emit(assign(r0229, r02C7, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02C0->else_instructions;

               body.emit(assign(r0229, r0225, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f02C0_parent_instructions;
            body.emit(f02C0);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f02BE->else_instructions;

            ir_variable *const r02E2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r02E3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r02E3, add(r022E, r022C), 0x01));

            ir_expression *const r02E4 = add(r022D, r022B);
            ir_expression *const r02E5 = less(r02E3, r022E);
            ir_expression *const r02E6 = expr(ir_unop_b2i, r02E5);
            ir_expression *const r02E7 = expr(ir_unop_i2u, r02E6);
            body.emit(assign(r02E2, add(r02E4, r02E7), 0x01));

            body.emit(assign(r0231, r02E2, 0x01));

            /* IF CONDITION */
            ir_expression *const r02E9 = equal(r0236, body.constant(int(0)));
            ir_if *f02E8 = new(mem_ctx) ir_if(operand(r02E9).val);
            exec_list *const f02E8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02E8->then_instructions;

               ir_variable *const r02EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02EA);
               ir_expression *const r02EB = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r02EA, add(r02EB, r02E2), 0x02));

               body.emit(assign(r02EA, r02E3, 0x01));

               body.emit(assign(r0229, r02EA, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02E8->else_instructions;

               body.emit(assign(r0231, bit_or(r02E2, body.constant(2097152u)), 0x01));

               body.emit(assign(r022F, r0236, 0x01));

               ir_variable *const r02EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r02EC);
               ir_variable *const r02ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r02ED);
               ir_variable *const r02EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r02EE);
               body.emit(assign(r02EC, lshift(r02E3, body.constant(int(31))), 0x01));

               ir_expression *const r02EF = lshift(r0231, body.constant(int(31)));
               ir_expression *const r02F0 = rshift(r02E3, body.constant(int(1)));
               body.emit(assign(r02ED, bit_or(r02EF, r02F0), 0x01));

               body.emit(assign(r02EE, rshift(r0231, body.constant(int(1))), 0x01));

               body.emit(assign(r02EC, bit_or(r02EC, body.constant(0u)), 0x01));

               body.emit(assign(r0231, r02EE, 0x01));

               body.emit(assign(r0230, r02EC, 0x01));

               ir_variable *const r02F1 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r02F1, r0236, 0x01));

               ir_variable *const r02F2 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r02F2, r02EE, 0x01));

               ir_variable *const r02F3 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r02F3, r02ED, 0x01));

               ir_variable *const r02F4 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r02F4, r02EC, 0x01));

               ir_variable *const r02F5 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r02F5, body.constant(true), 0x01));

               ir_variable *const r02F6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02F7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r02F7);
               ir_expression *const r02F8 = expr(ir_unop_u2i, r02EC);
               body.emit(assign(r02F7, less(r02F8, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r02FA = lequal(body.constant(int(2045)), r0236);
               ir_if *f02F9 = new(mem_ctx) ir_if(operand(r02FA).val);
               exec_list *const f02F9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02F9->then_instructions;

                  ir_variable *const r02FB = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02FD = less(body.constant(int(2045)), r0236);
                  ir_if *f02FC = new(mem_ctx) ir_if(operand(r02FD).val);
                  exec_list *const f02FC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02FC->then_instructions;

                     body.emit(assign(r02FB, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02FC->else_instructions;

                     ir_variable *const r02FE = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0300 = equal(r0236, body.constant(int(2045)));
                     ir_if *f02FF = new(mem_ctx) ir_if(operand(r0300).val);
                     exec_list *const f02FF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02FF->then_instructions;

                        ir_expression *const r0301 = equal(body.constant(2097151u), r02EE);
                        ir_expression *const r0302 = equal(body.constant(4294967295u), r02ED);
                        body.emit(assign(r02FE, logic_and(r0301, r0302), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02FF->else_instructions;

                        body.emit(assign(r02FE, body.constant(false), 0x01));


                     body.instructions = f02FF_parent_instructions;
                     body.emit(f02FF);

                     /* END IF */

                     body.emit(assign(r02FB, logic_and(r02FE, r02F7), 0x01));


                  body.instructions = f02FC_parent_instructions;
                  body.emit(f02FC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0303 = new(mem_ctx) ir_if(operand(r02FB).val);
                  exec_list *const f0303_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0303->then_instructions;

                     ir_variable *const r0304 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0304);
                     ir_expression *const r0305 = lshift(r0227, body.constant(int(31)));
                     body.emit(assign(r0304, add(r0305, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0304, body.constant(0u), 0x01));

                     body.emit(assign(r02F6, r0304, 0x03));

                     body.emit(assign(r02F5, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0303->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0307 = less(r0236, body.constant(int(0)));
                     ir_if *f0306 = new(mem_ctx) ir_if(operand(r0307).val);
                     exec_list *const f0306_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0306->then_instructions;

                        ir_variable *const r0308 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0308, r02EC, 0x01));

                        ir_variable *const r0309 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0309, neg(r0236), 0x01));

                        ir_variable *const r030A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r030A);
                        ir_variable *const r030B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r030B);
                        ir_variable *const r030C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r030C);
                        ir_variable *const r030D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r030E = neg(r0309);
                        body.emit(assign(r030D, bit_and(r030E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0310 = equal(r0309, body.constant(int(0)));
                        ir_if *f030F = new(mem_ctx) ir_if(operand(r0310).val);
                        exec_list *const f030F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f030F->then_instructions;

                           body.emit(assign(r030A, r02EC, 0x01));

                           body.emit(assign(r030B, r02ED, 0x01));

                           body.emit(assign(r030C, r02EE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f030F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0312 = less(r0309, body.constant(int(32)));
                           ir_if *f0311 = new(mem_ctx) ir_if(operand(r0312).val);
                           exec_list *const f0311_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0311->then_instructions;

                              body.emit(assign(r030A, lshift(r02ED, r030D), 0x01));

                              ir_expression *const r0313 = lshift(r02EE, r030D);
                              ir_expression *const r0314 = rshift(r02ED, r0309);
                              body.emit(assign(r030B, bit_or(r0313, r0314), 0x01));

                              body.emit(assign(r030C, rshift(r02EE, r0309), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0311->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0316 = equal(r0309, body.constant(int(32)));
                              ir_if *f0315 = new(mem_ctx) ir_if(operand(r0316).val);
                              exec_list *const f0315_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0315->then_instructions;

                                 body.emit(assign(r030A, r02ED, 0x01));

                                 body.emit(assign(r030B, r02EE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0315->else_instructions;

                                 body.emit(assign(r0308, bit_or(r02EC, r02ED), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0318 = less(r0309, body.constant(int(64)));
                                 ir_if *f0317 = new(mem_ctx) ir_if(operand(r0318).val);
                                 exec_list *const f0317_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0317->then_instructions;

                                    body.emit(assign(r030A, lshift(r02EE, r030D), 0x01));

                                    ir_expression *const r0319 = bit_and(r0309, body.constant(int(31)));
                                    body.emit(assign(r030B, rshift(r02EE, r0319), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0317->else_instructions;

                                    ir_variable *const r031A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r031C = equal(r0309, body.constant(int(64)));
                                    ir_if *f031B = new(mem_ctx) ir_if(operand(r031C).val);
                                    exec_list *const f031B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f031B->then_instructions;

                                       body.emit(assign(r031A, r02EE, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f031B->else_instructions;

                                       ir_expression *const r031D = nequal(r02EE, body.constant(0u));
                                       ir_expression *const r031E = expr(ir_unop_b2i, r031D);
                                       body.emit(assign(r031A, expr(ir_unop_i2u, r031E), 0x01));


                                    body.instructions = f031B_parent_instructions;
                                    body.emit(f031B);

                                    /* END IF */

                                    body.emit(assign(r030A, r031A, 0x01));

                                    body.emit(assign(r030B, body.constant(0u), 0x01));


                                 body.instructions = f0317_parent_instructions;
                                 body.emit(f0317);

                                 /* END IF */


                              body.instructions = f0315_parent_instructions;
                              body.emit(f0315);

                              /* END IF */

                              body.emit(assign(r030C, body.constant(0u), 0x01));


                           body.instructions = f0311_parent_instructions;
                           body.emit(f0311);

                           /* END IF */

                           ir_expression *const r031F = nequal(r0308, body.constant(0u));
                           ir_expression *const r0320 = expr(ir_unop_b2i, r031F);
                           ir_expression *const r0321 = expr(ir_unop_i2u, r0320);
                           body.emit(assign(r030A, bit_or(r030A, r0321), 0x01));


                        body.instructions = f030F_parent_instructions;
                        body.emit(f030F);

                        /* END IF */

                        body.emit(assign(r02F2, r030C, 0x01));

                        body.emit(assign(r02F3, r030B, 0x01));

                        body.emit(assign(r02F4, r030A, 0x01));

                        body.emit(assign(r02F1, body.constant(int(0)), 0x01));

                        body.emit(assign(r02F7, less(r030A, body.constant(0u)), 0x01));


                     body.instructions = f0306_parent_instructions;
                     body.emit(f0306);

                     /* END IF */


                  body.instructions = f0303_parent_instructions;
                  body.emit(f0303);

                  /* END IF */


               body.instructions = f02F9_parent_instructions;
               body.emit(f02F9);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0322 = new(mem_ctx) ir_if(operand(r02F5).val);
               exec_list *const f0322_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0322->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0323 = new(mem_ctx) ir_if(operand(r02F7).val);
                  exec_list *const f0323_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0323->then_instructions;

                     ir_variable *const r0324 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0324, add(r02F3, body.constant(1u)), 0x01));

                     ir_expression *const r0325 = less(r0324, r02F3);
                     ir_expression *const r0326 = expr(ir_unop_b2i, r0325);
                     ir_expression *const r0327 = expr(ir_unop_i2u, r0326);
                     body.emit(assign(r02F2, add(r02F2, r0327), 0x01));

                     ir_expression *const r0328 = equal(r02F4, body.constant(0u));
                     ir_expression *const r0329 = expr(ir_unop_b2i, r0328);
                     ir_expression *const r032A = expr(ir_unop_i2u, r0329);
                     ir_expression *const r032B = add(r02F4, r032A);
                     ir_expression *const r032C = bit_and(r032B, body.constant(1u));
                     ir_expression *const r032D = expr(ir_unop_bit_not, r032C);
                     body.emit(assign(r02F3, bit_and(r0324, r032D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0323->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r032F = bit_or(r02F2, r02F3);
                     ir_expression *const r0330 = equal(r032F, body.constant(0u));
                     ir_if *f032E = new(mem_ctx) ir_if(operand(r0330).val);
                     exec_list *const f032E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f032E->then_instructions;

                        body.emit(assign(r02F1, body.constant(int(0)), 0x01));


                     body.instructions = f032E_parent_instructions;
                     body.emit(f032E);

                     /* END IF */


                  body.instructions = f0323_parent_instructions;
                  body.emit(f0323);

                  /* END IF */

                  ir_variable *const r0331 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0331);
                  ir_expression *const r0332 = lshift(r0227, body.constant(int(31)));
                  ir_expression *const r0333 = expr(ir_unop_i2u, r02F1);
                  ir_expression *const r0334 = lshift(r0333, body.constant(int(20)));
                  ir_expression *const r0335 = add(r0332, r0334);
                  body.emit(assign(r0331, add(r0335, r02F2), 0x02));

                  body.emit(assign(r0331, r02F3, 0x01));

                  body.emit(assign(r02F6, r0331, 0x03));

                  body.emit(assign(r02F5, body.constant(false), 0x01));


               body.instructions = f0322_parent_instructions;
               body.emit(f0322);

               /* END IF */

               body.emit(assign(r0229, r02F6, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f02E8_parent_instructions;
            body.emit(f02E8);

            /* END IF */


         body.instructions = f02BE_parent_instructions;
         body.emit(f02BE);

         /* END IF */


      body.instructions = f027C_parent_instructions;
      body.emit(f027C);

      /* END IF */


   body.instructions = f023D_parent_instructions;
   body.emit(f023D);

   /* END IF */

   /* IF CONDITION */
   ir_if *f0336 = new(mem_ctx) ir_if(operand(r0228).val);
   exec_list *const f0336_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0336->then_instructions;

      body.emit(assign(r022D, bit_or(r022D, body.constant(1048576u)), 0x01));

      ir_variable *const r0337 = body.make_temp(glsl_type::uint_type, "z0Ptr");
      ir_variable *const r0338 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r0338, add(r022E, r022C), 0x01));

      ir_expression *const r0339 = add(r022D, r022B);
      ir_expression *const r033A = less(r0338, r022E);
      ir_expression *const r033B = expr(ir_unop_b2i, r033A);
      ir_expression *const r033C = expr(ir_unop_i2u, r033B);
      body.emit(assign(r0337, add(r0339, r033C), 0x01));

      body.emit(assign(r0231, r0337, 0x01));

      body.emit(assign(r022F, add(r022F, body.constant(int(-1))), 0x01));

      /* IF CONDITION */
      ir_expression *const r033E = less(r0337, body.constant(2097152u));
      ir_if *f033D = new(mem_ctx) ir_if(operand(r033E).val);
      exec_list *const f033D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f033D->then_instructions;

         ir_variable *const r033F = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r033F, r022F, 0x01));

         ir_variable *const r0340 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0340, r0337, 0x01));

         ir_variable *const r0341 = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r0341, r0338, 0x01));

         ir_variable *const r0342 = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r0342, r0230, 0x01));

         ir_variable *const r0343 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0343, body.constant(true), 0x01));

         ir_variable *const r0344 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0345 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0345);
         ir_expression *const r0346 = expr(ir_unop_u2i, r0230);
         body.emit(assign(r0345, less(r0346, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0348 = lequal(body.constant(int(2045)), r022F);
         ir_if *f0347 = new(mem_ctx) ir_if(operand(r0348).val);
         exec_list *const f0347_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0347->then_instructions;

            ir_variable *const r0349 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r034B = less(body.constant(int(2045)), r022F);
            ir_if *f034A = new(mem_ctx) ir_if(operand(r034B).val);
            exec_list *const f034A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f034A->then_instructions;

               body.emit(assign(r0349, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f034A->else_instructions;

               ir_variable *const r034C = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r034E = equal(r022F, body.constant(int(2045)));
               ir_if *f034D = new(mem_ctx) ir_if(operand(r034E).val);
               exec_list *const f034D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f034D->then_instructions;

                  ir_expression *const r034F = equal(body.constant(2097151u), r0337);
                  ir_expression *const r0350 = equal(body.constant(4294967295u), r0338);
                  body.emit(assign(r034C, logic_and(r034F, r0350), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f034D->else_instructions;

                  body.emit(assign(r034C, body.constant(false), 0x01));


               body.instructions = f034D_parent_instructions;
               body.emit(f034D);

               /* END IF */

               body.emit(assign(r0349, logic_and(r034C, r0345), 0x01));


            body.instructions = f034A_parent_instructions;
            body.emit(f034A);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0351 = new(mem_ctx) ir_if(operand(r0349).val);
            exec_list *const f0351_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0351->then_instructions;

               ir_variable *const r0352 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0352);
               ir_expression *const r0353 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r0352, add(r0353, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0352, body.constant(0u), 0x01));

               body.emit(assign(r0344, r0352, 0x03));

               body.emit(assign(r0343, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0351->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0355 = less(r022F, body.constant(int(0)));
               ir_if *f0354 = new(mem_ctx) ir_if(operand(r0355).val);
               exec_list *const f0354_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0354->then_instructions;

                  ir_variable *const r0356 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0356, r0230, 0x01));

                  ir_variable *const r0357 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0357, neg(r022F), 0x01));

                  ir_variable *const r0358 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0358);
                  ir_variable *const r0359 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0359);
                  ir_variable *const r035A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r035A);
                  ir_variable *const r035B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r035C = neg(r0357);
                  body.emit(assign(r035B, bit_and(r035C, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r035E = equal(r0357, body.constant(int(0)));
                  ir_if *f035D = new(mem_ctx) ir_if(operand(r035E).val);
                  exec_list *const f035D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f035D->then_instructions;

                     body.emit(assign(r0358, r0230, 0x01));

                     body.emit(assign(r0359, r0338, 0x01));

                     body.emit(assign(r035A, r0337, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f035D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0360 = less(r0357, body.constant(int(32)));
                     ir_if *f035F = new(mem_ctx) ir_if(operand(r0360).val);
                     exec_list *const f035F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f035F->then_instructions;

                        body.emit(assign(r0358, lshift(r0338, r035B), 0x01));

                        ir_expression *const r0361 = lshift(r0337, r035B);
                        ir_expression *const r0362 = rshift(r0338, r0357);
                        body.emit(assign(r0359, bit_or(r0361, r0362), 0x01));

                        body.emit(assign(r035A, rshift(r0337, r0357), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f035F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0364 = equal(r0357, body.constant(int(32)));
                        ir_if *f0363 = new(mem_ctx) ir_if(operand(r0364).val);
                        exec_list *const f0363_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0363->then_instructions;

                           body.emit(assign(r0358, r0338, 0x01));

                           body.emit(assign(r0359, r0337, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0363->else_instructions;

                           body.emit(assign(r0356, bit_or(r0230, r0338), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0366 = less(r0357, body.constant(int(64)));
                           ir_if *f0365 = new(mem_ctx) ir_if(operand(r0366).val);
                           exec_list *const f0365_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0365->then_instructions;

                              body.emit(assign(r0358, lshift(r0337, r035B), 0x01));

                              ir_expression *const r0367 = bit_and(r0357, body.constant(int(31)));
                              body.emit(assign(r0359, rshift(r0337, r0367), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0365->else_instructions;

                              ir_variable *const r0368 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r036A = equal(r0357, body.constant(int(64)));
                              ir_if *f0369 = new(mem_ctx) ir_if(operand(r036A).val);
                              exec_list *const f0369_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0369->then_instructions;

                                 body.emit(assign(r0368, r0337, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0369->else_instructions;

                                 ir_expression *const r036B = nequal(r0337, body.constant(0u));
                                 ir_expression *const r036C = expr(ir_unop_b2i, r036B);
                                 body.emit(assign(r0368, expr(ir_unop_i2u, r036C), 0x01));


                              body.instructions = f0369_parent_instructions;
                              body.emit(f0369);

                              /* END IF */

                              body.emit(assign(r0358, r0368, 0x01));

                              body.emit(assign(r0359, body.constant(0u), 0x01));


                           body.instructions = f0365_parent_instructions;
                           body.emit(f0365);

                           /* END IF */


                        body.instructions = f0363_parent_instructions;
                        body.emit(f0363);

                        /* END IF */

                        body.emit(assign(r035A, body.constant(0u), 0x01));


                     body.instructions = f035F_parent_instructions;
                     body.emit(f035F);

                     /* END IF */

                     ir_expression *const r036D = nequal(r0356, body.constant(0u));
                     ir_expression *const r036E = expr(ir_unop_b2i, r036D);
                     ir_expression *const r036F = expr(ir_unop_i2u, r036E);
                     body.emit(assign(r0358, bit_or(r0358, r036F), 0x01));


                  body.instructions = f035D_parent_instructions;
                  body.emit(f035D);

                  /* END IF */

                  body.emit(assign(r0340, r035A, 0x01));

                  body.emit(assign(r0341, r0359, 0x01));

                  body.emit(assign(r0342, r0358, 0x01));

                  body.emit(assign(r033F, body.constant(int(0)), 0x01));

                  body.emit(assign(r0345, less(r0358, body.constant(0u)), 0x01));


               body.instructions = f0354_parent_instructions;
               body.emit(f0354);

               /* END IF */


            body.instructions = f0351_parent_instructions;
            body.emit(f0351);

            /* END IF */


         body.instructions = f0347_parent_instructions;
         body.emit(f0347);

         /* END IF */

         /* IF CONDITION */
         ir_if *f0370 = new(mem_ctx) ir_if(operand(r0343).val);
         exec_list *const f0370_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0370->then_instructions;

            /* IF CONDITION */
            ir_if *f0371 = new(mem_ctx) ir_if(operand(r0345).val);
            exec_list *const f0371_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0371->then_instructions;

               ir_variable *const r0372 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0372, add(r0341, body.constant(1u)), 0x01));

               ir_expression *const r0373 = less(r0372, r0341);
               ir_expression *const r0374 = expr(ir_unop_b2i, r0373);
               ir_expression *const r0375 = expr(ir_unop_i2u, r0374);
               body.emit(assign(r0340, add(r0340, r0375), 0x01));

               ir_expression *const r0376 = equal(r0342, body.constant(0u));
               ir_expression *const r0377 = expr(ir_unop_b2i, r0376);
               ir_expression *const r0378 = expr(ir_unop_i2u, r0377);
               ir_expression *const r0379 = add(r0342, r0378);
               ir_expression *const r037A = bit_and(r0379, body.constant(1u));
               ir_expression *const r037B = expr(ir_unop_bit_not, r037A);
               body.emit(assign(r0341, bit_and(r0372, r037B), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0371->else_instructions;

               /* IF CONDITION */
               ir_expression *const r037D = bit_or(r0340, r0341);
               ir_expression *const r037E = equal(r037D, body.constant(0u));
               ir_if *f037C = new(mem_ctx) ir_if(operand(r037E).val);
               exec_list *const f037C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f037C->then_instructions;

                  body.emit(assign(r033F, body.constant(int(0)), 0x01));


               body.instructions = f037C_parent_instructions;
               body.emit(f037C);

               /* END IF */


            body.instructions = f0371_parent_instructions;
            body.emit(f0371);

            /* END IF */

            ir_variable *const r037F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r037F);
            ir_expression *const r0380 = lshift(r0227, body.constant(int(31)));
            ir_expression *const r0381 = expr(ir_unop_i2u, r033F);
            ir_expression *const r0382 = lshift(r0381, body.constant(int(20)));
            ir_expression *const r0383 = add(r0380, r0382);
            body.emit(assign(r037F, add(r0383, r0340), 0x02));

            body.emit(assign(r037F, r0341, 0x01));

            body.emit(assign(r0344, r037F, 0x03));

            body.emit(assign(r0343, body.constant(false), 0x01));


         body.instructions = f0370_parent_instructions;
         body.emit(f0370);

         /* END IF */

         body.emit(assign(r0229, r0344, 0x03));

         body.emit(assign(r0228, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f033D->else_instructions;

         body.emit(assign(r022F, add(r022F, body.constant(int(1))), 0x01));

         ir_variable *const r0384 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0384);
         ir_variable *const r0385 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0385);
         ir_variable *const r0386 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0386);
         body.emit(assign(r0384, lshift(r0338, body.constant(int(31))), 0x01));

         ir_expression *const r0387 = lshift(r0337, body.constant(int(31)));
         ir_expression *const r0388 = rshift(r0338, body.constant(int(1)));
         body.emit(assign(r0385, bit_or(r0387, r0388), 0x01));

         body.emit(assign(r0386, rshift(r0337, body.constant(int(1))), 0x01));

         ir_expression *const r0389 = nequal(r0230, body.constant(0u));
         ir_expression *const r038A = expr(ir_unop_b2i, r0389);
         ir_expression *const r038B = expr(ir_unop_i2u, r038A);
         body.emit(assign(r0384, bit_or(r0384, r038B), 0x01));

         body.emit(assign(r0231, r0386, 0x01));

         body.emit(assign(r0230, r0384, 0x01));

         ir_variable *const r038C = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r038C, r022F, 0x01));

         ir_variable *const r038D = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r038D, r0386, 0x01));

         ir_variable *const r038E = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r038E, r0385, 0x01));

         ir_variable *const r038F = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r038F, r0384, 0x01));

         ir_variable *const r0390 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0390, body.constant(true), 0x01));

         ir_variable *const r0391 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0392 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0392);
         ir_expression *const r0393 = expr(ir_unop_u2i, r0384);
         body.emit(assign(r0392, less(r0393, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0395 = lequal(body.constant(int(2045)), r022F);
         ir_if *f0394 = new(mem_ctx) ir_if(operand(r0395).val);
         exec_list *const f0394_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0394->then_instructions;

            ir_variable *const r0396 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0398 = less(body.constant(int(2045)), r022F);
            ir_if *f0397 = new(mem_ctx) ir_if(operand(r0398).val);
            exec_list *const f0397_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0397->then_instructions;

               body.emit(assign(r0396, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0397->else_instructions;

               ir_variable *const r0399 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r039B = equal(r022F, body.constant(int(2045)));
               ir_if *f039A = new(mem_ctx) ir_if(operand(r039B).val);
               exec_list *const f039A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f039A->then_instructions;

                  ir_expression *const r039C = equal(body.constant(2097151u), r0386);
                  ir_expression *const r039D = equal(body.constant(4294967295u), r0385);
                  body.emit(assign(r0399, logic_and(r039C, r039D), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f039A->else_instructions;

                  body.emit(assign(r0399, body.constant(false), 0x01));


               body.instructions = f039A_parent_instructions;
               body.emit(f039A);

               /* END IF */

               body.emit(assign(r0396, logic_and(r0399, r0392), 0x01));


            body.instructions = f0397_parent_instructions;
            body.emit(f0397);

            /* END IF */

            /* IF CONDITION */
            ir_if *f039E = new(mem_ctx) ir_if(operand(r0396).val);
            exec_list *const f039E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f039E->then_instructions;

               ir_variable *const r039F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r039F);
               ir_expression *const r03A0 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r039F, add(r03A0, body.constant(2146435072u)), 0x02));

               body.emit(assign(r039F, body.constant(0u), 0x01));

               body.emit(assign(r0391, r039F, 0x03));

               body.emit(assign(r0390, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f039E->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03A2 = less(r022F, body.constant(int(0)));
               ir_if *f03A1 = new(mem_ctx) ir_if(operand(r03A2).val);
               exec_list *const f03A1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03A1->then_instructions;

                  ir_variable *const r03A3 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r03A3, r0384, 0x01));

                  ir_variable *const r03A4 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r03A4, neg(r022F), 0x01));

                  ir_variable *const r03A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r03A5);
                  ir_variable *const r03A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r03A6);
                  ir_variable *const r03A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r03A7);
                  ir_variable *const r03A8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r03A9 = neg(r03A4);
                  body.emit(assign(r03A8, bit_and(r03A9, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r03AB = equal(r03A4, body.constant(int(0)));
                  ir_if *f03AA = new(mem_ctx) ir_if(operand(r03AB).val);
                  exec_list *const f03AA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f03AA->then_instructions;

                     body.emit(assign(r03A5, r0384, 0x01));

                     body.emit(assign(r03A6, r0385, 0x01));

                     body.emit(assign(r03A7, r0386, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f03AA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r03AD = less(r03A4, body.constant(int(32)));
                     ir_if *f03AC = new(mem_ctx) ir_if(operand(r03AD).val);
                     exec_list *const f03AC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f03AC->then_instructions;

                        body.emit(assign(r03A5, lshift(r0385, r03A8), 0x01));

                        ir_expression *const r03AE = lshift(r0386, r03A8);
                        ir_expression *const r03AF = rshift(r0385, r03A4);
                        body.emit(assign(r03A6, bit_or(r03AE, r03AF), 0x01));

                        body.emit(assign(r03A7, rshift(r0386, r03A4), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f03AC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r03B1 = equal(r03A4, body.constant(int(32)));
                        ir_if *f03B0 = new(mem_ctx) ir_if(operand(r03B1).val);
                        exec_list *const f03B0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f03B0->then_instructions;

                           body.emit(assign(r03A5, r0385, 0x01));

                           body.emit(assign(r03A6, r0386, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f03B0->else_instructions;

                           body.emit(assign(r03A3, bit_or(r0384, r0385), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r03B3 = less(r03A4, body.constant(int(64)));
                           ir_if *f03B2 = new(mem_ctx) ir_if(operand(r03B3).val);
                           exec_list *const f03B2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f03B2->then_instructions;

                              body.emit(assign(r03A5, lshift(r0386, r03A8), 0x01));

                              ir_expression *const r03B4 = bit_and(r03A4, body.constant(int(31)));
                              body.emit(assign(r03A6, rshift(r0386, r03B4), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f03B2->else_instructions;

                              ir_variable *const r03B5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r03B7 = equal(r03A4, body.constant(int(64)));
                              ir_if *f03B6 = new(mem_ctx) ir_if(operand(r03B7).val);
                              exec_list *const f03B6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f03B6->then_instructions;

                                 body.emit(assign(r03B5, r0386, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f03B6->else_instructions;

                                 ir_expression *const r03B8 = nequal(r0386, body.constant(0u));
                                 ir_expression *const r03B9 = expr(ir_unop_b2i, r03B8);
                                 body.emit(assign(r03B5, expr(ir_unop_i2u, r03B9), 0x01));


                              body.instructions = f03B6_parent_instructions;
                              body.emit(f03B6);

                              /* END IF */

                              body.emit(assign(r03A5, r03B5, 0x01));

                              body.emit(assign(r03A6, body.constant(0u), 0x01));


                           body.instructions = f03B2_parent_instructions;
                           body.emit(f03B2);

                           /* END IF */


                        body.instructions = f03B0_parent_instructions;
                        body.emit(f03B0);

                        /* END IF */

                        body.emit(assign(r03A7, body.constant(0u), 0x01));


                     body.instructions = f03AC_parent_instructions;
                     body.emit(f03AC);

                     /* END IF */

                     ir_expression *const r03BA = nequal(r03A3, body.constant(0u));
                     ir_expression *const r03BB = expr(ir_unop_b2i, r03BA);
                     ir_expression *const r03BC = expr(ir_unop_i2u, r03BB);
                     body.emit(assign(r03A5, bit_or(r03A5, r03BC), 0x01));


                  body.instructions = f03AA_parent_instructions;
                  body.emit(f03AA);

                  /* END IF */

                  body.emit(assign(r038D, r03A7, 0x01));

                  body.emit(assign(r038E, r03A6, 0x01));

                  body.emit(assign(r038F, r03A5, 0x01));

                  body.emit(assign(r038C, body.constant(int(0)), 0x01));

                  body.emit(assign(r0392, less(r03A5, body.constant(0u)), 0x01));


               body.instructions = f03A1_parent_instructions;
               body.emit(f03A1);

               /* END IF */


            body.instructions = f039E_parent_instructions;
            body.emit(f039E);

            /* END IF */


         body.instructions = f0394_parent_instructions;
         body.emit(f0394);

         /* END IF */

         /* IF CONDITION */
         ir_if *f03BD = new(mem_ctx) ir_if(operand(r0390).val);
         exec_list *const f03BD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03BD->then_instructions;

            /* IF CONDITION */
            ir_if *f03BE = new(mem_ctx) ir_if(operand(r0392).val);
            exec_list *const f03BE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f03BE->then_instructions;

               ir_variable *const r03BF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r03BF, add(r038E, body.constant(1u)), 0x01));

               ir_expression *const r03C0 = less(r03BF, r038E);
               ir_expression *const r03C1 = expr(ir_unop_b2i, r03C0);
               ir_expression *const r03C2 = expr(ir_unop_i2u, r03C1);
               body.emit(assign(r038D, add(r038D, r03C2), 0x01));

               ir_expression *const r03C3 = equal(r038F, body.constant(0u));
               ir_expression *const r03C4 = expr(ir_unop_b2i, r03C3);
               ir_expression *const r03C5 = expr(ir_unop_i2u, r03C4);
               ir_expression *const r03C6 = add(r038F, r03C5);
               ir_expression *const r03C7 = bit_and(r03C6, body.constant(1u));
               ir_expression *const r03C8 = expr(ir_unop_bit_not, r03C7);
               body.emit(assign(r038E, bit_and(r03BF, r03C8), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f03BE->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03CA = bit_or(r038D, r038E);
               ir_expression *const r03CB = equal(r03CA, body.constant(0u));
               ir_if *f03C9 = new(mem_ctx) ir_if(operand(r03CB).val);
               exec_list *const f03C9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03C9->then_instructions;

                  body.emit(assign(r038C, body.constant(int(0)), 0x01));


               body.instructions = f03C9_parent_instructions;
               body.emit(f03C9);

               /* END IF */


            body.instructions = f03BE_parent_instructions;
            body.emit(f03BE);

            /* END IF */

            ir_variable *const r03CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r03CC);
            ir_expression *const r03CD = lshift(r0227, body.constant(int(31)));
            ir_expression *const r03CE = expr(ir_unop_i2u, r038C);
            ir_expression *const r03CF = lshift(r03CE, body.constant(int(20)));
            ir_expression *const r03D0 = add(r03CD, r03CF);
            body.emit(assign(r03CC, add(r03D0, r038D), 0x02));

            body.emit(assign(r03CC, r038E, 0x01));

            body.emit(assign(r0391, r03CC, 0x03));

            body.emit(assign(r0390, body.constant(false), 0x01));


         body.instructions = f03BD_parent_instructions;
         body.emit(f03BD);

         /* END IF */

         body.emit(assign(r0229, r0391, 0x03));

         body.emit(assign(r0228, body.constant(false), 0x01));


      body.instructions = f033D_parent_instructions;
      body.emit(f033D);

      /* END IF */


   body.instructions = f0336_parent_instructions;
   body.emit(f0336);

   /* END IF */

   body.emit(ret(r0229));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
subFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r03D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r03D1);
   ir_variable *const r03D2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r03D2);
   ir_variable *const r03D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r03D3);
   ir_variable *const r03D4 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r03D5 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r03D5);
   ir_variable *const r03D6 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r03D6);
   ir_variable *const r03D7 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r03D7);
   ir_variable *const r03D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r03D8);
   ir_variable *const r03D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r03D9);
   ir_variable *const r03DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r03DA);
   ir_variable *const r03DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r03DB);
   ir_variable *const r03DC = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r03DC);
   ir_variable *const r03DD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03DE = rshift(swizzle_y(r03D1), body.constant(int(20)));
   ir_expression *const r03DF = bit_and(r03DE, body.constant(2047u));
   body.emit(assign(r03DD, expr(ir_unop_u2i, r03DF), 0x01));

   body.emit(assign(r03D7, r03DD, 0x01));

   ir_variable *const r03E0 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03E1 = rshift(swizzle_y(r03D2), body.constant(int(20)));
   ir_expression *const r03E2 = bit_and(r03E1, body.constant(2047u));
   body.emit(assign(r03E0, expr(ir_unop_u2i, r03E2), 0x01));

   body.emit(assign(r03D6, r03E0, 0x01));

   body.emit(assign(r03D5, sub(r03DD, r03E0), 0x01));

   ir_variable *const r03E3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E3, lshift(swizzle_x(r03D1), body.constant(int(10))), 0x01));

   ir_variable *const r03E4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03E5 = bit_and(swizzle_y(r03D1), body.constant(1048575u));
   ir_expression *const r03E6 = lshift(r03E5, body.constant(int(10)));
   ir_expression *const r03E7 = rshift(swizzle_x(r03D1), body.constant(int(22)));
   body.emit(assign(r03E4, bit_or(r03E6, r03E7), 0x01));

   body.emit(assign(r03DA, r03E4, 0x01));

   body.emit(assign(r03DB, r03E3, 0x01));

   ir_variable *const r03E8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E8, lshift(swizzle_x(r03D2), body.constant(int(10))), 0x01));

   ir_variable *const r03E9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03EA = bit_and(swizzle_y(r03D2), body.constant(1048575u));
   ir_expression *const r03EB = lshift(r03EA, body.constant(int(10)));
   ir_expression *const r03EC = rshift(swizzle_x(r03D2), body.constant(int(22)));
   body.emit(assign(r03E9, bit_or(r03EB, r03EC), 0x01));

   body.emit(assign(r03D8, r03E9, 0x01));

   body.emit(assign(r03D9, r03E8, 0x01));

   /* IF CONDITION */
   ir_expression *const r03EE = less(body.constant(int(0)), r03D5);
   ir_if *f03ED = new(mem_ctx) ir_if(operand(r03EE).val);
   exec_list *const f03ED_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f03ED->then_instructions;

      /* IF CONDITION */
      ir_expression *const r03F0 = equal(r03DD, body.constant(int(2047)));
      ir_if *f03EF = new(mem_ctx) ir_if(operand(r03F0).val);
      exec_list *const f03EF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f03EF->then_instructions;

         /* IF CONDITION */
         ir_expression *const r03F2 = bit_or(r03E4, r03E3);
         ir_expression *const r03F3 = nequal(r03F2, body.constant(0u));
         ir_if *f03F1 = new(mem_ctx) ir_if(operand(r03F3).val);
         exec_list *const f03F1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03F1->then_instructions;

            ir_variable *const r03F4 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r03F4, swizzle_x(r03D1), 0x01));

            ir_variable *const r03F5 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r03F5, swizzle_x(r03D2), 0x01));

            ir_variable *const r03F6 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r03F7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r03F8 = rshift(swizzle_y(r03D1), body.constant(int(19)));
            ir_expression *const r03F9 = bit_and(r03F8, body.constant(4095u));
            ir_expression *const r03FA = equal(r03F9, body.constant(4094u));
            ir_expression *const r03FB = nequal(swizzle_x(r03D1), body.constant(0u));
            ir_expression *const r03FC = bit_and(swizzle_y(r03D1), body.constant(524287u));
            ir_expression *const r03FD = nequal(r03FC, body.constant(0u));
            ir_expression *const r03FE = logic_or(r03FB, r03FD);
            body.emit(assign(r03F7, logic_and(r03FA, r03FE), 0x01));

            ir_variable *const r03FF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0400 = lshift(swizzle_y(r03D2), body.constant(int(1)));
            ir_expression *const r0401 = lequal(body.constant(4292870144u), r0400);
            ir_expression *const r0402 = nequal(swizzle_x(r03D2), body.constant(0u));
            ir_expression *const r0403 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
            ir_expression *const r0404 = nequal(r0403, body.constant(0u));
            ir_expression *const r0405 = logic_or(r0402, r0404);
            body.emit(assign(r03FF, logic_and(r0401, r0405), 0x01));

            body.emit(assign(r03F4, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

            body.emit(assign(r03F5, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0407 = lshift(swizzle_y(r03D1), body.constant(int(1)));
            ir_expression *const r0408 = lequal(body.constant(4292870144u), r0407);
            ir_expression *const r0409 = nequal(swizzle_x(r03D1), body.constant(0u));
            ir_expression *const r040A = bit_and(swizzle_y(r03D1), body.constant(1048575u));
            ir_expression *const r040B = nequal(r040A, body.constant(0u));
            ir_expression *const r040C = logic_or(r0409, r040B);
            ir_expression *const r040D = logic_and(r0408, r040C);
            ir_if *f0406 = new(mem_ctx) ir_if(operand(r040D).val);
            exec_list *const f0406_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0406->then_instructions;

               ir_variable *const r040E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0410 = logic_and(r03F7, r03FF);
               ir_if *f040F = new(mem_ctx) ir_if(operand(r0410).val);
               exec_list *const f040F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f040F->then_instructions;

                  body.emit(assign(r040E, r03F5, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f040F->else_instructions;

                  body.emit(assign(r040E, r03F4, 0x03));


               body.instructions = f040F_parent_instructions;
               body.emit(f040F);

               /* END IF */

               body.emit(assign(r03F6, r040E, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0406->else_instructions;

               body.emit(assign(r03F6, r03F5, 0x03));


            body.instructions = f0406_parent_instructions;
            body.emit(f0406);

            /* END IF */

            body.emit(assign(r03D4, r03F6, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f03F1->else_instructions;

            body.emit(assign(r03D4, r03D1, 0x03));


         body.instructions = f03F1_parent_instructions;
         body.emit(f03F1);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f03EF->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0412 = equal(r03E0, body.constant(int(0)));
         ir_if *f0411 = new(mem_ctx) ir_if(operand(r0412).val);
         exec_list *const f0411_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0411->then_instructions;

            body.emit(assign(r03D5, add(r03D5, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0411->else_instructions;

            body.emit(assign(r03D8, bit_or(r03E9, body.constant(1073741824u)), 0x01));


         body.instructions = f0411_parent_instructions;
         body.emit(f0411);

         /* END IF */

         ir_variable *const r0413 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0413);
         ir_variable *const r0414 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0414);
         ir_variable *const r0415 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0416 = neg(r03D5);
         body.emit(assign(r0415, bit_and(r0416, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0418 = equal(r03D5, body.constant(int(0)));
         ir_if *f0417 = new(mem_ctx) ir_if(operand(r0418).val);
         exec_list *const f0417_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0417->then_instructions;

            body.emit(assign(r0413, r03E8, 0x01));

            body.emit(assign(r0414, r03D8, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0417->else_instructions;

            /* IF CONDITION */
            ir_expression *const r041A = less(r03D5, body.constant(int(32)));
            ir_if *f0419 = new(mem_ctx) ir_if(operand(r041A).val);
            exec_list *const f0419_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0419->then_instructions;

               ir_expression *const r041B = lshift(r03D8, r0415);
               ir_expression *const r041C = rshift(r03E8, r03D5);
               ir_expression *const r041D = bit_or(r041B, r041C);
               ir_expression *const r041E = lshift(r03E8, r0415);
               ir_expression *const r041F = nequal(r041E, body.constant(0u));
               ir_expression *const r0420 = expr(ir_unop_b2i, r041F);
               ir_expression *const r0421 = expr(ir_unop_i2u, r0420);
               body.emit(assign(r0413, bit_or(r041D, r0421), 0x01));

               body.emit(assign(r0414, rshift(r03D8, r03D5), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0419->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0423 = equal(r03D5, body.constant(int(32)));
               ir_if *f0422 = new(mem_ctx) ir_if(operand(r0423).val);
               exec_list *const f0422_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0422->then_instructions;

                  ir_expression *const r0424 = nequal(r03E8, body.constant(0u));
                  ir_expression *const r0425 = expr(ir_unop_b2i, r0424);
                  ir_expression *const r0426 = expr(ir_unop_i2u, r0425);
                  body.emit(assign(r0413, bit_or(r03D8, r0426), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0422->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0428 = less(r03D5, body.constant(int(64)));
                  ir_if *f0427 = new(mem_ctx) ir_if(operand(r0428).val);
                  exec_list *const f0427_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0427->then_instructions;

                     ir_expression *const r0429 = bit_and(r03D5, body.constant(int(31)));
                     ir_expression *const r042A = rshift(r03D8, r0429);
                     ir_expression *const r042B = lshift(r03D8, r0415);
                     ir_expression *const r042C = bit_or(r042B, r03E8);
                     ir_expression *const r042D = nequal(r042C, body.constant(0u));
                     ir_expression *const r042E = expr(ir_unop_b2i, r042D);
                     ir_expression *const r042F = expr(ir_unop_i2u, r042E);
                     body.emit(assign(r0413, bit_or(r042A, r042F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0427->else_instructions;

                     ir_expression *const r0430 = bit_or(r03D8, r03E8);
                     ir_expression *const r0431 = nequal(r0430, body.constant(0u));
                     ir_expression *const r0432 = expr(ir_unop_b2i, r0431);
                     body.emit(assign(r0413, expr(ir_unop_i2u, r0432), 0x01));


                  body.instructions = f0427_parent_instructions;
                  body.emit(f0427);

                  /* END IF */


               body.instructions = f0422_parent_instructions;
               body.emit(f0422);

               /* END IF */

               body.emit(assign(r0414, body.constant(0u), 0x01));


            body.instructions = f0419_parent_instructions;
            body.emit(f0419);

            /* END IF */


         body.instructions = f0417_parent_instructions;
         body.emit(f0417);

         /* END IF */

         body.emit(assign(r03D8, r0414, 0x01));

         body.emit(assign(r03D9, r0413, 0x01));

         body.emit(assign(r03DA, bit_or(r03E4, body.constant(1073741824u)), 0x01));

         ir_variable *const r0433 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0434 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r0434, sub(r03E3, r0413), 0x01));

         ir_expression *const r0435 = sub(r03DA, r0414);
         ir_expression *const r0436 = less(r03E3, r0413);
         ir_expression *const r0437 = expr(ir_unop_b2i, r0436);
         ir_expression *const r0438 = expr(ir_unop_i2u, r0437);
         body.emit(assign(r0433, sub(r0435, r0438), 0x01));

         body.emit(assign(r03DC, add(r03DD, body.constant(int(-1))), 0x01));

         ir_variable *const r0439 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0439, add(r03DC, body.constant(int(-10))), 0x01));

         ir_variable *const r043A = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r043A, r0433, 0x01));

         ir_variable *const r043B = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r043B, r0434, 0x01));

         ir_variable *const r043C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r043C);
         ir_variable *const r043D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r043D);
         /* IF CONDITION */
         ir_expression *const r043F = equal(r0433, body.constant(0u));
         ir_if *f043E = new(mem_ctx) ir_if(operand(r043F).val);
         exec_list *const f043E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f043E->then_instructions;

            body.emit(assign(r043A, r0434, 0x01));

            body.emit(assign(r043B, body.constant(0u), 0x01));

            body.emit(assign(r0439, add(r0439, body.constant(int(-32))), 0x01));


         body.instructions = f043E_parent_instructions;
         body.emit(f043E);

         /* END IF */

         ir_variable *const r0440 = body.make_temp(glsl_type::uint_type, "a");
         body.emit(assign(r0440, r043A, 0x01));

         ir_variable *const r0441 = body.make_temp(glsl_type::int_type, "return_value");
         ir_variable *const r0442 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r0442);
         /* IF CONDITION */
         ir_expression *const r0444 = equal(r043A, body.constant(0u));
         ir_if *f0443 = new(mem_ctx) ir_if(operand(r0444).val);
         exec_list *const f0443_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0443->then_instructions;

            body.emit(assign(r0441, body.constant(int(32)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0443->else_instructions;

            body.emit(assign(r0442, body.constant(int(0)), 0x01));

            /* IF CONDITION */
            ir_expression *const r0446 = bit_and(r043A, body.constant(4294901760u));
            ir_expression *const r0447 = equal(r0446, body.constant(0u));
            ir_if *f0445 = new(mem_ctx) ir_if(operand(r0447).val);
            exec_list *const f0445_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0445->then_instructions;

               body.emit(assign(r0442, body.constant(int(16)), 0x01));

               body.emit(assign(r0440, lshift(r043A, body.constant(int(16))), 0x01));


            body.instructions = f0445_parent_instructions;
            body.emit(f0445);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0449 = bit_and(r0440, body.constant(4278190080u));
            ir_expression *const r044A = equal(r0449, body.constant(0u));
            ir_if *f0448 = new(mem_ctx) ir_if(operand(r044A).val);
            exec_list *const f0448_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0448->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(8))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(8))), 0x01));


            body.instructions = f0448_parent_instructions;
            body.emit(f0448);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044C = bit_and(r0440, body.constant(4026531840u));
            ir_expression *const r044D = equal(r044C, body.constant(0u));
            ir_if *f044B = new(mem_ctx) ir_if(operand(r044D).val);
            exec_list *const f044B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044B->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(4))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(4))), 0x01));


            body.instructions = f044B_parent_instructions;
            body.emit(f044B);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044F = bit_and(r0440, body.constant(3221225472u));
            ir_expression *const r0450 = equal(r044F, body.constant(0u));
            ir_if *f044E = new(mem_ctx) ir_if(operand(r0450).val);
            exec_list *const f044E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044E->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(2))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(2))), 0x01));


            body.instructions = f044E_parent_instructions;
            body.emit(f044E);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0452 = bit_and(r0440, body.constant(2147483648u));
            ir_expression *const r0453 = equal(r0452, body.constant(0u));
            ir_if *f0451 = new(mem_ctx) ir_if(operand(r0453).val);
            exec_list *const f0451_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0451->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(1))), 0x01));


            body.instructions = f0451_parent_instructions;
            body.emit(f0451);

            /* END IF */

            body.emit(assign(r0441, r0442, 0x01));


         body.instructions = f0443_parent_instructions;
         body.emit(f0443);

         /* END IF */

         body.emit(assign(r043D, add(r0441, body.constant(int(-11))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0455 = lequal(body.constant(int(0)), r043D);
         ir_if *f0454 = new(mem_ctx) ir_if(operand(r0455).val);
         exec_list *const f0454_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0454->then_instructions;

            body.emit(assign(r043C, body.constant(0u), 0x01));

            ir_variable *const r0456 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0456, lshift(r043B, r043D), 0x01));

            ir_variable *const r0457 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r0459 = equal(r043D, body.constant(int(0)));
            ir_if *f0458 = new(mem_ctx) ir_if(operand(r0459).val);
            exec_list *const f0458_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0458->then_instructions;

               body.emit(assign(r0457, r043A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0458->else_instructions;

               ir_expression *const r045A = lshift(r043A, r043D);
               ir_expression *const r045B = neg(r043D);
               ir_expression *const r045C = bit_and(r045B, body.constant(int(31)));
               ir_expression *const r045D = rshift(r043B, r045C);
               body.emit(assign(r0457, bit_or(r045A, r045D), 0x01));


            body.instructions = f0458_parent_instructions;
            body.emit(f0458);

            /* END IF */

            body.emit(assign(r043A, r0457, 0x01));

            body.emit(assign(r043B, r0456, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0454->else_instructions;

            ir_variable *const r045E = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r045E, body.constant(0u), 0x01));

            ir_variable *const r045F = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r045F, neg(r043D), 0x01));

            ir_variable *const r0460 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0460);
            ir_variable *const r0461 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0461);
            ir_variable *const r0462 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0462);
            ir_variable *const r0463 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0464 = neg(r045F);
            body.emit(assign(r0463, bit_and(r0464, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0466 = equal(r045F, body.constant(int(0)));
            ir_if *f0465 = new(mem_ctx) ir_if(operand(r0466).val);
            exec_list *const f0465_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0465->then_instructions;

               body.emit(assign(r0460, r045E, 0x01));

               body.emit(assign(r0461, r043B, 0x01));

               body.emit(assign(r0462, r043A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0465->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0468 = less(r045F, body.constant(int(32)));
               ir_if *f0467 = new(mem_ctx) ir_if(operand(r0468).val);
               exec_list *const f0467_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0467->then_instructions;

                  body.emit(assign(r0460, lshift(r043B, r0463), 0x01));

                  ir_expression *const r0469 = lshift(r043A, r0463);
                  ir_expression *const r046A = rshift(r043B, r045F);
                  body.emit(assign(r0461, bit_or(r0469, r046A), 0x01));

                  body.emit(assign(r0462, rshift(r043A, r045F), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0467->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r046C = equal(r045F, body.constant(int(32)));
                  ir_if *f046B = new(mem_ctx) ir_if(operand(r046C).val);
                  exec_list *const f046B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f046B->then_instructions;

                     body.emit(assign(r0460, r043B, 0x01));

                     body.emit(assign(r0461, r043A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f046B->else_instructions;

                     body.emit(assign(r045E, bit_or(body.constant(0u), r043B), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r046E = less(r045F, body.constant(int(64)));
                     ir_if *f046D = new(mem_ctx) ir_if(operand(r046E).val);
                     exec_list *const f046D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f046D->then_instructions;

                        body.emit(assign(r0460, lshift(r043A, r0463), 0x01));

                        ir_expression *const r046F = bit_and(r045F, body.constant(int(31)));
                        body.emit(assign(r0461, rshift(r043A, r046F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f046D->else_instructions;

                        ir_variable *const r0470 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0472 = equal(r045F, body.constant(int(64)));
                        ir_if *f0471 = new(mem_ctx) ir_if(operand(r0472).val);
                        exec_list *const f0471_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0471->then_instructions;

                           body.emit(assign(r0470, r043A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0471->else_instructions;

                           ir_expression *const r0473 = nequal(r043A, body.constant(0u));
                           ir_expression *const r0474 = expr(ir_unop_b2i, r0473);
                           body.emit(assign(r0470, expr(ir_unop_i2u, r0474), 0x01));


                        body.instructions = f0471_parent_instructions;
                        body.emit(f0471);

                        /* END IF */

                        body.emit(assign(r0460, r0470, 0x01));

                        body.emit(assign(r0461, body.constant(0u), 0x01));


                     body.instructions = f046D_parent_instructions;
                     body.emit(f046D);

                     /* END IF */


                  body.instructions = f046B_parent_instructions;
                  body.emit(f046B);

                  /* END IF */

                  body.emit(assign(r0462, body.constant(0u), 0x01));


               body.instructions = f0467_parent_instructions;
               body.emit(f0467);

               /* END IF */

               ir_expression *const r0475 = nequal(r045E, body.constant(0u));
               ir_expression *const r0476 = expr(ir_unop_b2i, r0475);
               ir_expression *const r0477 = expr(ir_unop_i2u, r0476);
               body.emit(assign(r0460, bit_or(r0460, r0477), 0x01));


            body.instructions = f0465_parent_instructions;
            body.emit(f0465);

            /* END IF */

            body.emit(assign(r043A, r0462, 0x01));

            body.emit(assign(r043B, r0461, 0x01));

            body.emit(assign(r043C, r0460, 0x01));


         body.instructions = f0454_parent_instructions;
         body.emit(f0454);

         /* END IF */

         body.emit(assign(r0439, sub(r0439, r043D), 0x01));

         ir_variable *const r0478 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0478, r0439, 0x01));

         ir_variable *const r0479 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0479, r043A, 0x01));

         ir_variable *const r047A = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r047A, r043B, 0x01));

         ir_variable *const r047B = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r047B, r043C, 0x01));

         ir_variable *const r047C = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r047C, body.constant(true), 0x01));

         ir_variable *const r047D = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r047E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r047E);
         ir_expression *const r047F = expr(ir_unop_u2i, r043C);
         body.emit(assign(r047E, less(r047F, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0481 = lequal(body.constant(int(2045)), r0439);
         ir_if *f0480 = new(mem_ctx) ir_if(operand(r0481).val);
         exec_list *const f0480_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0480->then_instructions;

            ir_variable *const r0482 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0484 = less(body.constant(int(2045)), r0439);
            ir_if *f0483 = new(mem_ctx) ir_if(operand(r0484).val);
            exec_list *const f0483_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0483->then_instructions;

               body.emit(assign(r0482, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0483->else_instructions;

               ir_variable *const r0485 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r0487 = equal(r0439, body.constant(int(2045)));
               ir_if *f0486 = new(mem_ctx) ir_if(operand(r0487).val);
               exec_list *const f0486_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0486->then_instructions;

                  ir_expression *const r0488 = equal(body.constant(2097151u), r043A);
                  ir_expression *const r0489 = equal(body.constant(4294967295u), r043B);
                  body.emit(assign(r0485, logic_and(r0488, r0489), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0486->else_instructions;

                  body.emit(assign(r0485, body.constant(false), 0x01));


               body.instructions = f0486_parent_instructions;
               body.emit(f0486);

               /* END IF */

               body.emit(assign(r0482, logic_and(r0485, r047E), 0x01));


            body.instructions = f0483_parent_instructions;
            body.emit(f0483);

            /* END IF */

            /* IF CONDITION */
            ir_if *f048A = new(mem_ctx) ir_if(operand(r0482).val);
            exec_list *const f048A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f048A->then_instructions;

               ir_variable *const r048B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r048B);
               ir_expression *const r048C = lshift(r03D3, body.constant(int(31)));
               body.emit(assign(r048B, add(r048C, body.constant(2146435072u)), 0x02));

               body.emit(assign(r048B, body.constant(0u), 0x01));

               body.emit(assign(r047D, r048B, 0x03));

               body.emit(assign(r047C, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f048A->else_instructions;

               /* IF CONDITION */
               ir_expression *const r048E = less(r0439, body.constant(int(0)));
               ir_if *f048D = new(mem_ctx) ir_if(operand(r048E).val);
               exec_list *const f048D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f048D->then_instructions;

                  ir_variable *const r048F = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r048F, r043C, 0x01));

                  ir_variable *const r0490 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0490, neg(r0439), 0x01));

                  ir_variable *const r0491 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0491);
                  ir_variable *const r0492 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0492);
                  ir_variable *const r0493 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0493);
                  ir_variable *const r0494 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0495 = neg(r0490);
                  body.emit(assign(r0494, bit_and(r0495, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0497 = equal(r0490, body.constant(int(0)));
                  ir_if *f0496 = new(mem_ctx) ir_if(operand(r0497).val);
                  exec_list *const f0496_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0496->then_instructions;

                     body.emit(assign(r0491, r043C, 0x01));

                     body.emit(assign(r0492, r043B, 0x01));

                     body.emit(assign(r0493, r043A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0496->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0499 = less(r0490, body.constant(int(32)));
                     ir_if *f0498 = new(mem_ctx) ir_if(operand(r0499).val);
                     exec_list *const f0498_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0498->then_instructions;

                        body.emit(assign(r0491, lshift(r043B, r0494), 0x01));

                        ir_expression *const r049A = lshift(r043A, r0494);
                        ir_expression *const r049B = rshift(r043B, r0490);
                        body.emit(assign(r0492, bit_or(r049A, r049B), 0x01));

                        body.emit(assign(r0493, rshift(r043A, r0490), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0498->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r049D = equal(r0490, body.constant(int(32)));
                        ir_if *f049C = new(mem_ctx) ir_if(operand(r049D).val);
                        exec_list *const f049C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f049C->then_instructions;

                           body.emit(assign(r0491, r043B, 0x01));

                           body.emit(assign(r0492, r043A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f049C->else_instructions;

                           body.emit(assign(r048F, bit_or(r043C, r043B), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r049F = less(r0490, body.constant(int(64)));
                           ir_if *f049E = new(mem_ctx) ir_if(operand(r049F).val);
                           exec_list *const f049E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f049E->then_instructions;

                              body.emit(assign(r0491, lshift(r043A, r0494), 0x01));

                              ir_expression *const r04A0 = bit_and(r0490, body.constant(int(31)));
                              body.emit(assign(r0492, rshift(r043A, r04A0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f049E->else_instructions;

                              ir_variable *const r04A1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r04A3 = equal(r0490, body.constant(int(64)));
                              ir_if *f04A2 = new(mem_ctx) ir_if(operand(r04A3).val);
                              exec_list *const f04A2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f04A2->then_instructions;

                                 body.emit(assign(r04A1, r043A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f04A2->else_instructions;

                                 ir_expression *const r04A4 = nequal(r043A, body.constant(0u));
                                 ir_expression *const r04A5 = expr(ir_unop_b2i, r04A4);
                                 body.emit(assign(r04A1, expr(ir_unop_i2u, r04A5), 0x01));


                              body.instructions = f04A2_parent_instructions;
                              body.emit(f04A2);

                              /* END IF */

                              body.emit(assign(r0491, r04A1, 0x01));

                              body.emit(assign(r0492, body.constant(0u), 0x01));


                           body.instructions = f049E_parent_instructions;
                           body.emit(f049E);

                           /* END IF */


                        body.instructions = f049C_parent_instructions;
                        body.emit(f049C);

                        /* END IF */

                        body.emit(assign(r0493, body.constant(0u), 0x01));


                     body.instructions = f0498_parent_instructions;
                     body.emit(f0498);

                     /* END IF */

                     ir_expression *const r04A6 = nequal(r048F, body.constant(0u));
                     ir_expression *const r04A7 = expr(ir_unop_b2i, r04A6);
                     ir_expression *const r04A8 = expr(ir_unop_i2u, r04A7);
                     body.emit(assign(r0491, bit_or(r0491, r04A8), 0x01));


                  body.instructions = f0496_parent_instructions;
                  body.emit(f0496);

                  /* END IF */

                  body.emit(assign(r0479, r0493, 0x01));

                  body.emit(assign(r047A, r0492, 0x01));

                  body.emit(assign(r047B, r0491, 0x01));

                  body.emit(assign(r0478, body.constant(int(0)), 0x01));

                  body.emit(assign(r047E, less(r0491, body.constant(0u)), 0x01));


               body.instructions = f048D_parent_instructions;
               body.emit(f048D);

               /* END IF */


            body.instructions = f048A_parent_instructions;
            body.emit(f048A);

            /* END IF */


         body.instructions = f0480_parent_instructions;
         body.emit(f0480);

         /* END IF */

         /* IF CONDITION */
         ir_if *f04A9 = new(mem_ctx) ir_if(operand(r047C).val);
         exec_list *const f04A9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04A9->then_instructions;

            /* IF CONDITION */
            ir_if *f04AA = new(mem_ctx) ir_if(operand(r047E).val);
            exec_list *const f04AA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04AA->then_instructions;

               ir_variable *const r04AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r04AB, add(r047A, body.constant(1u)), 0x01));

               ir_expression *const r04AC = less(r04AB, r047A);
               ir_expression *const r04AD = expr(ir_unop_b2i, r04AC);
               ir_expression *const r04AE = expr(ir_unop_i2u, r04AD);
               body.emit(assign(r0479, add(r0479, r04AE), 0x01));

               ir_expression *const r04AF = equal(r047B, body.constant(0u));
               ir_expression *const r04B0 = expr(ir_unop_b2i, r04AF);
               ir_expression *const r04B1 = expr(ir_unop_i2u, r04B0);
               ir_expression *const r04B2 = add(r047B, r04B1);
               ir_expression *const r04B3 = bit_and(r04B2, body.constant(1u));
               ir_expression *const r04B4 = expr(ir_unop_bit_not, r04B3);
               body.emit(assign(r047A, bit_and(r04AB, r04B4), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04AA->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04B6 = bit_or(r0479, r047A);
               ir_expression *const r04B7 = equal(r04B6, body.constant(0u));
               ir_if *f04B5 = new(mem_ctx) ir_if(operand(r04B7).val);
               exec_list *const f04B5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04B5->then_instructions;

                  body.emit(assign(r0478, body.constant(int(0)), 0x01));


               body.instructions = f04B5_parent_instructions;
               body.emit(f04B5);

               /* END IF */


            body.instructions = f04AA_parent_instructions;
            body.emit(f04AA);

            /* END IF */

            ir_variable *const r04B8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r04B8);
            ir_expression *const r04B9 = lshift(r03D3, body.constant(int(31)));
            ir_expression *const r04BA = expr(ir_unop_i2u, r0478);
            ir_expression *const r04BB = lshift(r04BA, body.constant(int(20)));
            ir_expression *const r04BC = add(r04B9, r04BB);
            body.emit(assign(r04B8, add(r04BC, r0479), 0x02));

            body.emit(assign(r04B8, r047A, 0x01));

            body.emit(assign(r047D, r04B8, 0x03));

            body.emit(assign(r047C, body.constant(false), 0x01));


         body.instructions = f04A9_parent_instructions;
         body.emit(f04A9);

         /* END IF */

         body.emit(assign(r03D4, r047D, 0x03));


      body.instructions = f03EF_parent_instructions;
      body.emit(f03EF);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f03ED->else_instructions;

      /* IF CONDITION */
      ir_expression *const r04BE = less(r03D5, body.constant(int(0)));
      ir_if *f04BD = new(mem_ctx) ir_if(operand(r04BE).val);
      exec_list *const f04BD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f04BD->then_instructions;

         /* IF CONDITION */
         ir_expression *const r04C0 = equal(r03E0, body.constant(int(2047)));
         ir_if *f04BF = new(mem_ctx) ir_if(operand(r04C0).val);
         exec_list *const f04BF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04BF->then_instructions;

            /* IF CONDITION */
            ir_expression *const r04C2 = bit_or(r03D8, r03D9);
            ir_expression *const r04C3 = nequal(r04C2, body.constant(0u));
            ir_if *f04C1 = new(mem_ctx) ir_if(operand(r04C3).val);
            exec_list *const f04C1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04C1->then_instructions;

               ir_variable *const r04C4 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r04C4, swizzle_x(r03D1), 0x01));

               ir_variable *const r04C5 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r04C5, swizzle_x(r03D2), 0x01));

               ir_variable *const r04C6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r04C7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r04C8 = rshift(swizzle_y(r03D1), body.constant(int(19)));
               ir_expression *const r04C9 = bit_and(r04C8, body.constant(4095u));
               ir_expression *const r04CA = equal(r04C9, body.constant(4094u));
               ir_expression *const r04CB = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r04CC = bit_and(swizzle_y(r03D1), body.constant(524287u));
               ir_expression *const r04CD = nequal(r04CC, body.constant(0u));
               ir_expression *const r04CE = logic_or(r04CB, r04CD);
               body.emit(assign(r04C7, logic_and(r04CA, r04CE), 0x01));

               ir_variable *const r04CF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r04D0 = lshift(swizzle_y(r03D2), body.constant(int(1)));
               ir_expression *const r04D1 = lequal(body.constant(4292870144u), r04D0);
               ir_expression *const r04D2 = nequal(swizzle_x(r03D2), body.constant(0u));
               ir_expression *const r04D3 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
               ir_expression *const r04D4 = nequal(r04D3, body.constant(0u));
               ir_expression *const r04D5 = logic_or(r04D2, r04D4);
               body.emit(assign(r04CF, logic_and(r04D1, r04D5), 0x01));

               body.emit(assign(r04C4, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

               body.emit(assign(r04C5, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r04D7 = lshift(swizzle_y(r03D1), body.constant(int(1)));
               ir_expression *const r04D8 = lequal(body.constant(4292870144u), r04D7);
               ir_expression *const r04D9 = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r04DA = bit_and(swizzle_y(r03D1), body.constant(1048575u));
               ir_expression *const r04DB = nequal(r04DA, body.constant(0u));
               ir_expression *const r04DC = logic_or(r04D9, r04DB);
               ir_expression *const r04DD = logic_and(r04D8, r04DC);
               ir_if *f04D6 = new(mem_ctx) ir_if(operand(r04DD).val);
               exec_list *const f04D6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04D6->then_instructions;

                  ir_variable *const r04DE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r04E0 = logic_and(r04C7, r04CF);
                  ir_if *f04DF = new(mem_ctx) ir_if(operand(r04E0).val);
                  exec_list *const f04DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04DF->then_instructions;

                     body.emit(assign(r04DE, r04C5, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04DF->else_instructions;

                     body.emit(assign(r04DE, r04C4, 0x03));


                  body.instructions = f04DF_parent_instructions;
                  body.emit(f04DF);

                  /* END IF */

                  body.emit(assign(r04C6, r04DE, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04D6->else_instructions;

                  body.emit(assign(r04C6, r04C5, 0x03));


               body.instructions = f04D6_parent_instructions;
               body.emit(f04D6);

               /* END IF */

               body.emit(assign(r03D4, r04C6, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04C1->else_instructions;

               ir_variable *const r04E1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r04E1);
               ir_expression *const r04E2 = bit_xor(r03D3, body.constant(1u));
               ir_expression *const r04E3 = lshift(r04E2, body.constant(int(31)));
               body.emit(assign(r04E1, add(r04E3, body.constant(2146435072u)), 0x02));

               body.emit(assign(r04E1, body.constant(0u), 0x01));

               body.emit(assign(r03D4, r04E1, 0x03));


            body.instructions = f04C1_parent_instructions;
            body.emit(f04C1);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f04BF->else_instructions;

            /* IF CONDITION */
            ir_expression *const r04E5 = equal(r03DD, body.constant(int(0)));
            ir_if *f04E4 = new(mem_ctx) ir_if(operand(r04E5).val);
            exec_list *const f04E4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04E4->then_instructions;

               body.emit(assign(r03D5, add(r03D5, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04E4->else_instructions;

               body.emit(assign(r03DA, bit_or(r03DA, body.constant(1073741824u)), 0x01));


            body.instructions = f04E4_parent_instructions;
            body.emit(f04E4);

            /* END IF */

            ir_variable *const r04E6 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r04E6, neg(r03D5), 0x01));

            ir_variable *const r04E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r04E7);
            ir_variable *const r04E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r04E8);
            ir_variable *const r04E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r04EA = neg(r04E6);
            body.emit(assign(r04E9, bit_and(r04EA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r04EC = equal(r04E6, body.constant(int(0)));
            ir_if *f04EB = new(mem_ctx) ir_if(operand(r04EC).val);
            exec_list *const f04EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04EB->then_instructions;

               body.emit(assign(r04E7, r03E3, 0x01));

               body.emit(assign(r04E8, r03DA, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04EB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04EE = less(r04E6, body.constant(int(32)));
               ir_if *f04ED = new(mem_ctx) ir_if(operand(r04EE).val);
               exec_list *const f04ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04ED->then_instructions;

                  ir_expression *const r04EF = lshift(r03DA, r04E9);
                  ir_expression *const r04F0 = rshift(r03E3, r04E6);
                  ir_expression *const r04F1 = bit_or(r04EF, r04F0);
                  ir_expression *const r04F2 = lshift(r03E3, r04E9);
                  ir_expression *const r04F3 = nequal(r04F2, body.constant(0u));
                  ir_expression *const r04F4 = expr(ir_unop_b2i, r04F3);
                  ir_expression *const r04F5 = expr(ir_unop_i2u, r04F4);
                  body.emit(assign(r04E7, bit_or(r04F1, r04F5), 0x01));

                  body.emit(assign(r04E8, rshift(r03DA, r04E6), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04ED->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r04F7 = equal(r04E6, body.constant(int(32)));
                  ir_if *f04F6 = new(mem_ctx) ir_if(operand(r04F7).val);
                  exec_list *const f04F6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04F6->then_instructions;

                     ir_expression *const r04F8 = nequal(r03E3, body.constant(0u));
                     ir_expression *const r04F9 = expr(ir_unop_b2i, r04F8);
                     ir_expression *const r04FA = expr(ir_unop_i2u, r04F9);
                     body.emit(assign(r04E7, bit_or(r03DA, r04FA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04F6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r04FC = less(r04E6, body.constant(int(64)));
                     ir_if *f04FB = new(mem_ctx) ir_if(operand(r04FC).val);
                     exec_list *const f04FB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f04FB->then_instructions;

                        ir_expression *const r04FD = bit_and(r04E6, body.constant(int(31)));
                        ir_expression *const r04FE = rshift(r03DA, r04FD);
                        ir_expression *const r04FF = lshift(r03DA, r04E9);
                        ir_expression *const r0500 = bit_or(r04FF, r03E3);
                        ir_expression *const r0501 = nequal(r0500, body.constant(0u));
                        ir_expression *const r0502 = expr(ir_unop_b2i, r0501);
                        ir_expression *const r0503 = expr(ir_unop_i2u, r0502);
                        body.emit(assign(r04E7, bit_or(r04FE, r0503), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f04FB->else_instructions;

                        ir_expression *const r0504 = bit_or(r03DA, r03E3);
                        ir_expression *const r0505 = nequal(r0504, body.constant(0u));
                        ir_expression *const r0506 = expr(ir_unop_b2i, r0505);
                        body.emit(assign(r04E7, expr(ir_unop_i2u, r0506), 0x01));


                     body.instructions = f04FB_parent_instructions;
                     body.emit(f04FB);

                     /* END IF */


                  body.instructions = f04F6_parent_instructions;
                  body.emit(f04F6);

                  /* END IF */

                  body.emit(assign(r04E8, body.constant(0u), 0x01));


               body.instructions = f04ED_parent_instructions;
               body.emit(f04ED);

               /* END IF */


            body.instructions = f04EB_parent_instructions;
            body.emit(f04EB);

            /* END IF */

            body.emit(assign(r03DA, r04E8, 0x01));

            body.emit(assign(r03DB, r04E7, 0x01));

            body.emit(assign(r03D8, bit_or(r03D8, body.constant(1073741824u)), 0x01));

            ir_variable *const r0507 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0508 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0508, sub(r03D9, r04E7), 0x01));

            ir_expression *const r0509 = sub(r03D8, r04E8);
            ir_expression *const r050A = less(r03D9, r04E7);
            ir_expression *const r050B = expr(ir_unop_b2i, r050A);
            ir_expression *const r050C = expr(ir_unop_i2u, r050B);
            body.emit(assign(r0507, sub(r0509, r050C), 0x01));

            body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

            body.emit(assign(r03DC, add(r03E0, body.constant(int(-1))), 0x01));

            ir_variable *const r050D = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r050D, add(r03DC, body.constant(int(-10))), 0x01));

            ir_variable *const r050E = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r050E, r0507, 0x01));

            ir_variable *const r050F = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r050F, r0508, 0x01));

            ir_variable *const r0510 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0510);
            ir_variable *const r0511 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0511);
            /* IF CONDITION */
            ir_expression *const r0513 = equal(r0507, body.constant(0u));
            ir_if *f0512 = new(mem_ctx) ir_if(operand(r0513).val);
            exec_list *const f0512_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0512->then_instructions;

               body.emit(assign(r050E, r0508, 0x01));

               body.emit(assign(r050F, body.constant(0u), 0x01));

               body.emit(assign(r050D, add(r050D, body.constant(int(-32))), 0x01));


            body.instructions = f0512_parent_instructions;
            body.emit(f0512);

            /* END IF */

            ir_variable *const r0514 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0514, r050E, 0x01));

            ir_variable *const r0515 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0516 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0516);
            /* IF CONDITION */
            ir_expression *const r0518 = equal(r050E, body.constant(0u));
            ir_if *f0517 = new(mem_ctx) ir_if(operand(r0518).val);
            exec_list *const f0517_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0517->then_instructions;

               body.emit(assign(r0515, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0517->else_instructions;

               body.emit(assign(r0516, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r051A = bit_and(r050E, body.constant(4294901760u));
               ir_expression *const r051B = equal(r051A, body.constant(0u));
               ir_if *f0519 = new(mem_ctx) ir_if(operand(r051B).val);
               exec_list *const f0519_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0519->then_instructions;

                  body.emit(assign(r0516, body.constant(int(16)), 0x01));

                  body.emit(assign(r0514, lshift(r050E, body.constant(int(16))), 0x01));


               body.instructions = f0519_parent_instructions;
               body.emit(f0519);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r051D = bit_and(r0514, body.constant(4278190080u));
               ir_expression *const r051E = equal(r051D, body.constant(0u));
               ir_if *f051C = new(mem_ctx) ir_if(operand(r051E).val);
               exec_list *const f051C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051C->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(8))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(8))), 0x01));


               body.instructions = f051C_parent_instructions;
               body.emit(f051C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0520 = bit_and(r0514, body.constant(4026531840u));
               ir_expression *const r0521 = equal(r0520, body.constant(0u));
               ir_if *f051F = new(mem_ctx) ir_if(operand(r0521).val);
               exec_list *const f051F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051F->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(4))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(4))), 0x01));


               body.instructions = f051F_parent_instructions;
               body.emit(f051F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0523 = bit_and(r0514, body.constant(3221225472u));
               ir_expression *const r0524 = equal(r0523, body.constant(0u));
               ir_if *f0522 = new(mem_ctx) ir_if(operand(r0524).val);
               exec_list *const f0522_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0522->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(2))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(2))), 0x01));


               body.instructions = f0522_parent_instructions;
               body.emit(f0522);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0526 = bit_and(r0514, body.constant(2147483648u));
               ir_expression *const r0527 = equal(r0526, body.constant(0u));
               ir_if *f0525 = new(mem_ctx) ir_if(operand(r0527).val);
               exec_list *const f0525_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0525->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(1))), 0x01));


               body.instructions = f0525_parent_instructions;
               body.emit(f0525);

               /* END IF */

               body.emit(assign(r0515, r0516, 0x01));


            body.instructions = f0517_parent_instructions;
            body.emit(f0517);

            /* END IF */

            body.emit(assign(r0511, add(r0515, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0529 = lequal(body.constant(int(0)), r0511);
            ir_if *f0528 = new(mem_ctx) ir_if(operand(r0529).val);
            exec_list *const f0528_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0528->then_instructions;

               body.emit(assign(r0510, body.constant(0u), 0x01));

               ir_variable *const r052A = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r052A, lshift(r050F, r0511), 0x01));

               ir_variable *const r052B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r052D = equal(r0511, body.constant(int(0)));
               ir_if *f052C = new(mem_ctx) ir_if(operand(r052D).val);
               exec_list *const f052C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f052C->then_instructions;

                  body.emit(assign(r052B, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f052C->else_instructions;

                  ir_expression *const r052E = lshift(r050E, r0511);
                  ir_expression *const r052F = neg(r0511);
                  ir_expression *const r0530 = bit_and(r052F, body.constant(int(31)));
                  ir_expression *const r0531 = rshift(r050F, r0530);
                  body.emit(assign(r052B, bit_or(r052E, r0531), 0x01));


               body.instructions = f052C_parent_instructions;
               body.emit(f052C);

               /* END IF */

               body.emit(assign(r050E, r052B, 0x01));

               body.emit(assign(r050F, r052A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0528->else_instructions;

               ir_variable *const r0532 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0532, body.constant(0u), 0x01));

               ir_variable *const r0533 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0533, neg(r0511), 0x01));

               ir_variable *const r0534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0534);
               ir_variable *const r0535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0535);
               ir_variable *const r0536 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0536);
               ir_variable *const r0537 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0538 = neg(r0533);
               body.emit(assign(r0537, bit_and(r0538, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r053A = equal(r0533, body.constant(int(0)));
               ir_if *f0539 = new(mem_ctx) ir_if(operand(r053A).val);
               exec_list *const f0539_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0539->then_instructions;

                  body.emit(assign(r0534, r0532, 0x01));

                  body.emit(assign(r0535, r050F, 0x01));

                  body.emit(assign(r0536, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0539->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r053C = less(r0533, body.constant(int(32)));
                  ir_if *f053B = new(mem_ctx) ir_if(operand(r053C).val);
                  exec_list *const f053B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f053B->then_instructions;

                     body.emit(assign(r0534, lshift(r050F, r0537), 0x01));

                     ir_expression *const r053D = lshift(r050E, r0537);
                     ir_expression *const r053E = rshift(r050F, r0533);
                     body.emit(assign(r0535, bit_or(r053D, r053E), 0x01));

                     body.emit(assign(r0536, rshift(r050E, r0533), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f053B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0540 = equal(r0533, body.constant(int(32)));
                     ir_if *f053F = new(mem_ctx) ir_if(operand(r0540).val);
                     exec_list *const f053F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f053F->then_instructions;

                        body.emit(assign(r0534, r050F, 0x01));

                        body.emit(assign(r0535, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f053F->else_instructions;

                        body.emit(assign(r0532, bit_or(body.constant(0u), r050F), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0542 = less(r0533, body.constant(int(64)));
                        ir_if *f0541 = new(mem_ctx) ir_if(operand(r0542).val);
                        exec_list *const f0541_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0541->then_instructions;

                           body.emit(assign(r0534, lshift(r050E, r0537), 0x01));

                           ir_expression *const r0543 = bit_and(r0533, body.constant(int(31)));
                           body.emit(assign(r0535, rshift(r050E, r0543), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0541->else_instructions;

                           ir_variable *const r0544 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0546 = equal(r0533, body.constant(int(64)));
                           ir_if *f0545 = new(mem_ctx) ir_if(operand(r0546).val);
                           exec_list *const f0545_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0545->then_instructions;

                              body.emit(assign(r0544, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0545->else_instructions;

                              ir_expression *const r0547 = nequal(r050E, body.constant(0u));
                              ir_expression *const r0548 = expr(ir_unop_b2i, r0547);
                              body.emit(assign(r0544, expr(ir_unop_i2u, r0548), 0x01));


                           body.instructions = f0545_parent_instructions;
                           body.emit(f0545);

                           /* END IF */

                           body.emit(assign(r0534, r0544, 0x01));

                           body.emit(assign(r0535, body.constant(0u), 0x01));


                        body.instructions = f0541_parent_instructions;
                        body.emit(f0541);

                        /* END IF */


                     body.instructions = f053F_parent_instructions;
                     body.emit(f053F);

                     /* END IF */

                     body.emit(assign(r0536, body.constant(0u), 0x01));


                  body.instructions = f053B_parent_instructions;
                  body.emit(f053B);

                  /* END IF */

                  ir_expression *const r0549 = nequal(r0532, body.constant(0u));
                  ir_expression *const r054A = expr(ir_unop_b2i, r0549);
                  ir_expression *const r054B = expr(ir_unop_i2u, r054A);
                  body.emit(assign(r0534, bit_or(r0534, r054B), 0x01));


               body.instructions = f0539_parent_instructions;
               body.emit(f0539);

               /* END IF */

               body.emit(assign(r050E, r0536, 0x01));

               body.emit(assign(r050F, r0535, 0x01));

               body.emit(assign(r0510, r0534, 0x01));


            body.instructions = f0528_parent_instructions;
            body.emit(f0528);

            /* END IF */

            body.emit(assign(r050D, sub(r050D, r0511), 0x01));

            ir_variable *const r054C = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r054C, r050D, 0x01));

            ir_variable *const r054D = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r054D, r050E, 0x01));

            ir_variable *const r054E = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r054E, r050F, 0x01));

            ir_variable *const r054F = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r054F, r0510, 0x01));

            ir_variable *const r0550 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0550, body.constant(true), 0x01));

            ir_variable *const r0551 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0552 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0552);
            ir_expression *const r0553 = expr(ir_unop_u2i, r0510);
            body.emit(assign(r0552, less(r0553, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0555 = lequal(body.constant(int(2045)), r050D);
            ir_if *f0554 = new(mem_ctx) ir_if(operand(r0555).val);
            exec_list *const f0554_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0554->then_instructions;

               ir_variable *const r0556 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0558 = less(body.constant(int(2045)), r050D);
               ir_if *f0557 = new(mem_ctx) ir_if(operand(r0558).val);
               exec_list *const f0557_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0557->then_instructions;

                  body.emit(assign(r0556, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0557->else_instructions;

                  ir_variable *const r0559 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r055B = equal(r050D, body.constant(int(2045)));
                  ir_if *f055A = new(mem_ctx) ir_if(operand(r055B).val);
                  exec_list *const f055A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f055A->then_instructions;

                     ir_expression *const r055C = equal(body.constant(2097151u), r050E);
                     ir_expression *const r055D = equal(body.constant(4294967295u), r050F);
                     body.emit(assign(r0559, logic_and(r055C, r055D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f055A->else_instructions;

                     body.emit(assign(r0559, body.constant(false), 0x01));


                  body.instructions = f055A_parent_instructions;
                  body.emit(f055A);

                  /* END IF */

                  body.emit(assign(r0556, logic_and(r0559, r0552), 0x01));


               body.instructions = f0557_parent_instructions;
               body.emit(f0557);

               /* END IF */

               /* IF CONDITION */
               ir_if *f055E = new(mem_ctx) ir_if(operand(r0556).val);
               exec_list *const f055E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f055E->then_instructions;

                  ir_variable *const r055F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r055F);
                  ir_expression *const r0560 = lshift(r03D3, body.constant(int(31)));
                  body.emit(assign(r055F, add(r0560, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r055F, body.constant(0u), 0x01));

                  body.emit(assign(r0551, r055F, 0x03));

                  body.emit(assign(r0550, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f055E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0562 = less(r050D, body.constant(int(0)));
                  ir_if *f0561 = new(mem_ctx) ir_if(operand(r0562).val);
                  exec_list *const f0561_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0561->then_instructions;

                     ir_variable *const r0563 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0563, r0510, 0x01));

                     ir_variable *const r0564 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0564, neg(r050D), 0x01));

                     ir_variable *const r0565 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0565);
                     ir_variable *const r0566 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0566);
                     ir_variable *const r0567 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0567);
                     ir_variable *const r0568 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0569 = neg(r0564);
                     body.emit(assign(r0568, bit_and(r0569, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r056B = equal(r0564, body.constant(int(0)));
                     ir_if *f056A = new(mem_ctx) ir_if(operand(r056B).val);
                     exec_list *const f056A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f056A->then_instructions;

                        body.emit(assign(r0565, r0510, 0x01));

                        body.emit(assign(r0566, r050F, 0x01));

                        body.emit(assign(r0567, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f056A->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r056D = less(r0564, body.constant(int(32)));
                        ir_if *f056C = new(mem_ctx) ir_if(operand(r056D).val);
                        exec_list *const f056C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f056C->then_instructions;

                           body.emit(assign(r0565, lshift(r050F, r0568), 0x01));

                           ir_expression *const r056E = lshift(r050E, r0568);
                           ir_expression *const r056F = rshift(r050F, r0564);
                           body.emit(assign(r0566, bit_or(r056E, r056F), 0x01));

                           body.emit(assign(r0567, rshift(r050E, r0564), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f056C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0571 = equal(r0564, body.constant(int(32)));
                           ir_if *f0570 = new(mem_ctx) ir_if(operand(r0571).val);
                           exec_list *const f0570_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0570->then_instructions;

                              body.emit(assign(r0565, r050F, 0x01));

                              body.emit(assign(r0566, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0570->else_instructions;

                              body.emit(assign(r0563, bit_or(r0510, r050F), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0573 = less(r0564, body.constant(int(64)));
                              ir_if *f0572 = new(mem_ctx) ir_if(operand(r0573).val);
                              exec_list *const f0572_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0572->then_instructions;

                                 body.emit(assign(r0565, lshift(r050E, r0568), 0x01));

                                 ir_expression *const r0574 = bit_and(r0564, body.constant(int(31)));
                                 body.emit(assign(r0566, rshift(r050E, r0574), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0572->else_instructions;

                                 ir_variable *const r0575 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0577 = equal(r0564, body.constant(int(64)));
                                 ir_if *f0576 = new(mem_ctx) ir_if(operand(r0577).val);
                                 exec_list *const f0576_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0576->then_instructions;

                                    body.emit(assign(r0575, r050E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0576->else_instructions;

                                    ir_expression *const r0578 = nequal(r050E, body.constant(0u));
                                    ir_expression *const r0579 = expr(ir_unop_b2i, r0578);
                                    body.emit(assign(r0575, expr(ir_unop_i2u, r0579), 0x01));


                                 body.instructions = f0576_parent_instructions;
                                 body.emit(f0576);

                                 /* END IF */

                                 body.emit(assign(r0565, r0575, 0x01));

                                 body.emit(assign(r0566, body.constant(0u), 0x01));


                              body.instructions = f0572_parent_instructions;
                              body.emit(f0572);

                              /* END IF */


                           body.instructions = f0570_parent_instructions;
                           body.emit(f0570);

                           /* END IF */

                           body.emit(assign(r0567, body.constant(0u), 0x01));


                        body.instructions = f056C_parent_instructions;
                        body.emit(f056C);

                        /* END IF */

                        ir_expression *const r057A = nequal(r0563, body.constant(0u));
                        ir_expression *const r057B = expr(ir_unop_b2i, r057A);
                        ir_expression *const r057C = expr(ir_unop_i2u, r057B);
                        body.emit(assign(r0565, bit_or(r0565, r057C), 0x01));


                     body.instructions = f056A_parent_instructions;
                     body.emit(f056A);

                     /* END IF */

                     body.emit(assign(r054D, r0567, 0x01));

                     body.emit(assign(r054E, r0566, 0x01));

                     body.emit(assign(r054F, r0565, 0x01));

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));

                     body.emit(assign(r0552, less(r0565, body.constant(0u)), 0x01));


                  body.instructions = f0561_parent_instructions;
                  body.emit(f0561);

                  /* END IF */


               body.instructions = f055E_parent_instructions;
               body.emit(f055E);

               /* END IF */


            body.instructions = f0554_parent_instructions;
            body.emit(f0554);

            /* END IF */

            /* IF CONDITION */
            ir_if *f057D = new(mem_ctx) ir_if(operand(r0550).val);
            exec_list *const f057D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f057D->then_instructions;

               /* IF CONDITION */
               ir_if *f057E = new(mem_ctx) ir_if(operand(r0552).val);
               exec_list *const f057E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f057E->then_instructions;

                  ir_variable *const r057F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r057F, add(r054E, body.constant(1u)), 0x01));

                  ir_expression *const r0580 = less(r057F, r054E);
                  ir_expression *const r0581 = expr(ir_unop_b2i, r0580);
                  ir_expression *const r0582 = expr(ir_unop_i2u, r0581);
                  body.emit(assign(r054D, add(r054D, r0582), 0x01));

                  ir_expression *const r0583 = equal(r054F, body.constant(0u));
                  ir_expression *const r0584 = expr(ir_unop_b2i, r0583);
                  ir_expression *const r0585 = expr(ir_unop_i2u, r0584);
                  ir_expression *const r0586 = add(r054F, r0585);
                  ir_expression *const r0587 = bit_and(r0586, body.constant(1u));
                  ir_expression *const r0588 = expr(ir_unop_bit_not, r0587);
                  body.emit(assign(r054E, bit_and(r057F, r0588), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f057E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r058A = bit_or(r054D, r054E);
                  ir_expression *const r058B = equal(r058A, body.constant(0u));
                  ir_if *f0589 = new(mem_ctx) ir_if(operand(r058B).val);
                  exec_list *const f0589_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0589->then_instructions;

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));


                  body.instructions = f0589_parent_instructions;
                  body.emit(f0589);

                  /* END IF */


               body.instructions = f057E_parent_instructions;
               body.emit(f057E);

               /* END IF */

               ir_variable *const r058C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r058C);
               ir_expression *const r058D = lshift(r03D3, body.constant(int(31)));
               ir_expression *const r058E = expr(ir_unop_i2u, r054C);
               ir_expression *const r058F = lshift(r058E, body.constant(int(20)));
               ir_expression *const r0590 = add(r058D, r058F);
               body.emit(assign(r058C, add(r0590, r054D), 0x02));

               body.emit(assign(r058C, r054E, 0x01));

               body.emit(assign(r0551, r058C, 0x03));

               body.emit(assign(r0550, body.constant(false), 0x01));


            body.instructions = f057D_parent_instructions;
            body.emit(f057D);

            /* END IF */

            body.emit(assign(r03D4, r0551, 0x03));


         body.instructions = f04BF_parent_instructions;
         body.emit(f04BF);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f04BD->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0592 = equal(r03DD, body.constant(int(2047)));
         ir_if *f0591 = new(mem_ctx) ir_if(operand(r0592).val);
         exec_list *const f0591_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0591->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0594 = bit_or(r03DA, r03DB);
            ir_expression *const r0595 = bit_or(r03D8, r03D9);
            ir_expression *const r0596 = bit_or(r0594, r0595);
            ir_expression *const r0597 = nequal(r0596, body.constant(0u));
            ir_if *f0593 = new(mem_ctx) ir_if(operand(r0597).val);
            exec_list *const f0593_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0593->then_instructions;

               ir_variable *const r0598 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0598, swizzle_x(r03D1), 0x01));

               ir_variable *const r0599 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0599, swizzle_x(r03D2), 0x01));

               ir_variable *const r059A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r059B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r059C = rshift(swizzle_y(r03D1), body.constant(int(19)));
               ir_expression *const r059D = bit_and(r059C, body.constant(4095u));
               ir_expression *const r059E = equal(r059D, body.constant(4094u));
               ir_expression *const r059F = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r05A0 = bit_and(swizzle_y(r03D1), body.constant(524287u));
               ir_expression *const r05A1 = nequal(r05A0, body.constant(0u));
               ir_expression *const r05A2 = logic_or(r059F, r05A1);
               body.emit(assign(r059B, logic_and(r059E, r05A2), 0x01));

               ir_variable *const r05A3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r05A4 = lshift(swizzle_y(r03D2), body.constant(int(1)));
               ir_expression *const r05A5 = lequal(body.constant(4292870144u), r05A4);
               ir_expression *const r05A6 = nequal(swizzle_x(r03D2), body.constant(0u));
               ir_expression *const r05A7 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
               ir_expression *const r05A8 = nequal(r05A7, body.constant(0u));
               ir_expression *const r05A9 = logic_or(r05A6, r05A8);
               body.emit(assign(r05A3, logic_and(r05A5, r05A9), 0x01));

               body.emit(assign(r0598, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

               body.emit(assign(r0599, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r05AB = lshift(swizzle_y(r03D1), body.constant(int(1)));
               ir_expression *const r05AC = lequal(body.constant(4292870144u), r05AB);
               ir_expression *const r05AD = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r05AE = bit_and(swizzle_y(r03D1), body.constant(1048575u));
               ir_expression *const r05AF = nequal(r05AE, body.constant(0u));
               ir_expression *const r05B0 = logic_or(r05AD, r05AF);
               ir_expression *const r05B1 = logic_and(r05AC, r05B0);
               ir_if *f05AA = new(mem_ctx) ir_if(operand(r05B1).val);
               exec_list *const f05AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05AA->then_instructions;

                  ir_variable *const r05B2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05B4 = logic_and(r059B, r05A3);
                  ir_if *f05B3 = new(mem_ctx) ir_if(operand(r05B4).val);
                  exec_list *const f05B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05B3->then_instructions;

                     body.emit(assign(r05B2, r0599, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05B3->else_instructions;

                     body.emit(assign(r05B2, r0598, 0x03));


                  body.instructions = f05B3_parent_instructions;
                  body.emit(f05B3);

                  /* END IF */

                  body.emit(assign(r059A, r05B2, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05AA->else_instructions;

                  body.emit(assign(r059A, r0599, 0x03));


               body.instructions = f05AA_parent_instructions;
               body.emit(f05AA);

               /* END IF */

               body.emit(assign(r03D4, r059A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0593->else_instructions;

               ir_constant_data r05B5_data;
               memset(&r05B5_data, 0, sizeof(ir_constant_data));
               r05B5_data.u[0] = 4294967295;
               r05B5_data.u[1] = 4294967295;
               ir_constant *const r05B5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r05B5_data);
               body.emit(assign(r03D4, r05B5, 0x03));


            body.instructions = f0593_parent_instructions;
            body.emit(f0593);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0591->else_instructions;

            /* IF CONDITION */
            ir_expression *const r05B7 = equal(r03DD, body.constant(int(0)));
            ir_if *f05B6 = new(mem_ctx) ir_if(operand(r05B7).val);
            exec_list *const f05B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B6->then_instructions;

               body.emit(assign(r03D7, body.constant(int(1)), 0x01));

               body.emit(assign(r03D6, body.constant(int(1)), 0x01));


            body.instructions = f05B6_parent_instructions;
            body.emit(f05B6);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r05B9 = less(r03D8, r03DA);
            ir_if *f05B8 = new(mem_ctx) ir_if(operand(r05B9).val);
            exec_list *const f05B8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B8->then_instructions;

               ir_variable *const r05BA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r05BB = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r05BB, sub(r03DB, r03D9), 0x01));

               ir_expression *const r05BC = sub(r03DA, r03D8);
               ir_expression *const r05BD = less(r03DB, r03D9);
               ir_expression *const r05BE = expr(ir_unop_b2i, r05BD);
               ir_expression *const r05BF = expr(ir_unop_i2u, r05BE);
               body.emit(assign(r05BA, sub(r05BC, r05BF), 0x01));

               body.emit(assign(r03DC, add(r03D7, body.constant(int(-1))), 0x01));

               ir_variable *const r05C0 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05C0, add(r03DC, body.constant(int(-10))), 0x01));

               ir_variable *const r05C1 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r05C1, r05BA, 0x01));

               ir_variable *const r05C2 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r05C2, r05BB, 0x01));

               ir_variable *const r05C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r05C3);
               ir_variable *const r05C4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C4);
               /* IF CONDITION */
               ir_expression *const r05C6 = equal(r05BA, body.constant(0u));
               ir_if *f05C5 = new(mem_ctx) ir_if(operand(r05C6).val);
               exec_list *const f05C5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05C5->then_instructions;

                  body.emit(assign(r05C1, r05BB, 0x01));

                  body.emit(assign(r05C2, body.constant(0u), 0x01));

                  body.emit(assign(r05C0, add(r05C0, body.constant(int(-32))), 0x01));


               body.instructions = f05C5_parent_instructions;
               body.emit(f05C5);

               /* END IF */

               ir_variable *const r05C7 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r05C7, r05C1, 0x01));

               ir_variable *const r05C8 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r05C9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C9);
               /* IF CONDITION */
               ir_expression *const r05CB = equal(r05C1, body.constant(0u));
               ir_if *f05CA = new(mem_ctx) ir_if(operand(r05CB).val);
               exec_list *const f05CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05CA->then_instructions;

                  body.emit(assign(r05C8, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05CA->else_instructions;

                  body.emit(assign(r05C9, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05CD = bit_and(r05C1, body.constant(4294901760u));
                  ir_expression *const r05CE = equal(r05CD, body.constant(0u));
                  ir_if *f05CC = new(mem_ctx) ir_if(operand(r05CE).val);
                  exec_list *const f05CC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CC->then_instructions;

                     body.emit(assign(r05C9, body.constant(int(16)), 0x01));

                     body.emit(assign(r05C7, lshift(r05C1, body.constant(int(16))), 0x01));


                  body.instructions = f05CC_parent_instructions;
                  body.emit(f05CC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D0 = bit_and(r05C7, body.constant(4278190080u));
                  ir_expression *const r05D1 = equal(r05D0, body.constant(0u));
                  ir_if *f05CF = new(mem_ctx) ir_if(operand(r05D1).val);
                  exec_list *const f05CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CF->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(8))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(8))), 0x01));


                  body.instructions = f05CF_parent_instructions;
                  body.emit(f05CF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D3 = bit_and(r05C7, body.constant(4026531840u));
                  ir_expression *const r05D4 = equal(r05D3, body.constant(0u));
                  ir_if *f05D2 = new(mem_ctx) ir_if(operand(r05D4).val);
                  exec_list *const f05D2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D2->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(4))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(4))), 0x01));


                  body.instructions = f05D2_parent_instructions;
                  body.emit(f05D2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D6 = bit_and(r05C7, body.constant(3221225472u));
                  ir_expression *const r05D7 = equal(r05D6, body.constant(0u));
                  ir_if *f05D5 = new(mem_ctx) ir_if(operand(r05D7).val);
                  exec_list *const f05D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D5->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(2))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(2))), 0x01));


                  body.instructions = f05D5_parent_instructions;
                  body.emit(f05D5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D9 = bit_and(r05C7, body.constant(2147483648u));
                  ir_expression *const r05DA = equal(r05D9, body.constant(0u));
                  ir_if *f05D8 = new(mem_ctx) ir_if(operand(r05DA).val);
                  exec_list *const f05D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D8->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(1))), 0x01));


                  body.instructions = f05D8_parent_instructions;
                  body.emit(f05D8);

                  /* END IF */

                  body.emit(assign(r05C8, r05C9, 0x01));


               body.instructions = f05CA_parent_instructions;
               body.emit(f05CA);

               /* END IF */

               body.emit(assign(r05C4, add(r05C8, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r05DC = lequal(body.constant(int(0)), r05C4);
               ir_if *f05DB = new(mem_ctx) ir_if(operand(r05DC).val);
               exec_list *const f05DB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05DB->then_instructions;

                  body.emit(assign(r05C3, body.constant(0u), 0x01));

                  ir_variable *const r05DD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r05DD, lshift(r05C2, r05C4), 0x01));

                  ir_variable *const r05DE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05E0 = equal(r05C4, body.constant(int(0)));
                  ir_if *f05DF = new(mem_ctx) ir_if(operand(r05E0).val);
                  exec_list *const f05DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05DF->then_instructions;

                     body.emit(assign(r05DE, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05DF->else_instructions;

                     ir_expression *const r05E1 = lshift(r05C1, r05C4);
                     ir_expression *const r05E2 = neg(r05C4);
                     ir_expression *const r05E3 = bit_and(r05E2, body.constant(int(31)));
                     ir_expression *const r05E4 = rshift(r05C2, r05E3);
                     body.emit(assign(r05DE, bit_or(r05E1, r05E4), 0x01));


                  body.instructions = f05DF_parent_instructions;
                  body.emit(f05DF);

                  /* END IF */

                  body.emit(assign(r05C1, r05DE, 0x01));

                  body.emit(assign(r05C2, r05DD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05DB->else_instructions;

                  ir_variable *const r05E5 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r05E5, body.constant(0u), 0x01));

                  ir_variable *const r05E6 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r05E6, neg(r05C4), 0x01));

                  ir_variable *const r05E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r05E7);
                  ir_variable *const r05E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r05E8);
                  ir_variable *const r05E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r05E9);
                  ir_variable *const r05EA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r05EB = neg(r05E6);
                  body.emit(assign(r05EA, bit_and(r05EB, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05ED = equal(r05E6, body.constant(int(0)));
                  ir_if *f05EC = new(mem_ctx) ir_if(operand(r05ED).val);
                  exec_list *const f05EC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05EC->then_instructions;

                     body.emit(assign(r05E7, r05E5, 0x01));

                     body.emit(assign(r05E8, r05C2, 0x01));

                     body.emit(assign(r05E9, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05EC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r05EF = less(r05E6, body.constant(int(32)));
                     ir_if *f05EE = new(mem_ctx) ir_if(operand(r05EF).val);
                     exec_list *const f05EE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f05EE->then_instructions;

                        body.emit(assign(r05E7, lshift(r05C2, r05EA), 0x01));

                        ir_expression *const r05F0 = lshift(r05C1, r05EA);
                        ir_expression *const r05F1 = rshift(r05C2, r05E6);
                        body.emit(assign(r05E8, bit_or(r05F0, r05F1), 0x01));

                        body.emit(assign(r05E9, rshift(r05C1, r05E6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f05EE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r05F3 = equal(r05E6, body.constant(int(32)));
                        ir_if *f05F2 = new(mem_ctx) ir_if(operand(r05F3).val);
                        exec_list *const f05F2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f05F2->then_instructions;

                           body.emit(assign(r05E7, r05C2, 0x01));

                           body.emit(assign(r05E8, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f05F2->else_instructions;

                           body.emit(assign(r05E5, bit_or(body.constant(0u), r05C2), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r05F5 = less(r05E6, body.constant(int(64)));
                           ir_if *f05F4 = new(mem_ctx) ir_if(operand(r05F5).val);
                           exec_list *const f05F4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f05F4->then_instructions;

                              body.emit(assign(r05E7, lshift(r05C1, r05EA), 0x01));

                              ir_expression *const r05F6 = bit_and(r05E6, body.constant(int(31)));
                              body.emit(assign(r05E8, rshift(r05C1, r05F6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f05F4->else_instructions;

                              ir_variable *const r05F7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r05F9 = equal(r05E6, body.constant(int(64)));
                              ir_if *f05F8 = new(mem_ctx) ir_if(operand(r05F9).val);
                              exec_list *const f05F8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f05F8->then_instructions;

                                 body.emit(assign(r05F7, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f05F8->else_instructions;

                                 ir_expression *const r05FA = nequal(r05C1, body.constant(0u));
                                 ir_expression *const r05FB = expr(ir_unop_b2i, r05FA);
                                 body.emit(assign(r05F7, expr(ir_unop_i2u, r05FB), 0x01));


                              body.instructions = f05F8_parent_instructions;
                              body.emit(f05F8);

                              /* END IF */

                              body.emit(assign(r05E7, r05F7, 0x01));

                              body.emit(assign(r05E8, body.constant(0u), 0x01));


                           body.instructions = f05F4_parent_instructions;
                           body.emit(f05F4);

                           /* END IF */


                        body.instructions = f05F2_parent_instructions;
                        body.emit(f05F2);

                        /* END IF */

                        body.emit(assign(r05E9, body.constant(0u), 0x01));


                     body.instructions = f05EE_parent_instructions;
                     body.emit(f05EE);

                     /* END IF */

                     ir_expression *const r05FC = nequal(r05E5, body.constant(0u));
                     ir_expression *const r05FD = expr(ir_unop_b2i, r05FC);
                     ir_expression *const r05FE = expr(ir_unop_i2u, r05FD);
                     body.emit(assign(r05E7, bit_or(r05E7, r05FE), 0x01));


                  body.instructions = f05EC_parent_instructions;
                  body.emit(f05EC);

                  /* END IF */

                  body.emit(assign(r05C1, r05E9, 0x01));

                  body.emit(assign(r05C2, r05E8, 0x01));

                  body.emit(assign(r05C3, r05E7, 0x01));


               body.instructions = f05DB_parent_instructions;
               body.emit(f05DB);

               /* END IF */

               body.emit(assign(r05C0, sub(r05C0, r05C4), 0x01));

               ir_variable *const r05FF = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05FF, r05C0, 0x01));

               ir_variable *const r0600 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0600, r05C1, 0x01));

               ir_variable *const r0601 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0601, r05C2, 0x01));

               ir_variable *const r0602 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0602, r05C3, 0x01));

               ir_variable *const r0603 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0603, body.constant(true), 0x01));

               ir_variable *const r0604 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0605 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0605);
               ir_expression *const r0606 = expr(ir_unop_u2i, r05C3);
               body.emit(assign(r0605, less(r0606, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0608 = lequal(body.constant(int(2045)), r05C0);
               ir_if *f0607 = new(mem_ctx) ir_if(operand(r0608).val);
               exec_list *const f0607_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0607->then_instructions;

                  ir_variable *const r0609 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r060B = less(body.constant(int(2045)), r05C0);
                  ir_if *f060A = new(mem_ctx) ir_if(operand(r060B).val);
                  exec_list *const f060A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f060A->then_instructions;

                     body.emit(assign(r0609, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f060A->else_instructions;

                     ir_variable *const r060C = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r060E = equal(r05C0, body.constant(int(2045)));
                     ir_if *f060D = new(mem_ctx) ir_if(operand(r060E).val);
                     exec_list *const f060D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f060D->then_instructions;

                        ir_expression *const r060F = equal(body.constant(2097151u), r05C1);
                        ir_expression *const r0610 = equal(body.constant(4294967295u), r05C2);
                        body.emit(assign(r060C, logic_and(r060F, r0610), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f060D->else_instructions;

                        body.emit(assign(r060C, body.constant(false), 0x01));


                     body.instructions = f060D_parent_instructions;
                     body.emit(f060D);

                     /* END IF */

                     body.emit(assign(r0609, logic_and(r060C, r0605), 0x01));


                  body.instructions = f060A_parent_instructions;
                  body.emit(f060A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0611 = new(mem_ctx) ir_if(operand(r0609).val);
                  exec_list *const f0611_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0611->then_instructions;

                     ir_variable *const r0612 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0612);
                     ir_expression *const r0613 = lshift(r03D3, body.constant(int(31)));
                     body.emit(assign(r0612, add(r0613, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0612, body.constant(0u), 0x01));

                     body.emit(assign(r0604, r0612, 0x03));

                     body.emit(assign(r0603, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0611->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0615 = less(r05C0, body.constant(int(0)));
                     ir_if *f0614 = new(mem_ctx) ir_if(operand(r0615).val);
                     exec_list *const f0614_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0614->then_instructions;

                        ir_variable *const r0616 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0616, r05C3, 0x01));

                        ir_variable *const r0617 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0617, neg(r05C0), 0x01));

                        ir_variable *const r0618 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0618);
                        ir_variable *const r0619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0619);
                        ir_variable *const r061A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r061A);
                        ir_variable *const r061B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r061C = neg(r0617);
                        body.emit(assign(r061B, bit_and(r061C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r061E = equal(r0617, body.constant(int(0)));
                        ir_if *f061D = new(mem_ctx) ir_if(operand(r061E).val);
                        exec_list *const f061D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f061D->then_instructions;

                           body.emit(assign(r0618, r05C3, 0x01));

                           body.emit(assign(r0619, r05C2, 0x01));

                           body.emit(assign(r061A, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f061D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0620 = less(r0617, body.constant(int(32)));
                           ir_if *f061F = new(mem_ctx) ir_if(operand(r0620).val);
                           exec_list *const f061F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f061F->then_instructions;

                              body.emit(assign(r0618, lshift(r05C2, r061B), 0x01));

                              ir_expression *const r0621 = lshift(r05C1, r061B);
                              ir_expression *const r0622 = rshift(r05C2, r0617);
                              body.emit(assign(r0619, bit_or(r0621, r0622), 0x01));

                              body.emit(assign(r061A, rshift(r05C1, r0617), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f061F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0624 = equal(r0617, body.constant(int(32)));
                              ir_if *f0623 = new(mem_ctx) ir_if(operand(r0624).val);
                              exec_list *const f0623_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0623->then_instructions;

                                 body.emit(assign(r0618, r05C2, 0x01));

                                 body.emit(assign(r0619, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0623->else_instructions;

                                 body.emit(assign(r0616, bit_or(r05C3, r05C2), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0626 = less(r0617, body.constant(int(64)));
                                 ir_if *f0625 = new(mem_ctx) ir_if(operand(r0626).val);
                                 exec_list *const f0625_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0625->then_instructions;

                                    body.emit(assign(r0618, lshift(r05C1, r061B), 0x01));

                                    ir_expression *const r0627 = bit_and(r0617, body.constant(int(31)));
                                    body.emit(assign(r0619, rshift(r05C1, r0627), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0625->else_instructions;

                                    ir_variable *const r0628 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r062A = equal(r0617, body.constant(int(64)));
                                    ir_if *f0629 = new(mem_ctx) ir_if(operand(r062A).val);
                                    exec_list *const f0629_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0629->then_instructions;

                                       body.emit(assign(r0628, r05C1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0629->else_instructions;

                                       ir_expression *const r062B = nequal(r05C1, body.constant(0u));
                                       ir_expression *const r062C = expr(ir_unop_b2i, r062B);
                                       body.emit(assign(r0628, expr(ir_unop_i2u, r062C), 0x01));


                                    body.instructions = f0629_parent_instructions;
                                    body.emit(f0629);

                                    /* END IF */

                                    body.emit(assign(r0618, r0628, 0x01));

                                    body.emit(assign(r0619, body.constant(0u), 0x01));


                                 body.instructions = f0625_parent_instructions;
                                 body.emit(f0625);

                                 /* END IF */


                              body.instructions = f0623_parent_instructions;
                              body.emit(f0623);

                              /* END IF */

                              body.emit(assign(r061A, body.constant(0u), 0x01));


                           body.instructions = f061F_parent_instructions;
                           body.emit(f061F);

                           /* END IF */

                           ir_expression *const r062D = nequal(r0616, body.constant(0u));
                           ir_expression *const r062E = expr(ir_unop_b2i, r062D);
                           ir_expression *const r062F = expr(ir_unop_i2u, r062E);
                           body.emit(assign(r0618, bit_or(r0618, r062F), 0x01));


                        body.instructions = f061D_parent_instructions;
                        body.emit(f061D);

                        /* END IF */

                        body.emit(assign(r0600, r061A, 0x01));

                        body.emit(assign(r0601, r0619, 0x01));

                        body.emit(assign(r0602, r0618, 0x01));

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));

                        body.emit(assign(r0605, less(r0618, body.constant(0u)), 0x01));


                     body.instructions = f0614_parent_instructions;
                     body.emit(f0614);

                     /* END IF */


                  body.instructions = f0611_parent_instructions;
                  body.emit(f0611);

                  /* END IF */


               body.instructions = f0607_parent_instructions;
               body.emit(f0607);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0630 = new(mem_ctx) ir_if(operand(r0603).val);
               exec_list *const f0630_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0630->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0631 = new(mem_ctx) ir_if(operand(r0605).val);
                  exec_list *const f0631_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0631->then_instructions;

                     ir_variable *const r0632 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0632, add(r0601, body.constant(1u)), 0x01));

                     ir_expression *const r0633 = less(r0632, r0601);
                     ir_expression *const r0634 = expr(ir_unop_b2i, r0633);
                     ir_expression *const r0635 = expr(ir_unop_i2u, r0634);
                     body.emit(assign(r0600, add(r0600, r0635), 0x01));

                     ir_expression *const r0636 = equal(r0602, body.constant(0u));
                     ir_expression *const r0637 = expr(ir_unop_b2i, r0636);
                     ir_expression *const r0638 = expr(ir_unop_i2u, r0637);
                     ir_expression *const r0639 = add(r0602, r0638);
                     ir_expression *const r063A = bit_and(r0639, body.constant(1u));
                     ir_expression *const r063B = expr(ir_unop_bit_not, r063A);
                     body.emit(assign(r0601, bit_and(r0632, r063B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0631->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r063D = bit_or(r0600, r0601);
                     ir_expression *const r063E = equal(r063D, body.constant(0u));
                     ir_if *f063C = new(mem_ctx) ir_if(operand(r063E).val);
                     exec_list *const f063C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f063C->then_instructions;

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));


                     body.instructions = f063C_parent_instructions;
                     body.emit(f063C);

                     /* END IF */


                  body.instructions = f0631_parent_instructions;
                  body.emit(f0631);

                  /* END IF */

                  ir_variable *const r063F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r063F);
                  ir_expression *const r0640 = lshift(r03D3, body.constant(int(31)));
                  ir_expression *const r0641 = expr(ir_unop_i2u, r05FF);
                  ir_expression *const r0642 = lshift(r0641, body.constant(int(20)));
                  ir_expression *const r0643 = add(r0640, r0642);
                  body.emit(assign(r063F, add(r0643, r0600), 0x02));

                  body.emit(assign(r063F, r0601, 0x01));

                  body.emit(assign(r0604, r063F, 0x03));

                  body.emit(assign(r0603, body.constant(false), 0x01));


               body.instructions = f0630_parent_instructions;
               body.emit(f0630);

               /* END IF */

               body.emit(assign(r03D4, r0604, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f05B8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0645 = less(r03DA, r03D8);
               ir_if *f0644 = new(mem_ctx) ir_if(operand(r0645).val);
               exec_list *const f0644_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0644->then_instructions;

                  ir_variable *const r0646 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0647 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0647, sub(r03D9, r03DB), 0x01));

                  ir_expression *const r0648 = sub(r03D8, r03DA);
                  ir_expression *const r0649 = less(r03D9, r03DB);
                  ir_expression *const r064A = expr(ir_unop_b2i, r0649);
                  ir_expression *const r064B = expr(ir_unop_i2u, r064A);
                  body.emit(assign(r0646, sub(r0648, r064B), 0x01));

                  body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

                  body.emit(assign(r03DC, add(r03D6, body.constant(int(-1))), 0x01));

                  ir_variable *const r064C = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r064C, add(r03DC, body.constant(int(-10))), 0x01));

                  ir_variable *const r064D = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r064D, r0646, 0x01));

                  ir_variable *const r064E = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r064E, r0647, 0x01));

                  ir_variable *const r064F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r064F);
                  ir_variable *const r0650 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0650);
                  /* IF CONDITION */
                  ir_expression *const r0652 = equal(r0646, body.constant(0u));
                  ir_if *f0651 = new(mem_ctx) ir_if(operand(r0652).val);
                  exec_list *const f0651_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0651->then_instructions;

                     body.emit(assign(r064D, r0647, 0x01));

                     body.emit(assign(r064E, body.constant(0u), 0x01));

                     body.emit(assign(r064C, add(r064C, body.constant(int(-32))), 0x01));


                  body.instructions = f0651_parent_instructions;
                  body.emit(f0651);

                  /* END IF */

                  ir_variable *const r0653 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0653, r064D, 0x01));

                  ir_variable *const r0654 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0655 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0655);
                  /* IF CONDITION */
                  ir_expression *const r0657 = equal(r064D, body.constant(0u));
                  ir_if *f0656 = new(mem_ctx) ir_if(operand(r0657).val);
                  exec_list *const f0656_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0656->then_instructions;

                     body.emit(assign(r0654, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0656->else_instructions;

                     body.emit(assign(r0655, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0659 = bit_and(r064D, body.constant(4294901760u));
                     ir_expression *const r065A = equal(r0659, body.constant(0u));
                     ir_if *f0658 = new(mem_ctx) ir_if(operand(r065A).val);
                     exec_list *const f0658_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0658->then_instructions;

                        body.emit(assign(r0655, body.constant(int(16)), 0x01));

                        body.emit(assign(r0653, lshift(r064D, body.constant(int(16))), 0x01));


                     body.instructions = f0658_parent_instructions;
                     body.emit(f0658);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065C = bit_and(r0653, body.constant(4278190080u));
                     ir_expression *const r065D = equal(r065C, body.constant(0u));
                     ir_if *f065B = new(mem_ctx) ir_if(operand(r065D).val);
                     exec_list *const f065B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065B->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(8))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(8))), 0x01));


                     body.instructions = f065B_parent_instructions;
                     body.emit(f065B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065F = bit_and(r0653, body.constant(4026531840u));
                     ir_expression *const r0660 = equal(r065F, body.constant(0u));
                     ir_if *f065E = new(mem_ctx) ir_if(operand(r0660).val);
                     exec_list *const f065E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065E->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(4))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(4))), 0x01));


                     body.instructions = f065E_parent_instructions;
                     body.emit(f065E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0662 = bit_and(r0653, body.constant(3221225472u));
                     ir_expression *const r0663 = equal(r0662, body.constant(0u));
                     ir_if *f0661 = new(mem_ctx) ir_if(operand(r0663).val);
                     exec_list *const f0661_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0661->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(2))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(2))), 0x01));


                     body.instructions = f0661_parent_instructions;
                     body.emit(f0661);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0665 = bit_and(r0653, body.constant(2147483648u));
                     ir_expression *const r0666 = equal(r0665, body.constant(0u));
                     ir_if *f0664 = new(mem_ctx) ir_if(operand(r0666).val);
                     exec_list *const f0664_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0664->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(1))), 0x01));


                     body.instructions = f0664_parent_instructions;
                     body.emit(f0664);

                     /* END IF */

                     body.emit(assign(r0654, r0655, 0x01));


                  body.instructions = f0656_parent_instructions;
                  body.emit(f0656);

                  /* END IF */

                  body.emit(assign(r0650, add(r0654, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0668 = lequal(body.constant(int(0)), r0650);
                  ir_if *f0667 = new(mem_ctx) ir_if(operand(r0668).val);
                  exec_list *const f0667_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0667->then_instructions;

                     body.emit(assign(r064F, body.constant(0u), 0x01));

                     ir_variable *const r0669 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0669, lshift(r064E, r0650), 0x01));

                     ir_variable *const r066A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r066C = equal(r0650, body.constant(int(0)));
                     ir_if *f066B = new(mem_ctx) ir_if(operand(r066C).val);
                     exec_list *const f066B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f066B->then_instructions;

                        body.emit(assign(r066A, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f066B->else_instructions;

                        ir_expression *const r066D = lshift(r064D, r0650);
                        ir_expression *const r066E = neg(r0650);
                        ir_expression *const r066F = bit_and(r066E, body.constant(int(31)));
                        ir_expression *const r0670 = rshift(r064E, r066F);
                        body.emit(assign(r066A, bit_or(r066D, r0670), 0x01));


                     body.instructions = f066B_parent_instructions;
                     body.emit(f066B);

                     /* END IF */

                     body.emit(assign(r064D, r066A, 0x01));

                     body.emit(assign(r064E, r0669, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0667->else_instructions;

                     ir_variable *const r0671 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0671, body.constant(0u), 0x01));

                     ir_variable *const r0672 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0672, neg(r0650), 0x01));

                     ir_variable *const r0673 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0673);
                     ir_variable *const r0674 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0674);
                     ir_variable *const r0675 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0675);
                     ir_variable *const r0676 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0677 = neg(r0672);
                     body.emit(assign(r0676, bit_and(r0677, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0679 = equal(r0672, body.constant(int(0)));
                     ir_if *f0678 = new(mem_ctx) ir_if(operand(r0679).val);
                     exec_list *const f0678_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0678->then_instructions;

                        body.emit(assign(r0673, r0671, 0x01));

                        body.emit(assign(r0674, r064E, 0x01));

                        body.emit(assign(r0675, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0678->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r067B = less(r0672, body.constant(int(32)));
                        ir_if *f067A = new(mem_ctx) ir_if(operand(r067B).val);
                        exec_list *const f067A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f067A->then_instructions;

                           body.emit(assign(r0673, lshift(r064E, r0676), 0x01));

                           ir_expression *const r067C = lshift(r064D, r0676);
                           ir_expression *const r067D = rshift(r064E, r0672);
                           body.emit(assign(r0674, bit_or(r067C, r067D), 0x01));

                           body.emit(assign(r0675, rshift(r064D, r0672), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f067A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r067F = equal(r0672, body.constant(int(32)));
                           ir_if *f067E = new(mem_ctx) ir_if(operand(r067F).val);
                           exec_list *const f067E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f067E->then_instructions;

                              body.emit(assign(r0673, r064E, 0x01));

                              body.emit(assign(r0674, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f067E->else_instructions;

                              body.emit(assign(r0671, bit_or(body.constant(0u), r064E), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0681 = less(r0672, body.constant(int(64)));
                              ir_if *f0680 = new(mem_ctx) ir_if(operand(r0681).val);
                              exec_list *const f0680_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0680->then_instructions;

                                 body.emit(assign(r0673, lshift(r064D, r0676), 0x01));

                                 ir_expression *const r0682 = bit_and(r0672, body.constant(int(31)));
                                 body.emit(assign(r0674, rshift(r064D, r0682), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0680->else_instructions;

                                 ir_variable *const r0683 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0685 = equal(r0672, body.constant(int(64)));
                                 ir_if *f0684 = new(mem_ctx) ir_if(operand(r0685).val);
                                 exec_list *const f0684_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0684->then_instructions;

                                    body.emit(assign(r0683, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0684->else_instructions;

                                    ir_expression *const r0686 = nequal(r064D, body.constant(0u));
                                    ir_expression *const r0687 = expr(ir_unop_b2i, r0686);
                                    body.emit(assign(r0683, expr(ir_unop_i2u, r0687), 0x01));


                                 body.instructions = f0684_parent_instructions;
                                 body.emit(f0684);

                                 /* END IF */

                                 body.emit(assign(r0673, r0683, 0x01));

                                 body.emit(assign(r0674, body.constant(0u), 0x01));


                              body.instructions = f0680_parent_instructions;
                              body.emit(f0680);

                              /* END IF */


                           body.instructions = f067E_parent_instructions;
                           body.emit(f067E);

                           /* END IF */

                           body.emit(assign(r0675, body.constant(0u), 0x01));


                        body.instructions = f067A_parent_instructions;
                        body.emit(f067A);

                        /* END IF */

                        ir_expression *const r0688 = nequal(r0671, body.constant(0u));
                        ir_expression *const r0689 = expr(ir_unop_b2i, r0688);
                        ir_expression *const r068A = expr(ir_unop_i2u, r0689);
                        body.emit(assign(r0673, bit_or(r0673, r068A), 0x01));


                     body.instructions = f0678_parent_instructions;
                     body.emit(f0678);

                     /* END IF */

                     body.emit(assign(r064D, r0675, 0x01));

                     body.emit(assign(r064E, r0674, 0x01));

                     body.emit(assign(r064F, r0673, 0x01));


                  body.instructions = f0667_parent_instructions;
                  body.emit(f0667);

                  /* END IF */

                  body.emit(assign(r064C, sub(r064C, r0650), 0x01));

                  ir_variable *const r068B = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r068B, r064C, 0x01));

                  ir_variable *const r068C = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r068C, r064D, 0x01));

                  ir_variable *const r068D = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r068D, r064E, 0x01));

                  ir_variable *const r068E = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r068E, r064F, 0x01));

                  ir_variable *const r068F = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r068F, body.constant(true), 0x01));

                  ir_variable *const r0690 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0691 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0691);
                  ir_expression *const r0692 = expr(ir_unop_u2i, r064F);
                  body.emit(assign(r0691, less(r0692, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0694 = lequal(body.constant(int(2045)), r064C);
                  ir_if *f0693 = new(mem_ctx) ir_if(operand(r0694).val);
                  exec_list *const f0693_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0693->then_instructions;

                     ir_variable *const r0695 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0697 = less(body.constant(int(2045)), r064C);
                     ir_if *f0696 = new(mem_ctx) ir_if(operand(r0697).val);
                     exec_list *const f0696_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0696->then_instructions;

                        body.emit(assign(r0695, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0696->else_instructions;

                        ir_variable *const r0698 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r069A = equal(r064C, body.constant(int(2045)));
                        ir_if *f0699 = new(mem_ctx) ir_if(operand(r069A).val);
                        exec_list *const f0699_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0699->then_instructions;

                           ir_expression *const r069B = equal(body.constant(2097151u), r064D);
                           ir_expression *const r069C = equal(body.constant(4294967295u), r064E);
                           body.emit(assign(r0698, logic_and(r069B, r069C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0699->else_instructions;

                           body.emit(assign(r0698, body.constant(false), 0x01));


                        body.instructions = f0699_parent_instructions;
                        body.emit(f0699);

                        /* END IF */

                        body.emit(assign(r0695, logic_and(r0698, r0691), 0x01));


                     body.instructions = f0696_parent_instructions;
                     body.emit(f0696);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f069D = new(mem_ctx) ir_if(operand(r0695).val);
                     exec_list *const f069D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f069D->then_instructions;

                        ir_variable *const r069E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r069E);
                        ir_expression *const r069F = lshift(r03D3, body.constant(int(31)));
                        body.emit(assign(r069E, add(r069F, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r069E, body.constant(0u), 0x01));

                        body.emit(assign(r0690, r069E, 0x03));

                        body.emit(assign(r068F, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f069D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06A1 = less(r064C, body.constant(int(0)));
                        ir_if *f06A0 = new(mem_ctx) ir_if(operand(r06A1).val);
                        exec_list *const f06A0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06A0->then_instructions;

                           ir_variable *const r06A2 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r06A2, r064F, 0x01));

                           ir_variable *const r06A3 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r06A3, neg(r064C), 0x01));

                           ir_variable *const r06A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r06A4);
                           ir_variable *const r06A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r06A5);
                           ir_variable *const r06A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r06A6);
                           ir_variable *const r06A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r06A8 = neg(r06A3);
                           body.emit(assign(r06A7, bit_and(r06A8, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r06AA = equal(r06A3, body.constant(int(0)));
                           ir_if *f06A9 = new(mem_ctx) ir_if(operand(r06AA).val);
                           exec_list *const f06A9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f06A9->then_instructions;

                              body.emit(assign(r06A4, r064F, 0x01));

                              body.emit(assign(r06A5, r064E, 0x01));

                              body.emit(assign(r06A6, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f06A9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r06AC = less(r06A3, body.constant(int(32)));
                              ir_if *f06AB = new(mem_ctx) ir_if(operand(r06AC).val);
                              exec_list *const f06AB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f06AB->then_instructions;

                                 body.emit(assign(r06A4, lshift(r064E, r06A7), 0x01));

                                 ir_expression *const r06AD = lshift(r064D, r06A7);
                                 ir_expression *const r06AE = rshift(r064E, r06A3);
                                 body.emit(assign(r06A5, bit_or(r06AD, r06AE), 0x01));

                                 body.emit(assign(r06A6, rshift(r064D, r06A3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f06AB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r06B0 = equal(r06A3, body.constant(int(32)));
                                 ir_if *f06AF = new(mem_ctx) ir_if(operand(r06B0).val);
                                 exec_list *const f06AF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f06AF->then_instructions;

                                    body.emit(assign(r06A4, r064E, 0x01));

                                    body.emit(assign(r06A5, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f06AF->else_instructions;

                                    body.emit(assign(r06A2, bit_or(r064F, r064E), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r06B2 = less(r06A3, body.constant(int(64)));
                                    ir_if *f06B1 = new(mem_ctx) ir_if(operand(r06B2).val);
                                    exec_list *const f06B1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f06B1->then_instructions;

                                       body.emit(assign(r06A4, lshift(r064D, r06A7), 0x01));

                                       ir_expression *const r06B3 = bit_and(r06A3, body.constant(int(31)));
                                       body.emit(assign(r06A5, rshift(r064D, r06B3), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f06B1->else_instructions;

                                       ir_variable *const r06B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r06B6 = equal(r06A3, body.constant(int(64)));
                                       ir_if *f06B5 = new(mem_ctx) ir_if(operand(r06B6).val);
                                       exec_list *const f06B5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f06B5->then_instructions;

                                          body.emit(assign(r06B4, r064D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f06B5->else_instructions;

                                          ir_expression *const r06B7 = nequal(r064D, body.constant(0u));
                                          ir_expression *const r06B8 = expr(ir_unop_b2i, r06B7);
                                          body.emit(assign(r06B4, expr(ir_unop_i2u, r06B8), 0x01));


                                       body.instructions = f06B5_parent_instructions;
                                       body.emit(f06B5);

                                       /* END IF */

                                       body.emit(assign(r06A4, r06B4, 0x01));

                                       body.emit(assign(r06A5, body.constant(0u), 0x01));


                                    body.instructions = f06B1_parent_instructions;
                                    body.emit(f06B1);

                                    /* END IF */


                                 body.instructions = f06AF_parent_instructions;
                                 body.emit(f06AF);

                                 /* END IF */

                                 body.emit(assign(r06A6, body.constant(0u), 0x01));


                              body.instructions = f06AB_parent_instructions;
                              body.emit(f06AB);

                              /* END IF */

                              ir_expression *const r06B9 = nequal(r06A2, body.constant(0u));
                              ir_expression *const r06BA = expr(ir_unop_b2i, r06B9);
                              ir_expression *const r06BB = expr(ir_unop_i2u, r06BA);
                              body.emit(assign(r06A4, bit_or(r06A4, r06BB), 0x01));


                           body.instructions = f06A9_parent_instructions;
                           body.emit(f06A9);

                           /* END IF */

                           body.emit(assign(r068C, r06A6, 0x01));

                           body.emit(assign(r068D, r06A5, 0x01));

                           body.emit(assign(r068E, r06A4, 0x01));

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));

                           body.emit(assign(r0691, less(r06A4, body.constant(0u)), 0x01));


                        body.instructions = f06A0_parent_instructions;
                        body.emit(f06A0);

                        /* END IF */


                     body.instructions = f069D_parent_instructions;
                     body.emit(f069D);

                     /* END IF */


                  body.instructions = f0693_parent_instructions;
                  body.emit(f0693);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f06BC = new(mem_ctx) ir_if(operand(r068F).val);
                  exec_list *const f06BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06BC->then_instructions;

                     /* IF CONDITION */
                     ir_if *f06BD = new(mem_ctx) ir_if(operand(r0691).val);
                     exec_list *const f06BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06BD->then_instructions;

                        ir_variable *const r06BE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r06BE, add(r068D, body.constant(1u)), 0x01));

                        ir_expression *const r06BF = less(r06BE, r068D);
                        ir_expression *const r06C0 = expr(ir_unop_b2i, r06BF);
                        ir_expression *const r06C1 = expr(ir_unop_i2u, r06C0);
                        body.emit(assign(r068C, add(r068C, r06C1), 0x01));

                        ir_expression *const r06C2 = equal(r068E, body.constant(0u));
                        ir_expression *const r06C3 = expr(ir_unop_b2i, r06C2);
                        ir_expression *const r06C4 = expr(ir_unop_i2u, r06C3);
                        ir_expression *const r06C5 = add(r068E, r06C4);
                        ir_expression *const r06C6 = bit_and(r06C5, body.constant(1u));
                        ir_expression *const r06C7 = expr(ir_unop_bit_not, r06C6);
                        body.emit(assign(r068D, bit_and(r06BE, r06C7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06BD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06C9 = bit_or(r068C, r068D);
                        ir_expression *const r06CA = equal(r06C9, body.constant(0u));
                        ir_if *f06C8 = new(mem_ctx) ir_if(operand(r06CA).val);
                        exec_list *const f06C8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06C8->then_instructions;

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));


                        body.instructions = f06C8_parent_instructions;
                        body.emit(f06C8);

                        /* END IF */


                     body.instructions = f06BD_parent_instructions;
                     body.emit(f06BD);

                     /* END IF */

                     ir_variable *const r06CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r06CB);
                     ir_expression *const r06CC = lshift(r03D3, body.constant(int(31)));
                     ir_expression *const r06CD = expr(ir_unop_i2u, r068B);
                     ir_expression *const r06CE = lshift(r06CD, body.constant(int(20)));
                     ir_expression *const r06CF = add(r06CC, r06CE);
                     body.emit(assign(r06CB, add(r06CF, r068C), 0x02));

                     body.emit(assign(r06CB, r068D, 0x01));

                     body.emit(assign(r0690, r06CB, 0x03));

                     body.emit(assign(r068F, body.constant(false), 0x01));


                  body.instructions = f06BC_parent_instructions;
                  body.emit(f06BC);

                  /* END IF */

                  body.emit(assign(r03D4, r0690, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0644->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r06D1 = less(r03D9, r03DB);
                  ir_if *f06D0 = new(mem_ctx) ir_if(operand(r06D1).val);
                  exec_list *const f06D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06D0->then_instructions;

                     ir_variable *const r06D2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r06D3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r06D3, sub(r03DB, r03D9), 0x01));

                     ir_expression *const r06D4 = sub(r03DA, r03D8);
                     ir_expression *const r06D5 = less(r03DB, r03D9);
                     ir_expression *const r06D6 = expr(ir_unop_b2i, r06D5);
                     ir_expression *const r06D7 = expr(ir_unop_i2u, r06D6);
                     body.emit(assign(r06D2, sub(r06D4, r06D7), 0x01));

                     body.emit(assign(r03DC, add(r03D7, body.constant(int(-1))), 0x01));

                     ir_variable *const r06D8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r06D8, add(r03DC, body.constant(int(-10))), 0x01));

                     ir_variable *const r06D9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r06D9, r06D2, 0x01));

                     ir_variable *const r06DA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r06DA, r06D3, 0x01));

                     ir_variable *const r06DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r06DB);
                     ir_variable *const r06DC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06DC);
                     /* IF CONDITION */
                     ir_expression *const r06DE = equal(r06D2, body.constant(0u));
                     ir_if *f06DD = new(mem_ctx) ir_if(operand(r06DE).val);
                     exec_list *const f06DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06DD->then_instructions;

                        body.emit(assign(r06D9, r06D3, 0x01));

                        body.emit(assign(r06DA, body.constant(0u), 0x01));

                        body.emit(assign(r06D8, add(r06D8, body.constant(int(-32))), 0x01));


                     body.instructions = f06DD_parent_instructions;
                     body.emit(f06DD);

                     /* END IF */

                     ir_variable *const r06DF = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r06DF, r06D9, 0x01));

                     ir_variable *const r06E0 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r06E1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06E1);
                     /* IF CONDITION */
                     ir_expression *const r06E3 = equal(r06D9, body.constant(0u));
                     ir_if *f06E2 = new(mem_ctx) ir_if(operand(r06E3).val);
                     exec_list *const f06E2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06E2->then_instructions;

                        body.emit(assign(r06E0, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06E2->else_instructions;

                        body.emit(assign(r06E1, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r06E5 = bit_and(r06D9, body.constant(4294901760u));
                        ir_expression *const r06E6 = equal(r06E5, body.constant(0u));
                        ir_if *f06E4 = new(mem_ctx) ir_if(operand(r06E6).val);
                        exec_list *const f06E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E4->then_instructions;

                           body.emit(assign(r06E1, body.constant(int(16)), 0x01));

                           body.emit(assign(r06DF, lshift(r06D9, body.constant(int(16))), 0x01));


                        body.instructions = f06E4_parent_instructions;
                        body.emit(f06E4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06E8 = bit_and(r06DF, body.constant(4278190080u));
                        ir_expression *const r06E9 = equal(r06E8, body.constant(0u));
                        ir_if *f06E7 = new(mem_ctx) ir_if(operand(r06E9).val);
                        exec_list *const f06E7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E7->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(8))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(8))), 0x01));


                        body.instructions = f06E7_parent_instructions;
                        body.emit(f06E7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EB = bit_and(r06DF, body.constant(4026531840u));
                        ir_expression *const r06EC = equal(r06EB, body.constant(0u));
                        ir_if *f06EA = new(mem_ctx) ir_if(operand(r06EC).val);
                        exec_list *const f06EA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06EA->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(4))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(4))), 0x01));


                        body.instructions = f06EA_parent_instructions;
                        body.emit(f06EA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EE = bit_and(r06DF, body.constant(3221225472u));
                        ir_expression *const r06EF = equal(r06EE, body.constant(0u));
                        ir_if *f06ED = new(mem_ctx) ir_if(operand(r06EF).val);
                        exec_list *const f06ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06ED->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(2))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(2))), 0x01));


                        body.instructions = f06ED_parent_instructions;
                        body.emit(f06ED);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06F1 = bit_and(r06DF, body.constant(2147483648u));
                        ir_expression *const r06F2 = equal(r06F1, body.constant(0u));
                        ir_if *f06F0 = new(mem_ctx) ir_if(operand(r06F2).val);
                        exec_list *const f06F0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F0->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(1))), 0x01));


                        body.instructions = f06F0_parent_instructions;
                        body.emit(f06F0);

                        /* END IF */

                        body.emit(assign(r06E0, r06E1, 0x01));


                     body.instructions = f06E2_parent_instructions;
                     body.emit(f06E2);

                     /* END IF */

                     body.emit(assign(r06DC, add(r06E0, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r06F4 = lequal(body.constant(int(0)), r06DC);
                     ir_if *f06F3 = new(mem_ctx) ir_if(operand(r06F4).val);
                     exec_list *const f06F3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06F3->then_instructions;

                        body.emit(assign(r06DB, body.constant(0u), 0x01));

                        ir_variable *const r06F5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r06F5, lshift(r06DA, r06DC), 0x01));

                        ir_variable *const r06F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r06F8 = equal(r06DC, body.constant(int(0)));
                        ir_if *f06F7 = new(mem_ctx) ir_if(operand(r06F8).val);
                        exec_list *const f06F7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F7->then_instructions;

                           body.emit(assign(r06F6, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f06F7->else_instructions;

                           ir_expression *const r06F9 = lshift(r06D9, r06DC);
                           ir_expression *const r06FA = neg(r06DC);
                           ir_expression *const r06FB = bit_and(r06FA, body.constant(int(31)));
                           ir_expression *const r06FC = rshift(r06DA, r06FB);
                           body.emit(assign(r06F6, bit_or(r06F9, r06FC), 0x01));


                        body.instructions = f06F7_parent_instructions;
                        body.emit(f06F7);

                        /* END IF */

                        body.emit(assign(r06D9, r06F6, 0x01));

                        body.emit(assign(r06DA, r06F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06F3->else_instructions;

                        ir_variable *const r06FD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r06FD, body.constant(0u), 0x01));

                        ir_variable *const r06FE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r06FE, neg(r06DC), 0x01));

                        ir_variable *const r06FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r06FF);
                        ir_variable *const r0700 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0700);
                        ir_variable *const r0701 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0701);
                        ir_variable *const r0702 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0703 = neg(r06FE);
                        body.emit(assign(r0702, bit_and(r0703, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0705 = equal(r06FE, body.constant(int(0)));
                        ir_if *f0704 = new(mem_ctx) ir_if(operand(r0705).val);
                        exec_list *const f0704_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0704->then_instructions;

                           body.emit(assign(r06FF, r06FD, 0x01));

                           body.emit(assign(r0700, r06DA, 0x01));

                           body.emit(assign(r0701, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0704->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0707 = less(r06FE, body.constant(int(32)));
                           ir_if *f0706 = new(mem_ctx) ir_if(operand(r0707).val);
                           exec_list *const f0706_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0706->then_instructions;

                              body.emit(assign(r06FF, lshift(r06DA, r0702), 0x01));

                              ir_expression *const r0708 = lshift(r06D9, r0702);
                              ir_expression *const r0709 = rshift(r06DA, r06FE);
                              body.emit(assign(r0700, bit_or(r0708, r0709), 0x01));

                              body.emit(assign(r0701, rshift(r06D9, r06FE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0706->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r070B = equal(r06FE, body.constant(int(32)));
                              ir_if *f070A = new(mem_ctx) ir_if(operand(r070B).val);
                              exec_list *const f070A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f070A->then_instructions;

                                 body.emit(assign(r06FF, r06DA, 0x01));

                                 body.emit(assign(r0700, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f070A->else_instructions;

                                 body.emit(assign(r06FD, bit_or(body.constant(0u), r06DA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r070D = less(r06FE, body.constant(int(64)));
                                 ir_if *f070C = new(mem_ctx) ir_if(operand(r070D).val);
                                 exec_list *const f070C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f070C->then_instructions;

                                    body.emit(assign(r06FF, lshift(r06D9, r0702), 0x01));

                                    ir_expression *const r070E = bit_and(r06FE, body.constant(int(31)));
                                    body.emit(assign(r0700, rshift(r06D9, r070E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f070C->else_instructions;

                                    ir_variable *const r070F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0711 = equal(r06FE, body.constant(int(64)));
                                    ir_if *f0710 = new(mem_ctx) ir_if(operand(r0711).val);
                                    exec_list *const f0710_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0710->then_instructions;

                                       body.emit(assign(r070F, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0710->else_instructions;

                                       ir_expression *const r0712 = nequal(r06D9, body.constant(0u));
                                       ir_expression *const r0713 = expr(ir_unop_b2i, r0712);
                                       body.emit(assign(r070F, expr(ir_unop_i2u, r0713), 0x01));


                                    body.instructions = f0710_parent_instructions;
                                    body.emit(f0710);

                                    /* END IF */

                                    body.emit(assign(r06FF, r070F, 0x01));

                                    body.emit(assign(r0700, body.constant(0u), 0x01));


                                 body.instructions = f070C_parent_instructions;
                                 body.emit(f070C);

                                 /* END IF */


                              body.instructions = f070A_parent_instructions;
                              body.emit(f070A);

                              /* END IF */

                              body.emit(assign(r0701, body.constant(0u), 0x01));


                           body.instructions = f0706_parent_instructions;
                           body.emit(f0706);

                           /* END IF */

                           ir_expression *const r0714 = nequal(r06FD, body.constant(0u));
                           ir_expression *const r0715 = expr(ir_unop_b2i, r0714);
                           ir_expression *const r0716 = expr(ir_unop_i2u, r0715);
                           body.emit(assign(r06FF, bit_or(r06FF, r0716), 0x01));


                        body.instructions = f0704_parent_instructions;
                        body.emit(f0704);

                        /* END IF */

                        body.emit(assign(r06D9, r0701, 0x01));

                        body.emit(assign(r06DA, r0700, 0x01));

                        body.emit(assign(r06DB, r06FF, 0x01));


                     body.instructions = f06F3_parent_instructions;
                     body.emit(f06F3);

                     /* END IF */

                     body.emit(assign(r06D8, sub(r06D8, r06DC), 0x01));

                     ir_variable *const r0717 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0717, r06D8, 0x01));

                     ir_variable *const r0718 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0718, r06D9, 0x01));

                     ir_variable *const r0719 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0719, r06DA, 0x01));

                     ir_variable *const r071A = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r071A, r06DB, 0x01));

                     ir_variable *const r071B = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r071B, body.constant(true), 0x01));

                     ir_variable *const r071C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r071D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r071D);
                     ir_expression *const r071E = expr(ir_unop_u2i, r06DB);
                     body.emit(assign(r071D, less(r071E, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0720 = lequal(body.constant(int(2045)), r06D8);
                     ir_if *f071F = new(mem_ctx) ir_if(operand(r0720).val);
                     exec_list *const f071F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f071F->then_instructions;

                        ir_variable *const r0721 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0723 = less(body.constant(int(2045)), r06D8);
                        ir_if *f0722 = new(mem_ctx) ir_if(operand(r0723).val);
                        exec_list *const f0722_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0722->then_instructions;

                           body.emit(assign(r0721, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0722->else_instructions;

                           ir_variable *const r0724 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0726 = equal(r06D8, body.constant(int(2045)));
                           ir_if *f0725 = new(mem_ctx) ir_if(operand(r0726).val);
                           exec_list *const f0725_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0725->then_instructions;

                              ir_expression *const r0727 = equal(body.constant(2097151u), r06D9);
                              ir_expression *const r0728 = equal(body.constant(4294967295u), r06DA);
                              body.emit(assign(r0724, logic_and(r0727, r0728), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0725->else_instructions;

                              body.emit(assign(r0724, body.constant(false), 0x01));


                           body.instructions = f0725_parent_instructions;
                           body.emit(f0725);

                           /* END IF */

                           body.emit(assign(r0721, logic_and(r0724, r071D), 0x01));


                        body.instructions = f0722_parent_instructions;
                        body.emit(f0722);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0729 = new(mem_ctx) ir_if(operand(r0721).val);
                        exec_list *const f0729_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0729->then_instructions;

                           ir_variable *const r072A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r072A);
                           ir_expression *const r072B = lshift(r03D3, body.constant(int(31)));
                           body.emit(assign(r072A, add(r072B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r072A, body.constant(0u), 0x01));

                           body.emit(assign(r071C, r072A, 0x03));

                           body.emit(assign(r071B, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0729->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r072D = less(r06D8, body.constant(int(0)));
                           ir_if *f072C = new(mem_ctx) ir_if(operand(r072D).val);
                           exec_list *const f072C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f072C->then_instructions;

                              ir_variable *const r072E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r072E, r06DB, 0x01));

                              ir_variable *const r072F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r072F, neg(r06D8), 0x01));

                              ir_variable *const r0730 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0730);
                              ir_variable *const r0731 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0731);
                              ir_variable *const r0732 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0732);
                              ir_variable *const r0733 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0734 = neg(r072F);
                              body.emit(assign(r0733, bit_and(r0734, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0736 = equal(r072F, body.constant(int(0)));
                              ir_if *f0735 = new(mem_ctx) ir_if(operand(r0736).val);
                              exec_list *const f0735_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0735->then_instructions;

                                 body.emit(assign(r0730, r06DB, 0x01));

                                 body.emit(assign(r0731, r06DA, 0x01));

                                 body.emit(assign(r0732, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0735->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0738 = less(r072F, body.constant(int(32)));
                                 ir_if *f0737 = new(mem_ctx) ir_if(operand(r0738).val);
                                 exec_list *const f0737_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0737->then_instructions;

                                    body.emit(assign(r0730, lshift(r06DA, r0733), 0x01));

                                    ir_expression *const r0739 = lshift(r06D9, r0733);
                                    ir_expression *const r073A = rshift(r06DA, r072F);
                                    body.emit(assign(r0731, bit_or(r0739, r073A), 0x01));

                                    body.emit(assign(r0732, rshift(r06D9, r072F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0737->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r073C = equal(r072F, body.constant(int(32)));
                                    ir_if *f073B = new(mem_ctx) ir_if(operand(r073C).val);
                                    exec_list *const f073B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f073B->then_instructions;

                                       body.emit(assign(r0730, r06DA, 0x01));

                                       body.emit(assign(r0731, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f073B->else_instructions;

                                       body.emit(assign(r072E, bit_or(r06DB, r06DA), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r073E = less(r072F, body.constant(int(64)));
                                       ir_if *f073D = new(mem_ctx) ir_if(operand(r073E).val);
                                       exec_list *const f073D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f073D->then_instructions;

                                          body.emit(assign(r0730, lshift(r06D9, r0733), 0x01));

                                          ir_expression *const r073F = bit_and(r072F, body.constant(int(31)));
                                          body.emit(assign(r0731, rshift(r06D9, r073F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f073D->else_instructions;

                                          ir_variable *const r0740 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0742 = equal(r072F, body.constant(int(64)));
                                          ir_if *f0741 = new(mem_ctx) ir_if(operand(r0742).val);
                                          exec_list *const f0741_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0741->then_instructions;

                                             body.emit(assign(r0740, r06D9, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0741->else_instructions;

                                             ir_expression *const r0743 = nequal(r06D9, body.constant(0u));
                                             ir_expression *const r0744 = expr(ir_unop_b2i, r0743);
                                             body.emit(assign(r0740, expr(ir_unop_i2u, r0744), 0x01));


                                          body.instructions = f0741_parent_instructions;
                                          body.emit(f0741);

                                          /* END IF */

                                          body.emit(assign(r0730, r0740, 0x01));

                                          body.emit(assign(r0731, body.constant(0u), 0x01));


                                       body.instructions = f073D_parent_instructions;
                                       body.emit(f073D);

                                       /* END IF */


                                    body.instructions = f073B_parent_instructions;
                                    body.emit(f073B);

                                    /* END IF */

                                    body.emit(assign(r0732, body.constant(0u), 0x01));


                                 body.instructions = f0737_parent_instructions;
                                 body.emit(f0737);

                                 /* END IF */

                                 ir_expression *const r0745 = nequal(r072E, body.constant(0u));
                                 ir_expression *const r0746 = expr(ir_unop_b2i, r0745);
                                 ir_expression *const r0747 = expr(ir_unop_i2u, r0746);
                                 body.emit(assign(r0730, bit_or(r0730, r0747), 0x01));


                              body.instructions = f0735_parent_instructions;
                              body.emit(f0735);

                              /* END IF */

                              body.emit(assign(r0718, r0732, 0x01));

                              body.emit(assign(r0719, r0731, 0x01));

                              body.emit(assign(r071A, r0730, 0x01));

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));

                              body.emit(assign(r071D, less(r0730, body.constant(0u)), 0x01));


                           body.instructions = f072C_parent_instructions;
                           body.emit(f072C);

                           /* END IF */


                        body.instructions = f0729_parent_instructions;
                        body.emit(f0729);

                        /* END IF */


                     body.instructions = f071F_parent_instructions;
                     body.emit(f071F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0748 = new(mem_ctx) ir_if(operand(r071B).val);
                     exec_list *const f0748_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0748->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0749 = new(mem_ctx) ir_if(operand(r071D).val);
                        exec_list *const f0749_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0749->then_instructions;

                           ir_variable *const r074A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r074A, add(r0719, body.constant(1u)), 0x01));

                           ir_expression *const r074B = less(r074A, r0719);
                           ir_expression *const r074C = expr(ir_unop_b2i, r074B);
                           ir_expression *const r074D = expr(ir_unop_i2u, r074C);
                           body.emit(assign(r0718, add(r0718, r074D), 0x01));

                           ir_expression *const r074E = equal(r071A, body.constant(0u));
                           ir_expression *const r074F = expr(ir_unop_b2i, r074E);
                           ir_expression *const r0750 = expr(ir_unop_i2u, r074F);
                           ir_expression *const r0751 = add(r071A, r0750);
                           ir_expression *const r0752 = bit_and(r0751, body.constant(1u));
                           ir_expression *const r0753 = expr(ir_unop_bit_not, r0752);
                           body.emit(assign(r0719, bit_and(r074A, r0753), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0749->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0755 = bit_or(r0718, r0719);
                           ir_expression *const r0756 = equal(r0755, body.constant(0u));
                           ir_if *f0754 = new(mem_ctx) ir_if(operand(r0756).val);
                           exec_list *const f0754_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0754->then_instructions;

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));


                           body.instructions = f0754_parent_instructions;
                           body.emit(f0754);

                           /* END IF */


                        body.instructions = f0749_parent_instructions;
                        body.emit(f0749);

                        /* END IF */

                        ir_variable *const r0757 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0757);
                        ir_expression *const r0758 = lshift(r03D3, body.constant(int(31)));
                        ir_expression *const r0759 = expr(ir_unop_i2u, r0717);
                        ir_expression *const r075A = lshift(r0759, body.constant(int(20)));
                        ir_expression *const r075B = add(r0758, r075A);
                        body.emit(assign(r0757, add(r075B, r0718), 0x02));

                        body.emit(assign(r0757, r0719, 0x01));

                        body.emit(assign(r071C, r0757, 0x03));

                        body.emit(assign(r071B, body.constant(false), 0x01));


                     body.instructions = f0748_parent_instructions;
                     body.emit(f0748);

                     /* END IF */

                     body.emit(assign(r03D4, r071C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f06D0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r075D = less(r03DB, r03D9);
                     ir_if *f075C = new(mem_ctx) ir_if(operand(r075D).val);
                     exec_list *const f075C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f075C->then_instructions;

                        ir_variable *const r075E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r075F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r075F, sub(r03D9, r03DB), 0x01));

                        ir_expression *const r0760 = sub(r03D8, r03DA);
                        ir_expression *const r0761 = less(r03D9, r03DB);
                        ir_expression *const r0762 = expr(ir_unop_b2i, r0761);
                        ir_expression *const r0763 = expr(ir_unop_i2u, r0762);
                        body.emit(assign(r075E, sub(r0760, r0763), 0x01));

                        body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

                        body.emit(assign(r03DC, add(r03D6, body.constant(int(-1))), 0x01));

                        ir_variable *const r0764 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0764, add(r03DC, body.constant(int(-10))), 0x01));

                        ir_variable *const r0765 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0765, r075E, 0x01));

                        ir_variable *const r0766 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0766, r075F, 0x01));

                        ir_variable *const r0767 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0767);
                        ir_variable *const r0768 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0768);
                        /* IF CONDITION */
                        ir_expression *const r076A = equal(r075E, body.constant(0u));
                        ir_if *f0769 = new(mem_ctx) ir_if(operand(r076A).val);
                        exec_list *const f0769_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0769->then_instructions;

                           body.emit(assign(r0765, r075F, 0x01));

                           body.emit(assign(r0766, body.constant(0u), 0x01));

                           body.emit(assign(r0764, add(r0764, body.constant(int(-32))), 0x01));


                        body.instructions = f0769_parent_instructions;
                        body.emit(f0769);

                        /* END IF */

                        ir_variable *const r076B = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r076B, r0765, 0x01));

                        ir_variable *const r076C = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r076D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r076D);
                        /* IF CONDITION */
                        ir_expression *const r076F = equal(r0765, body.constant(0u));
                        ir_if *f076E = new(mem_ctx) ir_if(operand(r076F).val);
                        exec_list *const f076E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f076E->then_instructions;

                           body.emit(assign(r076C, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f076E->else_instructions;

                           body.emit(assign(r076D, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0771 = bit_and(r0765, body.constant(4294901760u));
                           ir_expression *const r0772 = equal(r0771, body.constant(0u));
                           ir_if *f0770 = new(mem_ctx) ir_if(operand(r0772).val);
                           exec_list *const f0770_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0770->then_instructions;

                              body.emit(assign(r076D, body.constant(int(16)), 0x01));

                              body.emit(assign(r076B, lshift(r0765, body.constant(int(16))), 0x01));


                           body.instructions = f0770_parent_instructions;
                           body.emit(f0770);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0774 = bit_and(r076B, body.constant(4278190080u));
                           ir_expression *const r0775 = equal(r0774, body.constant(0u));
                           ir_if *f0773 = new(mem_ctx) ir_if(operand(r0775).val);
                           exec_list *const f0773_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0773->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(8))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(8))), 0x01));


                           body.instructions = f0773_parent_instructions;
                           body.emit(f0773);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0777 = bit_and(r076B, body.constant(4026531840u));
                           ir_expression *const r0778 = equal(r0777, body.constant(0u));
                           ir_if *f0776 = new(mem_ctx) ir_if(operand(r0778).val);
                           exec_list *const f0776_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0776->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(4))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(4))), 0x01));


                           body.instructions = f0776_parent_instructions;
                           body.emit(f0776);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077A = bit_and(r076B, body.constant(3221225472u));
                           ir_expression *const r077B = equal(r077A, body.constant(0u));
                           ir_if *f0779 = new(mem_ctx) ir_if(operand(r077B).val);
                           exec_list *const f0779_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0779->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(2))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(2))), 0x01));


                           body.instructions = f0779_parent_instructions;
                           body.emit(f0779);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077D = bit_and(r076B, body.constant(2147483648u));
                           ir_expression *const r077E = equal(r077D, body.constant(0u));
                           ir_if *f077C = new(mem_ctx) ir_if(operand(r077E).val);
                           exec_list *const f077C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f077C->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(1))), 0x01));


                           body.instructions = f077C_parent_instructions;
                           body.emit(f077C);

                           /* END IF */

                           body.emit(assign(r076C, r076D, 0x01));


                        body.instructions = f076E_parent_instructions;
                        body.emit(f076E);

                        /* END IF */

                        body.emit(assign(r0768, add(r076C, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0780 = lequal(body.constant(int(0)), r0768);
                        ir_if *f077F = new(mem_ctx) ir_if(operand(r0780).val);
                        exec_list *const f077F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f077F->then_instructions;

                           body.emit(assign(r0767, body.constant(0u), 0x01));

                           ir_variable *const r0781 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0781, lshift(r0766, r0768), 0x01));

                           ir_variable *const r0782 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0784 = equal(r0768, body.constant(int(0)));
                           ir_if *f0783 = new(mem_ctx) ir_if(operand(r0784).val);
                           exec_list *const f0783_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0783->then_instructions;

                              body.emit(assign(r0782, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0783->else_instructions;

                              ir_expression *const r0785 = lshift(r0765, r0768);
                              ir_expression *const r0786 = neg(r0768);
                              ir_expression *const r0787 = bit_and(r0786, body.constant(int(31)));
                              ir_expression *const r0788 = rshift(r0766, r0787);
                              body.emit(assign(r0782, bit_or(r0785, r0788), 0x01));


                           body.instructions = f0783_parent_instructions;
                           body.emit(f0783);

                           /* END IF */

                           body.emit(assign(r0765, r0782, 0x01));

                           body.emit(assign(r0766, r0781, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f077F->else_instructions;

                           ir_variable *const r0789 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0789, body.constant(0u), 0x01));

                           ir_variable *const r078A = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r078A, neg(r0768), 0x01));

                           ir_variable *const r078B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r078B);
                           ir_variable *const r078C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r078C);
                           ir_variable *const r078D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r078D);
                           ir_variable *const r078E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r078F = neg(r078A);
                           body.emit(assign(r078E, bit_and(r078F, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0791 = equal(r078A, body.constant(int(0)));
                           ir_if *f0790 = new(mem_ctx) ir_if(operand(r0791).val);
                           exec_list *const f0790_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0790->then_instructions;

                              body.emit(assign(r078B, r0789, 0x01));

                              body.emit(assign(r078C, r0766, 0x01));

                              body.emit(assign(r078D, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0790->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0793 = less(r078A, body.constant(int(32)));
                              ir_if *f0792 = new(mem_ctx) ir_if(operand(r0793).val);
                              exec_list *const f0792_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0792->then_instructions;

                                 body.emit(assign(r078B, lshift(r0766, r078E), 0x01));

                                 ir_expression *const r0794 = lshift(r0765, r078E);
                                 ir_expression *const r0795 = rshift(r0766, r078A);
                                 body.emit(assign(r078C, bit_or(r0794, r0795), 0x01));

                                 body.emit(assign(r078D, rshift(r0765, r078A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0792->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0797 = equal(r078A, body.constant(int(32)));
                                 ir_if *f0796 = new(mem_ctx) ir_if(operand(r0797).val);
                                 exec_list *const f0796_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0796->then_instructions;

                                    body.emit(assign(r078B, r0766, 0x01));

                                    body.emit(assign(r078C, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0796->else_instructions;

                                    body.emit(assign(r0789, bit_or(body.constant(0u), r0766), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0799 = less(r078A, body.constant(int(64)));
                                    ir_if *f0798 = new(mem_ctx) ir_if(operand(r0799).val);
                                    exec_list *const f0798_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0798->then_instructions;

                                       body.emit(assign(r078B, lshift(r0765, r078E), 0x01));

                                       ir_expression *const r079A = bit_and(r078A, body.constant(int(31)));
                                       body.emit(assign(r078C, rshift(r0765, r079A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0798->else_instructions;

                                       ir_variable *const r079B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r079D = equal(r078A, body.constant(int(64)));
                                       ir_if *f079C = new(mem_ctx) ir_if(operand(r079D).val);
                                       exec_list *const f079C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f079C->then_instructions;

                                          body.emit(assign(r079B, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f079C->else_instructions;

                                          ir_expression *const r079E = nequal(r0765, body.constant(0u));
                                          ir_expression *const r079F = expr(ir_unop_b2i, r079E);
                                          body.emit(assign(r079B, expr(ir_unop_i2u, r079F), 0x01));


                                       body.instructions = f079C_parent_instructions;
                                       body.emit(f079C);

                                       /* END IF */

                                       body.emit(assign(r078B, r079B, 0x01));

                                       body.emit(assign(r078C, body.constant(0u), 0x01));


                                    body.instructions = f0798_parent_instructions;
                                    body.emit(f0798);

                                    /* END IF */


                                 body.instructions = f0796_parent_instructions;
                                 body.emit(f0796);

                                 /* END IF */

                                 body.emit(assign(r078D, body.constant(0u), 0x01));


                              body.instructions = f0792_parent_instructions;
                              body.emit(f0792);

                              /* END IF */

                              ir_expression *const r07A0 = nequal(r0789, body.constant(0u));
                              ir_expression *const r07A1 = expr(ir_unop_b2i, r07A0);
                              ir_expression *const r07A2 = expr(ir_unop_i2u, r07A1);
                              body.emit(assign(r078B, bit_or(r078B, r07A2), 0x01));


                           body.instructions = f0790_parent_instructions;
                           body.emit(f0790);

                           /* END IF */

                           body.emit(assign(r0765, r078D, 0x01));

                           body.emit(assign(r0766, r078C, 0x01));

                           body.emit(assign(r0767, r078B, 0x01));


                        body.instructions = f077F_parent_instructions;
                        body.emit(f077F);

                        /* END IF */

                        body.emit(assign(r0764, sub(r0764, r0768), 0x01));

                        ir_variable *const r07A3 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r07A3, r0764, 0x01));

                        ir_variable *const r07A4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r07A4, r0765, 0x01));

                        ir_variable *const r07A5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r07A5, r0766, 0x01));

                        ir_variable *const r07A6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r07A6, r0767, 0x01));

                        ir_variable *const r07A7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r07A7, body.constant(true), 0x01));

                        ir_variable *const r07A8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r07A9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r07A9);
                        ir_expression *const r07AA = expr(ir_unop_u2i, r0767);
                        body.emit(assign(r07A9, less(r07AA, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r07AC = lequal(body.constant(int(2045)), r0764);
                        ir_if *f07AB = new(mem_ctx) ir_if(operand(r07AC).val);
                        exec_list *const f07AB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07AB->then_instructions;

                           ir_variable *const r07AD = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r07AF = less(body.constant(int(2045)), r0764);
                           ir_if *f07AE = new(mem_ctx) ir_if(operand(r07AF).val);
                           exec_list *const f07AE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07AE->then_instructions;

                              body.emit(assign(r07AD, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07AE->else_instructions;

                              ir_variable *const r07B0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r07B2 = equal(r0764, body.constant(int(2045)));
                              ir_if *f07B1 = new(mem_ctx) ir_if(operand(r07B2).val);
                              exec_list *const f07B1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B1->then_instructions;

                                 ir_expression *const r07B3 = equal(body.constant(2097151u), r0765);
                                 ir_expression *const r07B4 = equal(body.constant(4294967295u), r0766);
                                 body.emit(assign(r07B0, logic_and(r07B3, r07B4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f07B1->else_instructions;

                                 body.emit(assign(r07B0, body.constant(false), 0x01));


                              body.instructions = f07B1_parent_instructions;
                              body.emit(f07B1);

                              /* END IF */

                              body.emit(assign(r07AD, logic_and(r07B0, r07A9), 0x01));


                           body.instructions = f07AE_parent_instructions;
                           body.emit(f07AE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f07B5 = new(mem_ctx) ir_if(operand(r07AD).val);
                           exec_list *const f07B5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07B5->then_instructions;

                              ir_variable *const r07B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r07B6);
                              ir_expression *const r07B7 = lshift(r03D3, body.constant(int(31)));
                              body.emit(assign(r07B6, add(r07B7, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r07B6, body.constant(0u), 0x01));

                              body.emit(assign(r07A8, r07B6, 0x03));

                              body.emit(assign(r07A7, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07B5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07B9 = less(r0764, body.constant(int(0)));
                              ir_if *f07B8 = new(mem_ctx) ir_if(operand(r07B9).val);
                              exec_list *const f07B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B8->then_instructions;

                                 ir_variable *const r07BA = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r07BA, r0767, 0x01));

                                 ir_variable *const r07BB = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r07BB, neg(r0764), 0x01));

                                 ir_variable *const r07BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r07BC);
                                 ir_variable *const r07BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r07BD);
                                 ir_variable *const r07BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r07BE);
                                 ir_variable *const r07BF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r07C0 = neg(r07BB);
                                 body.emit(assign(r07BF, bit_and(r07C0, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r07C2 = equal(r07BB, body.constant(int(0)));
                                 ir_if *f07C1 = new(mem_ctx) ir_if(operand(r07C2).val);
                                 exec_list *const f07C1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f07C1->then_instructions;

                                    body.emit(assign(r07BC, r0767, 0x01));

                                    body.emit(assign(r07BD, r0766, 0x01));

                                    body.emit(assign(r07BE, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f07C1->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r07C4 = less(r07BB, body.constant(int(32)));
                                    ir_if *f07C3 = new(mem_ctx) ir_if(operand(r07C4).val);
                                    exec_list *const f07C3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f07C3->then_instructions;

                                       body.emit(assign(r07BC, lshift(r0766, r07BF), 0x01));

                                       ir_expression *const r07C5 = lshift(r0765, r07BF);
                                       ir_expression *const r07C6 = rshift(r0766, r07BB);
                                       body.emit(assign(r07BD, bit_or(r07C5, r07C6), 0x01));

                                       body.emit(assign(r07BE, rshift(r0765, r07BB), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f07C3->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r07C8 = equal(r07BB, body.constant(int(32)));
                                       ir_if *f07C7 = new(mem_ctx) ir_if(operand(r07C8).val);
                                       exec_list *const f07C7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f07C7->then_instructions;

                                          body.emit(assign(r07BC, r0766, 0x01));

                                          body.emit(assign(r07BD, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f07C7->else_instructions;

                                          body.emit(assign(r07BA, bit_or(r0767, r0766), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r07CA = less(r07BB, body.constant(int(64)));
                                          ir_if *f07C9 = new(mem_ctx) ir_if(operand(r07CA).val);
                                          exec_list *const f07C9_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f07C9->then_instructions;

                                             body.emit(assign(r07BC, lshift(r0765, r07BF), 0x01));

                                             ir_expression *const r07CB = bit_and(r07BB, body.constant(int(31)));
                                             body.emit(assign(r07BD, rshift(r0765, r07CB), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f07C9->else_instructions;

                                             ir_variable *const r07CC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r07CE = equal(r07BB, body.constant(int(64)));
                                             ir_if *f07CD = new(mem_ctx) ir_if(operand(r07CE).val);
                                             exec_list *const f07CD_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f07CD->then_instructions;

                                                body.emit(assign(r07CC, r0765, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f07CD->else_instructions;

                                                ir_expression *const r07CF = nequal(r0765, body.constant(0u));
                                                ir_expression *const r07D0 = expr(ir_unop_b2i, r07CF);
                                                body.emit(assign(r07CC, expr(ir_unop_i2u, r07D0), 0x01));


                                             body.instructions = f07CD_parent_instructions;
                                             body.emit(f07CD);

                                             /* END IF */

                                             body.emit(assign(r07BC, r07CC, 0x01));

                                             body.emit(assign(r07BD, body.constant(0u), 0x01));


                                          body.instructions = f07C9_parent_instructions;
                                          body.emit(f07C9);

                                          /* END IF */


                                       body.instructions = f07C7_parent_instructions;
                                       body.emit(f07C7);

                                       /* END IF */

                                       body.emit(assign(r07BE, body.constant(0u), 0x01));


                                    body.instructions = f07C3_parent_instructions;
                                    body.emit(f07C3);

                                    /* END IF */

                                    ir_expression *const r07D1 = nequal(r07BA, body.constant(0u));
                                    ir_expression *const r07D2 = expr(ir_unop_b2i, r07D1);
                                    ir_expression *const r07D3 = expr(ir_unop_i2u, r07D2);
                                    body.emit(assign(r07BC, bit_or(r07BC, r07D3), 0x01));


                                 body.instructions = f07C1_parent_instructions;
                                 body.emit(f07C1);

                                 /* END IF */

                                 body.emit(assign(r07A4, r07BE, 0x01));

                                 body.emit(assign(r07A5, r07BD, 0x01));

                                 body.emit(assign(r07A6, r07BC, 0x01));

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));

                                 body.emit(assign(r07A9, less(r07BC, body.constant(0u)), 0x01));


                              body.instructions = f07B8_parent_instructions;
                              body.emit(f07B8);

                              /* END IF */


                           body.instructions = f07B5_parent_instructions;
                           body.emit(f07B5);

                           /* END IF */


                        body.instructions = f07AB_parent_instructions;
                        body.emit(f07AB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f07D4 = new(mem_ctx) ir_if(operand(r07A7).val);
                        exec_list *const f07D4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07D4->then_instructions;

                           /* IF CONDITION */
                           ir_if *f07D5 = new(mem_ctx) ir_if(operand(r07A9).val);
                           exec_list *const f07D5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07D5->then_instructions;

                              ir_variable *const r07D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r07D6, add(r07A5, body.constant(1u)), 0x01));

                              ir_expression *const r07D7 = less(r07D6, r07A5);
                              ir_expression *const r07D8 = expr(ir_unop_b2i, r07D7);
                              ir_expression *const r07D9 = expr(ir_unop_i2u, r07D8);
                              body.emit(assign(r07A4, add(r07A4, r07D9), 0x01));

                              ir_expression *const r07DA = equal(r07A6, body.constant(0u));
                              ir_expression *const r07DB = expr(ir_unop_b2i, r07DA);
                              ir_expression *const r07DC = expr(ir_unop_i2u, r07DB);
                              ir_expression *const r07DD = add(r07A6, r07DC);
                              ir_expression *const r07DE = bit_and(r07DD, body.constant(1u));
                              ir_expression *const r07DF = expr(ir_unop_bit_not, r07DE);
                              body.emit(assign(r07A5, bit_and(r07D6, r07DF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07D5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07E1 = bit_or(r07A4, r07A5);
                              ir_expression *const r07E2 = equal(r07E1, body.constant(0u));
                              ir_if *f07E0 = new(mem_ctx) ir_if(operand(r07E2).val);
                              exec_list *const f07E0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07E0->then_instructions;

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));


                              body.instructions = f07E0_parent_instructions;
                              body.emit(f07E0);

                              /* END IF */


                           body.instructions = f07D5_parent_instructions;
                           body.emit(f07D5);

                           /* END IF */

                           ir_variable *const r07E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r07E3);
                           ir_expression *const r07E4 = lshift(r03D3, body.constant(int(31)));
                           ir_expression *const r07E5 = expr(ir_unop_i2u, r07A3);
                           ir_expression *const r07E6 = lshift(r07E5, body.constant(int(20)));
                           ir_expression *const r07E7 = add(r07E4, r07E6);
                           body.emit(assign(r07E3, add(r07E7, r07A4), 0x02));

                           body.emit(assign(r07E3, r07A5, 0x01));

                           body.emit(assign(r07A8, r07E3, 0x03));

                           body.emit(assign(r07A7, body.constant(false), 0x01));


                        body.instructions = f07D4_parent_instructions;
                        body.emit(f07D4);

                        /* END IF */

                        body.emit(assign(r03D4, r07A8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f075C->else_instructions;

                        ir_variable *const r07E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r07E8);
                        body.emit(assign(r07E8, body.constant(0u), 0x02));

                        body.emit(assign(r07E8, body.constant(0u), 0x01));

                        body.emit(assign(r03D4, r07E8, 0x03));


                     body.instructions = f075C_parent_instructions;
                     body.emit(f075C);

                     /* END IF */


                  body.instructions = f06D0_parent_instructions;
                  body.emit(f06D0);

                  /* END IF */


               body.instructions = f0644_parent_instructions;
               body.emit(f0644);

               /* END IF */


            body.instructions = f05B8_parent_instructions;
            body.emit(f05B8);

            /* END IF */


         body.instructions = f0591_parent_instructions;
         body.emit(f0591);

         /* END IF */


      body.instructions = f04BD_parent_instructions;
      body.emit(f04BD);

      /* END IF */


   body.instructions = f03ED_parent_instructions;
   body.emit(f03ED);

   /* END IF */

   body.emit(ret(r03D4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fadd64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r07E9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r07E9);
   ir_variable *const r07EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r07EA);
   ir_variable *const r07EB = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r07EC = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07EC, rshift(swizzle_y(r07E9), body.constant(int(31))), 0x01));

   ir_variable *const r07ED = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07ED, rshift(swizzle_y(r07EA), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r07EF = equal(r07EC, r07ED);
   ir_if *f07EE = new(mem_ctx) ir_if(operand(r07EF).val);
   exec_list *const f07EE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f07EE->then_instructions;

      ir_variable *const r07F0 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r07F0, body.constant(true), 0x01));

      ir_variable *const r07F1 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r07F2 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r07F2);
      ir_variable *const r07F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r07F3);
      ir_variable *const r07F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r07F4);
      ir_variable *const r07F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r07F5);
      ir_variable *const r07F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r07F6);
      ir_variable *const r07F7 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r07F7);
      ir_variable *const r07F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r07F8);
      ir_variable *const r07F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r07F9);
      body.emit(assign(r07F9, body.constant(0u), 0x01));

      body.emit(assign(r07F8, body.constant(0u), 0x01));

      ir_variable *const r07FA = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r07FA, swizzle_x(r07E9), 0x01));

      body.emit(assign(r07F6, r07FA, 0x01));

      ir_variable *const r07FB = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r07FB, bit_and(swizzle_y(r07E9), body.constant(1048575u)), 0x01));

      body.emit(assign(r07F5, r07FB, 0x01));

      ir_variable *const r07FC = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r07FC, swizzle_x(r07EA), 0x01));

      body.emit(assign(r07F4, r07FC, 0x01));

      ir_variable *const r07FD = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r07FD, bit_and(swizzle_y(r07EA), body.constant(1048575u)), 0x01));

      body.emit(assign(r07F3, r07FD, 0x01));

      ir_variable *const r07FE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r07FF = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r0800 = bit_and(r07FF, body.constant(2047u));
      body.emit(assign(r07FE, expr(ir_unop_u2i, r0800), 0x01));

      ir_variable *const r0801 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0802 = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r0803 = bit_and(r0802, body.constant(2047u));
      body.emit(assign(r0801, expr(ir_unop_u2i, r0803), 0x01));

      ir_variable *const r0804 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r0804, sub(r07FE, r0801), 0x01));

      body.emit(assign(r07F2, r0804, 0x01));

      /* IF CONDITION */
      ir_expression *const r0806 = less(body.constant(int(0)), r0804);
      ir_if *f0805 = new(mem_ctx) ir_if(operand(r0806).val);
      exec_list *const f0805_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0805->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0808 = equal(r07FE, body.constant(int(2047)));
         ir_if *f0807 = new(mem_ctx) ir_if(operand(r0808).val);
         exec_list *const f0807_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0807->then_instructions;

            /* IF CONDITION */
            ir_expression *const r080A = bit_or(r07FB, swizzle_x(r07E9));
            ir_expression *const r080B = nequal(r080A, body.constant(0u));
            ir_if *f0809 = new(mem_ctx) ir_if(operand(r080B).val);
            exec_list *const f0809_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0809->then_instructions;

               ir_variable *const r080C = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r080C, swizzle_x(r07E9), 0x01));

               ir_variable *const r080D = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r080D, swizzle_x(r07EA), 0x01));

               ir_variable *const r080E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r080F = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0810 = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r0811 = bit_and(r0810, body.constant(4095u));
               ir_expression *const r0812 = equal(r0811, body.constant(4094u));
               ir_expression *const r0813 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r0814 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r0815 = nequal(r0814, body.constant(0u));
               ir_expression *const r0816 = logic_or(r0813, r0815);
               body.emit(assign(r080F, logic_and(r0812, r0816), 0x01));

               ir_variable *const r0817 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0818 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r0819 = lequal(body.constant(4292870144u), r0818);
               ir_expression *const r081A = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r081B = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r081C = nequal(r081B, body.constant(0u));
               ir_expression *const r081D = logic_or(r081A, r081C);
               body.emit(assign(r0817, logic_and(r0819, r081D), 0x01));

               body.emit(assign(r080C, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r080D, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r081F = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r0820 = lequal(body.constant(4292870144u), r081F);
               ir_expression *const r0821 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r0822 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r0823 = nequal(r0822, body.constant(0u));
               ir_expression *const r0824 = logic_or(r0821, r0823);
               ir_expression *const r0825 = logic_and(r0820, r0824);
               ir_if *f081E = new(mem_ctx) ir_if(operand(r0825).val);
               exec_list *const f081E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f081E->then_instructions;

                  ir_variable *const r0826 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0828 = logic_and(r080F, r0817);
                  ir_if *f0827 = new(mem_ctx) ir_if(operand(r0828).val);
                  exec_list *const f0827_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0827->then_instructions;

                     body.emit(assign(r0826, r080D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0827->else_instructions;

                     body.emit(assign(r0826, r080C, 0x03));


                  body.instructions = f0827_parent_instructions;
                  body.emit(f0827);

                  /* END IF */

                  body.emit(assign(r080E, r0826, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f081E->else_instructions;

                  body.emit(assign(r080E, r080D, 0x03));


               body.instructions = f081E_parent_instructions;
               body.emit(f081E);

               /* END IF */

               body.emit(assign(r07F1, r080E, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0809->else_instructions;

               body.emit(assign(r07F1, r07E9, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


            body.instructions = f0809_parent_instructions;
            body.emit(f0809);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0807->else_instructions;

            /* IF CONDITION */
            ir_expression *const r082A = equal(r0801, body.constant(int(0)));
            ir_if *f0829 = new(mem_ctx) ir_if(operand(r082A).val);
            exec_list *const f0829_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0829->then_instructions;

               body.emit(assign(r07F2, add(r0804, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0829->else_instructions;

               body.emit(assign(r07F3, bit_or(r07FD, body.constant(1048576u)), 0x01));


            body.instructions = f0829_parent_instructions;
            body.emit(f0829);

            /* END IF */

            ir_variable *const r082B = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r082B, body.constant(0u), 0x01));

            ir_variable *const r082C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r082C);
            ir_variable *const r082D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r082D);
            ir_variable *const r082E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r082E);
            ir_variable *const r082F = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0830 = neg(r07F2);
            body.emit(assign(r082F, bit_and(r0830, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0832 = equal(r07F2, body.constant(int(0)));
            ir_if *f0831 = new(mem_ctx) ir_if(operand(r0832).val);
            exec_list *const f0831_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0831->then_instructions;

               body.emit(assign(r082C, r082B, 0x01));

               body.emit(assign(r082D, r07FC, 0x01));

               body.emit(assign(r082E, r07F3, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0831->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0834 = less(r07F2, body.constant(int(32)));
               ir_if *f0833 = new(mem_ctx) ir_if(operand(r0834).val);
               exec_list *const f0833_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0833->then_instructions;

                  body.emit(assign(r082C, lshift(swizzle_x(r07EA), r082F), 0x01));

                  ir_expression *const r0835 = lshift(r07F3, r082F);
                  ir_expression *const r0836 = rshift(swizzle_x(r07EA), r07F2);
                  body.emit(assign(r082D, bit_or(r0835, r0836), 0x01));

                  body.emit(assign(r082E, rshift(r07F3, r07F2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0833->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0838 = equal(r07F2, body.constant(int(32)));
                  ir_if *f0837 = new(mem_ctx) ir_if(operand(r0838).val);
                  exec_list *const f0837_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0837->then_instructions;

                     body.emit(assign(r082C, r07FC, 0x01));

                     body.emit(assign(r082D, r07F3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0837->else_instructions;

                     body.emit(assign(r082B, bit_or(body.constant(0u), swizzle_x(r07EA)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r083A = less(r07F2, body.constant(int(64)));
                     ir_if *f0839 = new(mem_ctx) ir_if(operand(r083A).val);
                     exec_list *const f0839_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0839->then_instructions;

                        body.emit(assign(r082C, lshift(r07F3, r082F), 0x01));

                        ir_expression *const r083B = bit_and(r07F2, body.constant(int(31)));
                        body.emit(assign(r082D, rshift(r07F3, r083B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0839->else_instructions;

                        ir_variable *const r083C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r083E = equal(r07F2, body.constant(int(64)));
                        ir_if *f083D = new(mem_ctx) ir_if(operand(r083E).val);
                        exec_list *const f083D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f083D->then_instructions;

                           body.emit(assign(r083C, r07F3, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f083D->else_instructions;

                           ir_expression *const r083F = nequal(r07F3, body.constant(0u));
                           ir_expression *const r0840 = expr(ir_unop_b2i, r083F);
                           body.emit(assign(r083C, expr(ir_unop_i2u, r0840), 0x01));


                        body.instructions = f083D_parent_instructions;
                        body.emit(f083D);

                        /* END IF */

                        body.emit(assign(r082C, r083C, 0x01));

                        body.emit(assign(r082D, body.constant(0u), 0x01));


                     body.instructions = f0839_parent_instructions;
                     body.emit(f0839);

                     /* END IF */


                  body.instructions = f0837_parent_instructions;
                  body.emit(f0837);

                  /* END IF */

                  body.emit(assign(r082E, body.constant(0u), 0x01));


               body.instructions = f0833_parent_instructions;
               body.emit(f0833);

               /* END IF */

               ir_expression *const r0841 = nequal(r082B, body.constant(0u));
               ir_expression *const r0842 = expr(ir_unop_b2i, r0841);
               ir_expression *const r0843 = expr(ir_unop_i2u, r0842);
               body.emit(assign(r082C, bit_or(r082C, r0843), 0x01));


            body.instructions = f0831_parent_instructions;
            body.emit(f0831);

            /* END IF */

            body.emit(assign(r07F3, r082E, 0x01));

            body.emit(assign(r07F4, r082D, 0x01));

            body.emit(assign(r07F8, r082C, 0x01));

            body.emit(assign(r07F7, r07FE, 0x01));


         body.instructions = f0807_parent_instructions;
         body.emit(f0807);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0805->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0845 = less(r07F2, body.constant(int(0)));
         ir_if *f0844 = new(mem_ctx) ir_if(operand(r0845).val);
         exec_list *const f0844_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0844->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0847 = equal(r0801, body.constant(int(2047)));
            ir_if *f0846 = new(mem_ctx) ir_if(operand(r0847).val);
            exec_list *const f0846_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0846->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0849 = bit_or(r07F3, r07F4);
               ir_expression *const r084A = nequal(r0849, body.constant(0u));
               ir_if *f0848 = new(mem_ctx) ir_if(operand(r084A).val);
               exec_list *const f0848_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0848->then_instructions;

                  ir_variable *const r084B = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r084B, swizzle_x(r07E9), 0x01));

                  ir_variable *const r084C = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r084C, swizzle_x(r07EA), 0x01));

                  ir_variable *const r084D = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r084E = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r084F = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0850 = bit_and(r084F, body.constant(4095u));
                  ir_expression *const r0851 = equal(r0850, body.constant(4094u));
                  ir_expression *const r0852 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0853 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0854 = nequal(r0853, body.constant(0u));
                  ir_expression *const r0855 = logic_or(r0852, r0854);
                  body.emit(assign(r084E, logic_and(r0851, r0855), 0x01));

                  ir_variable *const r0856 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0857 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0858 = lequal(body.constant(4292870144u), r0857);
                  ir_expression *const r0859 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r085A = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r085B = nequal(r085A, body.constant(0u));
                  ir_expression *const r085C = logic_or(r0859, r085B);
                  body.emit(assign(r0856, logic_and(r0858, r085C), 0x01));

                  body.emit(assign(r084B, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r084C, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r085E = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r085F = lequal(body.constant(4292870144u), r085E);
                  ir_expression *const r0860 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0861 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0862 = nequal(r0861, body.constant(0u));
                  ir_expression *const r0863 = logic_or(r0860, r0862);
                  ir_expression *const r0864 = logic_and(r085F, r0863);
                  ir_if *f085D = new(mem_ctx) ir_if(operand(r0864).val);
                  exec_list *const f085D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f085D->then_instructions;

                     ir_variable *const r0865 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0867 = logic_and(r084E, r0856);
                     ir_if *f0866 = new(mem_ctx) ir_if(operand(r0867).val);
                     exec_list *const f0866_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0866->then_instructions;

                        body.emit(assign(r0865, r084C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0866->else_instructions;

                        body.emit(assign(r0865, r084B, 0x03));


                     body.instructions = f0866_parent_instructions;
                     body.emit(f0866);

                     /* END IF */

                     body.emit(assign(r084D, r0865, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f085D->else_instructions;

                     body.emit(assign(r084D, r084C, 0x03));


                  body.instructions = f085D_parent_instructions;
                  body.emit(f085D);

                  /* END IF */

                  body.emit(assign(r07F1, r084D, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0848->else_instructions;

                  ir_variable *const r0868 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0868);
                  ir_expression *const r0869 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0868, add(r0869, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0868, body.constant(0u), 0x01));

                  body.emit(assign(r07F1, r0868, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0848_parent_instructions;
               body.emit(f0848);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0846->else_instructions;

               /* IF CONDITION */
               ir_expression *const r086B = equal(r07FE, body.constant(int(0)));
               ir_if *f086A = new(mem_ctx) ir_if(operand(r086B).val);
               exec_list *const f086A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f086A->then_instructions;

                  body.emit(assign(r07F2, add(r07F2, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f086A->else_instructions;

                  body.emit(assign(r07F5, bit_or(r07FB, body.constant(1048576u)), 0x01));


               body.instructions = f086A_parent_instructions;
               body.emit(f086A);

               /* END IF */

               ir_variable *const r086C = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r086C, body.constant(0u), 0x01));

               ir_variable *const r086D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r086D, neg(r07F2), 0x01));

               ir_variable *const r086E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r086E);
               ir_variable *const r086F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r086F);
               ir_variable *const r0870 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0870);
               ir_variable *const r0871 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0872 = neg(r086D);
               body.emit(assign(r0871, bit_and(r0872, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0874 = equal(r086D, body.constant(int(0)));
               ir_if *f0873 = new(mem_ctx) ir_if(operand(r0874).val);
               exec_list *const f0873_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0873->then_instructions;

                  body.emit(assign(r086E, r086C, 0x01));

                  body.emit(assign(r086F, r07FA, 0x01));

                  body.emit(assign(r0870, r07F5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0873->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0876 = less(r086D, body.constant(int(32)));
                  ir_if *f0875 = new(mem_ctx) ir_if(operand(r0876).val);
                  exec_list *const f0875_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0875->then_instructions;

                     body.emit(assign(r086E, lshift(swizzle_x(r07E9), r0871), 0x01));

                     ir_expression *const r0877 = lshift(r07F5, r0871);
                     ir_expression *const r0878 = rshift(swizzle_x(r07E9), r086D);
                     body.emit(assign(r086F, bit_or(r0877, r0878), 0x01));

                     body.emit(assign(r0870, rshift(r07F5, r086D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0875->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r087A = equal(r086D, body.constant(int(32)));
                     ir_if *f0879 = new(mem_ctx) ir_if(operand(r087A).val);
                     exec_list *const f0879_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0879->then_instructions;

                        body.emit(assign(r086E, r07FA, 0x01));

                        body.emit(assign(r086F, r07F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0879->else_instructions;

                        body.emit(assign(r086C, bit_or(body.constant(0u), swizzle_x(r07E9)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r087C = less(r086D, body.constant(int(64)));
                        ir_if *f087B = new(mem_ctx) ir_if(operand(r087C).val);
                        exec_list *const f087B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f087B->then_instructions;

                           body.emit(assign(r086E, lshift(r07F5, r0871), 0x01));

                           ir_expression *const r087D = bit_and(r086D, body.constant(int(31)));
                           body.emit(assign(r086F, rshift(r07F5, r087D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f087B->else_instructions;

                           ir_variable *const r087E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0880 = equal(r086D, body.constant(int(64)));
                           ir_if *f087F = new(mem_ctx) ir_if(operand(r0880).val);
                           exec_list *const f087F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f087F->then_instructions;

                              body.emit(assign(r087E, r07F5, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f087F->else_instructions;

                              ir_expression *const r0881 = nequal(r07F5, body.constant(0u));
                              ir_expression *const r0882 = expr(ir_unop_b2i, r0881);
                              body.emit(assign(r087E, expr(ir_unop_i2u, r0882), 0x01));


                           body.instructions = f087F_parent_instructions;
                           body.emit(f087F);

                           /* END IF */

                           body.emit(assign(r086E, r087E, 0x01));

                           body.emit(assign(r086F, body.constant(0u), 0x01));


                        body.instructions = f087B_parent_instructions;
                        body.emit(f087B);

                        /* END IF */


                     body.instructions = f0879_parent_instructions;
                     body.emit(f0879);

                     /* END IF */

                     body.emit(assign(r0870, body.constant(0u), 0x01));


                  body.instructions = f0875_parent_instructions;
                  body.emit(f0875);

                  /* END IF */

                  ir_expression *const r0883 = nequal(r086C, body.constant(0u));
                  ir_expression *const r0884 = expr(ir_unop_b2i, r0883);
                  ir_expression *const r0885 = expr(ir_unop_i2u, r0884);
                  body.emit(assign(r086E, bit_or(r086E, r0885), 0x01));


               body.instructions = f0873_parent_instructions;
               body.emit(f0873);

               /* END IF */

               body.emit(assign(r07F5, r0870, 0x01));

               body.emit(assign(r07F6, r086F, 0x01));

               body.emit(assign(r07F8, r086E, 0x01));

               body.emit(assign(r07F7, r0801, 0x01));


            body.instructions = f0846_parent_instructions;
            body.emit(f0846);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0844->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0887 = equal(r07FE, body.constant(int(2047)));
            ir_if *f0886 = new(mem_ctx) ir_if(operand(r0887).val);
            exec_list *const f0886_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0886->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0889 = bit_or(r07F5, r07F6);
               ir_expression *const r088A = bit_or(r07F3, r07F4);
               ir_expression *const r088B = bit_or(r0889, r088A);
               ir_expression *const r088C = nequal(r088B, body.constant(0u));
               ir_if *f0888 = new(mem_ctx) ir_if(operand(r088C).val);
               exec_list *const f0888_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0888->then_instructions;

                  ir_variable *const r088D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r088D, swizzle_x(r07E9), 0x01));

                  ir_variable *const r088E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r088E, swizzle_x(r07EA), 0x01));

                  ir_variable *const r088F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0890 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0891 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0892 = bit_and(r0891, body.constant(4095u));
                  ir_expression *const r0893 = equal(r0892, body.constant(4094u));
                  ir_expression *const r0894 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0895 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0896 = nequal(r0895, body.constant(0u));
                  ir_expression *const r0897 = logic_or(r0894, r0896);
                  body.emit(assign(r0890, logic_and(r0893, r0897), 0x01));

                  ir_variable *const r0898 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0899 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r089A = lequal(body.constant(4292870144u), r0899);
                  ir_expression *const r089B = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r089C = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r089D = nequal(r089C, body.constant(0u));
                  ir_expression *const r089E = logic_or(r089B, r089D);
                  body.emit(assign(r0898, logic_and(r089A, r089E), 0x01));

                  body.emit(assign(r088D, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r088E, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r08A0 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r08A1 = lequal(body.constant(4292870144u), r08A0);
                  ir_expression *const r08A2 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r08A3 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r08A4 = nequal(r08A3, body.constant(0u));
                  ir_expression *const r08A5 = logic_or(r08A2, r08A4);
                  ir_expression *const r08A6 = logic_and(r08A1, r08A5);
                  ir_if *f089F = new(mem_ctx) ir_if(operand(r08A6).val);
                  exec_list *const f089F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f089F->then_instructions;

                     ir_variable *const r08A7 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08A9 = logic_and(r0890, r0898);
                     ir_if *f08A8 = new(mem_ctx) ir_if(operand(r08A9).val);
                     exec_list *const f08A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08A8->then_instructions;

                        body.emit(assign(r08A7, r088E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08A8->else_instructions;

                        body.emit(assign(r08A7, r088D, 0x03));


                     body.instructions = f08A8_parent_instructions;
                     body.emit(f08A8);

                     /* END IF */

                     body.emit(assign(r088F, r08A7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f089F->else_instructions;

                     body.emit(assign(r088F, r088E, 0x03));


                  body.instructions = f089F_parent_instructions;
                  body.emit(f089F);

                  /* END IF */

                  body.emit(assign(r07F1, r088F, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0888->else_instructions;

                  body.emit(assign(r07F1, r07E9, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0888_parent_instructions;
               body.emit(f0888);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0886->else_instructions;

               ir_variable *const r08AA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r08AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r08AB, add(r07F6, r07F4), 0x01));

               ir_expression *const r08AC = add(r07F5, r07F3);
               ir_expression *const r08AD = less(r08AB, r07F6);
               ir_expression *const r08AE = expr(ir_unop_b2i, r08AD);
               ir_expression *const r08AF = expr(ir_unop_i2u, r08AE);
               body.emit(assign(r08AA, add(r08AC, r08AF), 0x01));

               body.emit(assign(r07F9, r08AA, 0x01));

               /* IF CONDITION */
               ir_expression *const r08B1 = equal(r07FE, body.constant(int(0)));
               ir_if *f08B0 = new(mem_ctx) ir_if(operand(r08B1).val);
               exec_list *const f08B0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f08B0->then_instructions;

                  ir_variable *const r08B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r08B2);
                  ir_expression *const r08B3 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r08B2, add(r08B3, r08AA), 0x02));

                  body.emit(assign(r08B2, r08AB, 0x01));

                  body.emit(assign(r07F1, r08B2, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f08B0->else_instructions;

                  body.emit(assign(r07F9, bit_or(r08AA, body.constant(2097152u)), 0x01));

                  body.emit(assign(r07F7, r07FE, 0x01));

                  ir_variable *const r08B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r08B4);
                  ir_variable *const r08B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r08B5);
                  ir_variable *const r08B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r08B6);
                  body.emit(assign(r08B4, lshift(r08AB, body.constant(int(31))), 0x01));

                  ir_expression *const r08B7 = lshift(r07F9, body.constant(int(31)));
                  ir_expression *const r08B8 = rshift(r08AB, body.constant(int(1)));
                  body.emit(assign(r08B5, bit_or(r08B7, r08B8), 0x01));

                  body.emit(assign(r08B6, rshift(r07F9, body.constant(int(1))), 0x01));

                  body.emit(assign(r08B4, bit_or(r08B4, body.constant(0u)), 0x01));

                  body.emit(assign(r07F9, r08B6, 0x01));

                  body.emit(assign(r07F8, r08B4, 0x01));

                  ir_variable *const r08B9 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r08B9, r07FE, 0x01));

                  ir_variable *const r08BA = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r08BA, r08B6, 0x01));

                  ir_variable *const r08BB = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r08BB, r08B5, 0x01));

                  ir_variable *const r08BC = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r08BC, r08B4, 0x01));

                  ir_variable *const r08BD = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r08BD, body.constant(true), 0x01));

                  ir_variable *const r08BE = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r08BF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r08BF);
                  ir_expression *const r08C0 = expr(ir_unop_u2i, r08B4);
                  body.emit(assign(r08BF, less(r08C0, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r08C2 = lequal(body.constant(int(2045)), r07FE);
                  ir_if *f08C1 = new(mem_ctx) ir_if(operand(r08C2).val);
                  exec_list *const f08C1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08C1->then_instructions;

                     ir_variable *const r08C3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08C5 = less(body.constant(int(2045)), r07FE);
                     ir_if *f08C4 = new(mem_ctx) ir_if(operand(r08C5).val);
                     exec_list *const f08C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08C4->then_instructions;

                        body.emit(assign(r08C3, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08C4->else_instructions;

                        ir_variable *const r08C6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r08C8 = equal(r07FE, body.constant(int(2045)));
                        ir_if *f08C7 = new(mem_ctx) ir_if(operand(r08C8).val);
                        exec_list *const f08C7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08C7->then_instructions;

                           ir_expression *const r08C9 = equal(body.constant(2097151u), r08B6);
                           ir_expression *const r08CA = equal(body.constant(4294967295u), r08B5);
                           body.emit(assign(r08C6, logic_and(r08C9, r08CA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f08C7->else_instructions;

                           body.emit(assign(r08C6, body.constant(false), 0x01));


                        body.instructions = f08C7_parent_instructions;
                        body.emit(f08C7);

                        /* END IF */

                        body.emit(assign(r08C3, logic_and(r08C6, r08BF), 0x01));


                     body.instructions = f08C4_parent_instructions;
                     body.emit(f08C4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f08CB = new(mem_ctx) ir_if(operand(r08C3).val);
                     exec_list *const f08CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08CB->then_instructions;

                        ir_variable *const r08CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r08CC);
                        ir_expression *const r08CD = lshift(r07EC, body.constant(int(31)));
                        body.emit(assign(r08CC, add(r08CD, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r08CC, body.constant(0u), 0x01));

                        body.emit(assign(r08BE, r08CC, 0x03));

                        body.emit(assign(r08BD, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08CB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08CF = less(r07FE, body.constant(int(0)));
                        ir_if *f08CE = new(mem_ctx) ir_if(operand(r08CF).val);
                        exec_list *const f08CE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08CE->then_instructions;

                           ir_variable *const r08D0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r08D0, r08B4, 0x01));

                           ir_variable *const r08D1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r08D1, neg(r07FE), 0x01));

                           ir_variable *const r08D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r08D2);
                           ir_variable *const r08D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r08D3);
                           ir_variable *const r08D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r08D4);
                           ir_variable *const r08D5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r08D6 = neg(r08D1);
                           body.emit(assign(r08D5, bit_and(r08D6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r08D8 = equal(r08D1, body.constant(int(0)));
                           ir_if *f08D7 = new(mem_ctx) ir_if(operand(r08D8).val);
                           exec_list *const f08D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f08D7->then_instructions;

                              body.emit(assign(r08D2, r08B4, 0x01));

                              body.emit(assign(r08D3, r08B5, 0x01));

                              body.emit(assign(r08D4, r08B6, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f08D7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r08DA = less(r08D1, body.constant(int(32)));
                              ir_if *f08D9 = new(mem_ctx) ir_if(operand(r08DA).val);
                              exec_list *const f08D9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f08D9->then_instructions;

                                 body.emit(assign(r08D2, lshift(r08B5, r08D5), 0x01));

                                 ir_expression *const r08DB = lshift(r08B6, r08D5);
                                 ir_expression *const r08DC = rshift(r08B5, r08D1);
                                 body.emit(assign(r08D3, bit_or(r08DB, r08DC), 0x01));

                                 body.emit(assign(r08D4, rshift(r08B6, r08D1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f08D9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r08DE = equal(r08D1, body.constant(int(32)));
                                 ir_if *f08DD = new(mem_ctx) ir_if(operand(r08DE).val);
                                 exec_list *const f08DD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f08DD->then_instructions;

                                    body.emit(assign(r08D2, r08B5, 0x01));

                                    body.emit(assign(r08D3, r08B6, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f08DD->else_instructions;

                                    body.emit(assign(r08D0, bit_or(r08B4, r08B5), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r08E0 = less(r08D1, body.constant(int(64)));
                                    ir_if *f08DF = new(mem_ctx) ir_if(operand(r08E0).val);
                                    exec_list *const f08DF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f08DF->then_instructions;

                                       body.emit(assign(r08D2, lshift(r08B6, r08D5), 0x01));

                                       ir_expression *const r08E1 = bit_and(r08D1, body.constant(int(31)));
                                       body.emit(assign(r08D3, rshift(r08B6, r08E1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f08DF->else_instructions;

                                       ir_variable *const r08E2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r08E4 = equal(r08D1, body.constant(int(64)));
                                       ir_if *f08E3 = new(mem_ctx) ir_if(operand(r08E4).val);
                                       exec_list *const f08E3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f08E3->then_instructions;

                                          body.emit(assign(r08E2, r08B6, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f08E3->else_instructions;

                                          ir_expression *const r08E5 = nequal(r08B6, body.constant(0u));
                                          ir_expression *const r08E6 = expr(ir_unop_b2i, r08E5);
                                          body.emit(assign(r08E2, expr(ir_unop_i2u, r08E6), 0x01));


                                       body.instructions = f08E3_parent_instructions;
                                       body.emit(f08E3);

                                       /* END IF */

                                       body.emit(assign(r08D2, r08E2, 0x01));

                                       body.emit(assign(r08D3, body.constant(0u), 0x01));


                                    body.instructions = f08DF_parent_instructions;
                                    body.emit(f08DF);

                                    /* END IF */


                                 body.instructions = f08DD_parent_instructions;
                                 body.emit(f08DD);

                                 /* END IF */

                                 body.emit(assign(r08D4, body.constant(0u), 0x01));


                              body.instructions = f08D9_parent_instructions;
                              body.emit(f08D9);

                              /* END IF */

                              ir_expression *const r08E7 = nequal(r08D0, body.constant(0u));
                              ir_expression *const r08E8 = expr(ir_unop_b2i, r08E7);
                              ir_expression *const r08E9 = expr(ir_unop_i2u, r08E8);
                              body.emit(assign(r08D2, bit_or(r08D2, r08E9), 0x01));


                           body.instructions = f08D7_parent_instructions;
                           body.emit(f08D7);

                           /* END IF */

                           body.emit(assign(r08BA, r08D4, 0x01));

                           body.emit(assign(r08BB, r08D3, 0x01));

                           body.emit(assign(r08BC, r08D2, 0x01));

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));

                           body.emit(assign(r08BF, less(r08D2, body.constant(0u)), 0x01));


                        body.instructions = f08CE_parent_instructions;
                        body.emit(f08CE);

                        /* END IF */


                     body.instructions = f08CB_parent_instructions;
                     body.emit(f08CB);

                     /* END IF */


                  body.instructions = f08C1_parent_instructions;
                  body.emit(f08C1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f08EA = new(mem_ctx) ir_if(operand(r08BD).val);
                  exec_list *const f08EA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08EA->then_instructions;

                     /* IF CONDITION */
                     ir_if *f08EB = new(mem_ctx) ir_if(operand(r08BF).val);
                     exec_list *const f08EB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08EB->then_instructions;

                        ir_variable *const r08EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r08EC, add(r08BB, body.constant(1u)), 0x01));

                        ir_expression *const r08ED = less(r08EC, r08BB);
                        ir_expression *const r08EE = expr(ir_unop_b2i, r08ED);
                        ir_expression *const r08EF = expr(ir_unop_i2u, r08EE);
                        body.emit(assign(r08BA, add(r08BA, r08EF), 0x01));

                        ir_expression *const r08F0 = equal(r08BC, body.constant(0u));
                        ir_expression *const r08F1 = expr(ir_unop_b2i, r08F0);
                        ir_expression *const r08F2 = expr(ir_unop_i2u, r08F1);
                        ir_expression *const r08F3 = add(r08BC, r08F2);
                        ir_expression *const r08F4 = bit_and(r08F3, body.constant(1u));
                        ir_expression *const r08F5 = expr(ir_unop_bit_not, r08F4);
                        body.emit(assign(r08BB, bit_and(r08EC, r08F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08EB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08F7 = bit_or(r08BA, r08BB);
                        ir_expression *const r08F8 = equal(r08F7, body.constant(0u));
                        ir_if *f08F6 = new(mem_ctx) ir_if(operand(r08F8).val);
                        exec_list *const f08F6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08F6->then_instructions;

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));


                        body.instructions = f08F6_parent_instructions;
                        body.emit(f08F6);

                        /* END IF */


                     body.instructions = f08EB_parent_instructions;
                     body.emit(f08EB);

                     /* END IF */

                     ir_variable *const r08F9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r08F9);
                     ir_expression *const r08FA = lshift(r07EC, body.constant(int(31)));
                     ir_expression *const r08FB = expr(ir_unop_i2u, r08B9);
                     ir_expression *const r08FC = lshift(r08FB, body.constant(int(20)));
                     ir_expression *const r08FD = add(r08FA, r08FC);
                     body.emit(assign(r08F9, add(r08FD, r08BA), 0x02));

                     body.emit(assign(r08F9, r08BB, 0x01));

                     body.emit(assign(r08BE, r08F9, 0x03));

                     body.emit(assign(r08BD, body.constant(false), 0x01));


                  body.instructions = f08EA_parent_instructions;
                  body.emit(f08EA);

                  /* END IF */

                  body.emit(assign(r07F1, r08BE, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f08B0_parent_instructions;
               body.emit(f08B0);

               /* END IF */


            body.instructions = f0886_parent_instructions;
            body.emit(f0886);

            /* END IF */


         body.instructions = f0844_parent_instructions;
         body.emit(f0844);

         /* END IF */


      body.instructions = f0805_parent_instructions;
      body.emit(f0805);

      /* END IF */

      /* IF CONDITION */
      ir_if *f08FE = new(mem_ctx) ir_if(operand(r07F0).val);
      exec_list *const f08FE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f08FE->then_instructions;

         body.emit(assign(r07F5, bit_or(r07F5, body.constant(1048576u)), 0x01));

         ir_variable *const r08FF = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0900 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r0900, add(r07F6, r07F4), 0x01));

         ir_expression *const r0901 = add(r07F5, r07F3);
         ir_expression *const r0902 = less(r0900, r07F6);
         ir_expression *const r0903 = expr(ir_unop_b2i, r0902);
         ir_expression *const r0904 = expr(ir_unop_i2u, r0903);
         body.emit(assign(r08FF, add(r0901, r0904), 0x01));

         body.emit(assign(r07F9, r08FF, 0x01));

         body.emit(assign(r07F7, add(r07F7, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0906 = less(r08FF, body.constant(2097152u));
         ir_if *f0905 = new(mem_ctx) ir_if(operand(r0906).val);
         exec_list *const f0905_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0905->then_instructions;

            ir_variable *const r0907 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0907, r07F7, 0x01));

            ir_variable *const r0908 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0908, r08FF, 0x01));

            ir_variable *const r0909 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0909, r0900, 0x01));

            ir_variable *const r090A = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r090A, r07F8, 0x01));

            ir_variable *const r090B = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r090B, body.constant(true), 0x01));

            ir_variable *const r090C = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r090D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r090D);
            ir_expression *const r090E = expr(ir_unop_u2i, r07F8);
            body.emit(assign(r090D, less(r090E, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0910 = lequal(body.constant(int(2045)), r07F7);
            ir_if *f090F = new(mem_ctx) ir_if(operand(r0910).val);
            exec_list *const f090F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f090F->then_instructions;

               ir_variable *const r0911 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0913 = less(body.constant(int(2045)), r07F7);
               ir_if *f0912 = new(mem_ctx) ir_if(operand(r0913).val);
               exec_list *const f0912_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0912->then_instructions;

                  body.emit(assign(r0911, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0912->else_instructions;

                  ir_variable *const r0914 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0916 = equal(r07F7, body.constant(int(2045)));
                  ir_if *f0915 = new(mem_ctx) ir_if(operand(r0916).val);
                  exec_list *const f0915_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0915->then_instructions;

                     ir_expression *const r0917 = equal(body.constant(2097151u), r08FF);
                     ir_expression *const r0918 = equal(body.constant(4294967295u), r0900);
                     body.emit(assign(r0914, logic_and(r0917, r0918), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0915->else_instructions;

                     body.emit(assign(r0914, body.constant(false), 0x01));


                  body.instructions = f0915_parent_instructions;
                  body.emit(f0915);

                  /* END IF */

                  body.emit(assign(r0911, logic_and(r0914, r090D), 0x01));


               body.instructions = f0912_parent_instructions;
               body.emit(f0912);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0919 = new(mem_ctx) ir_if(operand(r0911).val);
               exec_list *const f0919_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0919->then_instructions;

                  ir_variable *const r091A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r091A);
                  ir_expression *const r091B = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r091A, add(r091B, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r091A, body.constant(0u), 0x01));

                  body.emit(assign(r090C, r091A, 0x03));

                  body.emit(assign(r090B, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0919->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r091D = less(r07F7, body.constant(int(0)));
                  ir_if *f091C = new(mem_ctx) ir_if(operand(r091D).val);
                  exec_list *const f091C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f091C->then_instructions;

                     ir_variable *const r091E = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r091E, r07F8, 0x01));

                     ir_variable *const r091F = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r091F, neg(r07F7), 0x01));

                     ir_variable *const r0920 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0920);
                     ir_variable *const r0921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0921);
                     ir_variable *const r0922 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0922);
                     ir_variable *const r0923 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0924 = neg(r091F);
                     body.emit(assign(r0923, bit_and(r0924, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0926 = equal(r091F, body.constant(int(0)));
                     ir_if *f0925 = new(mem_ctx) ir_if(operand(r0926).val);
                     exec_list *const f0925_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0925->then_instructions;

                        body.emit(assign(r0920, r07F8, 0x01));

                        body.emit(assign(r0921, r0900, 0x01));

                        body.emit(assign(r0922, r08FF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0925->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0928 = less(r091F, body.constant(int(32)));
                        ir_if *f0927 = new(mem_ctx) ir_if(operand(r0928).val);
                        exec_list *const f0927_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0927->then_instructions;

                           body.emit(assign(r0920, lshift(r0900, r0923), 0x01));

                           ir_expression *const r0929 = lshift(r08FF, r0923);
                           ir_expression *const r092A = rshift(r0900, r091F);
                           body.emit(assign(r0921, bit_or(r0929, r092A), 0x01));

                           body.emit(assign(r0922, rshift(r08FF, r091F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0927->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r092C = equal(r091F, body.constant(int(32)));
                           ir_if *f092B = new(mem_ctx) ir_if(operand(r092C).val);
                           exec_list *const f092B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f092B->then_instructions;

                              body.emit(assign(r0920, r0900, 0x01));

                              body.emit(assign(r0921, r08FF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f092B->else_instructions;

                              body.emit(assign(r091E, bit_or(r07F8, r0900), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r092E = less(r091F, body.constant(int(64)));
                              ir_if *f092D = new(mem_ctx) ir_if(operand(r092E).val);
                              exec_list *const f092D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f092D->then_instructions;

                                 body.emit(assign(r0920, lshift(r08FF, r0923), 0x01));

                                 ir_expression *const r092F = bit_and(r091F, body.constant(int(31)));
                                 body.emit(assign(r0921, rshift(r08FF, r092F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f092D->else_instructions;

                                 ir_variable *const r0930 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0932 = equal(r091F, body.constant(int(64)));
                                 ir_if *f0931 = new(mem_ctx) ir_if(operand(r0932).val);
                                 exec_list *const f0931_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0931->then_instructions;

                                    body.emit(assign(r0930, r08FF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0931->else_instructions;

                                    ir_expression *const r0933 = nequal(r08FF, body.constant(0u));
                                    ir_expression *const r0934 = expr(ir_unop_b2i, r0933);
                                    body.emit(assign(r0930, expr(ir_unop_i2u, r0934), 0x01));


                                 body.instructions = f0931_parent_instructions;
                                 body.emit(f0931);

                                 /* END IF */

                                 body.emit(assign(r0920, r0930, 0x01));

                                 body.emit(assign(r0921, body.constant(0u), 0x01));


                              body.instructions = f092D_parent_instructions;
                              body.emit(f092D);

                              /* END IF */


                           body.instructions = f092B_parent_instructions;
                           body.emit(f092B);

                           /* END IF */

                           body.emit(assign(r0922, body.constant(0u), 0x01));


                        body.instructions = f0927_parent_instructions;
                        body.emit(f0927);

                        /* END IF */

                        ir_expression *const r0935 = nequal(r091E, body.constant(0u));
                        ir_expression *const r0936 = expr(ir_unop_b2i, r0935);
                        ir_expression *const r0937 = expr(ir_unop_i2u, r0936);
                        body.emit(assign(r0920, bit_or(r0920, r0937), 0x01));


                     body.instructions = f0925_parent_instructions;
                     body.emit(f0925);

                     /* END IF */

                     body.emit(assign(r0908, r0922, 0x01));

                     body.emit(assign(r0909, r0921, 0x01));

                     body.emit(assign(r090A, r0920, 0x01));

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));

                     body.emit(assign(r090D, less(r0920, body.constant(0u)), 0x01));


                  body.instructions = f091C_parent_instructions;
                  body.emit(f091C);

                  /* END IF */


               body.instructions = f0919_parent_instructions;
               body.emit(f0919);

               /* END IF */


            body.instructions = f090F_parent_instructions;
            body.emit(f090F);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0938 = new(mem_ctx) ir_if(operand(r090B).val);
            exec_list *const f0938_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0938->then_instructions;

               /* IF CONDITION */
               ir_if *f0939 = new(mem_ctx) ir_if(operand(r090D).val);
               exec_list *const f0939_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0939->then_instructions;

                  ir_variable *const r093A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r093A, add(r0909, body.constant(1u)), 0x01));

                  ir_expression *const r093B = less(r093A, r0909);
                  ir_expression *const r093C = expr(ir_unop_b2i, r093B);
                  ir_expression *const r093D = expr(ir_unop_i2u, r093C);
                  body.emit(assign(r0908, add(r0908, r093D), 0x01));

                  ir_expression *const r093E = equal(r090A, body.constant(0u));
                  ir_expression *const r093F = expr(ir_unop_b2i, r093E);
                  ir_expression *const r0940 = expr(ir_unop_i2u, r093F);
                  ir_expression *const r0941 = add(r090A, r0940);
                  ir_expression *const r0942 = bit_and(r0941, body.constant(1u));
                  ir_expression *const r0943 = expr(ir_unop_bit_not, r0942);
                  body.emit(assign(r0909, bit_and(r093A, r0943), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0939->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0945 = bit_or(r0908, r0909);
                  ir_expression *const r0946 = equal(r0945, body.constant(0u));
                  ir_if *f0944 = new(mem_ctx) ir_if(operand(r0946).val);
                  exec_list *const f0944_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0944->then_instructions;

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));


                  body.instructions = f0944_parent_instructions;
                  body.emit(f0944);

                  /* END IF */


               body.instructions = f0939_parent_instructions;
               body.emit(f0939);

               /* END IF */

               ir_variable *const r0947 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0947);
               ir_expression *const r0948 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0949 = expr(ir_unop_i2u, r0907);
               ir_expression *const r094A = lshift(r0949, body.constant(int(20)));
               ir_expression *const r094B = add(r0948, r094A);
               body.emit(assign(r0947, add(r094B, r0908), 0x02));

               body.emit(assign(r0947, r0909, 0x01));

               body.emit(assign(r090C, r0947, 0x03));

               body.emit(assign(r090B, body.constant(false), 0x01));


            body.instructions = f0938_parent_instructions;
            body.emit(f0938);

            /* END IF */

            body.emit(assign(r07F1, r090C, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0905->else_instructions;

            body.emit(assign(r07F7, add(r07F7, body.constant(int(1))), 0x01));

            ir_variable *const r094C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r094C);
            ir_variable *const r094D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r094D);
            ir_variable *const r094E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r094E);
            body.emit(assign(r094C, lshift(r0900, body.constant(int(31))), 0x01));

            ir_expression *const r094F = lshift(r08FF, body.constant(int(31)));
            ir_expression *const r0950 = rshift(r0900, body.constant(int(1)));
            body.emit(assign(r094D, bit_or(r094F, r0950), 0x01));

            body.emit(assign(r094E, rshift(r08FF, body.constant(int(1))), 0x01));

            ir_expression *const r0951 = nequal(r07F8, body.constant(0u));
            ir_expression *const r0952 = expr(ir_unop_b2i, r0951);
            ir_expression *const r0953 = expr(ir_unop_i2u, r0952);
            body.emit(assign(r094C, bit_or(r094C, r0953), 0x01));

            body.emit(assign(r07F9, r094E, 0x01));

            body.emit(assign(r07F8, r094C, 0x01));

            ir_variable *const r0954 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0954, r07F7, 0x01));

            ir_variable *const r0955 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0955, r094E, 0x01));

            ir_variable *const r0956 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0956, r094D, 0x01));

            ir_variable *const r0957 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0957, r094C, 0x01));

            ir_variable *const r0958 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0958, body.constant(true), 0x01));

            ir_variable *const r0959 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r095A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r095A);
            ir_expression *const r095B = expr(ir_unop_u2i, r094C);
            body.emit(assign(r095A, less(r095B, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r095D = lequal(body.constant(int(2045)), r07F7);
            ir_if *f095C = new(mem_ctx) ir_if(operand(r095D).val);
            exec_list *const f095C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f095C->then_instructions;

               ir_variable *const r095E = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0960 = less(body.constant(int(2045)), r07F7);
               ir_if *f095F = new(mem_ctx) ir_if(operand(r0960).val);
               exec_list *const f095F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f095F->then_instructions;

                  body.emit(assign(r095E, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f095F->else_instructions;

                  ir_variable *const r0961 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0963 = equal(r07F7, body.constant(int(2045)));
                  ir_if *f0962 = new(mem_ctx) ir_if(operand(r0963).val);
                  exec_list *const f0962_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0962->then_instructions;

                     ir_expression *const r0964 = equal(body.constant(2097151u), r094E);
                     ir_expression *const r0965 = equal(body.constant(4294967295u), r094D);
                     body.emit(assign(r0961, logic_and(r0964, r0965), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0962->else_instructions;

                     body.emit(assign(r0961, body.constant(false), 0x01));


                  body.instructions = f0962_parent_instructions;
                  body.emit(f0962);

                  /* END IF */

                  body.emit(assign(r095E, logic_and(r0961, r095A), 0x01));


               body.instructions = f095F_parent_instructions;
               body.emit(f095F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0966 = new(mem_ctx) ir_if(operand(r095E).val);
               exec_list *const f0966_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0966->then_instructions;

                  ir_variable *const r0967 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0967);
                  ir_expression *const r0968 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0967, add(r0968, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0967, body.constant(0u), 0x01));

                  body.emit(assign(r0959, r0967, 0x03));

                  body.emit(assign(r0958, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0966->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r096A = less(r07F7, body.constant(int(0)));
                  ir_if *f0969 = new(mem_ctx) ir_if(operand(r096A).val);
                  exec_list *const f0969_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0969->then_instructions;

                     ir_variable *const r096B = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r096B, r094C, 0x01));

                     ir_variable *const r096C = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r096C, neg(r07F7), 0x01));

                     ir_variable *const r096D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r096D);
                     ir_variable *const r096E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r096E);
                     ir_variable *const r096F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r096F);
                     ir_variable *const r0970 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0971 = neg(r096C);
                     body.emit(assign(r0970, bit_and(r0971, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0973 = equal(r096C, body.constant(int(0)));
                     ir_if *f0972 = new(mem_ctx) ir_if(operand(r0973).val);
                     exec_list *const f0972_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0972->then_instructions;

                        body.emit(assign(r096D, r094C, 0x01));

                        body.emit(assign(r096E, r094D, 0x01));

                        body.emit(assign(r096F, r094E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0972->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0975 = less(r096C, body.constant(int(32)));
                        ir_if *f0974 = new(mem_ctx) ir_if(operand(r0975).val);
                        exec_list *const f0974_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0974->then_instructions;

                           body.emit(assign(r096D, lshift(r094D, r0970), 0x01));

                           ir_expression *const r0976 = lshift(r094E, r0970);
                           ir_expression *const r0977 = rshift(r094D, r096C);
                           body.emit(assign(r096E, bit_or(r0976, r0977), 0x01));

                           body.emit(assign(r096F, rshift(r094E, r096C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0974->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0979 = equal(r096C, body.constant(int(32)));
                           ir_if *f0978 = new(mem_ctx) ir_if(operand(r0979).val);
                           exec_list *const f0978_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0978->then_instructions;

                              body.emit(assign(r096D, r094D, 0x01));

                              body.emit(assign(r096E, r094E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0978->else_instructions;

                              body.emit(assign(r096B, bit_or(r094C, r094D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r097B = less(r096C, body.constant(int(64)));
                              ir_if *f097A = new(mem_ctx) ir_if(operand(r097B).val);
                              exec_list *const f097A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f097A->then_instructions;

                                 body.emit(assign(r096D, lshift(r094E, r0970), 0x01));

                                 ir_expression *const r097C = bit_and(r096C, body.constant(int(31)));
                                 body.emit(assign(r096E, rshift(r094E, r097C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f097A->else_instructions;

                                 ir_variable *const r097D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r097F = equal(r096C, body.constant(int(64)));
                                 ir_if *f097E = new(mem_ctx) ir_if(operand(r097F).val);
                                 exec_list *const f097E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f097E->then_instructions;

                                    body.emit(assign(r097D, r094E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f097E->else_instructions;

                                    ir_expression *const r0980 = nequal(r094E, body.constant(0u));
                                    ir_expression *const r0981 = expr(ir_unop_b2i, r0980);
                                    body.emit(assign(r097D, expr(ir_unop_i2u, r0981), 0x01));


                                 body.instructions = f097E_parent_instructions;
                                 body.emit(f097E);

                                 /* END IF */

                                 body.emit(assign(r096D, r097D, 0x01));

                                 body.emit(assign(r096E, body.constant(0u), 0x01));


                              body.instructions = f097A_parent_instructions;
                              body.emit(f097A);

                              /* END IF */


                           body.instructions = f0978_parent_instructions;
                           body.emit(f0978);

                           /* END IF */

                           body.emit(assign(r096F, body.constant(0u), 0x01));


                        body.instructions = f0974_parent_instructions;
                        body.emit(f0974);

                        /* END IF */

                        ir_expression *const r0982 = nequal(r096B, body.constant(0u));
                        ir_expression *const r0983 = expr(ir_unop_b2i, r0982);
                        ir_expression *const r0984 = expr(ir_unop_i2u, r0983);
                        body.emit(assign(r096D, bit_or(r096D, r0984), 0x01));


                     body.instructions = f0972_parent_instructions;
                     body.emit(f0972);

                     /* END IF */

                     body.emit(assign(r0955, r096F, 0x01));

                     body.emit(assign(r0956, r096E, 0x01));

                     body.emit(assign(r0957, r096D, 0x01));

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));

                     body.emit(assign(r095A, less(r096D, body.constant(0u)), 0x01));


                  body.instructions = f0969_parent_instructions;
                  body.emit(f0969);

                  /* END IF */


               body.instructions = f0966_parent_instructions;
               body.emit(f0966);

               /* END IF */


            body.instructions = f095C_parent_instructions;
            body.emit(f095C);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0985 = new(mem_ctx) ir_if(operand(r0958).val);
            exec_list *const f0985_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0985->then_instructions;

               /* IF CONDITION */
               ir_if *f0986 = new(mem_ctx) ir_if(operand(r095A).val);
               exec_list *const f0986_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0986->then_instructions;

                  ir_variable *const r0987 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0987, add(r0956, body.constant(1u)), 0x01));

                  ir_expression *const r0988 = less(r0987, r0956);
                  ir_expression *const r0989 = expr(ir_unop_b2i, r0988);
                  ir_expression *const r098A = expr(ir_unop_i2u, r0989);
                  body.emit(assign(r0955, add(r0955, r098A), 0x01));

                  ir_expression *const r098B = equal(r0957, body.constant(0u));
                  ir_expression *const r098C = expr(ir_unop_b2i, r098B);
                  ir_expression *const r098D = expr(ir_unop_i2u, r098C);
                  ir_expression *const r098E = add(r0957, r098D);
                  ir_expression *const r098F = bit_and(r098E, body.constant(1u));
                  ir_expression *const r0990 = expr(ir_unop_bit_not, r098F);
                  body.emit(assign(r0956, bit_and(r0987, r0990), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0986->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0992 = bit_or(r0955, r0956);
                  ir_expression *const r0993 = equal(r0992, body.constant(0u));
                  ir_if *f0991 = new(mem_ctx) ir_if(operand(r0993).val);
                  exec_list *const f0991_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0991->then_instructions;

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));


                  body.instructions = f0991_parent_instructions;
                  body.emit(f0991);

                  /* END IF */


               body.instructions = f0986_parent_instructions;
               body.emit(f0986);

               /* END IF */

               ir_variable *const r0994 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0994);
               ir_expression *const r0995 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0996 = expr(ir_unop_i2u, r0954);
               ir_expression *const r0997 = lshift(r0996, body.constant(int(20)));
               ir_expression *const r0998 = add(r0995, r0997);
               body.emit(assign(r0994, add(r0998, r0955), 0x02));

               body.emit(assign(r0994, r0956, 0x01));

               body.emit(assign(r0959, r0994, 0x03));

               body.emit(assign(r0958, body.constant(false), 0x01));


            body.instructions = f0985_parent_instructions;
            body.emit(f0985);

            /* END IF */

            body.emit(assign(r07F1, r0959, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


         body.instructions = f0905_parent_instructions;
         body.emit(f0905);

         /* END IF */


      body.instructions = f08FE_parent_instructions;
      body.emit(f08FE);

      /* END IF */

      body.emit(assign(r07EB, r07F1, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f07EE->else_instructions;

      ir_variable *const r0999 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0999, r07EC, 0x01));

      ir_variable *const r099A = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r099B = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r099B);
      ir_variable *const r099C = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r099C);
      ir_variable *const r099D = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r099D);
      ir_variable *const r099E = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r099E);
      ir_variable *const r099F = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r099F);
      ir_variable *const r09A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r09A0);
      ir_variable *const r09A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r09A1);
      ir_variable *const r09A2 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r09A2);
      ir_variable *const r09A3 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A4 = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r09A5 = bit_and(r09A4, body.constant(2047u));
      body.emit(assign(r09A3, expr(ir_unop_u2i, r09A5), 0x01));

      body.emit(assign(r099D, r09A3, 0x01));

      ir_variable *const r09A6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A7 = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r09A8 = bit_and(r09A7, body.constant(2047u));
      body.emit(assign(r09A6, expr(ir_unop_u2i, r09A8), 0x01));

      body.emit(assign(r099C, r09A6, 0x01));

      body.emit(assign(r099B, sub(r09A3, r09A6), 0x01));

      ir_variable *const r09A9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09A9, lshift(swizzle_x(r07E9), body.constant(int(10))), 0x01));

      ir_variable *const r09AA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09AB = bit_and(swizzle_y(r07E9), body.constant(1048575u));
      ir_expression *const r09AC = lshift(r09AB, body.constant(int(10)));
      ir_expression *const r09AD = rshift(swizzle_x(r07E9), body.constant(int(22)));
      body.emit(assign(r09AA, bit_or(r09AC, r09AD), 0x01));

      body.emit(assign(r09A0, r09AA, 0x01));

      body.emit(assign(r09A1, r09A9, 0x01));

      ir_variable *const r09AE = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09AE, lshift(swizzle_x(r07EA), body.constant(int(10))), 0x01));

      ir_variable *const r09AF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09B0 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
      ir_expression *const r09B1 = lshift(r09B0, body.constant(int(10)));
      ir_expression *const r09B2 = rshift(swizzle_x(r07EA), body.constant(int(22)));
      body.emit(assign(r09AF, bit_or(r09B1, r09B2), 0x01));

      body.emit(assign(r099E, r09AF, 0x01));

      body.emit(assign(r099F, r09AE, 0x01));

      /* IF CONDITION */
      ir_expression *const r09B4 = less(body.constant(int(0)), r099B);
      ir_if *f09B3 = new(mem_ctx) ir_if(operand(r09B4).val);
      exec_list *const f09B3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f09B3->then_instructions;

         /* IF CONDITION */
         ir_expression *const r09B6 = equal(r09A3, body.constant(int(2047)));
         ir_if *f09B5 = new(mem_ctx) ir_if(operand(r09B6).val);
         exec_list *const f09B5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f09B5->then_instructions;

            /* IF CONDITION */
            ir_expression *const r09B8 = bit_or(r09AA, r09A9);
            ir_expression *const r09B9 = nequal(r09B8, body.constant(0u));
            ir_if *f09B7 = new(mem_ctx) ir_if(operand(r09B9).val);
            exec_list *const f09B7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09B7->then_instructions;

               ir_variable *const r09BA = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r09BA, swizzle_x(r07E9), 0x01));

               ir_variable *const r09BB = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r09BB, swizzle_x(r07EA), 0x01));

               ir_variable *const r09BC = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r09BD = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r09BE = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r09BF = bit_and(r09BE, body.constant(4095u));
               ir_expression *const r09C0 = equal(r09BF, body.constant(4094u));
               ir_expression *const r09C1 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09C2 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r09C3 = nequal(r09C2, body.constant(0u));
               ir_expression *const r09C4 = logic_or(r09C1, r09C3);
               body.emit(assign(r09BD, logic_and(r09C0, r09C4), 0x01));

               ir_variable *const r09C5 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r09C6 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r09C7 = lequal(body.constant(4292870144u), r09C6);
               ir_expression *const r09C8 = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r09C9 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r09CA = nequal(r09C9, body.constant(0u));
               ir_expression *const r09CB = logic_or(r09C8, r09CA);
               body.emit(assign(r09C5, logic_and(r09C7, r09CB), 0x01));

               body.emit(assign(r09BA, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r09BB, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r09CD = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r09CE = lequal(body.constant(4292870144u), r09CD);
               ir_expression *const r09CF = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09D0 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r09D1 = nequal(r09D0, body.constant(0u));
               ir_expression *const r09D2 = logic_or(r09CF, r09D1);
               ir_expression *const r09D3 = logic_and(r09CE, r09D2);
               ir_if *f09CC = new(mem_ctx) ir_if(operand(r09D3).val);
               exec_list *const f09CC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09CC->then_instructions;

                  ir_variable *const r09D4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r09D6 = logic_and(r09BD, r09C5);
                  ir_if *f09D5 = new(mem_ctx) ir_if(operand(r09D6).val);
                  exec_list *const f09D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09D5->then_instructions;

                     body.emit(assign(r09D4, r09BB, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09D5->else_instructions;

                     body.emit(assign(r09D4, r09BA, 0x03));


                  body.instructions = f09D5_parent_instructions;
                  body.emit(f09D5);

                  /* END IF */

                  body.emit(assign(r09BC, r09D4, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09CC->else_instructions;

                  body.emit(assign(r09BC, r09BB, 0x03));


               body.instructions = f09CC_parent_instructions;
               body.emit(f09CC);

               /* END IF */

               body.emit(assign(r099A, r09BC, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09B7->else_instructions;

               body.emit(assign(r099A, r07E9, 0x03));


            body.instructions = f09B7_parent_instructions;
            body.emit(f09B7);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f09B5->else_instructions;

            /* IF CONDITION */
            ir_expression *const r09D8 = equal(r09A6, body.constant(int(0)));
            ir_if *f09D7 = new(mem_ctx) ir_if(operand(r09D8).val);
            exec_list *const f09D7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09D7->then_instructions;

               body.emit(assign(r099B, add(r099B, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09D7->else_instructions;

               body.emit(assign(r099E, bit_or(r09AF, body.constant(1073741824u)), 0x01));


            body.instructions = f09D7_parent_instructions;
            body.emit(f09D7);

            /* END IF */

            ir_variable *const r09D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r09D9);
            ir_variable *const r09DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r09DA);
            ir_variable *const r09DB = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r09DC = neg(r099B);
            body.emit(assign(r09DB, bit_and(r09DC, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r09DE = equal(r099B, body.constant(int(0)));
            ir_if *f09DD = new(mem_ctx) ir_if(operand(r09DE).val);
            exec_list *const f09DD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09DD->then_instructions;

               body.emit(assign(r09D9, r09AE, 0x01));

               body.emit(assign(r09DA, r099E, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09DD->else_instructions;

               /* IF CONDITION */
               ir_expression *const r09E0 = less(r099B, body.constant(int(32)));
               ir_if *f09DF = new(mem_ctx) ir_if(operand(r09E0).val);
               exec_list *const f09DF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09DF->then_instructions;

                  ir_expression *const r09E1 = lshift(r099E, r09DB);
                  ir_expression *const r09E2 = rshift(r09AE, r099B);
                  ir_expression *const r09E3 = bit_or(r09E1, r09E2);
                  ir_expression *const r09E4 = lshift(r09AE, r09DB);
                  ir_expression *const r09E5 = nequal(r09E4, body.constant(0u));
                  ir_expression *const r09E6 = expr(ir_unop_b2i, r09E5);
                  ir_expression *const r09E7 = expr(ir_unop_i2u, r09E6);
                  body.emit(assign(r09D9, bit_or(r09E3, r09E7), 0x01));

                  body.emit(assign(r09DA, rshift(r099E, r099B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09DF->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r09E9 = equal(r099B, body.constant(int(32)));
                  ir_if *f09E8 = new(mem_ctx) ir_if(operand(r09E9).val);
                  exec_list *const f09E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09E8->then_instructions;

                     ir_expression *const r09EA = nequal(r09AE, body.constant(0u));
                     ir_expression *const r09EB = expr(ir_unop_b2i, r09EA);
                     ir_expression *const r09EC = expr(ir_unop_i2u, r09EB);
                     body.emit(assign(r09D9, bit_or(r099E, r09EC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09E8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r09EE = less(r099B, body.constant(int(64)));
                     ir_if *f09ED = new(mem_ctx) ir_if(operand(r09EE).val);
                     exec_list *const f09ED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f09ED->then_instructions;

                        ir_expression *const r09EF = bit_and(r099B, body.constant(int(31)));
                        ir_expression *const r09F0 = rshift(r099E, r09EF);
                        ir_expression *const r09F1 = lshift(r099E, r09DB);
                        ir_expression *const r09F2 = bit_or(r09F1, r09AE);
                        ir_expression *const r09F3 = nequal(r09F2, body.constant(0u));
                        ir_expression *const r09F4 = expr(ir_unop_b2i, r09F3);
                        ir_expression *const r09F5 = expr(ir_unop_i2u, r09F4);
                        body.emit(assign(r09D9, bit_or(r09F0, r09F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f09ED->else_instructions;

                        ir_expression *const r09F6 = bit_or(r099E, r09AE);
                        ir_expression *const r09F7 = nequal(r09F6, body.constant(0u));
                        ir_expression *const r09F8 = expr(ir_unop_b2i, r09F7);
                        body.emit(assign(r09D9, expr(ir_unop_i2u, r09F8), 0x01));


                     body.instructions = f09ED_parent_instructions;
                     body.emit(f09ED);

                     /* END IF */


                  body.instructions = f09E8_parent_instructions;
                  body.emit(f09E8);

                  /* END IF */

                  body.emit(assign(r09DA, body.constant(0u), 0x01));


               body.instructions = f09DF_parent_instructions;
               body.emit(f09DF);

               /* END IF */


            body.instructions = f09DD_parent_instructions;
            body.emit(f09DD);

            /* END IF */

            body.emit(assign(r099E, r09DA, 0x01));

            body.emit(assign(r099F, r09D9, 0x01));

            body.emit(assign(r09A0, bit_or(r09AA, body.constant(1073741824u)), 0x01));

            ir_variable *const r09F9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r09FA = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r09FA, sub(r09A9, r09D9), 0x01));

            ir_expression *const r09FB = sub(r09A0, r09DA);
            ir_expression *const r09FC = less(r09A9, r09D9);
            ir_expression *const r09FD = expr(ir_unop_b2i, r09FC);
            ir_expression *const r09FE = expr(ir_unop_i2u, r09FD);
            body.emit(assign(r09F9, sub(r09FB, r09FE), 0x01));

            body.emit(assign(r09A2, add(r09A3, body.constant(int(-1))), 0x01));

            ir_variable *const r09FF = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r09FF, add(r09A2, body.constant(int(-10))), 0x01));

            ir_variable *const r0A00 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A00, r09F9, 0x01));

            ir_variable *const r0A01 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A01, r09FA, 0x01));

            ir_variable *const r0A02 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0A02);
            ir_variable *const r0A03 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A03);
            /* IF CONDITION */
            ir_expression *const r0A05 = equal(r09F9, body.constant(0u));
            ir_if *f0A04 = new(mem_ctx) ir_if(operand(r0A05).val);
            exec_list *const f0A04_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A04->then_instructions;

               body.emit(assign(r0A00, r09FA, 0x01));

               body.emit(assign(r0A01, body.constant(0u), 0x01));

               body.emit(assign(r09FF, add(r09FF, body.constant(int(-32))), 0x01));


            body.instructions = f0A04_parent_instructions;
            body.emit(f0A04);

            /* END IF */

            ir_variable *const r0A06 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0A06, r0A00, 0x01));

            ir_variable *const r0A07 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0A08 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A08);
            /* IF CONDITION */
            ir_expression *const r0A0A = equal(r0A00, body.constant(0u));
            ir_if *f0A09 = new(mem_ctx) ir_if(operand(r0A0A).val);
            exec_list *const f0A09_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A09->then_instructions;

               body.emit(assign(r0A07, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A09->else_instructions;

               body.emit(assign(r0A08, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A0C = bit_and(r0A00, body.constant(4294901760u));
               ir_expression *const r0A0D = equal(r0A0C, body.constant(0u));
               ir_if *f0A0B = new(mem_ctx) ir_if(operand(r0A0D).val);
               exec_list *const f0A0B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0B->then_instructions;

                  body.emit(assign(r0A08, body.constant(int(16)), 0x01));

                  body.emit(assign(r0A06, lshift(r0A00, body.constant(int(16))), 0x01));


               body.instructions = f0A0B_parent_instructions;
               body.emit(f0A0B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A0F = bit_and(r0A06, body.constant(4278190080u));
               ir_expression *const r0A10 = equal(r0A0F, body.constant(0u));
               ir_if *f0A0E = new(mem_ctx) ir_if(operand(r0A10).val);
               exec_list *const f0A0E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0E->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(8))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(8))), 0x01));


               body.instructions = f0A0E_parent_instructions;
               body.emit(f0A0E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A12 = bit_and(r0A06, body.constant(4026531840u));
               ir_expression *const r0A13 = equal(r0A12, body.constant(0u));
               ir_if *f0A11 = new(mem_ctx) ir_if(operand(r0A13).val);
               exec_list *const f0A11_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A11->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(4))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(4))), 0x01));


               body.instructions = f0A11_parent_instructions;
               body.emit(f0A11);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A15 = bit_and(r0A06, body.constant(3221225472u));
               ir_expression *const r0A16 = equal(r0A15, body.constant(0u));
               ir_if *f0A14 = new(mem_ctx) ir_if(operand(r0A16).val);
               exec_list *const f0A14_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A14->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(2))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(2))), 0x01));


               body.instructions = f0A14_parent_instructions;
               body.emit(f0A14);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A18 = bit_and(r0A06, body.constant(2147483648u));
               ir_expression *const r0A19 = equal(r0A18, body.constant(0u));
               ir_if *f0A17 = new(mem_ctx) ir_if(operand(r0A19).val);
               exec_list *const f0A17_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A17->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(1))), 0x01));


               body.instructions = f0A17_parent_instructions;
               body.emit(f0A17);

               /* END IF */

               body.emit(assign(r0A07, r0A08, 0x01));


            body.instructions = f0A09_parent_instructions;
            body.emit(f0A09);

            /* END IF */

            body.emit(assign(r0A03, add(r0A07, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A1B = lequal(body.constant(int(0)), r0A03);
            ir_if *f0A1A = new(mem_ctx) ir_if(operand(r0A1B).val);
            exec_list *const f0A1A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A1A->then_instructions;

               body.emit(assign(r0A02, body.constant(0u), 0x01));

               ir_variable *const r0A1C = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0A1C, lshift(r0A01, r0A03), 0x01));

               ir_variable *const r0A1D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0A1F = equal(r0A03, body.constant(int(0)));
               ir_if *f0A1E = new(mem_ctx) ir_if(operand(r0A1F).val);
               exec_list *const f0A1E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A1E->then_instructions;

                  body.emit(assign(r0A1D, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A1E->else_instructions;

                  ir_expression *const r0A20 = lshift(r0A00, r0A03);
                  ir_expression *const r0A21 = neg(r0A03);
                  ir_expression *const r0A22 = bit_and(r0A21, body.constant(int(31)));
                  ir_expression *const r0A23 = rshift(r0A01, r0A22);
                  body.emit(assign(r0A1D, bit_or(r0A20, r0A23), 0x01));


               body.instructions = f0A1E_parent_instructions;
               body.emit(f0A1E);

               /* END IF */

               body.emit(assign(r0A00, r0A1D, 0x01));

               body.emit(assign(r0A01, r0A1C, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A1A->else_instructions;

               ir_variable *const r0A24 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0A24, body.constant(0u), 0x01));

               ir_variable *const r0A25 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0A25, neg(r0A03), 0x01));

               ir_variable *const r0A26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0A26);
               ir_variable *const r0A27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0A27);
               ir_variable *const r0A28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0A28);
               ir_variable *const r0A29 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0A2A = neg(r0A25);
               body.emit(assign(r0A29, bit_and(r0A2A, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A2C = equal(r0A25, body.constant(int(0)));
               ir_if *f0A2B = new(mem_ctx) ir_if(operand(r0A2C).val);
               exec_list *const f0A2B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A2B->then_instructions;

                  body.emit(assign(r0A26, r0A24, 0x01));

                  body.emit(assign(r0A27, r0A01, 0x01));

                  body.emit(assign(r0A28, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A2B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A2E = less(r0A25, body.constant(int(32)));
                  ir_if *f0A2D = new(mem_ctx) ir_if(operand(r0A2E).val);
                  exec_list *const f0A2D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A2D->then_instructions;

                     body.emit(assign(r0A26, lshift(r0A01, r0A29), 0x01));

                     ir_expression *const r0A2F = lshift(r0A00, r0A29);
                     ir_expression *const r0A30 = rshift(r0A01, r0A25);
                     body.emit(assign(r0A27, bit_or(r0A2F, r0A30), 0x01));

                     body.emit(assign(r0A28, rshift(r0A00, r0A25), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A2D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0A32 = equal(r0A25, body.constant(int(32)));
                     ir_if *f0A31 = new(mem_ctx) ir_if(operand(r0A32).val);
                     exec_list *const f0A31_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A31->then_instructions;

                        body.emit(assign(r0A26, r0A01, 0x01));

                        body.emit(assign(r0A27, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A31->else_instructions;

                        body.emit(assign(r0A24, bit_or(body.constant(0u), r0A01), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0A34 = less(r0A25, body.constant(int(64)));
                        ir_if *f0A33 = new(mem_ctx) ir_if(operand(r0A34).val);
                        exec_list *const f0A33_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A33->then_instructions;

                           body.emit(assign(r0A26, lshift(r0A00, r0A29), 0x01));

                           ir_expression *const r0A35 = bit_and(r0A25, body.constant(int(31)));
                           body.emit(assign(r0A27, rshift(r0A00, r0A35), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A33->else_instructions;

                           ir_variable *const r0A36 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0A38 = equal(r0A25, body.constant(int(64)));
                           ir_if *f0A37 = new(mem_ctx) ir_if(operand(r0A38).val);
                           exec_list *const f0A37_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A37->then_instructions;

                              body.emit(assign(r0A36, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A37->else_instructions;

                              ir_expression *const r0A39 = nequal(r0A00, body.constant(0u));
                              ir_expression *const r0A3A = expr(ir_unop_b2i, r0A39);
                              body.emit(assign(r0A36, expr(ir_unop_i2u, r0A3A), 0x01));


                           body.instructions = f0A37_parent_instructions;
                           body.emit(f0A37);

                           /* END IF */

                           body.emit(assign(r0A26, r0A36, 0x01));

                           body.emit(assign(r0A27, body.constant(0u), 0x01));


                        body.instructions = f0A33_parent_instructions;
                        body.emit(f0A33);

                        /* END IF */


                     body.instructions = f0A31_parent_instructions;
                     body.emit(f0A31);

                     /* END IF */

                     body.emit(assign(r0A28, body.constant(0u), 0x01));


                  body.instructions = f0A2D_parent_instructions;
                  body.emit(f0A2D);

                  /* END IF */

                  ir_expression *const r0A3B = nequal(r0A24, body.constant(0u));
                  ir_expression *const r0A3C = expr(ir_unop_b2i, r0A3B);
                  ir_expression *const r0A3D = expr(ir_unop_i2u, r0A3C);
                  body.emit(assign(r0A26, bit_or(r0A26, r0A3D), 0x01));


               body.instructions = f0A2B_parent_instructions;
               body.emit(f0A2B);

               /* END IF */

               body.emit(assign(r0A00, r0A28, 0x01));

               body.emit(assign(r0A01, r0A27, 0x01));

               body.emit(assign(r0A02, r0A26, 0x01));


            body.instructions = f0A1A_parent_instructions;
            body.emit(f0A1A);

            /* END IF */

            body.emit(assign(r09FF, sub(r09FF, r0A03), 0x01));

            ir_variable *const r0A3E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0A3E, r09FF, 0x01));

            ir_variable *const r0A3F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A3F, r0A00, 0x01));

            ir_variable *const r0A40 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A40, r0A01, 0x01));

            ir_variable *const r0A41 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0A41, r0A02, 0x01));

            ir_variable *const r0A42 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0A42, body.constant(true), 0x01));

            ir_variable *const r0A43 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0A44 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0A44);
            ir_expression *const r0A45 = expr(ir_unop_u2i, r0A02);
            body.emit(assign(r0A44, less(r0A45, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A47 = lequal(body.constant(int(2045)), r09FF);
            ir_if *f0A46 = new(mem_ctx) ir_if(operand(r0A47).val);
            exec_list *const f0A46_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A46->then_instructions;

               ir_variable *const r0A48 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0A4A = less(body.constant(int(2045)), r09FF);
               ir_if *f0A49 = new(mem_ctx) ir_if(operand(r0A4A).val);
               exec_list *const f0A49_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A49->then_instructions;

                  body.emit(assign(r0A48, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A49->else_instructions;

                  ir_variable *const r0A4B = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0A4D = equal(r09FF, body.constant(int(2045)));
                  ir_if *f0A4C = new(mem_ctx) ir_if(operand(r0A4D).val);
                  exec_list *const f0A4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A4C->then_instructions;

                     ir_expression *const r0A4E = equal(body.constant(2097151u), r0A00);
                     ir_expression *const r0A4F = equal(body.constant(4294967295u), r0A01);
                     body.emit(assign(r0A4B, logic_and(r0A4E, r0A4F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A4C->else_instructions;

                     body.emit(assign(r0A4B, body.constant(false), 0x01));


                  body.instructions = f0A4C_parent_instructions;
                  body.emit(f0A4C);

                  /* END IF */

                  body.emit(assign(r0A48, logic_and(r0A4B, r0A44), 0x01));


               body.instructions = f0A49_parent_instructions;
               body.emit(f0A49);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0A50 = new(mem_ctx) ir_if(operand(r0A48).val);
               exec_list *const f0A50_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A50->then_instructions;

                  ir_variable *const r0A51 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0A51);
                  ir_expression *const r0A52 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0A51, add(r0A52, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0A51, body.constant(0u), 0x01));

                  body.emit(assign(r0A43, r0A51, 0x03));

                  body.emit(assign(r0A42, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A50->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A54 = less(r09FF, body.constant(int(0)));
                  ir_if *f0A53 = new(mem_ctx) ir_if(operand(r0A54).val);
                  exec_list *const f0A53_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A53->then_instructions;

                     ir_variable *const r0A55 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0A55, r0A02, 0x01));

                     ir_variable *const r0A56 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0A56, neg(r09FF), 0x01));

                     ir_variable *const r0A57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0A57);
                     ir_variable *const r0A58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0A58);
                     ir_variable *const r0A59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0A59);
                     ir_variable *const r0A5A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0A5B = neg(r0A56);
                     body.emit(assign(r0A5A, bit_and(r0A5B, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0A5D = equal(r0A56, body.constant(int(0)));
                     ir_if *f0A5C = new(mem_ctx) ir_if(operand(r0A5D).val);
                     exec_list *const f0A5C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A5C->then_instructions;

                        body.emit(assign(r0A57, r0A02, 0x01));

                        body.emit(assign(r0A58, r0A01, 0x01));

                        body.emit(assign(r0A59, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A5C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0A5F = less(r0A56, body.constant(int(32)));
                        ir_if *f0A5E = new(mem_ctx) ir_if(operand(r0A5F).val);
                        exec_list *const f0A5E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A5E->then_instructions;

                           body.emit(assign(r0A57, lshift(r0A01, r0A5A), 0x01));

                           ir_expression *const r0A60 = lshift(r0A00, r0A5A);
                           ir_expression *const r0A61 = rshift(r0A01, r0A56);
                           body.emit(assign(r0A58, bit_or(r0A60, r0A61), 0x01));

                           body.emit(assign(r0A59, rshift(r0A00, r0A56), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A5E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0A63 = equal(r0A56, body.constant(int(32)));
                           ir_if *f0A62 = new(mem_ctx) ir_if(operand(r0A63).val);
                           exec_list *const f0A62_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A62->then_instructions;

                              body.emit(assign(r0A57, r0A01, 0x01));

                              body.emit(assign(r0A58, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A62->else_instructions;

                              body.emit(assign(r0A55, bit_or(r0A02, r0A01), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0A65 = less(r0A56, body.constant(int(64)));
                              ir_if *f0A64 = new(mem_ctx) ir_if(operand(r0A65).val);
                              exec_list *const f0A64_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0A64->then_instructions;

                                 body.emit(assign(r0A57, lshift(r0A00, r0A5A), 0x01));

                                 ir_expression *const r0A66 = bit_and(r0A56, body.constant(int(31)));
                                 body.emit(assign(r0A58, rshift(r0A00, r0A66), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0A64->else_instructions;

                                 ir_variable *const r0A67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0A69 = equal(r0A56, body.constant(int(64)));
                                 ir_if *f0A68 = new(mem_ctx) ir_if(operand(r0A69).val);
                                 exec_list *const f0A68_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0A68->then_instructions;

                                    body.emit(assign(r0A67, r0A00, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0A68->else_instructions;

                                    ir_expression *const r0A6A = nequal(r0A00, body.constant(0u));
                                    ir_expression *const r0A6B = expr(ir_unop_b2i, r0A6A);
                                    body.emit(assign(r0A67, expr(ir_unop_i2u, r0A6B), 0x01));


                                 body.instructions = f0A68_parent_instructions;
                                 body.emit(f0A68);

                                 /* END IF */

                                 body.emit(assign(r0A57, r0A67, 0x01));

                                 body.emit(assign(r0A58, body.constant(0u), 0x01));


                              body.instructions = f0A64_parent_instructions;
                              body.emit(f0A64);

                              /* END IF */


                           body.instructions = f0A62_parent_instructions;
                           body.emit(f0A62);

                           /* END IF */

                           body.emit(assign(r0A59, body.constant(0u), 0x01));


                        body.instructions = f0A5E_parent_instructions;
                        body.emit(f0A5E);

                        /* END IF */

                        ir_expression *const r0A6C = nequal(r0A55, body.constant(0u));
                        ir_expression *const r0A6D = expr(ir_unop_b2i, r0A6C);
                        ir_expression *const r0A6E = expr(ir_unop_i2u, r0A6D);
                        body.emit(assign(r0A57, bit_or(r0A57, r0A6E), 0x01));


                     body.instructions = f0A5C_parent_instructions;
                     body.emit(f0A5C);

                     /* END IF */

                     body.emit(assign(r0A3F, r0A59, 0x01));

                     body.emit(assign(r0A40, r0A58, 0x01));

                     body.emit(assign(r0A41, r0A57, 0x01));

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));

                     body.emit(assign(r0A44, less(r0A57, body.constant(0u)), 0x01));


                  body.instructions = f0A53_parent_instructions;
                  body.emit(f0A53);

                  /* END IF */


               body.instructions = f0A50_parent_instructions;
               body.emit(f0A50);

               /* END IF */


            body.instructions = f0A46_parent_instructions;
            body.emit(f0A46);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0A6F = new(mem_ctx) ir_if(operand(r0A42).val);
            exec_list *const f0A6F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A6F->then_instructions;

               /* IF CONDITION */
               ir_if *f0A70 = new(mem_ctx) ir_if(operand(r0A44).val);
               exec_list *const f0A70_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A70->then_instructions;

                  ir_variable *const r0A71 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0A71, add(r0A40, body.constant(1u)), 0x01));

                  ir_expression *const r0A72 = less(r0A71, r0A40);
                  ir_expression *const r0A73 = expr(ir_unop_b2i, r0A72);
                  ir_expression *const r0A74 = expr(ir_unop_i2u, r0A73);
                  body.emit(assign(r0A3F, add(r0A3F, r0A74), 0x01));

                  ir_expression *const r0A75 = equal(r0A41, body.constant(0u));
                  ir_expression *const r0A76 = expr(ir_unop_b2i, r0A75);
                  ir_expression *const r0A77 = expr(ir_unop_i2u, r0A76);
                  ir_expression *const r0A78 = add(r0A41, r0A77);
                  ir_expression *const r0A79 = bit_and(r0A78, body.constant(1u));
                  ir_expression *const r0A7A = expr(ir_unop_bit_not, r0A79);
                  body.emit(assign(r0A40, bit_and(r0A71, r0A7A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A70->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A7C = bit_or(r0A3F, r0A40);
                  ir_expression *const r0A7D = equal(r0A7C, body.constant(0u));
                  ir_if *f0A7B = new(mem_ctx) ir_if(operand(r0A7D).val);
                  exec_list *const f0A7B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A7B->then_instructions;

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));


                  body.instructions = f0A7B_parent_instructions;
                  body.emit(f0A7B);

                  /* END IF */


               body.instructions = f0A70_parent_instructions;
               body.emit(f0A70);

               /* END IF */

               ir_variable *const r0A7E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0A7E);
               ir_expression *const r0A7F = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0A80 = expr(ir_unop_i2u, r0A3E);
               ir_expression *const r0A81 = lshift(r0A80, body.constant(int(20)));
               ir_expression *const r0A82 = add(r0A7F, r0A81);
               body.emit(assign(r0A7E, add(r0A82, r0A3F), 0x02));

               body.emit(assign(r0A7E, r0A40, 0x01));

               body.emit(assign(r0A43, r0A7E, 0x03));

               body.emit(assign(r0A42, body.constant(false), 0x01));


            body.instructions = f0A6F_parent_instructions;
            body.emit(f0A6F);

            /* END IF */

            body.emit(assign(r099A, r0A43, 0x03));


         body.instructions = f09B5_parent_instructions;
         body.emit(f09B5);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f09B3->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0A84 = less(r099B, body.constant(int(0)));
         ir_if *f0A83 = new(mem_ctx) ir_if(operand(r0A84).val);
         exec_list *const f0A83_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0A83->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0A86 = equal(r09A6, body.constant(int(2047)));
            ir_if *f0A85 = new(mem_ctx) ir_if(operand(r0A86).val);
            exec_list *const f0A85_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A85->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0A88 = bit_or(r099E, r099F);
               ir_expression *const r0A89 = nequal(r0A88, body.constant(0u));
               ir_if *f0A87 = new(mem_ctx) ir_if(operand(r0A89).val);
               exec_list *const f0A87_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A87->then_instructions;

                  ir_variable *const r0A8A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0A8A, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0A8B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0A8B, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0A8C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0A8D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0A8E = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0A8F = bit_and(r0A8E, body.constant(4095u));
                  ir_expression *const r0A90 = equal(r0A8F, body.constant(4094u));
                  ir_expression *const r0A91 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0A92 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0A93 = nequal(r0A92, body.constant(0u));
                  ir_expression *const r0A94 = logic_or(r0A91, r0A93);
                  body.emit(assign(r0A8D, logic_and(r0A90, r0A94), 0x01));

                  ir_variable *const r0A95 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0A96 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0A97 = lequal(body.constant(4292870144u), r0A96);
                  ir_expression *const r0A98 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0A99 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0A9A = nequal(r0A99, body.constant(0u));
                  ir_expression *const r0A9B = logic_or(r0A98, r0A9A);
                  body.emit(assign(r0A95, logic_and(r0A97, r0A9B), 0x01));

                  body.emit(assign(r0A8A, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0A8B, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0A9D = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0A9E = lequal(body.constant(4292870144u), r0A9D);
                  ir_expression *const r0A9F = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0AA0 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0AA1 = nequal(r0AA0, body.constant(0u));
                  ir_expression *const r0AA2 = logic_or(r0A9F, r0AA1);
                  ir_expression *const r0AA3 = logic_and(r0A9E, r0AA2);
                  ir_if *f0A9C = new(mem_ctx) ir_if(operand(r0AA3).val);
                  exec_list *const f0A9C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A9C->then_instructions;

                     ir_variable *const r0AA4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0AA6 = logic_and(r0A8D, r0A95);
                     ir_if *f0AA5 = new(mem_ctx) ir_if(operand(r0AA6).val);
                     exec_list *const f0AA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0AA5->then_instructions;

                        body.emit(assign(r0AA4, r0A8B, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0AA5->else_instructions;

                        body.emit(assign(r0AA4, r0A8A, 0x03));


                     body.instructions = f0AA5_parent_instructions;
                     body.emit(f0AA5);

                     /* END IF */

                     body.emit(assign(r0A8C, r0AA4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A9C->else_instructions;

                     body.emit(assign(r0A8C, r0A8B, 0x03));


                  body.instructions = f0A9C_parent_instructions;
                  body.emit(f0A9C);

                  /* END IF */

                  body.emit(assign(r099A, r0A8C, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A87->else_instructions;

                  ir_variable *const r0AA7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0AA7);
                  ir_expression *const r0AA8 = bit_xor(r07EC, body.constant(1u));
                  ir_expression *const r0AA9 = lshift(r0AA8, body.constant(int(31)));
                  body.emit(assign(r0AA7, add(r0AA9, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0AA7, body.constant(0u), 0x01));

                  body.emit(assign(r099A, r0AA7, 0x03));


               body.instructions = f0A87_parent_instructions;
               body.emit(f0A87);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A85->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0AAB = equal(r09A3, body.constant(int(0)));
               ir_if *f0AAA = new(mem_ctx) ir_if(operand(r0AAB).val);
               exec_list *const f0AAA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AAA->then_instructions;

                  body.emit(assign(r099B, add(r099B, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AAA->else_instructions;

                  body.emit(assign(r09A0, bit_or(r09A0, body.constant(1073741824u)), 0x01));


               body.instructions = f0AAA_parent_instructions;
               body.emit(f0AAA);

               /* END IF */

               ir_variable *const r0AAC = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0AAC, neg(r099B), 0x01));

               ir_variable *const r0AAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0AAD);
               ir_variable *const r0AAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0AAE);
               ir_variable *const r0AAF = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0AB0 = neg(r0AAC);
               body.emit(assign(r0AAF, bit_and(r0AB0, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AB2 = equal(r0AAC, body.constant(int(0)));
               ir_if *f0AB1 = new(mem_ctx) ir_if(operand(r0AB2).val);
               exec_list *const f0AB1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AB1->then_instructions;

                  body.emit(assign(r0AAD, r09A9, 0x01));

                  body.emit(assign(r0AAE, r09A0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AB1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0AB4 = less(r0AAC, body.constant(int(32)));
                  ir_if *f0AB3 = new(mem_ctx) ir_if(operand(r0AB4).val);
                  exec_list *const f0AB3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AB3->then_instructions;

                     ir_expression *const r0AB5 = lshift(r09A0, r0AAF);
                     ir_expression *const r0AB6 = rshift(r09A9, r0AAC);
                     ir_expression *const r0AB7 = bit_or(r0AB5, r0AB6);
                     ir_expression *const r0AB8 = lshift(r09A9, r0AAF);
                     ir_expression *const r0AB9 = nequal(r0AB8, body.constant(0u));
                     ir_expression *const r0ABA = expr(ir_unop_b2i, r0AB9);
                     ir_expression *const r0ABB = expr(ir_unop_i2u, r0ABA);
                     body.emit(assign(r0AAD, bit_or(r0AB7, r0ABB), 0x01));

                     body.emit(assign(r0AAE, rshift(r09A0, r0AAC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AB3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0ABD = equal(r0AAC, body.constant(int(32)));
                     ir_if *f0ABC = new(mem_ctx) ir_if(operand(r0ABD).val);
                     exec_list *const f0ABC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0ABC->then_instructions;

                        ir_expression *const r0ABE = nequal(r09A9, body.constant(0u));
                        ir_expression *const r0ABF = expr(ir_unop_b2i, r0ABE);
                        ir_expression *const r0AC0 = expr(ir_unop_i2u, r0ABF);
                        body.emit(assign(r0AAD, bit_or(r09A0, r0AC0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0ABC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0AC2 = less(r0AAC, body.constant(int(64)));
                        ir_if *f0AC1 = new(mem_ctx) ir_if(operand(r0AC2).val);
                        exec_list *const f0AC1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0AC1->then_instructions;

                           ir_expression *const r0AC3 = bit_and(r0AAC, body.constant(int(31)));
                           ir_expression *const r0AC4 = rshift(r09A0, r0AC3);
                           ir_expression *const r0AC5 = lshift(r09A0, r0AAF);
                           ir_expression *const r0AC6 = bit_or(r0AC5, r09A9);
                           ir_expression *const r0AC7 = nequal(r0AC6, body.constant(0u));
                           ir_expression *const r0AC8 = expr(ir_unop_b2i, r0AC7);
                           ir_expression *const r0AC9 = expr(ir_unop_i2u, r0AC8);
                           body.emit(assign(r0AAD, bit_or(r0AC4, r0AC9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0AC1->else_instructions;

                           ir_expression *const r0ACA = bit_or(r09A0, r09A9);
                           ir_expression *const r0ACB = nequal(r0ACA, body.constant(0u));
                           ir_expression *const r0ACC = expr(ir_unop_b2i, r0ACB);
                           body.emit(assign(r0AAD, expr(ir_unop_i2u, r0ACC), 0x01));


                        body.instructions = f0AC1_parent_instructions;
                        body.emit(f0AC1);

                        /* END IF */


                     body.instructions = f0ABC_parent_instructions;
                     body.emit(f0ABC);

                     /* END IF */

                     body.emit(assign(r0AAE, body.constant(0u), 0x01));


                  body.instructions = f0AB3_parent_instructions;
                  body.emit(f0AB3);

                  /* END IF */


               body.instructions = f0AB1_parent_instructions;
               body.emit(f0AB1);

               /* END IF */

               body.emit(assign(r09A0, r0AAE, 0x01));

               body.emit(assign(r09A1, r0AAD, 0x01));

               body.emit(assign(r099E, bit_or(r099E, body.constant(1073741824u)), 0x01));

               ir_variable *const r0ACD = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0ACE = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0ACE, sub(r099F, r0AAD), 0x01));

               ir_expression *const r0ACF = sub(r099E, r0AAE);
               ir_expression *const r0AD0 = less(r099F, r0AAD);
               ir_expression *const r0AD1 = expr(ir_unop_b2i, r0AD0);
               ir_expression *const r0AD2 = expr(ir_unop_i2u, r0AD1);
               body.emit(assign(r0ACD, sub(r0ACF, r0AD2), 0x01));

               body.emit(assign(r0999, bit_xor(r07EC, body.constant(1u)), 0x01));

               body.emit(assign(r09A2, add(r09A6, body.constant(int(-1))), 0x01));

               ir_variable *const r0AD3 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0AD3, add(r09A2, body.constant(int(-10))), 0x01));

               ir_variable *const r0AD4 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0AD4, r0ACD, 0x01));

               ir_variable *const r0AD5 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0AD5, r0ACE, 0x01));

               ir_variable *const r0AD6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0AD6);
               ir_variable *const r0AD7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0AD7);
               /* IF CONDITION */
               ir_expression *const r0AD9 = equal(r0ACD, body.constant(0u));
               ir_if *f0AD8 = new(mem_ctx) ir_if(operand(r0AD9).val);
               exec_list *const f0AD8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AD8->then_instructions;

                  body.emit(assign(r0AD4, r0ACE, 0x01));

                  body.emit(assign(r0AD5, body.constant(0u), 0x01));

                  body.emit(assign(r0AD3, add(r0AD3, body.constant(int(-32))), 0x01));


               body.instructions = f0AD8_parent_instructions;
               body.emit(f0AD8);

               /* END IF */

               ir_variable *const r0ADA = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0ADA, r0AD4, 0x01));

               ir_variable *const r0ADB = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0ADC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0ADC);
               /* IF CONDITION */
               ir_expression *const r0ADE = equal(r0AD4, body.constant(0u));
               ir_if *f0ADD = new(mem_ctx) ir_if(operand(r0ADE).val);
               exec_list *const f0ADD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ADD->then_instructions;

                  body.emit(assign(r0ADB, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ADD->else_instructions;

                  body.emit(assign(r0ADC, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0AE0 = bit_and(r0AD4, body.constant(4294901760u));
                  ir_expression *const r0AE1 = equal(r0AE0, body.constant(0u));
                  ir_if *f0ADF = new(mem_ctx) ir_if(operand(r0AE1).val);
                  exec_list *const f0ADF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0ADF->then_instructions;

                     body.emit(assign(r0ADC, body.constant(int(16)), 0x01));

                     body.emit(assign(r0ADA, lshift(r0AD4, body.constant(int(16))), 0x01));


                  body.instructions = f0ADF_parent_instructions;
                  body.emit(f0ADF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE3 = bit_and(r0ADA, body.constant(4278190080u));
                  ir_expression *const r0AE4 = equal(r0AE3, body.constant(0u));
                  ir_if *f0AE2 = new(mem_ctx) ir_if(operand(r0AE4).val);
                  exec_list *const f0AE2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE2->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(8))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(8))), 0x01));


                  body.instructions = f0AE2_parent_instructions;
                  body.emit(f0AE2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE6 = bit_and(r0ADA, body.constant(4026531840u));
                  ir_expression *const r0AE7 = equal(r0AE6, body.constant(0u));
                  ir_if *f0AE5 = new(mem_ctx) ir_if(operand(r0AE7).val);
                  exec_list *const f0AE5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE5->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(4))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(4))), 0x01));


                  body.instructions = f0AE5_parent_instructions;
                  body.emit(f0AE5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE9 = bit_and(r0ADA, body.constant(3221225472u));
                  ir_expression *const r0AEA = equal(r0AE9, body.constant(0u));
                  ir_if *f0AE8 = new(mem_ctx) ir_if(operand(r0AEA).val);
                  exec_list *const f0AE8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE8->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(2))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(2))), 0x01));


                  body.instructions = f0AE8_parent_instructions;
                  body.emit(f0AE8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AEC = bit_and(r0ADA, body.constant(2147483648u));
                  ir_expression *const r0AED = equal(r0AEC, body.constant(0u));
                  ir_if *f0AEB = new(mem_ctx) ir_if(operand(r0AED).val);
                  exec_list *const f0AEB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AEB->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(1))), 0x01));


                  body.instructions = f0AEB_parent_instructions;
                  body.emit(f0AEB);

                  /* END IF */

                  body.emit(assign(r0ADB, r0ADC, 0x01));


               body.instructions = f0ADD_parent_instructions;
               body.emit(f0ADD);

               /* END IF */

               body.emit(assign(r0AD7, add(r0ADB, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AEF = lequal(body.constant(int(0)), r0AD7);
               ir_if *f0AEE = new(mem_ctx) ir_if(operand(r0AEF).val);
               exec_list *const f0AEE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AEE->then_instructions;

                  body.emit(assign(r0AD6, body.constant(0u), 0x01));

                  ir_variable *const r0AF0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0AF0, lshift(r0AD5, r0AD7), 0x01));

                  ir_variable *const r0AF1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0AF3 = equal(r0AD7, body.constant(int(0)));
                  ir_if *f0AF2 = new(mem_ctx) ir_if(operand(r0AF3).val);
                  exec_list *const f0AF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AF2->then_instructions;

                     body.emit(assign(r0AF1, r0AD4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AF2->else_instructions;

                     ir_expression *const r0AF4 = lshift(r0AD4, r0AD7);
                     ir_expression *const r0AF5 = neg(r0AD7);
                     ir_expression *const r0AF6 = bit_and(r0AF5, body.constant(int(31)));
                     ir_expression *const r0AF7 = rshift(r0AD5, r0AF6);
                     body.emit(assign(r0AF1, bit_or(r0AF4, r0AF7), 0x01));


                  body.instructions = f0AF2_parent_instructions;
                  body.emit(f0AF2);

                  /* END IF */

                  body.emit(assign(r0AD4, r0AF1, 0x01));

                  body.emit(assign(r0AD5, r0AF0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AEE->else_instructions;

                  ir_variable *const r0AF8 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0AF8, body.constant(0u), 0x01));

                  ir_variable *const r0AF9 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0AF9, neg(r0AD7), 0x01));

                  ir_variable *const r0AFA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0AFA);
                  ir_variable *const r0AFB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0AFB);
                  ir_variable *const r0AFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0AFC);
                  ir_variable *const r0AFD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0AFE = neg(r0AF9);
                  body.emit(assign(r0AFD, bit_and(r0AFE, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0B00 = equal(r0AF9, body.constant(int(0)));
                  ir_if *f0AFF = new(mem_ctx) ir_if(operand(r0B00).val);
                  exec_list *const f0AFF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AFF->then_instructions;

                     body.emit(assign(r0AFA, r0AF8, 0x01));

                     body.emit(assign(r0AFB, r0AD5, 0x01));

                     body.emit(assign(r0AFC, r0AD4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AFF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B02 = less(r0AF9, body.constant(int(32)));
                     ir_if *f0B01 = new(mem_ctx) ir_if(operand(r0B02).val);
                     exec_list *const f0B01_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B01->then_instructions;

                        body.emit(assign(r0AFA, lshift(r0AD5, r0AFD), 0x01));

                        ir_expression *const r0B03 = lshift(r0AD4, r0AFD);
                        ir_expression *const r0B04 = rshift(r0AD5, r0AF9);
                        body.emit(assign(r0AFB, bit_or(r0B03, r0B04), 0x01));

                        body.emit(assign(r0AFC, rshift(r0AD4, r0AF9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B01->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0B06 = equal(r0AF9, body.constant(int(32)));
                        ir_if *f0B05 = new(mem_ctx) ir_if(operand(r0B06).val);
                        exec_list *const f0B05_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B05->then_instructions;

                           body.emit(assign(r0AFA, r0AD5, 0x01));

                           body.emit(assign(r0AFB, r0AD4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B05->else_instructions;

                           body.emit(assign(r0AF8, bit_or(body.constant(0u), r0AD5), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0B08 = less(r0AF9, body.constant(int(64)));
                           ir_if *f0B07 = new(mem_ctx) ir_if(operand(r0B08).val);
                           exec_list *const f0B07_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B07->then_instructions;

                              body.emit(assign(r0AFA, lshift(r0AD4, r0AFD), 0x01));

                              ir_expression *const r0B09 = bit_and(r0AF9, body.constant(int(31)));
                              body.emit(assign(r0AFB, rshift(r0AD4, r0B09), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B07->else_instructions;

                              ir_variable *const r0B0A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0B0C = equal(r0AF9, body.constant(int(64)));
                              ir_if *f0B0B = new(mem_ctx) ir_if(operand(r0B0C).val);
                              exec_list *const f0B0B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B0B->then_instructions;

                                 body.emit(assign(r0B0A, r0AD4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B0B->else_instructions;

                                 ir_expression *const r0B0D = nequal(r0AD4, body.constant(0u));
                                 ir_expression *const r0B0E = expr(ir_unop_b2i, r0B0D);
                                 body.emit(assign(r0B0A, expr(ir_unop_i2u, r0B0E), 0x01));


                              body.instructions = f0B0B_parent_instructions;
                              body.emit(f0B0B);

                              /* END IF */

                              body.emit(assign(r0AFA, r0B0A, 0x01));

                              body.emit(assign(r0AFB, body.constant(0u), 0x01));


                           body.instructions = f0B07_parent_instructions;
                           body.emit(f0B07);

                           /* END IF */


                        body.instructions = f0B05_parent_instructions;
                        body.emit(f0B05);

                        /* END IF */

                        body.emit(assign(r0AFC, body.constant(0u), 0x01));


                     body.instructions = f0B01_parent_instructions;
                     body.emit(f0B01);

                     /* END IF */

                     ir_expression *const r0B0F = nequal(r0AF8, body.constant(0u));
                     ir_expression *const r0B10 = expr(ir_unop_b2i, r0B0F);
                     ir_expression *const r0B11 = expr(ir_unop_i2u, r0B10);
                     body.emit(assign(r0AFA, bit_or(r0AFA, r0B11), 0x01));


                  body.instructions = f0AFF_parent_instructions;
                  body.emit(f0AFF);

                  /* END IF */

                  body.emit(assign(r0AD4, r0AFC, 0x01));

                  body.emit(assign(r0AD5, r0AFB, 0x01));

                  body.emit(assign(r0AD6, r0AFA, 0x01));


               body.instructions = f0AEE_parent_instructions;
               body.emit(f0AEE);

               /* END IF */

               body.emit(assign(r0AD3, sub(r0AD3, r0AD7), 0x01));

               ir_variable *const r0B12 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0B12, r0AD3, 0x01));

               ir_variable *const r0B13 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0B13, r0AD4, 0x01));

               ir_variable *const r0B14 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0B14, r0AD5, 0x01));

               ir_variable *const r0B15 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0B15, r0AD6, 0x01));

               ir_variable *const r0B16 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0B16, body.constant(true), 0x01));

               ir_variable *const r0B17 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0B18 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0B18);
               ir_expression *const r0B19 = expr(ir_unop_u2i, r0AD6);
               body.emit(assign(r0B18, less(r0B19, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0B1B = lequal(body.constant(int(2045)), r0AD3);
               ir_if *f0B1A = new(mem_ctx) ir_if(operand(r0B1B).val);
               exec_list *const f0B1A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B1A->then_instructions;

                  ir_variable *const r0B1C = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0B1E = less(body.constant(int(2045)), r0AD3);
                  ir_if *f0B1D = new(mem_ctx) ir_if(operand(r0B1E).val);
                  exec_list *const f0B1D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B1D->then_instructions;

                     body.emit(assign(r0B1C, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B1D->else_instructions;

                     ir_variable *const r0B1F = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B21 = equal(r0AD3, body.constant(int(2045)));
                     ir_if *f0B20 = new(mem_ctx) ir_if(operand(r0B21).val);
                     exec_list *const f0B20_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B20->then_instructions;

                        ir_expression *const r0B22 = equal(body.constant(2097151u), r0AD4);
                        ir_expression *const r0B23 = equal(body.constant(4294967295u), r0AD5);
                        body.emit(assign(r0B1F, logic_and(r0B22, r0B23), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B20->else_instructions;

                        body.emit(assign(r0B1F, body.constant(false), 0x01));


                     body.instructions = f0B20_parent_instructions;
                     body.emit(f0B20);

                     /* END IF */

                     body.emit(assign(r0B1C, logic_and(r0B1F, r0B18), 0x01));


                  body.instructions = f0B1D_parent_instructions;
                  body.emit(f0B1D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0B24 = new(mem_ctx) ir_if(operand(r0B1C).val);
                  exec_list *const f0B24_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B24->then_instructions;

                     ir_variable *const r0B25 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0B25);
                     ir_expression *const r0B26 = lshift(r0999, body.constant(int(31)));
                     body.emit(assign(r0B25, add(r0B26, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0B25, body.constant(0u), 0x01));

                     body.emit(assign(r0B17, r0B25, 0x03));

                     body.emit(assign(r0B16, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B24->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B28 = less(r0AD3, body.constant(int(0)));
                     ir_if *f0B27 = new(mem_ctx) ir_if(operand(r0B28).val);
                     exec_list *const f0B27_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B27->then_instructions;

                        ir_variable *const r0B29 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0B29, r0AD6, 0x01));

                        ir_variable *const r0B2A = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0B2A, neg(r0AD3), 0x01));

                        ir_variable *const r0B2B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0B2B);
                        ir_variable *const r0B2C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0B2C);
                        ir_variable *const r0B2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0B2D);
                        ir_variable *const r0B2E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0B2F = neg(r0B2A);
                        body.emit(assign(r0B2E, bit_and(r0B2F, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0B31 = equal(r0B2A, body.constant(int(0)));
                        ir_if *f0B30 = new(mem_ctx) ir_if(operand(r0B31).val);
                        exec_list *const f0B30_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B30->then_instructions;

                           body.emit(assign(r0B2B, r0AD6, 0x01));

                           body.emit(assign(r0B2C, r0AD5, 0x01));

                           body.emit(assign(r0B2D, r0AD4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B30->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0B33 = less(r0B2A, body.constant(int(32)));
                           ir_if *f0B32 = new(mem_ctx) ir_if(operand(r0B33).val);
                           exec_list *const f0B32_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B32->then_instructions;

                              body.emit(assign(r0B2B, lshift(r0AD5, r0B2E), 0x01));

                              ir_expression *const r0B34 = lshift(r0AD4, r0B2E);
                              ir_expression *const r0B35 = rshift(r0AD5, r0B2A);
                              body.emit(assign(r0B2C, bit_or(r0B34, r0B35), 0x01));

                              body.emit(assign(r0B2D, rshift(r0AD4, r0B2A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B32->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0B37 = equal(r0B2A, body.constant(int(32)));
                              ir_if *f0B36 = new(mem_ctx) ir_if(operand(r0B37).val);
                              exec_list *const f0B36_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B36->then_instructions;

                                 body.emit(assign(r0B2B, r0AD5, 0x01));

                                 body.emit(assign(r0B2C, r0AD4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B36->else_instructions;

                                 body.emit(assign(r0B29, bit_or(r0AD6, r0AD5), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0B39 = less(r0B2A, body.constant(int(64)));
                                 ir_if *f0B38 = new(mem_ctx) ir_if(operand(r0B39).val);
                                 exec_list *const f0B38_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0B38->then_instructions;

                                    body.emit(assign(r0B2B, lshift(r0AD4, r0B2E), 0x01));

                                    ir_expression *const r0B3A = bit_and(r0B2A, body.constant(int(31)));
                                    body.emit(assign(r0B2C, rshift(r0AD4, r0B3A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0B38->else_instructions;

                                    ir_variable *const r0B3B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0B3D = equal(r0B2A, body.constant(int(64)));
                                    ir_if *f0B3C = new(mem_ctx) ir_if(operand(r0B3D).val);
                                    exec_list *const f0B3C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0B3C->then_instructions;

                                       body.emit(assign(r0B3B, r0AD4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0B3C->else_instructions;

                                       ir_expression *const r0B3E = nequal(r0AD4, body.constant(0u));
                                       ir_expression *const r0B3F = expr(ir_unop_b2i, r0B3E);
                                       body.emit(assign(r0B3B, expr(ir_unop_i2u, r0B3F), 0x01));


                                    body.instructions = f0B3C_parent_instructions;
                                    body.emit(f0B3C);

                                    /* END IF */

                                    body.emit(assign(r0B2B, r0B3B, 0x01));

                                    body.emit(assign(r0B2C, body.constant(0u), 0x01));


                                 body.instructions = f0B38_parent_instructions;
                                 body.emit(f0B38);

                                 /* END IF */


                              body.instructions = f0B36_parent_instructions;
                              body.emit(f0B36);

                              /* END IF */

                              body.emit(assign(r0B2D, body.constant(0u), 0x01));


                           body.instructions = f0B32_parent_instructions;
                           body.emit(f0B32);

                           /* END IF */

                           ir_expression *const r0B40 = nequal(r0B29, body.constant(0u));
                           ir_expression *const r0B41 = expr(ir_unop_b2i, r0B40);
                           ir_expression *const r0B42 = expr(ir_unop_i2u, r0B41);
                           body.emit(assign(r0B2B, bit_or(r0B2B, r0B42), 0x01));


                        body.instructions = f0B30_parent_instructions;
                        body.emit(f0B30);

                        /* END IF */

                        body.emit(assign(r0B13, r0B2D, 0x01));

                        body.emit(assign(r0B14, r0B2C, 0x01));

                        body.emit(assign(r0B15, r0B2B, 0x01));

                        body.emit(assign(r0B12, body.constant(int(0)), 0x01));

                        body.emit(assign(r0B18, less(r0B2B, body.constant(0u)), 0x01));


                     body.instructions = f0B27_parent_instructions;
                     body.emit(f0B27);

                     /* END IF */


                  body.instructions = f0B24_parent_instructions;
                  body.emit(f0B24);

                  /* END IF */


               body.instructions = f0B1A_parent_instructions;
               body.emit(f0B1A);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0B43 = new(mem_ctx) ir_if(operand(r0B16).val);
               exec_list *const f0B43_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B43->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0B44 = new(mem_ctx) ir_if(operand(r0B18).val);
                  exec_list *const f0B44_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B44->then_instructions;

                     ir_variable *const r0B45 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0B45, add(r0B14, body.constant(1u)), 0x01));

                     ir_expression *const r0B46 = less(r0B45, r0B14);
                     ir_expression *const r0B47 = expr(ir_unop_b2i, r0B46);
                     ir_expression *const r0B48 = expr(ir_unop_i2u, r0B47);
                     body.emit(assign(r0B13, add(r0B13, r0B48), 0x01));

                     ir_expression *const r0B49 = equal(r0B15, body.constant(0u));
                     ir_expression *const r0B4A = expr(ir_unop_b2i, r0B49);
                     ir_expression *const r0B4B = expr(ir_unop_i2u, r0B4A);
                     ir_expression *const r0B4C = add(r0B15, r0B4B);
                     ir_expression *const r0B4D = bit_and(r0B4C, body.constant(1u));
                     ir_expression *const r0B4E = expr(ir_unop_bit_not, r0B4D);
                     body.emit(assign(r0B14, bit_and(r0B45, r0B4E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B44->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B50 = bit_or(r0B13, r0B14);
                     ir_expression *const r0B51 = equal(r0B50, body.constant(0u));
                     ir_if *f0B4F = new(mem_ctx) ir_if(operand(r0B51).val);
                     exec_list *const f0B4F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B4F->then_instructions;

                        body.emit(assign(r0B12, body.constant(int(0)), 0x01));


                     body.instructions = f0B4F_parent_instructions;
                     body.emit(f0B4F);

                     /* END IF */


                  body.instructions = f0B44_parent_instructions;
                  body.emit(f0B44);

                  /* END IF */

                  ir_variable *const r0B52 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0B52);
                  ir_expression *const r0B53 = lshift(r0999, body.constant(int(31)));
                  ir_expression *const r0B54 = expr(ir_unop_i2u, r0B12);
                  ir_expression *const r0B55 = lshift(r0B54, body.constant(int(20)));
                  ir_expression *const r0B56 = add(r0B53, r0B55);
                  body.emit(assign(r0B52, add(r0B56, r0B13), 0x02));

                  body.emit(assign(r0B52, r0B14, 0x01));

                  body.emit(assign(r0B17, r0B52, 0x03));

                  body.emit(assign(r0B16, body.constant(false), 0x01));


               body.instructions = f0B43_parent_instructions;
               body.emit(f0B43);

               /* END IF */

               body.emit(assign(r099A, r0B17, 0x03));


            body.instructions = f0A85_parent_instructions;
            body.emit(f0A85);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0A83->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0B58 = equal(r09A3, body.constant(int(2047)));
            ir_if *f0B57 = new(mem_ctx) ir_if(operand(r0B58).val);
            exec_list *const f0B57_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0B57->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0B5A = bit_or(r09A0, r09A1);
               ir_expression *const r0B5B = bit_or(r099E, r099F);
               ir_expression *const r0B5C = bit_or(r0B5A, r0B5B);
               ir_expression *const r0B5D = nequal(r0B5C, body.constant(0u));
               ir_if *f0B59 = new(mem_ctx) ir_if(operand(r0B5D).val);
               exec_list *const f0B59_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B59->then_instructions;

                  ir_variable *const r0B5E = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0B5E, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0B5F = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0B5F, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0B60 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0B61 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0B62 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0B63 = bit_and(r0B62, body.constant(4095u));
                  ir_expression *const r0B64 = equal(r0B63, body.constant(4094u));
                  ir_expression *const r0B65 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B66 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0B67 = nequal(r0B66, body.constant(0u));
                  ir_expression *const r0B68 = logic_or(r0B65, r0B67);
                  body.emit(assign(r0B61, logic_and(r0B64, r0B68), 0x01));

                  ir_variable *const r0B69 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0B6A = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0B6B = lequal(body.constant(4292870144u), r0B6A);
                  ir_expression *const r0B6C = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0B6D = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0B6E = nequal(r0B6D, body.constant(0u));
                  ir_expression *const r0B6F = logic_or(r0B6C, r0B6E);
                  body.emit(assign(r0B69, logic_and(r0B6B, r0B6F), 0x01));

                  body.emit(assign(r0B5E, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0B5F, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0B71 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0B72 = lequal(body.constant(4292870144u), r0B71);
                  ir_expression *const r0B73 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B74 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0B75 = nequal(r0B74, body.constant(0u));
                  ir_expression *const r0B76 = logic_or(r0B73, r0B75);
                  ir_expression *const r0B77 = logic_and(r0B72, r0B76);
                  ir_if *f0B70 = new(mem_ctx) ir_if(operand(r0B77).val);
                  exec_list *const f0B70_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B70->then_instructions;

                     ir_variable *const r0B78 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B7A = logic_and(r0B61, r0B69);
                     ir_if *f0B79 = new(mem_ctx) ir_if(operand(r0B7A).val);
                     exec_list *const f0B79_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B79->then_instructions;

                        body.emit(assign(r0B78, r0B5F, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B79->else_instructions;

                        body.emit(assign(r0B78, r0B5E, 0x03));


                     body.instructions = f0B79_parent_instructions;
                     body.emit(f0B79);

                     /* END IF */

                     body.emit(assign(r0B60, r0B78, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B70->else_instructions;

                     body.emit(assign(r0B60, r0B5F, 0x03));


                  body.instructions = f0B70_parent_instructions;
                  body.emit(f0B70);

                  /* END IF */

                  body.emit(assign(r099A, r0B60, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B59->else_instructions;

                  ir_constant_data r0B7B_data;
                  memset(&r0B7B_data, 0, sizeof(ir_constant_data));
                  r0B7B_data.u[0] = 4294967295;
                  r0B7B_data.u[1] = 4294967295;
                  ir_constant *const r0B7B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0B7B_data);
                  body.emit(assign(r099A, r0B7B, 0x03));


               body.instructions = f0B59_parent_instructions;
               body.emit(f0B59);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0B57->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0B7D = equal(r09A3, body.constant(int(0)));
               ir_if *f0B7C = new(mem_ctx) ir_if(operand(r0B7D).val);
               exec_list *const f0B7C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B7C->then_instructions;

                  body.emit(assign(r099D, body.constant(int(1)), 0x01));

                  body.emit(assign(r099C, body.constant(int(1)), 0x01));


               body.instructions = f0B7C_parent_instructions;
               body.emit(f0B7C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0B7F = less(r099E, r09A0);
               ir_if *f0B7E = new(mem_ctx) ir_if(operand(r0B7F).val);
               exec_list *const f0B7E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B7E->then_instructions;

                  ir_variable *const r0B80 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0B81 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0B81, sub(r09A1, r099F), 0x01));

                  ir_expression *const r0B82 = sub(r09A0, r099E);
                  ir_expression *const r0B83 = less(r09A1, r099F);
                  ir_expression *const r0B84 = expr(ir_unop_b2i, r0B83);
                  ir_expression *const r0B85 = expr(ir_unop_i2u, r0B84);
                  body.emit(assign(r0B80, sub(r0B82, r0B85), 0x01));

                  body.emit(assign(r09A2, add(r099D, body.constant(int(-1))), 0x01));

                  ir_variable *const r0B86 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0B86, add(r09A2, body.constant(int(-10))), 0x01));

                  ir_variable *const r0B87 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0B87, r0B80, 0x01));

                  ir_variable *const r0B88 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0B88, r0B81, 0x01));

                  ir_variable *const r0B89 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0B89);
                  ir_variable *const r0B8A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B8A);
                  /* IF CONDITION */
                  ir_expression *const r0B8C = equal(r0B80, body.constant(0u));
                  ir_if *f0B8B = new(mem_ctx) ir_if(operand(r0B8C).val);
                  exec_list *const f0B8B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B8B->then_instructions;

                     body.emit(assign(r0B87, r0B81, 0x01));

                     body.emit(assign(r0B88, body.constant(0u), 0x01));

                     body.emit(assign(r0B86, add(r0B86, body.constant(int(-32))), 0x01));


                  body.instructions = f0B8B_parent_instructions;
                  body.emit(f0B8B);

                  /* END IF */

                  ir_variable *const r0B8D = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0B8D, r0B87, 0x01));

                  ir_variable *const r0B8E = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0B8F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B8F);
                  /* IF CONDITION */
                  ir_expression *const r0B91 = equal(r0B87, body.constant(0u));
                  ir_if *f0B90 = new(mem_ctx) ir_if(operand(r0B91).val);
                  exec_list *const f0B90_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B90->then_instructions;

                     body.emit(assign(r0B8E, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B90->else_instructions;

                     body.emit(assign(r0B8F, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0B93 = bit_and(r0B87, body.constant(4294901760u));
                     ir_expression *const r0B94 = equal(r0B93, body.constant(0u));
                     ir_if *f0B92 = new(mem_ctx) ir_if(operand(r0B94).val);
                     exec_list *const f0B92_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B92->then_instructions;

                        body.emit(assign(r0B8F, body.constant(int(16)), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B87, body.constant(int(16))), 0x01));


                     body.instructions = f0B92_parent_instructions;
                     body.emit(f0B92);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B96 = bit_and(r0B8D, body.constant(4278190080u));
                     ir_expression *const r0B97 = equal(r0B96, body.constant(0u));
                     ir_if *f0B95 = new(mem_ctx) ir_if(operand(r0B97).val);
                     exec_list *const f0B95_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B95->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(8))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(8))), 0x01));


                     body.instructions = f0B95_parent_instructions;
                     body.emit(f0B95);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B99 = bit_and(r0B8D, body.constant(4026531840u));
                     ir_expression *const r0B9A = equal(r0B99, body.constant(0u));
                     ir_if *f0B98 = new(mem_ctx) ir_if(operand(r0B9A).val);
                     exec_list *const f0B98_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B98->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(4))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(4))), 0x01));


                     body.instructions = f0B98_parent_instructions;
                     body.emit(f0B98);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9C = bit_and(r0B8D, body.constant(3221225472u));
                     ir_expression *const r0B9D = equal(r0B9C, body.constant(0u));
                     ir_if *f0B9B = new(mem_ctx) ir_if(operand(r0B9D).val);
                     exec_list *const f0B9B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9B->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(2))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(2))), 0x01));


                     body.instructions = f0B9B_parent_instructions;
                     body.emit(f0B9B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9F = bit_and(r0B8D, body.constant(2147483648u));
                     ir_expression *const r0BA0 = equal(r0B9F, body.constant(0u));
                     ir_if *f0B9E = new(mem_ctx) ir_if(operand(r0BA0).val);
                     exec_list *const f0B9E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9E->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(1))), 0x01));


                     body.instructions = f0B9E_parent_instructions;
                     body.emit(f0B9E);

                     /* END IF */

                     body.emit(assign(r0B8E, r0B8F, 0x01));


                  body.instructions = f0B90_parent_instructions;
                  body.emit(f0B90);

                  /* END IF */

                  body.emit(assign(r0B8A, add(r0B8E, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BA2 = lequal(body.constant(int(0)), r0B8A);
                  ir_if *f0BA1 = new(mem_ctx) ir_if(operand(r0BA2).val);
                  exec_list *const f0BA1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BA1->then_instructions;

                     body.emit(assign(r0B89, body.constant(0u), 0x01));

                     ir_variable *const r0BA3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0BA3, lshift(r0B88, r0B8A), 0x01));

                     ir_variable *const r0BA4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BA6 = equal(r0B8A, body.constant(int(0)));
                     ir_if *f0BA5 = new(mem_ctx) ir_if(operand(r0BA6).val);
                     exec_list *const f0BA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BA5->then_instructions;

                        body.emit(assign(r0BA4, r0B87, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BA5->else_instructions;

                        ir_expression *const r0BA7 = lshift(r0B87, r0B8A);
                        ir_expression *const r0BA8 = neg(r0B8A);
                        ir_expression *const r0BA9 = bit_and(r0BA8, body.constant(int(31)));
                        ir_expression *const r0BAA = rshift(r0B88, r0BA9);
                        body.emit(assign(r0BA4, bit_or(r0BA7, r0BAA), 0x01));


                     body.instructions = f0BA5_parent_instructions;
                     body.emit(f0BA5);

                     /* END IF */

                     body.emit(assign(r0B87, r0BA4, 0x01));

                     body.emit(assign(r0B88, r0BA3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0BA1->else_instructions;

                     ir_variable *const r0BAB = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0BAB, body.constant(0u), 0x01));

                     ir_variable *const r0BAC = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0BAC, neg(r0B8A), 0x01));

                     ir_variable *const r0BAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0BAD);
                     ir_variable *const r0BAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0BAE);
                     ir_variable *const r0BAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0BAF);
                     ir_variable *const r0BB0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0BB1 = neg(r0BAC);
                     body.emit(assign(r0BB0, bit_and(r0BB1, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0BB3 = equal(r0BAC, body.constant(int(0)));
                     ir_if *f0BB2 = new(mem_ctx) ir_if(operand(r0BB3).val);
                     exec_list *const f0BB2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BB2->then_instructions;

                        body.emit(assign(r0BAD, r0BAB, 0x01));

                        body.emit(assign(r0BAE, r0B88, 0x01));

                        body.emit(assign(r0BAF, r0B87, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BB2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BB5 = less(r0BAC, body.constant(int(32)));
                        ir_if *f0BB4 = new(mem_ctx) ir_if(operand(r0BB5).val);
                        exec_list *const f0BB4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BB4->then_instructions;

                           body.emit(assign(r0BAD, lshift(r0B88, r0BB0), 0x01));

                           ir_expression *const r0BB6 = lshift(r0B87, r0BB0);
                           ir_expression *const r0BB7 = rshift(r0B88, r0BAC);
                           body.emit(assign(r0BAE, bit_or(r0BB6, r0BB7), 0x01));

                           body.emit(assign(r0BAF, rshift(r0B87, r0BAC), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BB4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0BB9 = equal(r0BAC, body.constant(int(32)));
                           ir_if *f0BB8 = new(mem_ctx) ir_if(operand(r0BB9).val);
                           exec_list *const f0BB8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BB8->then_instructions;

                              body.emit(assign(r0BAD, r0B88, 0x01));

                              body.emit(assign(r0BAE, r0B87, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BB8->else_instructions;

                              body.emit(assign(r0BAB, bit_or(body.constant(0u), r0B88), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0BBB = less(r0BAC, body.constant(int(64)));
                              ir_if *f0BBA = new(mem_ctx) ir_if(operand(r0BBB).val);
                              exec_list *const f0BBA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BBA->then_instructions;

                                 body.emit(assign(r0BAD, lshift(r0B87, r0BB0), 0x01));

                                 ir_expression *const r0BBC = bit_and(r0BAC, body.constant(int(31)));
                                 body.emit(assign(r0BAE, rshift(r0B87, r0BBC), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BBA->else_instructions;

                                 ir_variable *const r0BBD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0BBF = equal(r0BAC, body.constant(int(64)));
                                 ir_if *f0BBE = new(mem_ctx) ir_if(operand(r0BBF).val);
                                 exec_list *const f0BBE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BBE->then_instructions;

                                    body.emit(assign(r0BBD, r0B87, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BBE->else_instructions;

                                    ir_expression *const r0BC0 = nequal(r0B87, body.constant(0u));
                                    ir_expression *const r0BC1 = expr(ir_unop_b2i, r0BC0);
                                    body.emit(assign(r0BBD, expr(ir_unop_i2u, r0BC1), 0x01));


                                 body.instructions = f0BBE_parent_instructions;
                                 body.emit(f0BBE);

                                 /* END IF */

                                 body.emit(assign(r0BAD, r0BBD, 0x01));

                                 body.emit(assign(r0BAE, body.constant(0u), 0x01));


                              body.instructions = f0BBA_parent_instructions;
                              body.emit(f0BBA);

                              /* END IF */


                           body.instructions = f0BB8_parent_instructions;
                           body.emit(f0BB8);

                           /* END IF */

                           body.emit(assign(r0BAF, body.constant(0u), 0x01));


                        body.instructions = f0BB4_parent_instructions;
                        body.emit(f0BB4);

                        /* END IF */

                        ir_expression *const r0BC2 = nequal(r0BAB, body.constant(0u));
                        ir_expression *const r0BC3 = expr(ir_unop_b2i, r0BC2);
                        ir_expression *const r0BC4 = expr(ir_unop_i2u, r0BC3);
                        body.emit(assign(r0BAD, bit_or(r0BAD, r0BC4), 0x01));


                     body.instructions = f0BB2_parent_instructions;
                     body.emit(f0BB2);

                     /* END IF */

                     body.emit(assign(r0B87, r0BAF, 0x01));

                     body.emit(assign(r0B88, r0BAE, 0x01));

                     body.emit(assign(r0B89, r0BAD, 0x01));


                  body.instructions = f0BA1_parent_instructions;
                  body.emit(f0BA1);

                  /* END IF */

                  body.emit(assign(r0B86, sub(r0B86, r0B8A), 0x01));

                  ir_variable *const r0BC5 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0BC5, r0B86, 0x01));

                  ir_variable *const r0BC6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0BC6, r0B87, 0x01));

                  ir_variable *const r0BC7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0BC7, r0B88, 0x01));

                  ir_variable *const r0BC8 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0BC8, r0B89, 0x01));

                  ir_variable *const r0BC9 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0BC9, body.constant(true), 0x01));

                  ir_variable *const r0BCA = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0BCB = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0BCB);
                  ir_expression *const r0BCC = expr(ir_unop_u2i, r0B89);
                  body.emit(assign(r0BCB, less(r0BCC, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BCE = lequal(body.constant(int(2045)), r0B86);
                  ir_if *f0BCD = new(mem_ctx) ir_if(operand(r0BCE).val);
                  exec_list *const f0BCD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BCD->then_instructions;

                     ir_variable *const r0BCF = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BD1 = less(body.constant(int(2045)), r0B86);
                     ir_if *f0BD0 = new(mem_ctx) ir_if(operand(r0BD1).val);
                     exec_list *const f0BD0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD0->then_instructions;

                        body.emit(assign(r0BCF, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD0->else_instructions;

                        ir_variable *const r0BD2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0BD4 = equal(r0B86, body.constant(int(2045)));
                        ir_if *f0BD3 = new(mem_ctx) ir_if(operand(r0BD4).val);
                        exec_list *const f0BD3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BD3->then_instructions;

                           ir_expression *const r0BD5 = equal(body.constant(2097151u), r0B87);
                           ir_expression *const r0BD6 = equal(body.constant(4294967295u), r0B88);
                           body.emit(assign(r0BD2, logic_and(r0BD5, r0BD6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BD3->else_instructions;

                           body.emit(assign(r0BD2, body.constant(false), 0x01));


                        body.instructions = f0BD3_parent_instructions;
                        body.emit(f0BD3);

                        /* END IF */

                        body.emit(assign(r0BCF, logic_and(r0BD2, r0BCB), 0x01));


                     body.instructions = f0BD0_parent_instructions;
                     body.emit(f0BD0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0BD7 = new(mem_ctx) ir_if(operand(r0BCF).val);
                     exec_list *const f0BD7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD7->then_instructions;

                        ir_variable *const r0BD8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0BD8);
                        ir_expression *const r0BD9 = lshift(r0999, body.constant(int(31)));
                        body.emit(assign(r0BD8, add(r0BD9, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0BD8, body.constant(0u), 0x01));

                        body.emit(assign(r0BCA, r0BD8, 0x03));

                        body.emit(assign(r0BC9, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BDB = less(r0B86, body.constant(int(0)));
                        ir_if *f0BDA = new(mem_ctx) ir_if(operand(r0BDB).val);
                        exec_list *const f0BDA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BDA->then_instructions;

                           ir_variable *const r0BDC = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0BDC, r0B89, 0x01));

                           ir_variable *const r0BDD = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0BDD, neg(r0B86), 0x01));

                           ir_variable *const r0BDE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0BDE);
                           ir_variable *const r0BDF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0BDF);
                           ir_variable *const r0BE0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0BE0);
                           ir_variable *const r0BE1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0BE2 = neg(r0BDD);
                           body.emit(assign(r0BE1, bit_and(r0BE2, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0BE4 = equal(r0BDD, body.constant(int(0)));
                           ir_if *f0BE3 = new(mem_ctx) ir_if(operand(r0BE4).val);
                           exec_list *const f0BE3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BE3->then_instructions;

                              body.emit(assign(r0BDE, r0B89, 0x01));

                              body.emit(assign(r0BDF, r0B88, 0x01));

                              body.emit(assign(r0BE0, r0B87, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BE3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0BE6 = less(r0BDD, body.constant(int(32)));
                              ir_if *f0BE5 = new(mem_ctx) ir_if(operand(r0BE6).val);
                              exec_list *const f0BE5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BE5->then_instructions;

                                 body.emit(assign(r0BDE, lshift(r0B88, r0BE1), 0x01));

                                 ir_expression *const r0BE7 = lshift(r0B87, r0BE1);
                                 ir_expression *const r0BE8 = rshift(r0B88, r0BDD);
                                 body.emit(assign(r0BDF, bit_or(r0BE7, r0BE8), 0x01));

                                 body.emit(assign(r0BE0, rshift(r0B87, r0BDD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BE5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0BEA = equal(r0BDD, body.constant(int(32)));
                                 ir_if *f0BE9 = new(mem_ctx) ir_if(operand(r0BEA).val);
                                 exec_list *const f0BE9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BE9->then_instructions;

                                    body.emit(assign(r0BDE, r0B88, 0x01));

                                    body.emit(assign(r0BDF, r0B87, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BE9->else_instructions;

                                    body.emit(assign(r0BDC, bit_or(r0B89, r0B88), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0BEC = less(r0BDD, body.constant(int(64)));
                                    ir_if *f0BEB = new(mem_ctx) ir_if(operand(r0BEC).val);
                                    exec_list *const f0BEB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0BEB->then_instructions;

                                       body.emit(assign(r0BDE, lshift(r0B87, r0BE1), 0x01));

                                       ir_expression *const r0BED = bit_and(r0BDD, body.constant(int(31)));
                                       body.emit(assign(r0BDF, rshift(r0B87, r0BED), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0BEB->else_instructions;

                                       ir_variable *const r0BEE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0BF0 = equal(r0BDD, body.constant(int(64)));
                                       ir_if *f0BEF = new(mem_ctx) ir_if(operand(r0BF0).val);
                                       exec_list *const f0BEF_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0BEF->then_instructions;

                                          body.emit(assign(r0BEE, r0B87, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0BEF->else_instructions;

                                          ir_expression *const r0BF1 = nequal(r0B87, body.constant(0u));
                                          ir_expression *const r0BF2 = expr(ir_unop_b2i, r0BF1);
                                          body.emit(assign(r0BEE, expr(ir_unop_i2u, r0BF2), 0x01));


                                       body.instructions = f0BEF_parent_instructions;
                                       body.emit(f0BEF);

                                       /* END IF */

                                       body.emit(assign(r0BDE, r0BEE, 0x01));

                                       body.emit(assign(r0BDF, body.constant(0u), 0x01));


                                    body.instructions = f0BEB_parent_instructions;
                                    body.emit(f0BEB);

                                    /* END IF */


                                 body.instructions = f0BE9_parent_instructions;
                                 body.emit(f0BE9);

                                 /* END IF */

                                 body.emit(assign(r0BE0, body.constant(0u), 0x01));


                              body.instructions = f0BE5_parent_instructions;
                              body.emit(f0BE5);

                              /* END IF */

                              ir_expression *const r0BF3 = nequal(r0BDC, body.constant(0u));
                              ir_expression *const r0BF4 = expr(ir_unop_b2i, r0BF3);
                              ir_expression *const r0BF5 = expr(ir_unop_i2u, r0BF4);
                              body.emit(assign(r0BDE, bit_or(r0BDE, r0BF5), 0x01));


                           body.instructions = f0BE3_parent_instructions;
                           body.emit(f0BE3);

                           /* END IF */

                           body.emit(assign(r0BC6, r0BE0, 0x01));

                           body.emit(assign(r0BC7, r0BDF, 0x01));

                           body.emit(assign(r0BC8, r0BDE, 0x01));

                           body.emit(assign(r0BC5, body.constant(int(0)), 0x01));

                           body.emit(assign(r0BCB, less(r0BDE, body.constant(0u)), 0x01));


                        body.instructions = f0BDA_parent_instructions;
                        body.emit(f0BDA);

                        /* END IF */


                     body.instructions = f0BD7_parent_instructions;
                     body.emit(f0BD7);

                     /* END IF */


                  body.instructions = f0BCD_parent_instructions;
                  body.emit(f0BCD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0BF6 = new(mem_ctx) ir_if(operand(r0BC9).val);
                  exec_list *const f0BF6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BF6->then_instructions;

                     /* IF CONDITION */
                     ir_if *f0BF7 = new(mem_ctx) ir_if(operand(r0BCB).val);
                     exec_list *const f0BF7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BF7->then_instructions;

                        ir_variable *const r0BF8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r0BF8, add(r0BC7, body.constant(1u)), 0x01));

                        ir_expression *const r0BF9 = less(r0BF8, r0BC7);
                        ir_expression *const r0BFA = expr(ir_unop_b2i, r0BF9);
                        ir_expression *const r0BFB = expr(ir_unop_i2u, r0BFA);
                        body.emit(assign(r0BC6, add(r0BC6, r0BFB), 0x01));

                        ir_expression *const r0BFC = equal(r0BC8, body.constant(0u));
                        ir_expression *const r0BFD = expr(ir_unop_b2i, r0BFC);
                        ir_expression *const r0BFE = expr(ir_unop_i2u, r0BFD);
                        ir_expression *const r0BFF = add(r0BC8, r0BFE);
                        ir_expression *const r0C00 = bit_and(r0BFF, body.constant(1u));
                        ir_expression *const r0C01 = expr(ir_unop_bit_not, r0C00);
                        body.emit(assign(r0BC7, bit_and(r0BF8, r0C01), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BF7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0C03 = bit_or(r0BC6, r0BC7);
                        ir_expression *const r0C04 = equal(r0C03, body.constant(0u));
                        ir_if *f0C02 = new(mem_ctx) ir_if(operand(r0C04).val);
                        exec_list *const f0C02_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C02->then_instructions;

                           body.emit(assign(r0BC5, body.constant(int(0)), 0x01));


                        body.instructions = f0C02_parent_instructions;
                        body.emit(f0C02);

                        /* END IF */


                     body.instructions = f0BF7_parent_instructions;
                     body.emit(f0BF7);

                     /* END IF */

                     ir_variable *const r0C05 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0C05);
                     ir_expression *const r0C06 = lshift(r0999, body.constant(int(31)));
                     ir_expression *const r0C07 = expr(ir_unop_i2u, r0BC5);
                     ir_expression *const r0C08 = lshift(r0C07, body.constant(int(20)));
                     ir_expression *const r0C09 = add(r0C06, r0C08);
                     body.emit(assign(r0C05, add(r0C09, r0BC6), 0x02));

                     body.emit(assign(r0C05, r0BC7, 0x01));

                     body.emit(assign(r0BCA, r0C05, 0x03));

                     body.emit(assign(r0BC9, body.constant(false), 0x01));


                  body.instructions = f0BF6_parent_instructions;
                  body.emit(f0BF6);

                  /* END IF */

                  body.emit(assign(r099A, r0BCA, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B7E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0C0B = less(r09A0, r099E);
                  ir_if *f0C0A = new(mem_ctx) ir_if(operand(r0C0B).val);
                  exec_list *const f0C0A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0C0A->then_instructions;

                     ir_variable *const r0C0C = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r0C0D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0C0D, sub(r099F, r09A1), 0x01));

                     ir_expression *const r0C0E = sub(r099E, r09A0);
                     ir_expression *const r0C0F = less(r099F, r09A1);
                     ir_expression *const r0C10 = expr(ir_unop_b2i, r0C0F);
                     ir_expression *const r0C11 = expr(ir_unop_i2u, r0C10);
                     body.emit(assign(r0C0C, sub(r0C0E, r0C11), 0x01));

                     body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                     body.emit(assign(r09A2, add(r099C, body.constant(int(-1))), 0x01));

                     ir_variable *const r0C12 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C12, add(r09A2, body.constant(int(-10))), 0x01));

                     ir_variable *const r0C13 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C13, r0C0C, 0x01));

                     ir_variable *const r0C14 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C14, r0C0D, 0x01));

                     ir_variable *const r0C15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r0C15);
                     ir_variable *const r0C16 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C16);
                     /* IF CONDITION */
                     ir_expression *const r0C18 = equal(r0C0C, body.constant(0u));
                     ir_if *f0C17 = new(mem_ctx) ir_if(operand(r0C18).val);
                     exec_list *const f0C17_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C17->then_instructions;

                        body.emit(assign(r0C13, r0C0D, 0x01));

                        body.emit(assign(r0C14, body.constant(0u), 0x01));

                        body.emit(assign(r0C12, add(r0C12, body.constant(int(-32))), 0x01));


                     body.instructions = f0C17_parent_instructions;
                     body.emit(f0C17);

                     /* END IF */

                     ir_variable *const r0C19 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0C19, r0C13, 0x01));

                     ir_variable *const r0C1A = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0C1B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C1B);
                     /* IF CONDITION */
                     ir_expression *const r0C1D = equal(r0C13, body.constant(0u));
                     ir_if *f0C1C = new(mem_ctx) ir_if(operand(r0C1D).val);
                     exec_list *const f0C1C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C1C->then_instructions;

                        body.emit(assign(r0C1A, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C1C->else_instructions;

                        body.emit(assign(r0C1B, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C1F = bit_and(r0C13, body.constant(4294901760u));
                        ir_expression *const r0C20 = equal(r0C1F, body.constant(0u));
                        ir_if *f0C1E = new(mem_ctx) ir_if(operand(r0C20).val);
                        exec_list *const f0C1E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C1E->then_instructions;

                           body.emit(assign(r0C1B, body.constant(int(16)), 0x01));

                           body.emit(assign(r0C19, lshift(r0C13, body.constant(int(16))), 0x01));


                        body.instructions = f0C1E_parent_instructions;
                        body.emit(f0C1E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C22 = bit_and(r0C19, body.constant(4278190080u));
                        ir_expression *const r0C23 = equal(r0C22, body.constant(0u));
                        ir_if *f0C21 = new(mem_ctx) ir_if(operand(r0C23).val);
                        exec_list *const f0C21_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C21->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(8))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(8))), 0x01));


                        body.instructions = f0C21_parent_instructions;
                        body.emit(f0C21);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C25 = bit_and(r0C19, body.constant(4026531840u));
                        ir_expression *const r0C26 = equal(r0C25, body.constant(0u));
                        ir_if *f0C24 = new(mem_ctx) ir_if(operand(r0C26).val);
                        exec_list *const f0C24_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C24->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(4))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(4))), 0x01));


                        body.instructions = f0C24_parent_instructions;
                        body.emit(f0C24);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C28 = bit_and(r0C19, body.constant(3221225472u));
                        ir_expression *const r0C29 = equal(r0C28, body.constant(0u));
                        ir_if *f0C27 = new(mem_ctx) ir_if(operand(r0C29).val);
                        exec_list *const f0C27_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C27->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(2))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(2))), 0x01));


                        body.instructions = f0C27_parent_instructions;
                        body.emit(f0C27);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C2B = bit_and(r0C19, body.constant(2147483648u));
                        ir_expression *const r0C2C = equal(r0C2B, body.constant(0u));
                        ir_if *f0C2A = new(mem_ctx) ir_if(operand(r0C2C).val);
                        exec_list *const f0C2A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C2A->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(1))), 0x01));


                        body.instructions = f0C2A_parent_instructions;
                        body.emit(f0C2A);

                        /* END IF */

                        body.emit(assign(r0C1A, r0C1B, 0x01));


                     body.instructions = f0C1C_parent_instructions;
                     body.emit(f0C1C);

                     /* END IF */

                     body.emit(assign(r0C16, add(r0C1A, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C2E = lequal(body.constant(int(0)), r0C16);
                     ir_if *f0C2D = new(mem_ctx) ir_if(operand(r0C2E).val);
                     exec_list *const f0C2D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C2D->then_instructions;

                        body.emit(assign(r0C15, body.constant(0u), 0x01));

                        ir_variable *const r0C2F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C2F, lshift(r0C14, r0C16), 0x01));

                        ir_variable *const r0C30 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C32 = equal(r0C16, body.constant(int(0)));
                        ir_if *f0C31 = new(mem_ctx) ir_if(operand(r0C32).val);
                        exec_list *const f0C31_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C31->then_instructions;

                           body.emit(assign(r0C30, r0C13, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C31->else_instructions;

                           ir_expression *const r0C33 = lshift(r0C13, r0C16);
                           ir_expression *const r0C34 = neg(r0C16);
                           ir_expression *const r0C35 = bit_and(r0C34, body.constant(int(31)));
                           ir_expression *const r0C36 = rshift(r0C14, r0C35);
                           body.emit(assign(r0C30, bit_or(r0C33, r0C36), 0x01));


                        body.instructions = f0C31_parent_instructions;
                        body.emit(f0C31);

                        /* END IF */

                        body.emit(assign(r0C13, r0C30, 0x01));

                        body.emit(assign(r0C14, r0C2F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C2D->else_instructions;

                        ir_variable *const r0C37 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0C37, body.constant(0u), 0x01));

                        ir_variable *const r0C38 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0C38, neg(r0C16), 0x01));

                        ir_variable *const r0C39 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0C39);
                        ir_variable *const r0C3A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0C3A);
                        ir_variable *const r0C3B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0C3B);
                        ir_variable *const r0C3C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0C3D = neg(r0C38);
                        body.emit(assign(r0C3C, bit_and(r0C3D, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C3F = equal(r0C38, body.constant(int(0)));
                        ir_if *f0C3E = new(mem_ctx) ir_if(operand(r0C3F).val);
                        exec_list *const f0C3E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C3E->then_instructions;

                           body.emit(assign(r0C39, r0C37, 0x01));

                           body.emit(assign(r0C3A, r0C14, 0x01));

                           body.emit(assign(r0C3B, r0C13, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C3E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C41 = less(r0C38, body.constant(int(32)));
                           ir_if *f0C40 = new(mem_ctx) ir_if(operand(r0C41).val);
                           exec_list *const f0C40_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C40->then_instructions;

                              body.emit(assign(r0C39, lshift(r0C14, r0C3C), 0x01));

                              ir_expression *const r0C42 = lshift(r0C13, r0C3C);
                              ir_expression *const r0C43 = rshift(r0C14, r0C38);
                              body.emit(assign(r0C3A, bit_or(r0C42, r0C43), 0x01));

                              body.emit(assign(r0C3B, rshift(r0C13, r0C38), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C40->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0C45 = equal(r0C38, body.constant(int(32)));
                              ir_if *f0C44 = new(mem_ctx) ir_if(operand(r0C45).val);
                              exec_list *const f0C44_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C44->then_instructions;

                                 body.emit(assign(r0C39, r0C14, 0x01));

                                 body.emit(assign(r0C3A, r0C13, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C44->else_instructions;

                                 body.emit(assign(r0C37, bit_or(body.constant(0u), r0C14), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0C47 = less(r0C38, body.constant(int(64)));
                                 ir_if *f0C46 = new(mem_ctx) ir_if(operand(r0C47).val);
                                 exec_list *const f0C46_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C46->then_instructions;

                                    body.emit(assign(r0C39, lshift(r0C13, r0C3C), 0x01));

                                    ir_expression *const r0C48 = bit_and(r0C38, body.constant(int(31)));
                                    body.emit(assign(r0C3A, rshift(r0C13, r0C48), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C46->else_instructions;

                                    ir_variable *const r0C49 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0C4B = equal(r0C38, body.constant(int(64)));
                                    ir_if *f0C4A = new(mem_ctx) ir_if(operand(r0C4B).val);
                                    exec_list *const f0C4A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C4A->then_instructions;

                                       body.emit(assign(r0C49, r0C13, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C4A->else_instructions;

                                       ir_expression *const r0C4C = nequal(r0C13, body.constant(0u));
                                       ir_expression *const r0C4D = expr(ir_unop_b2i, r0C4C);
                                       body.emit(assign(r0C49, expr(ir_unop_i2u, r0C4D), 0x01));


                                    body.instructions = f0C4A_parent_instructions;
                                    body.emit(f0C4A);

                                    /* END IF */

                                    body.emit(assign(r0C39, r0C49, 0x01));

                                    body.emit(assign(r0C3A, body.constant(0u), 0x01));


                                 body.instructions = f0C46_parent_instructions;
                                 body.emit(f0C46);

                                 /* END IF */


                              body.instructions = f0C44_parent_instructions;
                              body.emit(f0C44);

                              /* END IF */

                              body.emit(assign(r0C3B, body.constant(0u), 0x01));


                           body.instructions = f0C40_parent_instructions;
                           body.emit(f0C40);

                           /* END IF */

                           ir_expression *const r0C4E = nequal(r0C37, body.constant(0u));
                           ir_expression *const r0C4F = expr(ir_unop_b2i, r0C4E);
                           ir_expression *const r0C50 = expr(ir_unop_i2u, r0C4F);
                           body.emit(assign(r0C39, bit_or(r0C39, r0C50), 0x01));


                        body.instructions = f0C3E_parent_instructions;
                        body.emit(f0C3E);

                        /* END IF */

                        body.emit(assign(r0C13, r0C3B, 0x01));

                        body.emit(assign(r0C14, r0C3A, 0x01));

                        body.emit(assign(r0C15, r0C39, 0x01));


                     body.instructions = f0C2D_parent_instructions;
                     body.emit(f0C2D);

                     /* END IF */

                     body.emit(assign(r0C12, sub(r0C12, r0C16), 0x01));

                     ir_variable *const r0C51 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C51, r0C12, 0x01));

                     ir_variable *const r0C52 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C52, r0C13, 0x01));

                     ir_variable *const r0C53 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C53, r0C14, 0x01));

                     ir_variable *const r0C54 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r0C54, r0C15, 0x01));

                     ir_variable *const r0C55 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r0C55, body.constant(true), 0x01));

                     ir_variable *const r0C56 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r0C57 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r0C57);
                     ir_expression *const r0C58 = expr(ir_unop_u2i, r0C15);
                     body.emit(assign(r0C57, less(r0C58, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C5A = lequal(body.constant(int(2045)), r0C12);
                     ir_if *f0C59 = new(mem_ctx) ir_if(operand(r0C5A).val);
                     exec_list *const f0C59_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C59->then_instructions;

                        ir_variable *const r0C5B = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C5D = less(body.constant(int(2045)), r0C12);
                        ir_if *f0C5C = new(mem_ctx) ir_if(operand(r0C5D).val);
                        exec_list *const f0C5C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C5C->then_instructions;

                           body.emit(assign(r0C5B, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C5C->else_instructions;

                           ir_variable *const r0C5E = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0C60 = equal(r0C12, body.constant(int(2045)));
                           ir_if *f0C5F = new(mem_ctx) ir_if(operand(r0C60).val);
                           exec_list *const f0C5F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C5F->then_instructions;

                              ir_expression *const r0C61 = equal(body.constant(2097151u), r0C13);
                              ir_expression *const r0C62 = equal(body.constant(4294967295u), r0C14);
                              body.emit(assign(r0C5E, logic_and(r0C61, r0C62), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C5F->else_instructions;

                              body.emit(assign(r0C5E, body.constant(false), 0x01));


                           body.instructions = f0C5F_parent_instructions;
                           body.emit(f0C5F);

                           /* END IF */

                           body.emit(assign(r0C5B, logic_and(r0C5E, r0C57), 0x01));


                        body.instructions = f0C5C_parent_instructions;
                        body.emit(f0C5C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0C63 = new(mem_ctx) ir_if(operand(r0C5B).val);
                        exec_list *const f0C63_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C63->then_instructions;

                           ir_variable *const r0C64 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0C64);
                           ir_expression *const r0C65 = lshift(r0999, body.constant(int(31)));
                           body.emit(assign(r0C64, add(r0C65, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r0C64, body.constant(0u), 0x01));

                           body.emit(assign(r0C56, r0C64, 0x03));

                           body.emit(assign(r0C55, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C63->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C67 = less(r0C12, body.constant(int(0)));
                           ir_if *f0C66 = new(mem_ctx) ir_if(operand(r0C67).val);
                           exec_list *const f0C66_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C66->then_instructions;

                              ir_variable *const r0C68 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0C68, r0C15, 0x01));

                              ir_variable *const r0C69 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0C69, neg(r0C12), 0x01));

                              ir_variable *const r0C6A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0C6A);
                              ir_variable *const r0C6B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0C6B);
                              ir_variable *const r0C6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0C6C);
                              ir_variable *const r0C6D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0C6E = neg(r0C69);
                              body.emit(assign(r0C6D, bit_and(r0C6E, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0C70 = equal(r0C69, body.constant(int(0)));
                              ir_if *f0C6F = new(mem_ctx) ir_if(operand(r0C70).val);
                              exec_list *const f0C6F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C6F->then_instructions;

                                 body.emit(assign(r0C6A, r0C15, 0x01));

                                 body.emit(assign(r0C6B, r0C14, 0x01));

                                 body.emit(assign(r0C6C, r0C13, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C6F->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0C72 = less(r0C69, body.constant(int(32)));
                                 ir_if *f0C71 = new(mem_ctx) ir_if(operand(r0C72).val);
                                 exec_list *const f0C71_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C71->then_instructions;

                                    body.emit(assign(r0C6A, lshift(r0C14, r0C6D), 0x01));

                                    ir_expression *const r0C73 = lshift(r0C13, r0C6D);
                                    ir_expression *const r0C74 = rshift(r0C14, r0C69);
                                    body.emit(assign(r0C6B, bit_or(r0C73, r0C74), 0x01));

                                    body.emit(assign(r0C6C, rshift(r0C13, r0C69), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C71->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0C76 = equal(r0C69, body.constant(int(32)));
                                    ir_if *f0C75 = new(mem_ctx) ir_if(operand(r0C76).val);
                                    exec_list *const f0C75_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C75->then_instructions;

                                       body.emit(assign(r0C6A, r0C14, 0x01));

                                       body.emit(assign(r0C6B, r0C13, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C75->else_instructions;

                                       body.emit(assign(r0C68, bit_or(r0C15, r0C14), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0C78 = less(r0C69, body.constant(int(64)));
                                       ir_if *f0C77 = new(mem_ctx) ir_if(operand(r0C78).val);
                                       exec_list *const f0C77_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0C77->then_instructions;

                                          body.emit(assign(r0C6A, lshift(r0C13, r0C6D), 0x01));

                                          ir_expression *const r0C79 = bit_and(r0C69, body.constant(int(31)));
                                          body.emit(assign(r0C6B, rshift(r0C13, r0C79), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0C77->else_instructions;

                                          ir_variable *const r0C7A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0C7C = equal(r0C69, body.constant(int(64)));
                                          ir_if *f0C7B = new(mem_ctx) ir_if(operand(r0C7C).val);
                                          exec_list *const f0C7B_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0C7B->then_instructions;

                                             body.emit(assign(r0C7A, r0C13, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0C7B->else_instructions;

                                             ir_expression *const r0C7D = nequal(r0C13, body.constant(0u));
                                             ir_expression *const r0C7E = expr(ir_unop_b2i, r0C7D);
                                             body.emit(assign(r0C7A, expr(ir_unop_i2u, r0C7E), 0x01));


                                          body.instructions = f0C7B_parent_instructions;
                                          body.emit(f0C7B);

                                          /* END IF */

                                          body.emit(assign(r0C6A, r0C7A, 0x01));

                                          body.emit(assign(r0C6B, body.constant(0u), 0x01));


                                       body.instructions = f0C77_parent_instructions;
                                       body.emit(f0C77);

                                       /* END IF */


                                    body.instructions = f0C75_parent_instructions;
                                    body.emit(f0C75);

                                    /* END IF */

                                    body.emit(assign(r0C6C, body.constant(0u), 0x01));


                                 body.instructions = f0C71_parent_instructions;
                                 body.emit(f0C71);

                                 /* END IF */

                                 ir_expression *const r0C7F = nequal(r0C68, body.constant(0u));
                                 ir_expression *const r0C80 = expr(ir_unop_b2i, r0C7F);
                                 ir_expression *const r0C81 = expr(ir_unop_i2u, r0C80);
                                 body.emit(assign(r0C6A, bit_or(r0C6A, r0C81), 0x01));


                              body.instructions = f0C6F_parent_instructions;
                              body.emit(f0C6F);

                              /* END IF */

                              body.emit(assign(r0C52, r0C6C, 0x01));

                              body.emit(assign(r0C53, r0C6B, 0x01));

                              body.emit(assign(r0C54, r0C6A, 0x01));

                              body.emit(assign(r0C51, body.constant(int(0)), 0x01));

                              body.emit(assign(r0C57, less(r0C6A, body.constant(0u)), 0x01));


                           body.instructions = f0C66_parent_instructions;
                           body.emit(f0C66);

                           /* END IF */


                        body.instructions = f0C63_parent_instructions;
                        body.emit(f0C63);

                        /* END IF */


                     body.instructions = f0C59_parent_instructions;
                     body.emit(f0C59);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0C82 = new(mem_ctx) ir_if(operand(r0C55).val);
                     exec_list *const f0C82_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C82->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0C83 = new(mem_ctx) ir_if(operand(r0C57).val);
                        exec_list *const f0C83_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C83->then_instructions;

                           ir_variable *const r0C84 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r0C84, add(r0C53, body.constant(1u)), 0x01));

                           ir_expression *const r0C85 = less(r0C84, r0C53);
                           ir_expression *const r0C86 = expr(ir_unop_b2i, r0C85);
                           ir_expression *const r0C87 = expr(ir_unop_i2u, r0C86);
                           body.emit(assign(r0C52, add(r0C52, r0C87), 0x01));

                           ir_expression *const r0C88 = equal(r0C54, body.constant(0u));
                           ir_expression *const r0C89 = expr(ir_unop_b2i, r0C88);
                           ir_expression *const r0C8A = expr(ir_unop_i2u, r0C89);
                           ir_expression *const r0C8B = add(r0C54, r0C8A);
                           ir_expression *const r0C8C = bit_and(r0C8B, body.constant(1u));
                           ir_expression *const r0C8D = expr(ir_unop_bit_not, r0C8C);
                           body.emit(assign(r0C53, bit_and(r0C84, r0C8D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C83->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C8F = bit_or(r0C52, r0C53);
                           ir_expression *const r0C90 = equal(r0C8F, body.constant(0u));
                           ir_if *f0C8E = new(mem_ctx) ir_if(operand(r0C90).val);
                           exec_list *const f0C8E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C8E->then_instructions;

                              body.emit(assign(r0C51, body.constant(int(0)), 0x01));


                           body.instructions = f0C8E_parent_instructions;
                           body.emit(f0C8E);

                           /* END IF */


                        body.instructions = f0C83_parent_instructions;
                        body.emit(f0C83);

                        /* END IF */

                        ir_variable *const r0C91 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0C91);
                        ir_expression *const r0C92 = lshift(r0999, body.constant(int(31)));
                        ir_expression *const r0C93 = expr(ir_unop_i2u, r0C51);
                        ir_expression *const r0C94 = lshift(r0C93, body.constant(int(20)));
                        ir_expression *const r0C95 = add(r0C92, r0C94);
                        body.emit(assign(r0C91, add(r0C95, r0C52), 0x02));

                        body.emit(assign(r0C91, r0C53, 0x01));

                        body.emit(assign(r0C56, r0C91, 0x03));

                        body.emit(assign(r0C55, body.constant(false), 0x01));


                     body.instructions = f0C82_parent_instructions;
                     body.emit(f0C82);

                     /* END IF */

                     body.emit(assign(r099A, r0C56, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0C0A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0C97 = less(r099F, r09A1);
                     ir_if *f0C96 = new(mem_ctx) ir_if(operand(r0C97).val);
                     exec_list *const f0C96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C96->then_instructions;

                        ir_variable *const r0C98 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r0C99 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C99, sub(r09A1, r099F), 0x01));

                        ir_expression *const r0C9A = sub(r09A0, r099E);
                        ir_expression *const r0C9B = less(r09A1, r099F);
                        ir_expression *const r0C9C = expr(ir_unop_b2i, r0C9B);
                        ir_expression *const r0C9D = expr(ir_unop_i2u, r0C9C);
                        body.emit(assign(r0C98, sub(r0C9A, r0C9D), 0x01));

                        body.emit(assign(r09A2, add(r099D, body.constant(int(-1))), 0x01));

                        ir_variable *const r0C9E = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0C9E, add(r09A2, body.constant(int(-10))), 0x01));

                        ir_variable *const r0C9F = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0C9F, r0C98, 0x01));

                        ir_variable *const r0CA0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CA0, r0C99, 0x01));

                        ir_variable *const r0CA1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0CA1);
                        ir_variable *const r0CA2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA2);
                        /* IF CONDITION */
                        ir_expression *const r0CA4 = equal(r0C98, body.constant(0u));
                        ir_if *f0CA3 = new(mem_ctx) ir_if(operand(r0CA4).val);
                        exec_list *const f0CA3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA3->then_instructions;

                           body.emit(assign(r0C9F, r0C99, 0x01));

                           body.emit(assign(r0CA0, body.constant(0u), 0x01));

                           body.emit(assign(r0C9E, add(r0C9E, body.constant(int(-32))), 0x01));


                        body.instructions = f0CA3_parent_instructions;
                        body.emit(f0CA3);

                        /* END IF */

                        ir_variable *const r0CA5 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r0CA5, r0C9F, 0x01));

                        ir_variable *const r0CA6 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r0CA7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA7);
                        /* IF CONDITION */
                        ir_expression *const r0CA9 = equal(r0C9F, body.constant(0u));
                        ir_if *f0CA8 = new(mem_ctx) ir_if(operand(r0CA9).val);
                        exec_list *const f0CA8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA8->then_instructions;

                           body.emit(assign(r0CA6, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CA8->else_instructions;

                           body.emit(assign(r0CA7, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CAB = bit_and(r0C9F, body.constant(4294901760u));
                           ir_expression *const r0CAC = equal(r0CAB, body.constant(0u));
                           ir_if *f0CAA = new(mem_ctx) ir_if(operand(r0CAC).val);
                           exec_list *const f0CAA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAA->then_instructions;

                              body.emit(assign(r0CA7, body.constant(int(16)), 0x01));

                              body.emit(assign(r0CA5, lshift(r0C9F, body.constant(int(16))), 0x01));


                           body.instructions = f0CAA_parent_instructions;
                           body.emit(f0CAA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CAE = bit_and(r0CA5, body.constant(4278190080u));
                           ir_expression *const r0CAF = equal(r0CAE, body.constant(0u));
                           ir_if *f0CAD = new(mem_ctx) ir_if(operand(r0CAF).val);
                           exec_list *const f0CAD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAD->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(8))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(8))), 0x01));


                           body.instructions = f0CAD_parent_instructions;
                           body.emit(f0CAD);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB1 = bit_and(r0CA5, body.constant(4026531840u));
                           ir_expression *const r0CB2 = equal(r0CB1, body.constant(0u));
                           ir_if *f0CB0 = new(mem_ctx) ir_if(operand(r0CB2).val);
                           exec_list *const f0CB0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB0->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(4))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(4))), 0x01));


                           body.instructions = f0CB0_parent_instructions;
                           body.emit(f0CB0);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB4 = bit_and(r0CA5, body.constant(3221225472u));
                           ir_expression *const r0CB5 = equal(r0CB4, body.constant(0u));
                           ir_if *f0CB3 = new(mem_ctx) ir_if(operand(r0CB5).val);
                           exec_list *const f0CB3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB3->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(2))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(2))), 0x01));


                           body.instructions = f0CB3_parent_instructions;
                           body.emit(f0CB3);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB7 = bit_and(r0CA5, body.constant(2147483648u));
                           ir_expression *const r0CB8 = equal(r0CB7, body.constant(0u));
                           ir_if *f0CB6 = new(mem_ctx) ir_if(operand(r0CB8).val);
                           exec_list *const f0CB6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB6->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(1))), 0x01));


                           body.instructions = f0CB6_parent_instructions;
                           body.emit(f0CB6);

                           /* END IF */

                           body.emit(assign(r0CA6, r0CA7, 0x01));


                        body.instructions = f0CA8_parent_instructions;
                        body.emit(f0CA8);

                        /* END IF */

                        body.emit(assign(r0CA2, add(r0CA6, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CBA = lequal(body.constant(int(0)), r0CA2);
                        ir_if *f0CB9 = new(mem_ctx) ir_if(operand(r0CBA).val);
                        exec_list *const f0CB9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CB9->then_instructions;

                           body.emit(assign(r0CA1, body.constant(0u), 0x01));

                           ir_variable *const r0CBB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0CBB, lshift(r0CA0, r0CA2), 0x01));

                           ir_variable *const r0CBC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CBE = equal(r0CA2, body.constant(int(0)));
                           ir_if *f0CBD = new(mem_ctx) ir_if(operand(r0CBE).val);
                           exec_list *const f0CBD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CBD->then_instructions;

                              body.emit(assign(r0CBC, r0C9F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CBD->else_instructions;

                              ir_expression *const r0CBF = lshift(r0C9F, r0CA2);
                              ir_expression *const r0CC0 = neg(r0CA2);
                              ir_expression *const r0CC1 = bit_and(r0CC0, body.constant(int(31)));
                              ir_expression *const r0CC2 = rshift(r0CA0, r0CC1);
                              body.emit(assign(r0CBC, bit_or(r0CBF, r0CC2), 0x01));


                           body.instructions = f0CBD_parent_instructions;
                           body.emit(f0CBD);

                           /* END IF */

                           body.emit(assign(r0C9F, r0CBC, 0x01));

                           body.emit(assign(r0CA0, r0CBB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CB9->else_instructions;

                           ir_variable *const r0CC3 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0CC3, body.constant(0u), 0x01));

                           ir_variable *const r0CC4 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0CC4, neg(r0CA2), 0x01));

                           ir_variable *const r0CC5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0CC5);
                           ir_variable *const r0CC6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0CC6);
                           ir_variable *const r0CC7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0CC7);
                           ir_variable *const r0CC8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0CC9 = neg(r0CC4);
                           body.emit(assign(r0CC8, bit_and(r0CC9, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CCB = equal(r0CC4, body.constant(int(0)));
                           ir_if *f0CCA = new(mem_ctx) ir_if(operand(r0CCB).val);
                           exec_list *const f0CCA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CCA->then_instructions;

                              body.emit(assign(r0CC5, r0CC3, 0x01));

                              body.emit(assign(r0CC6, r0CA0, 0x01));

                              body.emit(assign(r0CC7, r0C9F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CCA->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CCD = less(r0CC4, body.constant(int(32)));
                              ir_if *f0CCC = new(mem_ctx) ir_if(operand(r0CCD).val);
                              exec_list *const f0CCC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CCC->then_instructions;

                                 body.emit(assign(r0CC5, lshift(r0CA0, r0CC8), 0x01));

                                 ir_expression *const r0CCE = lshift(r0C9F, r0CC8);
                                 ir_expression *const r0CCF = rshift(r0CA0, r0CC4);
                                 body.emit(assign(r0CC6, bit_or(r0CCE, r0CCF), 0x01));

                                 body.emit(assign(r0CC7, rshift(r0C9F, r0CC4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CCC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0CD1 = equal(r0CC4, body.constant(int(32)));
                                 ir_if *f0CD0 = new(mem_ctx) ir_if(operand(r0CD1).val);
                                 exec_list *const f0CD0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CD0->then_instructions;

                                    body.emit(assign(r0CC5, r0CA0, 0x01));

                                    body.emit(assign(r0CC6, r0C9F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CD0->else_instructions;

                                    body.emit(assign(r0CC3, bit_or(body.constant(0u), r0CA0), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0CD3 = less(r0CC4, body.constant(int(64)));
                                    ir_if *f0CD2 = new(mem_ctx) ir_if(operand(r0CD3).val);
                                    exec_list *const f0CD2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CD2->then_instructions;

                                       body.emit(assign(r0CC5, lshift(r0C9F, r0CC8), 0x01));

                                       ir_expression *const r0CD4 = bit_and(r0CC4, body.constant(int(31)));
                                       body.emit(assign(r0CC6, rshift(r0C9F, r0CD4), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CD2->else_instructions;

                                       ir_variable *const r0CD5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0CD7 = equal(r0CC4, body.constant(int(64)));
                                       ir_if *f0CD6 = new(mem_ctx) ir_if(operand(r0CD7).val);
                                       exec_list *const f0CD6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0CD6->then_instructions;

                                          body.emit(assign(r0CD5, r0C9F, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0CD6->else_instructions;

                                          ir_expression *const r0CD8 = nequal(r0C9F, body.constant(0u));
                                          ir_expression *const r0CD9 = expr(ir_unop_b2i, r0CD8);
                                          body.emit(assign(r0CD5, expr(ir_unop_i2u, r0CD9), 0x01));


                                       body.instructions = f0CD6_parent_instructions;
                                       body.emit(f0CD6);

                                       /* END IF */

                                       body.emit(assign(r0CC5, r0CD5, 0x01));

                                       body.emit(assign(r0CC6, body.constant(0u), 0x01));


                                    body.instructions = f0CD2_parent_instructions;
                                    body.emit(f0CD2);

                                    /* END IF */


                                 body.instructions = f0CD0_parent_instructions;
                                 body.emit(f0CD0);

                                 /* END IF */

                                 body.emit(assign(r0CC7, body.constant(0u), 0x01));


                              body.instructions = f0CCC_parent_instructions;
                              body.emit(f0CCC);

                              /* END IF */

                              ir_expression *const r0CDA = nequal(r0CC3, body.constant(0u));
                              ir_expression *const r0CDB = expr(ir_unop_b2i, r0CDA);
                              ir_expression *const r0CDC = expr(ir_unop_i2u, r0CDB);
                              body.emit(assign(r0CC5, bit_or(r0CC5, r0CDC), 0x01));


                           body.instructions = f0CCA_parent_instructions;
                           body.emit(f0CCA);

                           /* END IF */

                           body.emit(assign(r0C9F, r0CC7, 0x01));

                           body.emit(assign(r0CA0, r0CC6, 0x01));

                           body.emit(assign(r0CA1, r0CC5, 0x01));


                        body.instructions = f0CB9_parent_instructions;
                        body.emit(f0CB9);

                        /* END IF */

                        body.emit(assign(r0C9E, sub(r0C9E, r0CA2), 0x01));

                        ir_variable *const r0CDD = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0CDD, r0C9E, 0x01));

                        ir_variable *const r0CDE = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0CDE, r0C9F, 0x01));

                        ir_variable *const r0CDF = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CDF, r0CA0, 0x01));

                        ir_variable *const r0CE0 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r0CE0, r0CA1, 0x01));

                        ir_variable *const r0CE1 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r0CE1, body.constant(true), 0x01));

                        ir_variable *const r0CE2 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r0CE3 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r0CE3);
                        ir_expression *const r0CE4 = expr(ir_unop_u2i, r0CA1);
                        body.emit(assign(r0CE3, less(r0CE4, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CE6 = lequal(body.constant(int(2045)), r0C9E);
                        ir_if *f0CE5 = new(mem_ctx) ir_if(operand(r0CE6).val);
                        exec_list *const f0CE5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CE5->then_instructions;

                           ir_variable *const r0CE7 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CE9 = less(body.constant(int(2045)), r0C9E);
                           ir_if *f0CE8 = new(mem_ctx) ir_if(operand(r0CE9).val);
                           exec_list *const f0CE8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CE8->then_instructions;

                              body.emit(assign(r0CE7, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CE8->else_instructions;

                              ir_variable *const r0CEA = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0CEC = equal(r0C9E, body.constant(int(2045)));
                              ir_if *f0CEB = new(mem_ctx) ir_if(operand(r0CEC).val);
                              exec_list *const f0CEB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CEB->then_instructions;

                                 ir_expression *const r0CED = equal(body.constant(2097151u), r0C9F);
                                 ir_expression *const r0CEE = equal(body.constant(4294967295u), r0CA0);
                                 body.emit(assign(r0CEA, logic_and(r0CED, r0CEE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CEB->else_instructions;

                                 body.emit(assign(r0CEA, body.constant(false), 0x01));


                              body.instructions = f0CEB_parent_instructions;
                              body.emit(f0CEB);

                              /* END IF */

                              body.emit(assign(r0CE7, logic_and(r0CEA, r0CE3), 0x01));


                           body.instructions = f0CE8_parent_instructions;
                           body.emit(f0CE8);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0CEF = new(mem_ctx) ir_if(operand(r0CE7).val);
                           exec_list *const f0CEF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CEF->then_instructions;

                              ir_variable *const r0CF0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0CF0);
                              ir_expression *const r0CF1 = lshift(r0999, body.constant(int(31)));
                              body.emit(assign(r0CF0, add(r0CF1, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r0CF0, body.constant(0u), 0x01));

                              body.emit(assign(r0CE2, r0CF0, 0x03));

                              body.emit(assign(r0CE1, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CEF->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CF3 = less(r0C9E, body.constant(int(0)));
                              ir_if *f0CF2 = new(mem_ctx) ir_if(operand(r0CF3).val);
                              exec_list *const f0CF2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CF2->then_instructions;

                                 ir_variable *const r0CF4 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r0CF4, r0CA1, 0x01));

                                 ir_variable *const r0CF5 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r0CF5, neg(r0C9E), 0x01));

                                 ir_variable *const r0CF6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r0CF6);
                                 ir_variable *const r0CF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r0CF7);
                                 ir_variable *const r0CF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r0CF8);
                                 ir_variable *const r0CF9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r0CFA = neg(r0CF5);
                                 body.emit(assign(r0CF9, bit_and(r0CFA, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0CFC = equal(r0CF5, body.constant(int(0)));
                                 ir_if *f0CFB = new(mem_ctx) ir_if(operand(r0CFC).val);
                                 exec_list *const f0CFB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CFB->then_instructions;

                                    body.emit(assign(r0CF6, r0CA1, 0x01));

                                    body.emit(assign(r0CF7, r0CA0, 0x01));

                                    body.emit(assign(r0CF8, r0C9F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CFB->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0CFE = less(r0CF5, body.constant(int(32)));
                                    ir_if *f0CFD = new(mem_ctx) ir_if(operand(r0CFE).val);
                                    exec_list *const f0CFD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CFD->then_instructions;

                                       body.emit(assign(r0CF6, lshift(r0CA0, r0CF9), 0x01));

                                       ir_expression *const r0CFF = lshift(r0C9F, r0CF9);
                                       ir_expression *const r0D00 = rshift(r0CA0, r0CF5);
                                       body.emit(assign(r0CF7, bit_or(r0CFF, r0D00), 0x01));

                                       body.emit(assign(r0CF8, rshift(r0C9F, r0CF5), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CFD->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D02 = equal(r0CF5, body.constant(int(32)));
                                       ir_if *f0D01 = new(mem_ctx) ir_if(operand(r0D02).val);
                                       exec_list *const f0D01_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D01->then_instructions;

                                          body.emit(assign(r0CF6, r0CA0, 0x01));

                                          body.emit(assign(r0CF7, r0C9F, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D01->else_instructions;

                                          body.emit(assign(r0CF4, bit_or(r0CA1, r0CA0), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r0D04 = less(r0CF5, body.constant(int(64)));
                                          ir_if *f0D03 = new(mem_ctx) ir_if(operand(r0D04).val);
                                          exec_list *const f0D03_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D03->then_instructions;

                                             body.emit(assign(r0CF6, lshift(r0C9F, r0CF9), 0x01));

                                             ir_expression *const r0D05 = bit_and(r0CF5, body.constant(int(31)));
                                             body.emit(assign(r0CF7, rshift(r0C9F, r0D05), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D03->else_instructions;

                                             ir_variable *const r0D06 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r0D08 = equal(r0CF5, body.constant(int(64)));
                                             ir_if *f0D07 = new(mem_ctx) ir_if(operand(r0D08).val);
                                             exec_list *const f0D07_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D07->then_instructions;

                                                body.emit(assign(r0D06, r0C9F, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D07->else_instructions;

                                                ir_expression *const r0D09 = nequal(r0C9F, body.constant(0u));
                                                ir_expression *const r0D0A = expr(ir_unop_b2i, r0D09);
                                                body.emit(assign(r0D06, expr(ir_unop_i2u, r0D0A), 0x01));


                                             body.instructions = f0D07_parent_instructions;
                                             body.emit(f0D07);

                                             /* END IF */

                                             body.emit(assign(r0CF6, r0D06, 0x01));

                                             body.emit(assign(r0CF7, body.constant(0u), 0x01));


                                          body.instructions = f0D03_parent_instructions;
                                          body.emit(f0D03);

                                          /* END IF */


                                       body.instructions = f0D01_parent_instructions;
                                       body.emit(f0D01);

                                       /* END IF */

                                       body.emit(assign(r0CF8, body.constant(0u), 0x01));


                                    body.instructions = f0CFD_parent_instructions;
                                    body.emit(f0CFD);

                                    /* END IF */

                                    ir_expression *const r0D0B = nequal(r0CF4, body.constant(0u));
                                    ir_expression *const r0D0C = expr(ir_unop_b2i, r0D0B);
                                    ir_expression *const r0D0D = expr(ir_unop_i2u, r0D0C);
                                    body.emit(assign(r0CF6, bit_or(r0CF6, r0D0D), 0x01));


                                 body.instructions = f0CFB_parent_instructions;
                                 body.emit(f0CFB);

                                 /* END IF */

                                 body.emit(assign(r0CDE, r0CF8, 0x01));

                                 body.emit(assign(r0CDF, r0CF7, 0x01));

                                 body.emit(assign(r0CE0, r0CF6, 0x01));

                                 body.emit(assign(r0CDD, body.constant(int(0)), 0x01));

                                 body.emit(assign(r0CE3, less(r0CF6, body.constant(0u)), 0x01));


                              body.instructions = f0CF2_parent_instructions;
                              body.emit(f0CF2);

                              /* END IF */


                           body.instructions = f0CEF_parent_instructions;
                           body.emit(f0CEF);

                           /* END IF */


                        body.instructions = f0CE5_parent_instructions;
                        body.emit(f0CE5);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0D0E = new(mem_ctx) ir_if(operand(r0CE1).val);
                        exec_list *const f0D0E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D0E->then_instructions;

                           /* IF CONDITION */
                           ir_if *f0D0F = new(mem_ctx) ir_if(operand(r0CE3).val);
                           exec_list *const f0D0F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D0F->then_instructions;

                              ir_variable *const r0D10 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r0D10, add(r0CDF, body.constant(1u)), 0x01));

                              ir_expression *const r0D11 = less(r0D10, r0CDF);
                              ir_expression *const r0D12 = expr(ir_unop_b2i, r0D11);
                              ir_expression *const r0D13 = expr(ir_unop_i2u, r0D12);
                              body.emit(assign(r0CDE, add(r0CDE, r0D13), 0x01));

                              ir_expression *const r0D14 = equal(r0CE0, body.constant(0u));
                              ir_expression *const r0D15 = expr(ir_unop_b2i, r0D14);
                              ir_expression *const r0D16 = expr(ir_unop_i2u, r0D15);
                              ir_expression *const r0D17 = add(r0CE0, r0D16);
                              ir_expression *const r0D18 = bit_and(r0D17, body.constant(1u));
                              ir_expression *const r0D19 = expr(ir_unop_bit_not, r0D18);
                              body.emit(assign(r0CDF, bit_and(r0D10, r0D19), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D0F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0D1B = bit_or(r0CDE, r0CDF);
                              ir_expression *const r0D1C = equal(r0D1B, body.constant(0u));
                              ir_if *f0D1A = new(mem_ctx) ir_if(operand(r0D1C).val);
                              exec_list *const f0D1A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D1A->then_instructions;

                                 body.emit(assign(r0CDD, body.constant(int(0)), 0x01));


                              body.instructions = f0D1A_parent_instructions;
                              body.emit(f0D1A);

                              /* END IF */


                           body.instructions = f0D0F_parent_instructions;
                           body.emit(f0D0F);

                           /* END IF */

                           ir_variable *const r0D1D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0D1D);
                           ir_expression *const r0D1E = lshift(r0999, body.constant(int(31)));
                           ir_expression *const r0D1F = expr(ir_unop_i2u, r0CDD);
                           ir_expression *const r0D20 = lshift(r0D1F, body.constant(int(20)));
                           ir_expression *const r0D21 = add(r0D1E, r0D20);
                           body.emit(assign(r0D1D, add(r0D21, r0CDE), 0x02));

                           body.emit(assign(r0D1D, r0CDF, 0x01));

                           body.emit(assign(r0CE2, r0D1D, 0x03));

                           body.emit(assign(r0CE1, body.constant(false), 0x01));


                        body.instructions = f0D0E_parent_instructions;
                        body.emit(f0D0E);

                        /* END IF */

                        body.emit(assign(r099A, r0CE2, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C96->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0D23 = less(r09A1, r099F);
                        ir_if *f0D22 = new(mem_ctx) ir_if(operand(r0D23).val);
                        exec_list *const f0D22_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D22->then_instructions;

                           ir_variable *const r0D24 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r0D25 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0D25, sub(r099F, r09A1), 0x01));

                           ir_expression *const r0D26 = sub(r099E, r09A0);
                           ir_expression *const r0D27 = less(r099F, r09A1);
                           ir_expression *const r0D28 = expr(ir_unop_b2i, r0D27);
                           ir_expression *const r0D29 = expr(ir_unop_i2u, r0D28);
                           body.emit(assign(r0D24, sub(r0D26, r0D29), 0x01));

                           body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                           body.emit(assign(r09A2, add(r099C, body.constant(int(-1))), 0x01));

                           ir_variable *const r0D2A = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D2A, add(r09A2, body.constant(int(-10))), 0x01));

                           ir_variable *const r0D2B = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D2B, r0D24, 0x01));

                           ir_variable *const r0D2C = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D2C, r0D25, 0x01));

                           ir_variable *const r0D2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r0D2D);
                           ir_variable *const r0D2E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D2E);
                           /* IF CONDITION */
                           ir_expression *const r0D30 = equal(r0D24, body.constant(0u));
                           ir_if *f0D2F = new(mem_ctx) ir_if(operand(r0D30).val);
                           exec_list *const f0D2F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D2F->then_instructions;

                              body.emit(assign(r0D2B, r0D25, 0x01));

                              body.emit(assign(r0D2C, body.constant(0u), 0x01));

                              body.emit(assign(r0D2A, add(r0D2A, body.constant(int(-32))), 0x01));


                           body.instructions = f0D2F_parent_instructions;
                           body.emit(f0D2F);

                           /* END IF */

                           ir_variable *const r0D31 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r0D31, r0D2B, 0x01));

                           ir_variable *const r0D32 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r0D33 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D33);
                           /* IF CONDITION */
                           ir_expression *const r0D35 = equal(r0D2B, body.constant(0u));
                           ir_if *f0D34 = new(mem_ctx) ir_if(operand(r0D35).val);
                           exec_list *const f0D34_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D34->then_instructions;

                              body.emit(assign(r0D32, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D34->else_instructions;

                              body.emit(assign(r0D33, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D37 = bit_and(r0D2B, body.constant(4294901760u));
                              ir_expression *const r0D38 = equal(r0D37, body.constant(0u));
                              ir_if *f0D36 = new(mem_ctx) ir_if(operand(r0D38).val);
                              exec_list *const f0D36_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D36->then_instructions;

                                 body.emit(assign(r0D33, body.constant(int(16)), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D2B, body.constant(int(16))), 0x01));


                              body.instructions = f0D36_parent_instructions;
                              body.emit(f0D36);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3A = bit_and(r0D31, body.constant(4278190080u));
                              ir_expression *const r0D3B = equal(r0D3A, body.constant(0u));
                              ir_if *f0D39 = new(mem_ctx) ir_if(operand(r0D3B).val);
                              exec_list *const f0D39_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D39->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(8))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(8))), 0x01));


                              body.instructions = f0D39_parent_instructions;
                              body.emit(f0D39);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3D = bit_and(r0D31, body.constant(4026531840u));
                              ir_expression *const r0D3E = equal(r0D3D, body.constant(0u));
                              ir_if *f0D3C = new(mem_ctx) ir_if(operand(r0D3E).val);
                              exec_list *const f0D3C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3C->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(4))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(4))), 0x01));


                              body.instructions = f0D3C_parent_instructions;
                              body.emit(f0D3C);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D40 = bit_and(r0D31, body.constant(3221225472u));
                              ir_expression *const r0D41 = equal(r0D40, body.constant(0u));
                              ir_if *f0D3F = new(mem_ctx) ir_if(operand(r0D41).val);
                              exec_list *const f0D3F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3F->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(2))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(2))), 0x01));


                              body.instructions = f0D3F_parent_instructions;
                              body.emit(f0D3F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D43 = bit_and(r0D31, body.constant(2147483648u));
                              ir_expression *const r0D44 = equal(r0D43, body.constant(0u));
                              ir_if *f0D42 = new(mem_ctx) ir_if(operand(r0D44).val);
                              exec_list *const f0D42_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D42->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(1))), 0x01));


                              body.instructions = f0D42_parent_instructions;
                              body.emit(f0D42);

                              /* END IF */

                              body.emit(assign(r0D32, r0D33, 0x01));


                           body.instructions = f0D34_parent_instructions;
                           body.emit(f0D34);

                           /* END IF */

                           body.emit(assign(r0D2E, add(r0D32, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D46 = lequal(body.constant(int(0)), r0D2E);
                           ir_if *f0D45 = new(mem_ctx) ir_if(operand(r0D46).val);
                           exec_list *const f0D45_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D45->then_instructions;

                              body.emit(assign(r0D2D, body.constant(0u), 0x01));

                              ir_variable *const r0D47 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r0D47, lshift(r0D2C, r0D2E), 0x01));

                              ir_variable *const r0D48 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D4A = equal(r0D2E, body.constant(int(0)));
                              ir_if *f0D49 = new(mem_ctx) ir_if(operand(r0D4A).val);
                              exec_list *const f0D49_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D49->then_instructions;

                                 body.emit(assign(r0D48, r0D2B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D49->else_instructions;

                                 ir_expression *const r0D4B = lshift(r0D2B, r0D2E);
                                 ir_expression *const r0D4C = neg(r0D2E);
                                 ir_expression *const r0D4D = bit_and(r0D4C, body.constant(int(31)));
                                 ir_expression *const r0D4E = rshift(r0D2C, r0D4D);
                                 body.emit(assign(r0D48, bit_or(r0D4B, r0D4E), 0x01));


                              body.instructions = f0D49_parent_instructions;
                              body.emit(f0D49);

                              /* END IF */

                              body.emit(assign(r0D2B, r0D48, 0x01));

                              body.emit(assign(r0D2C, r0D47, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D45->else_instructions;

                              ir_variable *const r0D4F = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0D4F, body.constant(0u), 0x01));

                              ir_variable *const r0D50 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0D50, neg(r0D2E), 0x01));

                              ir_variable *const r0D51 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0D51);
                              ir_variable *const r0D52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0D52);
                              ir_variable *const r0D53 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0D53);
                              ir_variable *const r0D54 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0D55 = neg(r0D50);
                              body.emit(assign(r0D54, bit_and(r0D55, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D57 = equal(r0D50, body.constant(int(0)));
                              ir_if *f0D56 = new(mem_ctx) ir_if(operand(r0D57).val);
                              exec_list *const f0D56_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D56->then_instructions;

                                 body.emit(assign(r0D51, r0D4F, 0x01));

                                 body.emit(assign(r0D52, r0D2C, 0x01));

                                 body.emit(assign(r0D53, r0D2B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D56->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D59 = less(r0D50, body.constant(int(32)));
                                 ir_if *f0D58 = new(mem_ctx) ir_if(operand(r0D59).val);
                                 exec_list *const f0D58_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D58->then_instructions;

                                    body.emit(assign(r0D51, lshift(r0D2C, r0D54), 0x01));

                                    ir_expression *const r0D5A = lshift(r0D2B, r0D54);
                                    ir_expression *const r0D5B = rshift(r0D2C, r0D50);
                                    body.emit(assign(r0D52, bit_or(r0D5A, r0D5B), 0x01));

                                    body.emit(assign(r0D53, rshift(r0D2B, r0D50), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D58->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0D5D = equal(r0D50, body.constant(int(32)));
                                    ir_if *f0D5C = new(mem_ctx) ir_if(operand(r0D5D).val);
                                    exec_list *const f0D5C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D5C->then_instructions;

                                       body.emit(assign(r0D51, r0D2C, 0x01));

                                       body.emit(assign(r0D52, r0D2B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D5C->else_instructions;

                                       body.emit(assign(r0D4F, bit_or(body.constant(0u), r0D2C), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0D5F = less(r0D50, body.constant(int(64)));
                                       ir_if *f0D5E = new(mem_ctx) ir_if(operand(r0D5F).val);
                                       exec_list *const f0D5E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D5E->then_instructions;

                                          body.emit(assign(r0D51, lshift(r0D2B, r0D54), 0x01));

                                          ir_expression *const r0D60 = bit_and(r0D50, body.constant(int(31)));
                                          body.emit(assign(r0D52, rshift(r0D2B, r0D60), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D5E->else_instructions;

                                          ir_variable *const r0D61 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0D63 = equal(r0D50, body.constant(int(64)));
                                          ir_if *f0D62 = new(mem_ctx) ir_if(operand(r0D63).val);
                                          exec_list *const f0D62_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D62->then_instructions;

                                             body.emit(assign(r0D61, r0D2B, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D62->else_instructions;

                                             ir_expression *const r0D64 = nequal(r0D2B, body.constant(0u));
                                             ir_expression *const r0D65 = expr(ir_unop_b2i, r0D64);
                                             body.emit(assign(r0D61, expr(ir_unop_i2u, r0D65), 0x01));


                                          body.instructions = f0D62_parent_instructions;
                                          body.emit(f0D62);

                                          /* END IF */

                                          body.emit(assign(r0D51, r0D61, 0x01));

                                          body.emit(assign(r0D52, body.constant(0u), 0x01));


                                       body.instructions = f0D5E_parent_instructions;
                                       body.emit(f0D5E);

                                       /* END IF */


                                    body.instructions = f0D5C_parent_instructions;
                                    body.emit(f0D5C);

                                    /* END IF */

                                    body.emit(assign(r0D53, body.constant(0u), 0x01));


                                 body.instructions = f0D58_parent_instructions;
                                 body.emit(f0D58);

                                 /* END IF */

                                 ir_expression *const r0D66 = nequal(r0D4F, body.constant(0u));
                                 ir_expression *const r0D67 = expr(ir_unop_b2i, r0D66);
                                 ir_expression *const r0D68 = expr(ir_unop_i2u, r0D67);
                                 body.emit(assign(r0D51, bit_or(r0D51, r0D68), 0x01));


                              body.instructions = f0D56_parent_instructions;
                              body.emit(f0D56);

                              /* END IF */

                              body.emit(assign(r0D2B, r0D53, 0x01));

                              body.emit(assign(r0D2C, r0D52, 0x01));

                              body.emit(assign(r0D2D, r0D51, 0x01));


                           body.instructions = f0D45_parent_instructions;
                           body.emit(f0D45);

                           /* END IF */

                           body.emit(assign(r0D2A, sub(r0D2A, r0D2E), 0x01));

                           ir_variable *const r0D69 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D69, r0D2A, 0x01));

                           ir_variable *const r0D6A = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D6A, r0D2B, 0x01));

                           ir_variable *const r0D6B = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D6B, r0D2C, 0x01));

                           ir_variable *const r0D6C = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r0D6C, r0D2D, 0x01));

                           ir_variable *const r0D6D = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r0D6D, body.constant(true), 0x01));

                           ir_variable *const r0D6E = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r0D6F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r0D6F);
                           ir_expression *const r0D70 = expr(ir_unop_u2i, r0D2D);
                           body.emit(assign(r0D6F, less(r0D70, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D72 = lequal(body.constant(int(2045)), r0D2A);
                           ir_if *f0D71 = new(mem_ctx) ir_if(operand(r0D72).val);
                           exec_list *const f0D71_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D71->then_instructions;

                              ir_variable *const r0D73 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D75 = less(body.constant(int(2045)), r0D2A);
                              ir_if *f0D74 = new(mem_ctx) ir_if(operand(r0D75).val);
                              exec_list *const f0D74_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D74->then_instructions;

                                 body.emit(assign(r0D73, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D74->else_instructions;

                                 ir_variable *const r0D76 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0D78 = equal(r0D2A, body.constant(int(2045)));
                                 ir_if *f0D77 = new(mem_ctx) ir_if(operand(r0D78).val);
                                 exec_list *const f0D77_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D77->then_instructions;

                                    ir_expression *const r0D79 = equal(body.constant(2097151u), r0D2B);
                                    ir_expression *const r0D7A = equal(body.constant(4294967295u), r0D2C);
                                    body.emit(assign(r0D76, logic_and(r0D79, r0D7A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D77->else_instructions;

                                    body.emit(assign(r0D76, body.constant(false), 0x01));


                                 body.instructions = f0D77_parent_instructions;
                                 body.emit(f0D77);

                                 /* END IF */

                                 body.emit(assign(r0D73, logic_and(r0D76, r0D6F), 0x01));


                              body.instructions = f0D74_parent_instructions;
                              body.emit(f0D74);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f0D7B = new(mem_ctx) ir_if(operand(r0D73).val);
                              exec_list *const f0D7B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D7B->then_instructions;

                                 ir_variable *const r0D7C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r0D7C);
                                 ir_expression *const r0D7D = lshift(r0999, body.constant(int(31)));
                                 body.emit(assign(r0D7C, add(r0D7D, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r0D7C, body.constant(0u), 0x01));

                                 body.emit(assign(r0D6E, r0D7C, 0x03));

                                 body.emit(assign(r0D6D, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D7B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D7F = less(r0D2A, body.constant(int(0)));
                                 ir_if *f0D7E = new(mem_ctx) ir_if(operand(r0D7F).val);
                                 exec_list *const f0D7E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D7E->then_instructions;

                                    ir_variable *const r0D80 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r0D80, r0D2D, 0x01));

                                    ir_variable *const r0D81 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r0D81, neg(r0D2A), 0x01));

                                    ir_variable *const r0D82 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r0D82);
                                    ir_variable *const r0D83 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r0D83);
                                    ir_variable *const r0D84 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r0D84);
                                    ir_variable *const r0D85 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r0D86 = neg(r0D81);
                                    body.emit(assign(r0D85, bit_and(r0D86, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0D88 = equal(r0D81, body.constant(int(0)));
                                    ir_if *f0D87 = new(mem_ctx) ir_if(operand(r0D88).val);
                                    exec_list *const f0D87_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D87->then_instructions;

                                       body.emit(assign(r0D82, r0D2D, 0x01));

                                       body.emit(assign(r0D83, r0D2C, 0x01));

                                       body.emit(assign(r0D84, r0D2B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D87->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D8A = less(r0D81, body.constant(int(32)));
                                       ir_if *f0D89 = new(mem_ctx) ir_if(operand(r0D8A).val);
                                       exec_list *const f0D89_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D89->then_instructions;

                                          body.emit(assign(r0D82, lshift(r0D2C, r0D85), 0x01));

                                          ir_expression *const r0D8B = lshift(r0D2B, r0D85);
                                          ir_expression *const r0D8C = rshift(r0D2C, r0D81);
                                          body.emit(assign(r0D83, bit_or(r0D8B, r0D8C), 0x01));

                                          body.emit(assign(r0D84, rshift(r0D2B, r0D81), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D89->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r0D8E = equal(r0D81, body.constant(int(32)));
                                          ir_if *f0D8D = new(mem_ctx) ir_if(operand(r0D8E).val);
                                          exec_list *const f0D8D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D8D->then_instructions;

                                             body.emit(assign(r0D82, r0D2C, 0x01));

                                             body.emit(assign(r0D83, r0D2B, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D8D->else_instructions;

                                             body.emit(assign(r0D80, bit_or(r0D2D, r0D2C), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r0D90 = less(r0D81, body.constant(int(64)));
                                             ir_if *f0D8F = new(mem_ctx) ir_if(operand(r0D90).val);
                                             exec_list *const f0D8F_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D8F->then_instructions;

                                                body.emit(assign(r0D82, lshift(r0D2B, r0D85), 0x01));

                                                ir_expression *const r0D91 = bit_and(r0D81, body.constant(int(31)));
                                                body.emit(assign(r0D83, rshift(r0D2B, r0D91), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D8F->else_instructions;

                                                ir_variable *const r0D92 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r0D94 = equal(r0D81, body.constant(int(64)));
                                                ir_if *f0D93 = new(mem_ctx) ir_if(operand(r0D94).val);
                                                exec_list *const f0D93_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f0D93->then_instructions;

                                                   body.emit(assign(r0D92, r0D2B, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f0D93->else_instructions;

                                                   ir_expression *const r0D95 = nequal(r0D2B, body.constant(0u));
                                                   ir_expression *const r0D96 = expr(ir_unop_b2i, r0D95);
                                                   body.emit(assign(r0D92, expr(ir_unop_i2u, r0D96), 0x01));


                                                body.instructions = f0D93_parent_instructions;
                                                body.emit(f0D93);

                                                /* END IF */

                                                body.emit(assign(r0D82, r0D92, 0x01));

                                                body.emit(assign(r0D83, body.constant(0u), 0x01));


                                             body.instructions = f0D8F_parent_instructions;
                                             body.emit(f0D8F);

                                             /* END IF */


                                          body.instructions = f0D8D_parent_instructions;
                                          body.emit(f0D8D);

                                          /* END IF */

                                          body.emit(assign(r0D84, body.constant(0u), 0x01));


                                       body.instructions = f0D89_parent_instructions;
                                       body.emit(f0D89);

                                       /* END IF */

                                       ir_expression *const r0D97 = nequal(r0D80, body.constant(0u));
                                       ir_expression *const r0D98 = expr(ir_unop_b2i, r0D97);
                                       ir_expression *const r0D99 = expr(ir_unop_i2u, r0D98);
                                       body.emit(assign(r0D82, bit_or(r0D82, r0D99), 0x01));


                                    body.instructions = f0D87_parent_instructions;
                                    body.emit(f0D87);

                                    /* END IF */

                                    body.emit(assign(r0D6A, r0D84, 0x01));

                                    body.emit(assign(r0D6B, r0D83, 0x01));

                                    body.emit(assign(r0D6C, r0D82, 0x01));

                                    body.emit(assign(r0D69, body.constant(int(0)), 0x01));

                                    body.emit(assign(r0D6F, less(r0D82, body.constant(0u)), 0x01));


                                 body.instructions = f0D7E_parent_instructions;
                                 body.emit(f0D7E);

                                 /* END IF */


                              body.instructions = f0D7B_parent_instructions;
                              body.emit(f0D7B);

                              /* END IF */


                           body.instructions = f0D71_parent_instructions;
                           body.emit(f0D71);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0D9A = new(mem_ctx) ir_if(operand(r0D6D).val);
                           exec_list *const f0D9A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D9A->then_instructions;

                              /* IF CONDITION */
                              ir_if *f0D9B = new(mem_ctx) ir_if(operand(r0D6F).val);
                              exec_list *const f0D9B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D9B->then_instructions;

                                 ir_variable *const r0D9C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r0D9C, add(r0D6B, body.constant(1u)), 0x01));

                                 ir_expression *const r0D9D = less(r0D9C, r0D6B);
                                 ir_expression *const r0D9E = expr(ir_unop_b2i, r0D9D);
                                 ir_expression *const r0D9F = expr(ir_unop_i2u, r0D9E);
                                 body.emit(assign(r0D6A, add(r0D6A, r0D9F), 0x01));

                                 ir_expression *const r0DA0 = equal(r0D6C, body.constant(0u));
                                 ir_expression *const r0DA1 = expr(ir_unop_b2i, r0DA0);
                                 ir_expression *const r0DA2 = expr(ir_unop_i2u, r0DA1);
                                 ir_expression *const r0DA3 = add(r0D6C, r0DA2);
                                 ir_expression *const r0DA4 = bit_and(r0DA3, body.constant(1u));
                                 ir_expression *const r0DA5 = expr(ir_unop_bit_not, r0DA4);
                                 body.emit(assign(r0D6B, bit_and(r0D9C, r0DA5), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D9B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0DA7 = bit_or(r0D6A, r0D6B);
                                 ir_expression *const r0DA8 = equal(r0DA7, body.constant(0u));
                                 ir_if *f0DA6 = new(mem_ctx) ir_if(operand(r0DA8).val);
                                 exec_list *const f0DA6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0DA6->then_instructions;

                                    body.emit(assign(r0D69, body.constant(int(0)), 0x01));


                                 body.instructions = f0DA6_parent_instructions;
                                 body.emit(f0DA6);

                                 /* END IF */


                              body.instructions = f0D9B_parent_instructions;
                              body.emit(f0D9B);

                              /* END IF */

                              ir_variable *const r0DA9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0DA9);
                              ir_expression *const r0DAA = lshift(r0999, body.constant(int(31)));
                              ir_expression *const r0DAB = expr(ir_unop_i2u, r0D69);
                              ir_expression *const r0DAC = lshift(r0DAB, body.constant(int(20)));
                              ir_expression *const r0DAD = add(r0DAA, r0DAC);
                              body.emit(assign(r0DA9, add(r0DAD, r0D6A), 0x02));

                              body.emit(assign(r0DA9, r0D6B, 0x01));

                              body.emit(assign(r0D6E, r0DA9, 0x03));

                              body.emit(assign(r0D6D, body.constant(false), 0x01));


                           body.instructions = f0D9A_parent_instructions;
                           body.emit(f0D9A);

                           /* END IF */

                           body.emit(assign(r099A, r0D6E, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0D22->else_instructions;

                           ir_variable *const r0DAE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0DAE);
                           body.emit(assign(r0DAE, body.constant(0u), 0x02));

                           body.emit(assign(r0DAE, body.constant(0u), 0x01));

                           body.emit(assign(r099A, r0DAE, 0x03));


                        body.instructions = f0D22_parent_instructions;
                        body.emit(f0D22);

                        /* END IF */


                     body.instructions = f0C96_parent_instructions;
                     body.emit(f0C96);

                     /* END IF */


                  body.instructions = f0C0A_parent_instructions;
                  body.emit(f0C0A);

                  /* END IF */


               body.instructions = f0B7E_parent_instructions;
               body.emit(f0B7E);

               /* END IF */


            body.instructions = f0B57_parent_instructions;
            body.emit(f0B57);

            /* END IF */


         body.instructions = f0A83_parent_instructions;
         body.emit(f0A83);

         /* END IF */


      body.instructions = f09B3_parent_instructions;
      body.emit(f09B3);

      /* END IF */

      body.emit(assign(r07EB, r099A, 0x03));


   body.instructions = f07EE_parent_instructions;
   body.emit(f07EE);

   /* END IF */

   body.emit(ret(r07EB));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0DAF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0DAF);
   ir_variable *const r0DB0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0DB0);
   ir_variable *const r0DB1 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0DB2 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r0DB2, rshift(swizzle_y(r0DAF), body.constant(int(31))), 0x01));

   ir_variable *const r0DB3 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r0DB3, rshift(swizzle_y(r0DB0), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0DB5 = equal(r0DB2, r0DB3);
   ir_if *f0DB4 = new(mem_ctx) ir_if(operand(r0DB5).val);
   exec_list *const f0DB4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0DB4->then_instructions;

      ir_variable *const r0DB6 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0DB6, r0DB2, 0x01));

      ir_variable *const r0DB7 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r0DB8 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r0DB8);
      ir_variable *const r0DB9 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r0DB9);
      ir_variable *const r0DBA = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r0DBA);
      ir_variable *const r0DBB = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r0DBB);
      ir_variable *const r0DBC = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r0DBC);
      ir_variable *const r0DBD = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r0DBD);
      ir_variable *const r0DBE = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r0DBE);
      ir_variable *const r0DBF = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r0DBF);
      ir_variable *const r0DC0 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0DC1 = rshift(swizzle_y(r0DAF), body.constant(int(20)));
      ir_expression *const r0DC2 = bit_and(r0DC1, body.constant(2047u));
      body.emit(assign(r0DC0, expr(ir_unop_u2i, r0DC2), 0x01));

      body.emit(assign(r0DBA, r0DC0, 0x01));

      ir_variable *const r0DC3 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0DC4 = rshift(swizzle_y(r0DB0), body.constant(int(20)));
      ir_expression *const r0DC5 = bit_and(r0DC4, body.constant(2047u));
      body.emit(assign(r0DC3, expr(ir_unop_u2i, r0DC5), 0x01));

      body.emit(assign(r0DB9, r0DC3, 0x01));

      body.emit(assign(r0DB8, sub(r0DC0, r0DC3), 0x01));

      ir_variable *const r0DC6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0DC6, lshift(swizzle_x(r0DAF), body.constant(int(10))), 0x01));

      ir_variable *const r0DC7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r0DC8 = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
      ir_expression *const r0DC9 = lshift(r0DC8, body.constant(int(10)));
      ir_expression *const r0DCA = rshift(swizzle_x(r0DAF), body.constant(int(22)));
      body.emit(assign(r0DC7, bit_or(r0DC9, r0DCA), 0x01));

      body.emit(assign(r0DBD, r0DC7, 0x01));

      body.emit(assign(r0DBE, r0DC6, 0x01));

      ir_variable *const r0DCB = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0DCB, lshift(swizzle_x(r0DB0), body.constant(int(10))), 0x01));

      ir_variable *const r0DCC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r0DCD = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
      ir_expression *const r0DCE = lshift(r0DCD, body.constant(int(10)));
      ir_expression *const r0DCF = rshift(swizzle_x(r0DB0), body.constant(int(22)));
      body.emit(assign(r0DCC, bit_or(r0DCE, r0DCF), 0x01));

      body.emit(assign(r0DBB, r0DCC, 0x01));

      body.emit(assign(r0DBC, r0DCB, 0x01));

      /* IF CONDITION */
      ir_expression *const r0DD1 = less(body.constant(int(0)), r0DB8);
      ir_if *f0DD0 = new(mem_ctx) ir_if(operand(r0DD1).val);
      exec_list *const f0DD0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0DD0->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0DD3 = equal(r0DC0, body.constant(int(2047)));
         ir_if *f0DD2 = new(mem_ctx) ir_if(operand(r0DD3).val);
         exec_list *const f0DD2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0DD2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0DD5 = bit_or(r0DC7, r0DC6);
            ir_expression *const r0DD6 = nequal(r0DD5, body.constant(0u));
            ir_if *f0DD4 = new(mem_ctx) ir_if(operand(r0DD6).val);
            exec_list *const f0DD4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DD4->then_instructions;

               ir_variable *const r0DD7 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0DD7, swizzle_x(r0DAF), 0x01));

               ir_variable *const r0DD8 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0DD8, swizzle_x(r0DB0), 0x01));

               ir_variable *const r0DD9 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0DDA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0DDB = rshift(swizzle_y(r0DAF), body.constant(int(19)));
               ir_expression *const r0DDC = bit_and(r0DDB, body.constant(4095u));
               ir_expression *const r0DDD = equal(r0DDC, body.constant(4094u));
               ir_expression *const r0DDE = nequal(swizzle_x(r0DAF), body.constant(0u));
               ir_expression *const r0DDF = bit_and(swizzle_y(r0DAF), body.constant(524287u));
               ir_expression *const r0DE0 = nequal(r0DDF, body.constant(0u));
               ir_expression *const r0DE1 = logic_or(r0DDE, r0DE0);
               body.emit(assign(r0DDA, logic_and(r0DDD, r0DE1), 0x01));

               ir_variable *const r0DE2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0DE3 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
               ir_expression *const r0DE4 = lequal(body.constant(4292870144u), r0DE3);
               ir_expression *const r0DE5 = nequal(swizzle_x(r0DB0), body.constant(0u));
               ir_expression *const r0DE6 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
               ir_expression *const r0DE7 = nequal(r0DE6, body.constant(0u));
               ir_expression *const r0DE8 = logic_or(r0DE5, r0DE7);
               body.emit(assign(r0DE2, logic_and(r0DE4, r0DE8), 0x01));

               body.emit(assign(r0DD7, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

               body.emit(assign(r0DD8, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0DEA = lshift(swizzle_y(r0DAF), body.constant(int(1)));
               ir_expression *const r0DEB = lequal(body.constant(4292870144u), r0DEA);
               ir_expression *const r0DEC = nequal(swizzle_x(r0DAF), body.constant(0u));
               ir_expression *const r0DED = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
               ir_expression *const r0DEE = nequal(r0DED, body.constant(0u));
               ir_expression *const r0DEF = logic_or(r0DEC, r0DEE);
               ir_expression *const r0DF0 = logic_and(r0DEB, r0DEF);
               ir_if *f0DE9 = new(mem_ctx) ir_if(operand(r0DF0).val);
               exec_list *const f0DE9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0DE9->then_instructions;

                  ir_variable *const r0DF1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0DF3 = logic_and(r0DDA, r0DE2);
                  ir_if *f0DF2 = new(mem_ctx) ir_if(operand(r0DF3).val);
                  exec_list *const f0DF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0DF2->then_instructions;

                     body.emit(assign(r0DF1, r0DD8, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0DF2->else_instructions;

                     body.emit(assign(r0DF1, r0DD7, 0x03));


                  body.instructions = f0DF2_parent_instructions;
                  body.emit(f0DF2);

                  /* END IF */

                  body.emit(assign(r0DD9, r0DF1, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0DE9->else_instructions;

                  body.emit(assign(r0DD9, r0DD8, 0x03));


               body.instructions = f0DE9_parent_instructions;
               body.emit(f0DE9);

               /* END IF */

               body.emit(assign(r0DB7, r0DD9, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DD4->else_instructions;

               body.emit(assign(r0DB7, r0DAF, 0x03));


            body.instructions = f0DD4_parent_instructions;
            body.emit(f0DD4);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0DD2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0DF5 = equal(r0DC3, body.constant(int(0)));
            ir_if *f0DF4 = new(mem_ctx) ir_if(operand(r0DF5).val);
            exec_list *const f0DF4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DF4->then_instructions;

               body.emit(assign(r0DB8, add(r0DB8, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DF4->else_instructions;

               body.emit(assign(r0DBB, bit_or(r0DCC, body.constant(1073741824u)), 0x01));


            body.instructions = f0DF4_parent_instructions;
            body.emit(f0DF4);

            /* END IF */

            ir_variable *const r0DF6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0DF6);
            ir_variable *const r0DF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0DF7);
            ir_variable *const r0DF8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0DF9 = neg(r0DB8);
            body.emit(assign(r0DF8, bit_and(r0DF9, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0DFB = equal(r0DB8, body.constant(int(0)));
            ir_if *f0DFA = new(mem_ctx) ir_if(operand(r0DFB).val);
            exec_list *const f0DFA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DFA->then_instructions;

               body.emit(assign(r0DF6, r0DCB, 0x01));

               body.emit(assign(r0DF7, r0DBB, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DFA->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0DFD = less(r0DB8, body.constant(int(32)));
               ir_if *f0DFC = new(mem_ctx) ir_if(operand(r0DFD).val);
               exec_list *const f0DFC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0DFC->then_instructions;

                  ir_expression *const r0DFE = lshift(r0DBB, r0DF8);
                  ir_expression *const r0DFF = rshift(r0DCB, r0DB8);
                  ir_expression *const r0E00 = bit_or(r0DFE, r0DFF);
                  ir_expression *const r0E01 = lshift(r0DCB, r0DF8);
                  ir_expression *const r0E02 = nequal(r0E01, body.constant(0u));
                  ir_expression *const r0E03 = expr(ir_unop_b2i, r0E02);
                  ir_expression *const r0E04 = expr(ir_unop_i2u, r0E03);
                  body.emit(assign(r0DF6, bit_or(r0E00, r0E04), 0x01));

                  body.emit(assign(r0DF7, rshift(r0DBB, r0DB8), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0DFC->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E06 = equal(r0DB8, body.constant(int(32)));
                  ir_if *f0E05 = new(mem_ctx) ir_if(operand(r0E06).val);
                  exec_list *const f0E05_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E05->then_instructions;

                     ir_expression *const r0E07 = nequal(r0DCB, body.constant(0u));
                     ir_expression *const r0E08 = expr(ir_unop_b2i, r0E07);
                     ir_expression *const r0E09 = expr(ir_unop_i2u, r0E08);
                     body.emit(assign(r0DF6, bit_or(r0DBB, r0E09), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E05->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0E0B = less(r0DB8, body.constant(int(64)));
                     ir_if *f0E0A = new(mem_ctx) ir_if(operand(r0E0B).val);
                     exec_list *const f0E0A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E0A->then_instructions;

                        ir_expression *const r0E0C = bit_and(r0DB8, body.constant(int(31)));
                        ir_expression *const r0E0D = rshift(r0DBB, r0E0C);
                        ir_expression *const r0E0E = lshift(r0DBB, r0DF8);
                        ir_expression *const r0E0F = bit_or(r0E0E, r0DCB);
                        ir_expression *const r0E10 = nequal(r0E0F, body.constant(0u));
                        ir_expression *const r0E11 = expr(ir_unop_b2i, r0E10);
                        ir_expression *const r0E12 = expr(ir_unop_i2u, r0E11);
                        body.emit(assign(r0DF6, bit_or(r0E0D, r0E12), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E0A->else_instructions;

                        ir_expression *const r0E13 = bit_or(r0DBB, r0DCB);
                        ir_expression *const r0E14 = nequal(r0E13, body.constant(0u));
                        ir_expression *const r0E15 = expr(ir_unop_b2i, r0E14);
                        body.emit(assign(r0DF6, expr(ir_unop_i2u, r0E15), 0x01));


                     body.instructions = f0E0A_parent_instructions;
                     body.emit(f0E0A);

                     /* END IF */


                  body.instructions = f0E05_parent_instructions;
                  body.emit(f0E05);

                  /* END IF */

                  body.emit(assign(r0DF7, body.constant(0u), 0x01));


               body.instructions = f0DFC_parent_instructions;
               body.emit(f0DFC);

               /* END IF */


            body.instructions = f0DFA_parent_instructions;
            body.emit(f0DFA);

            /* END IF */

            body.emit(assign(r0DBB, r0DF7, 0x01));

            body.emit(assign(r0DBC, r0DF6, 0x01));

            body.emit(assign(r0DBD, bit_or(r0DC7, body.constant(1073741824u)), 0x01));

            ir_variable *const r0E16 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0E17 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0E17, sub(r0DC6, r0DF6), 0x01));

            ir_expression *const r0E18 = sub(r0DBD, r0DF7);
            ir_expression *const r0E19 = less(r0DC6, r0DF6);
            ir_expression *const r0E1A = expr(ir_unop_b2i, r0E19);
            ir_expression *const r0E1B = expr(ir_unop_i2u, r0E1A);
            body.emit(assign(r0E16, sub(r0E18, r0E1B), 0x01));

            body.emit(assign(r0DBF, add(r0DC0, body.constant(int(-1))), 0x01));

            ir_variable *const r0E1C = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0E1C, add(r0DBF, body.constant(int(-10))), 0x01));

            ir_variable *const r0E1D = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0E1D, r0E16, 0x01));

            ir_variable *const r0E1E = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0E1E, r0E17, 0x01));

            ir_variable *const r0E1F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0E1F);
            ir_variable *const r0E20 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0E20);
            /* IF CONDITION */
            ir_expression *const r0E22 = equal(r0E16, body.constant(0u));
            ir_if *f0E21 = new(mem_ctx) ir_if(operand(r0E22).val);
            exec_list *const f0E21_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E21->then_instructions;

               body.emit(assign(r0E1D, r0E17, 0x01));

               body.emit(assign(r0E1E, body.constant(0u), 0x01));

               body.emit(assign(r0E1C, add(r0E1C, body.constant(int(-32))), 0x01));


            body.instructions = f0E21_parent_instructions;
            body.emit(f0E21);

            /* END IF */

            ir_variable *const r0E23 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0E23, r0E1D, 0x01));

            ir_variable *const r0E24 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0E25 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0E25);
            /* IF CONDITION */
            ir_expression *const r0E27 = equal(r0E1D, body.constant(0u));
            ir_if *f0E26 = new(mem_ctx) ir_if(operand(r0E27).val);
            exec_list *const f0E26_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E26->then_instructions;

               body.emit(assign(r0E24, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0E26->else_instructions;

               body.emit(assign(r0E25, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0E29 = bit_and(r0E1D, body.constant(4294901760u));
               ir_expression *const r0E2A = equal(r0E29, body.constant(0u));
               ir_if *f0E28 = new(mem_ctx) ir_if(operand(r0E2A).val);
               exec_list *const f0E28_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E28->then_instructions;

                  body.emit(assign(r0E25, body.constant(int(16)), 0x01));

                  body.emit(assign(r0E23, lshift(r0E1D, body.constant(int(16))), 0x01));


               body.instructions = f0E28_parent_instructions;
               body.emit(f0E28);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E2C = bit_and(r0E23, body.constant(4278190080u));
               ir_expression *const r0E2D = equal(r0E2C, body.constant(0u));
               ir_if *f0E2B = new(mem_ctx) ir_if(operand(r0E2D).val);
               exec_list *const f0E2B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E2B->then_instructions;

                  body.emit(assign(r0E25, add(r0E25, body.constant(int(8))), 0x01));

                  body.emit(assign(r0E23, lshift(r0E23, body.constant(int(8))), 0x01));


               body.instructions = f0E2B_parent_instructions;
               body.emit(f0E2B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E2F = bit_and(r0E23, body.constant(4026531840u));
               ir_expression *const r0E30 = equal(r0E2F, body.constant(0u));
               ir_if *f0E2E = new(mem_ctx) ir_if(operand(r0E30).val);
               exec_list *const f0E2E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E2E->then_instructions;

                  body.emit(assign(r0E25, add(r0E25, body.constant(int(4))), 0x01));

                  body.emit(assign(r0E23, lshift(r0E23, body.constant(int(4))), 0x01));


               body.instructions = f0E2E_parent_instructions;
               body.emit(f0E2E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E32 = bit_and(r0E23, body.constant(3221225472u));
               ir_expression *const r0E33 = equal(r0E32, body.constant(0u));
               ir_if *f0E31 = new(mem_ctx) ir_if(operand(r0E33).val);
               exec_list *const f0E31_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E31->then_instructions;

                  body.emit(assign(r0E25, add(r0E25, body.constant(int(2))), 0x01));

                  body.emit(assign(r0E23, lshift(r0E23, body.constant(int(2))), 0x01));


               body.instructions = f0E31_parent_instructions;
               body.emit(f0E31);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E35 = bit_and(r0E23, body.constant(2147483648u));
               ir_expression *const r0E36 = equal(r0E35, body.constant(0u));
               ir_if *f0E34 = new(mem_ctx) ir_if(operand(r0E36).val);
               exec_list *const f0E34_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E34->then_instructions;

                  body.emit(assign(r0E25, add(r0E25, body.constant(int(1))), 0x01));


               body.instructions = f0E34_parent_instructions;
               body.emit(f0E34);

               /* END IF */

               body.emit(assign(r0E24, r0E25, 0x01));


            body.instructions = f0E26_parent_instructions;
            body.emit(f0E26);

            /* END IF */

            body.emit(assign(r0E20, add(r0E24, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0E38 = lequal(body.constant(int(0)), r0E20);
            ir_if *f0E37 = new(mem_ctx) ir_if(operand(r0E38).val);
            exec_list *const f0E37_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E37->then_instructions;

               body.emit(assign(r0E1F, body.constant(0u), 0x01));

               ir_variable *const r0E39 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0E39, lshift(r0E1E, r0E20), 0x01));

               ir_variable *const r0E3A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0E3C = equal(r0E20, body.constant(int(0)));
               ir_if *f0E3B = new(mem_ctx) ir_if(operand(r0E3C).val);
               exec_list *const f0E3B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E3B->then_instructions;

                  body.emit(assign(r0E3A, r0E1D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E3B->else_instructions;

                  ir_expression *const r0E3D = lshift(r0E1D, r0E20);
                  ir_expression *const r0E3E = neg(r0E20);
                  ir_expression *const r0E3F = bit_and(r0E3E, body.constant(int(31)));
                  ir_expression *const r0E40 = rshift(r0E1E, r0E3F);
                  body.emit(assign(r0E3A, bit_or(r0E3D, r0E40), 0x01));


               body.instructions = f0E3B_parent_instructions;
               body.emit(f0E3B);

               /* END IF */

               body.emit(assign(r0E1D, r0E3A, 0x01));

               body.emit(assign(r0E1E, r0E39, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0E37->else_instructions;

               ir_variable *const r0E41 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0E41, body.constant(0u), 0x01));

               ir_variable *const r0E42 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0E42, neg(r0E20), 0x01));

               ir_variable *const r0E43 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0E43);
               ir_variable *const r0E44 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0E44);
               ir_variable *const r0E45 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0E45);
               ir_variable *const r0E46 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0E47 = neg(r0E42);
               body.emit(assign(r0E46, bit_and(r0E47, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0E49 = equal(r0E42, body.constant(int(0)));
               ir_if *f0E48 = new(mem_ctx) ir_if(operand(r0E49).val);
               exec_list *const f0E48_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E48->then_instructions;

                  body.emit(assign(r0E43, r0E41, 0x01));

                  body.emit(assign(r0E44, r0E1E, 0x01));

                  body.emit(assign(r0E45, r0E1D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E48->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E4B = less(r0E42, body.constant(int(32)));
                  ir_if *f0E4A = new(mem_ctx) ir_if(operand(r0E4B).val);
                  exec_list *const f0E4A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E4A->then_instructions;

                     body.emit(assign(r0E43, lshift(r0E1E, r0E46), 0x01));

                     ir_expression *const r0E4C = lshift(r0E1D, r0E46);
                     ir_expression *const r0E4D = rshift(r0E1E, r0E42);
                     body.emit(assign(r0E44, bit_or(r0E4C, r0E4D), 0x01));

                     body.emit(assign(r0E45, rshift(r0E1D, r0E42), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E4A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0E4F = equal(r0E42, body.constant(int(32)));
                     ir_if *f0E4E = new(mem_ctx) ir_if(operand(r0E4F).val);
                     exec_list *const f0E4E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E4E->then_instructions;

                        body.emit(assign(r0E43, r0E1E, 0x01));

                        body.emit(assign(r0E44, r0E1D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E4E->else_instructions;

                        body.emit(assign(r0E41, bit_or(body.constant(0u), r0E1E), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0E51 = less(r0E42, body.constant(int(64)));
                        ir_if *f0E50 = new(mem_ctx) ir_if(operand(r0E51).val);
                        exec_list *const f0E50_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0E50->then_instructions;

                           body.emit(assign(r0E43, lshift(r0E1D, r0E46), 0x01));

                           ir_expression *const r0E52 = bit_and(r0E42, body.constant(int(31)));
                           body.emit(assign(r0E44, rshift(r0E1D, r0E52), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0E50->else_instructions;

                           ir_variable *const r0E53 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0E55 = equal(r0E42, body.constant(int(64)));
                           ir_if *f0E54 = new(mem_ctx) ir_if(operand(r0E55).val);
                           exec_list *const f0E54_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0E54->then_instructions;

                              body.emit(assign(r0E53, r0E1D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0E54->else_instructions;

                              ir_expression *const r0E56 = nequal(r0E1D, body.constant(0u));
                              ir_expression *const r0E57 = expr(ir_unop_b2i, r0E56);
                              body.emit(assign(r0E53, expr(ir_unop_i2u, r0E57), 0x01));


                           body.instructions = f0E54_parent_instructions;
                           body.emit(f0E54);

                           /* END IF */

                           body.emit(assign(r0E43, r0E53, 0x01));

                           body.emit(assign(r0E44, body.constant(0u), 0x01));


                        body.instructions = f0E50_parent_instructions;
                        body.emit(f0E50);

                        /* END IF */


                     body.instructions = f0E4E_parent_instructions;
                     body.emit(f0E4E);

                     /* END IF */

                     body.emit(assign(r0E45, body.constant(0u), 0x01));


                  body.instructions = f0E4A_parent_instructions;
                  body.emit(f0E4A);

                  /* END IF */

                  ir_expression *const r0E58 = nequal(r0E41, body.constant(0u));
                  ir_expression *const r0E59 = expr(ir_unop_b2i, r0E58);
                  ir_expression *const r0E5A = expr(ir_unop_i2u, r0E59);
                  body.emit(assign(r0E43, bit_or(r0E43, r0E5A), 0x01));


               body.instructions = f0E48_parent_instructions;
               body.emit(f0E48);

               /* END IF */

               body.emit(assign(r0E1D, r0E45, 0x01));

               body.emit(assign(r0E1E, r0E44, 0x01));

               body.emit(assign(r0E1F, r0E43, 0x01));


            body.instructions = f0E37_parent_instructions;
            body.emit(f0E37);

            /* END IF */

            body.emit(assign(r0E1C, sub(r0E1C, r0E20), 0x01));

            ir_variable *const r0E5B = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0E5B, r0E1C, 0x01));

            ir_variable *const r0E5C = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0E5C, r0E1D, 0x01));

            ir_variable *const r0E5D = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0E5D, r0E1E, 0x01));

            ir_variable *const r0E5E = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0E5E, r0E1F, 0x01));

            ir_variable *const r0E5F = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0E5F, body.constant(true), 0x01));

            ir_variable *const r0E60 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0E61 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0E61);
            ir_expression *const r0E62 = expr(ir_unop_u2i, r0E1F);
            body.emit(assign(r0E61, less(r0E62, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0E64 = lequal(body.constant(int(2045)), r0E1C);
            ir_if *f0E63 = new(mem_ctx) ir_if(operand(r0E64).val);
            exec_list *const f0E63_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E63->then_instructions;

               ir_variable *const r0E65 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0E67 = less(body.constant(int(2045)), r0E1C);
               ir_if *f0E66 = new(mem_ctx) ir_if(operand(r0E67).val);
               exec_list *const f0E66_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E66->then_instructions;

                  body.emit(assign(r0E65, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E66->else_instructions;

                  ir_variable *const r0E68 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0E6A = equal(r0E1C, body.constant(int(2045)));
                  ir_if *f0E69 = new(mem_ctx) ir_if(operand(r0E6A).val);
                  exec_list *const f0E69_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E69->then_instructions;

                     ir_expression *const r0E6B = equal(body.constant(2097151u), r0E1D);
                     ir_expression *const r0E6C = equal(body.constant(4294967295u), r0E1E);
                     body.emit(assign(r0E68, logic_and(r0E6B, r0E6C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E69->else_instructions;

                     body.emit(assign(r0E68, body.constant(false), 0x01));


                  body.instructions = f0E69_parent_instructions;
                  body.emit(f0E69);

                  /* END IF */

                  body.emit(assign(r0E65, logic_and(r0E68, r0E61), 0x01));


               body.instructions = f0E66_parent_instructions;
               body.emit(f0E66);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0E6D = new(mem_ctx) ir_if(operand(r0E65).val);
               exec_list *const f0E6D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E6D->then_instructions;

                  ir_variable *const r0E6E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0E6E);
                  ir_expression *const r0E6F = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r0E6E, add(r0E6F, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0E6E, body.constant(0u), 0x01));

                  body.emit(assign(r0E60, r0E6E, 0x03));

                  body.emit(assign(r0E5F, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E6D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E71 = less(r0E1C, body.constant(int(0)));
                  ir_if *f0E70 = new(mem_ctx) ir_if(operand(r0E71).val);
                  exec_list *const f0E70_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E70->then_instructions;

                     ir_variable *const r0E72 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0E72, r0E1F, 0x01));

                     ir_variable *const r0E73 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0E73, neg(r0E1C), 0x01));

                     ir_variable *const r0E74 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0E74);
                     ir_variable *const r0E75 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0E75);
                     ir_variable *const r0E76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0E76);
                     ir_variable *const r0E77 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0E78 = neg(r0E73);
                     body.emit(assign(r0E77, bit_and(r0E78, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0E7A = equal(r0E73, body.constant(int(0)));
                     ir_if *f0E79 = new(mem_ctx) ir_if(operand(r0E7A).val);
                     exec_list *const f0E79_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E79->then_instructions;

                        body.emit(assign(r0E74, r0E1F, 0x01));

                        body.emit(assign(r0E75, r0E1E, 0x01));

                        body.emit(assign(r0E76, r0E1D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E79->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0E7C = less(r0E73, body.constant(int(32)));
                        ir_if *f0E7B = new(mem_ctx) ir_if(operand(r0E7C).val);
                        exec_list *const f0E7B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0E7B->then_instructions;

                           body.emit(assign(r0E74, lshift(r0E1E, r0E77), 0x01));

                           ir_expression *const r0E7D = lshift(r0E1D, r0E77);
                           ir_expression *const r0E7E = rshift(r0E1E, r0E73);
                           body.emit(assign(r0E75, bit_or(r0E7D, r0E7E), 0x01));

                           body.emit(assign(r0E76, rshift(r0E1D, r0E73), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0E7B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0E80 = equal(r0E73, body.constant(int(32)));
                           ir_if *f0E7F = new(mem_ctx) ir_if(operand(r0E80).val);
                           exec_list *const f0E7F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0E7F->then_instructions;

                              body.emit(assign(r0E74, r0E1E, 0x01));

                              body.emit(assign(r0E75, r0E1D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0E7F->else_instructions;

                              body.emit(assign(r0E72, bit_or(r0E1F, r0E1E), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0E82 = less(r0E73, body.constant(int(64)));
                              ir_if *f0E81 = new(mem_ctx) ir_if(operand(r0E82).val);
                              exec_list *const f0E81_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0E81->then_instructions;

                                 body.emit(assign(r0E74, lshift(r0E1D, r0E77), 0x01));

                                 ir_expression *const r0E83 = bit_and(r0E73, body.constant(int(31)));
                                 body.emit(assign(r0E75, rshift(r0E1D, r0E83), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0E81->else_instructions;

                                 ir_variable *const r0E84 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0E86 = equal(r0E73, body.constant(int(64)));
                                 ir_if *f0E85 = new(mem_ctx) ir_if(operand(r0E86).val);
                                 exec_list *const f0E85_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0E85->then_instructions;

                                    body.emit(assign(r0E84, r0E1D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0E85->else_instructions;

                                    ir_expression *const r0E87 = nequal(r0E1D, body.constant(0u));
                                    ir_expression *const r0E88 = expr(ir_unop_b2i, r0E87);
                                    body.emit(assign(r0E84, expr(ir_unop_i2u, r0E88), 0x01));


                                 body.instructions = f0E85_parent_instructions;
                                 body.emit(f0E85);

                                 /* END IF */

                                 body.emit(assign(r0E74, r0E84, 0x01));

                                 body.emit(assign(r0E75, body.constant(0u), 0x01));


                              body.instructions = f0E81_parent_instructions;
                              body.emit(f0E81);

                              /* END IF */


                           body.instructions = f0E7F_parent_instructions;
                           body.emit(f0E7F);

                           /* END IF */

                           body.emit(assign(r0E76, body.constant(0u), 0x01));


                        body.instructions = f0E7B_parent_instructions;
                        body.emit(f0E7B);

                        /* END IF */

                        ir_expression *const r0E89 = nequal(r0E72, body.constant(0u));
                        ir_expression *const r0E8A = expr(ir_unop_b2i, r0E89);
                        ir_expression *const r0E8B = expr(ir_unop_i2u, r0E8A);
                        body.emit(assign(r0E74, bit_or(r0E74, r0E8B), 0x01));


                     body.instructions = f0E79_parent_instructions;
                     body.emit(f0E79);

                     /* END IF */

                     body.emit(assign(r0E5C, r0E76, 0x01));

                     body.emit(assign(r0E5D, r0E75, 0x01));

                     body.emit(assign(r0E5E, r0E74, 0x01));

                     body.emit(assign(r0E5B, body.constant(int(0)), 0x01));

                     body.emit(assign(r0E61, less(r0E74, body.constant(0u)), 0x01));


                  body.instructions = f0E70_parent_instructions;
                  body.emit(f0E70);

                  /* END IF */


               body.instructions = f0E6D_parent_instructions;
               body.emit(f0E6D);

               /* END IF */


            body.instructions = f0E63_parent_instructions;
            body.emit(f0E63);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0E8C = new(mem_ctx) ir_if(operand(r0E5F).val);
            exec_list *const f0E8C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E8C->then_instructions;

               /* IF CONDITION */
               ir_if *f0E8D = new(mem_ctx) ir_if(operand(r0E61).val);
               exec_list *const f0E8D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E8D->then_instructions;

                  ir_variable *const r0E8E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0E8E, add(r0E5D, body.constant(1u)), 0x01));

                  ir_expression *const r0E8F = less(r0E8E, r0E5D);
                  ir_expression *const r0E90 = expr(ir_unop_b2i, r0E8F);
                  ir_expression *const r0E91 = expr(ir_unop_i2u, r0E90);
                  body.emit(assign(r0E5C, add(r0E5C, r0E91), 0x01));

                  ir_expression *const r0E92 = equal(r0E5E, body.constant(0u));
                  ir_expression *const r0E93 = expr(ir_unop_b2i, r0E92);
                  ir_expression *const r0E94 = expr(ir_unop_i2u, r0E93);
                  ir_expression *const r0E95 = add(r0E5E, r0E94);
                  ir_expression *const r0E96 = bit_and(r0E95, body.constant(1u));
                  ir_expression *const r0E97 = expr(ir_unop_bit_not, r0E96);
                  body.emit(assign(r0E5D, bit_and(r0E8E, r0E97), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E8D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E99 = bit_or(r0E5C, r0E5D);
                  ir_expression *const r0E9A = equal(r0E99, body.constant(0u));
                  ir_if *f0E98 = new(mem_ctx) ir_if(operand(r0E9A).val);
                  exec_list *const f0E98_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E98->then_instructions;

                     body.emit(assign(r0E5B, body.constant(int(0)), 0x01));


                  body.instructions = f0E98_parent_instructions;
                  body.emit(f0E98);

                  /* END IF */


               body.instructions = f0E8D_parent_instructions;
               body.emit(f0E8D);

               /* END IF */

               ir_variable *const r0E9B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0E9B);
               ir_expression *const r0E9C = lshift(r0DB2, body.constant(int(31)));
               ir_expression *const r0E9D = expr(ir_unop_i2u, r0E5B);
               ir_expression *const r0E9E = lshift(r0E9D, body.constant(int(20)));
               ir_expression *const r0E9F = add(r0E9C, r0E9E);
               body.emit(assign(r0E9B, add(r0E9F, r0E5C), 0x02));

               body.emit(assign(r0E9B, r0E5D, 0x01));

               body.emit(assign(r0E60, r0E9B, 0x03));

               body.emit(assign(r0E5F, body.constant(false), 0x01));


            body.instructions = f0E8C_parent_instructions;
            body.emit(f0E8C);

            /* END IF */

            body.emit(assign(r0DB7, r0E60, 0x03));


         body.instructions = f0DD2_parent_instructions;
         body.emit(f0DD2);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0DD0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0EA1 = less(r0DB8, body.constant(int(0)));
         ir_if *f0EA0 = new(mem_ctx) ir_if(operand(r0EA1).val);
         exec_list *const f0EA0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EA0->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0EA3 = equal(r0DC3, body.constant(int(2047)));
            ir_if *f0EA2 = new(mem_ctx) ir_if(operand(r0EA3).val);
            exec_list *const f0EA2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EA2->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0EA5 = bit_or(r0DBB, r0DBC);
               ir_expression *const r0EA6 = nequal(r0EA5, body.constant(0u));
               ir_if *f0EA4 = new(mem_ctx) ir_if(operand(r0EA6).val);
               exec_list *const f0EA4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EA4->then_instructions;

                  ir_variable *const r0EA7 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0EA7, swizzle_x(r0DAF), 0x01));

                  ir_variable *const r0EA8 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0EA8, swizzle_x(r0DB0), 0x01));

                  ir_variable *const r0EA9 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0EAA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0EAB = rshift(swizzle_y(r0DAF), body.constant(int(19)));
                  ir_expression *const r0EAC = bit_and(r0EAB, body.constant(4095u));
                  ir_expression *const r0EAD = equal(r0EAC, body.constant(4094u));
                  ir_expression *const r0EAE = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r0EAF = bit_and(swizzle_y(r0DAF), body.constant(524287u));
                  ir_expression *const r0EB0 = nequal(r0EAF, body.constant(0u));
                  ir_expression *const r0EB1 = logic_or(r0EAE, r0EB0);
                  body.emit(assign(r0EAA, logic_and(r0EAD, r0EB1), 0x01));

                  ir_variable *const r0EB2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0EB3 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
                  ir_expression *const r0EB4 = lequal(body.constant(4292870144u), r0EB3);
                  ir_expression *const r0EB5 = nequal(swizzle_x(r0DB0), body.constant(0u));
                  ir_expression *const r0EB6 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
                  ir_expression *const r0EB7 = nequal(r0EB6, body.constant(0u));
                  ir_expression *const r0EB8 = logic_or(r0EB5, r0EB7);
                  body.emit(assign(r0EB2, logic_and(r0EB4, r0EB8), 0x01));

                  body.emit(assign(r0EA7, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

                  body.emit(assign(r0EA8, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0EBA = lshift(swizzle_y(r0DAF), body.constant(int(1)));
                  ir_expression *const r0EBB = lequal(body.constant(4292870144u), r0EBA);
                  ir_expression *const r0EBC = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r0EBD = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
                  ir_expression *const r0EBE = nequal(r0EBD, body.constant(0u));
                  ir_expression *const r0EBF = logic_or(r0EBC, r0EBE);
                  ir_expression *const r0EC0 = logic_and(r0EBB, r0EBF);
                  ir_if *f0EB9 = new(mem_ctx) ir_if(operand(r0EC0).val);
                  exec_list *const f0EB9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EB9->then_instructions;

                     ir_variable *const r0EC1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0EC3 = logic_and(r0EAA, r0EB2);
                     ir_if *f0EC2 = new(mem_ctx) ir_if(operand(r0EC3).val);
                     exec_list *const f0EC2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EC2->then_instructions;

                        body.emit(assign(r0EC1, r0EA8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0EC2->else_instructions;

                        body.emit(assign(r0EC1, r0EA7, 0x03));


                     body.instructions = f0EC2_parent_instructions;
                     body.emit(f0EC2);

                     /* END IF */

                     body.emit(assign(r0EA9, r0EC1, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0EB9->else_instructions;

                     body.emit(assign(r0EA9, r0EA8, 0x03));


                  body.instructions = f0EB9_parent_instructions;
                  body.emit(f0EB9);

                  /* END IF */

                  body.emit(assign(r0DB7, r0EA9, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EA4->else_instructions;

                  ir_variable *const r0EC4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0EC4);
                  ir_expression *const r0EC5 = bit_xor(r0DB2, body.constant(1u));
                  ir_expression *const r0EC6 = lshift(r0EC5, body.constant(int(31)));
                  body.emit(assign(r0EC4, add(r0EC6, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0EC4, body.constant(0u), 0x01));

                  body.emit(assign(r0DB7, r0EC4, 0x03));


               body.instructions = f0EA4_parent_instructions;
               body.emit(f0EA4);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EA2->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0EC8 = equal(r0DC0, body.constant(int(0)));
               ir_if *f0EC7 = new(mem_ctx) ir_if(operand(r0EC8).val);
               exec_list *const f0EC7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EC7->then_instructions;

                  body.emit(assign(r0DB8, add(r0DB8, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EC7->else_instructions;

                  body.emit(assign(r0DBD, bit_or(r0DBD, body.constant(1073741824u)), 0x01));


               body.instructions = f0EC7_parent_instructions;
               body.emit(f0EC7);

               /* END IF */

               ir_variable *const r0EC9 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0EC9, neg(r0DB8), 0x01));

               ir_variable *const r0ECA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0ECA);
               ir_variable *const r0ECB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0ECB);
               ir_variable *const r0ECC = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0ECD = neg(r0EC9);
               body.emit(assign(r0ECC, bit_and(r0ECD, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0ECF = equal(r0EC9, body.constant(int(0)));
               ir_if *f0ECE = new(mem_ctx) ir_if(operand(r0ECF).val);
               exec_list *const f0ECE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ECE->then_instructions;

                  body.emit(assign(r0ECA, r0DC6, 0x01));

                  body.emit(assign(r0ECB, r0DBD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ECE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0ED1 = less(r0EC9, body.constant(int(32)));
                  ir_if *f0ED0 = new(mem_ctx) ir_if(operand(r0ED1).val);
                  exec_list *const f0ED0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0ED0->then_instructions;

                     ir_expression *const r0ED2 = lshift(r0DBD, r0ECC);
                     ir_expression *const r0ED3 = rshift(r0DC6, r0EC9);
                     ir_expression *const r0ED4 = bit_or(r0ED2, r0ED3);
                     ir_expression *const r0ED5 = lshift(r0DC6, r0ECC);
                     ir_expression *const r0ED6 = nequal(r0ED5, body.constant(0u));
                     ir_expression *const r0ED7 = expr(ir_unop_b2i, r0ED6);
                     ir_expression *const r0ED8 = expr(ir_unop_i2u, r0ED7);
                     body.emit(assign(r0ECA, bit_or(r0ED4, r0ED8), 0x01));

                     body.emit(assign(r0ECB, rshift(r0DBD, r0EC9), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0ED0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0EDA = equal(r0EC9, body.constant(int(32)));
                     ir_if *f0ED9 = new(mem_ctx) ir_if(operand(r0EDA).val);
                     exec_list *const f0ED9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0ED9->then_instructions;

                        ir_expression *const r0EDB = nequal(r0DC6, body.constant(0u));
                        ir_expression *const r0EDC = expr(ir_unop_b2i, r0EDB);
                        ir_expression *const r0EDD = expr(ir_unop_i2u, r0EDC);
                        body.emit(assign(r0ECA, bit_or(r0DBD, r0EDD), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0ED9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0EDF = less(r0EC9, body.constant(int(64)));
                        ir_if *f0EDE = new(mem_ctx) ir_if(operand(r0EDF).val);
                        exec_list *const f0EDE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0EDE->then_instructions;

                           ir_expression *const r0EE0 = bit_and(r0EC9, body.constant(int(31)));
                           ir_expression *const r0EE1 = rshift(r0DBD, r0EE0);
                           ir_expression *const r0EE2 = lshift(r0DBD, r0ECC);
                           ir_expression *const r0EE3 = bit_or(r0EE2, r0DC6);
                           ir_expression *const r0EE4 = nequal(r0EE3, body.constant(0u));
                           ir_expression *const r0EE5 = expr(ir_unop_b2i, r0EE4);
                           ir_expression *const r0EE6 = expr(ir_unop_i2u, r0EE5);
                           body.emit(assign(r0ECA, bit_or(r0EE1, r0EE6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0EDE->else_instructions;

                           ir_expression *const r0EE7 = bit_or(r0DBD, r0DC6);
                           ir_expression *const r0EE8 = nequal(r0EE7, body.constant(0u));
                           ir_expression *const r0EE9 = expr(ir_unop_b2i, r0EE8);
                           body.emit(assign(r0ECA, expr(ir_unop_i2u, r0EE9), 0x01));


                        body.instructions = f0EDE_parent_instructions;
                        body.emit(f0EDE);

                        /* END IF */


                     body.instructions = f0ED9_parent_instructions;
                     body.emit(f0ED9);

                     /* END IF */

                     body.emit(assign(r0ECB, body.constant(0u), 0x01));


                  body.instructions = f0ED0_parent_instructions;
                  body.emit(f0ED0);

                  /* END IF */


               body.instructions = f0ECE_parent_instructions;
               body.emit(f0ECE);

               /* END IF */

               body.emit(assign(r0DBD, r0ECB, 0x01));

               body.emit(assign(r0DBE, r0ECA, 0x01));

               body.emit(assign(r0DBB, bit_or(r0DBB, body.constant(1073741824u)), 0x01));

               ir_variable *const r0EEA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0EEB = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0EEB, sub(r0DBC, r0ECA), 0x01));

               ir_expression *const r0EEC = sub(r0DBB, r0ECB);
               ir_expression *const r0EED = less(r0DBC, r0ECA);
               ir_expression *const r0EEE = expr(ir_unop_b2i, r0EED);
               ir_expression *const r0EEF = expr(ir_unop_i2u, r0EEE);
               body.emit(assign(r0EEA, sub(r0EEC, r0EEF), 0x01));

               body.emit(assign(r0DB6, bit_xor(r0DB2, body.constant(1u)), 0x01));

               body.emit(assign(r0DBF, add(r0DC3, body.constant(int(-1))), 0x01));

               ir_variable *const r0EF0 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0EF0, add(r0DBF, body.constant(int(-10))), 0x01));

               ir_variable *const r0EF1 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0EF1, r0EEA, 0x01));

               ir_variable *const r0EF2 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0EF2, r0EEB, 0x01));

               ir_variable *const r0EF3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0EF3);
               ir_variable *const r0EF4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EF4);
               /* IF CONDITION */
               ir_expression *const r0EF6 = equal(r0EEA, body.constant(0u));
               ir_if *f0EF5 = new(mem_ctx) ir_if(operand(r0EF6).val);
               exec_list *const f0EF5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EF5->then_instructions;

                  body.emit(assign(r0EF1, r0EEB, 0x01));

                  body.emit(assign(r0EF2, body.constant(0u), 0x01));

                  body.emit(assign(r0EF0, add(r0EF0, body.constant(int(-32))), 0x01));


               body.instructions = f0EF5_parent_instructions;
               body.emit(f0EF5);

               /* END IF */

               ir_variable *const r0EF7 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0EF7, r0EF1, 0x01));

               ir_variable *const r0EF8 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0EF9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EF9);
               /* IF CONDITION */
               ir_expression *const r0EFB = equal(r0EF1, body.constant(0u));
               ir_if *f0EFA = new(mem_ctx) ir_if(operand(r0EFB).val);
               exec_list *const f0EFA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EFA->then_instructions;

                  body.emit(assign(r0EF8, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EFA->else_instructions;

                  body.emit(assign(r0EF9, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0EFD = bit_and(r0EF1, body.constant(4294901760u));
                  ir_expression *const r0EFE = equal(r0EFD, body.constant(0u));
                  ir_if *f0EFC = new(mem_ctx) ir_if(operand(r0EFE).val);
                  exec_list *const f0EFC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EFC->then_instructions;

                     body.emit(assign(r0EF9, body.constant(int(16)), 0x01));

                     body.emit(assign(r0EF7, lshift(r0EF1, body.constant(int(16))), 0x01));


                  body.instructions = f0EFC_parent_instructions;
                  body.emit(f0EFC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F00 = bit_and(r0EF7, body.constant(4278190080u));
                  ir_expression *const r0F01 = equal(r0F00, body.constant(0u));
                  ir_if *f0EFF = new(mem_ctx) ir_if(operand(r0F01).val);
                  exec_list *const f0EFF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EFF->then_instructions;

                     body.emit(assign(r0EF9, add(r0EF9, body.constant(int(8))), 0x01));

                     body.emit(assign(r0EF7, lshift(r0EF7, body.constant(int(8))), 0x01));


                  body.instructions = f0EFF_parent_instructions;
                  body.emit(f0EFF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F03 = bit_and(r0EF7, body.constant(4026531840u));
                  ir_expression *const r0F04 = equal(r0F03, body.constant(0u));
                  ir_if *f0F02 = new(mem_ctx) ir_if(operand(r0F04).val);
                  exec_list *const f0F02_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F02->then_instructions;

                     body.emit(assign(r0EF9, add(r0EF9, body.constant(int(4))), 0x01));

                     body.emit(assign(r0EF7, lshift(r0EF7, body.constant(int(4))), 0x01));


                  body.instructions = f0F02_parent_instructions;
                  body.emit(f0F02);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F06 = bit_and(r0EF7, body.constant(3221225472u));
                  ir_expression *const r0F07 = equal(r0F06, body.constant(0u));
                  ir_if *f0F05 = new(mem_ctx) ir_if(operand(r0F07).val);
                  exec_list *const f0F05_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F05->then_instructions;

                     body.emit(assign(r0EF9, add(r0EF9, body.constant(int(2))), 0x01));

                     body.emit(assign(r0EF7, lshift(r0EF7, body.constant(int(2))), 0x01));


                  body.instructions = f0F05_parent_instructions;
                  body.emit(f0F05);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F09 = bit_and(r0EF7, body.constant(2147483648u));
                  ir_expression *const r0F0A = equal(r0F09, body.constant(0u));
                  ir_if *f0F08 = new(mem_ctx) ir_if(operand(r0F0A).val);
                  exec_list *const f0F08_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F08->then_instructions;

                     body.emit(assign(r0EF9, add(r0EF9, body.constant(int(1))), 0x01));


                  body.instructions = f0F08_parent_instructions;
                  body.emit(f0F08);

                  /* END IF */

                  body.emit(assign(r0EF8, r0EF9, 0x01));


               body.instructions = f0EFA_parent_instructions;
               body.emit(f0EFA);

               /* END IF */

               body.emit(assign(r0EF4, add(r0EF8, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0F0C = lequal(body.constant(int(0)), r0EF4);
               ir_if *f0F0B = new(mem_ctx) ir_if(operand(r0F0C).val);
               exec_list *const f0F0B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F0B->then_instructions;

                  body.emit(assign(r0EF3, body.constant(0u), 0x01));

                  ir_variable *const r0F0D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0F0D, lshift(r0EF2, r0EF4), 0x01));

                  ir_variable *const r0F0E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F10 = equal(r0EF4, body.constant(int(0)));
                  ir_if *f0F0F = new(mem_ctx) ir_if(operand(r0F10).val);
                  exec_list *const f0F0F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F0F->then_instructions;

                     body.emit(assign(r0F0E, r0EF1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F0F->else_instructions;

                     ir_expression *const r0F11 = lshift(r0EF1, r0EF4);
                     ir_expression *const r0F12 = neg(r0EF4);
                     ir_expression *const r0F13 = bit_and(r0F12, body.constant(int(31)));
                     ir_expression *const r0F14 = rshift(r0EF2, r0F13);
                     body.emit(assign(r0F0E, bit_or(r0F11, r0F14), 0x01));


                  body.instructions = f0F0F_parent_instructions;
                  body.emit(f0F0F);

                  /* END IF */

                  body.emit(assign(r0EF1, r0F0E, 0x01));

                  body.emit(assign(r0EF2, r0F0D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F0B->else_instructions;

                  ir_variable *const r0F15 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0F15, body.constant(0u), 0x01));

                  ir_variable *const r0F16 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0F16, neg(r0EF4), 0x01));

                  ir_variable *const r0F17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0F17);
                  ir_variable *const r0F18 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0F18);
                  ir_variable *const r0F19 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0F19);
                  ir_variable *const r0F1A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0F1B = neg(r0F16);
                  body.emit(assign(r0F1A, bit_and(r0F1B, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0F1D = equal(r0F16, body.constant(int(0)));
                  ir_if *f0F1C = new(mem_ctx) ir_if(operand(r0F1D).val);
                  exec_list *const f0F1C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F1C->then_instructions;

                     body.emit(assign(r0F17, r0F15, 0x01));

                     body.emit(assign(r0F18, r0EF2, 0x01));

                     body.emit(assign(r0F19, r0EF1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F1C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F1F = less(r0F16, body.constant(int(32)));
                     ir_if *f0F1E = new(mem_ctx) ir_if(operand(r0F1F).val);
                     exec_list *const f0F1E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F1E->then_instructions;

                        body.emit(assign(r0F17, lshift(r0EF2, r0F1A), 0x01));

                        ir_expression *const r0F20 = lshift(r0EF1, r0F1A);
                        ir_expression *const r0F21 = rshift(r0EF2, r0F16);
                        body.emit(assign(r0F18, bit_or(r0F20, r0F21), 0x01));

                        body.emit(assign(r0F19, rshift(r0EF1, r0F16), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F1E->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0F23 = equal(r0F16, body.constant(int(32)));
                        ir_if *f0F22 = new(mem_ctx) ir_if(operand(r0F23).val);
                        exec_list *const f0F22_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F22->then_instructions;

                           body.emit(assign(r0F17, r0EF2, 0x01));

                           body.emit(assign(r0F18, r0EF1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0F22->else_instructions;

                           body.emit(assign(r0F15, bit_or(body.constant(0u), r0EF2), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0F25 = less(r0F16, body.constant(int(64)));
                           ir_if *f0F24 = new(mem_ctx) ir_if(operand(r0F25).val);
                           exec_list *const f0F24_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0F24->then_instructions;

                              body.emit(assign(r0F17, lshift(r0EF1, r0F1A), 0x01));

                              ir_expression *const r0F26 = bit_and(r0F16, body.constant(int(31)));
                              body.emit(assign(r0F18, rshift(r0EF1, r0F26), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0F24->else_instructions;

                              ir_variable *const r0F27 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0F29 = equal(r0F16, body.constant(int(64)));
                              ir_if *f0F28 = new(mem_ctx) ir_if(operand(r0F29).val);
                              exec_list *const f0F28_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0F28->then_instructions;

                                 body.emit(assign(r0F27, r0EF1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0F28->else_instructions;

                                 ir_expression *const r0F2A = nequal(r0EF1, body.constant(0u));
                                 ir_expression *const r0F2B = expr(ir_unop_b2i, r0F2A);
                                 body.emit(assign(r0F27, expr(ir_unop_i2u, r0F2B), 0x01));


                              body.instructions = f0F28_parent_instructions;
                              body.emit(f0F28);

                              /* END IF */

                              body.emit(assign(r0F17, r0F27, 0x01));

                              body.emit(assign(r0F18, body.constant(0u), 0x01));


                           body.instructions = f0F24_parent_instructions;
                           body.emit(f0F24);

                           /* END IF */


                        body.instructions = f0F22_parent_instructions;
                        body.emit(f0F22);

                        /* END IF */

                        body.emit(assign(r0F19, body.constant(0u), 0x01));


                     body.instructions = f0F1E_parent_instructions;
                     body.emit(f0F1E);

                     /* END IF */

                     ir_expression *const r0F2C = nequal(r0F15, body.constant(0u));
                     ir_expression *const r0F2D = expr(ir_unop_b2i, r0F2C);
                     ir_expression *const r0F2E = expr(ir_unop_i2u, r0F2D);
                     body.emit(assign(r0F17, bit_or(r0F17, r0F2E), 0x01));


                  body.instructions = f0F1C_parent_instructions;
                  body.emit(f0F1C);

                  /* END IF */

                  body.emit(assign(r0EF1, r0F19, 0x01));

                  body.emit(assign(r0EF2, r0F18, 0x01));

                  body.emit(assign(r0EF3, r0F17, 0x01));


               body.instructions = f0F0B_parent_instructions;
               body.emit(f0F0B);

               /* END IF */

               body.emit(assign(r0EF0, sub(r0EF0, r0EF4), 0x01));

               ir_variable *const r0F2F = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0F2F, r0EF0, 0x01));

               ir_variable *const r0F30 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0F30, r0EF1, 0x01));

               ir_variable *const r0F31 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0F31, r0EF2, 0x01));

               ir_variable *const r0F32 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0F32, r0EF3, 0x01));

               ir_variable *const r0F33 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0F33, body.constant(true), 0x01));

               ir_variable *const r0F34 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0F35 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0F35);
               ir_expression *const r0F36 = expr(ir_unop_u2i, r0EF3);
               body.emit(assign(r0F35, less(r0F36, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0F38 = lequal(body.constant(int(2045)), r0EF0);
               ir_if *f0F37 = new(mem_ctx) ir_if(operand(r0F38).val);
               exec_list *const f0F37_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F37->then_instructions;

                  ir_variable *const r0F39 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F3B = less(body.constant(int(2045)), r0EF0);
                  ir_if *f0F3A = new(mem_ctx) ir_if(operand(r0F3B).val);
                  exec_list *const f0F3A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F3A->then_instructions;

                     body.emit(assign(r0F39, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F3A->else_instructions;

                     ir_variable *const r0F3C = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F3E = equal(r0EF0, body.constant(int(2045)));
                     ir_if *f0F3D = new(mem_ctx) ir_if(operand(r0F3E).val);
                     exec_list *const f0F3D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F3D->then_instructions;

                        ir_expression *const r0F3F = equal(body.constant(2097151u), r0EF1);
                        ir_expression *const r0F40 = equal(body.constant(4294967295u), r0EF2);
                        body.emit(assign(r0F3C, logic_and(r0F3F, r0F40), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F3D->else_instructions;

                        body.emit(assign(r0F3C, body.constant(false), 0x01));


                     body.instructions = f0F3D_parent_instructions;
                     body.emit(f0F3D);

                     /* END IF */

                     body.emit(assign(r0F39, logic_and(r0F3C, r0F35), 0x01));


                  body.instructions = f0F3A_parent_instructions;
                  body.emit(f0F3A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0F41 = new(mem_ctx) ir_if(operand(r0F39).val);
                  exec_list *const f0F41_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F41->then_instructions;

                     ir_variable *const r0F42 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0F42);
                     ir_expression *const r0F43 = lshift(r0DB6, body.constant(int(31)));
                     body.emit(assign(r0F42, add(r0F43, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0F42, body.constant(0u), 0x01));

                     body.emit(assign(r0F34, r0F42, 0x03));

                     body.emit(assign(r0F33, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F41->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F45 = less(r0EF0, body.constant(int(0)));
                     ir_if *f0F44 = new(mem_ctx) ir_if(operand(r0F45).val);
                     exec_list *const f0F44_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F44->then_instructions;

                        ir_variable *const r0F46 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0F46, r0EF3, 0x01));

                        ir_variable *const r0F47 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0F47, neg(r0EF0), 0x01));

                        ir_variable *const r0F48 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0F48);
                        ir_variable *const r0F49 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0F49);
                        ir_variable *const r0F4A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0F4A);
                        ir_variable *const r0F4B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0F4C = neg(r0F47);
                        body.emit(assign(r0F4B, bit_and(r0F4C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0F4E = equal(r0F47, body.constant(int(0)));
                        ir_if *f0F4D = new(mem_ctx) ir_if(operand(r0F4E).val);
                        exec_list *const f0F4D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F4D->then_instructions;

                           body.emit(assign(r0F48, r0EF3, 0x01));

                           body.emit(assign(r0F49, r0EF2, 0x01));

                           body.emit(assign(r0F4A, r0EF1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0F4D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0F50 = less(r0F47, body.constant(int(32)));
                           ir_if *f0F4F = new(mem_ctx) ir_if(operand(r0F50).val);
                           exec_list *const f0F4F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0F4F->then_instructions;

                              body.emit(assign(r0F48, lshift(r0EF2, r0F4B), 0x01));

                              ir_expression *const r0F51 = lshift(r0EF1, r0F4B);
                              ir_expression *const r0F52 = rshift(r0EF2, r0F47);
                              body.emit(assign(r0F49, bit_or(r0F51, r0F52), 0x01));

                              body.emit(assign(r0F4A, rshift(r0EF1, r0F47), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0F4F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0F54 = equal(r0F47, body.constant(int(32)));
                              ir_if *f0F53 = new(mem_ctx) ir_if(operand(r0F54).val);
                              exec_list *const f0F53_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0F53->then_instructions;

                                 body.emit(assign(r0F48, r0EF2, 0x01));

                                 body.emit(assign(r0F49, r0EF1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0F53->else_instructions;

                                 body.emit(assign(r0F46, bit_or(r0EF3, r0EF2), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0F56 = less(r0F47, body.constant(int(64)));
                                 ir_if *f0F55 = new(mem_ctx) ir_if(operand(r0F56).val);
                                 exec_list *const f0F55_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0F55->then_instructions;

                                    body.emit(assign(r0F48, lshift(r0EF1, r0F4B), 0x01));

                                    ir_expression *const r0F57 = bit_and(r0F47, body.constant(int(31)));
                                    body.emit(assign(r0F49, rshift(r0EF1, r0F57), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0F55->else_instructions;

                                    ir_variable *const r0F58 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0F5A = equal(r0F47, body.constant(int(64)));
                                    ir_if *f0F59 = new(mem_ctx) ir_if(operand(r0F5A).val);
                                    exec_list *const f0F59_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0F59->then_instructions;

                                       body.emit(assign(r0F58, r0EF1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0F59->else_instructions;

                                       ir_expression *const r0F5B = nequal(r0EF1, body.constant(0u));
                                       ir_expression *const r0F5C = expr(ir_unop_b2i, r0F5B);
                                       body.emit(assign(r0F58, expr(ir_unop_i2u, r0F5C), 0x01));


                                    body.instructions = f0F59_parent_instructions;
                                    body.emit(f0F59);

                                    /* END IF */

                                    body.emit(assign(r0F48, r0F58, 0x01));

                                    body.emit(assign(r0F49, body.constant(0u), 0x01));


                                 body.instructions = f0F55_parent_instructions;
                                 body.emit(f0F55);

                                 /* END IF */


                              body.instructions = f0F53_parent_instructions;
                              body.emit(f0F53);

                              /* END IF */

                              body.emit(assign(r0F4A, body.constant(0u), 0x01));


                           body.instructions = f0F4F_parent_instructions;
                           body.emit(f0F4F);

                           /* END IF */

                           ir_expression *const r0F5D = nequal(r0F46, body.constant(0u));
                           ir_expression *const r0F5E = expr(ir_unop_b2i, r0F5D);
                           ir_expression *const r0F5F = expr(ir_unop_i2u, r0F5E);
                           body.emit(assign(r0F48, bit_or(r0F48, r0F5F), 0x01));


                        body.instructions = f0F4D_parent_instructions;
                        body.emit(f0F4D);

                        /* END IF */

                        body.emit(assign(r0F30, r0F4A, 0x01));

                        body.emit(assign(r0F31, r0F49, 0x01));

                        body.emit(assign(r0F32, r0F48, 0x01));

                        body.emit(assign(r0F2F, body.constant(int(0)), 0x01));

                        body.emit(assign(r0F35, less(r0F48, body.constant(0u)), 0x01));


                     body.instructions = f0F44_parent_instructions;
                     body.emit(f0F44);

                     /* END IF */


                  body.instructions = f0F41_parent_instructions;
                  body.emit(f0F41);

                  /* END IF */


               body.instructions = f0F37_parent_instructions;
               body.emit(f0F37);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0F60 = new(mem_ctx) ir_if(operand(r0F33).val);
               exec_list *const f0F60_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F60->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0F61 = new(mem_ctx) ir_if(operand(r0F35).val);
                  exec_list *const f0F61_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F61->then_instructions;

                     ir_variable *const r0F62 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0F62, add(r0F31, body.constant(1u)), 0x01));

                     ir_expression *const r0F63 = less(r0F62, r0F31);
                     ir_expression *const r0F64 = expr(ir_unop_b2i, r0F63);
                     ir_expression *const r0F65 = expr(ir_unop_i2u, r0F64);
                     body.emit(assign(r0F30, add(r0F30, r0F65), 0x01));

                     ir_expression *const r0F66 = equal(r0F32, body.constant(0u));
                     ir_expression *const r0F67 = expr(ir_unop_b2i, r0F66);
                     ir_expression *const r0F68 = expr(ir_unop_i2u, r0F67);
                     ir_expression *const r0F69 = add(r0F32, r0F68);
                     ir_expression *const r0F6A = bit_and(r0F69, body.constant(1u));
                     ir_expression *const r0F6B = expr(ir_unop_bit_not, r0F6A);
                     body.emit(assign(r0F31, bit_and(r0F62, r0F6B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F61->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F6D = bit_or(r0F30, r0F31);
                     ir_expression *const r0F6E = equal(r0F6D, body.constant(0u));
                     ir_if *f0F6C = new(mem_ctx) ir_if(operand(r0F6E).val);
                     exec_list *const f0F6C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F6C->then_instructions;

                        body.emit(assign(r0F2F, body.constant(int(0)), 0x01));


                     body.instructions = f0F6C_parent_instructions;
                     body.emit(f0F6C);

                     /* END IF */


                  body.instructions = f0F61_parent_instructions;
                  body.emit(f0F61);

                  /* END IF */

                  ir_variable *const r0F6F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0F6F);
                  ir_expression *const r0F70 = lshift(r0DB6, body.constant(int(31)));
                  ir_expression *const r0F71 = expr(ir_unop_i2u, r0F2F);
                  ir_expression *const r0F72 = lshift(r0F71, body.constant(int(20)));
                  ir_expression *const r0F73 = add(r0F70, r0F72);
                  body.emit(assign(r0F6F, add(r0F73, r0F30), 0x02));

                  body.emit(assign(r0F6F, r0F31, 0x01));

                  body.emit(assign(r0F34, r0F6F, 0x03));

                  body.emit(assign(r0F33, body.constant(false), 0x01));


               body.instructions = f0F60_parent_instructions;
               body.emit(f0F60);

               /* END IF */

               body.emit(assign(r0DB7, r0F34, 0x03));


            body.instructions = f0EA2_parent_instructions;
            body.emit(f0EA2);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0EA0->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0F75 = equal(r0DC0, body.constant(int(2047)));
            ir_if *f0F74 = new(mem_ctx) ir_if(operand(r0F75).val);
            exec_list *const f0F74_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0F74->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0F77 = bit_or(r0DBD, r0DBE);
               ir_expression *const r0F78 = bit_or(r0DBB, r0DBC);
               ir_expression *const r0F79 = bit_or(r0F77, r0F78);
               ir_expression *const r0F7A = nequal(r0F79, body.constant(0u));
               ir_if *f0F76 = new(mem_ctx) ir_if(operand(r0F7A).val);
               exec_list *const f0F76_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F76->then_instructions;

                  ir_variable *const r0F7B = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0F7B, swizzle_x(r0DAF), 0x01));

                  ir_variable *const r0F7C = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0F7C, swizzle_x(r0DB0), 0x01));

                  ir_variable *const r0F7D = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0F7E = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0F7F = rshift(swizzle_y(r0DAF), body.constant(int(19)));
                  ir_expression *const r0F80 = bit_and(r0F7F, body.constant(4095u));
                  ir_expression *const r0F81 = equal(r0F80, body.constant(4094u));
                  ir_expression *const r0F82 = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r0F83 = bit_and(swizzle_y(r0DAF), body.constant(524287u));
                  ir_expression *const r0F84 = nequal(r0F83, body.constant(0u));
                  ir_expression *const r0F85 = logic_or(r0F82, r0F84);
                  body.emit(assign(r0F7E, logic_and(r0F81, r0F85), 0x01));

                  ir_variable *const r0F86 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0F87 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
                  ir_expression *const r0F88 = lequal(body.constant(4292870144u), r0F87);
                  ir_expression *const r0F89 = nequal(swizzle_x(r0DB0), body.constant(0u));
                  ir_expression *const r0F8A = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
                  ir_expression *const r0F8B = nequal(r0F8A, body.constant(0u));
                  ir_expression *const r0F8C = logic_or(r0F89, r0F8B);
                  body.emit(assign(r0F86, logic_and(r0F88, r0F8C), 0x01));

                  body.emit(assign(r0F7B, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

                  body.emit(assign(r0F7C, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0F8E = lshift(swizzle_y(r0DAF), body.constant(int(1)));
                  ir_expression *const r0F8F = lequal(body.constant(4292870144u), r0F8E);
                  ir_expression *const r0F90 = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r0F91 = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
                  ir_expression *const r0F92 = nequal(r0F91, body.constant(0u));
                  ir_expression *const r0F93 = logic_or(r0F90, r0F92);
                  ir_expression *const r0F94 = logic_and(r0F8F, r0F93);
                  ir_if *f0F8D = new(mem_ctx) ir_if(operand(r0F94).val);
                  exec_list *const f0F8D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F8D->then_instructions;

                     ir_variable *const r0F95 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F97 = logic_and(r0F7E, r0F86);
                     ir_if *f0F96 = new(mem_ctx) ir_if(operand(r0F97).val);
                     exec_list *const f0F96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F96->then_instructions;

                        body.emit(assign(r0F95, r0F7C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F96->else_instructions;

                        body.emit(assign(r0F95, r0F7B, 0x03));


                     body.instructions = f0F96_parent_instructions;
                     body.emit(f0F96);

                     /* END IF */

                     body.emit(assign(r0F7D, r0F95, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F8D->else_instructions;

                     body.emit(assign(r0F7D, r0F7C, 0x03));


                  body.instructions = f0F8D_parent_instructions;
                  body.emit(f0F8D);

                  /* END IF */

                  body.emit(assign(r0DB7, r0F7D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F76->else_instructions;

                  ir_constant_data r0F98_data;
                  memset(&r0F98_data, 0, sizeof(ir_constant_data));
                  r0F98_data.u[0] = 4294967295;
                  r0F98_data.u[1] = 4294967295;
                  ir_constant *const r0F98 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0F98_data);
                  body.emit(assign(r0DB7, r0F98, 0x03));


               body.instructions = f0F76_parent_instructions;
               body.emit(f0F76);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0F74->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0F9A = equal(r0DC0, body.constant(int(0)));
               ir_if *f0F99 = new(mem_ctx) ir_if(operand(r0F9A).val);
               exec_list *const f0F99_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F99->then_instructions;

                  body.emit(assign(r0DBA, body.constant(int(1)), 0x01));

                  body.emit(assign(r0DB9, body.constant(int(1)), 0x01));


               body.instructions = f0F99_parent_instructions;
               body.emit(f0F99);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0F9C = less(r0DBB, r0DBD);
               ir_if *f0F9B = new(mem_ctx) ir_if(operand(r0F9C).val);
               exec_list *const f0F9B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F9B->then_instructions;

                  ir_variable *const r0F9D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0F9E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0F9E, sub(r0DBE, r0DBC), 0x01));

                  ir_expression *const r0F9F = sub(r0DBD, r0DBB);
                  ir_expression *const r0FA0 = less(r0DBE, r0DBC);
                  ir_expression *const r0FA1 = expr(ir_unop_b2i, r0FA0);
                  ir_expression *const r0FA2 = expr(ir_unop_i2u, r0FA1);
                  body.emit(assign(r0F9D, sub(r0F9F, r0FA2), 0x01));

                  body.emit(assign(r0DBF, add(r0DBA, body.constant(int(-1))), 0x01));

                  ir_variable *const r0FA3 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0FA3, add(r0DBF, body.constant(int(-10))), 0x01));

                  ir_variable *const r0FA4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0FA4, r0F9D, 0x01));

                  ir_variable *const r0FA5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0FA5, r0F9E, 0x01));

                  ir_variable *const r0FA6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0FA6);
                  ir_variable *const r0FA7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0FA7);
                  /* IF CONDITION */
                  ir_expression *const r0FA9 = equal(r0F9D, body.constant(0u));
                  ir_if *f0FA8 = new(mem_ctx) ir_if(operand(r0FA9).val);
                  exec_list *const f0FA8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FA8->then_instructions;

                     body.emit(assign(r0FA4, r0F9E, 0x01));

                     body.emit(assign(r0FA5, body.constant(0u), 0x01));

                     body.emit(assign(r0FA3, add(r0FA3, body.constant(int(-32))), 0x01));


                  body.instructions = f0FA8_parent_instructions;
                  body.emit(f0FA8);

                  /* END IF */

                  ir_variable *const r0FAA = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0FAA, r0FA4, 0x01));

                  ir_variable *const r0FAB = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0FAC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0FAC);
                  /* IF CONDITION */
                  ir_expression *const r0FAE = equal(r0FA4, body.constant(0u));
                  ir_if *f0FAD = new(mem_ctx) ir_if(operand(r0FAE).val);
                  exec_list *const f0FAD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FAD->then_instructions;

                     body.emit(assign(r0FAB, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FAD->else_instructions;

                     body.emit(assign(r0FAC, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0FB0 = bit_and(r0FA4, body.constant(4294901760u));
                     ir_expression *const r0FB1 = equal(r0FB0, body.constant(0u));
                     ir_if *f0FAF = new(mem_ctx) ir_if(operand(r0FB1).val);
                     exec_list *const f0FAF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FAF->then_instructions;

                        body.emit(assign(r0FAC, body.constant(int(16)), 0x01));

                        body.emit(assign(r0FAA, lshift(r0FA4, body.constant(int(16))), 0x01));


                     body.instructions = f0FAF_parent_instructions;
                     body.emit(f0FAF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FB3 = bit_and(r0FAA, body.constant(4278190080u));
                     ir_expression *const r0FB4 = equal(r0FB3, body.constant(0u));
                     ir_if *f0FB2 = new(mem_ctx) ir_if(operand(r0FB4).val);
                     exec_list *const f0FB2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB2->then_instructions;

                        body.emit(assign(r0FAC, add(r0FAC, body.constant(int(8))), 0x01));

                        body.emit(assign(r0FAA, lshift(r0FAA, body.constant(int(8))), 0x01));


                     body.instructions = f0FB2_parent_instructions;
                     body.emit(f0FB2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FB6 = bit_and(r0FAA, body.constant(4026531840u));
                     ir_expression *const r0FB7 = equal(r0FB6, body.constant(0u));
                     ir_if *f0FB5 = new(mem_ctx) ir_if(operand(r0FB7).val);
                     exec_list *const f0FB5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB5->then_instructions;

                        body.emit(assign(r0FAC, add(r0FAC, body.constant(int(4))), 0x01));

                        body.emit(assign(r0FAA, lshift(r0FAA, body.constant(int(4))), 0x01));


                     body.instructions = f0FB5_parent_instructions;
                     body.emit(f0FB5);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FB9 = bit_and(r0FAA, body.constant(3221225472u));
                     ir_expression *const r0FBA = equal(r0FB9, body.constant(0u));
                     ir_if *f0FB8 = new(mem_ctx) ir_if(operand(r0FBA).val);
                     exec_list *const f0FB8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB8->then_instructions;

                        body.emit(assign(r0FAC, add(r0FAC, body.constant(int(2))), 0x01));

                        body.emit(assign(r0FAA, lshift(r0FAA, body.constant(int(2))), 0x01));


                     body.instructions = f0FB8_parent_instructions;
                     body.emit(f0FB8);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FBC = bit_and(r0FAA, body.constant(2147483648u));
                     ir_expression *const r0FBD = equal(r0FBC, body.constant(0u));
                     ir_if *f0FBB = new(mem_ctx) ir_if(operand(r0FBD).val);
                     exec_list *const f0FBB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FBB->then_instructions;

                        body.emit(assign(r0FAC, add(r0FAC, body.constant(int(1))), 0x01));


                     body.instructions = f0FBB_parent_instructions;
                     body.emit(f0FBB);

                     /* END IF */

                     body.emit(assign(r0FAB, r0FAC, 0x01));


                  body.instructions = f0FAD_parent_instructions;
                  body.emit(f0FAD);

                  /* END IF */

                  body.emit(assign(r0FA7, add(r0FAB, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0FBF = lequal(body.constant(int(0)), r0FA7);
                  ir_if *f0FBE = new(mem_ctx) ir_if(operand(r0FBF).val);
                  exec_list *const f0FBE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FBE->then_instructions;

                     body.emit(assign(r0FA6, body.constant(0u), 0x01));

                     ir_variable *const r0FC0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0FC0, lshift(r0FA5, r0FA7), 0x01));

                     ir_variable *const r0FC1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FC3 = equal(r0FA7, body.constant(int(0)));
                     ir_if *f0FC2 = new(mem_ctx) ir_if(operand(r0FC3).val);
                     exec_list *const f0FC2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FC2->then_instructions;

                        body.emit(assign(r0FC1, r0FA4, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FC2->else_instructions;

                        ir_expression *const r0FC4 = lshift(r0FA4, r0FA7);
                        ir_expression *const r0FC5 = neg(r0FA7);
                        ir_expression *const r0FC6 = bit_and(r0FC5, body.constant(int(31)));
                        ir_expression *const r0FC7 = rshift(r0FA5, r0FC6);
                        body.emit(assign(r0FC1, bit_or(r0FC4, r0FC7), 0x01));


                     body.instructions = f0FC2_parent_instructions;
                     body.emit(f0FC2);

                     /* END IF */

                     body.emit(assign(r0FA4, r0FC1, 0x01));

                     body.emit(assign(r0FA5, r0FC0, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FBE->else_instructions;

                     ir_variable *const r0FC8 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0FC8, body.constant(0u), 0x01));

                     ir_variable *const r0FC9 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0FC9, neg(r0FA7), 0x01));

                     ir_variable *const r0FCA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0FCA);
                     ir_variable *const r0FCB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0FCB);
                     ir_variable *const r0FCC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0FCC);
                     ir_variable *const r0FCD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0FCE = neg(r0FC9);
                     body.emit(assign(r0FCD, bit_and(r0FCE, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0FD0 = equal(r0FC9, body.constant(int(0)));
                     ir_if *f0FCF = new(mem_ctx) ir_if(operand(r0FD0).val);
                     exec_list *const f0FCF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FCF->then_instructions;

                        body.emit(assign(r0FCA, r0FC8, 0x01));

                        body.emit(assign(r0FCB, r0FA5, 0x01));

                        body.emit(assign(r0FCC, r0FA4, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FCF->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0FD2 = less(r0FC9, body.constant(int(32)));
                        ir_if *f0FD1 = new(mem_ctx) ir_if(operand(r0FD2).val);
                        exec_list *const f0FD1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FD1->then_instructions;

                           body.emit(assign(r0FCA, lshift(r0FA5, r0FCD), 0x01));

                           ir_expression *const r0FD3 = lshift(r0FA4, r0FCD);
                           ir_expression *const r0FD4 = rshift(r0FA5, r0FC9);
                           body.emit(assign(r0FCB, bit_or(r0FD3, r0FD4), 0x01));

                           body.emit(assign(r0FCC, rshift(r0FA4, r0FC9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FD1->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0FD6 = equal(r0FC9, body.constant(int(32)));
                           ir_if *f0FD5 = new(mem_ctx) ir_if(operand(r0FD6).val);
                           exec_list *const f0FD5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0FD5->then_instructions;

                              body.emit(assign(r0FCA, r0FA5, 0x01));

                              body.emit(assign(r0FCB, r0FA4, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0FD5->else_instructions;

                              body.emit(assign(r0FC8, bit_or(body.constant(0u), r0FA5), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0FD8 = less(r0FC9, body.constant(int(64)));
                              ir_if *f0FD7 = new(mem_ctx) ir_if(operand(r0FD8).val);
                              exec_list *const f0FD7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0FD7->then_instructions;

                                 body.emit(assign(r0FCA, lshift(r0FA4, r0FCD), 0x01));

                                 ir_expression *const r0FD9 = bit_and(r0FC9, body.constant(int(31)));
                                 body.emit(assign(r0FCB, rshift(r0FA4, r0FD9), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0FD7->else_instructions;

                                 ir_variable *const r0FDA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0FDC = equal(r0FC9, body.constant(int(64)));
                                 ir_if *f0FDB = new(mem_ctx) ir_if(operand(r0FDC).val);
                                 exec_list *const f0FDB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0FDB->then_instructions;

                                    body.emit(assign(r0FDA, r0FA4, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0FDB->else_instructions;

                                    ir_expression *const r0FDD = nequal(r0FA4, body.constant(0u));
                                    ir_expression *const r0FDE = expr(ir_unop_b2i, r0FDD);
                                    body.emit(assign(r0FDA, expr(ir_unop_i2u, r0FDE), 0x01));


                                 body.instructions = f0FDB_parent_instructions;
                                 body.emit(f0FDB);

                                 /* END IF */

                                 body.emit(assign(r0FCA, r0FDA, 0x01));

                                 body.emit(assign(r0FCB, body.constant(0u), 0x01));


                              body.instructions = f0FD7_parent_instructions;
                              body.emit(f0FD7);

                              /* END IF */


                           body.instructions = f0FD5_parent_instructions;
                           body.emit(f0FD5);

                           /* END IF */

                           body.emit(assign(r0FCC, body.constant(0u), 0x01));


                        body.instructions = f0FD1_parent_instructions;
                        body.emit(f0FD1);

                        /* END IF */

                        ir_expression *const r0FDF = nequal(r0FC8, body.constant(0u));
                        ir_expression *const r0FE0 = expr(ir_unop_b2i, r0FDF);
                        ir_expression *const r0FE1 = expr(ir_unop_i2u, r0FE0);
                        body.emit(assign(r0FCA, bit_or(r0FCA, r0FE1), 0x01));


                     body.instructions = f0FCF_parent_instructions;
                     body.emit(f0FCF);

                     /* END IF */

                     body.emit(assign(r0FA4, r0FCC, 0x01));

                     body.emit(assign(r0FA5, r0FCB, 0x01));

                     body.emit(assign(r0FA6, r0FCA, 0x01));


                  body.instructions = f0FBE_parent_instructions;
                  body.emit(f0FBE);

                  /* END IF */

                  body.emit(assign(r0FA3, sub(r0FA3, r0FA7), 0x01));

                  ir_variable *const r0FE2 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0FE2, r0FA3, 0x01));

                  ir_variable *const r0FE3 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0FE3, r0FA4, 0x01));

                  ir_variable *const r0FE4 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0FE4, r0FA5, 0x01));

                  ir_variable *const r0FE5 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0FE5, r0FA6, 0x01));

                  ir_variable *const r0FE6 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0FE6, body.constant(true), 0x01));

                  ir_variable *const r0FE7 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0FE8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0FE8);
                  ir_expression *const r0FE9 = expr(ir_unop_u2i, r0FA6);
                  body.emit(assign(r0FE8, less(r0FE9, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0FEB = lequal(body.constant(int(2045)), r0FA3);
                  ir_if *f0FEA = new(mem_ctx) ir_if(operand(r0FEB).val);
                  exec_list *const f0FEA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FEA->then_instructions;

                     ir_variable *const r0FEC = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FEE = less(body.constant(int(2045)), r0FA3);
                     ir_if *f0FED = new(mem_ctx) ir_if(operand(r0FEE).val);
                     exec_list *const f0FED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FED->then_instructions;

                        body.emit(assign(r0FEC, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FED->else_instructions;

                        ir_variable *const r0FEF = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0FF1 = equal(r0FA3, body.constant(int(2045)));
                        ir_if *f0FF0 = new(mem_ctx) ir_if(operand(r0FF1).val);
                        exec_list *const f0FF0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FF0->then_instructions;

                           ir_expression *const r0FF2 = equal(body.constant(2097151u), r0FA4);
                           ir_expression *const r0FF3 = equal(body.constant(4294967295u), r0FA5);
                           body.emit(assign(r0FEF, logic_and(r0FF2, r0FF3), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FF0->else_instructions;

                           body.emit(assign(r0FEF, body.constant(false), 0x01));


                        body.instructions = f0FF0_parent_instructions;
                        body.emit(f0FF0);

                        /* END IF */

                        body.emit(assign(r0FEC, logic_and(r0FEF, r0FE8), 0x01));


                     body.instructions = f0FED_parent_instructions;
                     body.emit(f0FED);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0FF4 = new(mem_ctx) ir_if(operand(r0FEC).val);
                     exec_list *const f0FF4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FF4->then_instructions;

                        ir_variable *const r0FF5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0FF5);
                        ir_expression *const r0FF6 = lshift(r0DB6, body.constant(int(31)));
                        body.emit(assign(r0FF5, add(r0FF6, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0FF5, body.constant(0u), 0x01));

                        body.emit(assign(r0FE7, r0FF5, 0x03));

                        body.emit(assign(r0FE6, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FF4->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0FF8 = less(r0FA3, body.constant(int(0)));
                        ir_if *f0FF7 = new(mem_ctx) ir_if(operand(r0FF8).val);
                        exec_list *const f0FF7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FF7->then_instructions;

                           ir_variable *const r0FF9 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0FF9, r0FA6, 0x01));

                           ir_variable *const r0FFA = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0FFA, neg(r0FA3), 0x01));

                           ir_variable *const r0FFB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0FFB);
                           ir_variable *const r0FFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0FFC);
                           ir_variable *const r0FFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0FFD);
                           ir_variable *const r0FFE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0FFF = neg(r0FFA);
                           body.emit(assign(r0FFE, bit_and(r0FFF, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1001 = equal(r0FFA, body.constant(int(0)));
                           ir_if *f1000 = new(mem_ctx) ir_if(operand(r1001).val);
                           exec_list *const f1000_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1000->then_instructions;

                              body.emit(assign(r0FFB, r0FA6, 0x01));

                              body.emit(assign(r0FFC, r0FA5, 0x01));

                              body.emit(assign(r0FFD, r0FA4, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1000->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1003 = less(r0FFA, body.constant(int(32)));
                              ir_if *f1002 = new(mem_ctx) ir_if(operand(r1003).val);
                              exec_list *const f1002_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1002->then_instructions;

                                 body.emit(assign(r0FFB, lshift(r0FA5, r0FFE), 0x01));

                                 ir_expression *const r1004 = lshift(r0FA4, r0FFE);
                                 ir_expression *const r1005 = rshift(r0FA5, r0FFA);
                                 body.emit(assign(r0FFC, bit_or(r1004, r1005), 0x01));

                                 body.emit(assign(r0FFD, rshift(r0FA4, r0FFA), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1002->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1007 = equal(r0FFA, body.constant(int(32)));
                                 ir_if *f1006 = new(mem_ctx) ir_if(operand(r1007).val);
                                 exec_list *const f1006_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1006->then_instructions;

                                    body.emit(assign(r0FFB, r0FA5, 0x01));

                                    body.emit(assign(r0FFC, r0FA4, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1006->else_instructions;

                                    body.emit(assign(r0FF9, bit_or(r0FA6, r0FA5), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1009 = less(r0FFA, body.constant(int(64)));
                                    ir_if *f1008 = new(mem_ctx) ir_if(operand(r1009).val);
                                    exec_list *const f1008_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1008->then_instructions;

                                       body.emit(assign(r0FFB, lshift(r0FA4, r0FFE), 0x01));

                                       ir_expression *const r100A = bit_and(r0FFA, body.constant(int(31)));
                                       body.emit(assign(r0FFC, rshift(r0FA4, r100A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1008->else_instructions;

                                       ir_variable *const r100B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r100D = equal(r0FFA, body.constant(int(64)));
                                       ir_if *f100C = new(mem_ctx) ir_if(operand(r100D).val);
                                       exec_list *const f100C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f100C->then_instructions;

                                          body.emit(assign(r100B, r0FA4, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f100C->else_instructions;

                                          ir_expression *const r100E = nequal(r0FA4, body.constant(0u));
                                          ir_expression *const r100F = expr(ir_unop_b2i, r100E);
                                          body.emit(assign(r100B, expr(ir_unop_i2u, r100F), 0x01));


                                       body.instructions = f100C_parent_instructions;
                                       body.emit(f100C);

                                       /* END IF */

                                       body.emit(assign(r0FFB, r100B, 0x01));

                                       body.emit(assign(r0FFC, body.constant(0u), 0x01));


                                    body.instructions = f1008_parent_instructions;
                                    body.emit(f1008);

                                    /* END IF */


                                 body.instructions = f1006_parent_instructions;
                                 body.emit(f1006);

                                 /* END IF */

                                 body.emit(assign(r0FFD, body.constant(0u), 0x01));


                              body.instructions = f1002_parent_instructions;
                              body.emit(f1002);

                              /* END IF */

                              ir_expression *const r1010 = nequal(r0FF9, body.constant(0u));
                              ir_expression *const r1011 = expr(ir_unop_b2i, r1010);
                              ir_expression *const r1012 = expr(ir_unop_i2u, r1011);
                              body.emit(assign(r0FFB, bit_or(r0FFB, r1012), 0x01));


                           body.instructions = f1000_parent_instructions;
                           body.emit(f1000);

                           /* END IF */

                           body.emit(assign(r0FE3, r0FFD, 0x01));

                           body.emit(assign(r0FE4, r0FFC, 0x01));

                           body.emit(assign(r0FE5, r0FFB, 0x01));

                           body.emit(assign(r0FE2, body.constant(int(0)), 0x01));

                           body.emit(assign(r0FE8, less(r0FFB, body.constant(0u)), 0x01));


                        body.instructions = f0FF7_parent_instructions;
                        body.emit(f0FF7);

                        /* END IF */


                     body.instructions = f0FF4_parent_instructions;
                     body.emit(f0FF4);

                     /* END IF */


                  body.instructions = f0FEA_parent_instructions;
                  body.emit(f0FEA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1013 = new(mem_ctx) ir_if(operand(r0FE6).val);
                  exec_list *const f1013_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1013->then_instructions;

                     /* IF CONDITION */
                     ir_if *f1014 = new(mem_ctx) ir_if(operand(r0FE8).val);
                     exec_list *const f1014_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1014->then_instructions;

                        ir_variable *const r1015 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r1015, add(r0FE4, body.constant(1u)), 0x01));

                        ir_expression *const r1016 = less(r1015, r0FE4);
                        ir_expression *const r1017 = expr(ir_unop_b2i, r1016);
                        ir_expression *const r1018 = expr(ir_unop_i2u, r1017);
                        body.emit(assign(r0FE3, add(r0FE3, r1018), 0x01));

                        ir_expression *const r1019 = equal(r0FE5, body.constant(0u));
                        ir_expression *const r101A = expr(ir_unop_b2i, r1019);
                        ir_expression *const r101B = expr(ir_unop_i2u, r101A);
                        ir_expression *const r101C = add(r0FE5, r101B);
                        ir_expression *const r101D = bit_and(r101C, body.constant(1u));
                        ir_expression *const r101E = expr(ir_unop_bit_not, r101D);
                        body.emit(assign(r0FE4, bit_and(r1015, r101E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1014->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1020 = bit_or(r0FE3, r0FE4);
                        ir_expression *const r1021 = equal(r1020, body.constant(0u));
                        ir_if *f101F = new(mem_ctx) ir_if(operand(r1021).val);
                        exec_list *const f101F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f101F->then_instructions;

                           body.emit(assign(r0FE2, body.constant(int(0)), 0x01));


                        body.instructions = f101F_parent_instructions;
                        body.emit(f101F);

                        /* END IF */


                     body.instructions = f1014_parent_instructions;
                     body.emit(f1014);

                     /* END IF */

                     ir_variable *const r1022 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1022);
                     ir_expression *const r1023 = lshift(r0DB6, body.constant(int(31)));
                     ir_expression *const r1024 = expr(ir_unop_i2u, r0FE2);
                     ir_expression *const r1025 = lshift(r1024, body.constant(int(20)));
                     ir_expression *const r1026 = add(r1023, r1025);
                     body.emit(assign(r1022, add(r1026, r0FE3), 0x02));

                     body.emit(assign(r1022, r0FE4, 0x01));

                     body.emit(assign(r0FE7, r1022, 0x03));

                     body.emit(assign(r0FE6, body.constant(false), 0x01));


                  body.instructions = f1013_parent_instructions;
                  body.emit(f1013);

                  /* END IF */

                  body.emit(assign(r0DB7, r0FE7, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F9B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1028 = less(r0DBD, r0DBB);
                  ir_if *f1027 = new(mem_ctx) ir_if(operand(r1028).val);
                  exec_list *const f1027_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1027->then_instructions;

                     ir_variable *const r1029 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r102A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r102A, sub(r0DBC, r0DBE), 0x01));

                     ir_expression *const r102B = sub(r0DBB, r0DBD);
                     ir_expression *const r102C = less(r0DBC, r0DBE);
                     ir_expression *const r102D = expr(ir_unop_b2i, r102C);
                     ir_expression *const r102E = expr(ir_unop_i2u, r102D);
                     body.emit(assign(r1029, sub(r102B, r102E), 0x01));

                     body.emit(assign(r0DB6, bit_xor(r0DB6, body.constant(1u)), 0x01));

                     body.emit(assign(r0DBF, add(r0DB9, body.constant(int(-1))), 0x01));

                     ir_variable *const r102F = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r102F, add(r0DBF, body.constant(int(-10))), 0x01));

                     ir_variable *const r1030 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1030, r1029, 0x01));

                     ir_variable *const r1031 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1031, r102A, 0x01));

                     ir_variable *const r1032 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r1032);
                     ir_variable *const r1033 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1033);
                     /* IF CONDITION */
                     ir_expression *const r1035 = equal(r1029, body.constant(0u));
                     ir_if *f1034 = new(mem_ctx) ir_if(operand(r1035).val);
                     exec_list *const f1034_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1034->then_instructions;

                        body.emit(assign(r1030, r102A, 0x01));

                        body.emit(assign(r1031, body.constant(0u), 0x01));

                        body.emit(assign(r102F, add(r102F, body.constant(int(-32))), 0x01));


                     body.instructions = f1034_parent_instructions;
                     body.emit(f1034);

                     /* END IF */

                     ir_variable *const r1036 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1036, r1030, 0x01));

                     ir_variable *const r1037 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1038 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1038);
                     /* IF CONDITION */
                     ir_expression *const r103A = equal(r1030, body.constant(0u));
                     ir_if *f1039 = new(mem_ctx) ir_if(operand(r103A).val);
                     exec_list *const f1039_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1039->then_instructions;

                        body.emit(assign(r1037, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1039->else_instructions;

                        body.emit(assign(r1038, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r103C = bit_and(r1030, body.constant(4294901760u));
                        ir_expression *const r103D = equal(r103C, body.constant(0u));
                        ir_if *f103B = new(mem_ctx) ir_if(operand(r103D).val);
                        exec_list *const f103B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f103B->then_instructions;

                           body.emit(assign(r1038, body.constant(int(16)), 0x01));

                           body.emit(assign(r1036, lshift(r1030, body.constant(int(16))), 0x01));


                        body.instructions = f103B_parent_instructions;
                        body.emit(f103B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r103F = bit_and(r1036, body.constant(4278190080u));
                        ir_expression *const r1040 = equal(r103F, body.constant(0u));
                        ir_if *f103E = new(mem_ctx) ir_if(operand(r1040).val);
                        exec_list *const f103E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f103E->then_instructions;

                           body.emit(assign(r1038, add(r1038, body.constant(int(8))), 0x01));

                           body.emit(assign(r1036, lshift(r1036, body.constant(int(8))), 0x01));


                        body.instructions = f103E_parent_instructions;
                        body.emit(f103E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1042 = bit_and(r1036, body.constant(4026531840u));
                        ir_expression *const r1043 = equal(r1042, body.constant(0u));
                        ir_if *f1041 = new(mem_ctx) ir_if(operand(r1043).val);
                        exec_list *const f1041_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1041->then_instructions;

                           body.emit(assign(r1038, add(r1038, body.constant(int(4))), 0x01));

                           body.emit(assign(r1036, lshift(r1036, body.constant(int(4))), 0x01));


                        body.instructions = f1041_parent_instructions;
                        body.emit(f1041);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1045 = bit_and(r1036, body.constant(3221225472u));
                        ir_expression *const r1046 = equal(r1045, body.constant(0u));
                        ir_if *f1044 = new(mem_ctx) ir_if(operand(r1046).val);
                        exec_list *const f1044_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1044->then_instructions;

                           body.emit(assign(r1038, add(r1038, body.constant(int(2))), 0x01));

                           body.emit(assign(r1036, lshift(r1036, body.constant(int(2))), 0x01));


                        body.instructions = f1044_parent_instructions;
                        body.emit(f1044);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1048 = bit_and(r1036, body.constant(2147483648u));
                        ir_expression *const r1049 = equal(r1048, body.constant(0u));
                        ir_if *f1047 = new(mem_ctx) ir_if(operand(r1049).val);
                        exec_list *const f1047_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1047->then_instructions;

                           body.emit(assign(r1038, add(r1038, body.constant(int(1))), 0x01));


                        body.instructions = f1047_parent_instructions;
                        body.emit(f1047);

                        /* END IF */

                        body.emit(assign(r1037, r1038, 0x01));


                     body.instructions = f1039_parent_instructions;
                     body.emit(f1039);

                     /* END IF */

                     body.emit(assign(r1033, add(r1037, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r104B = lequal(body.constant(int(0)), r1033);
                     ir_if *f104A = new(mem_ctx) ir_if(operand(r104B).val);
                     exec_list *const f104A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f104A->then_instructions;

                        body.emit(assign(r1032, body.constant(0u), 0x01));

                        ir_variable *const r104C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r104C, lshift(r1031, r1033), 0x01));

                        ir_variable *const r104D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r104F = equal(r1033, body.constant(int(0)));
                        ir_if *f104E = new(mem_ctx) ir_if(operand(r104F).val);
                        exec_list *const f104E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f104E->then_instructions;

                           body.emit(assign(r104D, r1030, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f104E->else_instructions;

                           ir_expression *const r1050 = lshift(r1030, r1033);
                           ir_expression *const r1051 = neg(r1033);
                           ir_expression *const r1052 = bit_and(r1051, body.constant(int(31)));
                           ir_expression *const r1053 = rshift(r1031, r1052);
                           body.emit(assign(r104D, bit_or(r1050, r1053), 0x01));


                        body.instructions = f104E_parent_instructions;
                        body.emit(f104E);

                        /* END IF */

                        body.emit(assign(r1030, r104D, 0x01));

                        body.emit(assign(r1031, r104C, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f104A->else_instructions;

                        ir_variable *const r1054 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1054, body.constant(0u), 0x01));

                        ir_variable *const r1055 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1055, neg(r1033), 0x01));

                        ir_variable *const r1056 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1056);
                        ir_variable *const r1057 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1057);
                        ir_variable *const r1058 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1058);
                        ir_variable *const r1059 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r105A = neg(r1055);
                        body.emit(assign(r1059, bit_and(r105A, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r105C = equal(r1055, body.constant(int(0)));
                        ir_if *f105B = new(mem_ctx) ir_if(operand(r105C).val);
                        exec_list *const f105B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f105B->then_instructions;

                           body.emit(assign(r1056, r1054, 0x01));

                           body.emit(assign(r1057, r1031, 0x01));

                           body.emit(assign(r1058, r1030, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f105B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r105E = less(r1055, body.constant(int(32)));
                           ir_if *f105D = new(mem_ctx) ir_if(operand(r105E).val);
                           exec_list *const f105D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f105D->then_instructions;

                              body.emit(assign(r1056, lshift(r1031, r1059), 0x01));

                              ir_expression *const r105F = lshift(r1030, r1059);
                              ir_expression *const r1060 = rshift(r1031, r1055);
                              body.emit(assign(r1057, bit_or(r105F, r1060), 0x01));

                              body.emit(assign(r1058, rshift(r1030, r1055), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f105D->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1062 = equal(r1055, body.constant(int(32)));
                              ir_if *f1061 = new(mem_ctx) ir_if(operand(r1062).val);
                              exec_list *const f1061_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1061->then_instructions;

                                 body.emit(assign(r1056, r1031, 0x01));

                                 body.emit(assign(r1057, r1030, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1061->else_instructions;

                                 body.emit(assign(r1054, bit_or(body.constant(0u), r1031), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1064 = less(r1055, body.constant(int(64)));
                                 ir_if *f1063 = new(mem_ctx) ir_if(operand(r1064).val);
                                 exec_list *const f1063_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1063->then_instructions;

                                    body.emit(assign(r1056, lshift(r1030, r1059), 0x01));

                                    ir_expression *const r1065 = bit_and(r1055, body.constant(int(31)));
                                    body.emit(assign(r1057, rshift(r1030, r1065), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1063->else_instructions;

                                    ir_variable *const r1066 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1068 = equal(r1055, body.constant(int(64)));
                                    ir_if *f1067 = new(mem_ctx) ir_if(operand(r1068).val);
                                    exec_list *const f1067_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1067->then_instructions;

                                       body.emit(assign(r1066, r1030, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1067->else_instructions;

                                       ir_expression *const r1069 = nequal(r1030, body.constant(0u));
                                       ir_expression *const r106A = expr(ir_unop_b2i, r1069);
                                       body.emit(assign(r1066, expr(ir_unop_i2u, r106A), 0x01));


                                    body.instructions = f1067_parent_instructions;
                                    body.emit(f1067);

                                    /* END IF */

                                    body.emit(assign(r1056, r1066, 0x01));

                                    body.emit(assign(r1057, body.constant(0u), 0x01));


                                 body.instructions = f1063_parent_instructions;
                                 body.emit(f1063);

                                 /* END IF */


                              body.instructions = f1061_parent_instructions;
                              body.emit(f1061);

                              /* END IF */

                              body.emit(assign(r1058, body.constant(0u), 0x01));


                           body.instructions = f105D_parent_instructions;
                           body.emit(f105D);

                           /* END IF */

                           ir_expression *const r106B = nequal(r1054, body.constant(0u));
                           ir_expression *const r106C = expr(ir_unop_b2i, r106B);
                           ir_expression *const r106D = expr(ir_unop_i2u, r106C);
                           body.emit(assign(r1056, bit_or(r1056, r106D), 0x01));


                        body.instructions = f105B_parent_instructions;
                        body.emit(f105B);

                        /* END IF */

                        body.emit(assign(r1030, r1058, 0x01));

                        body.emit(assign(r1031, r1057, 0x01));

                        body.emit(assign(r1032, r1056, 0x01));


                     body.instructions = f104A_parent_instructions;
                     body.emit(f104A);

                     /* END IF */

                     body.emit(assign(r102F, sub(r102F, r1033), 0x01));

                     ir_variable *const r106E = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r106E, r102F, 0x01));

                     ir_variable *const r106F = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r106F, r1030, 0x01));

                     ir_variable *const r1070 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1070, r1031, 0x01));

                     ir_variable *const r1071 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1071, r1032, 0x01));

                     ir_variable *const r1072 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1072, body.constant(true), 0x01));

                     ir_variable *const r1073 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1074 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1074);
                     ir_expression *const r1075 = expr(ir_unop_u2i, r1032);
                     body.emit(assign(r1074, less(r1075, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1077 = lequal(body.constant(int(2045)), r102F);
                     ir_if *f1076 = new(mem_ctx) ir_if(operand(r1077).val);
                     exec_list *const f1076_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1076->then_instructions;

                        ir_variable *const r1078 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r107A = less(body.constant(int(2045)), r102F);
                        ir_if *f1079 = new(mem_ctx) ir_if(operand(r107A).val);
                        exec_list *const f1079_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1079->then_instructions;

                           body.emit(assign(r1078, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1079->else_instructions;

                           ir_variable *const r107B = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r107D = equal(r102F, body.constant(int(2045)));
                           ir_if *f107C = new(mem_ctx) ir_if(operand(r107D).val);
                           exec_list *const f107C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f107C->then_instructions;

                              ir_expression *const r107E = equal(body.constant(2097151u), r1030);
                              ir_expression *const r107F = equal(body.constant(4294967295u), r1031);
                              body.emit(assign(r107B, logic_and(r107E, r107F), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f107C->else_instructions;

                              body.emit(assign(r107B, body.constant(false), 0x01));


                           body.instructions = f107C_parent_instructions;
                           body.emit(f107C);

                           /* END IF */

                           body.emit(assign(r1078, logic_and(r107B, r1074), 0x01));


                        body.instructions = f1079_parent_instructions;
                        body.emit(f1079);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1080 = new(mem_ctx) ir_if(operand(r1078).val);
                        exec_list *const f1080_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1080->then_instructions;

                           ir_variable *const r1081 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1081);
                           ir_expression *const r1082 = lshift(r0DB6, body.constant(int(31)));
                           body.emit(assign(r1081, add(r1082, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1081, body.constant(0u), 0x01));

                           body.emit(assign(r1073, r1081, 0x03));

                           body.emit(assign(r1072, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1080->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1084 = less(r102F, body.constant(int(0)));
                           ir_if *f1083 = new(mem_ctx) ir_if(operand(r1084).val);
                           exec_list *const f1083_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1083->then_instructions;

                              ir_variable *const r1085 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1085, r1032, 0x01));

                              ir_variable *const r1086 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1086, neg(r102F), 0x01));

                              ir_variable *const r1087 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1087);
                              ir_variable *const r1088 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1088);
                              ir_variable *const r1089 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1089);
                              ir_variable *const r108A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r108B = neg(r1086);
                              body.emit(assign(r108A, bit_and(r108B, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r108D = equal(r1086, body.constant(int(0)));
                              ir_if *f108C = new(mem_ctx) ir_if(operand(r108D).val);
                              exec_list *const f108C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f108C->then_instructions;

                                 body.emit(assign(r1087, r1032, 0x01));

                                 body.emit(assign(r1088, r1031, 0x01));

                                 body.emit(assign(r1089, r1030, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f108C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r108F = less(r1086, body.constant(int(32)));
                                 ir_if *f108E = new(mem_ctx) ir_if(operand(r108F).val);
                                 exec_list *const f108E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f108E->then_instructions;

                                    body.emit(assign(r1087, lshift(r1031, r108A), 0x01));

                                    ir_expression *const r1090 = lshift(r1030, r108A);
                                    ir_expression *const r1091 = rshift(r1031, r1086);
                                    body.emit(assign(r1088, bit_or(r1090, r1091), 0x01));

                                    body.emit(assign(r1089, rshift(r1030, r1086), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f108E->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1093 = equal(r1086, body.constant(int(32)));
                                    ir_if *f1092 = new(mem_ctx) ir_if(operand(r1093).val);
                                    exec_list *const f1092_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1092->then_instructions;

                                       body.emit(assign(r1087, r1031, 0x01));

                                       body.emit(assign(r1088, r1030, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1092->else_instructions;

                                       body.emit(assign(r1085, bit_or(r1032, r1031), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1095 = less(r1086, body.constant(int(64)));
                                       ir_if *f1094 = new(mem_ctx) ir_if(operand(r1095).val);
                                       exec_list *const f1094_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1094->then_instructions;

                                          body.emit(assign(r1087, lshift(r1030, r108A), 0x01));

                                          ir_expression *const r1096 = bit_and(r1086, body.constant(int(31)));
                                          body.emit(assign(r1088, rshift(r1030, r1096), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1094->else_instructions;

                                          ir_variable *const r1097 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1099 = equal(r1086, body.constant(int(64)));
                                          ir_if *f1098 = new(mem_ctx) ir_if(operand(r1099).val);
                                          exec_list *const f1098_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1098->then_instructions;

                                             body.emit(assign(r1097, r1030, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1098->else_instructions;

                                             ir_expression *const r109A = nequal(r1030, body.constant(0u));
                                             ir_expression *const r109B = expr(ir_unop_b2i, r109A);
                                             body.emit(assign(r1097, expr(ir_unop_i2u, r109B), 0x01));


                                          body.instructions = f1098_parent_instructions;
                                          body.emit(f1098);

                                          /* END IF */

                                          body.emit(assign(r1087, r1097, 0x01));

                                          body.emit(assign(r1088, body.constant(0u), 0x01));


                                       body.instructions = f1094_parent_instructions;
                                       body.emit(f1094);

                                       /* END IF */


                                    body.instructions = f1092_parent_instructions;
                                    body.emit(f1092);

                                    /* END IF */

                                    body.emit(assign(r1089, body.constant(0u), 0x01));


                                 body.instructions = f108E_parent_instructions;
                                 body.emit(f108E);

                                 /* END IF */

                                 ir_expression *const r109C = nequal(r1085, body.constant(0u));
                                 ir_expression *const r109D = expr(ir_unop_b2i, r109C);
                                 ir_expression *const r109E = expr(ir_unop_i2u, r109D);
                                 body.emit(assign(r1087, bit_or(r1087, r109E), 0x01));


                              body.instructions = f108C_parent_instructions;
                              body.emit(f108C);

                              /* END IF */

                              body.emit(assign(r106F, r1089, 0x01));

                              body.emit(assign(r1070, r1088, 0x01));

                              body.emit(assign(r1071, r1087, 0x01));

                              body.emit(assign(r106E, body.constant(int(0)), 0x01));

                              body.emit(assign(r1074, less(r1087, body.constant(0u)), 0x01));


                           body.instructions = f1083_parent_instructions;
                           body.emit(f1083);

                           /* END IF */


                        body.instructions = f1080_parent_instructions;
                        body.emit(f1080);

                        /* END IF */


                     body.instructions = f1076_parent_instructions;
                     body.emit(f1076);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f109F = new(mem_ctx) ir_if(operand(r1072).val);
                     exec_list *const f109F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f109F->then_instructions;

                        /* IF CONDITION */
                        ir_if *f10A0 = new(mem_ctx) ir_if(operand(r1074).val);
                        exec_list *const f10A0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10A0->then_instructions;

                           ir_variable *const r10A1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r10A1, add(r1070, body.constant(1u)), 0x01));

                           ir_expression *const r10A2 = less(r10A1, r1070);
                           ir_expression *const r10A3 = expr(ir_unop_b2i, r10A2);
                           ir_expression *const r10A4 = expr(ir_unop_i2u, r10A3);
                           body.emit(assign(r106F, add(r106F, r10A4), 0x01));

                           ir_expression *const r10A5 = equal(r1071, body.constant(0u));
                           ir_expression *const r10A6 = expr(ir_unop_b2i, r10A5);
                           ir_expression *const r10A7 = expr(ir_unop_i2u, r10A6);
                           ir_expression *const r10A8 = add(r1071, r10A7);
                           ir_expression *const r10A9 = bit_and(r10A8, body.constant(1u));
                           ir_expression *const r10AA = expr(ir_unop_bit_not, r10A9);
                           body.emit(assign(r1070, bit_and(r10A1, r10AA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10A0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r10AC = bit_or(r106F, r1070);
                           ir_expression *const r10AD = equal(r10AC, body.constant(0u));
                           ir_if *f10AB = new(mem_ctx) ir_if(operand(r10AD).val);
                           exec_list *const f10AB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10AB->then_instructions;

                              body.emit(assign(r106E, body.constant(int(0)), 0x01));


                           body.instructions = f10AB_parent_instructions;
                           body.emit(f10AB);

                           /* END IF */


                        body.instructions = f10A0_parent_instructions;
                        body.emit(f10A0);

                        /* END IF */

                        ir_variable *const r10AE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r10AE);
                        ir_expression *const r10AF = lshift(r0DB6, body.constant(int(31)));
                        ir_expression *const r10B0 = expr(ir_unop_i2u, r106E);
                        ir_expression *const r10B1 = lshift(r10B0, body.constant(int(20)));
                        ir_expression *const r10B2 = add(r10AF, r10B1);
                        body.emit(assign(r10AE, add(r10B2, r106F), 0x02));

                        body.emit(assign(r10AE, r1070, 0x01));

                        body.emit(assign(r1073, r10AE, 0x03));

                        body.emit(assign(r1072, body.constant(false), 0x01));


                     body.instructions = f109F_parent_instructions;
                     body.emit(f109F);

                     /* END IF */

                     body.emit(assign(r0DB7, r1073, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1027->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r10B4 = less(r0DBC, r0DBE);
                     ir_if *f10B3 = new(mem_ctx) ir_if(operand(r10B4).val);
                     exec_list *const f10B3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f10B3->then_instructions;

                        ir_variable *const r10B5 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r10B6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r10B6, sub(r0DBE, r0DBC), 0x01));

                        ir_expression *const r10B7 = sub(r0DBD, r0DBB);
                        ir_expression *const r10B8 = less(r0DBE, r0DBC);
                        ir_expression *const r10B9 = expr(ir_unop_b2i, r10B8);
                        ir_expression *const r10BA = expr(ir_unop_i2u, r10B9);
                        body.emit(assign(r10B5, sub(r10B7, r10BA), 0x01));

                        body.emit(assign(r0DBF, add(r0DBA, body.constant(int(-1))), 0x01));

                        ir_variable *const r10BB = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r10BB, add(r0DBF, body.constant(int(-10))), 0x01));

                        ir_variable *const r10BC = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r10BC, r10B5, 0x01));

                        ir_variable *const r10BD = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r10BD, r10B6, 0x01));

                        ir_variable *const r10BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r10BE);
                        ir_variable *const r10BF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r10BF);
                        /* IF CONDITION */
                        ir_expression *const r10C1 = equal(r10B5, body.constant(0u));
                        ir_if *f10C0 = new(mem_ctx) ir_if(operand(r10C1).val);
                        exec_list *const f10C0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10C0->then_instructions;

                           body.emit(assign(r10BC, r10B6, 0x01));

                           body.emit(assign(r10BD, body.constant(0u), 0x01));

                           body.emit(assign(r10BB, add(r10BB, body.constant(int(-32))), 0x01));


                        body.instructions = f10C0_parent_instructions;
                        body.emit(f10C0);

                        /* END IF */

                        ir_variable *const r10C2 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r10C2, r10BC, 0x01));

                        ir_variable *const r10C3 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r10C4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r10C4);
                        /* IF CONDITION */
                        ir_expression *const r10C6 = equal(r10BC, body.constant(0u));
                        ir_if *f10C5 = new(mem_ctx) ir_if(operand(r10C6).val);
                        exec_list *const f10C5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10C5->then_instructions;

                           body.emit(assign(r10C3, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10C5->else_instructions;

                           body.emit(assign(r10C4, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r10C8 = bit_and(r10BC, body.constant(4294901760u));
                           ir_expression *const r10C9 = equal(r10C8, body.constant(0u));
                           ir_if *f10C7 = new(mem_ctx) ir_if(operand(r10C9).val);
                           exec_list *const f10C7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10C7->then_instructions;

                              body.emit(assign(r10C4, body.constant(int(16)), 0x01));

                              body.emit(assign(r10C2, lshift(r10BC, body.constant(int(16))), 0x01));


                           body.instructions = f10C7_parent_instructions;
                           body.emit(f10C7);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10CB = bit_and(r10C2, body.constant(4278190080u));
                           ir_expression *const r10CC = equal(r10CB, body.constant(0u));
                           ir_if *f10CA = new(mem_ctx) ir_if(operand(r10CC).val);
                           exec_list *const f10CA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10CA->then_instructions;

                              body.emit(assign(r10C4, add(r10C4, body.constant(int(8))), 0x01));

                              body.emit(assign(r10C2, lshift(r10C2, body.constant(int(8))), 0x01));


                           body.instructions = f10CA_parent_instructions;
                           body.emit(f10CA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10CE = bit_and(r10C2, body.constant(4026531840u));
                           ir_expression *const r10CF = equal(r10CE, body.constant(0u));
                           ir_if *f10CD = new(mem_ctx) ir_if(operand(r10CF).val);
                           exec_list *const f10CD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10CD->then_instructions;

                              body.emit(assign(r10C4, add(r10C4, body.constant(int(4))), 0x01));

                              body.emit(assign(r10C2, lshift(r10C2, body.constant(int(4))), 0x01));


                           body.instructions = f10CD_parent_instructions;
                           body.emit(f10CD);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D1 = bit_and(r10C2, body.constant(3221225472u));
                           ir_expression *const r10D2 = equal(r10D1, body.constant(0u));
                           ir_if *f10D0 = new(mem_ctx) ir_if(operand(r10D2).val);
                           exec_list *const f10D0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D0->then_instructions;

                              body.emit(assign(r10C4, add(r10C4, body.constant(int(2))), 0x01));

                              body.emit(assign(r10C2, lshift(r10C2, body.constant(int(2))), 0x01));


                           body.instructions = f10D0_parent_instructions;
                           body.emit(f10D0);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D4 = bit_and(r10C2, body.constant(2147483648u));
                           ir_expression *const r10D5 = equal(r10D4, body.constant(0u));
                           ir_if *f10D3 = new(mem_ctx) ir_if(operand(r10D5).val);
                           exec_list *const f10D3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D3->then_instructions;

                              body.emit(assign(r10C4, add(r10C4, body.constant(int(1))), 0x01));


                           body.instructions = f10D3_parent_instructions;
                           body.emit(f10D3);

                           /* END IF */

                           body.emit(assign(r10C3, r10C4, 0x01));


                        body.instructions = f10C5_parent_instructions;
                        body.emit(f10C5);

                        /* END IF */

                        body.emit(assign(r10BF, add(r10C3, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r10D7 = lequal(body.constant(int(0)), r10BF);
                        ir_if *f10D6 = new(mem_ctx) ir_if(operand(r10D7).val);
                        exec_list *const f10D6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10D6->then_instructions;

                           body.emit(assign(r10BE, body.constant(0u), 0x01));

                           ir_variable *const r10D8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r10D8, lshift(r10BD, r10BF), 0x01));

                           ir_variable *const r10D9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r10DB = equal(r10BF, body.constant(int(0)));
                           ir_if *f10DA = new(mem_ctx) ir_if(operand(r10DB).val);
                           exec_list *const f10DA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10DA->then_instructions;

                              body.emit(assign(r10D9, r10BC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f10DA->else_instructions;

                              ir_expression *const r10DC = lshift(r10BC, r10BF);
                              ir_expression *const r10DD = neg(r10BF);
                              ir_expression *const r10DE = bit_and(r10DD, body.constant(int(31)));
                              ir_expression *const r10DF = rshift(r10BD, r10DE);
                              body.emit(assign(r10D9, bit_or(r10DC, r10DF), 0x01));


                           body.instructions = f10DA_parent_instructions;
                           body.emit(f10DA);

                           /* END IF */

                           body.emit(assign(r10BC, r10D9, 0x01));

                           body.emit(assign(r10BD, r10D8, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10D6->else_instructions;

                           ir_variable *const r10E0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r10E0, body.constant(0u), 0x01));

                           ir_variable *const r10E1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r10E1, neg(r10BF), 0x01));

                           ir_variable *const r10E2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r10E2);
                           ir_variable *const r10E3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r10E3);
                           ir_variable *const r10E4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r10E4);
                           ir_variable *const r10E5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r10E6 = neg(r10E1);
                           body.emit(assign(r10E5, bit_and(r10E6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r10E8 = equal(r10E1, body.constant(int(0)));
                           ir_if *f10E7 = new(mem_ctx) ir_if(operand(r10E8).val);
                           exec_list *const f10E7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10E7->then_instructions;

                              body.emit(assign(r10E2, r10E0, 0x01));

                              body.emit(assign(r10E3, r10BD, 0x01));

                              body.emit(assign(r10E4, r10BC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f10E7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r10EA = less(r10E1, body.constant(int(32)));
                              ir_if *f10E9 = new(mem_ctx) ir_if(operand(r10EA).val);
                              exec_list *const f10E9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f10E9->then_instructions;

                                 body.emit(assign(r10E2, lshift(r10BD, r10E5), 0x01));

                                 ir_expression *const r10EB = lshift(r10BC, r10E5);
                                 ir_expression *const r10EC = rshift(r10BD, r10E1);
                                 body.emit(assign(r10E3, bit_or(r10EB, r10EC), 0x01));

                                 body.emit(assign(r10E4, rshift(r10BC, r10E1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f10E9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r10EE = equal(r10E1, body.constant(int(32)));
                                 ir_if *f10ED = new(mem_ctx) ir_if(operand(r10EE).val);
                                 exec_list *const f10ED_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f10ED->then_instructions;

                                    body.emit(assign(r10E2, r10BD, 0x01));

                                    body.emit(assign(r10E3, r10BC, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f10ED->else_instructions;

                                    body.emit(assign(r10E0, bit_or(body.constant(0u), r10BD), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r10F0 = less(r10E1, body.constant(int(64)));
                                    ir_if *f10EF = new(mem_ctx) ir_if(operand(r10F0).val);
                                    exec_list *const f10EF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f10EF->then_instructions;

                                       body.emit(assign(r10E2, lshift(r10BC, r10E5), 0x01));

                                       ir_expression *const r10F1 = bit_and(r10E1, body.constant(int(31)));
                                       body.emit(assign(r10E3, rshift(r10BC, r10F1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f10EF->else_instructions;

                                       ir_variable *const r10F2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r10F4 = equal(r10E1, body.constant(int(64)));
                                       ir_if *f10F3 = new(mem_ctx) ir_if(operand(r10F4).val);
                                       exec_list *const f10F3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f10F3->then_instructions;

                                          body.emit(assign(r10F2, r10BC, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f10F3->else_instructions;

                                          ir_expression *const r10F5 = nequal(r10BC, body.constant(0u));
                                          ir_expression *const r10F6 = expr(ir_unop_b2i, r10F5);
                                          body.emit(assign(r10F2, expr(ir_unop_i2u, r10F6), 0x01));


                                       body.instructions = f10F3_parent_instructions;
                                       body.emit(f10F3);

                                       /* END IF */

                                       body.emit(assign(r10E2, r10F2, 0x01));

                                       body.emit(assign(r10E3, body.constant(0u), 0x01));


                                    body.instructions = f10EF_parent_instructions;
                                    body.emit(f10EF);

                                    /* END IF */


                                 body.instructions = f10ED_parent_instructions;
                                 body.emit(f10ED);

                                 /* END IF */

                                 body.emit(assign(r10E4, body.constant(0u), 0x01));


                              body.instructions = f10E9_parent_instructions;
                              body.emit(f10E9);

                              /* END IF */

                              ir_expression *const r10F7 = nequal(r10E0, body.constant(0u));
                              ir_expression *const r10F8 = expr(ir_unop_b2i, r10F7);
                              ir_expression *const r10F9 = expr(ir_unop_i2u, r10F8);
                              body.emit(assign(r10E2, bit_or(r10E2, r10F9), 0x01));


                           body.instructions = f10E7_parent_instructions;
                           body.emit(f10E7);

                           /* END IF */

                           body.emit(assign(r10BC, r10E4, 0x01));

                           body.emit(assign(r10BD, r10E3, 0x01));

                           body.emit(assign(r10BE, r10E2, 0x01));


                        body.instructions = f10D6_parent_instructions;
                        body.emit(f10D6);

                        /* END IF */

                        body.emit(assign(r10BB, sub(r10BB, r10BF), 0x01));

                        ir_variable *const r10FA = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r10FA, r10BB, 0x01));

                        ir_variable *const r10FB = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r10FB, r10BC, 0x01));

                        ir_variable *const r10FC = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r10FC, r10BD, 0x01));

                        ir_variable *const r10FD = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r10FD, r10BE, 0x01));

                        ir_variable *const r10FE = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r10FE, body.constant(true), 0x01));

                        ir_variable *const r10FF = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r1100 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r1100);
                        ir_expression *const r1101 = expr(ir_unop_u2i, r10BE);
                        body.emit(assign(r1100, less(r1101, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1103 = lequal(body.constant(int(2045)), r10BB);
                        ir_if *f1102 = new(mem_ctx) ir_if(operand(r1103).val);
                        exec_list *const f1102_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1102->then_instructions;

                           ir_variable *const r1104 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1106 = less(body.constant(int(2045)), r10BB);
                           ir_if *f1105 = new(mem_ctx) ir_if(operand(r1106).val);
                           exec_list *const f1105_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1105->then_instructions;

                              body.emit(assign(r1104, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1105->else_instructions;

                              ir_variable *const r1107 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1109 = equal(r10BB, body.constant(int(2045)));
                              ir_if *f1108 = new(mem_ctx) ir_if(operand(r1109).val);
                              exec_list *const f1108_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1108->then_instructions;

                                 ir_expression *const r110A = equal(body.constant(2097151u), r10BC);
                                 ir_expression *const r110B = equal(body.constant(4294967295u), r10BD);
                                 body.emit(assign(r1107, logic_and(r110A, r110B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1108->else_instructions;

                                 body.emit(assign(r1107, body.constant(false), 0x01));


                              body.instructions = f1108_parent_instructions;
                              body.emit(f1108);

                              /* END IF */

                              body.emit(assign(r1104, logic_and(r1107, r1100), 0x01));


                           body.instructions = f1105_parent_instructions;
                           body.emit(f1105);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f110C = new(mem_ctx) ir_if(operand(r1104).val);
                           exec_list *const f110C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f110C->then_instructions;

                              ir_variable *const r110D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r110D);
                              ir_expression *const r110E = lshift(r0DB6, body.constant(int(31)));
                              body.emit(assign(r110D, add(r110E, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r110D, body.constant(0u), 0x01));

                              body.emit(assign(r10FF, r110D, 0x03));

                              body.emit(assign(r10FE, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f110C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1110 = less(r10BB, body.constant(int(0)));
                              ir_if *f110F = new(mem_ctx) ir_if(operand(r1110).val);
                              exec_list *const f110F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f110F->then_instructions;

                                 ir_variable *const r1111 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1111, r10BE, 0x01));

                                 ir_variable *const r1112 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1112, neg(r10BB), 0x01));

                                 ir_variable *const r1113 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1113);
                                 ir_variable *const r1114 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1114);
                                 ir_variable *const r1115 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1115);
                                 ir_variable *const r1116 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r1117 = neg(r1112);
                                 body.emit(assign(r1116, bit_and(r1117, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1119 = equal(r1112, body.constant(int(0)));
                                 ir_if *f1118 = new(mem_ctx) ir_if(operand(r1119).val);
                                 exec_list *const f1118_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1118->then_instructions;

                                    body.emit(assign(r1113, r10BE, 0x01));

                                    body.emit(assign(r1114, r10BD, 0x01));

                                    body.emit(assign(r1115, r10BC, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1118->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r111B = less(r1112, body.constant(int(32)));
                                    ir_if *f111A = new(mem_ctx) ir_if(operand(r111B).val);
                                    exec_list *const f111A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f111A->then_instructions;

                                       body.emit(assign(r1113, lshift(r10BD, r1116), 0x01));

                                       ir_expression *const r111C = lshift(r10BC, r1116);
                                       ir_expression *const r111D = rshift(r10BD, r1112);
                                       body.emit(assign(r1114, bit_or(r111C, r111D), 0x01));

                                       body.emit(assign(r1115, rshift(r10BC, r1112), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f111A->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r111F = equal(r1112, body.constant(int(32)));
                                       ir_if *f111E = new(mem_ctx) ir_if(operand(r111F).val);
                                       exec_list *const f111E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f111E->then_instructions;

                                          body.emit(assign(r1113, r10BD, 0x01));

                                          body.emit(assign(r1114, r10BC, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f111E->else_instructions;

                                          body.emit(assign(r1111, bit_or(r10BE, r10BD), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1121 = less(r1112, body.constant(int(64)));
                                          ir_if *f1120 = new(mem_ctx) ir_if(operand(r1121).val);
                                          exec_list *const f1120_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1120->then_instructions;

                                             body.emit(assign(r1113, lshift(r10BC, r1116), 0x01));

                                             ir_expression *const r1122 = bit_and(r1112, body.constant(int(31)));
                                             body.emit(assign(r1114, rshift(r10BC, r1122), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1120->else_instructions;

                                             ir_variable *const r1123 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1125 = equal(r1112, body.constant(int(64)));
                                             ir_if *f1124 = new(mem_ctx) ir_if(operand(r1125).val);
                                             exec_list *const f1124_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1124->then_instructions;

                                                body.emit(assign(r1123, r10BC, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1124->else_instructions;

                                                ir_expression *const r1126 = nequal(r10BC, body.constant(0u));
                                                ir_expression *const r1127 = expr(ir_unop_b2i, r1126);
                                                body.emit(assign(r1123, expr(ir_unop_i2u, r1127), 0x01));


                                             body.instructions = f1124_parent_instructions;
                                             body.emit(f1124);

                                             /* END IF */

                                             body.emit(assign(r1113, r1123, 0x01));

                                             body.emit(assign(r1114, body.constant(0u), 0x01));


                                          body.instructions = f1120_parent_instructions;
                                          body.emit(f1120);

                                          /* END IF */


                                       body.instructions = f111E_parent_instructions;
                                       body.emit(f111E);

                                       /* END IF */

                                       body.emit(assign(r1115, body.constant(0u), 0x01));


                                    body.instructions = f111A_parent_instructions;
                                    body.emit(f111A);

                                    /* END IF */

                                    ir_expression *const r1128 = nequal(r1111, body.constant(0u));
                                    ir_expression *const r1129 = expr(ir_unop_b2i, r1128);
                                    ir_expression *const r112A = expr(ir_unop_i2u, r1129);
                                    body.emit(assign(r1113, bit_or(r1113, r112A), 0x01));


                                 body.instructions = f1118_parent_instructions;
                                 body.emit(f1118);

                                 /* END IF */

                                 body.emit(assign(r10FB, r1115, 0x01));

                                 body.emit(assign(r10FC, r1114, 0x01));

                                 body.emit(assign(r10FD, r1113, 0x01));

                                 body.emit(assign(r10FA, body.constant(int(0)), 0x01));

                                 body.emit(assign(r1100, less(r1113, body.constant(0u)), 0x01));


                              body.instructions = f110F_parent_instructions;
                              body.emit(f110F);

                              /* END IF */


                           body.instructions = f110C_parent_instructions;
                           body.emit(f110C);

                           /* END IF */


                        body.instructions = f1102_parent_instructions;
                        body.emit(f1102);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f112B = new(mem_ctx) ir_if(operand(r10FE).val);
                        exec_list *const f112B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f112B->then_instructions;

                           /* IF CONDITION */
                           ir_if *f112C = new(mem_ctx) ir_if(operand(r1100).val);
                           exec_list *const f112C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f112C->then_instructions;

                              ir_variable *const r112D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r112D, add(r10FC, body.constant(1u)), 0x01));

                              ir_expression *const r112E = less(r112D, r10FC);
                              ir_expression *const r112F = expr(ir_unop_b2i, r112E);
                              ir_expression *const r1130 = expr(ir_unop_i2u, r112F);
                              body.emit(assign(r10FB, add(r10FB, r1130), 0x01));

                              ir_expression *const r1131 = equal(r10FD, body.constant(0u));
                              ir_expression *const r1132 = expr(ir_unop_b2i, r1131);
                              ir_expression *const r1133 = expr(ir_unop_i2u, r1132);
                              ir_expression *const r1134 = add(r10FD, r1133);
                              ir_expression *const r1135 = bit_and(r1134, body.constant(1u));
                              ir_expression *const r1136 = expr(ir_unop_bit_not, r1135);
                              body.emit(assign(r10FC, bit_and(r112D, r1136), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f112C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1138 = bit_or(r10FB, r10FC);
                              ir_expression *const r1139 = equal(r1138, body.constant(0u));
                              ir_if *f1137 = new(mem_ctx) ir_if(operand(r1139).val);
                              exec_list *const f1137_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1137->then_instructions;

                                 body.emit(assign(r10FA, body.constant(int(0)), 0x01));


                              body.instructions = f1137_parent_instructions;
                              body.emit(f1137);

                              /* END IF */


                           body.instructions = f112C_parent_instructions;
                           body.emit(f112C);

                           /* END IF */

                           ir_variable *const r113A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r113A);
                           ir_expression *const r113B = lshift(r0DB6, body.constant(int(31)));
                           ir_expression *const r113C = expr(ir_unop_i2u, r10FA);
                           ir_expression *const r113D = lshift(r113C, body.constant(int(20)));
                           ir_expression *const r113E = add(r113B, r113D);
                           body.emit(assign(r113A, add(r113E, r10FB), 0x02));

                           body.emit(assign(r113A, r10FC, 0x01));

                           body.emit(assign(r10FF, r113A, 0x03));

                           body.emit(assign(r10FE, body.constant(false), 0x01));


                        body.instructions = f112B_parent_instructions;
                        body.emit(f112B);

                        /* END IF */

                        body.emit(assign(r0DB7, r10FF, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f10B3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1140 = less(r0DBE, r0DBC);
                        ir_if *f113F = new(mem_ctx) ir_if(operand(r1140).val);
                        exec_list *const f113F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f113F->then_instructions;

                           ir_variable *const r1141 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r1142 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1142, sub(r0DBC, r0DBE), 0x01));

                           ir_expression *const r1143 = sub(r0DBB, r0DBD);
                           ir_expression *const r1144 = less(r0DBC, r0DBE);
                           ir_expression *const r1145 = expr(ir_unop_b2i, r1144);
                           ir_expression *const r1146 = expr(ir_unop_i2u, r1145);
                           body.emit(assign(r1141, sub(r1143, r1146), 0x01));

                           body.emit(assign(r0DB6, bit_xor(r0DB6, body.constant(1u)), 0x01));

                           body.emit(assign(r0DBF, add(r0DB9, body.constant(int(-1))), 0x01));

                           ir_variable *const r1147 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1147, add(r0DBF, body.constant(int(-10))), 0x01));

                           ir_variable *const r1148 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1148, r1141, 0x01));

                           ir_variable *const r1149 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1149, r1142, 0x01));

                           ir_variable *const r114A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r114A);
                           ir_variable *const r114B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r114B);
                           /* IF CONDITION */
                           ir_expression *const r114D = equal(r1141, body.constant(0u));
                           ir_if *f114C = new(mem_ctx) ir_if(operand(r114D).val);
                           exec_list *const f114C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f114C->then_instructions;

                              body.emit(assign(r1148, r1142, 0x01));

                              body.emit(assign(r1149, body.constant(0u), 0x01));

                              body.emit(assign(r1147, add(r1147, body.constant(int(-32))), 0x01));


                           body.instructions = f114C_parent_instructions;
                           body.emit(f114C);

                           /* END IF */

                           ir_variable *const r114E = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r114E, r1148, 0x01));

                           ir_variable *const r114F = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r1150 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1150);
                           /* IF CONDITION */
                           ir_expression *const r1152 = equal(r1148, body.constant(0u));
                           ir_if *f1151 = new(mem_ctx) ir_if(operand(r1152).val);
                           exec_list *const f1151_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1151->then_instructions;

                              body.emit(assign(r114F, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1151->else_instructions;

                              body.emit(assign(r1150, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1154 = bit_and(r1148, body.constant(4294901760u));
                              ir_expression *const r1155 = equal(r1154, body.constant(0u));
                              ir_if *f1153 = new(mem_ctx) ir_if(operand(r1155).val);
                              exec_list *const f1153_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1153->then_instructions;

                                 body.emit(assign(r1150, body.constant(int(16)), 0x01));

                                 body.emit(assign(r114E, lshift(r1148, body.constant(int(16))), 0x01));


                              body.instructions = f1153_parent_instructions;
                              body.emit(f1153);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1157 = bit_and(r114E, body.constant(4278190080u));
                              ir_expression *const r1158 = equal(r1157, body.constant(0u));
                              ir_if *f1156 = new(mem_ctx) ir_if(operand(r1158).val);
                              exec_list *const f1156_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1156->then_instructions;

                                 body.emit(assign(r1150, add(r1150, body.constant(int(8))), 0x01));

                                 body.emit(assign(r114E, lshift(r114E, body.constant(int(8))), 0x01));


                              body.instructions = f1156_parent_instructions;
                              body.emit(f1156);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r115A = bit_and(r114E, body.constant(4026531840u));
                              ir_expression *const r115B = equal(r115A, body.constant(0u));
                              ir_if *f1159 = new(mem_ctx) ir_if(operand(r115B).val);
                              exec_list *const f1159_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1159->then_instructions;

                                 body.emit(assign(r1150, add(r1150, body.constant(int(4))), 0x01));

                                 body.emit(assign(r114E, lshift(r114E, body.constant(int(4))), 0x01));


                              body.instructions = f1159_parent_instructions;
                              body.emit(f1159);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r115D = bit_and(r114E, body.constant(3221225472u));
                              ir_expression *const r115E = equal(r115D, body.constant(0u));
                              ir_if *f115C = new(mem_ctx) ir_if(operand(r115E).val);
                              exec_list *const f115C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f115C->then_instructions;

                                 body.emit(assign(r1150, add(r1150, body.constant(int(2))), 0x01));

                                 body.emit(assign(r114E, lshift(r114E, body.constant(int(2))), 0x01));


                              body.instructions = f115C_parent_instructions;
                              body.emit(f115C);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1160 = bit_and(r114E, body.constant(2147483648u));
                              ir_expression *const r1161 = equal(r1160, body.constant(0u));
                              ir_if *f115F = new(mem_ctx) ir_if(operand(r1161).val);
                              exec_list *const f115F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f115F->then_instructions;

                                 body.emit(assign(r1150, add(r1150, body.constant(int(1))), 0x01));


                              body.instructions = f115F_parent_instructions;
                              body.emit(f115F);

                              /* END IF */

                              body.emit(assign(r114F, r1150, 0x01));


                           body.instructions = f1151_parent_instructions;
                           body.emit(f1151);

                           /* END IF */

                           body.emit(assign(r114B, add(r114F, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1163 = lequal(body.constant(int(0)), r114B);
                           ir_if *f1162 = new(mem_ctx) ir_if(operand(r1163).val);
                           exec_list *const f1162_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1162->then_instructions;

                              body.emit(assign(r114A, body.constant(0u), 0x01));

                              ir_variable *const r1164 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1164, lshift(r1149, r114B), 0x01));

                              ir_variable *const r1165 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1167 = equal(r114B, body.constant(int(0)));
                              ir_if *f1166 = new(mem_ctx) ir_if(operand(r1167).val);
                              exec_list *const f1166_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1166->then_instructions;

                                 body.emit(assign(r1165, r1148, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1166->else_instructions;

                                 ir_expression *const r1168 = lshift(r1148, r114B);
                                 ir_expression *const r1169 = neg(r114B);
                                 ir_expression *const r116A = bit_and(r1169, body.constant(int(31)));
                                 ir_expression *const r116B = rshift(r1149, r116A);
                                 body.emit(assign(r1165, bit_or(r1168, r116B), 0x01));


                              body.instructions = f1166_parent_instructions;
                              body.emit(f1166);

                              /* END IF */

                              body.emit(assign(r1148, r1165, 0x01));

                              body.emit(assign(r1149, r1164, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1162->else_instructions;

                              ir_variable *const r116C = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r116C, body.constant(0u), 0x01));

                              ir_variable *const r116D = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r116D, neg(r114B), 0x01));

                              ir_variable *const r116E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r116E);
                              ir_variable *const r116F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r116F);
                              ir_variable *const r1170 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1170);
                              ir_variable *const r1171 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1172 = neg(r116D);
                              body.emit(assign(r1171, bit_and(r1172, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1174 = equal(r116D, body.constant(int(0)));
                              ir_if *f1173 = new(mem_ctx) ir_if(operand(r1174).val);
                              exec_list *const f1173_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1173->then_instructions;

                                 body.emit(assign(r116E, r116C, 0x01));

                                 body.emit(assign(r116F, r1149, 0x01));

                                 body.emit(assign(r1170, r1148, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1173->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1176 = less(r116D, body.constant(int(32)));
                                 ir_if *f1175 = new(mem_ctx) ir_if(operand(r1176).val);
                                 exec_list *const f1175_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1175->then_instructions;

                                    body.emit(assign(r116E, lshift(r1149, r1171), 0x01));

                                    ir_expression *const r1177 = lshift(r1148, r1171);
                                    ir_expression *const r1178 = rshift(r1149, r116D);
                                    body.emit(assign(r116F, bit_or(r1177, r1178), 0x01));

                                    body.emit(assign(r1170, rshift(r1148, r116D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1175->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r117A = equal(r116D, body.constant(int(32)));
                                    ir_if *f1179 = new(mem_ctx) ir_if(operand(r117A).val);
                                    exec_list *const f1179_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1179->then_instructions;

                                       body.emit(assign(r116E, r1149, 0x01));

                                       body.emit(assign(r116F, r1148, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1179->else_instructions;

                                       body.emit(assign(r116C, bit_or(body.constant(0u), r1149), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r117C = less(r116D, body.constant(int(64)));
                                       ir_if *f117B = new(mem_ctx) ir_if(operand(r117C).val);
                                       exec_list *const f117B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f117B->then_instructions;

                                          body.emit(assign(r116E, lshift(r1148, r1171), 0x01));

                                          ir_expression *const r117D = bit_and(r116D, body.constant(int(31)));
                                          body.emit(assign(r116F, rshift(r1148, r117D), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f117B->else_instructions;

                                          ir_variable *const r117E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1180 = equal(r116D, body.constant(int(64)));
                                          ir_if *f117F = new(mem_ctx) ir_if(operand(r1180).val);
                                          exec_list *const f117F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f117F->then_instructions;

                                             body.emit(assign(r117E, r1148, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f117F->else_instructions;

                                             ir_expression *const r1181 = nequal(r1148, body.constant(0u));
                                             ir_expression *const r1182 = expr(ir_unop_b2i, r1181);
                                             body.emit(assign(r117E, expr(ir_unop_i2u, r1182), 0x01));


                                          body.instructions = f117F_parent_instructions;
                                          body.emit(f117F);

                                          /* END IF */

                                          body.emit(assign(r116E, r117E, 0x01));

                                          body.emit(assign(r116F, body.constant(0u), 0x01));


                                       body.instructions = f117B_parent_instructions;
                                       body.emit(f117B);

                                       /* END IF */


                                    body.instructions = f1179_parent_instructions;
                                    body.emit(f1179);

                                    /* END IF */

                                    body.emit(assign(r1170, body.constant(0u), 0x01));


                                 body.instructions = f1175_parent_instructions;
                                 body.emit(f1175);

                                 /* END IF */

                                 ir_expression *const r1183 = nequal(r116C, body.constant(0u));
                                 ir_expression *const r1184 = expr(ir_unop_b2i, r1183);
                                 ir_expression *const r1185 = expr(ir_unop_i2u, r1184);
                                 body.emit(assign(r116E, bit_or(r116E, r1185), 0x01));


                              body.instructions = f1173_parent_instructions;
                              body.emit(f1173);

                              /* END IF */

                              body.emit(assign(r1148, r1170, 0x01));

                              body.emit(assign(r1149, r116F, 0x01));

                              body.emit(assign(r114A, r116E, 0x01));


                           body.instructions = f1162_parent_instructions;
                           body.emit(f1162);

                           /* END IF */

                           body.emit(assign(r1147, sub(r1147, r114B), 0x01));

                           ir_variable *const r1186 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1186, r1147, 0x01));

                           ir_variable *const r1187 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1187, r1148, 0x01));

                           ir_variable *const r1188 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1188, r1149, 0x01));

                           ir_variable *const r1189 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r1189, r114A, 0x01));

                           ir_variable *const r118A = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r118A, body.constant(true), 0x01));

                           ir_variable *const r118B = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r118C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r118C);
                           ir_expression *const r118D = expr(ir_unop_u2i, r114A);
                           body.emit(assign(r118C, less(r118D, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r118F = lequal(body.constant(int(2045)), r1147);
                           ir_if *f118E = new(mem_ctx) ir_if(operand(r118F).val);
                           exec_list *const f118E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f118E->then_instructions;

                              ir_variable *const r1190 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1192 = less(body.constant(int(2045)), r1147);
                              ir_if *f1191 = new(mem_ctx) ir_if(operand(r1192).val);
                              exec_list *const f1191_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1191->then_instructions;

                                 body.emit(assign(r1190, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1191->else_instructions;

                                 ir_variable *const r1193 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1195 = equal(r1147, body.constant(int(2045)));
                                 ir_if *f1194 = new(mem_ctx) ir_if(operand(r1195).val);
                                 exec_list *const f1194_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1194->then_instructions;

                                    ir_expression *const r1196 = equal(body.constant(2097151u), r1148);
                                    ir_expression *const r1197 = equal(body.constant(4294967295u), r1149);
                                    body.emit(assign(r1193, logic_and(r1196, r1197), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1194->else_instructions;

                                    body.emit(assign(r1193, body.constant(false), 0x01));


                                 body.instructions = f1194_parent_instructions;
                                 body.emit(f1194);

                                 /* END IF */

                                 body.emit(assign(r1190, logic_and(r1193, r118C), 0x01));


                              body.instructions = f1191_parent_instructions;
                              body.emit(f1191);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f1198 = new(mem_ctx) ir_if(operand(r1190).val);
                              exec_list *const f1198_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1198->then_instructions;

                                 ir_variable *const r1199 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r1199);
                                 ir_expression *const r119A = lshift(r0DB6, body.constant(int(31)));
                                 body.emit(assign(r1199, add(r119A, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r1199, body.constant(0u), 0x01));

                                 body.emit(assign(r118B, r1199, 0x03));

                                 body.emit(assign(r118A, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1198->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r119C = less(r1147, body.constant(int(0)));
                                 ir_if *f119B = new(mem_ctx) ir_if(operand(r119C).val);
                                 exec_list *const f119B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f119B->then_instructions;

                                    ir_variable *const r119D = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r119D, r114A, 0x01));

                                    ir_variable *const r119E = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r119E, neg(r1147), 0x01));

                                    ir_variable *const r119F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r119F);
                                    ir_variable *const r11A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r11A0);
                                    ir_variable *const r11A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r11A1);
                                    ir_variable *const r11A2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r11A3 = neg(r119E);
                                    body.emit(assign(r11A2, bit_and(r11A3, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r11A5 = equal(r119E, body.constant(int(0)));
                                    ir_if *f11A4 = new(mem_ctx) ir_if(operand(r11A5).val);
                                    exec_list *const f11A4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f11A4->then_instructions;

                                       body.emit(assign(r119F, r114A, 0x01));

                                       body.emit(assign(r11A0, r1149, 0x01));

                                       body.emit(assign(r11A1, r1148, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f11A4->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r11A7 = less(r119E, body.constant(int(32)));
                                       ir_if *f11A6 = new(mem_ctx) ir_if(operand(r11A7).val);
                                       exec_list *const f11A6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f11A6->then_instructions;

                                          body.emit(assign(r119F, lshift(r1149, r11A2), 0x01));

                                          ir_expression *const r11A8 = lshift(r1148, r11A2);
                                          ir_expression *const r11A9 = rshift(r1149, r119E);
                                          body.emit(assign(r11A0, bit_or(r11A8, r11A9), 0x01));

                                          body.emit(assign(r11A1, rshift(r1148, r119E), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f11A6->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r11AB = equal(r119E, body.constant(int(32)));
                                          ir_if *f11AA = new(mem_ctx) ir_if(operand(r11AB).val);
                                          exec_list *const f11AA_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f11AA->then_instructions;

                                             body.emit(assign(r119F, r1149, 0x01));

                                             body.emit(assign(r11A0, r1148, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f11AA->else_instructions;

                                             body.emit(assign(r119D, bit_or(r114A, r1149), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r11AD = less(r119E, body.constant(int(64)));
                                             ir_if *f11AC = new(mem_ctx) ir_if(operand(r11AD).val);
                                             exec_list *const f11AC_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f11AC->then_instructions;

                                                body.emit(assign(r119F, lshift(r1148, r11A2), 0x01));

                                                ir_expression *const r11AE = bit_and(r119E, body.constant(int(31)));
                                                body.emit(assign(r11A0, rshift(r1148, r11AE), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f11AC->else_instructions;

                                                ir_variable *const r11AF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r11B1 = equal(r119E, body.constant(int(64)));
                                                ir_if *f11B0 = new(mem_ctx) ir_if(operand(r11B1).val);
                                                exec_list *const f11B0_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f11B0->then_instructions;

                                                   body.emit(assign(r11AF, r1148, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f11B0->else_instructions;

                                                   ir_expression *const r11B2 = nequal(r1148, body.constant(0u));
                                                   ir_expression *const r11B3 = expr(ir_unop_b2i, r11B2);
                                                   body.emit(assign(r11AF, expr(ir_unop_i2u, r11B3), 0x01));


                                                body.instructions = f11B0_parent_instructions;
                                                body.emit(f11B0);

                                                /* END IF */

                                                body.emit(assign(r119F, r11AF, 0x01));

                                                body.emit(assign(r11A0, body.constant(0u), 0x01));


                                             body.instructions = f11AC_parent_instructions;
                                             body.emit(f11AC);

                                             /* END IF */


                                          body.instructions = f11AA_parent_instructions;
                                          body.emit(f11AA);

                                          /* END IF */

                                          body.emit(assign(r11A1, body.constant(0u), 0x01));


                                       body.instructions = f11A6_parent_instructions;
                                       body.emit(f11A6);

                                       /* END IF */

                                       ir_expression *const r11B4 = nequal(r119D, body.constant(0u));
                                       ir_expression *const r11B5 = expr(ir_unop_b2i, r11B4);
                                       ir_expression *const r11B6 = expr(ir_unop_i2u, r11B5);
                                       body.emit(assign(r119F, bit_or(r119F, r11B6), 0x01));


                                    body.instructions = f11A4_parent_instructions;
                                    body.emit(f11A4);

                                    /* END IF */

                                    body.emit(assign(r1187, r11A1, 0x01));

                                    body.emit(assign(r1188, r11A0, 0x01));

                                    body.emit(assign(r1189, r119F, 0x01));

                                    body.emit(assign(r1186, body.constant(int(0)), 0x01));

                                    body.emit(assign(r118C, less(r119F, body.constant(0u)), 0x01));


                                 body.instructions = f119B_parent_instructions;
                                 body.emit(f119B);

                                 /* END IF */


                              body.instructions = f1198_parent_instructions;
                              body.emit(f1198);

                              /* END IF */


                           body.instructions = f118E_parent_instructions;
                           body.emit(f118E);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f11B7 = new(mem_ctx) ir_if(operand(r118A).val);
                           exec_list *const f11B7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f11B7->then_instructions;

                              /* IF CONDITION */
                              ir_if *f11B8 = new(mem_ctx) ir_if(operand(r118C).val);
                              exec_list *const f11B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f11B8->then_instructions;

                                 ir_variable *const r11B9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r11B9, add(r1188, body.constant(1u)), 0x01));

                                 ir_expression *const r11BA = less(r11B9, r1188);
                                 ir_expression *const r11BB = expr(ir_unop_b2i, r11BA);
                                 ir_expression *const r11BC = expr(ir_unop_i2u, r11BB);
                                 body.emit(assign(r1187, add(r1187, r11BC), 0x01));

                                 ir_expression *const r11BD = equal(r1189, body.constant(0u));
                                 ir_expression *const r11BE = expr(ir_unop_b2i, r11BD);
                                 ir_expression *const r11BF = expr(ir_unop_i2u, r11BE);
                                 ir_expression *const r11C0 = add(r1189, r11BF);
                                 ir_expression *const r11C1 = bit_and(r11C0, body.constant(1u));
                                 ir_expression *const r11C2 = expr(ir_unop_bit_not, r11C1);
                                 body.emit(assign(r1188, bit_and(r11B9, r11C2), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f11B8->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r11C4 = bit_or(r1187, r1188);
                                 ir_expression *const r11C5 = equal(r11C4, body.constant(0u));
                                 ir_if *f11C3 = new(mem_ctx) ir_if(operand(r11C5).val);
                                 exec_list *const f11C3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f11C3->then_instructions;

                                    body.emit(assign(r1186, body.constant(int(0)), 0x01));


                                 body.instructions = f11C3_parent_instructions;
                                 body.emit(f11C3);

                                 /* END IF */


                              body.instructions = f11B8_parent_instructions;
                              body.emit(f11B8);

                              /* END IF */

                              ir_variable *const r11C6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r11C6);
                              ir_expression *const r11C7 = lshift(r0DB6, body.constant(int(31)));
                              ir_expression *const r11C8 = expr(ir_unop_i2u, r1186);
                              ir_expression *const r11C9 = lshift(r11C8, body.constant(int(20)));
                              ir_expression *const r11CA = add(r11C7, r11C9);
                              body.emit(assign(r11C6, add(r11CA, r1187), 0x02));

                              body.emit(assign(r11C6, r1188, 0x01));

                              body.emit(assign(r118B, r11C6, 0x03));

                              body.emit(assign(r118A, body.constant(false), 0x01));


                           body.instructions = f11B7_parent_instructions;
                           body.emit(f11B7);

                           /* END IF */

                           body.emit(assign(r0DB7, r118B, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f113F->else_instructions;

                           ir_variable *const r11CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r11CB);
                           body.emit(assign(r11CB, body.constant(0u), 0x02));

                           body.emit(assign(r11CB, body.constant(0u), 0x01));

                           body.emit(assign(r0DB7, r11CB, 0x03));


                        body.instructions = f113F_parent_instructions;
                        body.emit(f113F);

                        /* END IF */


                     body.instructions = f10B3_parent_instructions;
                     body.emit(f10B3);

                     /* END IF */


                  body.instructions = f1027_parent_instructions;
                  body.emit(f1027);

                  /* END IF */


               body.instructions = f0F9B_parent_instructions;
               body.emit(f0F9B);

               /* END IF */


            body.instructions = f0F74_parent_instructions;
            body.emit(f0F74);

            /* END IF */


         body.instructions = f0EA0_parent_instructions;
         body.emit(f0EA0);

         /* END IF */


      body.instructions = f0DD0_parent_instructions;
      body.emit(f0DD0);

      /* END IF */

      body.emit(assign(r0DB1, r0DB7, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0DB4->else_instructions;

      ir_variable *const r11CC = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r11CC, body.constant(true), 0x01));

      ir_variable *const r11CD = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r11CE = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r11CE);
      ir_variable *const r11CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r11CF);
      ir_variable *const r11D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r11D0);
      ir_variable *const r11D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r11D1);
      ir_variable *const r11D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r11D2);
      ir_variable *const r11D3 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r11D3);
      ir_variable *const r11D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r11D4);
      ir_variable *const r11D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r11D5);
      body.emit(assign(r11D5, body.constant(0u), 0x01));

      body.emit(assign(r11D4, body.constant(0u), 0x01));

      ir_variable *const r11D6 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r11D6, swizzle_x(r0DAF), 0x01));

      body.emit(assign(r11D2, r11D6, 0x01));

      ir_variable *const r11D7 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r11D7, bit_and(swizzle_y(r0DAF), body.constant(1048575u)), 0x01));

      body.emit(assign(r11D1, r11D7, 0x01));

      ir_variable *const r11D8 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r11D8, swizzle_x(r0DB0), 0x01));

      body.emit(assign(r11D0, r11D8, 0x01));

      ir_variable *const r11D9 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r11D9, bit_and(swizzle_y(r0DB0), body.constant(1048575u)), 0x01));

      body.emit(assign(r11CF, r11D9, 0x01));

      ir_variable *const r11DA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r11DB = rshift(swizzle_y(r0DAF), body.constant(int(20)));
      ir_expression *const r11DC = bit_and(r11DB, body.constant(2047u));
      body.emit(assign(r11DA, expr(ir_unop_u2i, r11DC), 0x01));

      ir_variable *const r11DD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r11DE = rshift(swizzle_y(r0DB0), body.constant(int(20)));
      ir_expression *const r11DF = bit_and(r11DE, body.constant(2047u));
      body.emit(assign(r11DD, expr(ir_unop_u2i, r11DF), 0x01));

      ir_variable *const r11E0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r11E0, sub(r11DA, r11DD), 0x01));

      body.emit(assign(r11CE, r11E0, 0x01));

      /* IF CONDITION */
      ir_expression *const r11E2 = less(body.constant(int(0)), r11E0);
      ir_if *f11E1 = new(mem_ctx) ir_if(operand(r11E2).val);
      exec_list *const f11E1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f11E1->then_instructions;

         /* IF CONDITION */
         ir_expression *const r11E4 = equal(r11DA, body.constant(int(2047)));
         ir_if *f11E3 = new(mem_ctx) ir_if(operand(r11E4).val);
         exec_list *const f11E3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11E3->then_instructions;

            /* IF CONDITION */
            ir_expression *const r11E6 = bit_or(r11D7, swizzle_x(r0DAF));
            ir_expression *const r11E7 = nequal(r11E6, body.constant(0u));
            ir_if *f11E5 = new(mem_ctx) ir_if(operand(r11E7).val);
            exec_list *const f11E5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f11E5->then_instructions;

               ir_variable *const r11E8 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r11E8, swizzle_x(r0DAF), 0x01));

               ir_variable *const r11E9 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r11E9, swizzle_x(r0DB0), 0x01));

               ir_variable *const r11EA = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r11EB = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r11EC = rshift(swizzle_y(r0DAF), body.constant(int(19)));
               ir_expression *const r11ED = bit_and(r11EC, body.constant(4095u));
               ir_expression *const r11EE = equal(r11ED, body.constant(4094u));
               ir_expression *const r11EF = nequal(swizzle_x(r0DAF), body.constant(0u));
               ir_expression *const r11F0 = bit_and(swizzle_y(r0DAF), body.constant(524287u));
               ir_expression *const r11F1 = nequal(r11F0, body.constant(0u));
               ir_expression *const r11F2 = logic_or(r11EF, r11F1);
               body.emit(assign(r11EB, logic_and(r11EE, r11F2), 0x01));

               ir_variable *const r11F3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r11F4 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
               ir_expression *const r11F5 = lequal(body.constant(4292870144u), r11F4);
               ir_expression *const r11F6 = nequal(swizzle_x(r0DB0), body.constant(0u));
               ir_expression *const r11F7 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
               ir_expression *const r11F8 = nequal(r11F7, body.constant(0u));
               ir_expression *const r11F9 = logic_or(r11F6, r11F8);
               body.emit(assign(r11F3, logic_and(r11F5, r11F9), 0x01));

               body.emit(assign(r11E8, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

               body.emit(assign(r11E9, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r11FB = lshift(swizzle_y(r0DAF), body.constant(int(1)));
               ir_expression *const r11FC = lequal(body.constant(4292870144u), r11FB);
               ir_expression *const r11FD = nequal(swizzle_x(r0DAF), body.constant(0u));
               ir_expression *const r11FE = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
               ir_expression *const r11FF = nequal(r11FE, body.constant(0u));
               ir_expression *const r1200 = logic_or(r11FD, r11FF);
               ir_expression *const r1201 = logic_and(r11FC, r1200);
               ir_if *f11FA = new(mem_ctx) ir_if(operand(r1201).val);
               exec_list *const f11FA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f11FA->then_instructions;

                  ir_variable *const r1202 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1204 = logic_and(r11EB, r11F3);
                  ir_if *f1203 = new(mem_ctx) ir_if(operand(r1204).val);
                  exec_list *const f1203_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1203->then_instructions;

                     body.emit(assign(r1202, r11E9, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1203->else_instructions;

                     body.emit(assign(r1202, r11E8, 0x03));


                  body.instructions = f1203_parent_instructions;
                  body.emit(f1203);

                  /* END IF */

                  body.emit(assign(r11EA, r1202, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f11FA->else_instructions;

                  body.emit(assign(r11EA, r11E9, 0x03));


               body.instructions = f11FA_parent_instructions;
               body.emit(f11FA);

               /* END IF */

               body.emit(assign(r11CD, r11EA, 0x03));

               body.emit(assign(r11CC, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f11E5->else_instructions;

               body.emit(assign(r11CD, r0DAF, 0x03));

               body.emit(assign(r11CC, body.constant(false), 0x01));


            body.instructions = f11E5_parent_instructions;
            body.emit(f11E5);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f11E3->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1206 = equal(r11DD, body.constant(int(0)));
            ir_if *f1205 = new(mem_ctx) ir_if(operand(r1206).val);
            exec_list *const f1205_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1205->then_instructions;

               body.emit(assign(r11CE, add(r11E0, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1205->else_instructions;

               body.emit(assign(r11CF, bit_or(r11D9, body.constant(1048576u)), 0x01));


            body.instructions = f1205_parent_instructions;
            body.emit(f1205);

            /* END IF */

            ir_variable *const r1207 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r1207, body.constant(0u), 0x01));

            ir_variable *const r1208 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r1208);
            ir_variable *const r1209 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1209);
            ir_variable *const r120A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r120A);
            ir_variable *const r120B = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r120C = neg(r11CE);
            body.emit(assign(r120B, bit_and(r120C, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r120E = equal(r11CE, body.constant(int(0)));
            ir_if *f120D = new(mem_ctx) ir_if(operand(r120E).val);
            exec_list *const f120D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f120D->then_instructions;

               body.emit(assign(r1208, r1207, 0x01));

               body.emit(assign(r1209, r11D8, 0x01));

               body.emit(assign(r120A, r11CF, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f120D->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1210 = less(r11CE, body.constant(int(32)));
               ir_if *f120F = new(mem_ctx) ir_if(operand(r1210).val);
               exec_list *const f120F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f120F->then_instructions;

                  body.emit(assign(r1208, lshift(swizzle_x(r0DB0), r120B), 0x01));

                  ir_expression *const r1211 = lshift(r11CF, r120B);
                  ir_expression *const r1212 = rshift(swizzle_x(r0DB0), r11CE);
                  body.emit(assign(r1209, bit_or(r1211, r1212), 0x01));

                  body.emit(assign(r120A, rshift(r11CF, r11CE), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f120F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1214 = equal(r11CE, body.constant(int(32)));
                  ir_if *f1213 = new(mem_ctx) ir_if(operand(r1214).val);
                  exec_list *const f1213_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1213->then_instructions;

                     body.emit(assign(r1208, r11D8, 0x01));

                     body.emit(assign(r1209, r11CF, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1213->else_instructions;

                     body.emit(assign(r1207, bit_or(body.constant(0u), swizzle_x(r0DB0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1216 = less(r11CE, body.constant(int(64)));
                     ir_if *f1215 = new(mem_ctx) ir_if(operand(r1216).val);
                     exec_list *const f1215_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1215->then_instructions;

                        body.emit(assign(r1208, lshift(r11CF, r120B), 0x01));

                        ir_expression *const r1217 = bit_and(r11CE, body.constant(int(31)));
                        body.emit(assign(r1209, rshift(r11CF, r1217), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1215->else_instructions;

                        ir_variable *const r1218 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r121A = equal(r11CE, body.constant(int(64)));
                        ir_if *f1219 = new(mem_ctx) ir_if(operand(r121A).val);
                        exec_list *const f1219_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1219->then_instructions;

                           body.emit(assign(r1218, r11CF, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1219->else_instructions;

                           ir_expression *const r121B = nequal(r11CF, body.constant(0u));
                           ir_expression *const r121C = expr(ir_unop_b2i, r121B);
                           body.emit(assign(r1218, expr(ir_unop_i2u, r121C), 0x01));


                        body.instructions = f1219_parent_instructions;
                        body.emit(f1219);

                        /* END IF */

                        body.emit(assign(r1208, r1218, 0x01));

                        body.emit(assign(r1209, body.constant(0u), 0x01));


                     body.instructions = f1215_parent_instructions;
                     body.emit(f1215);

                     /* END IF */


                  body.instructions = f1213_parent_instructions;
                  body.emit(f1213);

                  /* END IF */

                  body.emit(assign(r120A, body.constant(0u), 0x01));


               body.instructions = f120F_parent_instructions;
               body.emit(f120F);

               /* END IF */

               ir_expression *const r121D = nequal(r1207, body.constant(0u));
               ir_expression *const r121E = expr(ir_unop_b2i, r121D);
               ir_expression *const r121F = expr(ir_unop_i2u, r121E);
               body.emit(assign(r1208, bit_or(r1208, r121F), 0x01));


            body.instructions = f120D_parent_instructions;
            body.emit(f120D);

            /* END IF */

            body.emit(assign(r11CF, r120A, 0x01));

            body.emit(assign(r11D0, r1209, 0x01));

            body.emit(assign(r11D4, r1208, 0x01));

            body.emit(assign(r11D3, r11DA, 0x01));


         body.instructions = f11E3_parent_instructions;
         body.emit(f11E3);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f11E1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1221 = less(r11CE, body.constant(int(0)));
         ir_if *f1220 = new(mem_ctx) ir_if(operand(r1221).val);
         exec_list *const f1220_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1220->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1223 = equal(r11DD, body.constant(int(2047)));
            ir_if *f1222 = new(mem_ctx) ir_if(operand(r1223).val);
            exec_list *const f1222_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1222->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1225 = bit_or(r11CF, r11D0);
               ir_expression *const r1226 = nequal(r1225, body.constant(0u));
               ir_if *f1224 = new(mem_ctx) ir_if(operand(r1226).val);
               exec_list *const f1224_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1224->then_instructions;

                  ir_variable *const r1227 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1227, swizzle_x(r0DAF), 0x01));

                  ir_variable *const r1228 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1228, swizzle_x(r0DB0), 0x01));

                  ir_variable *const r1229 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r122A = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r122B = rshift(swizzle_y(r0DAF), body.constant(int(19)));
                  ir_expression *const r122C = bit_and(r122B, body.constant(4095u));
                  ir_expression *const r122D = equal(r122C, body.constant(4094u));
                  ir_expression *const r122E = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r122F = bit_and(swizzle_y(r0DAF), body.constant(524287u));
                  ir_expression *const r1230 = nequal(r122F, body.constant(0u));
                  ir_expression *const r1231 = logic_or(r122E, r1230);
                  body.emit(assign(r122A, logic_and(r122D, r1231), 0x01));

                  ir_variable *const r1232 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r1233 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
                  ir_expression *const r1234 = lequal(body.constant(4292870144u), r1233);
                  ir_expression *const r1235 = nequal(swizzle_x(r0DB0), body.constant(0u));
                  ir_expression *const r1236 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
                  ir_expression *const r1237 = nequal(r1236, body.constant(0u));
                  ir_expression *const r1238 = logic_or(r1235, r1237);
                  body.emit(assign(r1232, logic_and(r1234, r1238), 0x01));

                  body.emit(assign(r1227, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

                  body.emit(assign(r1228, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r123A = lshift(swizzle_y(r0DAF), body.constant(int(1)));
                  ir_expression *const r123B = lequal(body.constant(4292870144u), r123A);
                  ir_expression *const r123C = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r123D = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
                  ir_expression *const r123E = nequal(r123D, body.constant(0u));
                  ir_expression *const r123F = logic_or(r123C, r123E);
                  ir_expression *const r1240 = logic_and(r123B, r123F);
                  ir_if *f1239 = new(mem_ctx) ir_if(operand(r1240).val);
                  exec_list *const f1239_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1239->then_instructions;

                     ir_variable *const r1241 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1243 = logic_and(r122A, r1232);
                     ir_if *f1242 = new(mem_ctx) ir_if(operand(r1243).val);
                     exec_list *const f1242_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1242->then_instructions;

                        body.emit(assign(r1241, r1228, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1242->else_instructions;

                        body.emit(assign(r1241, r1227, 0x03));


                     body.instructions = f1242_parent_instructions;
                     body.emit(f1242);

                     /* END IF */

                     body.emit(assign(r1229, r1241, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1239->else_instructions;

                     body.emit(assign(r1229, r1228, 0x03));


                  body.instructions = f1239_parent_instructions;
                  body.emit(f1239);

                  /* END IF */

                  body.emit(assign(r11CD, r1229, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1224->else_instructions;

                  ir_variable *const r1244 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1244);
                  ir_expression *const r1245 = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r1244, add(r1245, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1244, body.constant(0u), 0x01));

                  body.emit(assign(r11CD, r1244, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


               body.instructions = f1224_parent_instructions;
               body.emit(f1224);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1222->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1247 = equal(r11DA, body.constant(int(0)));
               ir_if *f1246 = new(mem_ctx) ir_if(operand(r1247).val);
               exec_list *const f1246_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1246->then_instructions;

                  body.emit(assign(r11CE, add(r11CE, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1246->else_instructions;

                  body.emit(assign(r11D1, bit_or(r11D7, body.constant(1048576u)), 0x01));


               body.instructions = f1246_parent_instructions;
               body.emit(f1246);

               /* END IF */

               ir_variable *const r1248 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r1248, body.constant(0u), 0x01));

               ir_variable *const r1249 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1249, neg(r11CE), 0x01));

               ir_variable *const r124A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r124A);
               ir_variable *const r124B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r124B);
               ir_variable *const r124C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r124C);
               ir_variable *const r124D = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r124E = neg(r1249);
               body.emit(assign(r124D, bit_and(r124E, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1250 = equal(r1249, body.constant(int(0)));
               ir_if *f124F = new(mem_ctx) ir_if(operand(r1250).val);
               exec_list *const f124F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f124F->then_instructions;

                  body.emit(assign(r124A, r1248, 0x01));

                  body.emit(assign(r124B, r11D6, 0x01));

                  body.emit(assign(r124C, r11D1, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f124F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1252 = less(r1249, body.constant(int(32)));
                  ir_if *f1251 = new(mem_ctx) ir_if(operand(r1252).val);
                  exec_list *const f1251_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1251->then_instructions;

                     body.emit(assign(r124A, lshift(swizzle_x(r0DAF), r124D), 0x01));

                     ir_expression *const r1253 = lshift(r11D1, r124D);
                     ir_expression *const r1254 = rshift(swizzle_x(r0DAF), r1249);
                     body.emit(assign(r124B, bit_or(r1253, r1254), 0x01));

                     body.emit(assign(r124C, rshift(r11D1, r1249), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1251->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1256 = equal(r1249, body.constant(int(32)));
                     ir_if *f1255 = new(mem_ctx) ir_if(operand(r1256).val);
                     exec_list *const f1255_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1255->then_instructions;

                        body.emit(assign(r124A, r11D6, 0x01));

                        body.emit(assign(r124B, r11D1, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1255->else_instructions;

                        body.emit(assign(r1248, bit_or(body.constant(0u), swizzle_x(r0DAF)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1258 = less(r1249, body.constant(int(64)));
                        ir_if *f1257 = new(mem_ctx) ir_if(operand(r1258).val);
                        exec_list *const f1257_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1257->then_instructions;

                           body.emit(assign(r124A, lshift(r11D1, r124D), 0x01));

                           ir_expression *const r1259 = bit_and(r1249, body.constant(int(31)));
                           body.emit(assign(r124B, rshift(r11D1, r1259), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1257->else_instructions;

                           ir_variable *const r125A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r125C = equal(r1249, body.constant(int(64)));
                           ir_if *f125B = new(mem_ctx) ir_if(operand(r125C).val);
                           exec_list *const f125B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f125B->then_instructions;

                              body.emit(assign(r125A, r11D1, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f125B->else_instructions;

                              ir_expression *const r125D = nequal(r11D1, body.constant(0u));
                              ir_expression *const r125E = expr(ir_unop_b2i, r125D);
                              body.emit(assign(r125A, expr(ir_unop_i2u, r125E), 0x01));


                           body.instructions = f125B_parent_instructions;
                           body.emit(f125B);

                           /* END IF */

                           body.emit(assign(r124A, r125A, 0x01));

                           body.emit(assign(r124B, body.constant(0u), 0x01));


                        body.instructions = f1257_parent_instructions;
                        body.emit(f1257);

                        /* END IF */


                     body.instructions = f1255_parent_instructions;
                     body.emit(f1255);

                     /* END IF */

                     body.emit(assign(r124C, body.constant(0u), 0x01));


                  body.instructions = f1251_parent_instructions;
                  body.emit(f1251);

                  /* END IF */

                  ir_expression *const r125F = nequal(r1248, body.constant(0u));
                  ir_expression *const r1260 = expr(ir_unop_b2i, r125F);
                  ir_expression *const r1261 = expr(ir_unop_i2u, r1260);
                  body.emit(assign(r124A, bit_or(r124A, r1261), 0x01));


               body.instructions = f124F_parent_instructions;
               body.emit(f124F);

               /* END IF */

               body.emit(assign(r11D1, r124C, 0x01));

               body.emit(assign(r11D2, r124B, 0x01));

               body.emit(assign(r11D4, r124A, 0x01));

               body.emit(assign(r11D3, r11DD, 0x01));


            body.instructions = f1222_parent_instructions;
            body.emit(f1222);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1220->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1263 = equal(r11DA, body.constant(int(2047)));
            ir_if *f1262 = new(mem_ctx) ir_if(operand(r1263).val);
            exec_list *const f1262_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1262->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1265 = bit_or(r11D1, r11D2);
               ir_expression *const r1266 = bit_or(r11CF, r11D0);
               ir_expression *const r1267 = bit_or(r1265, r1266);
               ir_expression *const r1268 = nequal(r1267, body.constant(0u));
               ir_if *f1264 = new(mem_ctx) ir_if(operand(r1268).val);
               exec_list *const f1264_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1264->then_instructions;

                  ir_variable *const r1269 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1269, swizzle_x(r0DAF), 0x01));

                  ir_variable *const r126A = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r126A, swizzle_x(r0DB0), 0x01));

                  ir_variable *const r126B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r126C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r126D = rshift(swizzle_y(r0DAF), body.constant(int(19)));
                  ir_expression *const r126E = bit_and(r126D, body.constant(4095u));
                  ir_expression *const r126F = equal(r126E, body.constant(4094u));
                  ir_expression *const r1270 = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r1271 = bit_and(swizzle_y(r0DAF), body.constant(524287u));
                  ir_expression *const r1272 = nequal(r1271, body.constant(0u));
                  ir_expression *const r1273 = logic_or(r1270, r1272);
                  body.emit(assign(r126C, logic_and(r126F, r1273), 0x01));

                  ir_variable *const r1274 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r1275 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
                  ir_expression *const r1276 = lequal(body.constant(4292870144u), r1275);
                  ir_expression *const r1277 = nequal(swizzle_x(r0DB0), body.constant(0u));
                  ir_expression *const r1278 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
                  ir_expression *const r1279 = nequal(r1278, body.constant(0u));
                  ir_expression *const r127A = logic_or(r1277, r1279);
                  body.emit(assign(r1274, logic_and(r1276, r127A), 0x01));

                  body.emit(assign(r1269, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

                  body.emit(assign(r126A, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r127C = lshift(swizzle_y(r0DAF), body.constant(int(1)));
                  ir_expression *const r127D = lequal(body.constant(4292870144u), r127C);
                  ir_expression *const r127E = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r127F = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
                  ir_expression *const r1280 = nequal(r127F, body.constant(0u));
                  ir_expression *const r1281 = logic_or(r127E, r1280);
                  ir_expression *const r1282 = logic_and(r127D, r1281);
                  ir_if *f127B = new(mem_ctx) ir_if(operand(r1282).val);
                  exec_list *const f127B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f127B->then_instructions;

                     ir_variable *const r1283 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1285 = logic_and(r126C, r1274);
                     ir_if *f1284 = new(mem_ctx) ir_if(operand(r1285).val);
                     exec_list *const f1284_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1284->then_instructions;

                        body.emit(assign(r1283, r126A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1284->else_instructions;

                        body.emit(assign(r1283, r1269, 0x03));


                     body.instructions = f1284_parent_instructions;
                     body.emit(f1284);

                     /* END IF */

                     body.emit(assign(r126B, r1283, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f127B->else_instructions;

                     body.emit(assign(r126B, r126A, 0x03));


                  body.instructions = f127B_parent_instructions;
                  body.emit(f127B);

                  /* END IF */

                  body.emit(assign(r11CD, r126B, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1264->else_instructions;

                  body.emit(assign(r11CD, r0DAF, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


               body.instructions = f1264_parent_instructions;
               body.emit(f1264);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1262->else_instructions;

               ir_variable *const r1286 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1287 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1287, add(r11D2, r11D0), 0x01));

               ir_expression *const r1288 = add(r11D1, r11CF);
               ir_expression *const r1289 = less(r1287, r11D2);
               ir_expression *const r128A = expr(ir_unop_b2i, r1289);
               ir_expression *const r128B = expr(ir_unop_i2u, r128A);
               body.emit(assign(r1286, add(r1288, r128B), 0x01));

               body.emit(assign(r11D5, r1286, 0x01));

               /* IF CONDITION */
               ir_expression *const r128D = equal(r11DA, body.constant(int(0)));
               ir_if *f128C = new(mem_ctx) ir_if(operand(r128D).val);
               exec_list *const f128C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f128C->then_instructions;

                  ir_variable *const r128E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r128E);
                  ir_expression *const r128F = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r128E, add(r128F, r1286), 0x02));

                  body.emit(assign(r128E, r1287, 0x01));

                  body.emit(assign(r11CD, r128E, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f128C->else_instructions;

                  body.emit(assign(r11D5, bit_or(r1286, body.constant(2097152u)), 0x01));

                  body.emit(assign(r11D3, r11DA, 0x01));

                  ir_variable *const r1290 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1290);
                  ir_variable *const r1291 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1291);
                  ir_variable *const r1292 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1292);
                  body.emit(assign(r1290, lshift(r1287, body.constant(int(31))), 0x01));

                  ir_expression *const r1293 = lshift(r11D5, body.constant(int(31)));
                  ir_expression *const r1294 = rshift(r1287, body.constant(int(1)));
                  body.emit(assign(r1291, bit_or(r1293, r1294), 0x01));

                  body.emit(assign(r1292, rshift(r11D5, body.constant(int(1))), 0x01));

                  body.emit(assign(r1290, bit_or(r1290, body.constant(0u)), 0x01));

                  body.emit(assign(r11D5, r1292, 0x01));

                  body.emit(assign(r11D4, r1290, 0x01));

                  ir_variable *const r1295 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r1295, r11DA, 0x01));

                  ir_variable *const r1296 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r1296, r1292, 0x01));

                  ir_variable *const r1297 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r1297, r1291, 0x01));

                  ir_variable *const r1298 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r1298, r1290, 0x01));

                  ir_variable *const r1299 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r1299, body.constant(true), 0x01));

                  ir_variable *const r129A = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r129B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r129B);
                  ir_expression *const r129C = expr(ir_unop_u2i, r1290);
                  body.emit(assign(r129B, less(r129C, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r129E = lequal(body.constant(int(2045)), r11DA);
                  ir_if *f129D = new(mem_ctx) ir_if(operand(r129E).val);
                  exec_list *const f129D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f129D->then_instructions;

                     ir_variable *const r129F = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r12A1 = less(body.constant(int(2045)), r11DA);
                     ir_if *f12A0 = new(mem_ctx) ir_if(operand(r12A1).val);
                     exec_list *const f12A0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12A0->then_instructions;

                        body.emit(assign(r129F, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12A0->else_instructions;

                        ir_variable *const r12A2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r12A4 = equal(r11DA, body.constant(int(2045)));
                        ir_if *f12A3 = new(mem_ctx) ir_if(operand(r12A4).val);
                        exec_list *const f12A3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12A3->then_instructions;

                           ir_expression *const r12A5 = equal(body.constant(2097151u), r1292);
                           ir_expression *const r12A6 = equal(body.constant(4294967295u), r1291);
                           body.emit(assign(r12A2, logic_and(r12A5, r12A6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f12A3->else_instructions;

                           body.emit(assign(r12A2, body.constant(false), 0x01));


                        body.instructions = f12A3_parent_instructions;
                        body.emit(f12A3);

                        /* END IF */

                        body.emit(assign(r129F, logic_and(r12A2, r129B), 0x01));


                     body.instructions = f12A0_parent_instructions;
                     body.emit(f12A0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f12A7 = new(mem_ctx) ir_if(operand(r129F).val);
                     exec_list *const f12A7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12A7->then_instructions;

                        ir_variable *const r12A8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r12A8);
                        ir_expression *const r12A9 = lshift(r0DB2, body.constant(int(31)));
                        body.emit(assign(r12A8, add(r12A9, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r12A8, body.constant(0u), 0x01));

                        body.emit(assign(r129A, r12A8, 0x03));

                        body.emit(assign(r1299, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12A7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r12AB = less(r11DA, body.constant(int(0)));
                        ir_if *f12AA = new(mem_ctx) ir_if(operand(r12AB).val);
                        exec_list *const f12AA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12AA->then_instructions;

                           ir_variable *const r12AC = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r12AC, r1290, 0x01));

                           ir_variable *const r12AD = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r12AD, neg(r11DA), 0x01));

                           ir_variable *const r12AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r12AE);
                           ir_variable *const r12AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r12AF);
                           ir_variable *const r12B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r12B0);
                           ir_variable *const r12B1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r12B2 = neg(r12AD);
                           body.emit(assign(r12B1, bit_and(r12B2, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r12B4 = equal(r12AD, body.constant(int(0)));
                           ir_if *f12B3 = new(mem_ctx) ir_if(operand(r12B4).val);
                           exec_list *const f12B3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f12B3->then_instructions;

                              body.emit(assign(r12AE, r1290, 0x01));

                              body.emit(assign(r12AF, r1291, 0x01));

                              body.emit(assign(r12B0, r1292, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f12B3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r12B6 = less(r12AD, body.constant(int(32)));
                              ir_if *f12B5 = new(mem_ctx) ir_if(operand(r12B6).val);
                              exec_list *const f12B5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f12B5->then_instructions;

                                 body.emit(assign(r12AE, lshift(r1291, r12B1), 0x01));

                                 ir_expression *const r12B7 = lshift(r1292, r12B1);
                                 ir_expression *const r12B8 = rshift(r1291, r12AD);
                                 body.emit(assign(r12AF, bit_or(r12B7, r12B8), 0x01));

                                 body.emit(assign(r12B0, rshift(r1292, r12AD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f12B5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r12BA = equal(r12AD, body.constant(int(32)));
                                 ir_if *f12B9 = new(mem_ctx) ir_if(operand(r12BA).val);
                                 exec_list *const f12B9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f12B9->then_instructions;

                                    body.emit(assign(r12AE, r1291, 0x01));

                                    body.emit(assign(r12AF, r1292, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f12B9->else_instructions;

                                    body.emit(assign(r12AC, bit_or(r1290, r1291), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r12BC = less(r12AD, body.constant(int(64)));
                                    ir_if *f12BB = new(mem_ctx) ir_if(operand(r12BC).val);
                                    exec_list *const f12BB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f12BB->then_instructions;

                                       body.emit(assign(r12AE, lshift(r1292, r12B1), 0x01));

                                       ir_expression *const r12BD = bit_and(r12AD, body.constant(int(31)));
                                       body.emit(assign(r12AF, rshift(r1292, r12BD), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f12BB->else_instructions;

                                       ir_variable *const r12BE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r12C0 = equal(r12AD, body.constant(int(64)));
                                       ir_if *f12BF = new(mem_ctx) ir_if(operand(r12C0).val);
                                       exec_list *const f12BF_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f12BF->then_instructions;

                                          body.emit(assign(r12BE, r1292, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f12BF->else_instructions;

                                          ir_expression *const r12C1 = nequal(r1292, body.constant(0u));
                                          ir_expression *const r12C2 = expr(ir_unop_b2i, r12C1);
                                          body.emit(assign(r12BE, expr(ir_unop_i2u, r12C2), 0x01));


                                       body.instructions = f12BF_parent_instructions;
                                       body.emit(f12BF);

                                       /* END IF */

                                       body.emit(assign(r12AE, r12BE, 0x01));

                                       body.emit(assign(r12AF, body.constant(0u), 0x01));


                                    body.instructions = f12BB_parent_instructions;
                                    body.emit(f12BB);

                                    /* END IF */


                                 body.instructions = f12B9_parent_instructions;
                                 body.emit(f12B9);

                                 /* END IF */

                                 body.emit(assign(r12B0, body.constant(0u), 0x01));


                              body.instructions = f12B5_parent_instructions;
                              body.emit(f12B5);

                              /* END IF */

                              ir_expression *const r12C3 = nequal(r12AC, body.constant(0u));
                              ir_expression *const r12C4 = expr(ir_unop_b2i, r12C3);
                              ir_expression *const r12C5 = expr(ir_unop_i2u, r12C4);
                              body.emit(assign(r12AE, bit_or(r12AE, r12C5), 0x01));


                           body.instructions = f12B3_parent_instructions;
                           body.emit(f12B3);

                           /* END IF */

                           body.emit(assign(r1296, r12B0, 0x01));

                           body.emit(assign(r1297, r12AF, 0x01));

                           body.emit(assign(r1298, r12AE, 0x01));

                           body.emit(assign(r1295, body.constant(int(0)), 0x01));

                           body.emit(assign(r129B, less(r12AE, body.constant(0u)), 0x01));


                        body.instructions = f12AA_parent_instructions;
                        body.emit(f12AA);

                        /* END IF */


                     body.instructions = f12A7_parent_instructions;
                     body.emit(f12A7);

                     /* END IF */


                  body.instructions = f129D_parent_instructions;
                  body.emit(f129D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f12C6 = new(mem_ctx) ir_if(operand(r1299).val);
                  exec_list *const f12C6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12C6->then_instructions;

                     /* IF CONDITION */
                     ir_if *f12C7 = new(mem_ctx) ir_if(operand(r129B).val);
                     exec_list *const f12C7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12C7->then_instructions;

                        ir_variable *const r12C8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r12C8, add(r1297, body.constant(1u)), 0x01));

                        ir_expression *const r12C9 = less(r12C8, r1297);
                        ir_expression *const r12CA = expr(ir_unop_b2i, r12C9);
                        ir_expression *const r12CB = expr(ir_unop_i2u, r12CA);
                        body.emit(assign(r1296, add(r1296, r12CB), 0x01));

                        ir_expression *const r12CC = equal(r1298, body.constant(0u));
                        ir_expression *const r12CD = expr(ir_unop_b2i, r12CC);
                        ir_expression *const r12CE = expr(ir_unop_i2u, r12CD);
                        ir_expression *const r12CF = add(r1298, r12CE);
                        ir_expression *const r12D0 = bit_and(r12CF, body.constant(1u));
                        ir_expression *const r12D1 = expr(ir_unop_bit_not, r12D0);
                        body.emit(assign(r1297, bit_and(r12C8, r12D1), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12C7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r12D3 = bit_or(r1296, r1297);
                        ir_expression *const r12D4 = equal(r12D3, body.constant(0u));
                        ir_if *f12D2 = new(mem_ctx) ir_if(operand(r12D4).val);
                        exec_list *const f12D2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12D2->then_instructions;

                           body.emit(assign(r1295, body.constant(int(0)), 0x01));


                        body.instructions = f12D2_parent_instructions;
                        body.emit(f12D2);

                        /* END IF */


                     body.instructions = f12C7_parent_instructions;
                     body.emit(f12C7);

                     /* END IF */

                     ir_variable *const r12D5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r12D5);
                     ir_expression *const r12D6 = lshift(r0DB2, body.constant(int(31)));
                     ir_expression *const r12D7 = expr(ir_unop_i2u, r1295);
                     ir_expression *const r12D8 = lshift(r12D7, body.constant(int(20)));
                     ir_expression *const r12D9 = add(r12D6, r12D8);
                     body.emit(assign(r12D5, add(r12D9, r1296), 0x02));

                     body.emit(assign(r12D5, r1297, 0x01));

                     body.emit(assign(r129A, r12D5, 0x03));

                     body.emit(assign(r1299, body.constant(false), 0x01));


                  body.instructions = f12C6_parent_instructions;
                  body.emit(f12C6);

                  /* END IF */

                  body.emit(assign(r11CD, r129A, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


               body.instructions = f128C_parent_instructions;
               body.emit(f128C);

               /* END IF */


            body.instructions = f1262_parent_instructions;
            body.emit(f1262);

            /* END IF */


         body.instructions = f1220_parent_instructions;
         body.emit(f1220);

         /* END IF */


      body.instructions = f11E1_parent_instructions;
      body.emit(f11E1);

      /* END IF */

      /* IF CONDITION */
      ir_if *f12DA = new(mem_ctx) ir_if(operand(r11CC).val);
      exec_list *const f12DA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f12DA->then_instructions;

         body.emit(assign(r11D1, bit_or(r11D1, body.constant(1048576u)), 0x01));

         ir_variable *const r12DB = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r12DC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r12DC, add(r11D2, r11D0), 0x01));

         ir_expression *const r12DD = add(r11D1, r11CF);
         ir_expression *const r12DE = less(r12DC, r11D2);
         ir_expression *const r12DF = expr(ir_unop_b2i, r12DE);
         ir_expression *const r12E0 = expr(ir_unop_i2u, r12DF);
         body.emit(assign(r12DB, add(r12DD, r12E0), 0x01));

         body.emit(assign(r11D5, r12DB, 0x01));

         body.emit(assign(r11D3, add(r11D3, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r12E2 = less(r12DB, body.constant(2097152u));
         ir_if *f12E1 = new(mem_ctx) ir_if(operand(r12E2).val);
         exec_list *const f12E1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f12E1->then_instructions;

            ir_variable *const r12E3 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r12E3, r11D3, 0x01));

            ir_variable *const r12E4 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r12E4, r12DB, 0x01));

            ir_variable *const r12E5 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r12E5, r12DC, 0x01));

            ir_variable *const r12E6 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r12E6, r11D4, 0x01));

            ir_variable *const r12E7 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r12E7, body.constant(true), 0x01));

            ir_variable *const r12E8 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r12E9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r12E9);
            ir_expression *const r12EA = expr(ir_unop_u2i, r11D4);
            body.emit(assign(r12E9, less(r12EA, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r12EC = lequal(body.constant(int(2045)), r11D3);
            ir_if *f12EB = new(mem_ctx) ir_if(operand(r12EC).val);
            exec_list *const f12EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f12EB->then_instructions;

               ir_variable *const r12ED = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r12EF = less(body.constant(int(2045)), r11D3);
               ir_if *f12EE = new(mem_ctx) ir_if(operand(r12EF).val);
               exec_list *const f12EE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12EE->then_instructions;

                  body.emit(assign(r12ED, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f12EE->else_instructions;

                  ir_variable *const r12F0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r12F2 = equal(r11D3, body.constant(int(2045)));
                  ir_if *f12F1 = new(mem_ctx) ir_if(operand(r12F2).val);
                  exec_list *const f12F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12F1->then_instructions;

                     ir_expression *const r12F3 = equal(body.constant(2097151u), r12DB);
                     ir_expression *const r12F4 = equal(body.constant(4294967295u), r12DC);
                     body.emit(assign(r12F0, logic_and(r12F3, r12F4), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f12F1->else_instructions;

                     body.emit(assign(r12F0, body.constant(false), 0x01));


                  body.instructions = f12F1_parent_instructions;
                  body.emit(f12F1);

                  /* END IF */

                  body.emit(assign(r12ED, logic_and(r12F0, r12E9), 0x01));


               body.instructions = f12EE_parent_instructions;
               body.emit(f12EE);

               /* END IF */

               /* IF CONDITION */
               ir_if *f12F5 = new(mem_ctx) ir_if(operand(r12ED).val);
               exec_list *const f12F5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12F5->then_instructions;

                  ir_variable *const r12F6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r12F6);
                  ir_expression *const r12F7 = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r12F6, add(r12F7, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r12F6, body.constant(0u), 0x01));

                  body.emit(assign(r12E8, r12F6, 0x03));

                  body.emit(assign(r12E7, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f12F5->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r12F9 = less(r11D3, body.constant(int(0)));
                  ir_if *f12F8 = new(mem_ctx) ir_if(operand(r12F9).val);
                  exec_list *const f12F8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12F8->then_instructions;

                     ir_variable *const r12FA = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r12FA, r11D4, 0x01));

                     ir_variable *const r12FB = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r12FB, neg(r11D3), 0x01));

                     ir_variable *const r12FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r12FC);
                     ir_variable *const r12FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r12FD);
                     ir_variable *const r12FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r12FE);
                     ir_variable *const r12FF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r1300 = neg(r12FB);
                     body.emit(assign(r12FF, bit_and(r1300, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1302 = equal(r12FB, body.constant(int(0)));
                     ir_if *f1301 = new(mem_ctx) ir_if(operand(r1302).val);
                     exec_list *const f1301_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1301->then_instructions;

                        body.emit(assign(r12FC, r11D4, 0x01));

                        body.emit(assign(r12FD, r12DC, 0x01));

                        body.emit(assign(r12FE, r12DB, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1301->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1304 = less(r12FB, body.constant(int(32)));
                        ir_if *f1303 = new(mem_ctx) ir_if(operand(r1304).val);
                        exec_list *const f1303_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1303->then_instructions;

                           body.emit(assign(r12FC, lshift(r12DC, r12FF), 0x01));

                           ir_expression *const r1305 = lshift(r12DB, r12FF);
                           ir_expression *const r1306 = rshift(r12DC, r12FB);
                           body.emit(assign(r12FD, bit_or(r1305, r1306), 0x01));

                           body.emit(assign(r12FE, rshift(r12DB, r12FB), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1303->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1308 = equal(r12FB, body.constant(int(32)));
                           ir_if *f1307 = new(mem_ctx) ir_if(operand(r1308).val);
                           exec_list *const f1307_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1307->then_instructions;

                              body.emit(assign(r12FC, r12DC, 0x01));

                              body.emit(assign(r12FD, r12DB, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1307->else_instructions;

                              body.emit(assign(r12FA, bit_or(r11D4, r12DC), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r130A = less(r12FB, body.constant(int(64)));
                              ir_if *f1309 = new(mem_ctx) ir_if(operand(r130A).val);
                              exec_list *const f1309_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1309->then_instructions;

                                 body.emit(assign(r12FC, lshift(r12DB, r12FF), 0x01));

                                 ir_expression *const r130B = bit_and(r12FB, body.constant(int(31)));
                                 body.emit(assign(r12FD, rshift(r12DB, r130B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1309->else_instructions;

                                 ir_variable *const r130C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r130E = equal(r12FB, body.constant(int(64)));
                                 ir_if *f130D = new(mem_ctx) ir_if(operand(r130E).val);
                                 exec_list *const f130D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f130D->then_instructions;

                                    body.emit(assign(r130C, r12DB, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f130D->else_instructions;

                                    ir_expression *const r130F = nequal(r12DB, body.constant(0u));
                                    ir_expression *const r1310 = expr(ir_unop_b2i, r130F);
                                    body.emit(assign(r130C, expr(ir_unop_i2u, r1310), 0x01));


                                 body.instructions = f130D_parent_instructions;
                                 body.emit(f130D);

                                 /* END IF */

                                 body.emit(assign(r12FC, r130C, 0x01));

                                 body.emit(assign(r12FD, body.constant(0u), 0x01));


                              body.instructions = f1309_parent_instructions;
                              body.emit(f1309);

                              /* END IF */


                           body.instructions = f1307_parent_instructions;
                           body.emit(f1307);

                           /* END IF */

                           body.emit(assign(r12FE, body.constant(0u), 0x01));


                        body.instructions = f1303_parent_instructions;
                        body.emit(f1303);

                        /* END IF */

                        ir_expression *const r1311 = nequal(r12FA, body.constant(0u));
                        ir_expression *const r1312 = expr(ir_unop_b2i, r1311);
                        ir_expression *const r1313 = expr(ir_unop_i2u, r1312);
                        body.emit(assign(r12FC, bit_or(r12FC, r1313), 0x01));


                     body.instructions = f1301_parent_instructions;
                     body.emit(f1301);

                     /* END IF */

                     body.emit(assign(r12E4, r12FE, 0x01));

                     body.emit(assign(r12E5, r12FD, 0x01));

                     body.emit(assign(r12E6, r12FC, 0x01));

                     body.emit(assign(r12E3, body.constant(int(0)), 0x01));

                     body.emit(assign(r12E9, less(r12FC, body.constant(0u)), 0x01));


                  body.instructions = f12F8_parent_instructions;
                  body.emit(f12F8);

                  /* END IF */


               body.instructions = f12F5_parent_instructions;
               body.emit(f12F5);

               /* END IF */


            body.instructions = f12EB_parent_instructions;
            body.emit(f12EB);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1314 = new(mem_ctx) ir_if(operand(r12E7).val);
            exec_list *const f1314_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1314->then_instructions;

               /* IF CONDITION */
               ir_if *f1315 = new(mem_ctx) ir_if(operand(r12E9).val);
               exec_list *const f1315_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1315->then_instructions;

                  ir_variable *const r1316 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1316, add(r12E5, body.constant(1u)), 0x01));

                  ir_expression *const r1317 = less(r1316, r12E5);
                  ir_expression *const r1318 = expr(ir_unop_b2i, r1317);
                  ir_expression *const r1319 = expr(ir_unop_i2u, r1318);
                  body.emit(assign(r12E4, add(r12E4, r1319), 0x01));

                  ir_expression *const r131A = equal(r12E6, body.constant(0u));
                  ir_expression *const r131B = expr(ir_unop_b2i, r131A);
                  ir_expression *const r131C = expr(ir_unop_i2u, r131B);
                  ir_expression *const r131D = add(r12E6, r131C);
                  ir_expression *const r131E = bit_and(r131D, body.constant(1u));
                  ir_expression *const r131F = expr(ir_unop_bit_not, r131E);
                  body.emit(assign(r12E5, bit_and(r1316, r131F), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1315->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1321 = bit_or(r12E4, r12E5);
                  ir_expression *const r1322 = equal(r1321, body.constant(0u));
                  ir_if *f1320 = new(mem_ctx) ir_if(operand(r1322).val);
                  exec_list *const f1320_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1320->then_instructions;

                     body.emit(assign(r12E3, body.constant(int(0)), 0x01));


                  body.instructions = f1320_parent_instructions;
                  body.emit(f1320);

                  /* END IF */


               body.instructions = f1315_parent_instructions;
               body.emit(f1315);

               /* END IF */

               ir_variable *const r1323 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1323);
               ir_expression *const r1324 = lshift(r0DB2, body.constant(int(31)));
               ir_expression *const r1325 = expr(ir_unop_i2u, r12E3);
               ir_expression *const r1326 = lshift(r1325, body.constant(int(20)));
               ir_expression *const r1327 = add(r1324, r1326);
               body.emit(assign(r1323, add(r1327, r12E4), 0x02));

               body.emit(assign(r1323, r12E5, 0x01));

               body.emit(assign(r12E8, r1323, 0x03));

               body.emit(assign(r12E7, body.constant(false), 0x01));


            body.instructions = f1314_parent_instructions;
            body.emit(f1314);

            /* END IF */

            body.emit(assign(r11CD, r12E8, 0x03));

            body.emit(assign(r11CC, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f12E1->else_instructions;

            body.emit(assign(r11D3, add(r11D3, body.constant(int(1))), 0x01));

            ir_variable *const r1328 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r1328);
            ir_variable *const r1329 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1329);
            ir_variable *const r132A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r132A);
            body.emit(assign(r1328, lshift(r12DC, body.constant(int(31))), 0x01));

            ir_expression *const r132B = lshift(r12DB, body.constant(int(31)));
            ir_expression *const r132C = rshift(r12DC, body.constant(int(1)));
            body.emit(assign(r1329, bit_or(r132B, r132C), 0x01));

            body.emit(assign(r132A, rshift(r12DB, body.constant(int(1))), 0x01));

            ir_expression *const r132D = nequal(r11D4, body.constant(0u));
            ir_expression *const r132E = expr(ir_unop_b2i, r132D);
            ir_expression *const r132F = expr(ir_unop_i2u, r132E);
            body.emit(assign(r1328, bit_or(r1328, r132F), 0x01));

            body.emit(assign(r11D5, r132A, 0x01));

            body.emit(assign(r11D4, r1328, 0x01));

            ir_variable *const r1330 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r1330, r11D3, 0x01));

            ir_variable *const r1331 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r1331, r132A, 0x01));

            ir_variable *const r1332 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r1332, r1329, 0x01));

            ir_variable *const r1333 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r1333, r1328, 0x01));

            ir_variable *const r1334 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r1334, body.constant(true), 0x01));

            ir_variable *const r1335 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r1336 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r1336);
            ir_expression *const r1337 = expr(ir_unop_u2i, r1328);
            body.emit(assign(r1336, less(r1337, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1339 = lequal(body.constant(int(2045)), r11D3);
            ir_if *f1338 = new(mem_ctx) ir_if(operand(r1339).val);
            exec_list *const f1338_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1338->then_instructions;

               ir_variable *const r133A = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r133C = less(body.constant(int(2045)), r11D3);
               ir_if *f133B = new(mem_ctx) ir_if(operand(r133C).val);
               exec_list *const f133B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f133B->then_instructions;

                  body.emit(assign(r133A, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f133B->else_instructions;

                  ir_variable *const r133D = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r133F = equal(r11D3, body.constant(int(2045)));
                  ir_if *f133E = new(mem_ctx) ir_if(operand(r133F).val);
                  exec_list *const f133E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f133E->then_instructions;

                     ir_expression *const r1340 = equal(body.constant(2097151u), r132A);
                     ir_expression *const r1341 = equal(body.constant(4294967295u), r1329);
                     body.emit(assign(r133D, logic_and(r1340, r1341), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f133E->else_instructions;

                     body.emit(assign(r133D, body.constant(false), 0x01));


                  body.instructions = f133E_parent_instructions;
                  body.emit(f133E);

                  /* END IF */

                  body.emit(assign(r133A, logic_and(r133D, r1336), 0x01));


               body.instructions = f133B_parent_instructions;
               body.emit(f133B);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1342 = new(mem_ctx) ir_if(operand(r133A).val);
               exec_list *const f1342_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1342->then_instructions;

                  ir_variable *const r1343 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1343);
                  ir_expression *const r1344 = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r1343, add(r1344, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1343, body.constant(0u), 0x01));

                  body.emit(assign(r1335, r1343, 0x03));

                  body.emit(assign(r1334, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1342->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1346 = less(r11D3, body.constant(int(0)));
                  ir_if *f1345 = new(mem_ctx) ir_if(operand(r1346).val);
                  exec_list *const f1345_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1345->then_instructions;

                     ir_variable *const r1347 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r1347, r1328, 0x01));

                     ir_variable *const r1348 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r1348, neg(r11D3), 0x01));

                     ir_variable *const r1349 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r1349);
                     ir_variable *const r134A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r134A);
                     ir_variable *const r134B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r134B);
                     ir_variable *const r134C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r134D = neg(r1348);
                     body.emit(assign(r134C, bit_and(r134D, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r134F = equal(r1348, body.constant(int(0)));
                     ir_if *f134E = new(mem_ctx) ir_if(operand(r134F).val);
                     exec_list *const f134E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f134E->then_instructions;

                        body.emit(assign(r1349, r1328, 0x01));

                        body.emit(assign(r134A, r1329, 0x01));

                        body.emit(assign(r134B, r132A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f134E->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1351 = less(r1348, body.constant(int(32)));
                        ir_if *f1350 = new(mem_ctx) ir_if(operand(r1351).val);
                        exec_list *const f1350_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1350->then_instructions;

                           body.emit(assign(r1349, lshift(r1329, r134C), 0x01));

                           ir_expression *const r1352 = lshift(r132A, r134C);
                           ir_expression *const r1353 = rshift(r1329, r1348);
                           body.emit(assign(r134A, bit_or(r1352, r1353), 0x01));

                           body.emit(assign(r134B, rshift(r132A, r1348), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1350->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1355 = equal(r1348, body.constant(int(32)));
                           ir_if *f1354 = new(mem_ctx) ir_if(operand(r1355).val);
                           exec_list *const f1354_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1354->then_instructions;

                              body.emit(assign(r1349, r1329, 0x01));

                              body.emit(assign(r134A, r132A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1354->else_instructions;

                              body.emit(assign(r1347, bit_or(r1328, r1329), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1357 = less(r1348, body.constant(int(64)));
                              ir_if *f1356 = new(mem_ctx) ir_if(operand(r1357).val);
                              exec_list *const f1356_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1356->then_instructions;

                                 body.emit(assign(r1349, lshift(r132A, r134C), 0x01));

                                 ir_expression *const r1358 = bit_and(r1348, body.constant(int(31)));
                                 body.emit(assign(r134A, rshift(r132A, r1358), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1356->else_instructions;

                                 ir_variable *const r1359 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r135B = equal(r1348, body.constant(int(64)));
                                 ir_if *f135A = new(mem_ctx) ir_if(operand(r135B).val);
                                 exec_list *const f135A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f135A->then_instructions;

                                    body.emit(assign(r1359, r132A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f135A->else_instructions;

                                    ir_expression *const r135C = nequal(r132A, body.constant(0u));
                                    ir_expression *const r135D = expr(ir_unop_b2i, r135C);
                                    body.emit(assign(r1359, expr(ir_unop_i2u, r135D), 0x01));


                                 body.instructions = f135A_parent_instructions;
                                 body.emit(f135A);

                                 /* END IF */

                                 body.emit(assign(r1349, r1359, 0x01));

                                 body.emit(assign(r134A, body.constant(0u), 0x01));


                              body.instructions = f1356_parent_instructions;
                              body.emit(f1356);

                              /* END IF */


                           body.instructions = f1354_parent_instructions;
                           body.emit(f1354);

                           /* END IF */

                           body.emit(assign(r134B, body.constant(0u), 0x01));


                        body.instructions = f1350_parent_instructions;
                        body.emit(f1350);

                        /* END IF */

                        ir_expression *const r135E = nequal(r1347, body.constant(0u));
                        ir_expression *const r135F = expr(ir_unop_b2i, r135E);
                        ir_expression *const r1360 = expr(ir_unop_i2u, r135F);
                        body.emit(assign(r1349, bit_or(r1349, r1360), 0x01));


                     body.instructions = f134E_parent_instructions;
                     body.emit(f134E);

                     /* END IF */

                     body.emit(assign(r1331, r134B, 0x01));

                     body.emit(assign(r1332, r134A, 0x01));

                     body.emit(assign(r1333, r1349, 0x01));

                     body.emit(assign(r1330, body.constant(int(0)), 0x01));

                     body.emit(assign(r1336, less(r1349, body.constant(0u)), 0x01));


                  body.instructions = f1345_parent_instructions;
                  body.emit(f1345);

                  /* END IF */


               body.instructions = f1342_parent_instructions;
               body.emit(f1342);

               /* END IF */


            body.instructions = f1338_parent_instructions;
            body.emit(f1338);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1361 = new(mem_ctx) ir_if(operand(r1334).val);
            exec_list *const f1361_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1361->then_instructions;

               /* IF CONDITION */
               ir_if *f1362 = new(mem_ctx) ir_if(operand(r1336).val);
               exec_list *const f1362_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1362->then_instructions;

                  ir_variable *const r1363 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1363, add(r1332, body.constant(1u)), 0x01));

                  ir_expression *const r1364 = less(r1363, r1332);
                  ir_expression *const r1365 = expr(ir_unop_b2i, r1364);
                  ir_expression *const r1366 = expr(ir_unop_i2u, r1365);
                  body.emit(assign(r1331, add(r1331, r1366), 0x01));

                  ir_expression *const r1367 = equal(r1333, body.constant(0u));
                  ir_expression *const r1368 = expr(ir_unop_b2i, r1367);
                  ir_expression *const r1369 = expr(ir_unop_i2u, r1368);
                  ir_expression *const r136A = add(r1333, r1369);
                  ir_expression *const r136B = bit_and(r136A, body.constant(1u));
                  ir_expression *const r136C = expr(ir_unop_bit_not, r136B);
                  body.emit(assign(r1332, bit_and(r1363, r136C), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1362->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r136E = bit_or(r1331, r1332);
                  ir_expression *const r136F = equal(r136E, body.constant(0u));
                  ir_if *f136D = new(mem_ctx) ir_if(operand(r136F).val);
                  exec_list *const f136D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f136D->then_instructions;

                     body.emit(assign(r1330, body.constant(int(0)), 0x01));


                  body.instructions = f136D_parent_instructions;
                  body.emit(f136D);

                  /* END IF */


               body.instructions = f1362_parent_instructions;
               body.emit(f1362);

               /* END IF */

               ir_variable *const r1370 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1370);
               ir_expression *const r1371 = lshift(r0DB2, body.constant(int(31)));
               ir_expression *const r1372 = expr(ir_unop_i2u, r1330);
               ir_expression *const r1373 = lshift(r1372, body.constant(int(20)));
               ir_expression *const r1374 = add(r1371, r1373);
               body.emit(assign(r1370, add(r1374, r1331), 0x02));

               body.emit(assign(r1370, r1332, 0x01));

               body.emit(assign(r1335, r1370, 0x03));

               body.emit(assign(r1334, body.constant(false), 0x01));


            body.instructions = f1361_parent_instructions;
            body.emit(f1361);

            /* END IF */

            body.emit(assign(r11CD, r1335, 0x03));

            body.emit(assign(r11CC, body.constant(false), 0x01));


         body.instructions = f12E1_parent_instructions;
         body.emit(f12E1);

         /* END IF */


      body.instructions = f12DA_parent_instructions;
      body.emit(f12DA);

      /* END IF */

      body.emit(assign(r0DB1, r11CD, 0x03));


   body.instructions = f0DB4_parent_instructions;
   body.emit(f0DB4);

   /* END IF */

   body.emit(ret(r0DB1));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul32To64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1375 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1375);
   ir_variable *const r1376 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1376);
   ir_variable *const r1377 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1377);
   ir_variable *const r1378 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1378);
   ir_variable *const r1379 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1379);
   ir_variable *const r137A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r137A);
   ir_variable *const r137B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r137B);
   ir_variable *const r137C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r137C, bit_and(r1375, body.constant(65535u)), 0x01));

   ir_variable *const r137D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r137D, rshift(r1375, body.constant(int(16))), 0x01));

   ir_variable *const r137E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r137E, bit_and(r1376, body.constant(65535u)), 0x01));

   ir_variable *const r137F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r137F, rshift(r1376, body.constant(int(16))), 0x01));

   ir_variable *const r1380 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1380, mul(r137D, r137E), 0x01));

   ir_expression *const r1381 = mul(r137C, r137F);
   body.emit(assign(r137A, add(r1381, r1380), 0x01));

   ir_expression *const r1382 = mul(r137D, r137F);
   ir_expression *const r1383 = less(r137A, r1380);
   ir_expression *const r1384 = expr(ir_unop_b2i, r1383);
   ir_expression *const r1385 = expr(ir_unop_i2u, r1384);
   ir_expression *const r1386 = lshift(r1385, body.constant(int(16)));
   ir_expression *const r1387 = rshift(r137A, body.constant(int(16)));
   ir_expression *const r1388 = add(r1386, r1387);
   body.emit(assign(r1379, add(r1382, r1388), 0x01));

   body.emit(assign(r137A, lshift(r137A, body.constant(int(16))), 0x01));

   ir_expression *const r1389 = mul(r137C, r137E);
   body.emit(assign(r137B, add(r1389, r137A), 0x01));

   ir_expression *const r138A = less(r137B, r137A);
   ir_expression *const r138B = expr(ir_unop_b2i, r138A);
   ir_expression *const r138C = expr(ir_unop_i2u, r138B);
   body.emit(assign(r1379, add(r1379, r138C), 0x01));

   body.emit(assign(r1378, r137B, 0x01));

   body.emit(assign(r1377, r1379, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64To128(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r138D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r138D);
   ir_variable *const r138E = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r138E);
   ir_variable *const r138F = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r138F);
   ir_variable *const r1390 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1390);
   ir_variable *const r1391 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1391);
   ir_variable *const r1392 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1392);
   ir_variable *const r1393 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1393);
   ir_variable *const r1394 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z3Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1394);
   ir_variable *const r1395 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1395);
   ir_variable *const r1396 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r1396);
   ir_variable *const r1397 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1397);
   ir_variable *const r1398 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1398, bit_and(r138E, body.constant(65535u)), 0x01));

   ir_variable *const r1399 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1399, rshift(r138E, body.constant(int(16))), 0x01));

   ir_variable *const r139A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139A, bit_and(r1390, body.constant(65535u)), 0x01));

   ir_variable *const r139B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139B, rshift(r1390, body.constant(int(16))), 0x01));

   ir_variable *const r139C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139C, mul(r1399, r139A), 0x01));

   ir_expression *const r139D = mul(r1398, r139B);
   body.emit(assign(r1396, add(r139D, r139C), 0x01));

   ir_expression *const r139E = mul(r1399, r139B);
   ir_expression *const r139F = less(r1396, r139C);
   ir_expression *const r13A0 = expr(ir_unop_b2i, r139F);
   ir_expression *const r13A1 = expr(ir_unop_i2u, r13A0);
   ir_expression *const r13A2 = lshift(r13A1, body.constant(int(16)));
   ir_expression *const r13A3 = rshift(r1396, body.constant(int(16)));
   ir_expression *const r13A4 = add(r13A2, r13A3);
   body.emit(assign(r1395, add(r139E, r13A4), 0x01));

   body.emit(assign(r1396, lshift(r1396, body.constant(int(16))), 0x01));

   ir_expression *const r13A5 = mul(r1398, r139A);
   body.emit(assign(r1397, add(r13A5, r1396), 0x01));

   ir_expression *const r13A6 = less(r1397, r1396);
   ir_expression *const r13A7 = expr(ir_unop_b2i, r13A6);
   ir_expression *const r13A8 = expr(ir_unop_i2u, r13A7);
   body.emit(assign(r1395, add(r1395, r13A8), 0x01));

   ir_variable *const r13A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13A9);
   ir_variable *const r13AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13AA);
   ir_variable *const r13AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13AB);
   ir_variable *const r13AC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13AC, bit_and(r138E, body.constant(65535u)), 0x01));

   ir_variable *const r13AD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13AD, rshift(r138E, body.constant(int(16))), 0x01));

   ir_variable *const r13AE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13AE, bit_and(r138F, body.constant(65535u)), 0x01));

   ir_variable *const r13AF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13AF, rshift(r138F, body.constant(int(16))), 0x01));

   ir_variable *const r13B0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B0, mul(r13AD, r13AE), 0x01));

   ir_expression *const r13B1 = mul(r13AC, r13AF);
   body.emit(assign(r13AA, add(r13B1, r13B0), 0x01));

   ir_expression *const r13B2 = mul(r13AD, r13AF);
   ir_expression *const r13B3 = less(r13AA, r13B0);
   ir_expression *const r13B4 = expr(ir_unop_b2i, r13B3);
   ir_expression *const r13B5 = expr(ir_unop_i2u, r13B4);
   ir_expression *const r13B6 = lshift(r13B5, body.constant(int(16)));
   ir_expression *const r13B7 = rshift(r13AA, body.constant(int(16)));
   ir_expression *const r13B8 = add(r13B6, r13B7);
   body.emit(assign(r13A9, add(r13B2, r13B8), 0x01));

   body.emit(assign(r13AA, lshift(r13AA, body.constant(int(16))), 0x01));

   ir_expression *const r13B9 = mul(r13AC, r13AE);
   body.emit(assign(r13AB, add(r13B9, r13AA), 0x01));

   ir_expression *const r13BA = less(r13AB, r13AA);
   ir_expression *const r13BB = expr(ir_unop_b2i, r13BA);
   ir_expression *const r13BC = expr(ir_unop_i2u, r13BB);
   body.emit(assign(r13A9, add(r13A9, r13BC), 0x01));

   ir_variable *const r13BD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13BD, add(r13AB, r1395), 0x01));

   ir_variable *const r13BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13BE);
   ir_variable *const r13BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13BF);
   ir_variable *const r13C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13C0);
   ir_variable *const r13C1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C1, bit_and(r138D, body.constant(65535u)), 0x01));

   ir_variable *const r13C2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C2, rshift(r138D, body.constant(int(16))), 0x01));

   ir_variable *const r13C3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C3, bit_and(r138F, body.constant(65535u)), 0x01));

   ir_variable *const r13C4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C4, rshift(r138F, body.constant(int(16))), 0x01));

   ir_variable *const r13C5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C5, mul(r13C2, r13C3), 0x01));

   ir_expression *const r13C6 = mul(r13C1, r13C4);
   body.emit(assign(r13BF, add(r13C6, r13C5), 0x01));

   ir_expression *const r13C7 = mul(r13C2, r13C4);
   ir_expression *const r13C8 = less(r13BF, r13C5);
   ir_expression *const r13C9 = expr(ir_unop_b2i, r13C8);
   ir_expression *const r13CA = expr(ir_unop_i2u, r13C9);
   ir_expression *const r13CB = lshift(r13CA, body.constant(int(16)));
   ir_expression *const r13CC = rshift(r13BF, body.constant(int(16)));
   ir_expression *const r13CD = add(r13CB, r13CC);
   body.emit(assign(r13BE, add(r13C7, r13CD), 0x01));

   body.emit(assign(r13BF, lshift(r13BF, body.constant(int(16))), 0x01));

   ir_expression *const r13CE = mul(r13C1, r13C3);
   body.emit(assign(r13C0, add(r13CE, r13BF), 0x01));

   ir_expression *const r13CF = less(r13C0, r13BF);
   ir_expression *const r13D0 = expr(ir_unop_b2i, r13CF);
   ir_expression *const r13D1 = expr(ir_unop_i2u, r13D0);
   body.emit(assign(r13BE, add(r13BE, r13D1), 0x01));

   ir_variable *const r13D2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r13D3 = less(r13BD, r13AB);
   ir_expression *const r13D4 = expr(ir_unop_b2i, r13D3);
   ir_expression *const r13D5 = expr(ir_unop_i2u, r13D4);
   ir_expression *const r13D6 = add(r13A9, r13D5);
   body.emit(assign(r13D2, add(r13C0, r13D6), 0x01));

   ir_variable *const r13D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13D7);
   ir_variable *const r13D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13D8);
   ir_variable *const r13D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13D9);
   ir_variable *const r13DA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DA, bit_and(r138D, body.constant(65535u)), 0x01));

   ir_variable *const r13DB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DB, rshift(r138D, body.constant(int(16))), 0x01));

   ir_variable *const r13DC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DC, bit_and(r1390, body.constant(65535u)), 0x01));

   ir_variable *const r13DD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DD, rshift(r1390, body.constant(int(16))), 0x01));

   ir_variable *const r13DE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DE, mul(r13DB, r13DC), 0x01));

   ir_expression *const r13DF = mul(r13DA, r13DD);
   body.emit(assign(r13D8, add(r13DF, r13DE), 0x01));

   ir_expression *const r13E0 = mul(r13DB, r13DD);
   ir_expression *const r13E1 = less(r13D8, r13DE);
   ir_expression *const r13E2 = expr(ir_unop_b2i, r13E1);
   ir_expression *const r13E3 = expr(ir_unop_i2u, r13E2);
   ir_expression *const r13E4 = lshift(r13E3, body.constant(int(16)));
   ir_expression *const r13E5 = rshift(r13D8, body.constant(int(16)));
   ir_expression *const r13E6 = add(r13E4, r13E5);
   body.emit(assign(r13D7, add(r13E0, r13E6), 0x01));

   body.emit(assign(r13D8, lshift(r13D8, body.constant(int(16))), 0x01));

   ir_expression *const r13E7 = mul(r13DA, r13DC);
   body.emit(assign(r13D9, add(r13E7, r13D8), 0x01));

   ir_expression *const r13E8 = less(r13D9, r13D8);
   ir_expression *const r13E9 = expr(ir_unop_b2i, r13E8);
   ir_expression *const r13EA = expr(ir_unop_i2u, r13E9);
   body.emit(assign(r13D7, add(r13D7, r13EA), 0x01));

   ir_variable *const r13EB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13EB, add(r13D9, r13BD), 0x01));

   ir_variable *const r13EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r13ED = less(r13EB, r13D9);
   ir_expression *const r13EE = expr(ir_unop_b2i, r13ED);
   ir_expression *const r13EF = expr(ir_unop_i2u, r13EE);
   ir_expression *const r13F0 = add(r13D7, r13EF);
   body.emit(assign(r13EC, add(r13D2, r13F0), 0x01));

   body.emit(assign(r1394, r1397, 0x01));

   body.emit(assign(r1393, r13EB, 0x01));

   body.emit(assign(r1392, r13EC, 0x01));

   ir_expression *const r13F1 = less(r13D2, r13C0);
   ir_expression *const r13F2 = expr(ir_unop_b2i, r13F1);
   ir_expression *const r13F3 = expr(ir_unop_i2u, r13F2);
   ir_expression *const r13F4 = add(r13BE, r13F3);
   ir_expression *const r13F5 = less(r13EC, r13D2);
   ir_expression *const r13F6 = expr(ir_unop_b2i, r13F5);
   ir_expression *const r13F7 = expr(ir_unop_i2u, r13F6);
   body.emit(assign(r1391, add(r13F4, r13F7), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat64Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r13F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac0", ir_var_function_in);
   sig_parameters.push_tail(r13F8);
   ir_variable *const r13F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac1", ir_var_function_in);
   sig_parameters.push_tail(r13F9);
   ir_variable *const r13FA = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r13FA);
   ir_variable *const r13FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r13FB);
   ir_variable *const r13FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r13FC);
   ir_variable *const r13FD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r13FD);
   /* IF CONDITION */
   ir_expression *const r13FF = equal(r13F8, body.constant(0u));
   ir_if *f13FE = new(mem_ctx) ir_if(operand(r13FF).val);
   exec_list *const f13FE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f13FE->then_instructions;

      ir_variable *const r1400 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1400, r13F9, 0x01));

      ir_variable *const r1401 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1402 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1402);
      /* IF CONDITION */
      ir_expression *const r1404 = equal(r13F9, body.constant(0u));
      ir_if *f1403 = new(mem_ctx) ir_if(operand(r1404).val);
      exec_list *const f1403_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1403->then_instructions;

         body.emit(assign(r1401, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1403->else_instructions;

         body.emit(assign(r1402, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1406 = bit_and(r13F9, body.constant(4294901760u));
         ir_expression *const r1407 = equal(r1406, body.constant(0u));
         ir_if *f1405 = new(mem_ctx) ir_if(operand(r1407).val);
         exec_list *const f1405_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1405->then_instructions;

            body.emit(assign(r1402, body.constant(int(16)), 0x01));

            body.emit(assign(r1400, lshift(r13F9, body.constant(int(16))), 0x01));


         body.instructions = f1405_parent_instructions;
         body.emit(f1405);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1409 = bit_and(r1400, body.constant(4278190080u));
         ir_expression *const r140A = equal(r1409, body.constant(0u));
         ir_if *f1408 = new(mem_ctx) ir_if(operand(r140A).val);
         exec_list *const f1408_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1408->then_instructions;

            body.emit(assign(r1402, add(r1402, body.constant(int(8))), 0x01));

            body.emit(assign(r1400, lshift(r1400, body.constant(int(8))), 0x01));


         body.instructions = f1408_parent_instructions;
         body.emit(f1408);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r140C = bit_and(r1400, body.constant(4026531840u));
         ir_expression *const r140D = equal(r140C, body.constant(0u));
         ir_if *f140B = new(mem_ctx) ir_if(operand(r140D).val);
         exec_list *const f140B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f140B->then_instructions;

            body.emit(assign(r1402, add(r1402, body.constant(int(4))), 0x01));

            body.emit(assign(r1400, lshift(r1400, body.constant(int(4))), 0x01));


         body.instructions = f140B_parent_instructions;
         body.emit(f140B);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r140F = bit_and(r1400, body.constant(3221225472u));
         ir_expression *const r1410 = equal(r140F, body.constant(0u));
         ir_if *f140E = new(mem_ctx) ir_if(operand(r1410).val);
         exec_list *const f140E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f140E->then_instructions;

            body.emit(assign(r1402, add(r1402, body.constant(int(2))), 0x01));

            body.emit(assign(r1400, lshift(r1400, body.constant(int(2))), 0x01));


         body.instructions = f140E_parent_instructions;
         body.emit(f140E);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1412 = bit_and(r1400, body.constant(2147483648u));
         ir_expression *const r1413 = equal(r1412, body.constant(0u));
         ir_if *f1411 = new(mem_ctx) ir_if(operand(r1413).val);
         exec_list *const f1411_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1411->then_instructions;

            body.emit(assign(r1402, add(r1402, body.constant(int(1))), 0x01));


         body.instructions = f1411_parent_instructions;
         body.emit(f1411);

         /* END IF */

         body.emit(assign(r1401, r1402, 0x01));


      body.instructions = f1403_parent_instructions;
      body.emit(f1403);

      /* END IF */

      body.emit(assign(r13FD, add(r1401, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1415 = less(r13FD, body.constant(int(0)));
      ir_if *f1414 = new(mem_ctx) ir_if(operand(r1415).val);
      exec_list *const f1414_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1414->then_instructions;

         ir_expression *const r1416 = neg(r13FD);
         body.emit(assign(r13FB, rshift(r13F9, r1416), 0x01));

         ir_expression *const r1417 = bit_and(r13FD, body.constant(int(31)));
         body.emit(assign(r13FC, lshift(r13F9, r1417), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1414->else_instructions;

         body.emit(assign(r13FB, lshift(r13F9, r13FD), 0x01));

         body.emit(assign(r13FC, body.constant(0u), 0x01));


      body.instructions = f1414_parent_instructions;
      body.emit(f1414);

      /* END IF */

      body.emit(assign(r13FA, sub(body.constant(int(-31)), r13FD), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f13FE->else_instructions;

      ir_variable *const r1418 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1418, r13F8, 0x01));

      ir_variable *const r1419 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r141A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r141A);
      /* IF CONDITION */
      ir_expression *const r141C = equal(r13F8, body.constant(0u));
      ir_if *f141B = new(mem_ctx) ir_if(operand(r141C).val);
      exec_list *const f141B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f141B->then_instructions;

         body.emit(assign(r1419, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f141B->else_instructions;

         body.emit(assign(r141A, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r141E = bit_and(r13F8, body.constant(4294901760u));
         ir_expression *const r141F = equal(r141E, body.constant(0u));
         ir_if *f141D = new(mem_ctx) ir_if(operand(r141F).val);
         exec_list *const f141D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f141D->then_instructions;

            body.emit(assign(r141A, body.constant(int(16)), 0x01));

            body.emit(assign(r1418, lshift(r13F8, body.constant(int(16))), 0x01));


         body.instructions = f141D_parent_instructions;
         body.emit(f141D);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1421 = bit_and(r1418, body.constant(4278190080u));
         ir_expression *const r1422 = equal(r1421, body.constant(0u));
         ir_if *f1420 = new(mem_ctx) ir_if(operand(r1422).val);
         exec_list *const f1420_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1420->then_instructions;

            body.emit(assign(r141A, add(r141A, body.constant(int(8))), 0x01));

            body.emit(assign(r1418, lshift(r1418, body.constant(int(8))), 0x01));


         body.instructions = f1420_parent_instructions;
         body.emit(f1420);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1424 = bit_and(r1418, body.constant(4026531840u));
         ir_expression *const r1425 = equal(r1424, body.constant(0u));
         ir_if *f1423 = new(mem_ctx) ir_if(operand(r1425).val);
         exec_list *const f1423_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1423->then_instructions;

            body.emit(assign(r141A, add(r141A, body.constant(int(4))), 0x01));

            body.emit(assign(r1418, lshift(r1418, body.constant(int(4))), 0x01));


         body.instructions = f1423_parent_instructions;
         body.emit(f1423);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1427 = bit_and(r1418, body.constant(3221225472u));
         ir_expression *const r1428 = equal(r1427, body.constant(0u));
         ir_if *f1426 = new(mem_ctx) ir_if(operand(r1428).val);
         exec_list *const f1426_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1426->then_instructions;

            body.emit(assign(r141A, add(r141A, body.constant(int(2))), 0x01));

            body.emit(assign(r1418, lshift(r1418, body.constant(int(2))), 0x01));


         body.instructions = f1426_parent_instructions;
         body.emit(f1426);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r142A = bit_and(r1418, body.constant(2147483648u));
         ir_expression *const r142B = equal(r142A, body.constant(0u));
         ir_if *f1429 = new(mem_ctx) ir_if(operand(r142B).val);
         exec_list *const f1429_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1429->then_instructions;

            body.emit(assign(r141A, add(r141A, body.constant(int(1))), 0x01));


         body.instructions = f1429_parent_instructions;
         body.emit(f1429);

         /* END IF */

         body.emit(assign(r1419, r141A, 0x01));


      body.instructions = f141B_parent_instructions;
      body.emit(f141B);

      /* END IF */

      body.emit(assign(r13FD, add(r1419, body.constant(int(-11))), 0x01));

      ir_variable *const r142C = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r142C, lshift(r13F9, r13FD), 0x01));

      ir_variable *const r142D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r142F = equal(r13FD, body.constant(int(0)));
      ir_if *f142E = new(mem_ctx) ir_if(operand(r142F).val);
      exec_list *const f142E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f142E->then_instructions;

         body.emit(assign(r142D, r13F8, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f142E->else_instructions;

         ir_expression *const r1430 = lshift(r13F8, r13FD);
         ir_expression *const r1431 = neg(r13FD);
         ir_expression *const r1432 = bit_and(r1431, body.constant(int(31)));
         ir_expression *const r1433 = rshift(r13F9, r1432);
         body.emit(assign(r142D, bit_or(r1430, r1433), 0x01));


      body.instructions = f142E_parent_instructions;
      body.emit(f142E);

      /* END IF */

      body.emit(assign(r13FB, r142D, 0x01));

      body.emit(assign(r13FC, r142C, 0x01));

      body.emit(assign(r13FA, sub(body.constant(int(1)), r13FD), 0x01));


   body.instructions = f13FE_parent_instructions;
   body.emit(f13FE);

   /* END IF */

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmul64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1434 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1434);
   ir_variable *const r1435 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1435);
   ir_variable *const r1436 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1436, body.constant(true), 0x01));

   ir_variable *const r1437 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1438 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1438);
   ir_variable *const r1439 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r1439);
   ir_variable *const r143A = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r143A);
   ir_variable *const r143B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r143B);
   ir_variable *const r143C = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r143C);
   ir_variable *const r143D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r143D);
   ir_variable *const r143E = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r143E);
   ir_variable *const r143F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r143F);
   ir_variable *const r1440 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r1440);
   ir_variable *const r1441 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1441);
   ir_variable *const r1442 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1442);
   body.emit(assign(r1442, body.constant(0u), 0x01));

   body.emit(assign(r1441, body.constant(0u), 0x01));

   body.emit(assign(r1440, body.constant(0u), 0x01));

   ir_variable *const r1443 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r1443, swizzle_x(r1434), 0x01));

   body.emit(assign(r143E, r1443, 0x01));

   ir_variable *const r1444 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1444, bit_and(swizzle_y(r1434), body.constant(1048575u)), 0x01));

   body.emit(assign(r143D, r1444, 0x01));

   ir_variable *const r1445 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r1445, swizzle_x(r1435), 0x01));

   body.emit(assign(r143C, r1445, 0x01));

   ir_variable *const r1446 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1446, bit_and(swizzle_y(r1435), body.constant(1048575u)), 0x01));

   body.emit(assign(r143B, r1446, 0x01));

   ir_variable *const r1447 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1448 = rshift(swizzle_y(r1434), body.constant(int(20)));
   ir_expression *const r1449 = bit_and(r1448, body.constant(2047u));
   body.emit(assign(r1447, expr(ir_unop_u2i, r1449), 0x01));

   body.emit(assign(r143A, r1447, 0x01));

   ir_variable *const r144A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r144B = rshift(swizzle_y(r1435), body.constant(int(20)));
   ir_expression *const r144C = bit_and(r144B, body.constant(2047u));
   body.emit(assign(r144A, expr(ir_unop_u2i, r144C), 0x01));

   body.emit(assign(r1439, r144A, 0x01));

   ir_expression *const r144D = rshift(swizzle_y(r1434), body.constant(int(31)));
   ir_expression *const r144E = rshift(swizzle_y(r1435), body.constant(int(31)));
   body.emit(assign(r1438, bit_xor(r144D, r144E), 0x01));

   /* IF CONDITION */
   ir_expression *const r1450 = equal(r1447, body.constant(int(2047)));
   ir_if *f144F = new(mem_ctx) ir_if(operand(r1450).val);
   exec_list *const f144F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f144F->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1452 = bit_or(r1444, swizzle_x(r1434));
      ir_expression *const r1453 = nequal(r1452, body.constant(0u));
      ir_expression *const r1454 = equal(r144A, body.constant(int(2047)));
      ir_expression *const r1455 = bit_or(r1446, swizzle_x(r1435));
      ir_expression *const r1456 = nequal(r1455, body.constant(0u));
      ir_expression *const r1457 = logic_and(r1454, r1456);
      ir_expression *const r1458 = logic_or(r1453, r1457);
      ir_if *f1451 = new(mem_ctx) ir_if(operand(r1458).val);
      exec_list *const f1451_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1451->then_instructions;

         ir_variable *const r1459 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r1459, swizzle_x(r1434), 0x01));

         ir_variable *const r145A = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r145A, swizzle_x(r1435), 0x01));

         ir_variable *const r145B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r145C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r145D = rshift(swizzle_y(r1434), body.constant(int(19)));
         ir_expression *const r145E = bit_and(r145D, body.constant(4095u));
         ir_expression *const r145F = equal(r145E, body.constant(4094u));
         ir_expression *const r1460 = nequal(swizzle_x(r1434), body.constant(0u));
         ir_expression *const r1461 = bit_and(swizzle_y(r1434), body.constant(524287u));
         ir_expression *const r1462 = nequal(r1461, body.constant(0u));
         ir_expression *const r1463 = logic_or(r1460, r1462);
         body.emit(assign(r145C, logic_and(r145F, r1463), 0x01));

         ir_variable *const r1464 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r1465 = lshift(swizzle_y(r1435), body.constant(int(1)));
         ir_expression *const r1466 = lequal(body.constant(4292870144u), r1465);
         ir_expression *const r1467 = nequal(swizzle_x(r1435), body.constant(0u));
         ir_expression *const r1468 = bit_and(swizzle_y(r1435), body.constant(1048575u));
         ir_expression *const r1469 = nequal(r1468, body.constant(0u));
         ir_expression *const r146A = logic_or(r1467, r1469);
         body.emit(assign(r1464, logic_and(r1466, r146A), 0x01));

         body.emit(assign(r1459, bit_or(swizzle_y(r1434), body.constant(524288u)), 0x02));

         body.emit(assign(r145A, bit_or(swizzle_y(r1435), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r146C = lshift(swizzle_y(r1434), body.constant(int(1)));
         ir_expression *const r146D = lequal(body.constant(4292870144u), r146C);
         ir_expression *const r146E = nequal(swizzle_x(r1434), body.constant(0u));
         ir_expression *const r146F = bit_and(swizzle_y(r1434), body.constant(1048575u));
         ir_expression *const r1470 = nequal(r146F, body.constant(0u));
         ir_expression *const r1471 = logic_or(r146E, r1470);
         ir_expression *const r1472 = logic_and(r146D, r1471);
         ir_if *f146B = new(mem_ctx) ir_if(operand(r1472).val);
         exec_list *const f146B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f146B->then_instructions;

            ir_variable *const r1473 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1475 = logic_and(r145C, r1464);
            ir_if *f1474 = new(mem_ctx) ir_if(operand(r1475).val);
            exec_list *const f1474_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1474->then_instructions;

               body.emit(assign(r1473, r145A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1474->else_instructions;

               body.emit(assign(r1473, r1459, 0x03));


            body.instructions = f1474_parent_instructions;
            body.emit(f1474);

            /* END IF */

            body.emit(assign(r145B, r1473, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f146B->else_instructions;

            body.emit(assign(r145B, r145A, 0x03));


         body.instructions = f146B_parent_instructions;
         body.emit(f146B);

         /* END IF */

         body.emit(assign(r1437, r145B, 0x03));

         body.emit(assign(r1436, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1451->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1477 = expr(ir_unop_i2u, r144A);
         ir_expression *const r1478 = bit_or(r1477, r1446);
         ir_expression *const r1479 = bit_or(r1478, swizzle_x(r1435));
         ir_expression *const r147A = equal(r1479, body.constant(0u));
         ir_if *f1476 = new(mem_ctx) ir_if(operand(r147A).val);
         exec_list *const f1476_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1476->then_instructions;

            ir_constant_data r147B_data;
            memset(&r147B_data, 0, sizeof(ir_constant_data));
            r147B_data.u[0] = 4294967295;
            r147B_data.u[1] = 4294967295;
            ir_constant *const r147B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r147B_data);
            body.emit(assign(r1437, r147B, 0x03));

            body.emit(assign(r1436, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1476->else_instructions;

            ir_variable *const r147C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r147C);
            ir_expression *const r147D = lshift(r1438, body.constant(int(31)));
            body.emit(assign(r147C, add(r147D, body.constant(2146435072u)), 0x02));

            body.emit(assign(r147C, body.constant(0u), 0x01));

            body.emit(assign(r1437, r147C, 0x03));

            body.emit(assign(r1436, body.constant(false), 0x01));


         body.instructions = f1476_parent_instructions;
         body.emit(f1476);

         /* END IF */


      body.instructions = f1451_parent_instructions;
      body.emit(f1451);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f144F->else_instructions;

      /* IF CONDITION */
      ir_expression *const r147F = equal(r144A, body.constant(int(2047)));
      ir_if *f147E = new(mem_ctx) ir_if(operand(r147F).val);
      exec_list *const f147E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f147E->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1481 = bit_or(r1446, swizzle_x(r1435));
         ir_expression *const r1482 = nequal(r1481, body.constant(0u));
         ir_if *f1480 = new(mem_ctx) ir_if(operand(r1482).val);
         exec_list *const f1480_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1480->then_instructions;

            ir_variable *const r1483 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r1483, swizzle_x(r1434), 0x01));

            ir_variable *const r1484 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r1484, swizzle_x(r1435), 0x01));

            ir_variable *const r1485 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r1486 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r1487 = rshift(swizzle_y(r1434), body.constant(int(19)));
            ir_expression *const r1488 = bit_and(r1487, body.constant(4095u));
            ir_expression *const r1489 = equal(r1488, body.constant(4094u));
            ir_expression *const r148A = nequal(swizzle_x(r1434), body.constant(0u));
            ir_expression *const r148B = bit_and(swizzle_y(r1434), body.constant(524287u));
            ir_expression *const r148C = nequal(r148B, body.constant(0u));
            ir_expression *const r148D = logic_or(r148A, r148C);
            body.emit(assign(r1486, logic_and(r1489, r148D), 0x01));

            ir_variable *const r148E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r148F = lshift(swizzle_y(r1435), body.constant(int(1)));
            ir_expression *const r1490 = lequal(body.constant(4292870144u), r148F);
            ir_expression *const r1491 = nequal(swizzle_x(r1435), body.constant(0u));
            ir_expression *const r1492 = bit_and(swizzle_y(r1435), body.constant(1048575u));
            ir_expression *const r1493 = nequal(r1492, body.constant(0u));
            ir_expression *const r1494 = logic_or(r1491, r1493);
            body.emit(assign(r148E, logic_and(r1490, r1494), 0x01));

            body.emit(assign(r1483, bit_or(swizzle_y(r1434), body.constant(524288u)), 0x02));

            body.emit(assign(r1484, bit_or(swizzle_y(r1435), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r1496 = lshift(swizzle_y(r1434), body.constant(int(1)));
            ir_expression *const r1497 = lequal(body.constant(4292870144u), r1496);
            ir_expression *const r1498 = nequal(swizzle_x(r1434), body.constant(0u));
            ir_expression *const r1499 = bit_and(swizzle_y(r1434), body.constant(1048575u));
            ir_expression *const r149A = nequal(r1499, body.constant(0u));
            ir_expression *const r149B = logic_or(r1498, r149A);
            ir_expression *const r149C = logic_and(r1497, r149B);
            ir_if *f1495 = new(mem_ctx) ir_if(operand(r149C).val);
            exec_list *const f1495_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1495->then_instructions;

               ir_variable *const r149D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r149F = logic_and(r1486, r148E);
               ir_if *f149E = new(mem_ctx) ir_if(operand(r149F).val);
               exec_list *const f149E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f149E->then_instructions;

                  body.emit(assign(r149D, r1484, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f149E->else_instructions;

                  body.emit(assign(r149D, r1483, 0x03));


               body.instructions = f149E_parent_instructions;
               body.emit(f149E);

               /* END IF */

               body.emit(assign(r1485, r149D, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1495->else_instructions;

               body.emit(assign(r1485, r1484, 0x03));


            body.instructions = f1495_parent_instructions;
            body.emit(f1495);

            /* END IF */

            body.emit(assign(r1437, r1485, 0x03));

            body.emit(assign(r1436, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1480->else_instructions;

            /* IF CONDITION */
            ir_expression *const r14A1 = expr(ir_unop_i2u, r1447);
            ir_expression *const r14A2 = bit_or(r14A1, r1444);
            ir_expression *const r14A3 = bit_or(r14A2, swizzle_x(r1434));
            ir_expression *const r14A4 = equal(r14A3, body.constant(0u));
            ir_if *f14A0 = new(mem_ctx) ir_if(operand(r14A4).val);
            exec_list *const f14A0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14A0->then_instructions;

               ir_constant_data r14A5_data;
               memset(&r14A5_data, 0, sizeof(ir_constant_data));
               r14A5_data.u[0] = 4294967295;
               r14A5_data.u[1] = 4294967295;
               ir_constant *const r14A5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r14A5_data);
               body.emit(assign(r1437, r14A5, 0x03));

               body.emit(assign(r1436, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f14A0->else_instructions;

               ir_variable *const r14A6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r14A6);
               ir_expression *const r14A7 = lshift(r1438, body.constant(int(31)));
               body.emit(assign(r14A6, add(r14A7, body.constant(2146435072u)), 0x02));

               body.emit(assign(r14A6, body.constant(0u), 0x01));

               body.emit(assign(r1437, r14A6, 0x03));

               body.emit(assign(r1436, body.constant(false), 0x01));


            body.instructions = f14A0_parent_instructions;
            body.emit(f14A0);

            /* END IF */


         body.instructions = f1480_parent_instructions;
         body.emit(f1480);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f147E->else_instructions;

         /* IF CONDITION */
         ir_expression *const r14A9 = equal(r1447, body.constant(int(0)));
         ir_if *f14A8 = new(mem_ctx) ir_if(operand(r14A9).val);
         exec_list *const f14A8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f14A8->then_instructions;

            /* IF CONDITION */
            ir_expression *const r14AB = bit_or(r1444, swizzle_x(r1434));
            ir_expression *const r14AC = equal(r14AB, body.constant(0u));
            ir_if *f14AA = new(mem_ctx) ir_if(operand(r14AC).val);
            exec_list *const f14AA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14AA->then_instructions;

               ir_variable *const r14AD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r14AD);
               body.emit(assign(r14AD, lshift(r1438, body.constant(int(31))), 0x02));

               body.emit(assign(r14AD, body.constant(0u), 0x01));

               body.emit(assign(r1437, r14AD, 0x03));

               body.emit(assign(r1436, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f14AA->else_instructions;

               ir_variable *const r14AE = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r14AE, r1447, 0x01));

               ir_variable *const r14AF = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r14AF, r1444, 0x01));

               ir_variable *const r14B0 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r14B0, r1443, 0x01));

               ir_variable *const r14B1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r14B1);
               /* IF CONDITION */
               ir_expression *const r14B3 = equal(r1444, body.constant(0u));
               ir_if *f14B2 = new(mem_ctx) ir_if(operand(r14B3).val);
               exec_list *const f14B2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14B2->then_instructions;

                  ir_variable *const r14B4 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r14B4, r1443, 0x01));

                  ir_variable *const r14B5 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r14B6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14B6);
                  /* IF CONDITION */
                  ir_expression *const r14B8 = equal(swizzle_x(r1434), body.constant(0u));
                  ir_if *f14B7 = new(mem_ctx) ir_if(operand(r14B8).val);
                  exec_list *const f14B7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14B7->then_instructions;

                     body.emit(assign(r14B5, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14B7->else_instructions;

                     body.emit(assign(r14B6, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r14BA = bit_and(swizzle_x(r1434), body.constant(4294901760u));
                     ir_expression *const r14BB = equal(r14BA, body.constant(0u));
                     ir_if *f14B9 = new(mem_ctx) ir_if(operand(r14BB).val);
                     exec_list *const f14B9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14B9->then_instructions;

                        body.emit(assign(r14B6, body.constant(int(16)), 0x01));

                        body.emit(assign(r14B4, lshift(swizzle_x(r1434), body.constant(int(16))), 0x01));


                     body.instructions = f14B9_parent_instructions;
                     body.emit(f14B9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14BD = bit_and(r14B4, body.constant(4278190080u));
                     ir_expression *const r14BE = equal(r14BD, body.constant(0u));
                     ir_if *f14BC = new(mem_ctx) ir_if(operand(r14BE).val);
                     exec_list *const f14BC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14BC->then_instructions;

                        body.emit(assign(r14B6, add(r14B6, body.constant(int(8))), 0x01));

                        body.emit(assign(r14B4, lshift(r14B4, body.constant(int(8))), 0x01));


                     body.instructions = f14BC_parent_instructions;
                     body.emit(f14BC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C0 = bit_and(r14B4, body.constant(4026531840u));
                     ir_expression *const r14C1 = equal(r14C0, body.constant(0u));
                     ir_if *f14BF = new(mem_ctx) ir_if(operand(r14C1).val);
                     exec_list *const f14BF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14BF->then_instructions;

                        body.emit(assign(r14B6, add(r14B6, body.constant(int(4))), 0x01));

                        body.emit(assign(r14B4, lshift(r14B4, body.constant(int(4))), 0x01));


                     body.instructions = f14BF_parent_instructions;
                     body.emit(f14BF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C3 = bit_and(r14B4, body.constant(3221225472u));
                     ir_expression *const r14C4 = equal(r14C3, body.constant(0u));
                     ir_if *f14C2 = new(mem_ctx) ir_if(operand(r14C4).val);
                     exec_list *const f14C2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C2->then_instructions;

                        body.emit(assign(r14B6, add(r14B6, body.constant(int(2))), 0x01));

                        body.emit(assign(r14B4, lshift(r14B4, body.constant(int(2))), 0x01));


                     body.instructions = f14C2_parent_instructions;
                     body.emit(f14C2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C6 = bit_and(r14B4, body.constant(2147483648u));
                     ir_expression *const r14C7 = equal(r14C6, body.constant(0u));
                     ir_if *f14C5 = new(mem_ctx) ir_if(operand(r14C7).val);
                     exec_list *const f14C5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C5->then_instructions;

                        body.emit(assign(r14B6, add(r14B6, body.constant(int(1))), 0x01));


                     body.instructions = f14C5_parent_instructions;
                     body.emit(f14C5);

                     /* END IF */

                     body.emit(assign(r14B5, r14B6, 0x01));


                  body.instructions = f14B7_parent_instructions;
                  body.emit(f14B7);

                  /* END IF */

                  body.emit(assign(r14B1, add(r14B5, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r14C9 = less(r14B1, body.constant(int(0)));
                  ir_if *f14C8 = new(mem_ctx) ir_if(operand(r14C9).val);
                  exec_list *const f14C8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14C8->then_instructions;

                     ir_expression *const r14CA = neg(r14B1);
                     body.emit(assign(r14AF, rshift(swizzle_x(r1434), r14CA), 0x01));

                     ir_expression *const r14CB = bit_and(r14B1, body.constant(int(31)));
                     body.emit(assign(r14B0, lshift(swizzle_x(r1434), r14CB), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14C8->else_instructions;

                     body.emit(assign(r14AF, lshift(swizzle_x(r1434), r14B1), 0x01));

                     body.emit(assign(r14B0, body.constant(0u), 0x01));


                  body.instructions = f14C8_parent_instructions;
                  body.emit(f14C8);

                  /* END IF */

                  body.emit(assign(r14AE, sub(body.constant(int(-31)), r14B1), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14B2->else_instructions;

                  ir_variable *const r14CC = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r14CC, r1444, 0x01));

                  ir_variable *const r14CD = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r14CE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14CE);
                  /* IF CONDITION */
                  ir_expression *const r14D0 = equal(r1444, body.constant(0u));
                  ir_if *f14CF = new(mem_ctx) ir_if(operand(r14D0).val);
                  exec_list *const f14CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14CF->then_instructions;

                     body.emit(assign(r14CD, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14CF->else_instructions;

                     body.emit(assign(r14CE, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r14D2 = bit_and(r1444, body.constant(4294901760u));
                     ir_expression *const r14D3 = equal(r14D2, body.constant(0u));
                     ir_if *f14D1 = new(mem_ctx) ir_if(operand(r14D3).val);
                     exec_list *const f14D1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D1->then_instructions;

                        body.emit(assign(r14CE, body.constant(int(16)), 0x01));

                        body.emit(assign(r14CC, lshift(r1444, body.constant(int(16))), 0x01));


                     body.instructions = f14D1_parent_instructions;
                     body.emit(f14D1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14D5 = bit_and(r14CC, body.constant(4278190080u));
                     ir_expression *const r14D6 = equal(r14D5, body.constant(0u));
                     ir_if *f14D4 = new(mem_ctx) ir_if(operand(r14D6).val);
                     exec_list *const f14D4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D4->then_instructions;

                        body.emit(assign(r14CE, add(r14CE, body.constant(int(8))), 0x01));

                        body.emit(assign(r14CC, lshift(r14CC, body.constant(int(8))), 0x01));


                     body.instructions = f14D4_parent_instructions;
                     body.emit(f14D4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14D8 = bit_and(r14CC, body.constant(4026531840u));
                     ir_expression *const r14D9 = equal(r14D8, body.constant(0u));
                     ir_if *f14D7 = new(mem_ctx) ir_if(operand(r14D9).val);
                     exec_list *const f14D7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D7->then_instructions;

                        body.emit(assign(r14CE, add(r14CE, body.constant(int(4))), 0x01));

                        body.emit(assign(r14CC, lshift(r14CC, body.constant(int(4))), 0x01));


                     body.instructions = f14D7_parent_instructions;
                     body.emit(f14D7);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14DB = bit_and(r14CC, body.constant(3221225472u));
                     ir_expression *const r14DC = equal(r14DB, body.constant(0u));
                     ir_if *f14DA = new(mem_ctx) ir_if(operand(r14DC).val);
                     exec_list *const f14DA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14DA->then_instructions;

                        body.emit(assign(r14CE, add(r14CE, body.constant(int(2))), 0x01));

                        body.emit(assign(r14CC, lshift(r14CC, body.constant(int(2))), 0x01));


                     body.instructions = f14DA_parent_instructions;
                     body.emit(f14DA);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14DE = bit_and(r14CC, body.constant(2147483648u));
                     ir_expression *const r14DF = equal(r14DE, body.constant(0u));
                     ir_if *f14DD = new(mem_ctx) ir_if(operand(r14DF).val);
                     exec_list *const f14DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14DD->then_instructions;

                        body.emit(assign(r14CE, add(r14CE, body.constant(int(1))), 0x01));


                     body.instructions = f14DD_parent_instructions;
                     body.emit(f14DD);

                     /* END IF */

                     body.emit(assign(r14CD, r14CE, 0x01));


                  body.instructions = f14CF_parent_instructions;
                  body.emit(f14CF);

                  /* END IF */

                  body.emit(assign(r14B1, add(r14CD, body.constant(int(-11))), 0x01));

                  ir_variable *const r14E0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r14E0, lshift(swizzle_x(r1434), r14B1), 0x01));

                  ir_variable *const r14E1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r14E3 = equal(r14B1, body.constant(int(0)));
                  ir_if *f14E2 = new(mem_ctx) ir_if(operand(r14E3).val);
                  exec_list *const f14E2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14E2->then_instructions;

                     body.emit(assign(r14E1, r1444, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14E2->else_instructions;

                     ir_expression *const r14E4 = lshift(r1444, r14B1);
                     ir_expression *const r14E5 = neg(r14B1);
                     ir_expression *const r14E6 = bit_and(r14E5, body.constant(int(31)));
                     ir_expression *const r14E7 = rshift(swizzle_x(r1434), r14E6);
                     body.emit(assign(r14E1, bit_or(r14E4, r14E7), 0x01));


                  body.instructions = f14E2_parent_instructions;
                  body.emit(f14E2);

                  /* END IF */

                  body.emit(assign(r14AF, r14E1, 0x01));

                  body.emit(assign(r14B0, r14E0, 0x01));

                  body.emit(assign(r14AE, sub(body.constant(int(1)), r14B1), 0x01));


               body.instructions = f14B2_parent_instructions;
               body.emit(f14B2);

               /* END IF */

               body.emit(assign(r143A, r14AE, 0x01));

               body.emit(assign(r143D, r14AF, 0x01));

               body.emit(assign(r143E, r14B0, 0x01));


            body.instructions = f14AA_parent_instructions;
            body.emit(f14AA);

            /* END IF */


         body.instructions = f14A8_parent_instructions;
         body.emit(f14A8);

         /* END IF */

         /* IF CONDITION */
         ir_if *f14E8 = new(mem_ctx) ir_if(operand(r1436).val);
         exec_list *const f14E8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f14E8->then_instructions;

            /* IF CONDITION */
            ir_expression *const r14EA = equal(r144A, body.constant(int(0)));
            ir_if *f14E9 = new(mem_ctx) ir_if(operand(r14EA).val);
            exec_list *const f14E9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14E9->then_instructions;

               /* IF CONDITION */
               ir_expression *const r14EC = bit_or(r1446, swizzle_x(r1435));
               ir_expression *const r14ED = equal(r14EC, body.constant(0u));
               ir_if *f14EB = new(mem_ctx) ir_if(operand(r14ED).val);
               exec_list *const f14EB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14EB->then_instructions;

                  ir_variable *const r14EE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r14EE);
                  body.emit(assign(r14EE, lshift(r1438, body.constant(int(31))), 0x02));

                  body.emit(assign(r14EE, body.constant(0u), 0x01));

                  body.emit(assign(r1437, r14EE, 0x03));

                  body.emit(assign(r1436, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14EB->else_instructions;

                  ir_variable *const r14EF = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r14EF, r144A, 0x01));

                  ir_variable *const r14F0 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r14F0, r1446, 0x01));

                  ir_variable *const r14F1 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r14F1, r1445, 0x01));

                  ir_variable *const r14F2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14F2);
                  /* IF CONDITION */
                  ir_expression *const r14F4 = equal(r1446, body.constant(0u));
                  ir_if *f14F3 = new(mem_ctx) ir_if(operand(r14F4).val);
                  exec_list *const f14F3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14F3->then_instructions;

                     ir_variable *const r14F5 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r14F5, r1445, 0x01));

                     ir_variable *const r14F6 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r14F7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r14F7);
                     /* IF CONDITION */
                     ir_expression *const r14F9 = equal(swizzle_x(r1435), body.constant(0u));
                     ir_if *f14F8 = new(mem_ctx) ir_if(operand(r14F9).val);
                     exec_list *const f14F8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14F8->then_instructions;

                        body.emit(assign(r14F6, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f14F8->else_instructions;

                        body.emit(assign(r14F7, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r14FB = bit_and(swizzle_x(r1435), body.constant(4294901760u));
                        ir_expression *const r14FC = equal(r14FB, body.constant(0u));
                        ir_if *f14FA = new(mem_ctx) ir_if(operand(r14FC).val);
                        exec_list *const f14FA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f14FA->then_instructions;

                           body.emit(assign(r14F7, body.constant(int(16)), 0x01));

                           body.emit(assign(r14F5, lshift(swizzle_x(r1435), body.constant(int(16))), 0x01));


                        body.instructions = f14FA_parent_instructions;
                        body.emit(f14FA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r14FE = bit_and(r14F5, body.constant(4278190080u));
                        ir_expression *const r14FF = equal(r14FE, body.constant(0u));
                        ir_if *f14FD = new(mem_ctx) ir_if(operand(r14FF).val);
                        exec_list *const f14FD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f14FD->then_instructions;

                           body.emit(assign(r14F7, add(r14F7, body.constant(int(8))), 0x01));

                           body.emit(assign(r14F5, lshift(r14F5, body.constant(int(8))), 0x01));


                        body.instructions = f14FD_parent_instructions;
                        body.emit(f14FD);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1501 = bit_and(r14F5, body.constant(4026531840u));
                        ir_expression *const r1502 = equal(r1501, body.constant(0u));
                        ir_if *f1500 = new(mem_ctx) ir_if(operand(r1502).val);
                        exec_list *const f1500_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1500->then_instructions;

                           body.emit(assign(r14F7, add(r14F7, body.constant(int(4))), 0x01));

                           body.emit(assign(r14F5, lshift(r14F5, body.constant(int(4))), 0x01));


                        body.instructions = f1500_parent_instructions;
                        body.emit(f1500);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1504 = bit_and(r14F5, body.constant(3221225472u));
                        ir_expression *const r1505 = equal(r1504, body.constant(0u));
                        ir_if *f1503 = new(mem_ctx) ir_if(operand(r1505).val);
                        exec_list *const f1503_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1503->then_instructions;

                           body.emit(assign(r14F7, add(r14F7, body.constant(int(2))), 0x01));

                           body.emit(assign(r14F5, lshift(r14F5, body.constant(int(2))), 0x01));


                        body.instructions = f1503_parent_instructions;
                        body.emit(f1503);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1507 = bit_and(r14F5, body.constant(2147483648u));
                        ir_expression *const r1508 = equal(r1507, body.constant(0u));
                        ir_if *f1506 = new(mem_ctx) ir_if(operand(r1508).val);
                        exec_list *const f1506_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1506->then_instructions;

                           body.emit(assign(r14F7, add(r14F7, body.constant(int(1))), 0x01));


                        body.instructions = f1506_parent_instructions;
                        body.emit(f1506);

                        /* END IF */

                        body.emit(assign(r14F6, r14F7, 0x01));


                     body.instructions = f14F8_parent_instructions;
                     body.emit(f14F8);

                     /* END IF */

                     body.emit(assign(r14F2, add(r14F6, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r150A = less(r14F2, body.constant(int(0)));
                     ir_if *f1509 = new(mem_ctx) ir_if(operand(r150A).val);
                     exec_list *const f1509_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1509->then_instructions;

                        ir_expression *const r150B = neg(r14F2);
                        body.emit(assign(r14F0, rshift(swizzle_x(r1435), r150B), 0x01));

                        ir_expression *const r150C = bit_and(r14F2, body.constant(int(31)));
                        body.emit(assign(r14F1, lshift(swizzle_x(r1435), r150C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1509->else_instructions;

                        body.emit(assign(r14F0, lshift(swizzle_x(r1435), r14F2), 0x01));

                        body.emit(assign(r14F1, body.constant(0u), 0x01));


                     body.instructions = f1509_parent_instructions;
                     body.emit(f1509);

                     /* END IF */

                     body.emit(assign(r14EF, sub(body.constant(int(-31)), r14F2), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14F3->else_instructions;

                     ir_variable *const r150D = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r150D, r1446, 0x01));

                     ir_variable *const r150E = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r150F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r150F);
                     /* IF CONDITION */
                     ir_expression *const r1511 = equal(r1446, body.constant(0u));
                     ir_if *f1510 = new(mem_ctx) ir_if(operand(r1511).val);
                     exec_list *const f1510_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1510->then_instructions;

                        body.emit(assign(r150E, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1510->else_instructions;

                        body.emit(assign(r150F, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1513 = bit_and(r1446, body.constant(4294901760u));
                        ir_expression *const r1514 = equal(r1513, body.constant(0u));
                        ir_if *f1512 = new(mem_ctx) ir_if(operand(r1514).val);
                        exec_list *const f1512_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1512->then_instructions;

                           body.emit(assign(r150F, body.constant(int(16)), 0x01));

                           body.emit(assign(r150D, lshift(r1446, body.constant(int(16))), 0x01));


                        body.instructions = f1512_parent_instructions;
                        body.emit(f1512);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1516 = bit_and(r150D, body.constant(4278190080u));
                        ir_expression *const r1517 = equal(r1516, body.constant(0u));
                        ir_if *f1515 = new(mem_ctx) ir_if(operand(r1517).val);
                        exec_list *const f1515_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1515->then_instructions;

                           body.emit(assign(r150F, add(r150F, body.constant(int(8))), 0x01));

                           body.emit(assign(r150D, lshift(r150D, body.constant(int(8))), 0x01));


                        body.instructions = f1515_parent_instructions;
                        body.emit(f1515);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1519 = bit_and(r150D, body.constant(4026531840u));
                        ir_expression *const r151A = equal(r1519, body.constant(0u));
                        ir_if *f1518 = new(mem_ctx) ir_if(operand(r151A).val);
                        exec_list *const f1518_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1518->then_instructions;

                           body.emit(assign(r150F, add(r150F, body.constant(int(4))), 0x01));

                           body.emit(assign(r150D, lshift(r150D, body.constant(int(4))), 0x01));


                        body.instructions = f1518_parent_instructions;
                        body.emit(f1518);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r151C = bit_and(r150D, body.constant(3221225472u));
                        ir_expression *const r151D = equal(r151C, body.constant(0u));
                        ir_if *f151B = new(mem_ctx) ir_if(operand(r151D).val);
                        exec_list *const f151B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f151B->then_instructions;

                           body.emit(assign(r150F, add(r150F, body.constant(int(2))), 0x01));

                           body.emit(assign(r150D, lshift(r150D, body.constant(int(2))), 0x01));


                        body.instructions = f151B_parent_instructions;
                        body.emit(f151B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r151F = bit_and(r150D, body.constant(2147483648u));
                        ir_expression *const r1520 = equal(r151F, body.constant(0u));
                        ir_if *f151E = new(mem_ctx) ir_if(operand(r1520).val);
                        exec_list *const f151E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f151E->then_instructions;

                           body.emit(assign(r150F, add(r150F, body.constant(int(1))), 0x01));


                        body.instructions = f151E_parent_instructions;
                        body.emit(f151E);

                        /* END IF */

                        body.emit(assign(r150E, r150F, 0x01));


                     body.instructions = f1510_parent_instructions;
                     body.emit(f1510);

                     /* END IF */

                     body.emit(assign(r14F2, add(r150E, body.constant(int(-11))), 0x01));

                     ir_variable *const r1521 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1521, lshift(swizzle_x(r1435), r14F2), 0x01));

                     ir_variable *const r1522 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1524 = equal(r14F2, body.constant(int(0)));
                     ir_if *f1523 = new(mem_ctx) ir_if(operand(r1524).val);
                     exec_list *const f1523_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1523->then_instructions;

                        body.emit(assign(r1522, r1446, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1523->else_instructions;

                        ir_expression *const r1525 = lshift(r1446, r14F2);
                        ir_expression *const r1526 = neg(r14F2);
                        ir_expression *const r1527 = bit_and(r1526, body.constant(int(31)));
                        ir_expression *const r1528 = rshift(swizzle_x(r1435), r1527);
                        body.emit(assign(r1522, bit_or(r1525, r1528), 0x01));


                     body.instructions = f1523_parent_instructions;
                     body.emit(f1523);

                     /* END IF */

                     body.emit(assign(r14F0, r1522, 0x01));

                     body.emit(assign(r14F1, r1521, 0x01));

                     body.emit(assign(r14EF, sub(body.constant(int(1)), r14F2), 0x01));


                  body.instructions = f14F3_parent_instructions;
                  body.emit(f14F3);

                  /* END IF */

                  body.emit(assign(r1439, r14EF, 0x01));

                  body.emit(assign(r143B, r14F0, 0x01));

                  body.emit(assign(r143C, r14F1, 0x01));


               body.instructions = f14EB_parent_instructions;
               body.emit(f14EB);

               /* END IF */


            body.instructions = f14E9_parent_instructions;
            body.emit(f14E9);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1529 = new(mem_ctx) ir_if(operand(r1436).val);
            exec_list *const f1529_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1529->then_instructions;

               ir_expression *const r152A = add(r143A, r1439);
               body.emit(assign(r143F, add(r152A, body.constant(int(-1024))), 0x01));

               body.emit(assign(r143D, bit_or(r143D, body.constant(1048576u)), 0x01));

               ir_variable *const r152B = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r152B, lshift(r143C, body.constant(int(12))), 0x01));

               ir_variable *const r152C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r152D = lshift(r143B, body.constant(int(12)));
               ir_expression *const r152E = rshift(r143C, body.constant(int(20)));
               body.emit(assign(r152C, bit_or(r152D, r152E), 0x01));

               body.emit(assign(r143B, r152C, 0x01));

               body.emit(assign(r143C, r152B, 0x01));

               ir_variable *const r152F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r152F);
               ir_variable *const r1530 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1530);
               ir_variable *const r1531 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1531);
               ir_variable *const r1532 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1532, bit_and(r143E, body.constant(65535u)), 0x01));

               ir_variable *const r1533 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1533, rshift(r143E, body.constant(int(16))), 0x01));

               ir_variable *const r1534 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1534, bit_and(r152B, body.constant(65535u)), 0x01));

               ir_variable *const r1535 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1535, rshift(r152B, body.constant(int(16))), 0x01));

               ir_variable *const r1536 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1536, mul(r1533, r1534), 0x01));

               ir_expression *const r1537 = mul(r1532, r1535);
               body.emit(assign(r1530, add(r1537, r1536), 0x01));

               ir_expression *const r1538 = mul(r1533, r1535);
               ir_expression *const r1539 = less(r1530, r1536);
               ir_expression *const r153A = expr(ir_unop_b2i, r1539);
               ir_expression *const r153B = expr(ir_unop_i2u, r153A);
               ir_expression *const r153C = lshift(r153B, body.constant(int(16)));
               ir_expression *const r153D = rshift(r1530, body.constant(int(16)));
               ir_expression *const r153E = add(r153C, r153D);
               body.emit(assign(r152F, add(r1538, r153E), 0x01));

               body.emit(assign(r1530, lshift(r1530, body.constant(int(16))), 0x01));

               ir_expression *const r153F = mul(r1532, r1534);
               body.emit(assign(r1531, add(r153F, r1530), 0x01));

               ir_expression *const r1540 = less(r1531, r1530);
               ir_expression *const r1541 = expr(ir_unop_b2i, r1540);
               ir_expression *const r1542 = expr(ir_unop_i2u, r1541);
               body.emit(assign(r152F, add(r152F, r1542), 0x01));

               ir_variable *const r1543 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1543);
               ir_variable *const r1544 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1544);
               ir_variable *const r1545 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1545);
               ir_variable *const r1546 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1546, bit_and(r143E, body.constant(65535u)), 0x01));

               ir_variable *const r1547 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1547, rshift(r143E, body.constant(int(16))), 0x01));

               ir_variable *const r1548 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1548, bit_and(r152C, body.constant(65535u)), 0x01));

               ir_variable *const r1549 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1549, rshift(r152C, body.constant(int(16))), 0x01));

               ir_variable *const r154A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154A, mul(r1547, r1548), 0x01));

               ir_expression *const r154B = mul(r1546, r1549);
               body.emit(assign(r1544, add(r154B, r154A), 0x01));

               ir_expression *const r154C = mul(r1547, r1549);
               ir_expression *const r154D = less(r1544, r154A);
               ir_expression *const r154E = expr(ir_unop_b2i, r154D);
               ir_expression *const r154F = expr(ir_unop_i2u, r154E);
               ir_expression *const r1550 = lshift(r154F, body.constant(int(16)));
               ir_expression *const r1551 = rshift(r1544, body.constant(int(16)));
               ir_expression *const r1552 = add(r1550, r1551);
               body.emit(assign(r1543, add(r154C, r1552), 0x01));

               body.emit(assign(r1544, lshift(r1544, body.constant(int(16))), 0x01));

               ir_expression *const r1553 = mul(r1546, r1548);
               body.emit(assign(r1545, add(r1553, r1544), 0x01));

               ir_expression *const r1554 = less(r1545, r1544);
               ir_expression *const r1555 = expr(ir_unop_b2i, r1554);
               ir_expression *const r1556 = expr(ir_unop_i2u, r1555);
               body.emit(assign(r1543, add(r1543, r1556), 0x01));

               ir_variable *const r1557 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1557, add(r1545, r152F), 0x01));

               ir_variable *const r1558 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1558);
               ir_variable *const r1559 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1559);
               ir_variable *const r155A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r155A);
               ir_variable *const r155B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155B, bit_and(r143D, body.constant(65535u)), 0x01));

               ir_variable *const r155C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155C, rshift(r143D, body.constant(int(16))), 0x01));

               ir_variable *const r155D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155D, bit_and(r152C, body.constant(65535u)), 0x01));

               ir_variable *const r155E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155E, rshift(r152C, body.constant(int(16))), 0x01));

               ir_variable *const r155F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155F, mul(r155C, r155D), 0x01));

               ir_expression *const r1560 = mul(r155B, r155E);
               body.emit(assign(r1559, add(r1560, r155F), 0x01));

               ir_expression *const r1561 = mul(r155C, r155E);
               ir_expression *const r1562 = less(r1559, r155F);
               ir_expression *const r1563 = expr(ir_unop_b2i, r1562);
               ir_expression *const r1564 = expr(ir_unop_i2u, r1563);
               ir_expression *const r1565 = lshift(r1564, body.constant(int(16)));
               ir_expression *const r1566 = rshift(r1559, body.constant(int(16)));
               ir_expression *const r1567 = add(r1565, r1566);
               body.emit(assign(r1558, add(r1561, r1567), 0x01));

               body.emit(assign(r1559, lshift(r1559, body.constant(int(16))), 0x01));

               ir_expression *const r1568 = mul(r155B, r155D);
               body.emit(assign(r155A, add(r1568, r1559), 0x01));

               ir_expression *const r1569 = less(r155A, r1559);
               ir_expression *const r156A = expr(ir_unop_b2i, r1569);
               ir_expression *const r156B = expr(ir_unop_i2u, r156A);
               body.emit(assign(r1558, add(r1558, r156B), 0x01));

               ir_variable *const r156C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r156D = less(r1557, r1545);
               ir_expression *const r156E = expr(ir_unop_b2i, r156D);
               ir_expression *const r156F = expr(ir_unop_i2u, r156E);
               ir_expression *const r1570 = add(r1543, r156F);
               body.emit(assign(r156C, add(r155A, r1570), 0x01));

               ir_variable *const r1571 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1571);
               ir_variable *const r1572 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1572);
               ir_variable *const r1573 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1573);
               ir_variable *const r1574 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1574, bit_and(r143D, body.constant(65535u)), 0x01));

               ir_variable *const r1575 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1575, rshift(r143D, body.constant(int(16))), 0x01));

               ir_variable *const r1576 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1576, bit_and(r152B, body.constant(65535u)), 0x01));

               ir_variable *const r1577 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1577, rshift(r152B, body.constant(int(16))), 0x01));

               ir_variable *const r1578 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1578, mul(r1575, r1576), 0x01));

               ir_expression *const r1579 = mul(r1574, r1577);
               body.emit(assign(r1572, add(r1579, r1578), 0x01));

               ir_expression *const r157A = mul(r1575, r1577);
               ir_expression *const r157B = less(r1572, r1578);
               ir_expression *const r157C = expr(ir_unop_b2i, r157B);
               ir_expression *const r157D = expr(ir_unop_i2u, r157C);
               ir_expression *const r157E = lshift(r157D, body.constant(int(16)));
               ir_expression *const r157F = rshift(r1572, body.constant(int(16)));
               ir_expression *const r1580 = add(r157E, r157F);
               body.emit(assign(r1571, add(r157A, r1580), 0x01));

               body.emit(assign(r1572, lshift(r1572, body.constant(int(16))), 0x01));

               ir_expression *const r1581 = mul(r1574, r1576);
               body.emit(assign(r1573, add(r1581, r1572), 0x01));

               ir_expression *const r1582 = less(r1573, r1572);
               ir_expression *const r1583 = expr(ir_unop_b2i, r1582);
               ir_expression *const r1584 = expr(ir_unop_i2u, r1583);
               body.emit(assign(r1571, add(r1571, r1584), 0x01));

               ir_variable *const r1585 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1585, add(r1573, r1557), 0x01));

               ir_variable *const r1586 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1587 = less(r1585, r1573);
               ir_expression *const r1588 = expr(ir_unop_b2i, r1587);
               ir_expression *const r1589 = expr(ir_unop_i2u, r1588);
               ir_expression *const r158A = add(r1571, r1589);
               body.emit(assign(r1586, add(r156C, r158A), 0x01));

               ir_variable *const r158B = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r158C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r158C, add(r1586, r143E), 0x01));

               ir_expression *const r158D = less(r156C, r155A);
               ir_expression *const r158E = expr(ir_unop_b2i, r158D);
               ir_expression *const r158F = expr(ir_unop_i2u, r158E);
               ir_expression *const r1590 = add(r1558, r158F);
               ir_expression *const r1591 = less(r1586, r156C);
               ir_expression *const r1592 = expr(ir_unop_b2i, r1591);
               ir_expression *const r1593 = expr(ir_unop_i2u, r1592);
               ir_expression *const r1594 = add(r1590, r1593);
               ir_expression *const r1595 = add(r1594, r143D);
               ir_expression *const r1596 = less(r158C, r1586);
               ir_expression *const r1597 = expr(ir_unop_b2i, r1596);
               ir_expression *const r1598 = expr(ir_unop_i2u, r1597);
               body.emit(assign(r158B, add(r1595, r1598), 0x01));

               body.emit(assign(r1442, r158B, 0x01));

               body.emit(assign(r1441, r158C, 0x01));

               ir_expression *const r1599 = nequal(r1531, body.constant(0u));
               ir_expression *const r159A = expr(ir_unop_b2i, r1599);
               ir_expression *const r159B = expr(ir_unop_i2u, r159A);
               body.emit(assign(r1440, bit_or(r1585, r159B), 0x01));

               /* IF CONDITION */
               ir_expression *const r159D = lequal(body.constant(2097152u), r158B);
               ir_if *f159C = new(mem_ctx) ir_if(operand(r159D).val);
               exec_list *const f159C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f159C->then_instructions;

                  ir_variable *const r159E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r159E);
                  body.emit(assign(r159E, lshift(r158C, body.constant(int(31))), 0x01));

                  ir_expression *const r159F = nequal(r1440, body.constant(0u));
                  ir_expression *const r15A0 = expr(ir_unop_b2i, r159F);
                  ir_expression *const r15A1 = expr(ir_unop_i2u, r15A0);
                  body.emit(assign(r159E, bit_or(r159E, r15A1), 0x01));

                  body.emit(assign(r1442, rshift(r158B, body.constant(int(1))), 0x01));

                  ir_expression *const r15A2 = lshift(r158B, body.constant(int(31)));
                  ir_expression *const r15A3 = rshift(r158C, body.constant(int(1)));
                  body.emit(assign(r1441, bit_or(r15A2, r15A3), 0x01));

                  body.emit(assign(r1440, r159E, 0x01));

                  body.emit(assign(r143F, add(r143F, body.constant(int(1))), 0x01));


               body.instructions = f159C_parent_instructions;
               body.emit(f159C);

               /* END IF */

               ir_variable *const r15A4 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r15A4, r143F, 0x01));

               ir_variable *const r15A5 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r15A5, r1442, 0x01));

               ir_variable *const r15A6 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r15A6, r1441, 0x01));

               ir_variable *const r15A7 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r15A7, r1440, 0x01));

               ir_variable *const r15A8 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r15A8, body.constant(true), 0x01));

               ir_variable *const r15A9 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r15AA = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r15AA);
               ir_expression *const r15AB = expr(ir_unop_u2i, r1440);
               body.emit(assign(r15AA, less(r15AB, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r15AD = lequal(body.constant(int(2045)), r143F);
               ir_if *f15AC = new(mem_ctx) ir_if(operand(r15AD).val);
               exec_list *const f15AC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15AC->then_instructions;

                  ir_variable *const r15AE = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r15B0 = less(body.constant(int(2045)), r143F);
                  ir_if *f15AF = new(mem_ctx) ir_if(operand(r15B0).val);
                  exec_list *const f15AF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15AF->then_instructions;

                     body.emit(assign(r15AE, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15AF->else_instructions;

                     ir_variable *const r15B1 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r15B3 = equal(r143F, body.constant(int(2045)));
                     ir_if *f15B2 = new(mem_ctx) ir_if(operand(r15B3).val);
                     exec_list *const f15B2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15B2->then_instructions;

                        ir_expression *const r15B4 = equal(body.constant(2097151u), r1442);
                        ir_expression *const r15B5 = equal(body.constant(4294967295u), r1441);
                        body.emit(assign(r15B1, logic_and(r15B4, r15B5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f15B2->else_instructions;

                        body.emit(assign(r15B1, body.constant(false), 0x01));


                     body.instructions = f15B2_parent_instructions;
                     body.emit(f15B2);

                     /* END IF */

                     body.emit(assign(r15AE, logic_and(r15B1, r15AA), 0x01));


                  body.instructions = f15AF_parent_instructions;
                  body.emit(f15AF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f15B6 = new(mem_ctx) ir_if(operand(r15AE).val);
                  exec_list *const f15B6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15B6->then_instructions;

                     ir_variable *const r15B7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r15B7);
                     ir_expression *const r15B8 = lshift(r1438, body.constant(int(31)));
                     body.emit(assign(r15B7, add(r15B8, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r15B7, body.constant(0u), 0x01));

                     body.emit(assign(r15A9, r15B7, 0x03));

                     body.emit(assign(r15A8, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15B6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15BA = less(r143F, body.constant(int(0)));
                     ir_if *f15B9 = new(mem_ctx) ir_if(operand(r15BA).val);
                     exec_list *const f15B9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15B9->then_instructions;

                        ir_variable *const r15BB = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r15BB, r1440, 0x01));

                        ir_variable *const r15BC = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r15BC, neg(r143F), 0x01));

                        ir_variable *const r15BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r15BD);
                        ir_variable *const r15BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r15BE);
                        ir_variable *const r15BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r15BF);
                        ir_variable *const r15C0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r15C1 = neg(r15BC);
                        body.emit(assign(r15C0, bit_and(r15C1, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r15C3 = equal(r15BC, body.constant(int(0)));
                        ir_if *f15C2 = new(mem_ctx) ir_if(operand(r15C3).val);
                        exec_list *const f15C2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f15C2->then_instructions;

                           body.emit(assign(r15BD, r1440, 0x01));

                           body.emit(assign(r15BE, r1441, 0x01));

                           body.emit(assign(r15BF, r1442, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f15C2->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r15C5 = less(r15BC, body.constant(int(32)));
                           ir_if *f15C4 = new(mem_ctx) ir_if(operand(r15C5).val);
                           exec_list *const f15C4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f15C4->then_instructions;

                              body.emit(assign(r15BD, lshift(r1441, r15C0), 0x01));

                              ir_expression *const r15C6 = lshift(r1442, r15C0);
                              ir_expression *const r15C7 = rshift(r1441, r15BC);
                              body.emit(assign(r15BE, bit_or(r15C6, r15C7), 0x01));

                              body.emit(assign(r15BF, rshift(r1442, r15BC), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f15C4->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r15C9 = equal(r15BC, body.constant(int(32)));
                              ir_if *f15C8 = new(mem_ctx) ir_if(operand(r15C9).val);
                              exec_list *const f15C8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f15C8->then_instructions;

                                 body.emit(assign(r15BD, r1441, 0x01));

                                 body.emit(assign(r15BE, r1442, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f15C8->else_instructions;

                                 body.emit(assign(r15BB, bit_or(r1440, r1441), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r15CB = less(r15BC, body.constant(int(64)));
                                 ir_if *f15CA = new(mem_ctx) ir_if(operand(r15CB).val);
                                 exec_list *const f15CA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f15CA->then_instructions;

                                    body.emit(assign(r15BD, lshift(r1442, r15C0), 0x01));

                                    ir_expression *const r15CC = bit_and(r15BC, body.constant(int(31)));
                                    body.emit(assign(r15BE, rshift(r1442, r15CC), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f15CA->else_instructions;

                                    ir_variable *const r15CD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r15CF = equal(r15BC, body.constant(int(64)));
                                    ir_if *f15CE = new(mem_ctx) ir_if(operand(r15CF).val);
                                    exec_list *const f15CE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f15CE->then_instructions;

                                       body.emit(assign(r15CD, r1442, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f15CE->else_instructions;

                                       ir_expression *const r15D0 = nequal(r1442, body.constant(0u));
                                       ir_expression *const r15D1 = expr(ir_unop_b2i, r15D0);
                                       body.emit(assign(r15CD, expr(ir_unop_i2u, r15D1), 0x01));


                                    body.instructions = f15CE_parent_instructions;
                                    body.emit(f15CE);

                                    /* END IF */

                                    body.emit(assign(r15BD, r15CD, 0x01));

                                    body.emit(assign(r15BE, body.constant(0u), 0x01));


                                 body.instructions = f15CA_parent_instructions;
                                 body.emit(f15CA);

                                 /* END IF */


                              body.instructions = f15C8_parent_instructions;
                              body.emit(f15C8);

                              /* END IF */

                              body.emit(assign(r15BF, body.constant(0u), 0x01));


                           body.instructions = f15C4_parent_instructions;
                           body.emit(f15C4);

                           /* END IF */

                           ir_expression *const r15D2 = nequal(r15BB, body.constant(0u));
                           ir_expression *const r15D3 = expr(ir_unop_b2i, r15D2);
                           ir_expression *const r15D4 = expr(ir_unop_i2u, r15D3);
                           body.emit(assign(r15BD, bit_or(r15BD, r15D4), 0x01));


                        body.instructions = f15C2_parent_instructions;
                        body.emit(f15C2);

                        /* END IF */

                        body.emit(assign(r15A5, r15BF, 0x01));

                        body.emit(assign(r15A6, r15BE, 0x01));

                        body.emit(assign(r15A7, r15BD, 0x01));

                        body.emit(assign(r15A4, body.constant(int(0)), 0x01));

                        body.emit(assign(r15AA, less(r15BD, body.constant(0u)), 0x01));


                     body.instructions = f15B9_parent_instructions;
                     body.emit(f15B9);

                     /* END IF */


                  body.instructions = f15B6_parent_instructions;
                  body.emit(f15B6);

                  /* END IF */


               body.instructions = f15AC_parent_instructions;
               body.emit(f15AC);

               /* END IF */

               /* IF CONDITION */
               ir_if *f15D5 = new(mem_ctx) ir_if(operand(r15A8).val);
               exec_list *const f15D5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15D5->then_instructions;

                  /* IF CONDITION */
                  ir_if *f15D6 = new(mem_ctx) ir_if(operand(r15AA).val);
                  exec_list *const f15D6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15D6->then_instructions;

                     ir_variable *const r15D7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r15D7, add(r15A6, body.constant(1u)), 0x01));

                     ir_expression *const r15D8 = less(r15D7, r15A6);
                     ir_expression *const r15D9 = expr(ir_unop_b2i, r15D8);
                     ir_expression *const r15DA = expr(ir_unop_i2u, r15D9);
                     body.emit(assign(r15A5, add(r15A5, r15DA), 0x01));

                     ir_expression *const r15DB = equal(r15A7, body.constant(0u));
                     ir_expression *const r15DC = expr(ir_unop_b2i, r15DB);
                     ir_expression *const r15DD = expr(ir_unop_i2u, r15DC);
                     ir_expression *const r15DE = add(r15A7, r15DD);
                     ir_expression *const r15DF = bit_and(r15DE, body.constant(1u));
                     ir_expression *const r15E0 = expr(ir_unop_bit_not, r15DF);
                     body.emit(assign(r15A6, bit_and(r15D7, r15E0), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15D6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15E2 = bit_or(r15A5, r15A6);
                     ir_expression *const r15E3 = equal(r15E2, body.constant(0u));
                     ir_if *f15E1 = new(mem_ctx) ir_if(operand(r15E3).val);
                     exec_list *const f15E1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15E1->then_instructions;

                        body.emit(assign(r15A4, body.constant(int(0)), 0x01));


                     body.instructions = f15E1_parent_instructions;
                     body.emit(f15E1);

                     /* END IF */


                  body.instructions = f15D6_parent_instructions;
                  body.emit(f15D6);

                  /* END IF */

                  ir_variable *const r15E4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r15E4);
                  ir_expression *const r15E5 = lshift(r1438, body.constant(int(31)));
                  ir_expression *const r15E6 = expr(ir_unop_i2u, r15A4);
                  ir_expression *const r15E7 = lshift(r15E6, body.constant(int(20)));
                  ir_expression *const r15E8 = add(r15E5, r15E7);
                  body.emit(assign(r15E4, add(r15E8, r15A5), 0x02));

                  body.emit(assign(r15E4, r15A6, 0x01));

                  body.emit(assign(r15A9, r15E4, 0x03));

                  body.emit(assign(r15A8, body.constant(false), 0x01));


               body.instructions = f15D5_parent_instructions;
               body.emit(f15D5);

               /* END IF */

               body.emit(assign(r1437, r15A9, 0x03));

               body.emit(assign(r1436, body.constant(false), 0x01));


            body.instructions = f1529_parent_instructions;
            body.emit(f1529);

            /* END IF */


         body.instructions = f14E8_parent_instructions;
         body.emit(f14E8);

         /* END IF */


      body.instructions = f147E_parent_instructions;
      body.emit(f147E);

      /* END IF */


   body.instructions = f144F_parent_instructions;
   body.emit(f144F);

   /* END IF */

   body.emit(ret(r1437));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r15E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r15E9);
   ir_variable *const r15EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r15EA);
   ir_variable *const r15EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r15EB);
   ir_variable *const r15EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r15EC);
   ir_variable *const r15ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r15ED);
   ir_variable *const r15EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r15EE);
   ir_variable *const r15EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15EF);
   ir_variable *const r15F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F0);
   ir_variable *const r15F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F1);
   ir_variable *const r15F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r15F2);
   ir_variable *const r15F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r15F3);
   ir_variable *const r15F4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r15F4, add(r15EB, r15EE), 0x01));

   ir_variable *const r15F5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r15F6 = less(r15F4, r15EB);
   ir_expression *const r15F7 = expr(ir_unop_b2i, r15F6);
   body.emit(assign(r15F5, expr(ir_unop_i2u, r15F7), 0x01));

   ir_variable *const r15F8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r15F8, add(r15EA, r15ED), 0x01));

   body.emit(assign(r15F3, add(r15F8, r15F5), 0x01));

   ir_expression *const r15F9 = add(r15E9, r15EC);
   ir_expression *const r15FA = less(r15F3, r15F5);
   ir_expression *const r15FB = expr(ir_unop_b2i, r15FA);
   ir_expression *const r15FC = expr(ir_unop_i2u, r15FB);
   body.emit(assign(r15F2, add(r15F9, r15FC), 0x01));

   ir_expression *const r15FD = less(r15F8, r15EA);
   ir_expression *const r15FE = expr(ir_unop_b2i, r15FD);
   ir_expression *const r15FF = expr(ir_unop_i2u, r15FE);
   body.emit(assign(r15F2, add(r15F2, r15FF), 0x01));

   body.emit(assign(r15F1, r15F4, 0x01));

   body.emit(assign(r15F0, r15F3, 0x01));

   body.emit(assign(r15EF, r15F2, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1600 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1600);
   ir_variable *const r1601 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1601);
   ir_variable *const r1602 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r1602);
   ir_variable *const r1603 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r1603);
   ir_variable *const r1604 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1604);
   ir_variable *const r1605 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r1605);
   ir_variable *const r1606 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1606);
   ir_variable *const r1607 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1607);
   ir_variable *const r1608 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1608);
   ir_variable *const r1609 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1609);
   ir_variable *const r160A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r160B = less(r1602, r1605);
   ir_expression *const r160C = expr(ir_unop_b2i, r160B);
   body.emit(assign(r160A, expr(ir_unop_i2u, r160C), 0x01));

   ir_variable *const r160D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r160D, sub(r1601, r1604), 0x01));

   ir_expression *const r160E = sub(r1600, r1603);
   ir_expression *const r160F = less(r160D, r160A);
   ir_expression *const r1610 = expr(ir_unop_b2i, r160F);
   ir_expression *const r1611 = expr(ir_unop_i2u, r1610);
   body.emit(assign(r1609, sub(r160E, r1611), 0x01));

   ir_expression *const r1612 = less(r1601, r1604);
   ir_expression *const r1613 = expr(ir_unop_b2i, r1612);
   ir_expression *const r1614 = expr(ir_unop_i2u, r1613);
   body.emit(assign(r1609, sub(r1609, r1614), 0x01));

   body.emit(assign(r1608, sub(r1602, r1605), 0x01));

   body.emit(assign(r1607, sub(r160D, r160A), 0x01));

   body.emit(assign(r1606, r1609, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Right(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1615 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1615);
   ir_variable *const r1616 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1616);
   ir_variable *const r1617 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1617);
   ir_variable *const r1618 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1618);
   ir_variable *const r1619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1619);
   ir_variable *const r161A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r161A);
   ir_variable *const r161B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r161B);
   ir_variable *const r161C = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r161D = neg(r1617);
   body.emit(assign(r161C, bit_and(r161D, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r161F = equal(r1617, body.constant(int(0)));
   ir_if *f161E = new(mem_ctx) ir_if(operand(r161F).val);
   exec_list *const f161E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f161E->then_instructions;

      body.emit(assign(r161A, r1616, 0x01));

      body.emit(assign(r161B, r1615, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f161E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1621 = less(r1617, body.constant(int(32)));
      ir_if *f1620 = new(mem_ctx) ir_if(operand(r1621).val);
      exec_list *const f1620_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1620->then_instructions;

         ir_expression *const r1622 = lshift(r1615, r161C);
         ir_expression *const r1623 = rshift(r1616, r1617);
         body.emit(assign(r161A, bit_or(r1622, r1623), 0x01));

         body.emit(assign(r161B, rshift(r1615, r1617), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1620->else_instructions;

         ir_variable *const r1624 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1626 = less(r1617, body.constant(int(64)));
         ir_if *f1625 = new(mem_ctx) ir_if(operand(r1626).val);
         exec_list *const f1625_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1625->then_instructions;

            ir_expression *const r1627 = bit_and(r1617, body.constant(int(31)));
            body.emit(assign(r1624, rshift(r1615, r1627), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1625->else_instructions;

            body.emit(assign(r1624, body.constant(0u), 0x01));


         body.instructions = f1625_parent_instructions;
         body.emit(f1625);

         /* END IF */

         body.emit(assign(r161A, r1624, 0x01));

         body.emit(assign(r161B, body.constant(0u), 0x01));


      body.instructions = f1620_parent_instructions;
      body.emit(f1620);

      /* END IF */


   body.instructions = f161E_parent_instructions;
   body.emit(f161E);

   /* END IF */

   body.emit(assign(r1619, r161A, 0x01));

   body.emit(assign(r1618, r161B, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateDiv64To32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1628 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1628);
   ir_variable *const r1629 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1629);
   ir_variable *const r162A = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r162A);
   ir_variable *const r162B = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r162C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r162C);
   ir_variable *const r162D = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r162D);
   ir_variable *const r162E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r162E);
   ir_variable *const r162F = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
   body.emit(r162F);
   body.emit(assign(r162E, body.constant(0u), 0x01));

   body.emit(assign(r162D, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1631 = lequal(r162A, r1628);
   ir_if *f1630 = new(mem_ctx) ir_if(operand(r1631).val);
   exec_list *const f1630_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1630->then_instructions;

      body.emit(assign(r162B, body.constant(4294967295u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1630->else_instructions;

      body.emit(assign(r162F, rshift(r162A, body.constant(int(16))), 0x01));

      ir_variable *const r1632 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1634 = lshift(r162F, body.constant(int(16)));
      ir_expression *const r1635 = lequal(r1634, r1628);
      ir_if *f1633 = new(mem_ctx) ir_if(operand(r1635).val);
      exec_list *const f1633_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1633->then_instructions;

         body.emit(assign(r1632, body.constant(4294901760u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1633->else_instructions;

         ir_expression *const r1636 = expr(ir_binop_div, r1628, r162F);
         body.emit(assign(r1632, lshift(r1636, body.constant(int(16))), 0x01));


      body.instructions = f1633_parent_instructions;
      body.emit(f1633);

      /* END IF */

      body.emit(assign(r162C, r1632, 0x01));

      ir_variable *const r1637 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1637);
      ir_variable *const r1638 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
      body.emit(r1638);
      ir_variable *const r1639 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1639);
      ir_variable *const r163A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163A, bit_and(r162A, body.constant(65535u)), 0x01));

      ir_variable *const r163B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163B, rshift(r162A, body.constant(int(16))), 0x01));

      ir_variable *const r163C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163C, bit_and(r1632, body.constant(65535u)), 0x01));

      ir_variable *const r163D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163D, rshift(r1632, body.constant(int(16))), 0x01));

      ir_variable *const r163E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163E, mul(r163B, r163C), 0x01));

      ir_expression *const r163F = mul(r163A, r163D);
      body.emit(assign(r1638, add(r163F, r163E), 0x01));

      ir_expression *const r1640 = mul(r163B, r163D);
      ir_expression *const r1641 = less(r1638, r163E);
      ir_expression *const r1642 = expr(ir_unop_b2i, r1641);
      ir_expression *const r1643 = expr(ir_unop_i2u, r1642);
      ir_expression *const r1644 = lshift(r1643, body.constant(int(16)));
      ir_expression *const r1645 = rshift(r1638, body.constant(int(16)));
      ir_expression *const r1646 = add(r1644, r1645);
      body.emit(assign(r1637, add(r1640, r1646), 0x01));

      body.emit(assign(r1638, lshift(r1638, body.constant(int(16))), 0x01));

      ir_expression *const r1647 = mul(r163A, r163C);
      body.emit(assign(r1639, add(r1647, r1638), 0x01));

      ir_expression *const r1648 = less(r1639, r1638);
      ir_expression *const r1649 = expr(ir_unop_b2i, r1648);
      ir_expression *const r164A = expr(ir_unop_i2u, r1649);
      body.emit(assign(r1637, add(r1637, r164A), 0x01));

      ir_expression *const r164B = sub(r1628, r1637);
      ir_expression *const r164C = less(r1629, r1639);
      ir_expression *const r164D = expr(ir_unop_b2i, r164C);
      ir_expression *const r164E = expr(ir_unop_i2u, r164D);
      body.emit(assign(r162E, sub(r164B, r164E), 0x01));

      body.emit(assign(r162D, sub(r1629, r1639), 0x01));

      /* LOOP BEGIN */
      ir_loop *f164F = new(mem_ctx) ir_loop();
      exec_list *const f164F_parent_instructions = body.instructions;

         body.instructions = &f164F->body_instructions;

         /* IF CONDITION */
         ir_expression *const r1651 = expr(ir_unop_u2i, r162E);
         ir_expression *const r1652 = gequal(r1651, body.constant(int(0)));
         ir_if *f1650 = new(mem_ctx) ir_if(operand(r1652).val);
         exec_list *const f1650_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1650->then_instructions;

            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


         body.instructions = f1650_parent_instructions;
         body.emit(f1650);

         /* END IF */

         body.emit(assign(r162C, add(r162C, body.constant(4294901760u)), 0x01));

         ir_variable *const r1653 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         ir_expression *const r1654 = lshift(r162A, body.constant(int(16)));
         body.emit(assign(r1653, add(r162D, r1654), 0x01));

         ir_expression *const r1655 = add(r162E, r162F);
         ir_expression *const r1656 = less(r1653, r162D);
         ir_expression *const r1657 = expr(ir_unop_b2i, r1656);
         ir_expression *const r1658 = expr(ir_unop_i2u, r1657);
         body.emit(assign(r162E, add(r1655, r1658), 0x01));

         body.emit(assign(r162D, r1653, 0x01));

      /* LOOP END */

      body.instructions = f164F_parent_instructions;
      body.emit(f164F);

      ir_expression *const r1659 = lshift(r162E, body.constant(int(16)));
      ir_expression *const r165A = rshift(r162D, body.constant(int(16)));
      body.emit(assign(r162E, bit_or(r1659, r165A), 0x01));

      ir_variable *const r165B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r165D = lshift(r162F, body.constant(int(16)));
      ir_expression *const r165E = lequal(r165D, r162E);
      ir_if *f165C = new(mem_ctx) ir_if(operand(r165E).val);
      exec_list *const f165C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f165C->then_instructions;

         body.emit(assign(r165B, body.constant(65535u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f165C->else_instructions;

         body.emit(assign(r165B, expr(ir_binop_div, r162E, r162F), 0x01));


      body.instructions = f165C_parent_instructions;
      body.emit(f165C);

      /* END IF */

      body.emit(assign(r162C, bit_or(r162C, r165B), 0x01));

      body.emit(assign(r162B, r162C, 0x01));


   body.instructions = f1630_parent_instructions;
   body.emit(f1630);

   /* END IF */

   body.emit(ret(r162B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64By32To96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r165F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r165F);
   ir_variable *const r1660 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1660);
   ir_variable *const r1661 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1661);
   ir_variable *const r1662 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1662);
   ir_variable *const r1663 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1663);
   ir_variable *const r1664 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1664);
   ir_variable *const r1665 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1665);
   ir_variable *const r1666 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r1666);
   ir_variable *const r1667 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1667);
   ir_variable *const r1668 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1668, bit_and(r1660, body.constant(65535u)), 0x01));

   ir_variable *const r1669 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1669, rshift(r1660, body.constant(int(16))), 0x01));

   ir_variable *const r166A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166A, bit_and(r1661, body.constant(65535u)), 0x01));

   ir_variable *const r166B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166B, rshift(r1661, body.constant(int(16))), 0x01));

   ir_variable *const r166C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166C, mul(r1669, r166A), 0x01));

   ir_expression *const r166D = mul(r1668, r166B);
   body.emit(assign(r1666, add(r166D, r166C), 0x01));

   ir_expression *const r166E = mul(r1669, r166B);
   ir_expression *const r166F = less(r1666, r166C);
   ir_expression *const r1670 = expr(ir_unop_b2i, r166F);
   ir_expression *const r1671 = expr(ir_unop_i2u, r1670);
   ir_expression *const r1672 = lshift(r1671, body.constant(int(16)));
   ir_expression *const r1673 = rshift(r1666, body.constant(int(16)));
   ir_expression *const r1674 = add(r1672, r1673);
   body.emit(assign(r1665, add(r166E, r1674), 0x01));

   body.emit(assign(r1666, lshift(r1666, body.constant(int(16))), 0x01));

   ir_expression *const r1675 = mul(r1668, r166A);
   body.emit(assign(r1667, add(r1675, r1666), 0x01));

   ir_expression *const r1676 = less(r1667, r1666);
   ir_expression *const r1677 = expr(ir_unop_b2i, r1676);
   ir_expression *const r1678 = expr(ir_unop_i2u, r1677);
   body.emit(assign(r1665, add(r1665, r1678), 0x01));

   ir_variable *const r1679 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1679);
   ir_variable *const r167A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r167A);
   ir_variable *const r167B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r167B);
   ir_variable *const r167C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r167C, bit_and(r165F, body.constant(65535u)), 0x01));

   ir_variable *const r167D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r167D, rshift(r165F, body.constant(int(16))), 0x01));

   ir_variable *const r167E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r167E, bit_and(r1661, body.constant(65535u)), 0x01));

   ir_variable *const r167F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r167F, rshift(r1661, body.constant(int(16))), 0x01));

   ir_variable *const r1680 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1680, mul(r167D, r167E), 0x01));

   ir_expression *const r1681 = mul(r167C, r167F);
   body.emit(assign(r167A, add(r1681, r1680), 0x01));

   ir_expression *const r1682 = mul(r167D, r167F);
   ir_expression *const r1683 = less(r167A, r1680);
   ir_expression *const r1684 = expr(ir_unop_b2i, r1683);
   ir_expression *const r1685 = expr(ir_unop_i2u, r1684);
   ir_expression *const r1686 = lshift(r1685, body.constant(int(16)));
   ir_expression *const r1687 = rshift(r167A, body.constant(int(16)));
   ir_expression *const r1688 = add(r1686, r1687);
   body.emit(assign(r1679, add(r1682, r1688), 0x01));

   body.emit(assign(r167A, lshift(r167A, body.constant(int(16))), 0x01));

   ir_expression *const r1689 = mul(r167C, r167E);
   body.emit(assign(r167B, add(r1689, r167A), 0x01));

   ir_expression *const r168A = less(r167B, r167A);
   ir_expression *const r168B = expr(ir_unop_b2i, r168A);
   ir_expression *const r168C = expr(ir_unop_i2u, r168B);
   body.emit(assign(r1679, add(r1679, r168C), 0x01));

   ir_variable *const r168D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r168D, add(r167B, r1665), 0x01));

   body.emit(assign(r1664, r1667, 0x01));

   body.emit(assign(r1663, r168D, 0x01));

   ir_expression *const r168E = less(r168D, r167B);
   ir_expression *const r168F = expr(ir_unop_b2i, r168E);
   ir_expression *const r1690 = expr(ir_unop_i2u, r168F);
   body.emit(assign(r1662, add(r1679, r1690), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fdiv64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1691 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1691);
   ir_variable *const r1692 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1692);
   ir_variable *const r1693 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1693, body.constant(true), 0x01));

   ir_variable *const r1694 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1695 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1695);
   ir_variable *const r1696 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r1696);
   ir_variable *const r1697 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r1697);
   ir_variable *const r1698 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r1698);
   ir_variable *const r1699 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r1699);
   ir_variable *const r169A = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r169A);
   ir_variable *const r169B = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r169B);
   ir_variable *const r169C = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r169C);
   ir_variable *const r169D = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r169D);
   ir_variable *const r169E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r169E);
   ir_variable *const r169F = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r169F);
   ir_variable *const r16A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r16A0);
   ir_variable *const r16A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r16A1);
   ir_variable *const r16A2 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r16A2);
   body.emit(assign(r16A1, body.constant(0u), 0x01));

   body.emit(assign(r16A0, body.constant(0u), 0x01));

   body.emit(assign(r169F, body.constant(0u), 0x01));

   body.emit(assign(r169E, body.constant(0u), 0x01));

   body.emit(assign(r169D, body.constant(0u), 0x01));

   body.emit(assign(r169C, body.constant(0u), 0x01));

   ir_variable *const r16A3 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r16A3, swizzle_x(r1691), 0x01));

   body.emit(assign(r169B, r16A3, 0x01));

   ir_variable *const r16A4 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r16A4, bit_and(swizzle_y(r1691), body.constant(1048575u)), 0x01));

   body.emit(assign(r169A, r16A4, 0x01));

   ir_variable *const r16A5 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r16A5, swizzle_x(r1692), 0x01));

   body.emit(assign(r1699, r16A5, 0x01));

   ir_variable *const r16A6 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r16A6, bit_and(swizzle_y(r1692), body.constant(1048575u)), 0x01));

   body.emit(assign(r1698, r16A6, 0x01));

   ir_variable *const r16A7 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r16A8 = rshift(swizzle_y(r1691), body.constant(int(20)));
   ir_expression *const r16A9 = bit_and(r16A8, body.constant(2047u));
   body.emit(assign(r16A7, expr(ir_unop_u2i, r16A9), 0x01));

   body.emit(assign(r1697, r16A7, 0x01));

   ir_variable *const r16AA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r16AB = rshift(swizzle_y(r1692), body.constant(int(20)));
   ir_expression *const r16AC = bit_and(r16AB, body.constant(2047u));
   body.emit(assign(r16AA, expr(ir_unop_u2i, r16AC), 0x01));

   body.emit(assign(r1696, r16AA, 0x01));

   ir_expression *const r16AD = rshift(swizzle_y(r1691), body.constant(int(31)));
   ir_expression *const r16AE = rshift(swizzle_y(r1692), body.constant(int(31)));
   body.emit(assign(r1695, bit_xor(r16AD, r16AE), 0x01));

   /* IF CONDITION */
   ir_expression *const r16B0 = equal(r16A7, body.constant(int(2047)));
   ir_if *f16AF = new(mem_ctx) ir_if(operand(r16B0).val);
   exec_list *const f16AF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f16AF->then_instructions;

      /* IF CONDITION */
      ir_expression *const r16B2 = bit_or(r16A4, swizzle_x(r1691));
      ir_expression *const r16B3 = nequal(r16B2, body.constant(0u));
      ir_if *f16B1 = new(mem_ctx) ir_if(operand(r16B3).val);
      exec_list *const f16B1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16B1->then_instructions;

         ir_variable *const r16B4 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r16B4, swizzle_x(r1691), 0x01));

         ir_variable *const r16B5 = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r16B5, swizzle_x(r1692), 0x01));

         ir_variable *const r16B6 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r16B7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r16B8 = rshift(swizzle_y(r1691), body.constant(int(19)));
         ir_expression *const r16B9 = bit_and(r16B8, body.constant(4095u));
         ir_expression *const r16BA = equal(r16B9, body.constant(4094u));
         ir_expression *const r16BB = nequal(swizzle_x(r1691), body.constant(0u));
         ir_expression *const r16BC = bit_and(swizzle_y(r1691), body.constant(524287u));
         ir_expression *const r16BD = nequal(r16BC, body.constant(0u));
         ir_expression *const r16BE = logic_or(r16BB, r16BD);
         body.emit(assign(r16B7, logic_and(r16BA, r16BE), 0x01));

         ir_variable *const r16BF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r16C0 = lshift(swizzle_y(r1692), body.constant(int(1)));
         ir_expression *const r16C1 = lequal(body.constant(4292870144u), r16C0);
         ir_expression *const r16C2 = nequal(swizzle_x(r1692), body.constant(0u));
         ir_expression *const r16C3 = bit_and(swizzle_y(r1692), body.constant(1048575u));
         ir_expression *const r16C4 = nequal(r16C3, body.constant(0u));
         ir_expression *const r16C5 = logic_or(r16C2, r16C4);
         body.emit(assign(r16BF, logic_and(r16C1, r16C5), 0x01));

         body.emit(assign(r16B4, bit_or(swizzle_y(r1691), body.constant(524288u)), 0x02));

         body.emit(assign(r16B5, bit_or(swizzle_y(r1692), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r16C7 = lshift(swizzle_y(r1691), body.constant(int(1)));
         ir_expression *const r16C8 = lequal(body.constant(4292870144u), r16C7);
         ir_expression *const r16C9 = nequal(swizzle_x(r1691), body.constant(0u));
         ir_expression *const r16CA = bit_and(swizzle_y(r1691), body.constant(1048575u));
         ir_expression *const r16CB = nequal(r16CA, body.constant(0u));
         ir_expression *const r16CC = logic_or(r16C9, r16CB);
         ir_expression *const r16CD = logic_and(r16C8, r16CC);
         ir_if *f16C6 = new(mem_ctx) ir_if(operand(r16CD).val);
         exec_list *const f16C6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16C6->then_instructions;

            ir_variable *const r16CE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r16D0 = logic_and(r16B7, r16BF);
            ir_if *f16CF = new(mem_ctx) ir_if(operand(r16D0).val);
            exec_list *const f16CF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16CF->then_instructions;

               body.emit(assign(r16CE, r16B5, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16CF->else_instructions;

               body.emit(assign(r16CE, r16B4, 0x03));


            body.instructions = f16CF_parent_instructions;
            body.emit(f16CF);

            /* END IF */

            body.emit(assign(r16B6, r16CE, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16C6->else_instructions;

            body.emit(assign(r16B6, r16B5, 0x03));


         body.instructions = f16C6_parent_instructions;
         body.emit(f16C6);

         /* END IF */

         body.emit(assign(r1694, r16B6, 0x03));

         body.emit(assign(r1693, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16B1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r16D2 = equal(r16AA, body.constant(int(2047)));
         ir_if *f16D1 = new(mem_ctx) ir_if(operand(r16D2).val);
         exec_list *const f16D1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16D1->then_instructions;

            /* IF CONDITION */
            ir_expression *const r16D4 = bit_or(r16A6, swizzle_x(r1692));
            ir_expression *const r16D5 = nequal(r16D4, body.constant(0u));
            ir_if *f16D3 = new(mem_ctx) ir_if(operand(r16D5).val);
            exec_list *const f16D3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16D3->then_instructions;

               ir_variable *const r16D6 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r16D6, swizzle_x(r1691), 0x01));

               ir_variable *const r16D7 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r16D7, swizzle_x(r1692), 0x01));

               ir_variable *const r16D8 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r16D9 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r16DA = rshift(swizzle_y(r1691), body.constant(int(19)));
               ir_expression *const r16DB = bit_and(r16DA, body.constant(4095u));
               ir_expression *const r16DC = equal(r16DB, body.constant(4094u));
               ir_expression *const r16DD = nequal(swizzle_x(r1691), body.constant(0u));
               ir_expression *const r16DE = bit_and(swizzle_y(r1691), body.constant(524287u));
               ir_expression *const r16DF = nequal(r16DE, body.constant(0u));
               ir_expression *const r16E0 = logic_or(r16DD, r16DF);
               body.emit(assign(r16D9, logic_and(r16DC, r16E0), 0x01));

               ir_variable *const r16E1 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r16E2 = lshift(swizzle_y(r1692), body.constant(int(1)));
               ir_expression *const r16E3 = lequal(body.constant(4292870144u), r16E2);
               ir_expression *const r16E4 = nequal(swizzle_x(r1692), body.constant(0u));
               ir_expression *const r16E5 = bit_and(swizzle_y(r1692), body.constant(1048575u));
               ir_expression *const r16E6 = nequal(r16E5, body.constant(0u));
               ir_expression *const r16E7 = logic_or(r16E4, r16E6);
               body.emit(assign(r16E1, logic_and(r16E3, r16E7), 0x01));

               body.emit(assign(r16D6, bit_or(swizzle_y(r1691), body.constant(524288u)), 0x02));

               body.emit(assign(r16D7, bit_or(swizzle_y(r1692), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r16E9 = lshift(swizzle_y(r1691), body.constant(int(1)));
               ir_expression *const r16EA = lequal(body.constant(4292870144u), r16E9);
               ir_expression *const r16EB = nequal(swizzle_x(r1691), body.constant(0u));
               ir_expression *const r16EC = bit_and(swizzle_y(r1691), body.constant(1048575u));
               ir_expression *const r16ED = nequal(r16EC, body.constant(0u));
               ir_expression *const r16EE = logic_or(r16EB, r16ED);
               ir_expression *const r16EF = logic_and(r16EA, r16EE);
               ir_if *f16E8 = new(mem_ctx) ir_if(operand(r16EF).val);
               exec_list *const f16E8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f16E8->then_instructions;

                  ir_variable *const r16F0 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r16F2 = logic_and(r16D9, r16E1);
                  ir_if *f16F1 = new(mem_ctx) ir_if(operand(r16F2).val);
                  exec_list *const f16F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f16F1->then_instructions;

                     body.emit(assign(r16F0, r16D7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f16F1->else_instructions;

                     body.emit(assign(r16F0, r16D6, 0x03));


                  body.instructions = f16F1_parent_instructions;
                  body.emit(f16F1);

                  /* END IF */

                  body.emit(assign(r16D8, r16F0, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f16E8->else_instructions;

                  body.emit(assign(r16D8, r16D7, 0x03));


               body.instructions = f16E8_parent_instructions;
               body.emit(f16E8);

               /* END IF */

               body.emit(assign(r1694, r16D8, 0x03));

               body.emit(assign(r1693, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16D3->else_instructions;

               ir_constant_data r16F3_data;
               memset(&r16F3_data, 0, sizeof(ir_constant_data));
               r16F3_data.u[0] = 4294967295;
               r16F3_data.u[1] = 4294967295;
               ir_constant *const r16F3 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r16F3_data);
               body.emit(assign(r1694, r16F3, 0x03));

               body.emit(assign(r1693, body.constant(false), 0x01));


            body.instructions = f16D3_parent_instructions;
            body.emit(f16D3);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16D1->else_instructions;

            ir_variable *const r16F4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r16F4);
            ir_expression *const r16F5 = lshift(r1695, body.constant(int(31)));
            body.emit(assign(r16F4, add(r16F5, body.constant(2146435072u)), 0x02));

            body.emit(assign(r16F4, body.constant(0u), 0x01));

            body.emit(assign(r1694, r16F4, 0x03));

            body.emit(assign(r1693, body.constant(false), 0x01));


         body.instructions = f16D1_parent_instructions;
         body.emit(f16D1);

         /* END IF */


      body.instructions = f16B1_parent_instructions;
      body.emit(f16B1);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f16AF->else_instructions;

      /* IF CONDITION */
      ir_expression *const r16F7 = equal(r16AA, body.constant(int(2047)));
      ir_if *f16F6 = new(mem_ctx) ir_if(operand(r16F7).val);
      exec_list *const f16F6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16F6->then_instructions;

         /* IF CONDITION */
         ir_expression *const r16F9 = bit_or(r16A6, swizzle_x(r1692));
         ir_expression *const r16FA = nequal(r16F9, body.constant(0u));
         ir_if *f16F8 = new(mem_ctx) ir_if(operand(r16FA).val);
         exec_list *const f16F8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16F8->then_instructions;

            ir_variable *const r16FB = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r16FB, swizzle_x(r1691), 0x01));

            ir_variable *const r16FC = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r16FC, swizzle_x(r1692), 0x01));

            ir_variable *const r16FD = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r16FE = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r16FF = rshift(swizzle_y(r1691), body.constant(int(19)));
            ir_expression *const r1700 = bit_and(r16FF, body.constant(4095u));
            ir_expression *const r1701 = equal(r1700, body.constant(4094u));
            ir_expression *const r1702 = nequal(swizzle_x(r1691), body.constant(0u));
            ir_expression *const r1703 = bit_and(swizzle_y(r1691), body.constant(524287u));
            ir_expression *const r1704 = nequal(r1703, body.constant(0u));
            ir_expression *const r1705 = logic_or(r1702, r1704);
            body.emit(assign(r16FE, logic_and(r1701, r1705), 0x01));

            ir_variable *const r1706 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r1707 = lshift(swizzle_y(r1692), body.constant(int(1)));
            ir_expression *const r1708 = lequal(body.constant(4292870144u), r1707);
            ir_expression *const r1709 = nequal(swizzle_x(r1692), body.constant(0u));
            ir_expression *const r170A = bit_and(swizzle_y(r1692), body.constant(1048575u));
            ir_expression *const r170B = nequal(r170A, body.constant(0u));
            ir_expression *const r170C = logic_or(r1709, r170B);
            body.emit(assign(r1706, logic_and(r1708, r170C), 0x01));

            body.emit(assign(r16FB, bit_or(swizzle_y(r1691), body.constant(524288u)), 0x02));

            body.emit(assign(r16FC, bit_or(swizzle_y(r1692), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r170E = lshift(swizzle_y(r1691), body.constant(int(1)));
            ir_expression *const r170F = lequal(body.constant(4292870144u), r170E);
            ir_expression *const r1710 = nequal(swizzle_x(r1691), body.constant(0u));
            ir_expression *const r1711 = bit_and(swizzle_y(r1691), body.constant(1048575u));
            ir_expression *const r1712 = nequal(r1711, body.constant(0u));
            ir_expression *const r1713 = logic_or(r1710, r1712);
            ir_expression *const r1714 = logic_and(r170F, r1713);
            ir_if *f170D = new(mem_ctx) ir_if(operand(r1714).val);
            exec_list *const f170D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f170D->then_instructions;

               ir_variable *const r1715 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1717 = logic_and(r16FE, r1706);
               ir_if *f1716 = new(mem_ctx) ir_if(operand(r1717).val);
               exec_list *const f1716_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1716->then_instructions;

                  body.emit(assign(r1715, r16FC, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1716->else_instructions;

                  body.emit(assign(r1715, r16FB, 0x03));


               body.instructions = f1716_parent_instructions;
               body.emit(f1716);

               /* END IF */

               body.emit(assign(r16FD, r1715, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f170D->else_instructions;

               body.emit(assign(r16FD, r16FC, 0x03));


            body.instructions = f170D_parent_instructions;
            body.emit(f170D);

            /* END IF */

            body.emit(assign(r1694, r16FD, 0x03));

            body.emit(assign(r1693, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16F8->else_instructions;

            ir_variable *const r1718 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1718);
            body.emit(assign(r1718, lshift(r1695, body.constant(int(31))), 0x02));

            body.emit(assign(r1718, body.constant(0u), 0x01));

            body.emit(assign(r1694, r1718, 0x03));

            body.emit(assign(r1693, body.constant(false), 0x01));


         body.instructions = f16F8_parent_instructions;
         body.emit(f16F8);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16F6->else_instructions;

         /* IF CONDITION */
         ir_expression *const r171A = equal(r16AA, body.constant(int(0)));
         ir_if *f1719 = new(mem_ctx) ir_if(operand(r171A).val);
         exec_list *const f1719_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1719->then_instructions;

            /* IF CONDITION */
            ir_expression *const r171C = bit_or(r16A6, swizzle_x(r1692));
            ir_expression *const r171D = equal(r171C, body.constant(0u));
            ir_if *f171B = new(mem_ctx) ir_if(operand(r171D).val);
            exec_list *const f171B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f171B->then_instructions;

               /* IF CONDITION */
               ir_expression *const r171F = expr(ir_unop_i2u, r16A7);
               ir_expression *const r1720 = bit_or(r171F, r16A4);
               ir_expression *const r1721 = bit_or(r1720, swizzle_x(r1691));
               ir_expression *const r1722 = equal(r1721, body.constant(0u));
               ir_if *f171E = new(mem_ctx) ir_if(operand(r1722).val);
               exec_list *const f171E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f171E->then_instructions;

                  ir_constant_data r1723_data;
                  memset(&r1723_data, 0, sizeof(ir_constant_data));
                  r1723_data.u[0] = 4294967295;
                  r1723_data.u[1] = 4294967295;
                  ir_constant *const r1723 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1723_data);
                  body.emit(assign(r1694, r1723, 0x03));

                  body.emit(assign(r1693, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f171E->else_instructions;

                  ir_variable *const r1724 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1724);
                  ir_expression *const r1725 = lshift(r1695, body.constant(int(31)));
                  body.emit(assign(r1724, add(r1725, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1724, body.constant(0u), 0x01));

                  body.emit(assign(r1694, r1724, 0x03));

                  body.emit(assign(r1693, body.constant(false), 0x01));


               body.instructions = f171E_parent_instructions;
               body.emit(f171E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f171B->else_instructions;

               ir_variable *const r1726 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r1726, r16AA, 0x01));

               ir_variable *const r1727 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r1727, r16A6, 0x01));

               ir_variable *const r1728 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r1728, r16A5, 0x01));

               ir_variable *const r1729 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1729);
               /* IF CONDITION */
               ir_expression *const r172B = equal(r16A6, body.constant(0u));
               ir_if *f172A = new(mem_ctx) ir_if(operand(r172B).val);
               exec_list *const f172A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f172A->then_instructions;

                  ir_variable *const r172C = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r172C, r16A5, 0x01));

                  ir_variable *const r172D = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r172E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r172E);
                  /* IF CONDITION */
                  ir_expression *const r1730 = equal(swizzle_x(r1692), body.constant(0u));
                  ir_if *f172F = new(mem_ctx) ir_if(operand(r1730).val);
                  exec_list *const f172F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f172F->then_instructions;

                     body.emit(assign(r172D, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f172F->else_instructions;

                     body.emit(assign(r172E, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1732 = bit_and(swizzle_x(r1692), body.constant(4294901760u));
                     ir_expression *const r1733 = equal(r1732, body.constant(0u));
                     ir_if *f1731 = new(mem_ctx) ir_if(operand(r1733).val);
                     exec_list *const f1731_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1731->then_instructions;

                        body.emit(assign(r172E, body.constant(int(16)), 0x01));

                        body.emit(assign(r172C, lshift(swizzle_x(r1692), body.constant(int(16))), 0x01));


                     body.instructions = f1731_parent_instructions;
                     body.emit(f1731);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1735 = bit_and(r172C, body.constant(4278190080u));
                     ir_expression *const r1736 = equal(r1735, body.constant(0u));
                     ir_if *f1734 = new(mem_ctx) ir_if(operand(r1736).val);
                     exec_list *const f1734_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1734->then_instructions;

                        body.emit(assign(r172E, add(r172E, body.constant(int(8))), 0x01));

                        body.emit(assign(r172C, lshift(r172C, body.constant(int(8))), 0x01));


                     body.instructions = f1734_parent_instructions;
                     body.emit(f1734);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1738 = bit_and(r172C, body.constant(4026531840u));
                     ir_expression *const r1739 = equal(r1738, body.constant(0u));
                     ir_if *f1737 = new(mem_ctx) ir_if(operand(r1739).val);
                     exec_list *const f1737_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1737->then_instructions;

                        body.emit(assign(r172E, add(r172E, body.constant(int(4))), 0x01));

                        body.emit(assign(r172C, lshift(r172C, body.constant(int(4))), 0x01));


                     body.instructions = f1737_parent_instructions;
                     body.emit(f1737);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r173B = bit_and(r172C, body.constant(3221225472u));
                     ir_expression *const r173C = equal(r173B, body.constant(0u));
                     ir_if *f173A = new(mem_ctx) ir_if(operand(r173C).val);
                     exec_list *const f173A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f173A->then_instructions;

                        body.emit(assign(r172E, add(r172E, body.constant(int(2))), 0x01));

                        body.emit(assign(r172C, lshift(r172C, body.constant(int(2))), 0x01));


                     body.instructions = f173A_parent_instructions;
                     body.emit(f173A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r173E = bit_and(r172C, body.constant(2147483648u));
                     ir_expression *const r173F = equal(r173E, body.constant(0u));
                     ir_if *f173D = new(mem_ctx) ir_if(operand(r173F).val);
                     exec_list *const f173D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f173D->then_instructions;

                        body.emit(assign(r172E, add(r172E, body.constant(int(1))), 0x01));


                     body.instructions = f173D_parent_instructions;
                     body.emit(f173D);

                     /* END IF */

                     body.emit(assign(r172D, r172E, 0x01));


                  body.instructions = f172F_parent_instructions;
                  body.emit(f172F);

                  /* END IF */

                  body.emit(assign(r1729, add(r172D, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1741 = less(r1729, body.constant(int(0)));
                  ir_if *f1740 = new(mem_ctx) ir_if(operand(r1741).val);
                  exec_list *const f1740_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1740->then_instructions;

                     ir_expression *const r1742 = neg(r1729);
                     body.emit(assign(r1727, rshift(swizzle_x(r1692), r1742), 0x01));

                     ir_expression *const r1743 = bit_and(r1729, body.constant(int(31)));
                     body.emit(assign(r1728, lshift(swizzle_x(r1692), r1743), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1740->else_instructions;

                     body.emit(assign(r1727, lshift(swizzle_x(r1692), r1729), 0x01));

                     body.emit(assign(r1728, body.constant(0u), 0x01));


                  body.instructions = f1740_parent_instructions;
                  body.emit(f1740);

                  /* END IF */

                  body.emit(assign(r1726, sub(body.constant(int(-31)), r1729), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f172A->else_instructions;

                  ir_variable *const r1744 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r1744, r16A6, 0x01));

                  ir_variable *const r1745 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1746 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1746);
                  /* IF CONDITION */
                  ir_expression *const r1748 = equal(r16A6, body.constant(0u));
                  ir_if *f1747 = new(mem_ctx) ir_if(operand(r1748).val);
                  exec_list *const f1747_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1747->then_instructions;

                     body.emit(assign(r1745, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1747->else_instructions;

                     body.emit(assign(r1746, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r174A = bit_and(r16A6, body.constant(4294901760u));
                     ir_expression *const r174B = equal(r174A, body.constant(0u));
                     ir_if *f1749 = new(mem_ctx) ir_if(operand(r174B).val);
                     exec_list *const f1749_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1749->then_instructions;

                        body.emit(assign(r1746, body.constant(int(16)), 0x01));

                        body.emit(assign(r1744, lshift(r16A6, body.constant(int(16))), 0x01));


                     body.instructions = f1749_parent_instructions;
                     body.emit(f1749);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r174D = bit_and(r1744, body.constant(4278190080u));
                     ir_expression *const r174E = equal(r174D, body.constant(0u));
                     ir_if *f174C = new(mem_ctx) ir_if(operand(r174E).val);
                     exec_list *const f174C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f174C->then_instructions;

                        body.emit(assign(r1746, add(r1746, body.constant(int(8))), 0x01));

                        body.emit(assign(r1744, lshift(r1744, body.constant(int(8))), 0x01));


                     body.instructions = f174C_parent_instructions;
                     body.emit(f174C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1750 = bit_and(r1744, body.constant(4026531840u));
                     ir_expression *const r1751 = equal(r1750, body.constant(0u));
                     ir_if *f174F = new(mem_ctx) ir_if(operand(r1751).val);
                     exec_list *const f174F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f174F->then_instructions;

                        body.emit(assign(r1746, add(r1746, body.constant(int(4))), 0x01));

                        body.emit(assign(r1744, lshift(r1744, body.constant(int(4))), 0x01));


                     body.instructions = f174F_parent_instructions;
                     body.emit(f174F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1753 = bit_and(r1744, body.constant(3221225472u));
                     ir_expression *const r1754 = equal(r1753, body.constant(0u));
                     ir_if *f1752 = new(mem_ctx) ir_if(operand(r1754).val);
                     exec_list *const f1752_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1752->then_instructions;

                        body.emit(assign(r1746, add(r1746, body.constant(int(2))), 0x01));

                        body.emit(assign(r1744, lshift(r1744, body.constant(int(2))), 0x01));


                     body.instructions = f1752_parent_instructions;
                     body.emit(f1752);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1756 = bit_and(r1744, body.constant(2147483648u));
                     ir_expression *const r1757 = equal(r1756, body.constant(0u));
                     ir_if *f1755 = new(mem_ctx) ir_if(operand(r1757).val);
                     exec_list *const f1755_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1755->then_instructions;

                        body.emit(assign(r1746, add(r1746, body.constant(int(1))), 0x01));


                     body.instructions = f1755_parent_instructions;
                     body.emit(f1755);

                     /* END IF */

                     body.emit(assign(r1745, r1746, 0x01));


                  body.instructions = f1747_parent_instructions;
                  body.emit(f1747);

                  /* END IF */

                  body.emit(assign(r1729, add(r1745, body.constant(int(-11))), 0x01));

                  ir_variable *const r1758 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1758, lshift(swizzle_x(r1692), r1729), 0x01));

                  ir_variable *const r1759 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r175B = equal(r1729, body.constant(int(0)));
                  ir_if *f175A = new(mem_ctx) ir_if(operand(r175B).val);
                  exec_list *const f175A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f175A->then_instructions;

                     body.emit(assign(r1759, r16A6, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f175A->else_instructions;

                     ir_expression *const r175C = lshift(r16A6, r1729);
                     ir_expression *const r175D = neg(r1729);
                     ir_expression *const r175E = bit_and(r175D, body.constant(int(31)));
                     ir_expression *const r175F = rshift(swizzle_x(r1692), r175E);
                     body.emit(assign(r1759, bit_or(r175C, r175F), 0x01));


                  body.instructions = f175A_parent_instructions;
                  body.emit(f175A);

                  /* END IF */

                  body.emit(assign(r1727, r1759, 0x01));

                  body.emit(assign(r1728, r1758, 0x01));

                  body.emit(assign(r1726, sub(body.constant(int(1)), r1729), 0x01));


               body.instructions = f172A_parent_instructions;
               body.emit(f172A);

               /* END IF */

               body.emit(assign(r1696, r1726, 0x01));

               body.emit(assign(r1698, r1727, 0x01));

               body.emit(assign(r1699, r1728, 0x01));


            body.instructions = f171B_parent_instructions;
            body.emit(f171B);

            /* END IF */


         body.instructions = f1719_parent_instructions;
         body.emit(f1719);

         /* END IF */

         /* IF CONDITION */
         ir_if *f1760 = new(mem_ctx) ir_if(operand(r1693).val);
         exec_list *const f1760_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1760->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1762 = equal(r16A7, body.constant(int(0)));
            ir_if *f1761 = new(mem_ctx) ir_if(operand(r1762).val);
            exec_list *const f1761_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1761->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1764 = bit_or(r16A4, swizzle_x(r1691));
               ir_expression *const r1765 = equal(r1764, body.constant(0u));
               ir_if *f1763 = new(mem_ctx) ir_if(operand(r1765).val);
               exec_list *const f1763_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1763->then_instructions;

                  ir_variable *const r1766 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1766);
                  body.emit(assign(r1766, lshift(r1695, body.constant(int(31))), 0x02));

                  body.emit(assign(r1766, body.constant(0u), 0x01));

                  body.emit(assign(r1694, r1766, 0x03));

                  body.emit(assign(r1693, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1763->else_instructions;

                  ir_variable *const r1767 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r1767, r16A7, 0x01));

                  ir_variable *const r1768 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r1768, r16A4, 0x01));

                  ir_variable *const r1769 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r1769, r16A3, 0x01));

                  ir_variable *const r176A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r176A);
                  /* IF CONDITION */
                  ir_expression *const r176C = equal(r16A4, body.constant(0u));
                  ir_if *f176B = new(mem_ctx) ir_if(operand(r176C).val);
                  exec_list *const f176B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f176B->then_instructions;

                     ir_variable *const r176D = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r176D, r16A3, 0x01));

                     ir_variable *const r176E = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r176F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r176F);
                     /* IF CONDITION */
                     ir_expression *const r1771 = equal(swizzle_x(r1691), body.constant(0u));
                     ir_if *f1770 = new(mem_ctx) ir_if(operand(r1771).val);
                     exec_list *const f1770_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1770->then_instructions;

                        body.emit(assign(r176E, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1770->else_instructions;

                        body.emit(assign(r176F, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1773 = bit_and(swizzle_x(r1691), body.constant(4294901760u));
                        ir_expression *const r1774 = equal(r1773, body.constant(0u));
                        ir_if *f1772 = new(mem_ctx) ir_if(operand(r1774).val);
                        exec_list *const f1772_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1772->then_instructions;

                           body.emit(assign(r176F, body.constant(int(16)), 0x01));

                           body.emit(assign(r176D, lshift(swizzle_x(r1691), body.constant(int(16))), 0x01));


                        body.instructions = f1772_parent_instructions;
                        body.emit(f1772);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1776 = bit_and(r176D, body.constant(4278190080u));
                        ir_expression *const r1777 = equal(r1776, body.constant(0u));
                        ir_if *f1775 = new(mem_ctx) ir_if(operand(r1777).val);
                        exec_list *const f1775_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1775->then_instructions;

                           body.emit(assign(r176F, add(r176F, body.constant(int(8))), 0x01));

                           body.emit(assign(r176D, lshift(r176D, body.constant(int(8))), 0x01));


                        body.instructions = f1775_parent_instructions;
                        body.emit(f1775);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1779 = bit_and(r176D, body.constant(4026531840u));
                        ir_expression *const r177A = equal(r1779, body.constant(0u));
                        ir_if *f1778 = new(mem_ctx) ir_if(operand(r177A).val);
                        exec_list *const f1778_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1778->then_instructions;

                           body.emit(assign(r176F, add(r176F, body.constant(int(4))), 0x01));

                           body.emit(assign(r176D, lshift(r176D, body.constant(int(4))), 0x01));


                        body.instructions = f1778_parent_instructions;
                        body.emit(f1778);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r177C = bit_and(r176D, body.constant(3221225472u));
                        ir_expression *const r177D = equal(r177C, body.constant(0u));
                        ir_if *f177B = new(mem_ctx) ir_if(operand(r177D).val);
                        exec_list *const f177B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f177B->then_instructions;

                           body.emit(assign(r176F, add(r176F, body.constant(int(2))), 0x01));

                           body.emit(assign(r176D, lshift(r176D, body.constant(int(2))), 0x01));


                        body.instructions = f177B_parent_instructions;
                        body.emit(f177B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r177F = bit_and(r176D, body.constant(2147483648u));
                        ir_expression *const r1780 = equal(r177F, body.constant(0u));
                        ir_if *f177E = new(mem_ctx) ir_if(operand(r1780).val);
                        exec_list *const f177E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f177E->then_instructions;

                           body.emit(assign(r176F, add(r176F, body.constant(int(1))), 0x01));


                        body.instructions = f177E_parent_instructions;
                        body.emit(f177E);

                        /* END IF */

                        body.emit(assign(r176E, r176F, 0x01));


                     body.instructions = f1770_parent_instructions;
                     body.emit(f1770);

                     /* END IF */

                     body.emit(assign(r176A, add(r176E, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1782 = less(r176A, body.constant(int(0)));
                     ir_if *f1781 = new(mem_ctx) ir_if(operand(r1782).val);
                     exec_list *const f1781_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1781->then_instructions;

                        ir_expression *const r1783 = neg(r176A);
                        body.emit(assign(r1768, rshift(swizzle_x(r1691), r1783), 0x01));

                        ir_expression *const r1784 = bit_and(r176A, body.constant(int(31)));
                        body.emit(assign(r1769, lshift(swizzle_x(r1691), r1784), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1781->else_instructions;

                        body.emit(assign(r1768, lshift(swizzle_x(r1691), r176A), 0x01));

                        body.emit(assign(r1769, body.constant(0u), 0x01));


                     body.instructions = f1781_parent_instructions;
                     body.emit(f1781);

                     /* END IF */

                     body.emit(assign(r1767, sub(body.constant(int(-31)), r176A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f176B->else_instructions;

                     ir_variable *const r1785 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1785, r16A4, 0x01));

                     ir_variable *const r1786 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1787 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1787);
                     /* IF CONDITION */
                     ir_expression *const r1789 = equal(r16A4, body.constant(0u));
                     ir_if *f1788 = new(mem_ctx) ir_if(operand(r1789).val);
                     exec_list *const f1788_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1788->then_instructions;

                        body.emit(assign(r1786, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1788->else_instructions;

                        body.emit(assign(r1787, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r178B = bit_and(r16A4, body.constant(4294901760u));
                        ir_expression *const r178C = equal(r178B, body.constant(0u));
                        ir_if *f178A = new(mem_ctx) ir_if(operand(r178C).val);
                        exec_list *const f178A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f178A->then_instructions;

                           body.emit(assign(r1787, body.constant(int(16)), 0x01));

                           body.emit(assign(r1785, lshift(r16A4, body.constant(int(16))), 0x01));


                        body.instructions = f178A_parent_instructions;
                        body.emit(f178A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r178E = bit_and(r1785, body.constant(4278190080u));
                        ir_expression *const r178F = equal(r178E, body.constant(0u));
                        ir_if *f178D = new(mem_ctx) ir_if(operand(r178F).val);
                        exec_list *const f178D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f178D->then_instructions;

                           body.emit(assign(r1787, add(r1787, body.constant(int(8))), 0x01));

                           body.emit(assign(r1785, lshift(r1785, body.constant(int(8))), 0x01));


                        body.instructions = f178D_parent_instructions;
                        body.emit(f178D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1791 = bit_and(r1785, body.constant(4026531840u));
                        ir_expression *const r1792 = equal(r1791, body.constant(0u));
                        ir_if *f1790 = new(mem_ctx) ir_if(operand(r1792).val);
                        exec_list *const f1790_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1790->then_instructions;

                           body.emit(assign(r1787, add(r1787, body.constant(int(4))), 0x01));

                           body.emit(assign(r1785, lshift(r1785, body.constant(int(4))), 0x01));


                        body.instructions = f1790_parent_instructions;
                        body.emit(f1790);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1794 = bit_and(r1785, body.constant(3221225472u));
                        ir_expression *const r1795 = equal(r1794, body.constant(0u));
                        ir_if *f1793 = new(mem_ctx) ir_if(operand(r1795).val);
                        exec_list *const f1793_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1793->then_instructions;

                           body.emit(assign(r1787, add(r1787, body.constant(int(2))), 0x01));

                           body.emit(assign(r1785, lshift(r1785, body.constant(int(2))), 0x01));


                        body.instructions = f1793_parent_instructions;
                        body.emit(f1793);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1797 = bit_and(r1785, body.constant(2147483648u));
                        ir_expression *const r1798 = equal(r1797, body.constant(0u));
                        ir_if *f1796 = new(mem_ctx) ir_if(operand(r1798).val);
                        exec_list *const f1796_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1796->then_instructions;

                           body.emit(assign(r1787, add(r1787, body.constant(int(1))), 0x01));


                        body.instructions = f1796_parent_instructions;
                        body.emit(f1796);

                        /* END IF */

                        body.emit(assign(r1786, r1787, 0x01));


                     body.instructions = f1788_parent_instructions;
                     body.emit(f1788);

                     /* END IF */

                     body.emit(assign(r176A, add(r1786, body.constant(int(-11))), 0x01));

                     ir_variable *const r1799 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1799, lshift(swizzle_x(r1691), r176A), 0x01));

                     ir_variable *const r179A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r179C = equal(r176A, body.constant(int(0)));
                     ir_if *f179B = new(mem_ctx) ir_if(operand(r179C).val);
                     exec_list *const f179B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f179B->then_instructions;

                        body.emit(assign(r179A, r16A4, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f179B->else_instructions;

                        ir_expression *const r179D = lshift(r16A4, r176A);
                        ir_expression *const r179E = neg(r176A);
                        ir_expression *const r179F = bit_and(r179E, body.constant(int(31)));
                        ir_expression *const r17A0 = rshift(swizzle_x(r1691), r179F);
                        body.emit(assign(r179A, bit_or(r179D, r17A0), 0x01));


                     body.instructions = f179B_parent_instructions;
                     body.emit(f179B);

                     /* END IF */

                     body.emit(assign(r1768, r179A, 0x01));

                     body.emit(assign(r1769, r1799, 0x01));

                     body.emit(assign(r1767, sub(body.constant(int(1)), r176A), 0x01));


                  body.instructions = f176B_parent_instructions;
                  body.emit(f176B);

                  /* END IF */

                  body.emit(assign(r1697, r1767, 0x01));

                  body.emit(assign(r169A, r1768, 0x01));

                  body.emit(assign(r169B, r1769, 0x01));


               body.instructions = f1763_parent_instructions;
               body.emit(f1763);

               /* END IF */


            body.instructions = f1761_parent_instructions;
            body.emit(f1761);

            /* END IF */

            /* IF CONDITION */
            ir_if *f17A1 = new(mem_ctx) ir_if(operand(r1693).val);
            exec_list *const f17A1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f17A1->then_instructions;

               ir_expression *const r17A2 = sub(r1697, r1696);
               body.emit(assign(r16A2, add(r17A2, body.constant(int(1021))), 0x01));

               ir_variable *const r17A3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r17A3, lshift(r169B, body.constant(int(11))), 0x01));

               ir_variable *const r17A4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r17A5 = bit_or(r169A, body.constant(1048576u));
               ir_expression *const r17A6 = lshift(r17A5, body.constant(int(11)));
               ir_expression *const r17A7 = rshift(r169B, body.constant(int(21)));
               body.emit(assign(r17A4, bit_or(r17A6, r17A7), 0x01));

               body.emit(assign(r169A, r17A4, 0x01));

               body.emit(assign(r169B, r17A3, 0x01));

               ir_variable *const r17A8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r17A8, lshift(r1699, body.constant(int(11))), 0x01));

               ir_variable *const r17A9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r17AA = bit_or(r1698, body.constant(1048576u));
               ir_expression *const r17AB = lshift(r17AA, body.constant(int(11)));
               ir_expression *const r17AC = rshift(r1699, body.constant(int(21)));
               body.emit(assign(r17A9, bit_or(r17AB, r17AC), 0x01));

               body.emit(assign(r1698, r17A9, 0x01));

               body.emit(assign(r1699, r17A8, 0x01));

               /* IF CONDITION */
               ir_expression *const r17AE = less(r17A9, r17A4);
               ir_expression *const r17AF = equal(r17A9, r17A4);
               ir_expression *const r17B0 = lequal(r17A8, r17A3);
               ir_expression *const r17B1 = logic_and(r17AF, r17B0);
               ir_expression *const r17B2 = logic_or(r17AE, r17B1);
               ir_if *f17AD = new(mem_ctx) ir_if(operand(r17B2).val);
               exec_list *const f17AD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f17AD->then_instructions;

                  body.emit(assign(r169A, rshift(r17A4, body.constant(int(1))), 0x01));

                  ir_expression *const r17B3 = lshift(r17A4, body.constant(int(31)));
                  ir_expression *const r17B4 = rshift(r17A3, body.constant(int(1)));
                  body.emit(assign(r169B, bit_or(r17B3, r17B4), 0x01));

                  body.emit(assign(r16A2, add(r16A2, body.constant(int(1))), 0x01));


               body.instructions = f17AD_parent_instructions;
               body.emit(f17AD);

               /* END IF */

               ir_variable *const r17B5 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r17B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r17B6);
               ir_variable *const r17B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r17B7);
               ir_variable *const r17B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r17B8);
               ir_variable *const r17B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r17B9);
               body.emit(assign(r17B8, body.constant(0u), 0x01));

               body.emit(assign(r17B7, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r17BB = lequal(r17A9, r169A);
               ir_if *f17BA = new(mem_ctx) ir_if(operand(r17BB).val);
               exec_list *const f17BA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f17BA->then_instructions;

                  body.emit(assign(r17B5, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f17BA->else_instructions;

                  body.emit(assign(r17B9, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r17BC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r17BE = lshift(r17B9, body.constant(int(16)));
                  ir_expression *const r17BF = lequal(r17BE, r169A);
                  ir_if *f17BD = new(mem_ctx) ir_if(operand(r17BF).val);
                  exec_list *const f17BD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17BD->then_instructions;

                     body.emit(assign(r17BC, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17BD->else_instructions;

                     ir_expression *const r17C0 = expr(ir_binop_div, r169A, r17B9);
                     body.emit(assign(r17BC, lshift(r17C0, body.constant(int(16))), 0x01));


                  body.instructions = f17BD_parent_instructions;
                  body.emit(f17BD);

                  /* END IF */

                  body.emit(assign(r17B6, r17BC, 0x01));

                  ir_variable *const r17C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r17C1);
                  ir_variable *const r17C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r17C2);
                  ir_variable *const r17C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r17C3);
                  ir_variable *const r17C4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C4, bit_and(r17A9, body.constant(65535u)), 0x01));

                  ir_variable *const r17C5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C5, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r17C6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C6, bit_and(r17BC, body.constant(65535u)), 0x01));

                  ir_variable *const r17C7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C7, rshift(r17BC, body.constant(int(16))), 0x01));

                  ir_variable *const r17C8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C8, mul(r17C5, r17C6), 0x01));

                  ir_expression *const r17C9 = mul(r17C4, r17C7);
                  body.emit(assign(r17C2, add(r17C9, r17C8), 0x01));

                  ir_expression *const r17CA = mul(r17C5, r17C7);
                  ir_expression *const r17CB = less(r17C2, r17C8);
                  ir_expression *const r17CC = expr(ir_unop_b2i, r17CB);
                  ir_expression *const r17CD = expr(ir_unop_i2u, r17CC);
                  ir_expression *const r17CE = lshift(r17CD, body.constant(int(16)));
                  ir_expression *const r17CF = rshift(r17C2, body.constant(int(16)));
                  ir_expression *const r17D0 = add(r17CE, r17CF);
                  body.emit(assign(r17C1, add(r17CA, r17D0), 0x01));

                  body.emit(assign(r17C2, lshift(r17C2, body.constant(int(16))), 0x01));

                  ir_expression *const r17D1 = mul(r17C4, r17C6);
                  body.emit(assign(r17C3, add(r17D1, r17C2), 0x01));

                  ir_expression *const r17D2 = less(r17C3, r17C2);
                  ir_expression *const r17D3 = expr(ir_unop_b2i, r17D2);
                  ir_expression *const r17D4 = expr(ir_unop_i2u, r17D3);
                  body.emit(assign(r17C1, add(r17C1, r17D4), 0x01));

                  ir_expression *const r17D5 = sub(r169A, r17C1);
                  ir_expression *const r17D6 = less(r169B, r17C3);
                  ir_expression *const r17D7 = expr(ir_unop_b2i, r17D6);
                  ir_expression *const r17D8 = expr(ir_unop_i2u, r17D7);
                  body.emit(assign(r17B8, sub(r17D5, r17D8), 0x01));

                  body.emit(assign(r17B7, sub(r169B, r17C3), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f17D9 = new(mem_ctx) ir_loop();
                  exec_list *const f17D9_parent_instructions = body.instructions;

                     body.instructions = &f17D9->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r17DB = expr(ir_unop_u2i, r17B8);
                     ir_expression *const r17DC = gequal(r17DB, body.constant(int(0)));
                     ir_if *f17DA = new(mem_ctx) ir_if(operand(r17DC).val);
                     exec_list *const f17DA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17DA->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f17DA_parent_instructions;
                     body.emit(f17DA);

                     /* END IF */

                     body.emit(assign(r17B6, add(r17B6, body.constant(4294901760u)), 0x01));

                     ir_variable *const r17DD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r17DE = lshift(r17A9, body.constant(int(16)));
                     body.emit(assign(r17DD, add(r17B7, r17DE), 0x01));

                     ir_expression *const r17DF = add(r17B8, r17B9);
                     ir_expression *const r17E0 = less(r17DD, r17B7);
                     ir_expression *const r17E1 = expr(ir_unop_b2i, r17E0);
                     ir_expression *const r17E2 = expr(ir_unop_i2u, r17E1);
                     body.emit(assign(r17B8, add(r17DF, r17E2), 0x01));

                     body.emit(assign(r17B7, r17DD, 0x01));

                  /* LOOP END */

                  body.instructions = f17D9_parent_instructions;
                  body.emit(f17D9);

                  ir_expression *const r17E3 = lshift(r17B8, body.constant(int(16)));
                  ir_expression *const r17E4 = rshift(r17B7, body.constant(int(16)));
                  body.emit(assign(r17B8, bit_or(r17E3, r17E4), 0x01));

                  ir_variable *const r17E5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r17E7 = lshift(r17B9, body.constant(int(16)));
                  ir_expression *const r17E8 = lequal(r17E7, r17B8);
                  ir_if *f17E6 = new(mem_ctx) ir_if(operand(r17E8).val);
                  exec_list *const f17E6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17E6->then_instructions;

                     body.emit(assign(r17E5, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17E6->else_instructions;

                     body.emit(assign(r17E5, expr(ir_binop_div, r17B8, r17B9), 0x01));


                  body.instructions = f17E6_parent_instructions;
                  body.emit(f17E6);

                  /* END IF */

                  body.emit(assign(r17B6, bit_or(r17B6, r17E5), 0x01));

                  body.emit(assign(r17B5, r17B6, 0x01));


               body.instructions = f17BA_parent_instructions;
               body.emit(f17BA);

               /* END IF */

               body.emit(assign(r16A1, r17B5, 0x01));

               ir_variable *const r17E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r17E9);
               ir_variable *const r17EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r17EA);
               ir_variable *const r17EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r17EB);
               ir_variable *const r17EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17EC, bit_and(r17A8, body.constant(65535u)), 0x01));

               ir_variable *const r17ED = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17ED, rshift(r17A8, body.constant(int(16))), 0x01));

               ir_variable *const r17EE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17EE, bit_and(r17B5, body.constant(65535u)), 0x01));

               ir_variable *const r17EF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17EF, rshift(r17B5, body.constant(int(16))), 0x01));

               ir_variable *const r17F0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F0, mul(r17ED, r17EE), 0x01));

               ir_expression *const r17F1 = mul(r17EC, r17EF);
               body.emit(assign(r17EA, add(r17F1, r17F0), 0x01));

               ir_expression *const r17F2 = mul(r17ED, r17EF);
               ir_expression *const r17F3 = less(r17EA, r17F0);
               ir_expression *const r17F4 = expr(ir_unop_b2i, r17F3);
               ir_expression *const r17F5 = expr(ir_unop_i2u, r17F4);
               ir_expression *const r17F6 = lshift(r17F5, body.constant(int(16)));
               ir_expression *const r17F7 = rshift(r17EA, body.constant(int(16)));
               ir_expression *const r17F8 = add(r17F6, r17F7);
               body.emit(assign(r17E9, add(r17F2, r17F8), 0x01));

               body.emit(assign(r17EA, lshift(r17EA, body.constant(int(16))), 0x01));

               ir_expression *const r17F9 = mul(r17EC, r17EE);
               body.emit(assign(r17EB, add(r17F9, r17EA), 0x01));

               ir_expression *const r17FA = less(r17EB, r17EA);
               ir_expression *const r17FB = expr(ir_unop_b2i, r17FA);
               ir_expression *const r17FC = expr(ir_unop_i2u, r17FB);
               body.emit(assign(r17E9, add(r17E9, r17FC), 0x01));

               ir_variable *const r17FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r17FD);
               ir_variable *const r17FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r17FE);
               ir_variable *const r17FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r17FF);
               ir_variable *const r1800 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1800, bit_and(r17A9, body.constant(65535u)), 0x01));

               ir_variable *const r1801 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1801, rshift(r17A9, body.constant(int(16))), 0x01));

               ir_variable *const r1802 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1802, bit_and(r17B5, body.constant(65535u)), 0x01));

               ir_variable *const r1803 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1803, rshift(r17B5, body.constant(int(16))), 0x01));

               ir_variable *const r1804 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1804, mul(r1801, r1802), 0x01));

               ir_expression *const r1805 = mul(r1800, r1803);
               body.emit(assign(r17FE, add(r1805, r1804), 0x01));

               ir_expression *const r1806 = mul(r1801, r1803);
               ir_expression *const r1807 = less(r17FE, r1804);
               ir_expression *const r1808 = expr(ir_unop_b2i, r1807);
               ir_expression *const r1809 = expr(ir_unop_i2u, r1808);
               ir_expression *const r180A = lshift(r1809, body.constant(int(16)));
               ir_expression *const r180B = rshift(r17FE, body.constant(int(16)));
               ir_expression *const r180C = add(r180A, r180B);
               body.emit(assign(r17FD, add(r1806, r180C), 0x01));

               body.emit(assign(r17FE, lshift(r17FE, body.constant(int(16))), 0x01));

               ir_expression *const r180D = mul(r1800, r1802);
               body.emit(assign(r17FF, add(r180D, r17FE), 0x01));

               ir_expression *const r180E = less(r17FF, r17FE);
               ir_expression *const r180F = expr(ir_unop_b2i, r180E);
               ir_expression *const r1810 = expr(ir_unop_i2u, r180F);
               body.emit(assign(r17FD, add(r17FD, r1810), 0x01));

               ir_variable *const r1811 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1811, add(r17FF, r17E9), 0x01));

               ir_variable *const r1812 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1812);
               ir_variable *const r1813 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1814 = less(body.constant(0u), r17EB);
               ir_expression *const r1815 = expr(ir_unop_b2i, r1814);
               body.emit(assign(r1813, expr(ir_unop_i2u, r1815), 0x01));

               ir_variable *const r1816 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1816, sub(r169B, r1811), 0x01));

               ir_expression *const r1817 = less(r1811, r17FF);
               ir_expression *const r1818 = expr(ir_unop_b2i, r1817);
               ir_expression *const r1819 = expr(ir_unop_i2u, r1818);
               ir_expression *const r181A = add(r17FD, r1819);
               ir_expression *const r181B = sub(r169A, r181A);
               ir_expression *const r181C = less(r1816, r1813);
               ir_expression *const r181D = expr(ir_unop_b2i, r181C);
               ir_expression *const r181E = expr(ir_unop_i2u, r181D);
               body.emit(assign(r1812, sub(r181B, r181E), 0x01));

               ir_expression *const r181F = less(r169B, r1811);
               ir_expression *const r1820 = expr(ir_unop_b2i, r181F);
               ir_expression *const r1821 = expr(ir_unop_i2u, r1820);
               body.emit(assign(r1812, sub(r1812, r1821), 0x01));

               body.emit(assign(r169F, r1812, 0x01));

               body.emit(assign(r169E, sub(r1816, r1813), 0x01));

               body.emit(assign(r169D, neg(r17EB), 0x01));

               /* LOOP BEGIN */
               ir_loop *f1822 = new(mem_ctx) ir_loop();
               exec_list *const f1822_parent_instructions = body.instructions;

                  body.instructions = &f1822->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1824 = expr(ir_unop_u2i, r169F);
                  ir_expression *const r1825 = gequal(r1824, body.constant(int(0)));
                  ir_if *f1823 = new(mem_ctx) ir_if(operand(r1825).val);
                  exec_list *const f1823_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1823->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f1823_parent_instructions;
                  body.emit(f1823);

                  /* END IF */

                  body.emit(assign(r16A1, add(r16A1, body.constant(4294967295u)), 0x01));

                  ir_variable *const r1826 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1826);
                  ir_variable *const r1827 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1827);
                  ir_variable *const r1828 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1828, add(r169D, r17A8), 0x01));

                  ir_variable *const r1829 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r182A = less(r1828, r169D);
                  ir_expression *const r182B = expr(ir_unop_b2i, r182A);
                  body.emit(assign(r1829, expr(ir_unop_i2u, r182B), 0x01));

                  ir_variable *const r182C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r182C, add(r169E, r17A9), 0x01));

                  body.emit(assign(r1827, add(r182C, r1829), 0x01));

                  ir_expression *const r182D = less(r1827, r1829);
                  ir_expression *const r182E = expr(ir_unop_b2i, r182D);
                  ir_expression *const r182F = expr(ir_unop_i2u, r182E);
                  body.emit(assign(r1826, add(r169F, r182F), 0x01));

                  ir_expression *const r1830 = less(r182C, r169E);
                  ir_expression *const r1831 = expr(ir_unop_b2i, r1830);
                  ir_expression *const r1832 = expr(ir_unop_i2u, r1831);
                  body.emit(assign(r1826, add(r1826, r1832), 0x01));

                  body.emit(assign(r169F, r1826, 0x01));

                  body.emit(assign(r169E, r1827, 0x01));

                  body.emit(assign(r169D, r1828, 0x01));

               /* LOOP END */

               body.instructions = f1822_parent_instructions;
               body.emit(f1822);

               ir_variable *const r1833 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r1834 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r1834);
               ir_variable *const r1835 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r1835);
               ir_variable *const r1836 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r1836);
               ir_variable *const r1837 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r1837);
               body.emit(assign(r1836, body.constant(0u), 0x01));

               body.emit(assign(r1835, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r1839 = lequal(r17A9, r169E);
               ir_if *f1838 = new(mem_ctx) ir_if(operand(r1839).val);
               exec_list *const f1838_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1838->then_instructions;

                  body.emit(assign(r1833, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1838->else_instructions;

                  body.emit(assign(r1837, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r183A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r183C = lshift(r1837, body.constant(int(16)));
                  ir_expression *const r183D = lequal(r183C, r169E);
                  ir_if *f183B = new(mem_ctx) ir_if(operand(r183D).val);
                  exec_list *const f183B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f183B->then_instructions;

                     body.emit(assign(r183A, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f183B->else_instructions;

                     ir_expression *const r183E = expr(ir_binop_div, r169E, r1837);
                     body.emit(assign(r183A, lshift(r183E, body.constant(int(16))), 0x01));


                  body.instructions = f183B_parent_instructions;
                  body.emit(f183B);

                  /* END IF */

                  body.emit(assign(r1834, r183A, 0x01));

                  ir_variable *const r183F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r183F);
                  ir_variable *const r1840 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r1840);
                  ir_variable *const r1841 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1841);
                  ir_variable *const r1842 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1842, bit_and(r17A9, body.constant(65535u)), 0x01));

                  ir_variable *const r1843 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1843, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r1844 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1844, bit_and(r183A, body.constant(65535u)), 0x01));

                  ir_variable *const r1845 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1845, rshift(r183A, body.constant(int(16))), 0x01));

                  ir_variable *const r1846 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1846, mul(r1843, r1844), 0x01));

                  ir_expression *const r1847 = mul(r1842, r1845);
                  body.emit(assign(r1840, add(r1847, r1846), 0x01));

                  ir_expression *const r1848 = mul(r1843, r1845);
                  ir_expression *const r1849 = less(r1840, r1846);
                  ir_expression *const r184A = expr(ir_unop_b2i, r1849);
                  ir_expression *const r184B = expr(ir_unop_i2u, r184A);
                  ir_expression *const r184C = lshift(r184B, body.constant(int(16)));
                  ir_expression *const r184D = rshift(r1840, body.constant(int(16)));
                  ir_expression *const r184E = add(r184C, r184D);
                  body.emit(assign(r183F, add(r1848, r184E), 0x01));

                  body.emit(assign(r1840, lshift(r1840, body.constant(int(16))), 0x01));

                  ir_expression *const r184F = mul(r1842, r1844);
                  body.emit(assign(r1841, add(r184F, r1840), 0x01));

                  ir_expression *const r1850 = less(r1841, r1840);
                  ir_expression *const r1851 = expr(ir_unop_b2i, r1850);
                  ir_expression *const r1852 = expr(ir_unop_i2u, r1851);
                  body.emit(assign(r183F, add(r183F, r1852), 0x01));

                  ir_expression *const r1853 = sub(r169E, r183F);
                  ir_expression *const r1854 = less(r169D, r1841);
                  ir_expression *const r1855 = expr(ir_unop_b2i, r1854);
                  ir_expression *const r1856 = expr(ir_unop_i2u, r1855);
                  body.emit(assign(r1836, sub(r1853, r1856), 0x01));

                  body.emit(assign(r1835, sub(r169D, r1841), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f1857 = new(mem_ctx) ir_loop();
                  exec_list *const f1857_parent_instructions = body.instructions;

                     body.instructions = &f1857->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1859 = expr(ir_unop_u2i, r1836);
                     ir_expression *const r185A = gequal(r1859, body.constant(int(0)));
                     ir_if *f1858 = new(mem_ctx) ir_if(operand(r185A).val);
                     exec_list *const f1858_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1858->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f1858_parent_instructions;
                     body.emit(f1858);

                     /* END IF */

                     body.emit(assign(r1834, add(r1834, body.constant(4294901760u)), 0x01));

                     ir_variable *const r185B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r185C = lshift(r17A9, body.constant(int(16)));
                     body.emit(assign(r185B, add(r1835, r185C), 0x01));

                     ir_expression *const r185D = add(r1836, r1837);
                     ir_expression *const r185E = less(r185B, r1835);
                     ir_expression *const r185F = expr(ir_unop_b2i, r185E);
                     ir_expression *const r1860 = expr(ir_unop_i2u, r185F);
                     body.emit(assign(r1836, add(r185D, r1860), 0x01));

                     body.emit(assign(r1835, r185B, 0x01));

                  /* LOOP END */

                  body.instructions = f1857_parent_instructions;
                  body.emit(f1857);

                  ir_expression *const r1861 = lshift(r1836, body.constant(int(16)));
                  ir_expression *const r1862 = rshift(r1835, body.constant(int(16)));
                  body.emit(assign(r1836, bit_or(r1861, r1862), 0x01));

                  ir_variable *const r1863 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1865 = lshift(r1837, body.constant(int(16)));
                  ir_expression *const r1866 = lequal(r1865, r1836);
                  ir_if *f1864 = new(mem_ctx) ir_if(operand(r1866).val);
                  exec_list *const f1864_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1864->then_instructions;

                     body.emit(assign(r1863, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1864->else_instructions;

                     body.emit(assign(r1863, expr(ir_binop_div, r1836, r1837), 0x01));


                  body.instructions = f1864_parent_instructions;
                  body.emit(f1864);

                  /* END IF */

                  body.emit(assign(r1834, bit_or(r1834, r1863), 0x01));

                  body.emit(assign(r1833, r1834, 0x01));


               body.instructions = f1838_parent_instructions;
               body.emit(f1838);

               /* END IF */

               body.emit(assign(r16A0, r1833, 0x01));

               /* IF CONDITION */
               ir_expression *const r1868 = bit_and(r1833, body.constant(1023u));
               ir_expression *const r1869 = lequal(r1868, body.constant(4u));
               ir_if *f1867 = new(mem_ctx) ir_if(operand(r1869).val);
               exec_list *const f1867_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1867->then_instructions;

                  ir_variable *const r186A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r186A);
                  ir_variable *const r186B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r186B);
                  ir_variable *const r186C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r186C);
                  ir_variable *const r186D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r186D, bit_and(r17A8, body.constant(65535u)), 0x01));

                  ir_variable *const r186E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r186E, rshift(r17A8, body.constant(int(16))), 0x01));

                  ir_variable *const r186F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r186F, bit_and(r1833, body.constant(65535u)), 0x01));

                  ir_variable *const r1870 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1870, rshift(r1833, body.constant(int(16))), 0x01));

                  ir_variable *const r1871 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1871, mul(r186E, r186F), 0x01));

                  ir_expression *const r1872 = mul(r186D, r1870);
                  body.emit(assign(r186B, add(r1872, r1871), 0x01));

                  ir_expression *const r1873 = mul(r186E, r1870);
                  ir_expression *const r1874 = less(r186B, r1871);
                  ir_expression *const r1875 = expr(ir_unop_b2i, r1874);
                  ir_expression *const r1876 = expr(ir_unop_i2u, r1875);
                  ir_expression *const r1877 = lshift(r1876, body.constant(int(16)));
                  ir_expression *const r1878 = rshift(r186B, body.constant(int(16)));
                  ir_expression *const r1879 = add(r1877, r1878);
                  body.emit(assign(r186A, add(r1873, r1879), 0x01));

                  body.emit(assign(r186B, lshift(r186B, body.constant(int(16))), 0x01));

                  ir_expression *const r187A = mul(r186D, r186F);
                  body.emit(assign(r186C, add(r187A, r186B), 0x01));

                  ir_expression *const r187B = less(r186C, r186B);
                  ir_expression *const r187C = expr(ir_unop_b2i, r187B);
                  ir_expression *const r187D = expr(ir_unop_i2u, r187C);
                  body.emit(assign(r186A, add(r186A, r187D), 0x01));

                  ir_variable *const r187E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r187E);
                  ir_variable *const r187F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r187F);
                  ir_variable *const r1880 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1880);
                  ir_variable *const r1881 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1881, bit_and(r17A9, body.constant(65535u)), 0x01));

                  ir_variable *const r1882 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1882, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r1883 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1883, bit_and(r1833, body.constant(65535u)), 0x01));

                  ir_variable *const r1884 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1884, rshift(r1833, body.constant(int(16))), 0x01));

                  ir_variable *const r1885 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1885, mul(r1882, r1883), 0x01));

                  ir_expression *const r1886 = mul(r1881, r1884);
                  body.emit(assign(r187F, add(r1886, r1885), 0x01));

                  ir_expression *const r1887 = mul(r1882, r1884);
                  ir_expression *const r1888 = less(r187F, r1885);
                  ir_expression *const r1889 = expr(ir_unop_b2i, r1888);
                  ir_expression *const r188A = expr(ir_unop_i2u, r1889);
                  ir_expression *const r188B = lshift(r188A, body.constant(int(16)));
                  ir_expression *const r188C = rshift(r187F, body.constant(int(16)));
                  ir_expression *const r188D = add(r188B, r188C);
                  body.emit(assign(r187E, add(r1887, r188D), 0x01));

                  body.emit(assign(r187F, lshift(r187F, body.constant(int(16))), 0x01));

                  ir_expression *const r188E = mul(r1881, r1883);
                  body.emit(assign(r1880, add(r188E, r187F), 0x01));

                  ir_expression *const r188F = less(r1880, r187F);
                  ir_expression *const r1890 = expr(ir_unop_b2i, r188F);
                  ir_expression *const r1891 = expr(ir_unop_i2u, r1890);
                  body.emit(assign(r187E, add(r187E, r1891), 0x01));

                  ir_variable *const r1892 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1892, add(r1880, r186A), 0x01));

                  ir_variable *const r1893 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1893);
                  ir_variable *const r1894 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r1895 = less(body.constant(0u), r186C);
                  ir_expression *const r1896 = expr(ir_unop_b2i, r1895);
                  body.emit(assign(r1894, expr(ir_unop_i2u, r1896), 0x01));

                  ir_variable *const r1897 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1897, sub(r169D, r1892), 0x01));

                  ir_expression *const r1898 = less(r1892, r1880);
                  ir_expression *const r1899 = expr(ir_unop_b2i, r1898);
                  ir_expression *const r189A = expr(ir_unop_i2u, r1899);
                  ir_expression *const r189B = add(r187E, r189A);
                  ir_expression *const r189C = sub(r169E, r189B);
                  ir_expression *const r189D = less(r1897, r1894);
                  ir_expression *const r189E = expr(ir_unop_b2i, r189D);
                  ir_expression *const r189F = expr(ir_unop_i2u, r189E);
                  body.emit(assign(r1893, sub(r189C, r189F), 0x01));

                  ir_expression *const r18A0 = less(r169D, r1892);
                  ir_expression *const r18A1 = expr(ir_unop_b2i, r18A0);
                  ir_expression *const r18A2 = expr(ir_unop_i2u, r18A1);
                  body.emit(assign(r1893, sub(r1893, r18A2), 0x01));

                  body.emit(assign(r169E, r1893, 0x01));

                  body.emit(assign(r169D, sub(r1897, r1894), 0x01));

                  body.emit(assign(r169C, neg(r186C), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f18A3 = new(mem_ctx) ir_loop();
                  exec_list *const f18A3_parent_instructions = body.instructions;

                     body.instructions = &f18A3->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18A5 = expr(ir_unop_u2i, r169E);
                     ir_expression *const r18A6 = gequal(r18A5, body.constant(int(0)));
                     ir_if *f18A4 = new(mem_ctx) ir_if(operand(r18A6).val);
                     exec_list *const f18A4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18A4->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f18A4_parent_instructions;
                     body.emit(f18A4);

                     /* END IF */

                     body.emit(assign(r16A0, add(r16A0, body.constant(4294967295u)), 0x01));

                     ir_variable *const r18A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r18A7);
                     ir_variable *const r18A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r18A8);
                     ir_variable *const r18A9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18A9, add(r169C, r17A8), 0x01));

                     ir_variable *const r18AA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r18AB = less(r18A9, r169C);
                     ir_expression *const r18AC = expr(ir_unop_b2i, r18AB);
                     body.emit(assign(r18AA, expr(ir_unop_i2u, r18AC), 0x01));

                     ir_variable *const r18AD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18AD, add(r169D, r17A9), 0x01));

                     body.emit(assign(r18A8, add(r18AD, r18AA), 0x01));

                     ir_expression *const r18AE = less(r18A8, r18AA);
                     ir_expression *const r18AF = expr(ir_unop_b2i, r18AE);
                     ir_expression *const r18B0 = expr(ir_unop_i2u, r18AF);
                     body.emit(assign(r18A7, add(r169E, r18B0), 0x01));

                     ir_expression *const r18B1 = less(r18AD, r169D);
                     ir_expression *const r18B2 = expr(ir_unop_b2i, r18B1);
                     ir_expression *const r18B3 = expr(ir_unop_i2u, r18B2);
                     body.emit(assign(r18A7, add(r18A7, r18B3), 0x01));

                     body.emit(assign(r169E, r18A7, 0x01));

                     body.emit(assign(r169D, r18A8, 0x01));

                     body.emit(assign(r169C, r18A9, 0x01));

                  /* LOOP END */

                  body.instructions = f18A3_parent_instructions;
                  body.emit(f18A3);

                  ir_expression *const r18B4 = bit_or(r169E, r169D);
                  ir_expression *const r18B5 = bit_or(r18B4, r169C);
                  ir_expression *const r18B6 = nequal(r18B5, body.constant(0u));
                  ir_expression *const r18B7 = expr(ir_unop_b2i, r18B6);
                  ir_expression *const r18B8 = expr(ir_unop_i2u, r18B7);
                  body.emit(assign(r16A0, bit_or(r16A0, r18B8), 0x01));


               body.instructions = f1867_parent_instructions;
               body.emit(f1867);

               /* END IF */

               ir_variable *const r18B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r18B9);
               ir_variable *const r18BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r18BA);
               ir_variable *const r18BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r18BB);
               body.emit(assign(r18B9, lshift(r16A0, body.constant(int(21))), 0x01));

               ir_expression *const r18BC = lshift(r16A1, body.constant(int(21)));
               ir_expression *const r18BD = rshift(r16A0, body.constant(int(11)));
               body.emit(assign(r18BA, bit_or(r18BC, r18BD), 0x01));

               body.emit(assign(r18BB, rshift(r16A1, body.constant(int(11))), 0x01));

               body.emit(assign(r18B9, bit_or(r18B9, body.constant(0u)), 0x01));

               body.emit(assign(r16A1, r18BB, 0x01));

               body.emit(assign(r16A0, r18BA, 0x01));

               ir_variable *const r18BE = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r18BE, r16A2, 0x01));

               ir_variable *const r18BF = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r18BF, r18BB, 0x01));

               ir_variable *const r18C0 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r18C0, r18BA, 0x01));

               ir_variable *const r18C1 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r18C1, r18B9, 0x01));

               ir_variable *const r18C2 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r18C2, body.constant(true), 0x01));

               ir_variable *const r18C3 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r18C4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r18C4);
               ir_expression *const r18C5 = expr(ir_unop_u2i, r18B9);
               body.emit(assign(r18C4, less(r18C5, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r18C7 = lequal(body.constant(int(2045)), r16A2);
               ir_if *f18C6 = new(mem_ctx) ir_if(operand(r18C7).val);
               exec_list *const f18C6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18C6->then_instructions;

                  ir_variable *const r18C8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r18CA = less(body.constant(int(2045)), r16A2);
                  ir_if *f18C9 = new(mem_ctx) ir_if(operand(r18CA).val);
                  exec_list *const f18C9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18C9->then_instructions;

                     body.emit(assign(r18C8, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18C9->else_instructions;

                     ir_variable *const r18CB = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r18CD = equal(r16A2, body.constant(int(2045)));
                     ir_if *f18CC = new(mem_ctx) ir_if(operand(r18CD).val);
                     exec_list *const f18CC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18CC->then_instructions;

                        ir_expression *const r18CE = equal(body.constant(2097151u), r18BB);
                        ir_expression *const r18CF = equal(body.constant(4294967295u), r18BA);
                        body.emit(assign(r18CB, logic_and(r18CE, r18CF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f18CC->else_instructions;

                        body.emit(assign(r18CB, body.constant(false), 0x01));


                     body.instructions = f18CC_parent_instructions;
                     body.emit(f18CC);

                     /* END IF */

                     body.emit(assign(r18C8, logic_and(r18CB, r18C4), 0x01));


                  body.instructions = f18C9_parent_instructions;
                  body.emit(f18C9);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f18D0 = new(mem_ctx) ir_if(operand(r18C8).val);
                  exec_list *const f18D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18D0->then_instructions;

                     ir_variable *const r18D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r18D1);
                     ir_expression *const r18D2 = lshift(r1695, body.constant(int(31)));
                     body.emit(assign(r18D1, add(r18D2, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r18D1, body.constant(0u), 0x01));

                     body.emit(assign(r18C3, r18D1, 0x03));

                     body.emit(assign(r18C2, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18D0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18D4 = less(r16A2, body.constant(int(0)));
                     ir_if *f18D3 = new(mem_ctx) ir_if(operand(r18D4).val);
                     exec_list *const f18D3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18D3->then_instructions;

                        ir_variable *const r18D5 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r18D5, r18B9, 0x01));

                        ir_variable *const r18D6 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r18D6, neg(r16A2), 0x01));

                        ir_variable *const r18D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r18D7);
                        ir_variable *const r18D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r18D8);
                        ir_variable *const r18D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r18D9);
                        ir_variable *const r18DA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r18DB = neg(r18D6);
                        body.emit(assign(r18DA, bit_and(r18DB, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r18DD = equal(r18D6, body.constant(int(0)));
                        ir_if *f18DC = new(mem_ctx) ir_if(operand(r18DD).val);
                        exec_list *const f18DC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f18DC->then_instructions;

                           body.emit(assign(r18D7, r18B9, 0x01));

                           body.emit(assign(r18D8, r18BA, 0x01));

                           body.emit(assign(r18D9, r18BB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f18DC->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r18DF = less(r18D6, body.constant(int(32)));
                           ir_if *f18DE = new(mem_ctx) ir_if(operand(r18DF).val);
                           exec_list *const f18DE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f18DE->then_instructions;

                              body.emit(assign(r18D7, lshift(r18BA, r18DA), 0x01));

                              ir_expression *const r18E0 = lshift(r18BB, r18DA);
                              ir_expression *const r18E1 = rshift(r18BA, r18D6);
                              body.emit(assign(r18D8, bit_or(r18E0, r18E1), 0x01));

                              body.emit(assign(r18D9, rshift(r18BB, r18D6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f18DE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r18E3 = equal(r18D6, body.constant(int(32)));
                              ir_if *f18E2 = new(mem_ctx) ir_if(operand(r18E3).val);
                              exec_list *const f18E2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18E2->then_instructions;

                                 body.emit(assign(r18D7, r18BA, 0x01));

                                 body.emit(assign(r18D8, r18BB, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f18E2->else_instructions;

                                 body.emit(assign(r18D5, bit_or(r18B9, r18BA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r18E5 = less(r18D6, body.constant(int(64)));
                                 ir_if *f18E4 = new(mem_ctx) ir_if(operand(r18E5).val);
                                 exec_list *const f18E4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f18E4->then_instructions;

                                    body.emit(assign(r18D7, lshift(r18BB, r18DA), 0x01));

                                    ir_expression *const r18E6 = bit_and(r18D6, body.constant(int(31)));
                                    body.emit(assign(r18D8, rshift(r18BB, r18E6), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f18E4->else_instructions;

                                    ir_variable *const r18E7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r18E9 = equal(r18D6, body.constant(int(64)));
                                    ir_if *f18E8 = new(mem_ctx) ir_if(operand(r18E9).val);
                                    exec_list *const f18E8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f18E8->then_instructions;

                                       body.emit(assign(r18E7, r18BB, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f18E8->else_instructions;

                                       ir_expression *const r18EA = nequal(r18BB, body.constant(0u));
                                       ir_expression *const r18EB = expr(ir_unop_b2i, r18EA);
                                       body.emit(assign(r18E7, expr(ir_unop_i2u, r18EB), 0x01));


                                    body.instructions = f18E8_parent_instructions;
                                    body.emit(f18E8);

                                    /* END IF */

                                    body.emit(assign(r18D7, r18E7, 0x01));

                                    body.emit(assign(r18D8, body.constant(0u), 0x01));


                                 body.instructions = f18E4_parent_instructions;
                                 body.emit(f18E4);

                                 /* END IF */


                              body.instructions = f18E2_parent_instructions;
                              body.emit(f18E2);

                              /* END IF */

                              body.emit(assign(r18D9, body.constant(0u), 0x01));


                           body.instructions = f18DE_parent_instructions;
                           body.emit(f18DE);

                           /* END IF */

                           ir_expression *const r18EC = nequal(r18D5, body.constant(0u));
                           ir_expression *const r18ED = expr(ir_unop_b2i, r18EC);
                           ir_expression *const r18EE = expr(ir_unop_i2u, r18ED);
                           body.emit(assign(r18D7, bit_or(r18D7, r18EE), 0x01));


                        body.instructions = f18DC_parent_instructions;
                        body.emit(f18DC);

                        /* END IF */

                        body.emit(assign(r18BF, r18D9, 0x01));

                        body.emit(assign(r18C0, r18D8, 0x01));

                        body.emit(assign(r18C1, r18D7, 0x01));

                        body.emit(assign(r18BE, body.constant(int(0)), 0x01));

                        body.emit(assign(r18C4, less(r18D7, body.constant(0u)), 0x01));


                     body.instructions = f18D3_parent_instructions;
                     body.emit(f18D3);

                     /* END IF */


                  body.instructions = f18D0_parent_instructions;
                  body.emit(f18D0);

                  /* END IF */


               body.instructions = f18C6_parent_instructions;
               body.emit(f18C6);

               /* END IF */

               /* IF CONDITION */
               ir_if *f18EF = new(mem_ctx) ir_if(operand(r18C2).val);
               exec_list *const f18EF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18EF->then_instructions;

                  /* IF CONDITION */
                  ir_if *f18F0 = new(mem_ctx) ir_if(operand(r18C4).val);
                  exec_list *const f18F0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18F0->then_instructions;

                     ir_variable *const r18F1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18F1, add(r18C0, body.constant(1u)), 0x01));

                     ir_expression *const r18F2 = less(r18F1, r18C0);
                     ir_expression *const r18F3 = expr(ir_unop_b2i, r18F2);
                     ir_expression *const r18F4 = expr(ir_unop_i2u, r18F3);
                     body.emit(assign(r18BF, add(r18BF, r18F4), 0x01));

                     ir_expression *const r18F5 = equal(r18C1, body.constant(0u));
                     ir_expression *const r18F6 = expr(ir_unop_b2i, r18F5);
                     ir_expression *const r18F7 = expr(ir_unop_i2u, r18F6);
                     ir_expression *const r18F8 = add(r18C1, r18F7);
                     ir_expression *const r18F9 = bit_and(r18F8, body.constant(1u));
                     ir_expression *const r18FA = expr(ir_unop_bit_not, r18F9);
                     body.emit(assign(r18C0, bit_and(r18F1, r18FA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18F0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18FC = bit_or(r18BF, r18C0);
                     ir_expression *const r18FD = equal(r18FC, body.constant(0u));
                     ir_if *f18FB = new(mem_ctx) ir_if(operand(r18FD).val);
                     exec_list *const f18FB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18FB->then_instructions;

                        body.emit(assign(r18BE, body.constant(int(0)), 0x01));


                     body.instructions = f18FB_parent_instructions;
                     body.emit(f18FB);

                     /* END IF */


                  body.instructions = f18F0_parent_instructions;
                  body.emit(f18F0);

                  /* END IF */

                  ir_variable *const r18FE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r18FE);
                  ir_expression *const r18FF = lshift(r1695, body.constant(int(31)));
                  ir_expression *const r1900 = expr(ir_unop_i2u, r18BE);
                  ir_expression *const r1901 = lshift(r1900, body.constant(int(20)));
                  ir_expression *const r1902 = add(r18FF, r1901);
                  body.emit(assign(r18FE, add(r1902, r18BF), 0x02));

                  body.emit(assign(r18FE, r18C0, 0x01));

                  body.emit(assign(r18C3, r18FE, 0x03));

                  body.emit(assign(r18C2, body.constant(false), 0x01));


               body.instructions = f18EF_parent_instructions;
               body.emit(f18EF);

               /* END IF */

               body.emit(assign(r1694, r18C3, 0x03));

               body.emit(assign(r1693, body.constant(false), 0x01));


            body.instructions = f17A1_parent_instructions;
            body.emit(f17A1);

            /* END IF */


         body.instructions = f1760_parent_instructions;
         body.emit(f1760);

         /* END IF */


      body.instructions = f16F6_parent_instructions;
      body.emit(f16F6);

      /* END IF */


   body.instructions = f16AF_parent_instructions;
   body.emit(f16AF);

   /* END IF */

   body.emit(ret(r1694));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat32Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1903 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_function_in);
   sig_parameters.push_tail(r1903);
   ir_variable *const r1904 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1904);
   ir_variable *const r1905 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFracPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1905);
   ir_variable *const r1906 = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r1906, r1903, 0x01));

   ir_variable *const r1907 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r1908 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r1908);
   /* IF CONDITION */
   ir_expression *const r190A = equal(r1903, body.constant(0u));
   ir_if *f1909 = new(mem_ctx) ir_if(operand(r190A).val);
   exec_list *const f1909_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1909->then_instructions;

      body.emit(assign(r1907, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1909->else_instructions;

      body.emit(assign(r1908, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r190C = bit_and(r1903, body.constant(4294901760u));
      ir_expression *const r190D = equal(r190C, body.constant(0u));
      ir_if *f190B = new(mem_ctx) ir_if(operand(r190D).val);
      exec_list *const f190B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f190B->then_instructions;

         body.emit(assign(r1908, body.constant(int(16)), 0x01));

         body.emit(assign(r1906, lshift(r1903, body.constant(int(16))), 0x01));


      body.instructions = f190B_parent_instructions;
      body.emit(f190B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r190F = bit_and(r1906, body.constant(4278190080u));
      ir_expression *const r1910 = equal(r190F, body.constant(0u));
      ir_if *f190E = new(mem_ctx) ir_if(operand(r1910).val);
      exec_list *const f190E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f190E->then_instructions;

         body.emit(assign(r1908, add(r1908, body.constant(int(8))), 0x01));

         body.emit(assign(r1906, lshift(r1906, body.constant(int(8))), 0x01));


      body.instructions = f190E_parent_instructions;
      body.emit(f190E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1912 = bit_and(r1906, body.constant(4026531840u));
      ir_expression *const r1913 = equal(r1912, body.constant(0u));
      ir_if *f1911 = new(mem_ctx) ir_if(operand(r1913).val);
      exec_list *const f1911_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1911->then_instructions;

         body.emit(assign(r1908, add(r1908, body.constant(int(4))), 0x01));

         body.emit(assign(r1906, lshift(r1906, body.constant(int(4))), 0x01));


      body.instructions = f1911_parent_instructions;
      body.emit(f1911);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1915 = bit_and(r1906, body.constant(3221225472u));
      ir_expression *const r1916 = equal(r1915, body.constant(0u));
      ir_if *f1914 = new(mem_ctx) ir_if(operand(r1916).val);
      exec_list *const f1914_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1914->then_instructions;

         body.emit(assign(r1908, add(r1908, body.constant(int(2))), 0x01));

         body.emit(assign(r1906, lshift(r1906, body.constant(int(2))), 0x01));


      body.instructions = f1914_parent_instructions;
      body.emit(f1914);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1918 = bit_and(r1906, body.constant(2147483648u));
      ir_expression *const r1919 = equal(r1918, body.constant(0u));
      ir_if *f1917 = new(mem_ctx) ir_if(operand(r1919).val);
      exec_list *const f1917_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1917->then_instructions;

         body.emit(assign(r1908, add(r1908, body.constant(int(1))), 0x01));


      body.instructions = f1917_parent_instructions;
      body.emit(f1917);

      /* END IF */

      body.emit(assign(r1907, r1908, 0x01));


   body.instructions = f1909_parent_instructions;
   body.emit(f1909);

   /* END IF */

   ir_variable *const r191A = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r191A, add(r1907, body.constant(int(-8))), 0x01));

   body.emit(assign(r1905, lshift(r1903, r191A), 0x01));

   body.emit(assign(r1904, sub(body.constant(int(1)), r191A), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Frac(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r191B = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r191B);
   ir_expression *const r191C = bit_and(r191B, body.constant(8388607u));
   body.emit(ret(r191C));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r191D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r191D);
   ir_expression *const r191E = rshift(r191D, body.constant(int(23)));
   ir_expression *const r191F = bit_and(r191E, body.constant(255u));
   ir_expression *const r1920 = expr(ir_unop_u2i, r191F);
   body.emit(ret(r1920));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1921);
   ir_expression *const r1922 = rshift(r1921, body.constant(int(31)));
   body.emit(ret(r1922));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp32_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1923 = new(mem_ctx) ir_variable(glsl_type::float_type, "f", ir_var_function_in);
   sig_parameters.push_tail(r1923);
   ir_variable *const r1924 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1924, body.constant(true), 0x01));

   ir_variable *const r1925 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1926 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r1926);
   ir_variable *const r1927 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r1927);
   ir_variable *const r1928 = body.make_temp(glsl_type::uint_type, "floatBitsToUint_retval");
   body.emit(assign(r1928, expr(ir_unop_bitcast_f2u, r1923), 0x01));

   ir_variable *const r1929 = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r1929, bit_and(r1928, body.constant(8388607u)), 0x01));

   body.emit(assign(r1927, r1929, 0x01));

   ir_variable *const r192A = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r192B = rshift(r1928, body.constant(int(23)));
   ir_expression *const r192C = bit_and(r192B, body.constant(255u));
   body.emit(assign(r192A, expr(ir_unop_u2i, r192C), 0x01));

   body.emit(assign(r1926, r192A, 0x01));

   ir_variable *const r192D = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r192D, rshift(r1928, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r192F = equal(r192A, body.constant(int(255)));
   ir_if *f192E = new(mem_ctx) ir_if(operand(r192F).val);
   exec_list *const f192E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f192E->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1931 = nequal(r1929, body.constant(0u));
      ir_if *f1930 = new(mem_ctx) ir_if(operand(r1931).val);
      exec_list *const f1930_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1930->then_instructions;

         ir_variable *const r1932 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1932, lshift(r1928, body.constant(int(9))), 0x01));

         ir_variable *const r1933 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         ir_expression *const r1934 = lshift(r1932, body.constant(int(20)));
         body.emit(assign(r1933, bit_or(r1934, body.constant(0u)), 0x01));

         ir_expression *const r1935 = rshift(r1932, body.constant(int(12)));
         ir_expression *const r1936 = lshift(r192D, body.constant(int(31)));
         ir_expression *const r1937 = bit_or(r1936, body.constant(2146959360u));
         body.emit(assign(r1933, bit_or(r1935, r1937), 0x02));

         body.emit(assign(r1925, r1933, 0x03));

         body.emit(assign(r1924, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1930->else_instructions;

         ir_variable *const r1938 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1938);
         ir_expression *const r1939 = lshift(r192D, body.constant(int(31)));
         body.emit(assign(r1938, add(r1939, body.constant(2146435072u)), 0x02));

         body.emit(assign(r1938, body.constant(0u), 0x01));

         body.emit(assign(r1925, r1938, 0x03));

         body.emit(assign(r1924, body.constant(false), 0x01));


      body.instructions = f1930_parent_instructions;
      body.emit(f1930);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f192E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r193B = equal(r192A, body.constant(int(0)));
      ir_if *f193A = new(mem_ctx) ir_if(operand(r193B).val);
      exec_list *const f193A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f193A->then_instructions;

         /* IF CONDITION */
         ir_expression *const r193D = equal(r1929, body.constant(0u));
         ir_if *f193C = new(mem_ctx) ir_if(operand(r193D).val);
         exec_list *const f193C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f193C->then_instructions;

            ir_variable *const r193E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r193E);
            body.emit(assign(r193E, lshift(r192D, body.constant(int(31))), 0x02));

            body.emit(assign(r193E, body.constant(0u), 0x01));

            body.emit(assign(r1925, r193E, 0x03));

            body.emit(assign(r1924, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f193C->else_instructions;

            ir_variable *const r193F = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r193F, r192A, 0x01));

            ir_variable *const r1940 = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r1940, r1929, 0x01));

            ir_variable *const r1941 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r1941, r1929, 0x01));

            ir_variable *const r1942 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r1943 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r1943);
            /* IF CONDITION */
            ir_expression *const r1945 = equal(r1929, body.constant(0u));
            ir_if *f1944 = new(mem_ctx) ir_if(operand(r1945).val);
            exec_list *const f1944_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1944->then_instructions;

               body.emit(assign(r1942, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1944->else_instructions;

               body.emit(assign(r1943, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r1947 = bit_and(r1929, body.constant(4294901760u));
               ir_expression *const r1948 = equal(r1947, body.constant(0u));
               ir_if *f1946 = new(mem_ctx) ir_if(operand(r1948).val);
               exec_list *const f1946_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1946->then_instructions;

                  body.emit(assign(r1943, body.constant(int(16)), 0x01));

                  body.emit(assign(r1941, lshift(r1929, body.constant(int(16))), 0x01));


               body.instructions = f1946_parent_instructions;
               body.emit(f1946);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r194A = bit_and(r1941, body.constant(4278190080u));
               ir_expression *const r194B = equal(r194A, body.constant(0u));
               ir_if *f1949 = new(mem_ctx) ir_if(operand(r194B).val);
               exec_list *const f1949_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1949->then_instructions;

                  body.emit(assign(r1943, add(r1943, body.constant(int(8))), 0x01));

                  body.emit(assign(r1941, lshift(r1941, body.constant(int(8))), 0x01));


               body.instructions = f1949_parent_instructions;
               body.emit(f1949);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r194D = bit_and(r1941, body.constant(4026531840u));
               ir_expression *const r194E = equal(r194D, body.constant(0u));
               ir_if *f194C = new(mem_ctx) ir_if(operand(r194E).val);
               exec_list *const f194C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f194C->then_instructions;

                  body.emit(assign(r1943, add(r1943, body.constant(int(4))), 0x01));

                  body.emit(assign(r1941, lshift(r1941, body.constant(int(4))), 0x01));


               body.instructions = f194C_parent_instructions;
               body.emit(f194C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1950 = bit_and(r1941, body.constant(3221225472u));
               ir_expression *const r1951 = equal(r1950, body.constant(0u));
               ir_if *f194F = new(mem_ctx) ir_if(operand(r1951).val);
               exec_list *const f194F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f194F->then_instructions;

                  body.emit(assign(r1943, add(r1943, body.constant(int(2))), 0x01));

                  body.emit(assign(r1941, lshift(r1941, body.constant(int(2))), 0x01));


               body.instructions = f194F_parent_instructions;
               body.emit(f194F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1953 = bit_and(r1941, body.constant(2147483648u));
               ir_expression *const r1954 = equal(r1953, body.constant(0u));
               ir_if *f1952 = new(mem_ctx) ir_if(operand(r1954).val);
               exec_list *const f1952_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1952->then_instructions;

                  body.emit(assign(r1943, add(r1943, body.constant(int(1))), 0x01));


               body.instructions = f1952_parent_instructions;
               body.emit(f1952);

               /* END IF */

               body.emit(assign(r1942, r1943, 0x01));


            body.instructions = f1944_parent_instructions;
            body.emit(f1944);

            /* END IF */

            ir_variable *const r1955 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r1955, add(r1942, body.constant(int(-8))), 0x01));

            body.emit(assign(r1940, lshift(r1929, r1955), 0x01));

            body.emit(assign(r193F, sub(body.constant(int(1)), r1955), 0x01));

            body.emit(assign(r1927, r1940, 0x01));

            body.emit(assign(r1926, add(r193F, body.constant(int(-1))), 0x01));


         body.instructions = f193C_parent_instructions;
         body.emit(f193C);

         /* END IF */


      body.instructions = f193A_parent_instructions;
      body.emit(f193A);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1956 = new(mem_ctx) ir_if(operand(r1924).val);
      exec_list *const f1956_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1956->then_instructions;

         ir_variable *const r1957 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1957);
         ir_expression *const r1958 = lshift(r192D, body.constant(int(31)));
         ir_expression *const r1959 = add(r1926, body.constant(int(896)));
         ir_expression *const r195A = expr(ir_unop_i2u, r1959);
         ir_expression *const r195B = lshift(r195A, body.constant(int(20)));
         ir_expression *const r195C = add(r1958, r195B);
         ir_expression *const r195D = rshift(r1927, body.constant(int(3)));
         body.emit(assign(r1957, add(r195C, r195D), 0x02));

         ir_expression *const r195E = lshift(r1927, body.constant(int(29)));
         body.emit(assign(r1957, bit_or(r195E, body.constant(0u)), 0x01));

         body.emit(assign(r1925, r1957, 0x03));

         body.emit(assign(r1924, body.constant(false), 0x01));


      body.instructions = f1956_parent_instructions;
      body.emit(f1956);

      /* END IF */


   body.instructions = f192E_parent_instructions;
   body.emit(f192E);

   /* END IF */

   body.emit(ret(r1925));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r195F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r195F);
   ir_variable *const r1960 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r1960);
   ir_variable *const r1961 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r1961);
   ir_expression *const r1962 = lshift(r195F, body.constant(int(31)));
   ir_expression *const r1963 = expr(ir_unop_i2u, r1960);
   ir_expression *const r1964 = lshift(r1963, body.constant(int(23)));
   ir_expression *const r1965 = add(r1962, r1964);
   ir_expression *const r1966 = add(r1965, r1961);
   body.emit(ret(r1966));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift32RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1967 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1967);
   ir_variable *const r1968 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1968);
   ir_variable *const r1969 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1969);
   ir_variable *const r196A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r196A);
   /* IF CONDITION */
   ir_expression *const r196C = equal(r1968, body.constant(int(0)));
   ir_if *f196B = new(mem_ctx) ir_if(operand(r196C).val);
   exec_list *const f196B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f196B->then_instructions;

      body.emit(assign(r196A, r1967, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f196B->else_instructions;

      /* IF CONDITION */
      ir_expression *const r196E = less(r1968, body.constant(int(32)));
      ir_if *f196D = new(mem_ctx) ir_if(operand(r196E).val);
      exec_list *const f196D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f196D->then_instructions;

         ir_expression *const r196F = rshift(r1967, r1968);
         ir_expression *const r1970 = neg(r1968);
         ir_expression *const r1971 = bit_and(r1970, body.constant(int(31)));
         ir_expression *const r1972 = lshift(r1967, r1971);
         ir_expression *const r1973 = nequal(r1972, body.constant(0u));
         ir_expression *const r1974 = expr(ir_unop_b2i, r1973);
         ir_expression *const r1975 = expr(ir_unop_i2u, r1974);
         body.emit(assign(r196A, bit_or(r196F, r1975), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f196D->else_instructions;

         ir_expression *const r1976 = nequal(r1967, body.constant(0u));
         ir_expression *const r1977 = expr(ir_unop_b2i, r1976);
         body.emit(assign(r196A, expr(ir_unop_i2u, r1977), 0x01));


      body.instructions = f196D_parent_instructions;
      body.emit(f196D);

      /* END IF */


   body.instructions = f196B_parent_instructions;
   body.emit(f196B);

   /* END IF */

   body.emit(assign(r1969, r196A, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1978 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r1978);
   ir_variable *const r1979 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r1979);
   ir_variable *const r197A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r197A);
   ir_variable *const r197B = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r197B, body.constant(true), 0x01));

   ir_variable *const r197C = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r197D = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
   body.emit(r197D);
   ir_expression *const r197E = expr(ir_unop_u2i, r197A);
   body.emit(assign(r197D, bit_and(r197E, body.constant(int(127))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1980 = expr(ir_unop_i2u, r1979);
   ir_expression *const r1981 = lequal(body.constant(253u), r1980);
   ir_if *f197F = new(mem_ctx) ir_if(operand(r1981).val);
   exec_list *const f197F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f197F->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1983 = less(body.constant(int(253)), r1979);
      ir_expression *const r1984 = equal(r1979, body.constant(int(253)));
      ir_expression *const r1985 = add(r197A, body.constant(64u));
      ir_expression *const r1986 = expr(ir_unop_u2i, r1985);
      ir_expression *const r1987 = less(r1986, body.constant(int(0)));
      ir_expression *const r1988 = logic_and(r1984, r1987);
      ir_expression *const r1989 = logic_or(r1983, r1988);
      ir_if *f1982 = new(mem_ctx) ir_if(operand(r1989).val);
      exec_list *const f1982_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1982->then_instructions;

         ir_expression *const r198A = lshift(r1978, body.constant(int(31)));
         body.emit(assign(r197C, add(r198A, body.constant(2139095040u)), 0x01));

         body.emit(assign(r197B, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1982->else_instructions;

         /* IF CONDITION */
         ir_expression *const r198C = less(r1979, body.constant(int(0)));
         ir_if *f198B = new(mem_ctx) ir_if(operand(r198C).val);
         exec_list *const f198B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f198B->then_instructions;

            ir_variable *const r198D = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r198D, neg(r1979), 0x01));

            ir_variable *const r198E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
            body.emit(r198E);
            /* IF CONDITION */
            ir_expression *const r1990 = equal(r198D, body.constant(int(0)));
            ir_if *f198F = new(mem_ctx) ir_if(operand(r1990).val);
            exec_list *const f198F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f198F->then_instructions;

               body.emit(assign(r198E, r197A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f198F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1992 = less(r198D, body.constant(int(32)));
               ir_if *f1991 = new(mem_ctx) ir_if(operand(r1992).val);
               exec_list *const f1991_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1991->then_instructions;

                  ir_expression *const r1993 = rshift(r197A, r198D);
                  ir_expression *const r1994 = neg(r198D);
                  ir_expression *const r1995 = bit_and(r1994, body.constant(int(31)));
                  ir_expression *const r1996 = lshift(r197A, r1995);
                  ir_expression *const r1997 = nequal(r1996, body.constant(0u));
                  ir_expression *const r1998 = expr(ir_unop_b2i, r1997);
                  ir_expression *const r1999 = expr(ir_unop_i2u, r1998);
                  body.emit(assign(r198E, bit_or(r1993, r1999), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1991->else_instructions;

                  ir_expression *const r199A = nequal(r197A, body.constant(0u));
                  ir_expression *const r199B = expr(ir_unop_b2i, r199A);
                  body.emit(assign(r198E, expr(ir_unop_i2u, r199B), 0x01));


               body.instructions = f1991_parent_instructions;
               body.emit(f1991);

               /* END IF */


            body.instructions = f198F_parent_instructions;
            body.emit(f198F);

            /* END IF */

            body.emit(assign(r197A, r198E, 0x01));

            body.emit(assign(r1979, body.constant(int(0)), 0x01));

            ir_expression *const r199C = expr(ir_unop_u2i, r198E);
            body.emit(assign(r197D, bit_and(r199C, body.constant(int(127))), 0x01));


         body.instructions = f198B_parent_instructions;
         body.emit(f198B);

         /* END IF */


      body.instructions = f1982_parent_instructions;
      body.emit(f1982);

      /* END IF */


   body.instructions = f197F_parent_instructions;
   body.emit(f197F);

   /* END IF */

   /* IF CONDITION */
   ir_if *f199D = new(mem_ctx) ir_if(operand(r197B).val);
   exec_list *const f199D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f199D->then_instructions;

      ir_expression *const r199E = add(r197A, body.constant(64u));
      body.emit(assign(r197A, rshift(r199E, body.constant(int(7))), 0x01));

      ir_expression *const r199F = bit_xor(r197D, body.constant(int(64)));
      ir_expression *const r19A0 = equal(r199F, body.constant(int(0)));
      ir_expression *const r19A1 = expr(ir_unop_b2i, r19A0);
      ir_expression *const r19A2 = expr(ir_unop_i2u, r19A1);
      ir_expression *const r19A3 = bit_and(r19A2, body.constant(1u));
      ir_expression *const r19A4 = expr(ir_unop_bit_not, r19A3);
      body.emit(assign(r197A, bit_and(r197A, r19A4), 0x01));

      /* IF CONDITION */
      ir_expression *const r19A6 = equal(r197A, body.constant(0u));
      ir_if *f19A5 = new(mem_ctx) ir_if(operand(r19A6).val);
      exec_list *const f19A5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19A5->then_instructions;

         body.emit(assign(r1979, body.constant(int(0)), 0x01));


      body.instructions = f19A5_parent_instructions;
      body.emit(f19A5);

      /* END IF */

      ir_expression *const r19A7 = lshift(r1978, body.constant(int(31)));
      ir_expression *const r19A8 = expr(ir_unop_i2u, r1979);
      ir_expression *const r19A9 = lshift(r19A8, body.constant(int(23)));
      ir_expression *const r19AA = add(r19A7, r19A9);
      body.emit(assign(r197C, add(r19AA, r197A), 0x01));

      body.emit(assign(r197B, body.constant(false), 0x01));


   body.instructions = f199D_parent_instructions;
   body.emit(f199D);

   /* END IF */

   body.emit(ret(r197C));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_fp32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r19AB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r19AB);
   ir_variable *const r19AC = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r19AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r19AD);
   body.emit(assign(r19AD, body.constant(0u), 0x01));

   ir_variable *const r19AE = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r19AE, swizzle_x(r19AB), 0x01));

   ir_variable *const r19AF = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r19AF, bit_and(swizzle_y(r19AB), body.constant(1048575u)), 0x01));

   ir_variable *const r19B0 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r19B1 = rshift(swizzle_y(r19AB), body.constant(int(20)));
   ir_expression *const r19B2 = bit_and(r19B1, body.constant(2047u));
   body.emit(assign(r19B0, expr(ir_unop_u2i, r19B2), 0x01));

   ir_variable *const r19B3 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r19B3, rshift(swizzle_y(r19AB), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r19B5 = equal(r19B0, body.constant(int(2047)));
   ir_if *f19B4 = new(mem_ctx) ir_if(operand(r19B5).val);
   exec_list *const f19B4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f19B4->then_instructions;

      /* IF CONDITION */
      ir_expression *const r19B7 = bit_or(r19AF, swizzle_x(r19AB));
      ir_expression *const r19B8 = nequal(r19B7, body.constant(0u));
      ir_if *f19B6 = new(mem_ctx) ir_if(operand(r19B8).val);
      exec_list *const f19B6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19B6->then_instructions;

         ir_variable *const r19B9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r19B9, lshift(swizzle_x(r19AB), body.constant(int(12))), 0x01));

         ir_variable *const r19BA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r19BB = lshift(swizzle_y(r19AB), body.constant(int(12)));
         ir_expression *const r19BC = rshift(swizzle_x(r19AB), body.constant(int(20)));
         body.emit(assign(r19BA, bit_or(r19BB, r19BC), 0x01));

         body.emit(assign(r19AB, r19BA, 0x02));

         body.emit(assign(r19AB, r19B9, 0x01));

         ir_expression *const r19BD = lshift(r19B3, body.constant(int(31)));
         ir_expression *const r19BE = bit_or(r19BD, body.constant(2143289344u));
         ir_expression *const r19BF = rshift(r19BA, body.constant(int(9)));
         ir_expression *const r19C0 = bit_or(r19BE, r19BF);
         body.emit(assign(r19AC, expr(ir_unop_bitcast_u2f, r19C0), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f19B6->else_instructions;

         ir_expression *const r19C1 = lshift(r19B3, body.constant(int(31)));
         ir_expression *const r19C2 = add(r19C1, body.constant(2139095040u));
         body.emit(assign(r19AC, expr(ir_unop_bitcast_u2f, r19C2), 0x01));


      body.instructions = f19B6_parent_instructions;
      body.emit(f19B6);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f19B4->else_instructions;

      ir_variable *const r19C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r19C3);
      ir_variable *const r19C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r19C4);
      ir_expression *const r19C5 = lshift(r19AF, body.constant(int(10)));
      ir_expression *const r19C6 = rshift(r19AE, body.constant(int(22)));
      ir_expression *const r19C7 = bit_or(r19C5, r19C6);
      ir_expression *const r19C8 = lshift(r19AE, body.constant(int(10)));
      ir_expression *const r19C9 = nequal(r19C8, body.constant(0u));
      ir_expression *const r19CA = expr(ir_unop_b2i, r19C9);
      ir_expression *const r19CB = expr(ir_unop_i2u, r19CA);
      body.emit(assign(r19C3, bit_or(r19C7, r19CB), 0x01));

      body.emit(assign(r19C4, rshift(r19AF, body.constant(int(22))), 0x01));

      body.emit(assign(r19AD, r19C3, 0x01));

      /* IF CONDITION */
      ir_expression *const r19CD = nequal(r19B0, body.constant(int(0)));
      ir_if *f19CC = new(mem_ctx) ir_if(operand(r19CD).val);
      exec_list *const f19CC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19CC->then_instructions;

         body.emit(assign(r19AD, bit_or(r19C3, body.constant(1073741824u)), 0x01));


      body.instructions = f19CC_parent_instructions;
      body.emit(f19CC);

      /* END IF */

      ir_variable *const r19CE = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r19CE, add(r19B0, body.constant(int(-897))), 0x01));

      ir_variable *const r19CF = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r19CF, r19AD, 0x01));

      ir_variable *const r19D0 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r19D0, body.constant(true), 0x01));

      ir_variable *const r19D1 = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r19D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
      body.emit(r19D2);
      ir_expression *const r19D3 = expr(ir_unop_u2i, r19AD);
      body.emit(assign(r19D2, bit_and(r19D3, body.constant(int(127))), 0x01));

      /* IF CONDITION */
      ir_expression *const r19D5 = expr(ir_unop_i2u, r19CE);
      ir_expression *const r19D6 = lequal(body.constant(253u), r19D5);
      ir_if *f19D4 = new(mem_ctx) ir_if(operand(r19D6).val);
      exec_list *const f19D4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19D4->then_instructions;

         /* IF CONDITION */
         ir_expression *const r19D8 = less(body.constant(int(253)), r19CE);
         ir_expression *const r19D9 = equal(r19CE, body.constant(int(253)));
         ir_expression *const r19DA = add(r19AD, body.constant(64u));
         ir_expression *const r19DB = expr(ir_unop_u2i, r19DA);
         ir_expression *const r19DC = less(r19DB, body.constant(int(0)));
         ir_expression *const r19DD = logic_and(r19D9, r19DC);
         ir_expression *const r19DE = logic_or(r19D8, r19DD);
         ir_if *f19D7 = new(mem_ctx) ir_if(operand(r19DE).val);
         exec_list *const f19D7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19D7->then_instructions;

            ir_expression *const r19DF = lshift(r19B3, body.constant(int(31)));
            body.emit(assign(r19D1, add(r19DF, body.constant(2139095040u)), 0x01));

            body.emit(assign(r19D0, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f19D7->else_instructions;

            /* IF CONDITION */
            ir_expression *const r19E1 = less(r19CE, body.constant(int(0)));
            ir_if *f19E0 = new(mem_ctx) ir_if(operand(r19E1).val);
            exec_list *const f19E0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f19E0->then_instructions;

               ir_variable *const r19E2 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r19E2, neg(r19CE), 0x01));

               ir_variable *const r19E3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r19E3);
               /* IF CONDITION */
               ir_expression *const r19E5 = equal(r19E2, body.constant(int(0)));
               ir_if *f19E4 = new(mem_ctx) ir_if(operand(r19E5).val);
               exec_list *const f19E4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f19E4->then_instructions;

                  body.emit(assign(r19E3, r19AD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f19E4->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r19E7 = less(r19E2, body.constant(int(32)));
                  ir_if *f19E6 = new(mem_ctx) ir_if(operand(r19E7).val);
                  exec_list *const f19E6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f19E6->then_instructions;

                     ir_expression *const r19E8 = rshift(r19AD, r19E2);
                     ir_expression *const r19E9 = neg(r19E2);
                     ir_expression *const r19EA = bit_and(r19E9, body.constant(int(31)));
                     ir_expression *const r19EB = lshift(r19AD, r19EA);
                     ir_expression *const r19EC = nequal(r19EB, body.constant(0u));
                     ir_expression *const r19ED = expr(ir_unop_b2i, r19EC);
                     ir_expression *const r19EE = expr(ir_unop_i2u, r19ED);
                     body.emit(assign(r19E3, bit_or(r19E8, r19EE), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f19E6->else_instructions;

                     ir_expression *const r19EF = nequal(r19AD, body.constant(0u));
                     ir_expression *const r19F0 = expr(ir_unop_b2i, r19EF);
                     body.emit(assign(r19E3, expr(ir_unop_i2u, r19F0), 0x01));


                  body.instructions = f19E6_parent_instructions;
                  body.emit(f19E6);

                  /* END IF */


               body.instructions = f19E4_parent_instructions;
               body.emit(f19E4);

               /* END IF */

               body.emit(assign(r19CF, r19E3, 0x01));

               body.emit(assign(r19CE, body.constant(int(0)), 0x01));

               ir_expression *const r19F1 = expr(ir_unop_u2i, r19E3);
               body.emit(assign(r19D2, bit_and(r19F1, body.constant(int(127))), 0x01));


            body.instructions = f19E0_parent_instructions;
            body.emit(f19E0);

            /* END IF */


         body.instructions = f19D7_parent_instructions;
         body.emit(f19D7);

         /* END IF */


      body.instructions = f19D4_parent_instructions;
      body.emit(f19D4);

      /* END IF */

      /* IF CONDITION */
      ir_if *f19F2 = new(mem_ctx) ir_if(operand(r19D0).val);
      exec_list *const f19F2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19F2->then_instructions;

         ir_expression *const r19F3 = add(r19CF, body.constant(64u));
         body.emit(assign(r19CF, rshift(r19F3, body.constant(int(7))), 0x01));

         ir_expression *const r19F4 = bit_xor(r19D2, body.constant(int(64)));
         ir_expression *const r19F5 = equal(r19F4, body.constant(int(0)));
         ir_expression *const r19F6 = expr(ir_unop_b2i, r19F5);
         ir_expression *const r19F7 = expr(ir_unop_i2u, r19F6);
         ir_expression *const r19F8 = bit_and(r19F7, body.constant(1u));
         ir_expression *const r19F9 = expr(ir_unop_bit_not, r19F8);
         body.emit(assign(r19CF, bit_and(r19CF, r19F9), 0x01));

         /* IF CONDITION */
         ir_expression *const r19FB = equal(r19CF, body.constant(0u));
         ir_if *f19FA = new(mem_ctx) ir_if(operand(r19FB).val);
         exec_list *const f19FA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19FA->then_instructions;

            body.emit(assign(r19CE, body.constant(int(0)), 0x01));


         body.instructions = f19FA_parent_instructions;
         body.emit(f19FA);

         /* END IF */

         ir_expression *const r19FC = lshift(r19B3, body.constant(int(31)));
         ir_expression *const r19FD = expr(ir_unop_i2u, r19CE);
         ir_expression *const r19FE = lshift(r19FD, body.constant(int(23)));
         ir_expression *const r19FF = add(r19FC, r19FE);
         body.emit(assign(r19D1, add(r19FF, r19CF), 0x01));

         body.emit(assign(r19D0, body.constant(false), 0x01));


      body.instructions = f19F2_parent_instructions;
      body.emit(f19F2);

      /* END IF */

      body.emit(assign(r19AC, expr(ir_unop_bitcast_u2f, r19D1), 0x01));


   body.instructions = f19B4_parent_instructions;
   body.emit(f19B4);

   /* END IF */

   body.emit(ret(r19AC));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_int(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A00 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A00);
   ir_variable *const r1A01 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1A01, body.constant(true), 0x01));

   ir_variable *const r1A02 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r1A03 = new(mem_ctx) ir_variable(glsl_type::uint_type, "absZ", ir_var_auto);
   body.emit(r1A03);
   ir_variable *const r1A04 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aSign", ir_var_auto);
   body.emit(r1A04);
   ir_variable *const r1A05 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r1A05);
   ir_variable *const r1A06 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1A06, bit_and(swizzle_y(r1A00), body.constant(1048575u)), 0x01));

   body.emit(assign(r1A05, r1A06, 0x01));

   ir_variable *const r1A07 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1A08 = rshift(swizzle_y(r1A00), body.constant(int(20)));
   ir_expression *const r1A09 = bit_and(r1A08, body.constant(2047u));
   body.emit(assign(r1A07, expr(ir_unop_u2i, r1A09), 0x01));

   body.emit(assign(r1A04, rshift(swizzle_y(r1A00), body.constant(int(31))), 0x01));

   body.emit(assign(r1A03, body.constant(0u), 0x01));

   ir_variable *const r1A0A = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r1A0A, add(r1A07, body.constant(int(-1043))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A0C = lequal(body.constant(int(0)), r1A0A);
   ir_if *f1A0B = new(mem_ctx) ir_if(operand(r1A0C).val);
   exec_list *const f1A0B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A0B->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1A0E = less(body.constant(int(1054)), r1A07);
      ir_if *f1A0D = new(mem_ctx) ir_if(operand(r1A0E).val);
      exec_list *const f1A0D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A0D->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1A10 = equal(r1A07, body.constant(int(2047)));
         ir_expression *const r1A11 = bit_or(r1A06, swizzle_x(r1A00));
         ir_expression *const r1A12 = expr(ir_unop_u2i, r1A11);
         ir_expression *const r1A13 = expr(ir_unop_i2b, r1A12);
         ir_expression *const r1A14 = logic_and(r1A10, r1A13);
         ir_if *f1A0F = new(mem_ctx) ir_if(operand(r1A14).val);
         exec_list *const f1A0F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A0F->then_instructions;

            body.emit(assign(r1A04, body.constant(0u), 0x01));


         body.instructions = f1A0F_parent_instructions;
         body.emit(f1A0F);

         /* END IF */

         ir_variable *const r1A15 = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A17 = expr(ir_unop_u2i, r1A04);
         ir_expression *const r1A18 = expr(ir_unop_i2b, r1A17);
         ir_if *f1A16 = new(mem_ctx) ir_if(operand(r1A18).val);
         exec_list *const f1A16_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A16->then_instructions;

            body.emit(assign(r1A15, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A16->else_instructions;

            body.emit(assign(r1A15, body.constant(int(2147483647)), 0x01));


         body.instructions = f1A16_parent_instructions;
         body.emit(f1A16);

         /* END IF */

         body.emit(assign(r1A02, r1A15, 0x01));

         body.emit(assign(r1A01, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A0D->else_instructions;

         ir_variable *const r1A19 = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r1A19, bit_or(r1A06, body.constant(1048576u)), 0x01));

         ir_variable *const r1A1A = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1A1A, lshift(swizzle_x(r1A00), r1A0A), 0x01));

         ir_variable *const r1A1B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A1D = equal(r1A0A, body.constant(int(0)));
         ir_if *f1A1C = new(mem_ctx) ir_if(operand(r1A1D).val);
         exec_list *const f1A1C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A1C->then_instructions;

            body.emit(assign(r1A1B, r1A19, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A1C->else_instructions;

            ir_expression *const r1A1E = lshift(r1A19, r1A0A);
            ir_expression *const r1A1F = neg(r1A0A);
            ir_expression *const r1A20 = bit_and(r1A1F, body.constant(int(31)));
            ir_expression *const r1A21 = rshift(swizzle_x(r1A00), r1A20);
            body.emit(assign(r1A1B, bit_or(r1A1E, r1A21), 0x01));


         body.instructions = f1A1C_parent_instructions;
         body.emit(f1A1C);

         /* END IF */

         body.emit(assign(r1A03, r1A1B, 0x01));


      body.instructions = f1A0D_parent_instructions;
      body.emit(f1A0D);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A0B->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1A23 = less(r1A07, body.constant(int(1023)));
      ir_if *f1A22 = new(mem_ctx) ir_if(operand(r1A23).val);
      exec_list *const f1A22_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A22->then_instructions;

         body.emit(assign(r1A02, body.constant(int(0)), 0x01));

         body.emit(assign(r1A01, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A22->else_instructions;

         body.emit(assign(r1A05, bit_or(r1A06, body.constant(1048576u)), 0x01));

         ir_expression *const r1A24 = neg(r1A0A);
         body.emit(assign(r1A03, rshift(r1A05, r1A24), 0x01));


      body.instructions = f1A22_parent_instructions;
      body.emit(f1A22);

      /* END IF */


   body.instructions = f1A0B_parent_instructions;
   body.emit(f1A0B);

   /* END IF */

   /* IF CONDITION */
   ir_if *f1A25 = new(mem_ctx) ir_if(operand(r1A01).val);
   exec_list *const f1A25_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A25->then_instructions;

      ir_variable *const r1A26 = body.make_temp(glsl_type::int_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1A28 = nequal(r1A04, body.constant(0u));
      ir_if *f1A27 = new(mem_ctx) ir_if(operand(r1A28).val);
      exec_list *const f1A27_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A27->then_instructions;

         ir_expression *const r1A29 = expr(ir_unop_u2i, r1A03);
         body.emit(assign(r1A26, neg(r1A29), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A27->else_instructions;

         body.emit(assign(r1A26, expr(ir_unop_u2i, r1A03), 0x01));


      body.instructions = f1A27_parent_instructions;
      body.emit(f1A27);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1A2B = less(r1A26, body.constant(int(0)));
      ir_expression *const r1A2C = expr(ir_unop_b2i, r1A2B);
      ir_expression *const r1A2D = expr(ir_unop_i2u, r1A2C);
      ir_expression *const r1A2E = bit_xor(r1A04, r1A2D);
      ir_expression *const r1A2F = expr(ir_unop_u2i, r1A2E);
      ir_expression *const r1A30 = expr(ir_unop_i2b, r1A2F);
      ir_expression *const r1A31 = expr(ir_unop_i2b, r1A26);
      ir_expression *const r1A32 = logic_and(r1A30, r1A31);
      ir_if *f1A2A = new(mem_ctx) ir_if(operand(r1A32).val);
      exec_list *const f1A2A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A2A->then_instructions;

         ir_variable *const r1A33 = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A35 = expr(ir_unop_u2i, r1A04);
         ir_expression *const r1A36 = expr(ir_unop_i2b, r1A35);
         ir_if *f1A34 = new(mem_ctx) ir_if(operand(r1A36).val);
         exec_list *const f1A34_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A34->then_instructions;

            body.emit(assign(r1A33, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A34->else_instructions;

            body.emit(assign(r1A33, body.constant(int(2147483647)), 0x01));


         body.instructions = f1A34_parent_instructions;
         body.emit(f1A34);

         /* END IF */

         body.emit(assign(r1A02, r1A33, 0x01));

         body.emit(assign(r1A01, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A2A->else_instructions;

         body.emit(assign(r1A02, r1A26, 0x01));

         body.emit(assign(r1A01, body.constant(false), 0x01));


      body.instructions = f1A2A_parent_instructions;
      body.emit(f1A2A);

      /* END IF */


   body.instructions = f1A25_parent_instructions;
   body.emit(f1A25);

   /* END IF */

   body.emit(ret(r1A02));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
int_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A37 = new(mem_ctx) ir_variable(glsl_type::int_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A37);
   ir_variable *const r1A38 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1A39 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1A39);
   ir_variable *const r1A3A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1A3A);
   ir_variable *const r1A3B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1A3B);
   body.emit(assign(r1A3B, body.constant(0u), 0x01));

   body.emit(assign(r1A3A, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A3D = equal(r1A37, body.constant(int(0)));
   ir_if *f1A3C = new(mem_ctx) ir_if(operand(r1A3D).val);
   exec_list *const f1A3C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A3C->then_instructions;

      ir_variable *const r1A3E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1A3E);
      body.emit(assign(r1A3E, body.constant(0u), 0x02));

      body.emit(assign(r1A3E, body.constant(0u), 0x01));

      body.emit(assign(r1A38, r1A3E, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A3C->else_instructions;

      ir_expression *const r1A3F = less(r1A37, body.constant(int(0)));
      ir_expression *const r1A40 = expr(ir_unop_b2i, r1A3F);
      body.emit(assign(r1A39, expr(ir_unop_i2u, r1A40), 0x01));

      ir_variable *const r1A41 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1A43 = less(r1A37, body.constant(int(0)));
      ir_if *f1A42 = new(mem_ctx) ir_if(operand(r1A43).val);
      exec_list *const f1A42_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A42->then_instructions;

         ir_expression *const r1A44 = neg(r1A37);
         body.emit(assign(r1A41, expr(ir_unop_i2u, r1A44), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A42->else_instructions;

         body.emit(assign(r1A41, expr(ir_unop_i2u, r1A37), 0x01));


      body.instructions = f1A42_parent_instructions;
      body.emit(f1A42);

      /* END IF */

      ir_variable *const r1A45 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1A45, r1A41, 0x01));

      ir_variable *const r1A46 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1A47 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1A47);
      /* IF CONDITION */
      ir_expression *const r1A49 = equal(r1A41, body.constant(0u));
      ir_if *f1A48 = new(mem_ctx) ir_if(operand(r1A49).val);
      exec_list *const f1A48_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A48->then_instructions;

         body.emit(assign(r1A46, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A48->else_instructions;

         body.emit(assign(r1A47, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1A4B = bit_and(r1A41, body.constant(4294901760u));
         ir_expression *const r1A4C = equal(r1A4B, body.constant(0u));
         ir_if *f1A4A = new(mem_ctx) ir_if(operand(r1A4C).val);
         exec_list *const f1A4A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A4A->then_instructions;

            body.emit(assign(r1A47, body.constant(int(16)), 0x01));

            body.emit(assign(r1A45, lshift(r1A41, body.constant(int(16))), 0x01));


         body.instructions = f1A4A_parent_instructions;
         body.emit(f1A4A);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A4E = bit_and(r1A45, body.constant(4278190080u));
         ir_expression *const r1A4F = equal(r1A4E, body.constant(0u));
         ir_if *f1A4D = new(mem_ctx) ir_if(operand(r1A4F).val);
         exec_list *const f1A4D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A4D->then_instructions;

            body.emit(assign(r1A47, add(r1A47, body.constant(int(8))), 0x01));

            body.emit(assign(r1A45, lshift(r1A45, body.constant(int(8))), 0x01));


         body.instructions = f1A4D_parent_instructions;
         body.emit(f1A4D);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A51 = bit_and(r1A45, body.constant(4026531840u));
         ir_expression *const r1A52 = equal(r1A51, body.constant(0u));
         ir_if *f1A50 = new(mem_ctx) ir_if(operand(r1A52).val);
         exec_list *const f1A50_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A50->then_instructions;

            body.emit(assign(r1A47, add(r1A47, body.constant(int(4))), 0x01));

            body.emit(assign(r1A45, lshift(r1A45, body.constant(int(4))), 0x01));


         body.instructions = f1A50_parent_instructions;
         body.emit(f1A50);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A54 = bit_and(r1A45, body.constant(3221225472u));
         ir_expression *const r1A55 = equal(r1A54, body.constant(0u));
         ir_if *f1A53 = new(mem_ctx) ir_if(operand(r1A55).val);
         exec_list *const f1A53_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A53->then_instructions;

            body.emit(assign(r1A47, add(r1A47, body.constant(int(2))), 0x01));

            body.emit(assign(r1A45, lshift(r1A45, body.constant(int(2))), 0x01));


         body.instructions = f1A53_parent_instructions;
         body.emit(f1A53);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A57 = bit_and(r1A45, body.constant(2147483648u));
         ir_expression *const r1A58 = equal(r1A57, body.constant(0u));
         ir_if *f1A56 = new(mem_ctx) ir_if(operand(r1A58).val);
         exec_list *const f1A56_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A56->then_instructions;

            body.emit(assign(r1A47, add(r1A47, body.constant(int(1))), 0x01));


         body.instructions = f1A56_parent_instructions;
         body.emit(f1A56);

         /* END IF */

         body.emit(assign(r1A46, r1A47, 0x01));


      body.instructions = f1A48_parent_instructions;
      body.emit(f1A48);

      /* END IF */

      ir_variable *const r1A59 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r1A59, add(r1A46, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1A5B = lequal(body.constant(int(0)), r1A59);
      ir_if *f1A5A = new(mem_ctx) ir_if(operand(r1A5B).val);
      exec_list *const f1A5A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A5A->then_instructions;

         body.emit(assign(r1A3B, lshift(r1A41, r1A59), 0x01));

         body.emit(assign(r1A3A, body.constant(0u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A5A->else_instructions;

         ir_variable *const r1A5C = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r1A5C, body.constant(0u), 0x01));

         ir_variable *const r1A5D = body.make_temp(glsl_type::int_type, "count");
         body.emit(assign(r1A5D, neg(r1A59), 0x01));

         ir_variable *const r1A5E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r1A5E);
         ir_variable *const r1A5F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1A5F);
         ir_variable *const r1A60 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r1A61 = neg(r1A5D);
         body.emit(assign(r1A60, bit_and(r1A61, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r1A63 = equal(r1A5D, body.constant(int(0)));
         ir_if *f1A62 = new(mem_ctx) ir_if(operand(r1A63).val);
         exec_list *const f1A62_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A62->then_instructions;

            body.emit(assign(r1A5E, body.constant(0u), 0x01));

            body.emit(assign(r1A5F, r1A41, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A62->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1A65 = less(r1A5D, body.constant(int(32)));
            ir_if *f1A64 = new(mem_ctx) ir_if(operand(r1A65).val);
            exec_list *const f1A64_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1A64->then_instructions;

               ir_expression *const r1A66 = lshift(r1A41, r1A60);
               body.emit(assign(r1A5E, bit_or(r1A66, body.constant(0u)), 0x01));

               body.emit(assign(r1A5F, rshift(r1A41, r1A5D), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1A64->else_instructions;

               ir_variable *const r1A67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1A69 = less(r1A5D, body.constant(int(64)));
               ir_if *f1A68 = new(mem_ctx) ir_if(operand(r1A69).val);
               exec_list *const f1A68_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1A68->then_instructions;

                  ir_expression *const r1A6A = bit_and(r1A5D, body.constant(int(31)));
                  body.emit(assign(r1A67, rshift(r1A41, r1A6A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1A68->else_instructions;

                  body.emit(assign(r1A67, body.constant(0u), 0x01));


               body.instructions = f1A68_parent_instructions;
               body.emit(f1A68);

               /* END IF */

               body.emit(assign(r1A5E, r1A67, 0x01));

               body.emit(assign(r1A5F, body.constant(0u), 0x01));


            body.instructions = f1A64_parent_instructions;
            body.emit(f1A64);

            /* END IF */


         body.instructions = f1A62_parent_instructions;
         body.emit(f1A62);

         /* END IF */

         body.emit(assign(r1A3B, r1A5F, 0x01));

         body.emit(assign(r1A3A, r1A5E, 0x01));


      body.instructions = f1A5A_parent_instructions;
      body.emit(f1A5A);

      /* END IF */

      ir_variable *const r1A6B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1A6B);
      ir_expression *const r1A6C = lshift(r1A39, body.constant(int(31)));
      ir_expression *const r1A6D = sub(body.constant(int(1042)), r1A59);
      ir_expression *const r1A6E = expr(ir_unop_i2u, r1A6D);
      ir_expression *const r1A6F = lshift(r1A6E, body.constant(int(20)));
      ir_expression *const r1A70 = add(r1A6C, r1A6F);
      body.emit(assign(r1A6B, add(r1A70, r1A3B), 0x02));

      body.emit(assign(r1A6B, r1A3A, 0x01));

      body.emit(assign(r1A38, r1A6B, 0x03));


   body.instructions = f1A3C_parent_instructions;
   body.emit(f1A3C);

   /* END IF */

   body.emit(ret(r1A38));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtOddAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A71 = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r1A71);
   ir_variable *const r1A72 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r1A72);
   body.emit(assign(r1A72, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A74 = equal(r1A71, body.constant(int(0)));
   ir_if *f1A73 = new(mem_ctx) ir_if(operand(r1A74).val);
   exec_list *const f1A73_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A73->then_instructions;

      body.emit(assign(r1A72, body.constant(4u), 0x01));


   body.instructions = f1A73_parent_instructions;
   body.emit(f1A73);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A76 = equal(r1A71, body.constant(int(1)));
   ir_if *f1A75 = new(mem_ctx) ir_if(operand(r1A76).val);
   exec_list *const f1A75_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A75->then_instructions;

      body.emit(assign(r1A72, body.constant(34u), 0x01));


   body.instructions = f1A75_parent_instructions;
   body.emit(f1A75);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A78 = equal(r1A71, body.constant(int(2)));
   ir_if *f1A77 = new(mem_ctx) ir_if(operand(r1A78).val);
   exec_list *const f1A77_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A77->then_instructions;

      body.emit(assign(r1A72, body.constant(93u), 0x01));


   body.instructions = f1A77_parent_instructions;
   body.emit(f1A77);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A7A = equal(r1A71, body.constant(int(3)));
   ir_if *f1A79 = new(mem_ctx) ir_if(operand(r1A7A).val);
   exec_list *const f1A79_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A79->then_instructions;

      body.emit(assign(r1A72, body.constant(177u), 0x01));


   body.instructions = f1A79_parent_instructions;
   body.emit(f1A79);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A7C = equal(r1A71, body.constant(int(4)));
   ir_if *f1A7B = new(mem_ctx) ir_if(operand(r1A7C).val);
   exec_list *const f1A7B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A7B->then_instructions;

      body.emit(assign(r1A72, body.constant(285u), 0x01));


   body.instructions = f1A7B_parent_instructions;
   body.emit(f1A7B);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A7E = equal(r1A71, body.constant(int(5)));
   ir_if *f1A7D = new(mem_ctx) ir_if(operand(r1A7E).val);
   exec_list *const f1A7D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A7D->then_instructions;

      body.emit(assign(r1A72, body.constant(415u), 0x01));


   body.instructions = f1A7D_parent_instructions;
   body.emit(f1A7D);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A80 = equal(r1A71, body.constant(int(6)));
   ir_if *f1A7F = new(mem_ctx) ir_if(operand(r1A80).val);
   exec_list *const f1A7F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A7F->then_instructions;

      body.emit(assign(r1A72, body.constant(566u), 0x01));


   body.instructions = f1A7F_parent_instructions;
   body.emit(f1A7F);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A82 = equal(r1A71, body.constant(int(7)));
   ir_if *f1A81 = new(mem_ctx) ir_if(operand(r1A82).val);
   exec_list *const f1A81_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A81->then_instructions;

      body.emit(assign(r1A72, body.constant(736u), 0x01));


   body.instructions = f1A81_parent_instructions;
   body.emit(f1A81);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A84 = equal(r1A71, body.constant(int(8)));
   ir_if *f1A83 = new(mem_ctx) ir_if(operand(r1A84).val);
   exec_list *const f1A83_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A83->then_instructions;

      body.emit(assign(r1A72, body.constant(924u), 0x01));


   body.instructions = f1A83_parent_instructions;
   body.emit(f1A83);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A86 = equal(r1A71, body.constant(int(9)));
   ir_if *f1A85 = new(mem_ctx) ir_if(operand(r1A86).val);
   exec_list *const f1A85_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A85->then_instructions;

      body.emit(assign(r1A72, body.constant(1128u), 0x01));


   body.instructions = f1A85_parent_instructions;
   body.emit(f1A85);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A88 = equal(r1A71, body.constant(int(10)));
   ir_if *f1A87 = new(mem_ctx) ir_if(operand(r1A88).val);
   exec_list *const f1A87_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A87->then_instructions;

      body.emit(assign(r1A72, body.constant(1349u), 0x01));


   body.instructions = f1A87_parent_instructions;
   body.emit(f1A87);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A8A = equal(r1A71, body.constant(int(11)));
   ir_if *f1A89 = new(mem_ctx) ir_if(operand(r1A8A).val);
   exec_list *const f1A89_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A89->then_instructions;

      body.emit(assign(r1A72, body.constant(1585u), 0x01));


   body.instructions = f1A89_parent_instructions;
   body.emit(f1A89);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A8C = equal(r1A71, body.constant(int(12)));
   ir_if *f1A8B = new(mem_ctx) ir_if(operand(r1A8C).val);
   exec_list *const f1A8B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A8B->then_instructions;

      body.emit(assign(r1A72, body.constant(1835u), 0x01));


   body.instructions = f1A8B_parent_instructions;
   body.emit(f1A8B);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A8E = equal(r1A71, body.constant(int(13)));
   ir_if *f1A8D = new(mem_ctx) ir_if(operand(r1A8E).val);
   exec_list *const f1A8D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A8D->then_instructions;

      body.emit(assign(r1A72, body.constant(2098u), 0x01));


   body.instructions = f1A8D_parent_instructions;
   body.emit(f1A8D);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A90 = equal(r1A71, body.constant(int(14)));
   ir_if *f1A8F = new(mem_ctx) ir_if(operand(r1A90).val);
   exec_list *const f1A8F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A8F->then_instructions;

      body.emit(assign(r1A72, body.constant(2374u), 0x01));


   body.instructions = f1A8F_parent_instructions;
   body.emit(f1A8F);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A92 = equal(r1A71, body.constant(int(15)));
   ir_if *f1A91 = new(mem_ctx) ir_if(operand(r1A92).val);
   exec_list *const f1A91_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A91->then_instructions;

      body.emit(assign(r1A72, body.constant(2663u), 0x01));


   body.instructions = f1A91_parent_instructions;
   body.emit(f1A91);

   /* END IF */

   body.emit(ret(r1A72));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtEvenAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A93 = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r1A93);
   ir_variable *const r1A94 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r1A94);
   body.emit(assign(r1A94, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A96 = equal(r1A93, body.constant(int(0)));
   ir_if *f1A95 = new(mem_ctx) ir_if(operand(r1A96).val);
   exec_list *const f1A95_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A95->then_instructions;

      body.emit(assign(r1A94, body.constant(2605u), 0x01));


   body.instructions = f1A95_parent_instructions;
   body.emit(f1A95);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A98 = equal(r1A93, body.constant(int(1)));
   ir_if *f1A97 = new(mem_ctx) ir_if(operand(r1A98).val);
   exec_list *const f1A97_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A97->then_instructions;

      body.emit(assign(r1A94, body.constant(2223u), 0x01));


   body.instructions = f1A97_parent_instructions;
   body.emit(f1A97);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A9A = equal(r1A93, body.constant(int(2)));
   ir_if *f1A99 = new(mem_ctx) ir_if(operand(r1A9A).val);
   exec_list *const f1A99_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A99->then_instructions;

      body.emit(assign(r1A94, body.constant(1882u), 0x01));


   body.instructions = f1A99_parent_instructions;
   body.emit(f1A99);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A9C = equal(r1A93, body.constant(int(3)));
   ir_if *f1A9B = new(mem_ctx) ir_if(operand(r1A9C).val);
   exec_list *const f1A9B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A9B->then_instructions;

      body.emit(assign(r1A94, body.constant(1577u), 0x01));


   body.instructions = f1A9B_parent_instructions;
   body.emit(f1A9B);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A9E = equal(r1A93, body.constant(int(4)));
   ir_if *f1A9D = new(mem_ctx) ir_if(operand(r1A9E).val);
   exec_list *const f1A9D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A9D->then_instructions;

      body.emit(assign(r1A94, body.constant(1306u), 0x01));


   body.instructions = f1A9D_parent_instructions;
   body.emit(f1A9D);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA0 = equal(r1A93, body.constant(int(5)));
   ir_if *f1A9F = new(mem_ctx) ir_if(operand(r1AA0).val);
   exec_list *const f1A9F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A9F->then_instructions;

      body.emit(assign(r1A94, body.constant(1065u), 0x01));


   body.instructions = f1A9F_parent_instructions;
   body.emit(f1A9F);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA2 = equal(r1A93, body.constant(int(6)));
   ir_if *f1AA1 = new(mem_ctx) ir_if(operand(r1AA2).val);
   exec_list *const f1AA1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA1->then_instructions;

      body.emit(assign(r1A94, body.constant(854u), 0x01));


   body.instructions = f1AA1_parent_instructions;
   body.emit(f1AA1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA4 = equal(r1A93, body.constant(int(7)));
   ir_if *f1AA3 = new(mem_ctx) ir_if(operand(r1AA4).val);
   exec_list *const f1AA3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA3->then_instructions;

      body.emit(assign(r1A94, body.constant(670u), 0x01));


   body.instructions = f1AA3_parent_instructions;
   body.emit(f1AA3);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA6 = equal(r1A93, body.constant(int(8)));
   ir_if *f1AA5 = new(mem_ctx) ir_if(operand(r1AA6).val);
   exec_list *const f1AA5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA5->then_instructions;

      body.emit(assign(r1A94, body.constant(512u), 0x01));


   body.instructions = f1AA5_parent_instructions;
   body.emit(f1AA5);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA8 = equal(r1A93, body.constant(int(9)));
   ir_if *f1AA7 = new(mem_ctx) ir_if(operand(r1AA8).val);
   exec_list *const f1AA7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA7->then_instructions;

      body.emit(assign(r1A94, body.constant(377u), 0x01));


   body.instructions = f1AA7_parent_instructions;
   body.emit(f1AA7);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AAA = equal(r1A93, body.constant(int(10)));
   ir_if *f1AA9 = new(mem_ctx) ir_if(operand(r1AAA).val);
   exec_list *const f1AA9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA9->then_instructions;

      body.emit(assign(r1A94, body.constant(265u), 0x01));


   body.instructions = f1AA9_parent_instructions;
   body.emit(f1AA9);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AAC = equal(r1A93, body.constant(int(11)));
   ir_if *f1AAB = new(mem_ctx) ir_if(operand(r1AAC).val);
   exec_list *const f1AAB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AAB->then_instructions;

      body.emit(assign(r1A94, body.constant(175u), 0x01));


   body.instructions = f1AAB_parent_instructions;
   body.emit(f1AAB);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AAE = equal(r1A93, body.constant(int(12)));
   ir_if *f1AAD = new(mem_ctx) ir_if(operand(r1AAE).val);
   exec_list *const f1AAD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AAD->then_instructions;

      body.emit(assign(r1A94, body.constant(104u), 0x01));


   body.instructions = f1AAD_parent_instructions;
   body.emit(f1AAD);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB0 = equal(r1A93, body.constant(int(13)));
   ir_if *f1AAF = new(mem_ctx) ir_if(operand(r1AB0).val);
   exec_list *const f1AAF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AAF->then_instructions;

      body.emit(assign(r1A94, body.constant(52u), 0x01));


   body.instructions = f1AAF_parent_instructions;
   body.emit(f1AAF);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB2 = equal(r1A93, body.constant(int(14)));
   ir_if *f1AB1 = new(mem_ctx) ir_if(operand(r1AB2).val);
   exec_list *const f1AB1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB1->then_instructions;

      body.emit(assign(r1A94, body.constant(18u), 0x01));


   body.instructions = f1AB1_parent_instructions;
   body.emit(f1AB1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB4 = equal(r1A93, body.constant(int(15)));
   ir_if *f1AB3 = new(mem_ctx) ir_if(operand(r1AB4).val);
   exec_list *const f1AB3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB3->then_instructions;

      body.emit(assign(r1A94, body.constant(2u), 0x01));


   body.instructions = f1AB3_parent_instructions;
   body.emit(f1AB3);

   /* END IF */

   body.emit(ret(r1A94));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateSqrt32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1AB5 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_function_in);
   sig_parameters.push_tail(r1AB5);
   ir_variable *const r1AB6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1AB6);
   ir_variable *const r1AB7 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1AB7, body.constant(true), 0x01));

   ir_variable *const r1AB8 = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1AB9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r1AB9);
   ir_variable *const r1ABA = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1ABB = rshift(r1AB6, body.constant(int(27)));
   ir_expression *const r1ABC = bit_and(r1ABB, body.constant(15u));
   body.emit(assign(r1ABA, expr(ir_unop_u2i, r1ABC), 0x01));

   /* IF CONDITION */
   ir_expression *const r1ABE = bit_and(r1AB5, body.constant(int(1)));
   ir_expression *const r1ABF = nequal(r1ABE, body.constant(int(0)));
   ir_if *f1ABD = new(mem_ctx) ir_if(operand(r1ABF).val);
   exec_list *const f1ABD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ABD->then_instructions;

      ir_variable *const r1AC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r1AC0);
      body.emit(assign(r1AC0, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1AC2 = equal(r1ABA, body.constant(int(0)));
      ir_if *f1AC1 = new(mem_ctx) ir_if(operand(r1AC2).val);
      exec_list *const f1AC1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AC1->then_instructions;

         body.emit(assign(r1AC0, body.constant(4u), 0x01));


      body.instructions = f1AC1_parent_instructions;
      body.emit(f1AC1);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AC4 = equal(r1ABA, body.constant(int(1)));
      ir_if *f1AC3 = new(mem_ctx) ir_if(operand(r1AC4).val);
      exec_list *const f1AC3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AC3->then_instructions;

         body.emit(assign(r1AC0, body.constant(34u), 0x01));


      body.instructions = f1AC3_parent_instructions;
      body.emit(f1AC3);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AC6 = equal(r1ABA, body.constant(int(2)));
      ir_if *f1AC5 = new(mem_ctx) ir_if(operand(r1AC6).val);
      exec_list *const f1AC5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AC5->then_instructions;

         body.emit(assign(r1AC0, body.constant(93u), 0x01));


      body.instructions = f1AC5_parent_instructions;
      body.emit(f1AC5);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AC8 = equal(r1ABA, body.constant(int(3)));
      ir_if *f1AC7 = new(mem_ctx) ir_if(operand(r1AC8).val);
      exec_list *const f1AC7_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AC7->then_instructions;

         body.emit(assign(r1AC0, body.constant(177u), 0x01));


      body.instructions = f1AC7_parent_instructions;
      body.emit(f1AC7);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1ACA = equal(r1ABA, body.constant(int(4)));
      ir_if *f1AC9 = new(mem_ctx) ir_if(operand(r1ACA).val);
      exec_list *const f1AC9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AC9->then_instructions;

         body.emit(assign(r1AC0, body.constant(285u), 0x01));


      body.instructions = f1AC9_parent_instructions;
      body.emit(f1AC9);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1ACC = equal(r1ABA, body.constant(int(5)));
      ir_if *f1ACB = new(mem_ctx) ir_if(operand(r1ACC).val);
      exec_list *const f1ACB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1ACB->then_instructions;

         body.emit(assign(r1AC0, body.constant(415u), 0x01));


      body.instructions = f1ACB_parent_instructions;
      body.emit(f1ACB);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1ACE = equal(r1ABA, body.constant(int(6)));
      ir_if *f1ACD = new(mem_ctx) ir_if(operand(r1ACE).val);
      exec_list *const f1ACD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1ACD->then_instructions;

         body.emit(assign(r1AC0, body.constant(566u), 0x01));


      body.instructions = f1ACD_parent_instructions;
      body.emit(f1ACD);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AD0 = equal(r1ABA, body.constant(int(7)));
      ir_if *f1ACF = new(mem_ctx) ir_if(operand(r1AD0).val);
      exec_list *const f1ACF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1ACF->then_instructions;

         body.emit(assign(r1AC0, body.constant(736u), 0x01));


      body.instructions = f1ACF_parent_instructions;
      body.emit(f1ACF);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AD2 = equal(r1ABA, body.constant(int(8)));
      ir_if *f1AD1 = new(mem_ctx) ir_if(operand(r1AD2).val);
      exec_list *const f1AD1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AD1->then_instructions;

         body.emit(assign(r1AC0, body.constant(924u), 0x01));


      body.instructions = f1AD1_parent_instructions;
      body.emit(f1AD1);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AD4 = equal(r1ABA, body.constant(int(9)));
      ir_if *f1AD3 = new(mem_ctx) ir_if(operand(r1AD4).val);
      exec_list *const f1AD3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AD3->then_instructions;

         body.emit(assign(r1AC0, body.constant(1128u), 0x01));


      body.instructions = f1AD3_parent_instructions;
      body.emit(f1AD3);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AD6 = equal(r1ABA, body.constant(int(10)));
      ir_if *f1AD5 = new(mem_ctx) ir_if(operand(r1AD6).val);
      exec_list *const f1AD5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AD5->then_instructions;

         body.emit(assign(r1AC0, body.constant(1349u), 0x01));


      body.instructions = f1AD5_parent_instructions;
      body.emit(f1AD5);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AD8 = equal(r1ABA, body.constant(int(11)));
      ir_if *f1AD7 = new(mem_ctx) ir_if(operand(r1AD8).val);
      exec_list *const f1AD7_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AD7->then_instructions;

         body.emit(assign(r1AC0, body.constant(1585u), 0x01));


      body.instructions = f1AD7_parent_instructions;
      body.emit(f1AD7);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1ADA = equal(r1ABA, body.constant(int(12)));
      ir_if *f1AD9 = new(mem_ctx) ir_if(operand(r1ADA).val);
      exec_list *const f1AD9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AD9->then_instructions;

         body.emit(assign(r1AC0, body.constant(1835u), 0x01));


      body.instructions = f1AD9_parent_instructions;
      body.emit(f1AD9);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1ADC = equal(r1ABA, body.constant(int(13)));
      ir_if *f1ADB = new(mem_ctx) ir_if(operand(r1ADC).val);
      exec_list *const f1ADB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1ADB->then_instructions;

         body.emit(assign(r1AC0, body.constant(2098u), 0x01));


      body.instructions = f1ADB_parent_instructions;
      body.emit(f1ADB);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1ADE = equal(r1ABA, body.constant(int(14)));
      ir_if *f1ADD = new(mem_ctx) ir_if(operand(r1ADE).val);
      exec_list *const f1ADD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1ADD->then_instructions;

         body.emit(assign(r1AC0, body.constant(2374u), 0x01));


      body.instructions = f1ADD_parent_instructions;
      body.emit(f1ADD);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AE0 = equal(r1ABA, body.constant(int(15)));
      ir_if *f1ADF = new(mem_ctx) ir_if(operand(r1AE0).val);
      exec_list *const f1ADF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1ADF->then_instructions;

         body.emit(assign(r1AC0, body.constant(2663u), 0x01));


      body.instructions = f1ADF_parent_instructions;
      body.emit(f1ADF);

      /* END IF */

      ir_expression *const r1AE1 = rshift(r1AB6, body.constant(int(17)));
      ir_expression *const r1AE2 = add(body.constant(16384u), r1AE1);
      body.emit(assign(r1AB9, sub(r1AE2, r1AC0), 0x01));

      ir_expression *const r1AE3 = expr(ir_binop_div, r1AB6, r1AB9);
      ir_expression *const r1AE4 = lshift(r1AE3, body.constant(int(14)));
      ir_expression *const r1AE5 = lshift(r1AB9, body.constant(int(15)));
      body.emit(assign(r1AB9, add(r1AE4, r1AE5), 0x01));

      body.emit(assign(r1AB6, rshift(r1AB6, body.constant(int(1))), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1ABD->else_instructions;

      ir_variable *const r1AE6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r1AE6);
      body.emit(assign(r1AE6, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1AE8 = equal(r1ABA, body.constant(int(0)));
      ir_if *f1AE7 = new(mem_ctx) ir_if(operand(r1AE8).val);
      exec_list *const f1AE7_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AE7->then_instructions;

         body.emit(assign(r1AE6, body.constant(2605u), 0x01));


      body.instructions = f1AE7_parent_instructions;
      body.emit(f1AE7);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AEA = equal(r1ABA, body.constant(int(1)));
      ir_if *f1AE9 = new(mem_ctx) ir_if(operand(r1AEA).val);
      exec_list *const f1AE9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AE9->then_instructions;

         body.emit(assign(r1AE6, body.constant(2223u), 0x01));


      body.instructions = f1AE9_parent_instructions;
      body.emit(f1AE9);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AEC = equal(r1ABA, body.constant(int(2)));
      ir_if *f1AEB = new(mem_ctx) ir_if(operand(r1AEC).val);
      exec_list *const f1AEB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AEB->then_instructions;

         body.emit(assign(r1AE6, body.constant(1882u), 0x01));


      body.instructions = f1AEB_parent_instructions;
      body.emit(f1AEB);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AEE = equal(r1ABA, body.constant(int(3)));
      ir_if *f1AED = new(mem_ctx) ir_if(operand(r1AEE).val);
      exec_list *const f1AED_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AED->then_instructions;

         body.emit(assign(r1AE6, body.constant(1577u), 0x01));


      body.instructions = f1AED_parent_instructions;
      body.emit(f1AED);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF0 = equal(r1ABA, body.constant(int(4)));
      ir_if *f1AEF = new(mem_ctx) ir_if(operand(r1AF0).val);
      exec_list *const f1AEF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AEF->then_instructions;

         body.emit(assign(r1AE6, body.constant(1306u), 0x01));


      body.instructions = f1AEF_parent_instructions;
      body.emit(f1AEF);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF2 = equal(r1ABA, body.constant(int(5)));
      ir_if *f1AF1 = new(mem_ctx) ir_if(operand(r1AF2).val);
      exec_list *const f1AF1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF1->then_instructions;

         body.emit(assign(r1AE6, body.constant(1065u), 0x01));


      body.instructions = f1AF1_parent_instructions;
      body.emit(f1AF1);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF4 = equal(r1ABA, body.constant(int(6)));
      ir_if *f1AF3 = new(mem_ctx) ir_if(operand(r1AF4).val);
      exec_list *const f1AF3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF3->then_instructions;

         body.emit(assign(r1AE6, body.constant(854u), 0x01));


      body.instructions = f1AF3_parent_instructions;
      body.emit(f1AF3);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF6 = equal(r1ABA, body.constant(int(7)));
      ir_if *f1AF5 = new(mem_ctx) ir_if(operand(r1AF6).val);
      exec_list *const f1AF5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF5->then_instructions;

         body.emit(assign(r1AE6, body.constant(670u), 0x01));


      body.instructions = f1AF5_parent_instructions;
      body.emit(f1AF5);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF8 = equal(r1ABA, body.constant(int(8)));
      ir_if *f1AF7 = new(mem_ctx) ir_if(operand(r1AF8).val);
      exec_list *const f1AF7_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF7->then_instructions;

         body.emit(assign(r1AE6, body.constant(512u), 0x01));


      body.instructions = f1AF7_parent_instructions;
      body.emit(f1AF7);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AFA = equal(r1ABA, body.constant(int(9)));
      ir_if *f1AF9 = new(mem_ctx) ir_if(operand(r1AFA).val);
      exec_list *const f1AF9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF9->then_instructions;

         body.emit(assign(r1AE6, body.constant(377u), 0x01));


      body.instructions = f1AF9_parent_instructions;
      body.emit(f1AF9);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AFC = equal(r1ABA, body.constant(int(10)));
      ir_if *f1AFB = new(mem_ctx) ir_if(operand(r1AFC).val);
      exec_list *const f1AFB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFB->then_instructions;

         body.emit(assign(r1AE6, body.constant(265u), 0x01));


      body.instructions = f1AFB_parent_instructions;
      body.emit(f1AFB);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AFE = equal(r1ABA, body.constant(int(11)));
      ir_if *f1AFD = new(mem_ctx) ir_if(operand(r1AFE).val);
      exec_list *const f1AFD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFD->then_instructions;

         body.emit(assign(r1AE6, body.constant(175u), 0x01));


      body.instructions = f1AFD_parent_instructions;
      body.emit(f1AFD);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B00 = equal(r1ABA, body.constant(int(12)));
      ir_if *f1AFF = new(mem_ctx) ir_if(operand(r1B00).val);
      exec_list *const f1AFF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFF->then_instructions;

         body.emit(assign(r1AE6, body.constant(104u), 0x01));


      body.instructions = f1AFF_parent_instructions;
      body.emit(f1AFF);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B02 = equal(r1ABA, body.constant(int(13)));
      ir_if *f1B01 = new(mem_ctx) ir_if(operand(r1B02).val);
      exec_list *const f1B01_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B01->then_instructions;

         body.emit(assign(r1AE6, body.constant(52u), 0x01));


      body.instructions = f1B01_parent_instructions;
      body.emit(f1B01);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B04 = equal(r1ABA, body.constant(int(14)));
      ir_if *f1B03 = new(mem_ctx) ir_if(operand(r1B04).val);
      exec_list *const f1B03_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B03->then_instructions;

         body.emit(assign(r1AE6, body.constant(18u), 0x01));


      body.instructions = f1B03_parent_instructions;
      body.emit(f1B03);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B06 = equal(r1ABA, body.constant(int(15)));
      ir_if *f1B05 = new(mem_ctx) ir_if(operand(r1B06).val);
      exec_list *const f1B05_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B05->then_instructions;

         body.emit(assign(r1AE6, body.constant(2u), 0x01));


      body.instructions = f1B05_parent_instructions;
      body.emit(f1B05);

      /* END IF */

      ir_expression *const r1B07 = rshift(r1AB6, body.constant(int(17)));
      ir_expression *const r1B08 = add(body.constant(32768u), r1B07);
      body.emit(assign(r1AB9, sub(r1B08, r1AE6), 0x01));

      ir_expression *const r1B09 = expr(ir_binop_div, r1AB6, r1AB9);
      body.emit(assign(r1AB9, add(r1B09, r1AB9), 0x01));

      ir_variable *const r1B0A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1B0C = lequal(body.constant(131072u), r1AB9);
      ir_if *f1B0B = new(mem_ctx) ir_if(operand(r1B0C).val);
      exec_list *const f1B0B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B0B->then_instructions;

         body.emit(assign(r1B0A, body.constant(4294934528u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B0B->else_instructions;

         body.emit(assign(r1B0A, lshift(r1AB9, body.constant(int(15))), 0x01));


      body.instructions = f1B0B_parent_instructions;
      body.emit(f1B0B);

      /* END IF */

      body.emit(assign(r1AB9, r1B0A, 0x01));

      /* IF CONDITION */
      ir_expression *const r1B0E = lequal(r1B0A, r1AB6);
      ir_if *f1B0D = new(mem_ctx) ir_if(operand(r1B0E).val);
      exec_list *const f1B0D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B0D->then_instructions;

         ir_expression *const r1B0F = expr(ir_unop_u2i, r1AB6);
         ir_expression *const r1B10 = rshift(r1B0F, body.constant(int(1)));
         body.emit(assign(r1AB8, expr(ir_unop_i2u, r1B10), 0x01));

         body.emit(assign(r1AB7, body.constant(false), 0x01));


      body.instructions = f1B0D_parent_instructions;
      body.emit(f1B0D);

      /* END IF */


   body.instructions = f1ABD_parent_instructions;
   body.emit(f1ABD);

   /* END IF */

   /* IF CONDITION */
   ir_if *f1B11 = new(mem_ctx) ir_if(operand(r1AB7).val);
   exec_list *const f1B11_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1B11->then_instructions;

      ir_variable *const r1B12 = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r1B13 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
      body.emit(r1B13);
      ir_variable *const r1B14 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
      body.emit(r1B14);
      ir_variable *const r1B15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
      body.emit(r1B15);
      ir_variable *const r1B16 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
      body.emit(r1B16);
      body.emit(assign(r1B15, body.constant(0u), 0x01));

      body.emit(assign(r1B14, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1B18 = lequal(r1AB9, r1AB6);
      ir_if *f1B17 = new(mem_ctx) ir_if(operand(r1B18).val);
      exec_list *const f1B17_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B17->then_instructions;

         body.emit(assign(r1B12, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B17->else_instructions;

         body.emit(assign(r1B16, rshift(r1AB9, body.constant(int(16))), 0x01));

         ir_variable *const r1B19 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1B1B = lshift(r1B16, body.constant(int(16)));
         ir_expression *const r1B1C = lequal(r1B1B, r1AB6);
         ir_if *f1B1A = new(mem_ctx) ir_if(operand(r1B1C).val);
         exec_list *const f1B1A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B1A->then_instructions;

            body.emit(assign(r1B19, body.constant(4294901760u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B1A->else_instructions;

            ir_expression *const r1B1D = expr(ir_binop_div, r1AB6, r1B16);
            body.emit(assign(r1B19, lshift(r1B1D, body.constant(int(16))), 0x01));


         body.instructions = f1B1A_parent_instructions;
         body.emit(f1B1A);

         /* END IF */

         body.emit(assign(r1B13, r1B19, 0x01));

         ir_variable *const r1B1E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1B1E);
         ir_variable *const r1B1F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
         body.emit(r1B1F);
         ir_variable *const r1B20 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r1B20);
         ir_variable *const r1B21 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B21, bit_and(r1AB9, body.constant(65535u)), 0x01));

         ir_variable *const r1B22 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B22, rshift(r1AB9, body.constant(int(16))), 0x01));

         ir_variable *const r1B23 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B23, bit_and(r1B19, body.constant(65535u)), 0x01));

         ir_variable *const r1B24 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B24, rshift(r1B19, body.constant(int(16))), 0x01));

         ir_variable *const r1B25 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B25, mul(r1B22, r1B23), 0x01));

         ir_expression *const r1B26 = mul(r1B21, r1B24);
         body.emit(assign(r1B1F, add(r1B26, r1B25), 0x01));

         ir_expression *const r1B27 = mul(r1B22, r1B24);
         ir_expression *const r1B28 = less(r1B1F, r1B25);
         ir_expression *const r1B29 = expr(ir_unop_b2i, r1B28);
         ir_expression *const r1B2A = expr(ir_unop_i2u, r1B29);
         ir_expression *const r1B2B = lshift(r1B2A, body.constant(int(16)));
         ir_expression *const r1B2C = rshift(r1B1F, body.constant(int(16)));
         ir_expression *const r1B2D = add(r1B2B, r1B2C);
         body.emit(assign(r1B1E, add(r1B27, r1B2D), 0x01));

         body.emit(assign(r1B1F, lshift(r1B1F, body.constant(int(16))), 0x01));

         ir_expression *const r1B2E = mul(r1B21, r1B23);
         body.emit(assign(r1B20, add(r1B2E, r1B1F), 0x01));

         ir_expression *const r1B2F = less(r1B20, r1B1F);
         ir_expression *const r1B30 = expr(ir_unop_b2i, r1B2F);
         ir_expression *const r1B31 = expr(ir_unop_i2u, r1B30);
         body.emit(assign(r1B1E, add(r1B1E, r1B31), 0x01));

         ir_expression *const r1B32 = sub(r1AB6, r1B1E);
         ir_expression *const r1B33 = less(body.constant(0u), r1B20);
         ir_expression *const r1B34 = expr(ir_unop_b2i, r1B33);
         ir_expression *const r1B35 = expr(ir_unop_i2u, r1B34);
         body.emit(assign(r1B15, sub(r1B32, r1B35), 0x01));

         body.emit(assign(r1B14, neg(r1B20), 0x01));

         /* LOOP BEGIN */
         ir_loop *f1B36 = new(mem_ctx) ir_loop();
         exec_list *const f1B36_parent_instructions = body.instructions;

            body.instructions = &f1B36->body_instructions;

            /* IF CONDITION */
            ir_expression *const r1B38 = expr(ir_unop_u2i, r1B15);
            ir_expression *const r1B39 = gequal(r1B38, body.constant(int(0)));
            ir_if *f1B37 = new(mem_ctx) ir_if(operand(r1B39).val);
            exec_list *const f1B37_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1B37->then_instructions;

               body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


            body.instructions = f1B37_parent_instructions;
            body.emit(f1B37);

            /* END IF */

            body.emit(assign(r1B13, add(r1B13, body.constant(4294901760u)), 0x01));

            ir_variable *const r1B3A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            ir_expression *const r1B3B = lshift(r1AB9, body.constant(int(16)));
            body.emit(assign(r1B3A, add(r1B14, r1B3B), 0x01));

            ir_expression *const r1B3C = add(r1B15, r1B16);
            ir_expression *const r1B3D = less(r1B3A, r1B14);
            ir_expression *const r1B3E = expr(ir_unop_b2i, r1B3D);
            ir_expression *const r1B3F = expr(ir_unop_i2u, r1B3E);
            body.emit(assign(r1B15, add(r1B3C, r1B3F), 0x01));

            body.emit(assign(r1B14, r1B3A, 0x01));

         /* LOOP END */

         body.instructions = f1B36_parent_instructions;
         body.emit(f1B36);

         ir_expression *const r1B40 = lshift(r1B15, body.constant(int(16)));
         ir_expression *const r1B41 = rshift(r1B14, body.constant(int(16)));
         body.emit(assign(r1B15, bit_or(r1B40, r1B41), 0x01));

         ir_variable *const r1B42 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1B44 = lshift(r1B16, body.constant(int(16)));
         ir_expression *const r1B45 = lequal(r1B44, r1B15);
         ir_if *f1B43 = new(mem_ctx) ir_if(operand(r1B45).val);
         exec_list *const f1B43_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B43->then_instructions;

            body.emit(assign(r1B42, body.constant(65535u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B43->else_instructions;

            body.emit(assign(r1B42, expr(ir_binop_div, r1B15, r1B16), 0x01));


         body.instructions = f1B43_parent_instructions;
         body.emit(f1B43);

         /* END IF */

         body.emit(assign(r1B13, bit_or(r1B13, r1B42), 0x01));

         body.emit(assign(r1B12, r1B13, 0x01));


      body.instructions = f1B17_parent_instructions;
      body.emit(f1B17);

      /* END IF */

      ir_expression *const r1B46 = rshift(r1B12, body.constant(int(1)));
      ir_expression *const r1B47 = rshift(r1AB9, body.constant(int(1)));
      body.emit(assign(r1AB8, add(r1B46, r1B47), 0x01));

      body.emit(assign(r1AB7, body.constant(false), 0x01));


   body.instructions = f1B11_parent_instructions;
   body.emit(f1B11);

   /* END IF */

   body.emit(ret(r1AB8));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsqrt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1B48 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1B48);
   ir_variable *const r1B49 = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r1B4A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r1B4A);
   body.emit(assign(r1B4A, body.constant(0u), 0x01));

   ir_variable *const r1B4B = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1B4B, bit_and(swizzle_y(r1B48), body.constant(1048575u)), 0x01));

   ir_variable *const r1B4C = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1B4D = rshift(swizzle_y(r1B48), body.constant(int(20)));
   ir_expression *const r1B4E = bit_and(r1B4D, body.constant(2047u));
   body.emit(assign(r1B4C, expr(ir_unop_u2i, r1B4E), 0x01));

   ir_variable *const r1B4F = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r1B4F, rshift(swizzle_y(r1B48), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1B51 = equal(r1B4C, body.constant(int(2047)));
   ir_if *f1B50 = new(mem_ctx) ir_if(operand(r1B51).val);
   exec_list *const f1B50_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1B50->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1B53 = bit_or(r1B4B, swizzle_x(r1B48));
      ir_expression *const r1B54 = nequal(r1B53, body.constant(0u));
      ir_if *f1B52 = new(mem_ctx) ir_if(operand(r1B54).val);
      exec_list *const f1B52_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B52->then_instructions;

         ir_variable *const r1B55 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1B55, lshift(swizzle_x(r1B48), body.constant(int(12))), 0x01));

         ir_expression *const r1B56 = lshift(r1B4F, body.constant(int(31)));
         ir_expression *const r1B57 = bit_or(r1B56, body.constant(2143289344u));
         ir_expression *const r1B58 = lshift(swizzle_y(r1B48), body.constant(int(12)));
         ir_expression *const r1B59 = rshift(swizzle_x(r1B48), body.constant(int(20)));
         ir_expression *const r1B5A = bit_or(r1B58, r1B59);
         ir_expression *const r1B5B = rshift(r1B5A, body.constant(int(9)));
         ir_expression *const r1B5C = bit_or(r1B57, r1B5B);
         body.emit(assign(r1B49, expr(ir_unop_bitcast_u2f, r1B5C), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B52->else_instructions;

         ir_expression *const r1B5D = lshift(r1B4F, body.constant(int(31)));
         ir_expression *const r1B5E = add(r1B5D, body.constant(2139095040u));
         body.emit(assign(r1B49, expr(ir_unop_bitcast_u2f, r1B5E), 0x01));


      body.instructions = f1B52_parent_instructions;
      body.emit(f1B52);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1B50->else_instructions;

      ir_variable *const r1B5F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1B5F);
      ir_variable *const r1B60 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1B60);
      ir_expression *const r1B61 = lshift(r1B4B, body.constant(int(10)));
      ir_expression *const r1B62 = rshift(swizzle_x(r1B48), body.constant(int(22)));
      ir_expression *const r1B63 = bit_or(r1B61, r1B62);
      ir_expression *const r1B64 = lshift(swizzle_x(r1B48), body.constant(int(10)));
      ir_expression *const r1B65 = nequal(r1B64, body.constant(0u));
      ir_expression *const r1B66 = expr(ir_unop_b2i, r1B65);
      ir_expression *const r1B67 = expr(ir_unop_i2u, r1B66);
      body.emit(assign(r1B5F, bit_or(r1B63, r1B67), 0x01));

      body.emit(assign(r1B60, rshift(r1B4B, body.constant(int(22))), 0x01));

      body.emit(assign(r1B4A, r1B5F, 0x01));

      /* IF CONDITION */
      ir_expression *const r1B69 = nequal(r1B4C, body.constant(int(0)));
      ir_if *f1B68 = new(mem_ctx) ir_if(operand(r1B69).val);
      exec_list *const f1B68_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B68->then_instructions;

         body.emit(assign(r1B4A, bit_or(r1B5F, body.constant(1073741824u)), 0x01));


      body.instructions = f1B68_parent_instructions;
      body.emit(f1B68);

      /* END IF */

      ir_variable *const r1B6A = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r1B6A, add(r1B4C, body.constant(int(-897))), 0x01));

      ir_variable *const r1B6B = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r1B6B, r1B4A, 0x01));

      ir_variable *const r1B6C = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r1B6C, body.constant(true), 0x01));

      ir_variable *const r1B6D = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r1B6E = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
      body.emit(r1B6E);
      ir_expression *const r1B6F = expr(ir_unop_u2i, r1B4A);
      body.emit(assign(r1B6E, bit_and(r1B6F, body.constant(int(127))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1B71 = expr(ir_unop_i2u, r1B6A);
      ir_expression *const r1B72 = lequal(body.constant(253u), r1B71);
      ir_if *f1B70 = new(mem_ctx) ir_if(operand(r1B72).val);
      exec_list *const f1B70_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B70->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1B74 = less(body.constant(int(253)), r1B6A);
         ir_expression *const r1B75 = equal(r1B6A, body.constant(int(253)));
         ir_expression *const r1B76 = add(r1B4A, body.constant(64u));
         ir_expression *const r1B77 = expr(ir_unop_u2i, r1B76);
         ir_expression *const r1B78 = less(r1B77, body.constant(int(0)));
         ir_expression *const r1B79 = logic_and(r1B75, r1B78);
         ir_expression *const r1B7A = logic_or(r1B74, r1B79);
         ir_if *f1B73 = new(mem_ctx) ir_if(operand(r1B7A).val);
         exec_list *const f1B73_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B73->then_instructions;

            ir_expression *const r1B7B = lshift(r1B4F, body.constant(int(31)));
            body.emit(assign(r1B6D, add(r1B7B, body.constant(2139095040u)), 0x01));

            body.emit(assign(r1B6C, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B73->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1B7D = less(r1B6A, body.constant(int(0)));
            ir_if *f1B7C = new(mem_ctx) ir_if(operand(r1B7D).val);
            exec_list *const f1B7C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1B7C->then_instructions;

               ir_variable *const r1B7E = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1B7E, neg(r1B6A), 0x01));

               ir_variable *const r1B7F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r1B7F);
               /* IF CONDITION */
               ir_expression *const r1B81 = equal(r1B7E, body.constant(int(0)));
               ir_if *f1B80 = new(mem_ctx) ir_if(operand(r1B81).val);
               exec_list *const f1B80_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1B80->then_instructions;

                  body.emit(assign(r1B7F, r1B4A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1B80->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1B83 = less(r1B7E, body.constant(int(32)));
                  ir_if *f1B82 = new(mem_ctx) ir_if(operand(r1B83).val);
                  exec_list *const f1B82_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1B82->then_instructions;

                     ir_expression *const r1B84 = rshift(r1B4A, r1B7E);
                     ir_expression *const r1B85 = neg(r1B7E);
                     ir_expression *const r1B86 = bit_and(r1B85, body.constant(int(31)));
                     ir_expression *const r1B87 = lshift(r1B4A, r1B86);
                     ir_expression *const r1B88 = nequal(r1B87, body.constant(0u));
                     ir_expression *const r1B89 = expr(ir_unop_b2i, r1B88);
                     ir_expression *const r1B8A = expr(ir_unop_i2u, r1B89);
                     body.emit(assign(r1B7F, bit_or(r1B84, r1B8A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1B82->else_instructions;

                     ir_expression *const r1B8B = nequal(r1B4A, body.constant(0u));
                     ir_expression *const r1B8C = expr(ir_unop_b2i, r1B8B);
                     body.emit(assign(r1B7F, expr(ir_unop_i2u, r1B8C), 0x01));


                  body.instructions = f1B82_parent_instructions;
                  body.emit(f1B82);

                  /* END IF */


               body.instructions = f1B80_parent_instructions;
               body.emit(f1B80);

               /* END IF */

               body.emit(assign(r1B6B, r1B7F, 0x01));

               body.emit(assign(r1B6A, body.constant(int(0)), 0x01));

               ir_expression *const r1B8D = expr(ir_unop_u2i, r1B7F);
               body.emit(assign(r1B6E, bit_and(r1B8D, body.constant(int(127))), 0x01));


            body.instructions = f1B7C_parent_instructions;
            body.emit(f1B7C);

            /* END IF */


         body.instructions = f1B73_parent_instructions;
         body.emit(f1B73);

         /* END IF */


      body.instructions = f1B70_parent_instructions;
      body.emit(f1B70);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1B8E = new(mem_ctx) ir_if(operand(r1B6C).val);
      exec_list *const f1B8E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B8E->then_instructions;

         ir_expression *const r1B8F = add(r1B6B, body.constant(64u));
         body.emit(assign(r1B6B, rshift(r1B8F, body.constant(int(7))), 0x01));

         ir_expression *const r1B90 = bit_xor(r1B6E, body.constant(int(64)));
         ir_expression *const r1B91 = equal(r1B90, body.constant(int(0)));
         ir_expression *const r1B92 = expr(ir_unop_b2i, r1B91);
         ir_expression *const r1B93 = expr(ir_unop_i2u, r1B92);
         ir_expression *const r1B94 = bit_and(r1B93, body.constant(1u));
         ir_expression *const r1B95 = expr(ir_unop_bit_not, r1B94);
         body.emit(assign(r1B6B, bit_and(r1B6B, r1B95), 0x01));

         /* IF CONDITION */
         ir_expression *const r1B97 = equal(r1B6B, body.constant(0u));
         ir_if *f1B96 = new(mem_ctx) ir_if(operand(r1B97).val);
         exec_list *const f1B96_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B96->then_instructions;

            body.emit(assign(r1B6A, body.constant(int(0)), 0x01));


         body.instructions = f1B96_parent_instructions;
         body.emit(f1B96);

         /* END IF */

         ir_expression *const r1B98 = lshift(r1B4F, body.constant(int(31)));
         ir_expression *const r1B99 = expr(ir_unop_i2u, r1B6A);
         ir_expression *const r1B9A = lshift(r1B99, body.constant(int(23)));
         ir_expression *const r1B9B = add(r1B98, r1B9A);
         body.emit(assign(r1B6D, add(r1B9B, r1B6B), 0x01));

         body.emit(assign(r1B6C, body.constant(false), 0x01));


      body.instructions = f1B8E_parent_instructions;
      body.emit(f1B8E);

      /* END IF */

      body.emit(assign(r1B49, expr(ir_unop_bitcast_u2f, r1B6D), 0x01));


   body.instructions = f1B50_parent_instructions;
   body.emit(f1B50);

   /* END IF */

   ir_variable *const r1B9C = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1B9C, body.constant(true), 0x01));

   ir_variable *const r1B9D = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1B9E = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r1B9E);
   ir_variable *const r1B9F = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r1B9F);
   ir_variable *const r1BA0 = body.make_temp(glsl_type::uint_type, "floatBitsToUint_retval");
   ir_expression *const r1BA1 = expr(ir_unop_sqrt, r1B49);
   body.emit(assign(r1BA0, expr(ir_unop_bitcast_f2u, r1BA1), 0x01));

   ir_variable *const r1BA2 = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r1BA2, bit_and(r1BA0, body.constant(8388607u)), 0x01));

   body.emit(assign(r1B9F, r1BA2, 0x01));

   ir_variable *const r1BA3 = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r1BA4 = rshift(r1BA0, body.constant(int(23)));
   ir_expression *const r1BA5 = bit_and(r1BA4, body.constant(255u));
   body.emit(assign(r1BA3, expr(ir_unop_u2i, r1BA5), 0x01));

   body.emit(assign(r1B9E, r1BA3, 0x01));

   ir_variable *const r1BA6 = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r1BA6, rshift(r1BA0, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1BA8 = equal(r1BA3, body.constant(int(255)));
   ir_if *f1BA7 = new(mem_ctx) ir_if(operand(r1BA8).val);
   exec_list *const f1BA7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1BA7->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1BAA = nequal(r1BA2, body.constant(0u));
      ir_if *f1BA9 = new(mem_ctx) ir_if(operand(r1BAA).val);
      exec_list *const f1BA9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BA9->then_instructions;

         ir_variable *const r1BAB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1BAB, lshift(r1BA0, body.constant(int(9))), 0x01));

         ir_variable *const r1BAC = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         ir_expression *const r1BAD = lshift(r1BAB, body.constant(int(20)));
         body.emit(assign(r1BAC, bit_or(r1BAD, body.constant(0u)), 0x01));

         ir_expression *const r1BAE = rshift(r1BAB, body.constant(int(12)));
         ir_expression *const r1BAF = lshift(r1BA6, body.constant(int(31)));
         ir_expression *const r1BB0 = bit_or(r1BAF, body.constant(2146959360u));
         body.emit(assign(r1BAC, bit_or(r1BAE, r1BB0), 0x02));

         body.emit(assign(r1B9D, r1BAC, 0x03));

         body.emit(assign(r1B9C, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1BA9->else_instructions;

         ir_variable *const r1BB1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1BB1);
         ir_expression *const r1BB2 = lshift(r1BA6, body.constant(int(31)));
         body.emit(assign(r1BB1, add(r1BB2, body.constant(2146435072u)), 0x02));

         body.emit(assign(r1BB1, body.constant(0u), 0x01));

         body.emit(assign(r1B9D, r1BB1, 0x03));

         body.emit(assign(r1B9C, body.constant(false), 0x01));


      body.instructions = f1BA9_parent_instructions;
      body.emit(f1BA9);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1BA7->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1BB4 = equal(r1BA3, body.constant(int(0)));
      ir_if *f1BB3 = new(mem_ctx) ir_if(operand(r1BB4).val);
      exec_list *const f1BB3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BB3->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1BB6 = equal(r1BA2, body.constant(0u));
         ir_if *f1BB5 = new(mem_ctx) ir_if(operand(r1BB6).val);
         exec_list *const f1BB5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BB5->then_instructions;

            ir_variable *const r1BB7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1BB7);
            body.emit(assign(r1BB7, lshift(r1BA6, body.constant(int(31))), 0x02));

            body.emit(assign(r1BB7, body.constant(0u), 0x01));

            body.emit(assign(r1B9D, r1BB7, 0x03));

            body.emit(assign(r1B9C, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1BB5->else_instructions;

            ir_variable *const r1BB8 = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r1BB8, r1BA3, 0x01));

            ir_variable *const r1BB9 = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r1BB9, r1BA2, 0x01));

            ir_variable *const r1BBA = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r1BBA, r1BA2, 0x01));

            ir_variable *const r1BBB = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r1BBC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r1BBC);
            /* IF CONDITION */
            ir_expression *const r1BBE = equal(r1BA2, body.constant(0u));
            ir_if *f1BBD = new(mem_ctx) ir_if(operand(r1BBE).val);
            exec_list *const f1BBD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1BBD->then_instructions;

               body.emit(assign(r1BBB, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1BBD->else_instructions;

               body.emit(assign(r1BBC, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r1BC0 = bit_and(r1BA2, body.constant(4294901760u));
               ir_expression *const r1BC1 = equal(r1BC0, body.constant(0u));
               ir_if *f1BBF = new(mem_ctx) ir_if(operand(r1BC1).val);
               exec_list *const f1BBF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BBF->then_instructions;

                  body.emit(assign(r1BBC, body.constant(int(16)), 0x01));

                  body.emit(assign(r1BBA, lshift(r1BA2, body.constant(int(16))), 0x01));


               body.instructions = f1BBF_parent_instructions;
               body.emit(f1BBF);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1BC3 = bit_and(r1BBA, body.constant(4278190080u));
               ir_expression *const r1BC4 = equal(r1BC3, body.constant(0u));
               ir_if *f1BC2 = new(mem_ctx) ir_if(operand(r1BC4).val);
               exec_list *const f1BC2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BC2->then_instructions;

                  body.emit(assign(r1BBC, add(r1BBC, body.constant(int(8))), 0x01));

                  body.emit(assign(r1BBA, lshift(r1BBA, body.constant(int(8))), 0x01));


               body.instructions = f1BC2_parent_instructions;
               body.emit(f1BC2);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1BC6 = bit_and(r1BBA, body.constant(4026531840u));
               ir_expression *const r1BC7 = equal(r1BC6, body.constant(0u));
               ir_if *f1BC5 = new(mem_ctx) ir_if(operand(r1BC7).val);
               exec_list *const f1BC5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BC5->then_instructions;

                  body.emit(assign(r1BBC, add(r1BBC, body.constant(int(4))), 0x01));

                  body.emit(assign(r1BBA, lshift(r1BBA, body.constant(int(4))), 0x01));


               body.instructions = f1BC5_parent_instructions;
               body.emit(f1BC5);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1BC9 = bit_and(r1BBA, body.constant(3221225472u));
               ir_expression *const r1BCA = equal(r1BC9, body.constant(0u));
               ir_if *f1BC8 = new(mem_ctx) ir_if(operand(r1BCA).val);
               exec_list *const f1BC8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BC8->then_instructions;

                  body.emit(assign(r1BBC, add(r1BBC, body.constant(int(2))), 0x01));

                  body.emit(assign(r1BBA, lshift(r1BBA, body.constant(int(2))), 0x01));


               body.instructions = f1BC8_parent_instructions;
               body.emit(f1BC8);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1BCC = bit_and(r1BBA, body.constant(2147483648u));
               ir_expression *const r1BCD = equal(r1BCC, body.constant(0u));
               ir_if *f1BCB = new(mem_ctx) ir_if(operand(r1BCD).val);
               exec_list *const f1BCB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BCB->then_instructions;

                  body.emit(assign(r1BBC, add(r1BBC, body.constant(int(1))), 0x01));


               body.instructions = f1BCB_parent_instructions;
               body.emit(f1BCB);

               /* END IF */

               body.emit(assign(r1BBB, r1BBC, 0x01));


            body.instructions = f1BBD_parent_instructions;
            body.emit(f1BBD);

            /* END IF */

            ir_variable *const r1BCE = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r1BCE, add(r1BBB, body.constant(int(-8))), 0x01));

            body.emit(assign(r1BB9, lshift(r1BA2, r1BCE), 0x01));

            body.emit(assign(r1BB8, sub(body.constant(int(1)), r1BCE), 0x01));

            body.emit(assign(r1B9F, r1BB9, 0x01));

            body.emit(assign(r1B9E, add(r1BB8, body.constant(int(-1))), 0x01));


         body.instructions = f1BB5_parent_instructions;
         body.emit(f1BB5);

         /* END IF */


      body.instructions = f1BB3_parent_instructions;
      body.emit(f1BB3);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1BCF = new(mem_ctx) ir_if(operand(r1B9C).val);
      exec_list *const f1BCF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BCF->then_instructions;

         ir_variable *const r1BD0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1BD0);
         ir_expression *const r1BD1 = lshift(r1BA6, body.constant(int(31)));
         ir_expression *const r1BD2 = add(r1B9E, body.constant(int(896)));
         ir_expression *const r1BD3 = expr(ir_unop_i2u, r1BD2);
         ir_expression *const r1BD4 = lshift(r1BD3, body.constant(int(20)));
         ir_expression *const r1BD5 = add(r1BD1, r1BD4);
         ir_expression *const r1BD6 = rshift(r1B9F, body.constant(int(3)));
         body.emit(assign(r1BD0, add(r1BD5, r1BD6), 0x02));

         ir_expression *const r1BD7 = lshift(r1B9F, body.constant(int(29)));
         body.emit(assign(r1BD0, bit_or(r1BD7, body.constant(0u)), 0x01));

         body.emit(assign(r1B9D, r1BD0, 0x03));

         body.emit(assign(r1B9C, body.constant(false), 0x01));


      body.instructions = f1BCF_parent_instructions;
      body.emit(f1BCF);

      /* END IF */


   body.instructions = f1BA7_parent_instructions;
   body.emit(f1BA7);

   /* END IF */

   body.emit(ret(r1B9D));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1BD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1BD8);
   ir_variable *const r1BD9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1BD9);
   ir_variable *const r1BDA = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1BDA);
   ir_variable *const r1BDB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1BDB);
   ir_variable *const r1BDC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1BDC);
   ir_variable *const r1BDD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1BDD);
   ir_variable *const r1BDE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1BDE);
   ir_variable *const r1BDF = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1BE0 = neg(r1BDA);
   body.emit(assign(r1BDF, bit_and(r1BE0, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1BE2 = equal(r1BDA, body.constant(int(0)));
   ir_if *f1BE1 = new(mem_ctx) ir_if(operand(r1BE2).val);
   exec_list *const f1BE1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1BE1->then_instructions;

      body.emit(assign(r1BDE, r1BD8, 0x01));

      body.emit(assign(r1BDD, r1BD9, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1BE1->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1BE4 = less(r1BDA, body.constant(int(32)));
      ir_if *f1BE3 = new(mem_ctx) ir_if(operand(r1BE4).val);
      exec_list *const f1BE3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BE3->then_instructions;

         ir_expression *const r1BE5 = lshift(r1BD8, r1BDA);
         ir_expression *const r1BE6 = rshift(r1BD9, r1BDF);
         body.emit(assign(r1BDE, bit_or(r1BE5, r1BE6), 0x01));

         body.emit(assign(r1BDD, lshift(r1BD9, r1BDA), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1BE3->else_instructions;

         ir_variable *const r1BE7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1BE9 = less(r1BDA, body.constant(int(64)));
         ir_if *f1BE8 = new(mem_ctx) ir_if(operand(r1BE9).val);
         exec_list *const f1BE8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BE8->then_instructions;

            ir_expression *const r1BEA = add(r1BDA, body.constant(int(-32)));
            body.emit(assign(r1BE7, lshift(r1BD9, r1BEA), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1BE8->else_instructions;

            body.emit(assign(r1BE7, body.constant(0u), 0x01));


         body.instructions = f1BE8_parent_instructions;
         body.emit(f1BE8);

         /* END IF */

         body.emit(assign(r1BDE, r1BE7, 0x01));

         body.emit(assign(r1BDD, body.constant(0u), 0x01));


      body.instructions = f1BE3_parent_instructions;
      body.emit(f1BE3);

      /* END IF */


   body.instructions = f1BE1_parent_instructions;
   body.emit(f1BE1);

   /* END IF */

   body.emit(assign(r1BDB, r1BDE, 0x01));

   body.emit(assign(r1BDC, r1BDD, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
uint_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1BEB = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1BEB);
   ir_variable *const r1BEC = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r1BEE = equal(r1BEB, body.constant(0u));
   ir_if *f1BED = new(mem_ctx) ir_if(operand(r1BEE).val);
   exec_list *const f1BED_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1BED->then_instructions;

      body.emit(assign(r1BEC, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1BED->else_instructions;

      ir_variable *const r1BEF = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1BEF, r1BEB, 0x01));

      ir_variable *const r1BF0 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1BF1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1BF1);
      /* IF CONDITION */
      ir_expression *const r1BF3 = equal(r1BEB, body.constant(0u));
      ir_if *f1BF2 = new(mem_ctx) ir_if(operand(r1BF3).val);
      exec_list *const f1BF2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BF2->then_instructions;

         body.emit(assign(r1BF0, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1BF2->else_instructions;

         body.emit(assign(r1BF1, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1BF5 = bit_and(r1BEB, body.constant(4294901760u));
         ir_expression *const r1BF6 = equal(r1BF5, body.constant(0u));
         ir_if *f1BF4 = new(mem_ctx) ir_if(operand(r1BF6).val);
         exec_list *const f1BF4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BF4->then_instructions;

            body.emit(assign(r1BF1, body.constant(int(16)), 0x01));

            body.emit(assign(r1BEF, lshift(r1BEB, body.constant(int(16))), 0x01));


         body.instructions = f1BF4_parent_instructions;
         body.emit(f1BF4);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1BF8 = bit_and(r1BEF, body.constant(4278190080u));
         ir_expression *const r1BF9 = equal(r1BF8, body.constant(0u));
         ir_if *f1BF7 = new(mem_ctx) ir_if(operand(r1BF9).val);
         exec_list *const f1BF7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BF7->then_instructions;

            body.emit(assign(r1BF1, add(r1BF1, body.constant(int(8))), 0x01));

            body.emit(assign(r1BEF, lshift(r1BEF, body.constant(int(8))), 0x01));


         body.instructions = f1BF7_parent_instructions;
         body.emit(f1BF7);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1BFB = bit_and(r1BEF, body.constant(4026531840u));
         ir_expression *const r1BFC = equal(r1BFB, body.constant(0u));
         ir_if *f1BFA = new(mem_ctx) ir_if(operand(r1BFC).val);
         exec_list *const f1BFA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BFA->then_instructions;

            body.emit(assign(r1BF1, add(r1BF1, body.constant(int(4))), 0x01));

            body.emit(assign(r1BEF, lshift(r1BEF, body.constant(int(4))), 0x01));


         body.instructions = f1BFA_parent_instructions;
         body.emit(f1BFA);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1BFE = bit_and(r1BEF, body.constant(3221225472u));
         ir_expression *const r1BFF = equal(r1BFE, body.constant(0u));
         ir_if *f1BFD = new(mem_ctx) ir_if(operand(r1BFF).val);
         exec_list *const f1BFD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BFD->then_instructions;

            body.emit(assign(r1BF1, add(r1BF1, body.constant(int(2))), 0x01));

            body.emit(assign(r1BEF, lshift(r1BEF, body.constant(int(2))), 0x01));


         body.instructions = f1BFD_parent_instructions;
         body.emit(f1BFD);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1C01 = bit_and(r1BEF, body.constant(2147483648u));
         ir_expression *const r1C02 = equal(r1C01, body.constant(0u));
         ir_if *f1C00 = new(mem_ctx) ir_if(operand(r1C02).val);
         exec_list *const f1C00_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C00->then_instructions;

            body.emit(assign(r1BF1, add(r1BF1, body.constant(int(1))), 0x01));


         body.instructions = f1C00_parent_instructions;
         body.emit(f1C00);

         /* END IF */

         body.emit(assign(r1BF0, r1BF1, 0x01));


      body.instructions = f1BF2_parent_instructions;
      body.emit(f1BF2);

      /* END IF */

      ir_variable *const r1C03 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r1C03, add(r1BF0, body.constant(int(21))), 0x01));

      ir_variable *const r1C04 = body.make_temp(glsl_type::uint_type, "a0");
      body.emit(assign(r1C04, body.constant(0u), 0x01));

      ir_variable *const r1C05 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1C05);
      ir_variable *const r1C06 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1C06);
      ir_variable *const r1C07 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r1C08 = neg(r1C03);
      body.emit(assign(r1C07, bit_and(r1C08, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1C0A = equal(r1C03, body.constant(int(0)));
      ir_if *f1C09 = new(mem_ctx) ir_if(operand(r1C0A).val);
      exec_list *const f1C09_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C09->then_instructions;

         body.emit(assign(r1C06, body.constant(0u), 0x01));

         body.emit(assign(r1C05, r1BEB, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C09->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1C0C = less(r1C03, body.constant(int(32)));
         ir_if *f1C0B = new(mem_ctx) ir_if(operand(r1C0C).val);
         exec_list *const f1C0B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C0B->then_instructions;

            ir_expression *const r1C0D = rshift(r1BEB, r1C07);
            body.emit(assign(r1C06, bit_or(body.constant(0u), r1C0D), 0x01));

            body.emit(assign(r1C05, lshift(r1BEB, r1C03), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C0B->else_instructions;

            ir_variable *const r1C0E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1C10 = less(r1C03, body.constant(int(64)));
            ir_if *f1C0F = new(mem_ctx) ir_if(operand(r1C10).val);
            exec_list *const f1C0F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C0F->then_instructions;

               ir_expression *const r1C11 = add(r1C03, body.constant(int(-32)));
               body.emit(assign(r1C0E, lshift(r1BEB, r1C11), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C0F->else_instructions;

               body.emit(assign(r1C0E, body.constant(0u), 0x01));


            body.instructions = f1C0F_parent_instructions;
            body.emit(f1C0F);

            /* END IF */

            body.emit(assign(r1C06, r1C0E, 0x01));

            body.emit(assign(r1C05, body.constant(0u), 0x01));


         body.instructions = f1C0B_parent_instructions;
         body.emit(f1C0B);

         /* END IF */


      body.instructions = f1C09_parent_instructions;
      body.emit(f1C09);

      /* END IF */

      ir_variable *const r1C12 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1C12);
      ir_expression *const r1C13 = sub(body.constant(int(1074)), r1C03);
      ir_expression *const r1C14 = expr(ir_unop_i2u, r1C13);
      ir_expression *const r1C15 = lshift(r1C14, body.constant(int(20)));
      body.emit(assign(r1C12, add(r1C15, r1C06), 0x02));

      body.emit(assign(r1C12, r1C05, 0x01));

      body.emit(assign(r1BEC, r1C12, 0x03));


   body.instructions = f1BED_parent_instructions;
   body.emit(f1BED);

   /* END IF */

   body.emit(ret(r1BEC));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_uint(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1C16 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1C16);
   ir_variable *const r1C17 = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1C18 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r1C18);
   ir_variable *const r1C19 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r1C19);
   ir_variable *const r1C1A = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r1C1A, swizzle_x(r1C16), 0x01));

   body.emit(assign(r1C19, r1C1A, 0x01));

   ir_variable *const r1C1B = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1C1B, bit_and(swizzle_y(r1C16), body.constant(1048575u)), 0x01));

   body.emit(assign(r1C18, r1C1B, 0x01));

   ir_variable *const r1C1C = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1C1D = rshift(swizzle_y(r1C16), body.constant(int(20)));
   ir_expression *const r1C1E = bit_and(r1C1D, body.constant(2047u));
   body.emit(assign(r1C1C, expr(ir_unop_u2i, r1C1E), 0x01));

   ir_variable *const r1C1F = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r1C1F, rshift(swizzle_y(r1C16), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1C21 = nequal(r1C1F, body.constant(0u));
   ir_if *f1C20 = new(mem_ctx) ir_if(operand(r1C21).val);
   exec_list *const f1C20_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C20->then_instructions;

      body.emit(assign(r1C17, body.constant(0u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C20->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1C23 = equal(r1C1C, body.constant(int(2047)));
      ir_expression *const r1C24 = bit_or(r1C1B, swizzle_x(r1C16));
      ir_expression *const r1C25 = nequal(r1C24, body.constant(0u));
      ir_expression *const r1C26 = logic_and(r1C23, r1C25);
      ir_if *f1C22 = new(mem_ctx) ir_if(operand(r1C26).val);
      exec_list *const f1C22_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C22->then_instructions;

         body.emit(assign(r1C17, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C22->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1C28 = nequal(r1C1C, body.constant(int(0)));
         ir_if *f1C27 = new(mem_ctx) ir_if(operand(r1C28).val);
         exec_list *const f1C27_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C27->then_instructions;

            body.emit(assign(r1C18, bit_or(r1C1B, body.constant(1048576u)), 0x01));


         body.instructions = f1C27_parent_instructions;
         body.emit(f1C27);

         /* END IF */

         ir_variable *const r1C29 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1C29, sub(body.constant(int(1063)), r1C1C), 0x01));

         /* IF CONDITION */
         ir_expression *const r1C2B = less(body.constant(int(0)), r1C29);
         ir_if *f1C2A = new(mem_ctx) ir_if(operand(r1C2B).val);
         exec_list *const f1C2A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C2A->then_instructions;

            ir_variable *const r1C2C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1C2C);
            ir_variable *const r1C2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1C2D);
            ir_variable *const r1C2E = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r1C2F = neg(r1C29);
            body.emit(assign(r1C2E, bit_and(r1C2F, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1C31 = equal(r1C29, body.constant(int(0)));
            ir_if *f1C30 = new(mem_ctx) ir_if(operand(r1C31).val);
            exec_list *const f1C30_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C30->then_instructions;

               body.emit(assign(r1C2C, r1C1A, 0x01));

               body.emit(assign(r1C2D, r1C18, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C30->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1C33 = less(r1C29, body.constant(int(32)));
               ir_if *f1C32 = new(mem_ctx) ir_if(operand(r1C33).val);
               exec_list *const f1C32_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C32->then_instructions;

                  ir_expression *const r1C34 = lshift(r1C18, r1C2E);
                  ir_expression *const r1C35 = rshift(swizzle_x(r1C16), r1C29);
                  ir_expression *const r1C36 = bit_or(r1C34, r1C35);
                  ir_expression *const r1C37 = lshift(swizzle_x(r1C16), r1C2E);
                  ir_expression *const r1C38 = nequal(r1C37, body.constant(0u));
                  ir_expression *const r1C39 = expr(ir_unop_b2i, r1C38);
                  ir_expression *const r1C3A = expr(ir_unop_i2u, r1C39);
                  body.emit(assign(r1C2C, bit_or(r1C36, r1C3A), 0x01));

                  body.emit(assign(r1C2D, rshift(r1C18, r1C29), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C32->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1C3C = equal(r1C29, body.constant(int(32)));
                  ir_if *f1C3B = new(mem_ctx) ir_if(operand(r1C3C).val);
                  exec_list *const f1C3B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C3B->then_instructions;

                     ir_expression *const r1C3D = nequal(swizzle_x(r1C16), body.constant(0u));
                     ir_expression *const r1C3E = expr(ir_unop_b2i, r1C3D);
                     ir_expression *const r1C3F = expr(ir_unop_i2u, r1C3E);
                     body.emit(assign(r1C2C, bit_or(r1C18, r1C3F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1C3B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1C41 = less(r1C29, body.constant(int(64)));
                     ir_if *f1C40 = new(mem_ctx) ir_if(operand(r1C41).val);
                     exec_list *const f1C40_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1C40->then_instructions;

                        ir_expression *const r1C42 = bit_and(r1C29, body.constant(int(31)));
                        ir_expression *const r1C43 = rshift(r1C18, r1C42);
                        ir_expression *const r1C44 = lshift(r1C18, r1C2E);
                        ir_expression *const r1C45 = bit_or(r1C44, swizzle_x(r1C16));
                        ir_expression *const r1C46 = nequal(r1C45, body.constant(0u));
                        ir_expression *const r1C47 = expr(ir_unop_b2i, r1C46);
                        ir_expression *const r1C48 = expr(ir_unop_i2u, r1C47);
                        body.emit(assign(r1C2C, bit_or(r1C43, r1C48), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1C40->else_instructions;

                        ir_expression *const r1C49 = bit_or(r1C18, swizzle_x(r1C16));
                        ir_expression *const r1C4A = nequal(r1C49, body.constant(0u));
                        ir_expression *const r1C4B = expr(ir_unop_b2i, r1C4A);
                        body.emit(assign(r1C2C, expr(ir_unop_i2u, r1C4B), 0x01));


                     body.instructions = f1C40_parent_instructions;
                     body.emit(f1C40);

                     /* END IF */


                  body.instructions = f1C3B_parent_instructions;
                  body.emit(f1C3B);

                  /* END IF */

                  body.emit(assign(r1C2D, body.constant(0u), 0x01));


               body.instructions = f1C32_parent_instructions;
               body.emit(f1C32);

               /* END IF */


            body.instructions = f1C30_parent_instructions;
            body.emit(f1C30);

            /* END IF */

            body.emit(assign(r1C18, r1C2D, 0x01));

            body.emit(assign(r1C19, r1C2C, 0x01));


         body.instructions = f1C2A_parent_instructions;
         body.emit(f1C2A);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1C4D = bit_and(r1C18, body.constant(4294963200u));
         ir_expression *const r1C4E = nequal(r1C4D, body.constant(0u));
         ir_if *f1C4C = new(mem_ctx) ir_if(operand(r1C4E).val);
         exec_list *const f1C4C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C4C->then_instructions;

            ir_variable *const r1C4F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1C51 = nequal(r1C1F, body.constant(0u));
            ir_if *f1C50 = new(mem_ctx) ir_if(operand(r1C51).val);
            exec_list *const f1C50_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C50->then_instructions;

               body.emit(assign(r1C4F, body.constant(0u), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C50->else_instructions;

               body.emit(assign(r1C4F, body.constant(4294967295u), 0x01));


            body.instructions = f1C50_parent_instructions;
            body.emit(f1C50);

            /* END IF */

            body.emit(assign(r1C17, r1C4F, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C4C->else_instructions;

            ir_variable *const r1C52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1C52);
            ir_variable *const r1C53 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1C53);
            ir_expression *const r1C54 = lshift(r1C18, body.constant(int(20)));
            ir_expression *const r1C55 = rshift(r1C19, body.constant(int(12)));
            body.emit(assign(r1C52, bit_or(r1C54, r1C55), 0x01));

            body.emit(assign(r1C53, rshift(r1C18, body.constant(int(12))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1C57 = nequal(r1C1F, body.constant(0u));
            ir_expression *const r1C58 = nequal(r1C52, body.constant(0u));
            ir_expression *const r1C59 = logic_and(r1C57, r1C58);
            ir_if *f1C56 = new(mem_ctx) ir_if(operand(r1C59).val);
            exec_list *const f1C56_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C56->then_instructions;

               ir_variable *const r1C5A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1C5C = nequal(r1C1F, body.constant(0u));
               ir_if *f1C5B = new(mem_ctx) ir_if(operand(r1C5C).val);
               exec_list *const f1C5B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C5B->then_instructions;

                  body.emit(assign(r1C5A, body.constant(0u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C5B->else_instructions;

                  body.emit(assign(r1C5A, body.constant(4294967295u), 0x01));


               body.instructions = f1C5B_parent_instructions;
               body.emit(f1C5B);

               /* END IF */

               body.emit(assign(r1C17, r1C5A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C56->else_instructions;

               body.emit(assign(r1C17, r1C52, 0x01));


            body.instructions = f1C56_parent_instructions;
            body.emit(f1C56);

            /* END IF */


         body.instructions = f1C4C_parent_instructions;
         body.emit(f1C4C);

         /* END IF */


      body.instructions = f1C22_parent_instructions;
      body.emit(f1C22);

      /* END IF */


   body.instructions = f1C20_parent_instructions;
   body.emit(f1C20);

   /* END IF */

   body.emit(ret(r1C17));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ftrunc64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1C5D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1C5D);
   ir_variable *const r1C5E = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1C5F = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1C60 = rshift(swizzle_y(r1C5D), body.constant(int(20)));
   ir_expression *const r1C61 = bit_and(r1C60, body.constant(2047u));
   ir_expression *const r1C62 = expr(ir_unop_u2i, r1C61);
   body.emit(assign(r1C5F, add(r1C62, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1C64 = less(r1C5F, body.constant(int(0)));
   ir_if *f1C63 = new(mem_ctx) ir_if(operand(r1C64).val);
   exec_list *const f1C63_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C63->then_instructions;

      body.emit(assign(r1C5E, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C63->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1C66 = greater(r1C5F, body.constant(int(52)));
      ir_if *f1C65 = new(mem_ctx) ir_if(operand(r1C66).val);
      exec_list *const f1C65_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C65->then_instructions;

         body.emit(assign(r1C5E, r1C5D, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C65->else_instructions;

         ir_variable *const r1C67 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1C67, sub(body.constant(int(52)), r1C5F), 0x01));

         ir_variable *const r1C68 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1C6A = gequal(r1C67, body.constant(int(32)));
         ir_if *f1C69 = new(mem_ctx) ir_if(operand(r1C6A).val);
         exec_list *const f1C69_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C69->then_instructions;

            body.emit(assign(r1C68, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C69->else_instructions;

            body.emit(assign(r1C68, lshift(body.constant(4294967295u), r1C67), 0x01));


         body.instructions = f1C69_parent_instructions;
         body.emit(f1C69);

         /* END IF */

         ir_variable *const r1C6B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1C6D = less(r1C67, body.constant(int(33)));
         ir_if *f1C6C = new(mem_ctx) ir_if(operand(r1C6D).val);
         exec_list *const f1C6C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C6C->then_instructions;

            body.emit(assign(r1C6B, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C6C->else_instructions;

            ir_expression *const r1C6E = add(r1C67, body.constant(int(-32)));
            body.emit(assign(r1C6B, lshift(body.constant(4294967295u), r1C6E), 0x01));


         body.instructions = f1C6C_parent_instructions;
         body.emit(f1C6C);

         /* END IF */

         ir_variable *const r1C6F = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r1C6F, bit_and(r1C68, swizzle_x(r1C5D)), 0x01));

         body.emit(assign(r1C6F, bit_and(r1C6B, swizzle_y(r1C5D)), 0x02));

         body.emit(assign(r1C5E, r1C6F, 0x03));


      body.instructions = f1C65_parent_instructions;
      body.emit(f1C65);

      /* END IF */


   body.instructions = f1C63_parent_instructions;
   body.emit(f1C63);

   /* END IF */

   body.emit(ret(r1C5E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffloor64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1C70 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1C70);
   ir_variable *const r1C71 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1C72 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1C73 = rshift(swizzle_y(r1C70), body.constant(int(20)));
   ir_expression *const r1C74 = bit_and(r1C73, body.constant(2047u));
   ir_expression *const r1C75 = expr(ir_unop_u2i, r1C74);
   body.emit(assign(r1C72, add(r1C75, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1C77 = less(r1C72, body.constant(int(0)));
   ir_if *f1C76 = new(mem_ctx) ir_if(operand(r1C77).val);
   exec_list *const f1C76_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C76->then_instructions;

      body.emit(assign(r1C71, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C76->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1C79 = greater(r1C72, body.constant(int(52)));
      ir_if *f1C78 = new(mem_ctx) ir_if(operand(r1C79).val);
      exec_list *const f1C78_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C78->then_instructions;

         body.emit(assign(r1C71, r1C70, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C78->else_instructions;

         ir_variable *const r1C7A = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1C7A, sub(body.constant(int(52)), r1C72), 0x01));

         ir_variable *const r1C7B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1C7D = gequal(r1C7A, body.constant(int(32)));
         ir_if *f1C7C = new(mem_ctx) ir_if(operand(r1C7D).val);
         exec_list *const f1C7C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C7C->then_instructions;

            body.emit(assign(r1C7B, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C7C->else_instructions;

            body.emit(assign(r1C7B, lshift(body.constant(4294967295u), r1C7A), 0x01));


         body.instructions = f1C7C_parent_instructions;
         body.emit(f1C7C);

         /* END IF */

         ir_variable *const r1C7E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1C80 = less(r1C7A, body.constant(int(33)));
         ir_if *f1C7F = new(mem_ctx) ir_if(operand(r1C80).val);
         exec_list *const f1C7F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C7F->then_instructions;

            body.emit(assign(r1C7E, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C7F->else_instructions;

            ir_expression *const r1C81 = add(r1C7A, body.constant(int(-32)));
            body.emit(assign(r1C7E, lshift(body.constant(4294967295u), r1C81), 0x01));


         body.instructions = f1C7F_parent_instructions;
         body.emit(f1C7F);

         /* END IF */

         ir_variable *const r1C82 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r1C82, bit_and(r1C7B, swizzle_x(r1C70)), 0x01));

         body.emit(assign(r1C82, bit_and(r1C7E, swizzle_y(r1C70)), 0x02));

         body.emit(assign(r1C71, r1C82, 0x03));


      body.instructions = f1C78_parent_instructions;
      body.emit(f1C78);

      /* END IF */


   body.instructions = f1C76_parent_instructions;
   body.emit(f1C76);

   /* END IF */

   ir_variable *const r1C83 = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r1C84 = rshift(swizzle_y(r1C70), body.constant(int(31)));
   ir_expression *const r1C85 = expr(ir_unop_u2i, r1C84);
   body.emit(assign(r1C83, expr(ir_unop_i2b, r1C85), 0x01));

   ir_variable *const r1C86 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r1C88 = expr(ir_unop_logic_not, r1C83);
   ir_if *f1C87 = new(mem_ctx) ir_if(operand(r1C88).val);
   exec_list *const f1C87_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C87->then_instructions;

      body.emit(assign(r1C86, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C87->else_instructions;

      ir_variable *const r1C89 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r1C8A = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r1C8A);
      ir_variable *const r1C8B = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r1C8B);
      ir_expression *const r1C8C = rshift(swizzle_y(r1C70), body.constant(int(20)));
      ir_expression *const r1C8D = bit_and(r1C8C, body.constant(2047u));
      ir_expression *const r1C8E = expr(ir_unop_u2i, r1C8D);
      ir_expression *const r1C8F = equal(r1C8E, body.constant(int(2047)));
      ir_expression *const r1C90 = bit_and(swizzle_y(r1C70), body.constant(1048575u));
      ir_expression *const r1C91 = bit_or(r1C90, swizzle_x(r1C70));
      ir_expression *const r1C92 = nequal(r1C91, body.constant(0u));
      body.emit(assign(r1C8B, logic_and(r1C8F, r1C92), 0x01));

      ir_expression *const r1C93 = rshift(swizzle_y(r1C71), body.constant(int(20)));
      ir_expression *const r1C94 = bit_and(r1C93, body.constant(2047u));
      ir_expression *const r1C95 = expr(ir_unop_u2i, r1C94);
      ir_expression *const r1C96 = equal(r1C95, body.constant(int(2047)));
      ir_expression *const r1C97 = bit_and(swizzle_y(r1C71), body.constant(1048575u));
      ir_expression *const r1C98 = bit_or(r1C97, swizzle_x(r1C71));
      ir_expression *const r1C99 = nequal(r1C98, body.constant(0u));
      body.emit(assign(r1C8A, logic_and(r1C96, r1C99), 0x01));

      /* IF CONDITION */
      ir_expression *const r1C9B = logic_or(r1C8B, r1C8A);
      ir_if *f1C9A = new(mem_ctx) ir_if(operand(r1C9B).val);
      exec_list *const f1C9A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C9A->then_instructions;

         body.emit(assign(r1C89, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C9A->else_instructions;

         ir_expression *const r1C9C = equal(swizzle_x(r1C70), swizzle_x(r1C71));
         ir_expression *const r1C9D = equal(swizzle_y(r1C70), swizzle_y(r1C71));
         ir_expression *const r1C9E = equal(swizzle_x(r1C70), body.constant(0u));
         ir_expression *const r1C9F = bit_or(swizzle_y(r1C70), swizzle_y(r1C71));
         ir_expression *const r1CA0 = lshift(r1C9F, body.constant(int(1)));
         ir_expression *const r1CA1 = equal(r1CA0, body.constant(0u));
         ir_expression *const r1CA2 = logic_and(r1C9E, r1CA1);
         ir_expression *const r1CA3 = logic_or(r1C9D, r1CA2);
         body.emit(assign(r1C89, logic_and(r1C9C, r1CA3), 0x01));


      body.instructions = f1C9A_parent_instructions;
      body.emit(f1C9A);

      /* END IF */

      body.emit(assign(r1C86, r1C89, 0x01));


   body.instructions = f1C87_parent_instructions;
   body.emit(f1C87);

   /* END IF */

   ir_variable *const r1CA4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f1CA5 = new(mem_ctx) ir_if(operand(r1C86).val);
   exec_list *const f1CA5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1CA5->then_instructions;

      body.emit(assign(r1CA4, r1C71, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1CA5->else_instructions;

      ir_variable *const r1CA6 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r1CA7 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1CA7, rshift(swizzle_y(r1C71), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1CA9 = equal(r1CA7, body.constant(0u));
      ir_if *f1CA8 = new(mem_ctx) ir_if(operand(r1CA9).val);
      exec_list *const f1CA8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1CA8->then_instructions;

         ir_variable *const r1CAA = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r1CAA, r1CA7, 0x01));

         ir_variable *const r1CAB = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r1CAC = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r1CAC);
         ir_variable *const r1CAD = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r1CAD);
         ir_variable *const r1CAE = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r1CAE);
         ir_variable *const r1CAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r1CAF);
         ir_variable *const r1CB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r1CB0);
         ir_variable *const r1CB1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r1CB1);
         ir_variable *const r1CB2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r1CB2);
         ir_variable *const r1CB3 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r1CB3);
         ir_variable *const r1CB4 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r1CB4, body.constant(0u), 0x01));

         ir_variable *const r1CB5 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r1CB6 = rshift(swizzle_y(r1C71), body.constant(int(20)));
         ir_expression *const r1CB7 = bit_and(r1CB6, body.constant(2047u));
         body.emit(assign(r1CB5, expr(ir_unop_u2i, r1CB7), 0x01));

         body.emit(assign(r1CAE, r1CB5, 0x01));

         body.emit(assign(r1CAD, body.constant(int(1023)), 0x01));

         body.emit(assign(r1CAC, add(r1CB5, body.constant(int(-1023))), 0x01));

         ir_variable *const r1CB8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1CB8, lshift(swizzle_x(r1C71), body.constant(int(10))), 0x01));

         ir_variable *const r1CB9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r1CBA = bit_and(swizzle_y(r1C71), body.constant(1048575u));
         ir_expression *const r1CBB = lshift(r1CBA, body.constant(int(10)));
         ir_expression *const r1CBC = rshift(swizzle_x(r1C71), body.constant(int(22)));
         body.emit(assign(r1CB9, bit_or(r1CBB, r1CBC), 0x01));

         body.emit(assign(r1CB1, r1CB9, 0x01));

         body.emit(assign(r1CB2, r1CB8, 0x01));

         ir_variable *const r1CBD = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1CBD, body.constant(0u), 0x01));

         ir_variable *const r1CBE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r1CBE, body.constant(0u), 0x01));

         body.emit(assign(r1CAF, r1CBE, 0x01));

         body.emit(assign(r1CB0, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r1CC0 = less(body.constant(int(0)), r1CAC);
         ir_if *f1CBF = new(mem_ctx) ir_if(operand(r1CC0).val);
         exec_list *const f1CBF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1CBF->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1CC2 = equal(r1CB5, body.constant(int(2047)));
            ir_if *f1CC1 = new(mem_ctx) ir_if(operand(r1CC2).val);
            exec_list *const f1CC1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1CC1->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1CC4 = bit_or(r1CB9, r1CB8);
               ir_expression *const r1CC5 = nequal(r1CC4, body.constant(0u));
               ir_if *f1CC3 = new(mem_ctx) ir_if(operand(r1CC5).val);
               exec_list *const f1CC3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CC3->then_instructions;

                  ir_variable *const r1CC6 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1CC6, swizzle_x(r1C71), 0x01));

                  ir_variable *const r1CC7 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1CC7, body.constant(0u), 0x01));

                  ir_variable *const r1CC8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r1CC6, bit_or(swizzle_y(r1C71), body.constant(524288u)), 0x02));

                  body.emit(assign(r1CC7, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1CCA = lshift(swizzle_y(r1C71), body.constant(int(1)));
                  ir_expression *const r1CCB = lequal(body.constant(4292870144u), r1CCA);
                  ir_expression *const r1CCC = nequal(swizzle_x(r1C71), body.constant(0u));
                  ir_expression *const r1CCD = bit_and(swizzle_y(r1C71), body.constant(1048575u));
                  ir_expression *const r1CCE = nequal(r1CCD, body.constant(0u));
                  ir_expression *const r1CCF = logic_or(r1CCC, r1CCE);
                  ir_expression *const r1CD0 = logic_and(r1CCB, r1CCF);
                  ir_if *f1CC9 = new(mem_ctx) ir_if(operand(r1CD0).val);
                  exec_list *const f1CC9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CC9->then_instructions;

                     body.emit(assign(r1CC8, r1CC6, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1CC9->else_instructions;

                     body.emit(assign(r1CC8, r1CC7, 0x03));


                  body.instructions = f1CC9_parent_instructions;
                  body.emit(f1CC9);

                  /* END IF */

                  body.emit(assign(r1CAB, r1CC8, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CC3->else_instructions;

                  body.emit(assign(r1CAB, r1C71, 0x03));


               body.instructions = f1CC3_parent_instructions;
               body.emit(f1CC3);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1CC1->else_instructions;

               body.emit(assign(r1CAF, body.constant(1073741824u), 0x01));

               ir_variable *const r1CD1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1CD1);
               ir_variable *const r1CD2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1CD2);
               ir_variable *const r1CD3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1CD4 = neg(r1CAC);
               body.emit(assign(r1CD3, bit_and(r1CD4, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1CD6 = equal(r1CAC, body.constant(int(0)));
               ir_if *f1CD5 = new(mem_ctx) ir_if(operand(r1CD6).val);
               exec_list *const f1CD5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CD5->then_instructions;

                  body.emit(assign(r1CD1, body.constant(0u), 0x01));

                  body.emit(assign(r1CD2, r1CAF, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CD5->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1CD8 = less(r1CAC, body.constant(int(32)));
                  ir_if *f1CD7 = new(mem_ctx) ir_if(operand(r1CD8).val);
                  exec_list *const f1CD7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CD7->then_instructions;

                     ir_expression *const r1CD9 = lshift(body.constant(1073741824u), r1CD3);
                     ir_expression *const r1CDA = bit_or(r1CD9, body.constant(0u));
                     body.emit(assign(r1CD1, bit_or(r1CDA, body.constant(0u)), 0x01));

                     body.emit(assign(r1CD2, rshift(body.constant(1073741824u), r1CAC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1CD7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1CDC = equal(r1CAC, body.constant(int(32)));
                     ir_if *f1CDB = new(mem_ctx) ir_if(operand(r1CDC).val);
                     exec_list *const f1CDB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1CDB->then_instructions;

                        body.emit(assign(r1CD1, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1CDB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1CDE = less(r1CAC, body.constant(int(64)));
                        ir_if *f1CDD = new(mem_ctx) ir_if(operand(r1CDE).val);
                        exec_list *const f1CDD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1CDD->then_instructions;

                           ir_expression *const r1CDF = bit_and(r1CAC, body.constant(int(31)));
                           ir_expression *const r1CE0 = rshift(body.constant(1073741824u), r1CDF);
                           ir_expression *const r1CE1 = lshift(body.constant(1073741824u), r1CD3);
                           ir_expression *const r1CE2 = bit_or(r1CE1, body.constant(0u));
                           ir_expression *const r1CE3 = nequal(r1CE2, body.constant(0u));
                           ir_expression *const r1CE4 = expr(ir_unop_b2i, r1CE3);
                           ir_expression *const r1CE5 = expr(ir_unop_i2u, r1CE4);
                           body.emit(assign(r1CD1, bit_or(r1CE0, r1CE5), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1CDD->else_instructions;

                           body.emit(assign(r1CD1, body.constant(1u), 0x01));


                        body.instructions = f1CDD_parent_instructions;
                        body.emit(f1CDD);

                        /* END IF */


                     body.instructions = f1CDB_parent_instructions;
                     body.emit(f1CDB);

                     /* END IF */

                     body.emit(assign(r1CD2, body.constant(0u), 0x01));


                  body.instructions = f1CD7_parent_instructions;
                  body.emit(f1CD7);

                  /* END IF */


               body.instructions = f1CD5_parent_instructions;
               body.emit(f1CD5);

               /* END IF */

               body.emit(assign(r1CAF, r1CD2, 0x01));

               body.emit(assign(r1CB0, r1CD1, 0x01));

               body.emit(assign(r1CB1, bit_or(r1CB9, body.constant(1073741824u)), 0x01));

               ir_variable *const r1CE6 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1CE7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1CE7, sub(r1CB8, r1CD1), 0x01));

               ir_expression *const r1CE8 = sub(r1CB1, r1CD2);
               ir_expression *const r1CE9 = less(r1CB8, r1CD1);
               ir_expression *const r1CEA = expr(ir_unop_b2i, r1CE9);
               ir_expression *const r1CEB = expr(ir_unop_i2u, r1CEA);
               body.emit(assign(r1CE6, sub(r1CE8, r1CEB), 0x01));

               body.emit(assign(r1CB3, add(r1CB5, body.constant(int(-1))), 0x01));

               ir_variable *const r1CEC = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1CEC, add(r1CB3, body.constant(int(-10))), 0x01));

               ir_variable *const r1CED = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1CED, r1CE6, 0x01));

               ir_variable *const r1CEE = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1CEE, r1CE7, 0x01));

               ir_variable *const r1CEF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1CEF);
               ir_variable *const r1CF0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1CF0);
               /* IF CONDITION */
               ir_expression *const r1CF2 = equal(r1CE6, body.constant(0u));
               ir_if *f1CF1 = new(mem_ctx) ir_if(operand(r1CF2).val);
               exec_list *const f1CF1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CF1->then_instructions;

                  body.emit(assign(r1CED, r1CE7, 0x01));

                  body.emit(assign(r1CEE, body.constant(0u), 0x01));

                  body.emit(assign(r1CEC, add(r1CEC, body.constant(int(-32))), 0x01));


               body.instructions = f1CF1_parent_instructions;
               body.emit(f1CF1);

               /* END IF */

               ir_variable *const r1CF3 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1CF3, r1CED, 0x01));

               ir_variable *const r1CF4 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1CF5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1CF5);
               /* IF CONDITION */
               ir_expression *const r1CF7 = equal(r1CED, body.constant(0u));
               ir_if *f1CF6 = new(mem_ctx) ir_if(operand(r1CF7).val);
               exec_list *const f1CF6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CF6->then_instructions;

                  body.emit(assign(r1CF4, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CF6->else_instructions;

                  body.emit(assign(r1CF5, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1CF9 = bit_and(r1CED, body.constant(4294901760u));
                  ir_expression *const r1CFA = equal(r1CF9, body.constant(0u));
                  ir_if *f1CF8 = new(mem_ctx) ir_if(operand(r1CFA).val);
                  exec_list *const f1CF8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CF8->then_instructions;

                     body.emit(assign(r1CF5, body.constant(int(16)), 0x01));

                     body.emit(assign(r1CF3, lshift(r1CED, body.constant(int(16))), 0x01));


                  body.instructions = f1CF8_parent_instructions;
                  body.emit(f1CF8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1CFC = bit_and(r1CF3, body.constant(4278190080u));
                  ir_expression *const r1CFD = equal(r1CFC, body.constant(0u));
                  ir_if *f1CFB = new(mem_ctx) ir_if(operand(r1CFD).val);
                  exec_list *const f1CFB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CFB->then_instructions;

                     body.emit(assign(r1CF5, add(r1CF5, body.constant(int(8))), 0x01));

                     body.emit(assign(r1CF3, lshift(r1CF3, body.constant(int(8))), 0x01));


                  body.instructions = f1CFB_parent_instructions;
                  body.emit(f1CFB);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1CFF = bit_and(r1CF3, body.constant(4026531840u));
                  ir_expression *const r1D00 = equal(r1CFF, body.constant(0u));
                  ir_if *f1CFE = new(mem_ctx) ir_if(operand(r1D00).val);
                  exec_list *const f1CFE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CFE->then_instructions;

                     body.emit(assign(r1CF5, add(r1CF5, body.constant(int(4))), 0x01));

                     body.emit(assign(r1CF3, lshift(r1CF3, body.constant(int(4))), 0x01));


                  body.instructions = f1CFE_parent_instructions;
                  body.emit(f1CFE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1D02 = bit_and(r1CF3, body.constant(3221225472u));
                  ir_expression *const r1D03 = equal(r1D02, body.constant(0u));
                  ir_if *f1D01 = new(mem_ctx) ir_if(operand(r1D03).val);
                  exec_list *const f1D01_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D01->then_instructions;

                     body.emit(assign(r1CF5, add(r1CF5, body.constant(int(2))), 0x01));

                     body.emit(assign(r1CF3, lshift(r1CF3, body.constant(int(2))), 0x01));


                  body.instructions = f1D01_parent_instructions;
                  body.emit(f1D01);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1D05 = bit_and(r1CF3, body.constant(2147483648u));
                  ir_expression *const r1D06 = equal(r1D05, body.constant(0u));
                  ir_if *f1D04 = new(mem_ctx) ir_if(operand(r1D06).val);
                  exec_list *const f1D04_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D04->then_instructions;

                     body.emit(assign(r1CF5, add(r1CF5, body.constant(int(1))), 0x01));


                  body.instructions = f1D04_parent_instructions;
                  body.emit(f1D04);

                  /* END IF */

                  body.emit(assign(r1CF4, r1CF5, 0x01));


               body.instructions = f1CF6_parent_instructions;
               body.emit(f1CF6);

               /* END IF */

               body.emit(assign(r1CF0, add(r1CF4, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1D08 = lequal(body.constant(int(0)), r1CF0);
               ir_if *f1D07 = new(mem_ctx) ir_if(operand(r1D08).val);
               exec_list *const f1D07_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D07->then_instructions;

                  body.emit(assign(r1CEF, body.constant(0u), 0x01));

                  ir_variable *const r1D09 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1D09, lshift(r1CEE, r1CF0), 0x01));

                  ir_variable *const r1D0A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1D0C = equal(r1CF0, body.constant(int(0)));
                  ir_if *f1D0B = new(mem_ctx) ir_if(operand(r1D0C).val);
                  exec_list *const f1D0B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D0B->then_instructions;

                     body.emit(assign(r1D0A, r1CED, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D0B->else_instructions;

                     ir_expression *const r1D0D = lshift(r1CED, r1CF0);
                     ir_expression *const r1D0E = neg(r1CF0);
                     ir_expression *const r1D0F = bit_and(r1D0E, body.constant(int(31)));
                     ir_expression *const r1D10 = rshift(r1CEE, r1D0F);
                     body.emit(assign(r1D0A, bit_or(r1D0D, r1D10), 0x01));


                  body.instructions = f1D0B_parent_instructions;
                  body.emit(f1D0B);

                  /* END IF */

                  body.emit(assign(r1CED, r1D0A, 0x01));

                  body.emit(assign(r1CEE, r1D09, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D07->else_instructions;

                  ir_variable *const r1D11 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1D11, body.constant(0u), 0x01));

                  ir_variable *const r1D12 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1D12, neg(r1CF0), 0x01));

                  ir_variable *const r1D13 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1D13);
                  ir_variable *const r1D14 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1D14);
                  ir_variable *const r1D15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1D15);
                  ir_variable *const r1D16 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1D17 = neg(r1D12);
                  body.emit(assign(r1D16, bit_and(r1D17, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1D19 = equal(r1D12, body.constant(int(0)));
                  ir_if *f1D18 = new(mem_ctx) ir_if(operand(r1D19).val);
                  exec_list *const f1D18_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D18->then_instructions;

                     body.emit(assign(r1D13, r1D11, 0x01));

                     body.emit(assign(r1D14, r1CEE, 0x01));

                     body.emit(assign(r1D15, r1CED, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D18->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D1B = less(r1D12, body.constant(int(32)));
                     ir_if *f1D1A = new(mem_ctx) ir_if(operand(r1D1B).val);
                     exec_list *const f1D1A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D1A->then_instructions;

                        body.emit(assign(r1D13, lshift(r1CEE, r1D16), 0x01));

                        ir_expression *const r1D1C = lshift(r1CED, r1D16);
                        ir_expression *const r1D1D = rshift(r1CEE, r1D12);
                        body.emit(assign(r1D14, bit_or(r1D1C, r1D1D), 0x01));

                        body.emit(assign(r1D15, rshift(r1CED, r1D12), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D1A->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1D1F = equal(r1D12, body.constant(int(32)));
                        ir_if *f1D1E = new(mem_ctx) ir_if(operand(r1D1F).val);
                        exec_list *const f1D1E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D1E->then_instructions;

                           body.emit(assign(r1D13, r1CEE, 0x01));

                           body.emit(assign(r1D14, r1CED, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D1E->else_instructions;

                           body.emit(assign(r1D11, bit_or(body.constant(0u), r1CEE), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1D21 = less(r1D12, body.constant(int(64)));
                           ir_if *f1D20 = new(mem_ctx) ir_if(operand(r1D21).val);
                           exec_list *const f1D20_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D20->then_instructions;

                              body.emit(assign(r1D13, lshift(r1CED, r1D16), 0x01));

                              ir_expression *const r1D22 = bit_and(r1D12, body.constant(int(31)));
                              body.emit(assign(r1D14, rshift(r1CED, r1D22), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1D20->else_instructions;

                              ir_variable *const r1D23 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1D25 = equal(r1D12, body.constant(int(64)));
                              ir_if *f1D24 = new(mem_ctx) ir_if(operand(r1D25).val);
                              exec_list *const f1D24_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1D24->then_instructions;

                                 body.emit(assign(r1D23, r1CED, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1D24->else_instructions;

                                 ir_expression *const r1D26 = nequal(r1CED, body.constant(0u));
                                 ir_expression *const r1D27 = expr(ir_unop_b2i, r1D26);
                                 body.emit(assign(r1D23, expr(ir_unop_i2u, r1D27), 0x01));


                              body.instructions = f1D24_parent_instructions;
                              body.emit(f1D24);

                              /* END IF */

                              body.emit(assign(r1D13, r1D23, 0x01));

                              body.emit(assign(r1D14, body.constant(0u), 0x01));


                           body.instructions = f1D20_parent_instructions;
                           body.emit(f1D20);

                           /* END IF */


                        body.instructions = f1D1E_parent_instructions;
                        body.emit(f1D1E);

                        /* END IF */

                        body.emit(assign(r1D15, body.constant(0u), 0x01));


                     body.instructions = f1D1A_parent_instructions;
                     body.emit(f1D1A);

                     /* END IF */

                     ir_expression *const r1D28 = nequal(r1D11, body.constant(0u));
                     ir_expression *const r1D29 = expr(ir_unop_b2i, r1D28);
                     ir_expression *const r1D2A = expr(ir_unop_i2u, r1D29);
                     body.emit(assign(r1D13, bit_or(r1D13, r1D2A), 0x01));


                  body.instructions = f1D18_parent_instructions;
                  body.emit(f1D18);

                  /* END IF */

                  body.emit(assign(r1CED, r1D15, 0x01));

                  body.emit(assign(r1CEE, r1D14, 0x01));

                  body.emit(assign(r1CEF, r1D13, 0x01));


               body.instructions = f1D07_parent_instructions;
               body.emit(f1D07);

               /* END IF */

               body.emit(assign(r1CEC, sub(r1CEC, r1CF0), 0x01));

               ir_variable *const r1D2B = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1D2B, r1CEC, 0x01));

               ir_variable *const r1D2C = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1D2C, r1CED, 0x01));

               ir_variable *const r1D2D = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1D2D, r1CEE, 0x01));

               ir_variable *const r1D2E = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1D2E, r1CEF, 0x01));

               ir_variable *const r1D2F = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1D2F, body.constant(true), 0x01));

               ir_variable *const r1D30 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1D31 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1D31);
               ir_expression *const r1D32 = expr(ir_unop_u2i, r1CEF);
               body.emit(assign(r1D31, less(r1D32, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1D34 = lequal(body.constant(int(2045)), r1CEC);
               ir_if *f1D33 = new(mem_ctx) ir_if(operand(r1D34).val);
               exec_list *const f1D33_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D33->then_instructions;

                  ir_variable *const r1D35 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1D37 = less(body.constant(int(2045)), r1CEC);
                  ir_if *f1D36 = new(mem_ctx) ir_if(operand(r1D37).val);
                  exec_list *const f1D36_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D36->then_instructions;

                     body.emit(assign(r1D35, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D36->else_instructions;

                     ir_variable *const r1D38 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1D3A = equal(r1CEC, body.constant(int(2045)));
                     ir_if *f1D39 = new(mem_ctx) ir_if(operand(r1D3A).val);
                     exec_list *const f1D39_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D39->then_instructions;

                        ir_expression *const r1D3B = equal(body.constant(2097151u), r1CED);
                        ir_expression *const r1D3C = equal(body.constant(4294967295u), r1CEE);
                        body.emit(assign(r1D38, logic_and(r1D3B, r1D3C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D39->else_instructions;

                        body.emit(assign(r1D38, body.constant(false), 0x01));


                     body.instructions = f1D39_parent_instructions;
                     body.emit(f1D39);

                     /* END IF */

                     body.emit(assign(r1D35, logic_and(r1D38, r1D31), 0x01));


                  body.instructions = f1D36_parent_instructions;
                  body.emit(f1D36);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1D3D = new(mem_ctx) ir_if(operand(r1D35).val);
                  exec_list *const f1D3D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D3D->then_instructions;

                     ir_variable *const r1D3E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1D3E);
                     ir_expression *const r1D3F = lshift(r1CA7, body.constant(int(31)));
                     body.emit(assign(r1D3E, add(r1D3F, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1D3E, body.constant(0u), 0x01));

                     body.emit(assign(r1D30, r1D3E, 0x03));

                     body.emit(assign(r1D2F, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D3D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D41 = less(r1CEC, body.constant(int(0)));
                     ir_if *f1D40 = new(mem_ctx) ir_if(operand(r1D41).val);
                     exec_list *const f1D40_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D40->then_instructions;

                        ir_variable *const r1D42 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1D42, r1CEF, 0x01));

                        ir_variable *const r1D43 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1D43, neg(r1CEC), 0x01));

                        ir_variable *const r1D44 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1D44);
                        ir_variable *const r1D45 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1D45);
                        ir_variable *const r1D46 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1D46);
                        ir_variable *const r1D47 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1D48 = neg(r1D43);
                        body.emit(assign(r1D47, bit_and(r1D48, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1D4A = equal(r1D43, body.constant(int(0)));
                        ir_if *f1D49 = new(mem_ctx) ir_if(operand(r1D4A).val);
                        exec_list *const f1D49_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D49->then_instructions;

                           body.emit(assign(r1D44, r1CEF, 0x01));

                           body.emit(assign(r1D45, r1CEE, 0x01));

                           body.emit(assign(r1D46, r1CED, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D49->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1D4C = less(r1D43, body.constant(int(32)));
                           ir_if *f1D4B = new(mem_ctx) ir_if(operand(r1D4C).val);
                           exec_list *const f1D4B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D4B->then_instructions;

                              body.emit(assign(r1D44, lshift(r1CEE, r1D47), 0x01));

                              ir_expression *const r1D4D = lshift(r1CED, r1D47);
                              ir_expression *const r1D4E = rshift(r1CEE, r1D43);
                              body.emit(assign(r1D45, bit_or(r1D4D, r1D4E), 0x01));

                              body.emit(assign(r1D46, rshift(r1CED, r1D43), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1D4B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1D50 = equal(r1D43, body.constant(int(32)));
                              ir_if *f1D4F = new(mem_ctx) ir_if(operand(r1D50).val);
                              exec_list *const f1D4F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1D4F->then_instructions;

                                 body.emit(assign(r1D44, r1CEE, 0x01));

                                 body.emit(assign(r1D45, r1CED, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1D4F->else_instructions;

                                 body.emit(assign(r1D42, bit_or(r1CEF, r1CEE), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1D52 = less(r1D43, body.constant(int(64)));
                                 ir_if *f1D51 = new(mem_ctx) ir_if(operand(r1D52).val);
                                 exec_list *const f1D51_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1D51->then_instructions;

                                    body.emit(assign(r1D44, lshift(r1CED, r1D47), 0x01));

                                    ir_expression *const r1D53 = bit_and(r1D43, body.constant(int(31)));
                                    body.emit(assign(r1D45, rshift(r1CED, r1D53), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1D51->else_instructions;

                                    ir_variable *const r1D54 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1D56 = equal(r1D43, body.constant(int(64)));
                                    ir_if *f1D55 = new(mem_ctx) ir_if(operand(r1D56).val);
                                    exec_list *const f1D55_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1D55->then_instructions;

                                       body.emit(assign(r1D54, r1CED, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1D55->else_instructions;

                                       ir_expression *const r1D57 = nequal(r1CED, body.constant(0u));
                                       ir_expression *const r1D58 = expr(ir_unop_b2i, r1D57);
                                       body.emit(assign(r1D54, expr(ir_unop_i2u, r1D58), 0x01));


                                    body.instructions = f1D55_parent_instructions;
                                    body.emit(f1D55);

                                    /* END IF */

                                    body.emit(assign(r1D44, r1D54, 0x01));

                                    body.emit(assign(r1D45, body.constant(0u), 0x01));


                                 body.instructions = f1D51_parent_instructions;
                                 body.emit(f1D51);

                                 /* END IF */


                              body.instructions = f1D4F_parent_instructions;
                              body.emit(f1D4F);

                              /* END IF */

                              body.emit(assign(r1D46, body.constant(0u), 0x01));


                           body.instructions = f1D4B_parent_instructions;
                           body.emit(f1D4B);

                           /* END IF */

                           ir_expression *const r1D59 = nequal(r1D42, body.constant(0u));
                           ir_expression *const r1D5A = expr(ir_unop_b2i, r1D59);
                           ir_expression *const r1D5B = expr(ir_unop_i2u, r1D5A);
                           body.emit(assign(r1D44, bit_or(r1D44, r1D5B), 0x01));


                        body.instructions = f1D49_parent_instructions;
                        body.emit(f1D49);

                        /* END IF */

                        body.emit(assign(r1D2C, r1D46, 0x01));

                        body.emit(assign(r1D2D, r1D45, 0x01));

                        body.emit(assign(r1D2E, r1D44, 0x01));

                        body.emit(assign(r1D2B, body.constant(int(0)), 0x01));

                        body.emit(assign(r1D31, less(r1D44, body.constant(0u)), 0x01));


                     body.instructions = f1D40_parent_instructions;
                     body.emit(f1D40);

                     /* END IF */


                  body.instructions = f1D3D_parent_instructions;
                  body.emit(f1D3D);

                  /* END IF */


               body.instructions = f1D33_parent_instructions;
               body.emit(f1D33);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1D5C = new(mem_ctx) ir_if(operand(r1D2F).val);
               exec_list *const f1D5C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D5C->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1D5D = new(mem_ctx) ir_if(operand(r1D31).val);
                  exec_list *const f1D5D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D5D->then_instructions;

                     ir_variable *const r1D5E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1D5E, add(r1D2D, body.constant(1u)), 0x01));

                     ir_expression *const r1D5F = less(r1D5E, r1D2D);
                     ir_expression *const r1D60 = expr(ir_unop_b2i, r1D5F);
                     ir_expression *const r1D61 = expr(ir_unop_i2u, r1D60);
                     body.emit(assign(r1D2C, add(r1D2C, r1D61), 0x01));

                     ir_expression *const r1D62 = equal(r1D2E, body.constant(0u));
                     ir_expression *const r1D63 = expr(ir_unop_b2i, r1D62);
                     ir_expression *const r1D64 = expr(ir_unop_i2u, r1D63);
                     ir_expression *const r1D65 = add(r1D2E, r1D64);
                     ir_expression *const r1D66 = bit_and(r1D65, body.constant(1u));
                     ir_expression *const r1D67 = expr(ir_unop_bit_not, r1D66);
                     body.emit(assign(r1D2D, bit_and(r1D5E, r1D67), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D5D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D69 = bit_or(r1D2C, r1D2D);
                     ir_expression *const r1D6A = equal(r1D69, body.constant(0u));
                     ir_if *f1D68 = new(mem_ctx) ir_if(operand(r1D6A).val);
                     exec_list *const f1D68_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D68->then_instructions;

                        body.emit(assign(r1D2B, body.constant(int(0)), 0x01));


                     body.instructions = f1D68_parent_instructions;
                     body.emit(f1D68);

                     /* END IF */


                  body.instructions = f1D5D_parent_instructions;
                  body.emit(f1D5D);

                  /* END IF */

                  ir_variable *const r1D6B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1D6B);
                  ir_expression *const r1D6C = lshift(r1CA7, body.constant(int(31)));
                  ir_expression *const r1D6D = expr(ir_unop_i2u, r1D2B);
                  ir_expression *const r1D6E = lshift(r1D6D, body.constant(int(20)));
                  ir_expression *const r1D6F = add(r1D6C, r1D6E);
                  body.emit(assign(r1D6B, add(r1D6F, r1D2C), 0x02));

                  body.emit(assign(r1D6B, r1D2D, 0x01));

                  body.emit(assign(r1D30, r1D6B, 0x03));

                  body.emit(assign(r1D2F, body.constant(false), 0x01));


               body.instructions = f1D5C_parent_instructions;
               body.emit(f1D5C);

               /* END IF */

               body.emit(assign(r1CAB, r1D30, 0x03));


            body.instructions = f1CC1_parent_instructions;
            body.emit(f1CC1);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1CBF->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1D71 = less(r1CAC, body.constant(int(0)));
            ir_if *f1D70 = new(mem_ctx) ir_if(operand(r1D71).val);
            exec_list *const f1D70_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1D70->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1D73 = equal(r1CB5, body.constant(int(0)));
               ir_if *f1D72 = new(mem_ctx) ir_if(operand(r1D73).val);
               exec_list *const f1D72_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D72->then_instructions;

                  body.emit(assign(r1CAC, add(r1CAC, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D72->else_instructions;

                  body.emit(assign(r1CB1, bit_or(r1CB1, body.constant(1073741824u)), 0x01));


               body.instructions = f1D72_parent_instructions;
               body.emit(f1D72);

               /* END IF */

               ir_variable *const r1D74 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1D74, neg(r1CAC), 0x01));

               ir_variable *const r1D75 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1D75);
               ir_variable *const r1D76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1D76);
               ir_variable *const r1D77 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1D78 = neg(r1D74);
               body.emit(assign(r1D77, bit_and(r1D78, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1D7A = equal(r1D74, body.constant(int(0)));
               ir_if *f1D79 = new(mem_ctx) ir_if(operand(r1D7A).val);
               exec_list *const f1D79_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D79->then_instructions;

                  body.emit(assign(r1D75, r1CB8, 0x01));

                  body.emit(assign(r1D76, r1CB1, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D79->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1D7C = less(r1D74, body.constant(int(32)));
                  ir_if *f1D7B = new(mem_ctx) ir_if(operand(r1D7C).val);
                  exec_list *const f1D7B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D7B->then_instructions;

                     ir_expression *const r1D7D = lshift(r1CB1, r1D77);
                     ir_expression *const r1D7E = rshift(r1CB8, r1D74);
                     ir_expression *const r1D7F = bit_or(r1D7D, r1D7E);
                     ir_expression *const r1D80 = lshift(r1CB8, r1D77);
                     ir_expression *const r1D81 = nequal(r1D80, body.constant(0u));
                     ir_expression *const r1D82 = expr(ir_unop_b2i, r1D81);
                     ir_expression *const r1D83 = expr(ir_unop_i2u, r1D82);
                     body.emit(assign(r1D75, bit_or(r1D7F, r1D83), 0x01));

                     body.emit(assign(r1D76, rshift(r1CB1, r1D74), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D7B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D85 = equal(r1D74, body.constant(int(32)));
                     ir_if *f1D84 = new(mem_ctx) ir_if(operand(r1D85).val);
                     exec_list *const f1D84_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D84->then_instructions;

                        ir_expression *const r1D86 = nequal(r1CB8, body.constant(0u));
                        ir_expression *const r1D87 = expr(ir_unop_b2i, r1D86);
                        ir_expression *const r1D88 = expr(ir_unop_i2u, r1D87);
                        body.emit(assign(r1D75, bit_or(r1CB1, r1D88), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D84->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1D8A = less(r1D74, body.constant(int(64)));
                        ir_if *f1D89 = new(mem_ctx) ir_if(operand(r1D8A).val);
                        exec_list *const f1D89_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D89->then_instructions;

                           ir_expression *const r1D8B = bit_and(r1D74, body.constant(int(31)));
                           ir_expression *const r1D8C = rshift(r1CB1, r1D8B);
                           ir_expression *const r1D8D = lshift(r1CB1, r1D77);
                           ir_expression *const r1D8E = bit_or(r1D8D, r1CB8);
                           ir_expression *const r1D8F = nequal(r1D8E, body.constant(0u));
                           ir_expression *const r1D90 = expr(ir_unop_b2i, r1D8F);
                           ir_expression *const r1D91 = expr(ir_unop_i2u, r1D90);
                           body.emit(assign(r1D75, bit_or(r1D8C, r1D91), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D89->else_instructions;

                           ir_expression *const r1D92 = bit_or(r1CB1, r1CB8);
                           ir_expression *const r1D93 = nequal(r1D92, body.constant(0u));
                           ir_expression *const r1D94 = expr(ir_unop_b2i, r1D93);
                           body.emit(assign(r1D75, expr(ir_unop_i2u, r1D94), 0x01));


                        body.instructions = f1D89_parent_instructions;
                        body.emit(f1D89);

                        /* END IF */


                     body.instructions = f1D84_parent_instructions;
                     body.emit(f1D84);

                     /* END IF */

                     body.emit(assign(r1D76, body.constant(0u), 0x01));


                  body.instructions = f1D7B_parent_instructions;
                  body.emit(f1D7B);

                  /* END IF */


               body.instructions = f1D79_parent_instructions;
               body.emit(f1D79);

               /* END IF */

               body.emit(assign(r1CB1, r1D76, 0x01));

               body.emit(assign(r1CB2, r1D75, 0x01));

               body.emit(assign(r1CAF, bit_or(r1CAF, body.constant(1073741824u)), 0x01));

               ir_variable *const r1D95 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1D96 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1D96, sub(r1CB0, r1D75), 0x01));

               ir_expression *const r1D97 = sub(r1CAF, r1D76);
               ir_expression *const r1D98 = less(r1CB0, r1D75);
               ir_expression *const r1D99 = expr(ir_unop_b2i, r1D98);
               ir_expression *const r1D9A = expr(ir_unop_i2u, r1D99);
               body.emit(assign(r1D95, sub(r1D97, r1D9A), 0x01));

               body.emit(assign(r1CAA, bit_xor(r1CA7, body.constant(1u)), 0x01));

               body.emit(assign(r1CB3, body.constant(int(1022)), 0x01));

               ir_variable *const r1D9B = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1D9B, body.constant(int(1012)), 0x01));

               ir_variable *const r1D9C = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1D9C, r1D95, 0x01));

               ir_variable *const r1D9D = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1D9D, r1D96, 0x01));

               ir_variable *const r1D9E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1D9E);
               ir_variable *const r1D9F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1D9F);
               /* IF CONDITION */
               ir_expression *const r1DA1 = equal(r1D95, body.constant(0u));
               ir_if *f1DA0 = new(mem_ctx) ir_if(operand(r1DA1).val);
               exec_list *const f1DA0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DA0->then_instructions;

                  body.emit(assign(r1D9C, r1D96, 0x01));

                  body.emit(assign(r1D9D, body.constant(0u), 0x01));

                  body.emit(assign(r1D9B, body.constant(int(980)), 0x01));


               body.instructions = f1DA0_parent_instructions;
               body.emit(f1DA0);

               /* END IF */

               ir_variable *const r1DA2 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1DA2, r1D9C, 0x01));

               ir_variable *const r1DA3 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1DA4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1DA4);
               /* IF CONDITION */
               ir_expression *const r1DA6 = equal(r1D9C, body.constant(0u));
               ir_if *f1DA5 = new(mem_ctx) ir_if(operand(r1DA6).val);
               exec_list *const f1DA5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DA5->then_instructions;

                  body.emit(assign(r1DA3, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1DA5->else_instructions;

                  body.emit(assign(r1DA4, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1DA8 = bit_and(r1D9C, body.constant(4294901760u));
                  ir_expression *const r1DA9 = equal(r1DA8, body.constant(0u));
                  ir_if *f1DA7 = new(mem_ctx) ir_if(operand(r1DA9).val);
                  exec_list *const f1DA7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DA7->then_instructions;

                     body.emit(assign(r1DA4, body.constant(int(16)), 0x01));

                     body.emit(assign(r1DA2, lshift(r1D9C, body.constant(int(16))), 0x01));


                  body.instructions = f1DA7_parent_instructions;
                  body.emit(f1DA7);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1DAB = bit_and(r1DA2, body.constant(4278190080u));
                  ir_expression *const r1DAC = equal(r1DAB, body.constant(0u));
                  ir_if *f1DAA = new(mem_ctx) ir_if(operand(r1DAC).val);
                  exec_list *const f1DAA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DAA->then_instructions;

                     body.emit(assign(r1DA4, add(r1DA4, body.constant(int(8))), 0x01));

                     body.emit(assign(r1DA2, lshift(r1DA2, body.constant(int(8))), 0x01));


                  body.instructions = f1DAA_parent_instructions;
                  body.emit(f1DAA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1DAE = bit_and(r1DA2, body.constant(4026531840u));
                  ir_expression *const r1DAF = equal(r1DAE, body.constant(0u));
                  ir_if *f1DAD = new(mem_ctx) ir_if(operand(r1DAF).val);
                  exec_list *const f1DAD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DAD->then_instructions;

                     body.emit(assign(r1DA4, add(r1DA4, body.constant(int(4))), 0x01));

                     body.emit(assign(r1DA2, lshift(r1DA2, body.constant(int(4))), 0x01));


                  body.instructions = f1DAD_parent_instructions;
                  body.emit(f1DAD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1DB1 = bit_and(r1DA2, body.constant(3221225472u));
                  ir_expression *const r1DB2 = equal(r1DB1, body.constant(0u));
                  ir_if *f1DB0 = new(mem_ctx) ir_if(operand(r1DB2).val);
                  exec_list *const f1DB0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DB0->then_instructions;

                     body.emit(assign(r1DA4, add(r1DA4, body.constant(int(2))), 0x01));

                     body.emit(assign(r1DA2, lshift(r1DA2, body.constant(int(2))), 0x01));


                  body.instructions = f1DB0_parent_instructions;
                  body.emit(f1DB0);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1DB4 = bit_and(r1DA2, body.constant(2147483648u));
                  ir_expression *const r1DB5 = equal(r1DB4, body.constant(0u));
                  ir_if *f1DB3 = new(mem_ctx) ir_if(operand(r1DB5).val);
                  exec_list *const f1DB3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DB3->then_instructions;

                     body.emit(assign(r1DA4, add(r1DA4, body.constant(int(1))), 0x01));


                  body.instructions = f1DB3_parent_instructions;
                  body.emit(f1DB3);

                  /* END IF */

                  body.emit(assign(r1DA3, r1DA4, 0x01));


               body.instructions = f1DA5_parent_instructions;
               body.emit(f1DA5);

               /* END IF */

               body.emit(assign(r1D9F, add(r1DA3, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1DB7 = lequal(body.constant(int(0)), r1D9F);
               ir_if *f1DB6 = new(mem_ctx) ir_if(operand(r1DB7).val);
               exec_list *const f1DB6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DB6->then_instructions;

                  body.emit(assign(r1D9E, body.constant(0u), 0x01));

                  ir_variable *const r1DB8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1DB8, lshift(r1D9D, r1D9F), 0x01));

                  ir_variable *const r1DB9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1DBB = equal(r1D9F, body.constant(int(0)));
                  ir_if *f1DBA = new(mem_ctx) ir_if(operand(r1DBB).val);
                  exec_list *const f1DBA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DBA->then_instructions;

                     body.emit(assign(r1DB9, r1D9C, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DBA->else_instructions;

                     ir_expression *const r1DBC = lshift(r1D9C, r1D9F);
                     ir_expression *const r1DBD = neg(r1D9F);
                     ir_expression *const r1DBE = bit_and(r1DBD, body.constant(int(31)));
                     ir_expression *const r1DBF = rshift(r1D9D, r1DBE);
                     body.emit(assign(r1DB9, bit_or(r1DBC, r1DBF), 0x01));


                  body.instructions = f1DBA_parent_instructions;
                  body.emit(f1DBA);

                  /* END IF */

                  body.emit(assign(r1D9C, r1DB9, 0x01));

                  body.emit(assign(r1D9D, r1DB8, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1DB6->else_instructions;

                  ir_variable *const r1DC0 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1DC0, body.constant(0u), 0x01));

                  ir_variable *const r1DC1 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1DC1, neg(r1D9F), 0x01));

                  ir_variable *const r1DC2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1DC2);
                  ir_variable *const r1DC3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1DC3);
                  ir_variable *const r1DC4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1DC4);
                  ir_variable *const r1DC5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1DC6 = neg(r1DC1);
                  body.emit(assign(r1DC5, bit_and(r1DC6, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1DC8 = equal(r1DC1, body.constant(int(0)));
                  ir_if *f1DC7 = new(mem_ctx) ir_if(operand(r1DC8).val);
                  exec_list *const f1DC7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DC7->then_instructions;

                     body.emit(assign(r1DC2, r1DC0, 0x01));

                     body.emit(assign(r1DC3, r1D9D, 0x01));

                     body.emit(assign(r1DC4, r1D9C, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DC7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1DCA = less(r1DC1, body.constant(int(32)));
                     ir_if *f1DC9 = new(mem_ctx) ir_if(operand(r1DCA).val);
                     exec_list *const f1DC9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1DC9->then_instructions;

                        body.emit(assign(r1DC2, lshift(r1D9D, r1DC5), 0x01));

                        ir_expression *const r1DCB = lshift(r1D9C, r1DC5);
                        ir_expression *const r1DCC = rshift(r1D9D, r1DC1);
                        body.emit(assign(r1DC3, bit_or(r1DCB, r1DCC), 0x01));

                        body.emit(assign(r1DC4, rshift(r1D9C, r1DC1), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1DC9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1DCE = equal(r1DC1, body.constant(int(32)));
                        ir_if *f1DCD = new(mem_ctx) ir_if(operand(r1DCE).val);
                        exec_list *const f1DCD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1DCD->then_instructions;

                           body.emit(assign(r1DC2, r1D9D, 0x01));

                           body.emit(assign(r1DC3, r1D9C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1DCD->else_instructions;

                           body.emit(assign(r1DC0, bit_or(body.constant(0u), r1D9D), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1DD0 = less(r1DC1, body.constant(int(64)));
                           ir_if *f1DCF = new(mem_ctx) ir_if(operand(r1DD0).val);
                           exec_list *const f1DCF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1DCF->then_instructions;

                              body.emit(assign(r1DC2, lshift(r1D9C, r1DC5), 0x01));

                              ir_expression *const r1DD1 = bit_and(r1DC1, body.constant(int(31)));
                              body.emit(assign(r1DC3, rshift(r1D9C, r1DD1), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1DCF->else_instructions;

                              ir_variable *const r1DD2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1DD4 = equal(r1DC1, body.constant(int(64)));
                              ir_if *f1DD3 = new(mem_ctx) ir_if(operand(r1DD4).val);
                              exec_list *const f1DD3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1DD3->then_instructions;

                                 body.emit(assign(r1DD2, r1D9C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1DD3->else_instructions;

                                 ir_expression *const r1DD5 = nequal(r1D9C, body.constant(0u));
                                 ir_expression *const r1DD6 = expr(ir_unop_b2i, r1DD5);
                                 body.emit(assign(r1DD2, expr(ir_unop_i2u, r1DD6), 0x01));


                              body.instructions = f1DD3_parent_instructions;
                              body.emit(f1DD3);

                              /* END IF */

                              body.emit(assign(r1DC2, r1DD2, 0x01));

                              body.emit(assign(r1DC3, body.constant(0u), 0x01));


                           body.instructions = f1DCF_parent_instructions;
                           body.emit(f1DCF);

                           /* END IF */


                        body.instructions = f1DCD_parent_instructions;
                        body.emit(f1DCD);

                        /* END IF */

                        body.emit(assign(r1DC4, body.constant(0u), 0x01));


                     body.instructions = f1DC9_parent_instructions;
                     body.emit(f1DC9);

                     /* END IF */

                     ir_expression *const r1DD7 = nequal(r1DC0, body.constant(0u));
                     ir_expression *const r1DD8 = expr(ir_unop_b2i, r1DD7);
                     ir_expression *const r1DD9 = expr(ir_unop_i2u, r1DD8);
                     body.emit(assign(r1DC2, bit_or(r1DC2, r1DD9), 0x01));


                  body.instructions = f1DC7_parent_instructions;
                  body.emit(f1DC7);

                  /* END IF */

                  body.emit(assign(r1D9C, r1DC4, 0x01));

                  body.emit(assign(r1D9D, r1DC3, 0x01));

                  body.emit(assign(r1D9E, r1DC2, 0x01));


               body.instructions = f1DB6_parent_instructions;
               body.emit(f1DB6);

               /* END IF */

               body.emit(assign(r1D9B, sub(r1D9B, r1D9F), 0x01));

               ir_variable *const r1DDA = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1DDA, r1D9B, 0x01));

               ir_variable *const r1DDB = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1DDB, r1D9C, 0x01));

               ir_variable *const r1DDC = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1DDC, r1D9D, 0x01));

               ir_variable *const r1DDD = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1DDD, r1D9E, 0x01));

               ir_variable *const r1DDE = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1DDE, body.constant(true), 0x01));

               ir_variable *const r1DDF = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1DE0 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1DE0);
               ir_expression *const r1DE1 = expr(ir_unop_u2i, r1D9E);
               body.emit(assign(r1DE0, less(r1DE1, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1DE3 = lequal(body.constant(int(2045)), r1D9B);
               ir_if *f1DE2 = new(mem_ctx) ir_if(operand(r1DE3).val);
               exec_list *const f1DE2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DE2->then_instructions;

                  ir_variable *const r1DE4 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1DE6 = less(body.constant(int(2045)), r1D9B);
                  ir_if *f1DE5 = new(mem_ctx) ir_if(operand(r1DE6).val);
                  exec_list *const f1DE5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DE5->then_instructions;

                     body.emit(assign(r1DE4, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DE5->else_instructions;

                     ir_variable *const r1DE7 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1DE9 = equal(r1D9B, body.constant(int(2045)));
                     ir_if *f1DE8 = new(mem_ctx) ir_if(operand(r1DE9).val);
                     exec_list *const f1DE8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1DE8->then_instructions;

                        ir_expression *const r1DEA = equal(body.constant(2097151u), r1D9C);
                        ir_expression *const r1DEB = equal(body.constant(4294967295u), r1D9D);
                        body.emit(assign(r1DE7, logic_and(r1DEA, r1DEB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1DE8->else_instructions;

                        body.emit(assign(r1DE7, body.constant(false), 0x01));


                     body.instructions = f1DE8_parent_instructions;
                     body.emit(f1DE8);

                     /* END IF */

                     body.emit(assign(r1DE4, logic_and(r1DE7, r1DE0), 0x01));


                  body.instructions = f1DE5_parent_instructions;
                  body.emit(f1DE5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1DEC = new(mem_ctx) ir_if(operand(r1DE4).val);
                  exec_list *const f1DEC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DEC->then_instructions;

                     ir_variable *const r1DED = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1DED);
                     ir_expression *const r1DEE = lshift(r1CAA, body.constant(int(31)));
                     body.emit(assign(r1DED, add(r1DEE, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1DED, body.constant(0u), 0x01));

                     body.emit(assign(r1DDF, r1DED, 0x03));

                     body.emit(assign(r1DDE, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DEC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1DF0 = less(r1D9B, body.constant(int(0)));
                     ir_if *f1DEF = new(mem_ctx) ir_if(operand(r1DF0).val);
                     exec_list *const f1DEF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1DEF->then_instructions;

                        ir_variable *const r1DF1 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1DF1, r1D9E, 0x01));

                        ir_variable *const r1DF2 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1DF2, neg(r1D9B), 0x01));

                        ir_variable *const r1DF3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1DF3);
                        ir_variable *const r1DF4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1DF4);
                        ir_variable *const r1DF5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1DF5);
                        ir_variable *const r1DF6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1DF7 = neg(r1DF2);
                        body.emit(assign(r1DF6, bit_and(r1DF7, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1DF9 = equal(r1DF2, body.constant(int(0)));
                        ir_if *f1DF8 = new(mem_ctx) ir_if(operand(r1DF9).val);
                        exec_list *const f1DF8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1DF8->then_instructions;

                           body.emit(assign(r1DF3, r1D9E, 0x01));

                           body.emit(assign(r1DF4, r1D9D, 0x01));

                           body.emit(assign(r1DF5, r1D9C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1DF8->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1DFB = less(r1DF2, body.constant(int(32)));
                           ir_if *f1DFA = new(mem_ctx) ir_if(operand(r1DFB).val);
                           exec_list *const f1DFA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1DFA->then_instructions;

                              body.emit(assign(r1DF3, lshift(r1D9D, r1DF6), 0x01));

                              ir_expression *const r1DFC = lshift(r1D9C, r1DF6);
                              ir_expression *const r1DFD = rshift(r1D9D, r1DF2);
                              body.emit(assign(r1DF4, bit_or(r1DFC, r1DFD), 0x01));

                              body.emit(assign(r1DF5, rshift(r1D9C, r1DF2), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1DFA->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1DFF = equal(r1DF2, body.constant(int(32)));
                              ir_if *f1DFE = new(mem_ctx) ir_if(operand(r1DFF).val);
                              exec_list *const f1DFE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1DFE->then_instructions;

                                 body.emit(assign(r1DF3, r1D9D, 0x01));

                                 body.emit(assign(r1DF4, r1D9C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1DFE->else_instructions;

                                 body.emit(assign(r1DF1, bit_or(r1D9E, r1D9D), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1E01 = less(r1DF2, body.constant(int(64)));
                                 ir_if *f1E00 = new(mem_ctx) ir_if(operand(r1E01).val);
                                 exec_list *const f1E00_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1E00->then_instructions;

                                    body.emit(assign(r1DF3, lshift(r1D9C, r1DF6), 0x01));

                                    ir_expression *const r1E02 = bit_and(r1DF2, body.constant(int(31)));
                                    body.emit(assign(r1DF4, rshift(r1D9C, r1E02), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1E00->else_instructions;

                                    ir_variable *const r1E03 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1E05 = equal(r1DF2, body.constant(int(64)));
                                    ir_if *f1E04 = new(mem_ctx) ir_if(operand(r1E05).val);
                                    exec_list *const f1E04_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1E04->then_instructions;

                                       body.emit(assign(r1E03, r1D9C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1E04->else_instructions;

                                       ir_expression *const r1E06 = nequal(r1D9C, body.constant(0u));
                                       ir_expression *const r1E07 = expr(ir_unop_b2i, r1E06);
                                       body.emit(assign(r1E03, expr(ir_unop_i2u, r1E07), 0x01));


                                    body.instructions = f1E04_parent_instructions;
                                    body.emit(f1E04);

                                    /* END IF */

                                    body.emit(assign(r1DF3, r1E03, 0x01));

                                    body.emit(assign(r1DF4, body.constant(0u), 0x01));


                                 body.instructions = f1E00_parent_instructions;
                                 body.emit(f1E00);

                                 /* END IF */


                              body.instructions = f1DFE_parent_instructions;
                              body.emit(f1DFE);

                              /* END IF */

                              body.emit(assign(r1DF5, body.constant(0u), 0x01));


                           body.instructions = f1DFA_parent_instructions;
                           body.emit(f1DFA);

                           /* END IF */

                           ir_expression *const r1E08 = nequal(r1DF1, body.constant(0u));
                           ir_expression *const r1E09 = expr(ir_unop_b2i, r1E08);
                           ir_expression *const r1E0A = expr(ir_unop_i2u, r1E09);
                           body.emit(assign(r1DF3, bit_or(r1DF3, r1E0A), 0x01));


                        body.instructions = f1DF8_parent_instructions;
                        body.emit(f1DF8);

                        /* END IF */

                        body.emit(assign(r1DDB, r1DF5, 0x01));

                        body.emit(assign(r1DDC, r1DF4, 0x01));

                        body.emit(assign(r1DDD, r1DF3, 0x01));

                        body.emit(assign(r1DDA, body.constant(int(0)), 0x01));

                        body.emit(assign(r1DE0, less(r1DF3, body.constant(0u)), 0x01));


                     body.instructions = f1DEF_parent_instructions;
                     body.emit(f1DEF);

                     /* END IF */


                  body.instructions = f1DEC_parent_instructions;
                  body.emit(f1DEC);

                  /* END IF */


               body.instructions = f1DE2_parent_instructions;
               body.emit(f1DE2);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1E0B = new(mem_ctx) ir_if(operand(r1DDE).val);
               exec_list *const f1E0B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E0B->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1E0C = new(mem_ctx) ir_if(operand(r1DE0).val);
                  exec_list *const f1E0C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E0C->then_instructions;

                     ir_variable *const r1E0D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1E0D, add(r1DDC, body.constant(1u)), 0x01));

                     ir_expression *const r1E0E = less(r1E0D, r1DDC);
                     ir_expression *const r1E0F = expr(ir_unop_b2i, r1E0E);
                     ir_expression *const r1E10 = expr(ir_unop_i2u, r1E0F);
                     body.emit(assign(r1DDB, add(r1DDB, r1E10), 0x01));

                     ir_expression *const r1E11 = equal(r1DDD, body.constant(0u));
                     ir_expression *const r1E12 = expr(ir_unop_b2i, r1E11);
                     ir_expression *const r1E13 = expr(ir_unop_i2u, r1E12);
                     ir_expression *const r1E14 = add(r1DDD, r1E13);
                     ir_expression *const r1E15 = bit_and(r1E14, body.constant(1u));
                     ir_expression *const r1E16 = expr(ir_unop_bit_not, r1E15);
                     body.emit(assign(r1DDC, bit_and(r1E0D, r1E16), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E0C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1E18 = bit_or(r1DDB, r1DDC);
                     ir_expression *const r1E19 = equal(r1E18, body.constant(0u));
                     ir_if *f1E17 = new(mem_ctx) ir_if(operand(r1E19).val);
                     exec_list *const f1E17_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E17->then_instructions;

                        body.emit(assign(r1DDA, body.constant(int(0)), 0x01));


                     body.instructions = f1E17_parent_instructions;
                     body.emit(f1E17);

                     /* END IF */


                  body.instructions = f1E0C_parent_instructions;
                  body.emit(f1E0C);

                  /* END IF */

                  ir_variable *const r1E1A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1E1A);
                  ir_expression *const r1E1B = lshift(r1CAA, body.constant(int(31)));
                  ir_expression *const r1E1C = expr(ir_unop_i2u, r1DDA);
                  ir_expression *const r1E1D = lshift(r1E1C, body.constant(int(20)));
                  ir_expression *const r1E1E = add(r1E1B, r1E1D);
                  body.emit(assign(r1E1A, add(r1E1E, r1DDB), 0x02));

                  body.emit(assign(r1E1A, r1DDC, 0x01));

                  body.emit(assign(r1DDF, r1E1A, 0x03));

                  body.emit(assign(r1DDE, body.constant(false), 0x01));


               body.instructions = f1E0B_parent_instructions;
               body.emit(f1E0B);

               /* END IF */

               body.emit(assign(r1CAB, r1DDF, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1D70->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1E20 = equal(r1CB5, body.constant(int(2047)));
               ir_if *f1E1F = new(mem_ctx) ir_if(operand(r1E20).val);
               exec_list *const f1E1F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E1F->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1E22 = bit_or(r1CB1, r1CB2);
                  ir_expression *const r1E23 = bit_or(r1CAF, r1CB0);
                  ir_expression *const r1E24 = bit_or(r1E22, r1E23);
                  ir_expression *const r1E25 = nequal(r1E24, body.constant(0u));
                  ir_if *f1E21 = new(mem_ctx) ir_if(operand(r1E25).val);
                  exec_list *const f1E21_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E21->then_instructions;

                     ir_variable *const r1E26 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1E26, swizzle_x(r1C71), 0x01));

                     ir_variable *const r1E27 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1E27, body.constant(0u), 0x01));

                     ir_variable *const r1E28 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r1E26, bit_or(swizzle_y(r1C71), body.constant(524288u)), 0x02));

                     body.emit(assign(r1E27, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1E2A = lshift(swizzle_y(r1C71), body.constant(int(1)));
                     ir_expression *const r1E2B = lequal(body.constant(4292870144u), r1E2A);
                     ir_expression *const r1E2C = nequal(swizzle_x(r1C71), body.constant(0u));
                     ir_expression *const r1E2D = bit_and(swizzle_y(r1C71), body.constant(1048575u));
                     ir_expression *const r1E2E = nequal(r1E2D, body.constant(0u));
                     ir_expression *const r1E2F = logic_or(r1E2C, r1E2E);
                     ir_expression *const r1E30 = logic_and(r1E2B, r1E2F);
                     ir_if *f1E29 = new(mem_ctx) ir_if(operand(r1E30).val);
                     exec_list *const f1E29_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E29->then_instructions;

                        body.emit(assign(r1E28, r1E26, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E29->else_instructions;

                        body.emit(assign(r1E28, r1E27, 0x03));


                     body.instructions = f1E29_parent_instructions;
                     body.emit(f1E29);

                     /* END IF */

                     body.emit(assign(r1CAB, r1E28, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E21->else_instructions;

                     ir_constant_data r1E31_data;
                     memset(&r1E31_data, 0, sizeof(ir_constant_data));
                     r1E31_data.u[0] = 4294967295;
                     r1E31_data.u[1] = 4294967295;
                     ir_constant *const r1E31 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1E31_data);
                     body.emit(assign(r1CAB, r1E31, 0x03));


                  body.instructions = f1E21_parent_instructions;
                  body.emit(f1E21);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1E1F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1E33 = equal(r1CB5, body.constant(int(0)));
                  ir_if *f1E32 = new(mem_ctx) ir_if(operand(r1E33).val);
                  exec_list *const f1E32_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E32->then_instructions;

                     body.emit(assign(r1CAE, body.constant(int(1)), 0x01));

                     body.emit(assign(r1CAD, body.constant(int(1)), 0x01));


                  body.instructions = f1E32_parent_instructions;
                  body.emit(f1E32);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1E35 = less(r1CAF, r1CB1);
                  ir_if *f1E34 = new(mem_ctx) ir_if(operand(r1E35).val);
                  exec_list *const f1E34_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E34->then_instructions;

                     ir_variable *const r1E36 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r1E37 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1E37, sub(r1CB2, r1CB0), 0x01));

                     ir_expression *const r1E38 = sub(r1CB1, r1CAF);
                     ir_expression *const r1E39 = less(r1CB2, r1CB0);
                     ir_expression *const r1E3A = expr(ir_unop_b2i, r1E39);
                     ir_expression *const r1E3B = expr(ir_unop_i2u, r1E3A);
                     body.emit(assign(r1E36, sub(r1E38, r1E3B), 0x01));

                     body.emit(assign(r1CB3, add(r1CAE, body.constant(int(-1))), 0x01));

                     ir_variable *const r1E3C = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1E3C, add(r1CB3, body.constant(int(-10))), 0x01));

                     ir_variable *const r1E3D = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1E3D, r1E36, 0x01));

                     ir_variable *const r1E3E = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1E3E, r1E37, 0x01));

                     ir_variable *const r1E3F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r1E3F);
                     ir_variable *const r1E40 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1E40);
                     /* IF CONDITION */
                     ir_expression *const r1E42 = equal(r1E36, body.constant(0u));
                     ir_if *f1E41 = new(mem_ctx) ir_if(operand(r1E42).val);
                     exec_list *const f1E41_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E41->then_instructions;

                        body.emit(assign(r1E3D, r1E37, 0x01));

                        body.emit(assign(r1E3E, body.constant(0u), 0x01));

                        body.emit(assign(r1E3C, add(r1E3C, body.constant(int(-32))), 0x01));


                     body.instructions = f1E41_parent_instructions;
                     body.emit(f1E41);

                     /* END IF */

                     ir_variable *const r1E43 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1E43, r1E3D, 0x01));

                     ir_variable *const r1E44 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1E45 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1E45);
                     /* IF CONDITION */
                     ir_expression *const r1E47 = equal(r1E3D, body.constant(0u));
                     ir_if *f1E46 = new(mem_ctx) ir_if(operand(r1E47).val);
                     exec_list *const f1E46_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E46->then_instructions;

                        body.emit(assign(r1E44, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E46->else_instructions;

                        body.emit(assign(r1E45, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1E49 = bit_and(r1E3D, body.constant(4294901760u));
                        ir_expression *const r1E4A = equal(r1E49, body.constant(0u));
                        ir_if *f1E48 = new(mem_ctx) ir_if(operand(r1E4A).val);
                        exec_list *const f1E48_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E48->then_instructions;

                           body.emit(assign(r1E45, body.constant(int(16)), 0x01));

                           body.emit(assign(r1E43, lshift(r1E3D, body.constant(int(16))), 0x01));


                        body.instructions = f1E48_parent_instructions;
                        body.emit(f1E48);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1E4C = bit_and(r1E43, body.constant(4278190080u));
                        ir_expression *const r1E4D = equal(r1E4C, body.constant(0u));
                        ir_if *f1E4B = new(mem_ctx) ir_if(operand(r1E4D).val);
                        exec_list *const f1E4B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E4B->then_instructions;

                           body.emit(assign(r1E45, add(r1E45, body.constant(int(8))), 0x01));

                           body.emit(assign(r1E43, lshift(r1E43, body.constant(int(8))), 0x01));


                        body.instructions = f1E4B_parent_instructions;
                        body.emit(f1E4B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1E4F = bit_and(r1E43, body.constant(4026531840u));
                        ir_expression *const r1E50 = equal(r1E4F, body.constant(0u));
                        ir_if *f1E4E = new(mem_ctx) ir_if(operand(r1E50).val);
                        exec_list *const f1E4E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E4E->then_instructions;

                           body.emit(assign(r1E45, add(r1E45, body.constant(int(4))), 0x01));

                           body.emit(assign(r1E43, lshift(r1E43, body.constant(int(4))), 0x01));


                        body.instructions = f1E4E_parent_instructions;
                        body.emit(f1E4E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1E52 = bit_and(r1E43, body.constant(3221225472u));
                        ir_expression *const r1E53 = equal(r1E52, body.constant(0u));
                        ir_if *f1E51 = new(mem_ctx) ir_if(operand(r1E53).val);
                        exec_list *const f1E51_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E51->then_instructions;

                           body.emit(assign(r1E45, add(r1E45, body.constant(int(2))), 0x01));

                           body.emit(assign(r1E43, lshift(r1E43, body.constant(int(2))), 0x01));


                        body.instructions = f1E51_parent_instructions;
                        body.emit(f1E51);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1E55 = bit_and(r1E43, body.constant(2147483648u));
                        ir_expression *const r1E56 = equal(r1E55, body.constant(0u));
                        ir_if *f1E54 = new(mem_ctx) ir_if(operand(r1E56).val);
                        exec_list *const f1E54_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E54->then_instructions;

                           body.emit(assign(r1E45, add(r1E45, body.constant(int(1))), 0x01));


                        body.instructions = f1E54_parent_instructions;
                        body.emit(f1E54);

                        /* END IF */

                        body.emit(assign(r1E44, r1E45, 0x01));


                     body.instructions = f1E46_parent_instructions;
                     body.emit(f1E46);

                     /* END IF */

                     body.emit(assign(r1E40, add(r1E44, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1E58 = lequal(body.constant(int(0)), r1E40);
                     ir_if *f1E57 = new(mem_ctx) ir_if(operand(r1E58).val);
                     exec_list *const f1E57_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E57->then_instructions;

                        body.emit(assign(r1E3F, body.constant(0u), 0x01));

                        ir_variable *const r1E59 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1E59, lshift(r1E3E, r1E40), 0x01));

                        ir_variable *const r1E5A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1E5C = equal(r1E40, body.constant(int(0)));
                        ir_if *f1E5B = new(mem_ctx) ir_if(operand(r1E5C).val);
                        exec_list *const f1E5B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E5B->then_instructions;

                           body.emit(assign(r1E5A, r1E3D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E5B->else_instructions;

                           ir_expression *const r1E5D = lshift(r1E3D, r1E40);
                           ir_expression *const r1E5E = neg(r1E40);
                           ir_expression *const r1E5F = bit_and(r1E5E, body.constant(int(31)));
                           ir_expression *const r1E60 = rshift(r1E3E, r1E5F);
                           body.emit(assign(r1E5A, bit_or(r1E5D, r1E60), 0x01));


                        body.instructions = f1E5B_parent_instructions;
                        body.emit(f1E5B);

                        /* END IF */

                        body.emit(assign(r1E3D, r1E5A, 0x01));

                        body.emit(assign(r1E3E, r1E59, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E57->else_instructions;

                        ir_variable *const r1E61 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1E61, body.constant(0u), 0x01));

                        ir_variable *const r1E62 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1E62, neg(r1E40), 0x01));

                        ir_variable *const r1E63 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1E63);
                        ir_variable *const r1E64 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1E64);
                        ir_variable *const r1E65 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1E65);
                        ir_variable *const r1E66 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1E67 = neg(r1E62);
                        body.emit(assign(r1E66, bit_and(r1E67, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1E69 = equal(r1E62, body.constant(int(0)));
                        ir_if *f1E68 = new(mem_ctx) ir_if(operand(r1E69).val);
                        exec_list *const f1E68_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E68->then_instructions;

                           body.emit(assign(r1E63, r1E61, 0x01));

                           body.emit(assign(r1E64, r1E3E, 0x01));

                           body.emit(assign(r1E65, r1E3D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E68->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1E6B = less(r1E62, body.constant(int(32)));
                           ir_if *f1E6A = new(mem_ctx) ir_if(operand(r1E6B).val);
                           exec_list *const f1E6A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E6A->then_instructions;

                              body.emit(assign(r1E63, lshift(r1E3E, r1E66), 0x01));

                              ir_expression *const r1E6C = lshift(r1E3D, r1E66);
                              ir_expression *const r1E6D = rshift(r1E3E, r1E62);
                              body.emit(assign(r1E64, bit_or(r1E6C, r1E6D), 0x01));

                              body.emit(assign(r1E65, rshift(r1E3D, r1E62), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1E6A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1E6F = equal(r1E62, body.constant(int(32)));
                              ir_if *f1E6E = new(mem_ctx) ir_if(operand(r1E6F).val);
                              exec_list *const f1E6E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E6E->then_instructions;

                                 body.emit(assign(r1E63, r1E3E, 0x01));

                                 body.emit(assign(r1E64, r1E3D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1E6E->else_instructions;

                                 body.emit(assign(r1E61, bit_or(body.constant(0u), r1E3E), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1E71 = less(r1E62, body.constant(int(64)));
                                 ir_if *f1E70 = new(mem_ctx) ir_if(operand(r1E71).val);
                                 exec_list *const f1E70_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1E70->then_instructions;

                                    body.emit(assign(r1E63, lshift(r1E3D, r1E66), 0x01));

                                    ir_expression *const r1E72 = bit_and(r1E62, body.constant(int(31)));
                                    body.emit(assign(r1E64, rshift(r1E3D, r1E72), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1E70->else_instructions;

                                    ir_variable *const r1E73 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1E75 = equal(r1E62, body.constant(int(64)));
                                    ir_if *f1E74 = new(mem_ctx) ir_if(operand(r1E75).val);
                                    exec_list *const f1E74_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1E74->then_instructions;

                                       body.emit(assign(r1E73, r1E3D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1E74->else_instructions;

                                       ir_expression *const r1E76 = nequal(r1E3D, body.constant(0u));
                                       ir_expression *const r1E77 = expr(ir_unop_b2i, r1E76);
                                       body.emit(assign(r1E73, expr(ir_unop_i2u, r1E77), 0x01));


                                    body.instructions = f1E74_parent_instructions;
                                    body.emit(f1E74);

                                    /* END IF */

                                    body.emit(assign(r1E63, r1E73, 0x01));

                                    body.emit(assign(r1E64, body.constant(0u), 0x01));


                                 body.instructions = f1E70_parent_instructions;
                                 body.emit(f1E70);

                                 /* END IF */


                              body.instructions = f1E6E_parent_instructions;
                              body.emit(f1E6E);

                              /* END IF */

                              body.emit(assign(r1E65, body.constant(0u), 0x01));


                           body.instructions = f1E6A_parent_instructions;
                           body.emit(f1E6A);

                           /* END IF */

                           ir_expression *const r1E78 = nequal(r1E61, body.constant(0u));
                           ir_expression *const r1E79 = expr(ir_unop_b2i, r1E78);
                           ir_expression *const r1E7A = expr(ir_unop_i2u, r1E79);
                           body.emit(assign(r1E63, bit_or(r1E63, r1E7A), 0x01));


                        body.instructions = f1E68_parent_instructions;
                        body.emit(f1E68);

                        /* END IF */

                        body.emit(assign(r1E3D, r1E65, 0x01));

                        body.emit(assign(r1E3E, r1E64, 0x01));

                        body.emit(assign(r1E3F, r1E63, 0x01));


                     body.instructions = f1E57_parent_instructions;
                     body.emit(f1E57);

                     /* END IF */

                     body.emit(assign(r1E3C, sub(r1E3C, r1E40), 0x01));

                     ir_variable *const r1E7B = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1E7B, r1E3C, 0x01));

                     ir_variable *const r1E7C = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1E7C, r1E3D, 0x01));

                     ir_variable *const r1E7D = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1E7D, r1E3E, 0x01));

                     ir_variable *const r1E7E = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1E7E, r1E3F, 0x01));

                     ir_variable *const r1E7F = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1E7F, body.constant(true), 0x01));

                     ir_variable *const r1E80 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1E81 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1E81);
                     ir_expression *const r1E82 = expr(ir_unop_u2i, r1E3F);
                     body.emit(assign(r1E81, less(r1E82, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1E84 = lequal(body.constant(int(2045)), r1E3C);
                     ir_if *f1E83 = new(mem_ctx) ir_if(operand(r1E84).val);
                     exec_list *const f1E83_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E83->then_instructions;

                        ir_variable *const r1E85 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1E87 = less(body.constant(int(2045)), r1E3C);
                        ir_if *f1E86 = new(mem_ctx) ir_if(operand(r1E87).val);
                        exec_list *const f1E86_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E86->then_instructions;

                           body.emit(assign(r1E85, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E86->else_instructions;

                           ir_variable *const r1E88 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1E8A = equal(r1E3C, body.constant(int(2045)));
                           ir_if *f1E89 = new(mem_ctx) ir_if(operand(r1E8A).val);
                           exec_list *const f1E89_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E89->then_instructions;

                              ir_expression *const r1E8B = equal(body.constant(2097151u), r1E3D);
                              ir_expression *const r1E8C = equal(body.constant(4294967295u), r1E3E);
                              body.emit(assign(r1E88, logic_and(r1E8B, r1E8C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1E89->else_instructions;

                              body.emit(assign(r1E88, body.constant(false), 0x01));


                           body.instructions = f1E89_parent_instructions;
                           body.emit(f1E89);

                           /* END IF */

                           body.emit(assign(r1E85, logic_and(r1E88, r1E81), 0x01));


                        body.instructions = f1E86_parent_instructions;
                        body.emit(f1E86);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1E8D = new(mem_ctx) ir_if(operand(r1E85).val);
                        exec_list *const f1E8D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E8D->then_instructions;

                           ir_variable *const r1E8E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1E8E);
                           ir_expression *const r1E8F = lshift(r1CAA, body.constant(int(31)));
                           body.emit(assign(r1E8E, add(r1E8F, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1E8E, body.constant(0u), 0x01));

                           body.emit(assign(r1E80, r1E8E, 0x03));

                           body.emit(assign(r1E7F, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E8D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1E91 = less(r1E3C, body.constant(int(0)));
                           ir_if *f1E90 = new(mem_ctx) ir_if(operand(r1E91).val);
                           exec_list *const f1E90_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E90->then_instructions;

                              ir_variable *const r1E92 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1E92, r1E3F, 0x01));

                              ir_variable *const r1E93 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1E93, neg(r1E3C), 0x01));

                              ir_variable *const r1E94 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1E94);
                              ir_variable *const r1E95 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1E95);
                              ir_variable *const r1E96 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1E96);
                              ir_variable *const r1E97 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1E98 = neg(r1E93);
                              body.emit(assign(r1E97, bit_and(r1E98, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1E9A = equal(r1E93, body.constant(int(0)));
                              ir_if *f1E99 = new(mem_ctx) ir_if(operand(r1E9A).val);
                              exec_list *const f1E99_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E99->then_instructions;

                                 body.emit(assign(r1E94, r1E3F, 0x01));

                                 body.emit(assign(r1E95, r1E3E, 0x01));

                                 body.emit(assign(r1E96, r1E3D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1E99->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1E9C = less(r1E93, body.constant(int(32)));
                                 ir_if *f1E9B = new(mem_ctx) ir_if(operand(r1E9C).val);
                                 exec_list *const f1E9B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1E9B->then_instructions;

                                    body.emit(assign(r1E94, lshift(r1E3E, r1E97), 0x01));

                                    ir_expression *const r1E9D = lshift(r1E3D, r1E97);
                                    ir_expression *const r1E9E = rshift(r1E3E, r1E93);
                                    body.emit(assign(r1E95, bit_or(r1E9D, r1E9E), 0x01));

                                    body.emit(assign(r1E96, rshift(r1E3D, r1E93), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1E9B->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1EA0 = equal(r1E93, body.constant(int(32)));
                                    ir_if *f1E9F = new(mem_ctx) ir_if(operand(r1EA0).val);
                                    exec_list *const f1E9F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1E9F->then_instructions;

                                       body.emit(assign(r1E94, r1E3E, 0x01));

                                       body.emit(assign(r1E95, r1E3D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1E9F->else_instructions;

                                       body.emit(assign(r1E92, bit_or(r1E3F, r1E3E), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1EA2 = less(r1E93, body.constant(int(64)));
                                       ir_if *f1EA1 = new(mem_ctx) ir_if(operand(r1EA2).val);
                                       exec_list *const f1EA1_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1EA1->then_instructions;

                                          body.emit(assign(r1E94, lshift(r1E3D, r1E97), 0x01));

                                          ir_expression *const r1EA3 = bit_and(r1E93, body.constant(int(31)));
                                          body.emit(assign(r1E95, rshift(r1E3D, r1EA3), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1EA1->else_instructions;

                                          ir_variable *const r1EA4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1EA6 = equal(r1E93, body.constant(int(64)));
                                          ir_if *f1EA5 = new(mem_ctx) ir_if(operand(r1EA6).val);
                                          exec_list *const f1EA5_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1EA5->then_instructions;

                                             body.emit(assign(r1EA4, r1E3D, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1EA5->else_instructions;

                                             ir_expression *const r1EA7 = nequal(r1E3D, body.constant(0u));
                                             ir_expression *const r1EA8 = expr(ir_unop_b2i, r1EA7);
                                             body.emit(assign(r1EA4, expr(ir_unop_i2u, r1EA8), 0x01));


                                          body.instructions = f1EA5_parent_instructions;
                                          body.emit(f1EA5);

                                          /* END IF */

                                          body.emit(assign(r1E94, r1EA4, 0x01));

                                          body.emit(assign(r1E95, body.constant(0u), 0x01));


                                       body.instructions = f1EA1_parent_instructions;
                                       body.emit(f1EA1);

                                       /* END IF */


                                    body.instructions = f1E9F_parent_instructions;
                                    body.emit(f1E9F);

                                    /* END IF */

                                    body.emit(assign(r1E96, body.constant(0u), 0x01));


                                 body.instructions = f1E9B_parent_instructions;
                                 body.emit(f1E9B);

                                 /* END IF */

                                 ir_expression *const r1EA9 = nequal(r1E92, body.constant(0u));
                                 ir_expression *const r1EAA = expr(ir_unop_b2i, r1EA9);
                                 ir_expression *const r1EAB = expr(ir_unop_i2u, r1EAA);
                                 body.emit(assign(r1E94, bit_or(r1E94, r1EAB), 0x01));


                              body.instructions = f1E99_parent_instructions;
                              body.emit(f1E99);

                              /* END IF */

                              body.emit(assign(r1E7C, r1E96, 0x01));

                              body.emit(assign(r1E7D, r1E95, 0x01));

                              body.emit(assign(r1E7E, r1E94, 0x01));

                              body.emit(assign(r1E7B, body.constant(int(0)), 0x01));

                              body.emit(assign(r1E81, less(r1E94, body.constant(0u)), 0x01));


                           body.instructions = f1E90_parent_instructions;
                           body.emit(f1E90);

                           /* END IF */


                        body.instructions = f1E8D_parent_instructions;
                        body.emit(f1E8D);

                        /* END IF */


                     body.instructions = f1E83_parent_instructions;
                     body.emit(f1E83);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f1EAC = new(mem_ctx) ir_if(operand(r1E7F).val);
                     exec_list *const f1EAC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1EAC->then_instructions;

                        /* IF CONDITION */
                        ir_if *f1EAD = new(mem_ctx) ir_if(operand(r1E81).val);
                        exec_list *const f1EAD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1EAD->then_instructions;

                           ir_variable *const r1EAE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r1EAE, add(r1E7D, body.constant(1u)), 0x01));

                           ir_expression *const r1EAF = less(r1EAE, r1E7D);
                           ir_expression *const r1EB0 = expr(ir_unop_b2i, r1EAF);
                           ir_expression *const r1EB1 = expr(ir_unop_i2u, r1EB0);
                           body.emit(assign(r1E7C, add(r1E7C, r1EB1), 0x01));

                           ir_expression *const r1EB2 = equal(r1E7E, body.constant(0u));
                           ir_expression *const r1EB3 = expr(ir_unop_b2i, r1EB2);
                           ir_expression *const r1EB4 = expr(ir_unop_i2u, r1EB3);
                           ir_expression *const r1EB5 = add(r1E7E, r1EB4);
                           ir_expression *const r1EB6 = bit_and(r1EB5, body.constant(1u));
                           ir_expression *const r1EB7 = expr(ir_unop_bit_not, r1EB6);
                           body.emit(assign(r1E7D, bit_and(r1EAE, r1EB7), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1EAD->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1EB9 = bit_or(r1E7C, r1E7D);
                           ir_expression *const r1EBA = equal(r1EB9, body.constant(0u));
                           ir_if *f1EB8 = new(mem_ctx) ir_if(operand(r1EBA).val);
                           exec_list *const f1EB8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EB8->then_instructions;

                              body.emit(assign(r1E7B, body.constant(int(0)), 0x01));


                           body.instructions = f1EB8_parent_instructions;
                           body.emit(f1EB8);

                           /* END IF */


                        body.instructions = f1EAD_parent_instructions;
                        body.emit(f1EAD);

                        /* END IF */

                        ir_variable *const r1EBB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r1EBB);
                        ir_expression *const r1EBC = lshift(r1CAA, body.constant(int(31)));
                        ir_expression *const r1EBD = expr(ir_unop_i2u, r1E7B);
                        ir_expression *const r1EBE = lshift(r1EBD, body.constant(int(20)));
                        ir_expression *const r1EBF = add(r1EBC, r1EBE);
                        body.emit(assign(r1EBB, add(r1EBF, r1E7C), 0x02));

                        body.emit(assign(r1EBB, r1E7D, 0x01));

                        body.emit(assign(r1E80, r1EBB, 0x03));

                        body.emit(assign(r1E7F, body.constant(false), 0x01));


                     body.instructions = f1EAC_parent_instructions;
                     body.emit(f1EAC);

                     /* END IF */

                     body.emit(assign(r1CAB, r1E80, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E34->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1EC1 = less(r1CB1, r1CAF);
                     ir_if *f1EC0 = new(mem_ctx) ir_if(operand(r1EC1).val);
                     exec_list *const f1EC0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1EC0->then_instructions;

                        ir_variable *const r1EC2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r1EC3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1EC3, sub(r1CB0, r1CB2), 0x01));

                        ir_expression *const r1EC4 = sub(r1CAF, r1CB1);
                        ir_expression *const r1EC5 = less(r1CB0, r1CB2);
                        ir_expression *const r1EC6 = expr(ir_unop_b2i, r1EC5);
                        ir_expression *const r1EC7 = expr(ir_unop_i2u, r1EC6);
                        body.emit(assign(r1EC2, sub(r1EC4, r1EC7), 0x01));

                        body.emit(assign(r1CAA, bit_xor(r1CAA, body.constant(1u)), 0x01));

                        body.emit(assign(r1CB3, add(r1CAD, body.constant(int(-1))), 0x01));

                        ir_variable *const r1EC8 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r1EC8, add(r1CB3, body.constant(int(-10))), 0x01));

                        ir_variable *const r1EC9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r1EC9, r1EC2, 0x01));

                        ir_variable *const r1ECA = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1ECA, r1EC3, 0x01));

                        ir_variable *const r1ECB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r1ECB);
                        ir_variable *const r1ECC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r1ECC);
                        /* IF CONDITION */
                        ir_expression *const r1ECE = equal(r1EC2, body.constant(0u));
                        ir_if *f1ECD = new(mem_ctx) ir_if(operand(r1ECE).val);
                        exec_list *const f1ECD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1ECD->then_instructions;

                           body.emit(assign(r1EC9, r1EC3, 0x01));

                           body.emit(assign(r1ECA, body.constant(0u), 0x01));

                           body.emit(assign(r1EC8, add(r1EC8, body.constant(int(-32))), 0x01));


                        body.instructions = f1ECD_parent_instructions;
                        body.emit(f1ECD);

                        /* END IF */

                        ir_variable *const r1ECF = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r1ECF, r1EC9, 0x01));

                        ir_variable *const r1ED0 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r1ED1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r1ED1);
                        /* IF CONDITION */
                        ir_expression *const r1ED3 = equal(r1EC9, body.constant(0u));
                        ir_if *f1ED2 = new(mem_ctx) ir_if(operand(r1ED3).val);
                        exec_list *const f1ED2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1ED2->then_instructions;

                           body.emit(assign(r1ED0, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1ED2->else_instructions;

                           body.emit(assign(r1ED1, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1ED5 = bit_and(r1EC9, body.constant(4294901760u));
                           ir_expression *const r1ED6 = equal(r1ED5, body.constant(0u));
                           ir_if *f1ED4 = new(mem_ctx) ir_if(operand(r1ED6).val);
                           exec_list *const f1ED4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1ED4->then_instructions;

                              body.emit(assign(r1ED1, body.constant(int(16)), 0x01));

                              body.emit(assign(r1ECF, lshift(r1EC9, body.constant(int(16))), 0x01));


                           body.instructions = f1ED4_parent_instructions;
                           body.emit(f1ED4);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1ED8 = bit_and(r1ECF, body.constant(4278190080u));
                           ir_expression *const r1ED9 = equal(r1ED8, body.constant(0u));
                           ir_if *f1ED7 = new(mem_ctx) ir_if(operand(r1ED9).val);
                           exec_list *const f1ED7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1ED7->then_instructions;

                              body.emit(assign(r1ED1, add(r1ED1, body.constant(int(8))), 0x01));

                              body.emit(assign(r1ECF, lshift(r1ECF, body.constant(int(8))), 0x01));


                           body.instructions = f1ED7_parent_instructions;
                           body.emit(f1ED7);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1EDB = bit_and(r1ECF, body.constant(4026531840u));
                           ir_expression *const r1EDC = equal(r1EDB, body.constant(0u));
                           ir_if *f1EDA = new(mem_ctx) ir_if(operand(r1EDC).val);
                           exec_list *const f1EDA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EDA->then_instructions;

                              body.emit(assign(r1ED1, add(r1ED1, body.constant(int(4))), 0x01));

                              body.emit(assign(r1ECF, lshift(r1ECF, body.constant(int(4))), 0x01));


                           body.instructions = f1EDA_parent_instructions;
                           body.emit(f1EDA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1EDE = bit_and(r1ECF, body.constant(3221225472u));
                           ir_expression *const r1EDF = equal(r1EDE, body.constant(0u));
                           ir_if *f1EDD = new(mem_ctx) ir_if(operand(r1EDF).val);
                           exec_list *const f1EDD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EDD->then_instructions;

                              body.emit(assign(r1ED1, add(r1ED1, body.constant(int(2))), 0x01));

                              body.emit(assign(r1ECF, lshift(r1ECF, body.constant(int(2))), 0x01));


                           body.instructions = f1EDD_parent_instructions;
                           body.emit(f1EDD);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1EE1 = bit_and(r1ECF, body.constant(2147483648u));
                           ir_expression *const r1EE2 = equal(r1EE1, body.constant(0u));
                           ir_if *f1EE0 = new(mem_ctx) ir_if(operand(r1EE2).val);
                           exec_list *const f1EE0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EE0->then_instructions;

                              body.emit(assign(r1ED1, add(r1ED1, body.constant(int(1))), 0x01));


                           body.instructions = f1EE0_parent_instructions;
                           body.emit(f1EE0);

                           /* END IF */

                           body.emit(assign(r1ED0, r1ED1, 0x01));


                        body.instructions = f1ED2_parent_instructions;
                        body.emit(f1ED2);

                        /* END IF */

                        body.emit(assign(r1ECC, add(r1ED0, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1EE4 = lequal(body.constant(int(0)), r1ECC);
                        ir_if *f1EE3 = new(mem_ctx) ir_if(operand(r1EE4).val);
                        exec_list *const f1EE3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1EE3->then_instructions;

                           body.emit(assign(r1ECB, body.constant(0u), 0x01));

                           ir_variable *const r1EE5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1EE5, lshift(r1ECA, r1ECC), 0x01));

                           ir_variable *const r1EE6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1EE8 = equal(r1ECC, body.constant(int(0)));
                           ir_if *f1EE7 = new(mem_ctx) ir_if(operand(r1EE8).val);
                           exec_list *const f1EE7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EE7->then_instructions;

                              body.emit(assign(r1EE6, r1EC9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1EE7->else_instructions;

                              ir_expression *const r1EE9 = lshift(r1EC9, r1ECC);
                              ir_expression *const r1EEA = neg(r1ECC);
                              ir_expression *const r1EEB = bit_and(r1EEA, body.constant(int(31)));
                              ir_expression *const r1EEC = rshift(r1ECA, r1EEB);
                              body.emit(assign(r1EE6, bit_or(r1EE9, r1EEC), 0x01));


                           body.instructions = f1EE7_parent_instructions;
                           body.emit(f1EE7);

                           /* END IF */

                           body.emit(assign(r1EC9, r1EE6, 0x01));

                           body.emit(assign(r1ECA, r1EE5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1EE3->else_instructions;

                           ir_variable *const r1EED = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r1EED, body.constant(0u), 0x01));

                           ir_variable *const r1EEE = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r1EEE, neg(r1ECC), 0x01));

                           ir_variable *const r1EEF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r1EEF);
                           ir_variable *const r1EF0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r1EF0);
                           ir_variable *const r1EF1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r1EF1);
                           ir_variable *const r1EF2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r1EF3 = neg(r1EEE);
                           body.emit(assign(r1EF2, bit_and(r1EF3, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1EF5 = equal(r1EEE, body.constant(int(0)));
                           ir_if *f1EF4 = new(mem_ctx) ir_if(operand(r1EF5).val);
                           exec_list *const f1EF4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EF4->then_instructions;

                              body.emit(assign(r1EEF, r1EED, 0x01));

                              body.emit(assign(r1EF0, r1ECA, 0x01));

                              body.emit(assign(r1EF1, r1EC9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1EF4->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1EF7 = less(r1EEE, body.constant(int(32)));
                              ir_if *f1EF6 = new(mem_ctx) ir_if(operand(r1EF7).val);
                              exec_list *const f1EF6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1EF6->then_instructions;

                                 body.emit(assign(r1EEF, lshift(r1ECA, r1EF2), 0x01));

                                 ir_expression *const r1EF8 = lshift(r1EC9, r1EF2);
                                 ir_expression *const r1EF9 = rshift(r1ECA, r1EEE);
                                 body.emit(assign(r1EF0, bit_or(r1EF8, r1EF9), 0x01));

                                 body.emit(assign(r1EF1, rshift(r1EC9, r1EEE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1EF6->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1EFB = equal(r1EEE, body.constant(int(32)));
                                 ir_if *f1EFA = new(mem_ctx) ir_if(operand(r1EFB).val);
                                 exec_list *const f1EFA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1EFA->then_instructions;

                                    body.emit(assign(r1EEF, r1ECA, 0x01));

                                    body.emit(assign(r1EF0, r1EC9, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1EFA->else_instructions;

                                    body.emit(assign(r1EED, bit_or(body.constant(0u), r1ECA), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1EFD = less(r1EEE, body.constant(int(64)));
                                    ir_if *f1EFC = new(mem_ctx) ir_if(operand(r1EFD).val);
                                    exec_list *const f1EFC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1EFC->then_instructions;

                                       body.emit(assign(r1EEF, lshift(r1EC9, r1EF2), 0x01));

                                       ir_expression *const r1EFE = bit_and(r1EEE, body.constant(int(31)));
                                       body.emit(assign(r1EF0, rshift(r1EC9, r1EFE), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1EFC->else_instructions;

                                       ir_variable *const r1EFF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r1F01 = equal(r1EEE, body.constant(int(64)));
                                       ir_if *f1F00 = new(mem_ctx) ir_if(operand(r1F01).val);
                                       exec_list *const f1F00_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1F00->then_instructions;

                                          body.emit(assign(r1EFF, r1EC9, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1F00->else_instructions;

                                          ir_expression *const r1F02 = nequal(r1EC9, body.constant(0u));
                                          ir_expression *const r1F03 = expr(ir_unop_b2i, r1F02);
                                          body.emit(assign(r1EFF, expr(ir_unop_i2u, r1F03), 0x01));


                                       body.instructions = f1F00_parent_instructions;
                                       body.emit(f1F00);

                                       /* END IF */

                                       body.emit(assign(r1EEF, r1EFF, 0x01));

                                       body.emit(assign(r1EF0, body.constant(0u), 0x01));


                                    body.instructions = f1EFC_parent_instructions;
                                    body.emit(f1EFC);

                                    /* END IF */


                                 body.instructions = f1EFA_parent_instructions;
                                 body.emit(f1EFA);

                                 /* END IF */

                                 body.emit(assign(r1EF1, body.constant(0u), 0x01));


                              body.instructions = f1EF6_parent_instructions;
                              body.emit(f1EF6);

                              /* END IF */

                              ir_expression *const r1F04 = nequal(r1EED, body.constant(0u));
                              ir_expression *const r1F05 = expr(ir_unop_b2i, r1F04);
                              ir_expression *const r1F06 = expr(ir_unop_i2u, r1F05);
                              body.emit(assign(r1EEF, bit_or(r1EEF, r1F06), 0x01));


                           body.instructions = f1EF4_parent_instructions;
                           body.emit(f1EF4);

                           /* END IF */

                           body.emit(assign(r1EC9, r1EF1, 0x01));

                           body.emit(assign(r1ECA, r1EF0, 0x01));

                           body.emit(assign(r1ECB, r1EEF, 0x01));


                        body.instructions = f1EE3_parent_instructions;
                        body.emit(f1EE3);

                        /* END IF */

                        body.emit(assign(r1EC8, sub(r1EC8, r1ECC), 0x01));

                        ir_variable *const r1F07 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r1F07, r1EC8, 0x01));

                        ir_variable *const r1F08 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r1F08, r1EC9, 0x01));

                        ir_variable *const r1F09 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1F09, r1ECA, 0x01));

                        ir_variable *const r1F0A = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r1F0A, r1ECB, 0x01));

                        ir_variable *const r1F0B = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r1F0B, body.constant(true), 0x01));

                        ir_variable *const r1F0C = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r1F0D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r1F0D);
                        ir_expression *const r1F0E = expr(ir_unop_u2i, r1ECB);
                        body.emit(assign(r1F0D, less(r1F0E, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1F10 = lequal(body.constant(int(2045)), r1EC8);
                        ir_if *f1F0F = new(mem_ctx) ir_if(operand(r1F10).val);
                        exec_list *const f1F0F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F0F->then_instructions;

                           ir_variable *const r1F11 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1F13 = less(body.constant(int(2045)), r1EC8);
                           ir_if *f1F12 = new(mem_ctx) ir_if(operand(r1F13).val);
                           exec_list *const f1F12_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F12->then_instructions;

                              body.emit(assign(r1F11, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F12->else_instructions;

                              ir_variable *const r1F14 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1F16 = equal(r1EC8, body.constant(int(2045)));
                              ir_if *f1F15 = new(mem_ctx) ir_if(operand(r1F16).val);
                              exec_list *const f1F15_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F15->then_instructions;

                                 ir_expression *const r1F17 = equal(body.constant(2097151u), r1EC9);
                                 ir_expression *const r1F18 = equal(body.constant(4294967295u), r1ECA);
                                 body.emit(assign(r1F14, logic_and(r1F17, r1F18), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F15->else_instructions;

                                 body.emit(assign(r1F14, body.constant(false), 0x01));


                              body.instructions = f1F15_parent_instructions;
                              body.emit(f1F15);

                              /* END IF */

                              body.emit(assign(r1F11, logic_and(r1F14, r1F0D), 0x01));


                           body.instructions = f1F12_parent_instructions;
                           body.emit(f1F12);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1F19 = new(mem_ctx) ir_if(operand(r1F11).val);
                           exec_list *const f1F19_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F19->then_instructions;

                              ir_variable *const r1F1A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1F1A);
                              ir_expression *const r1F1B = lshift(r1CAA, body.constant(int(31)));
                              body.emit(assign(r1F1A, add(r1F1B, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r1F1A, body.constant(0u), 0x01));

                              body.emit(assign(r1F0C, r1F1A, 0x03));

                              body.emit(assign(r1F0B, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F19->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1F1D = less(r1EC8, body.constant(int(0)));
                              ir_if *f1F1C = new(mem_ctx) ir_if(operand(r1F1D).val);
                              exec_list *const f1F1C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F1C->then_instructions;

                                 ir_variable *const r1F1E = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1F1E, r1ECB, 0x01));

                                 ir_variable *const r1F1F = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1F1F, neg(r1EC8), 0x01));

                                 ir_variable *const r1F20 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1F20);
                                 ir_variable *const r1F21 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1F21);
                                 ir_variable *const r1F22 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1F22);
                                 ir_variable *const r1F23 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r1F24 = neg(r1F1F);
                                 body.emit(assign(r1F23, bit_and(r1F24, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1F26 = equal(r1F1F, body.constant(int(0)));
                                 ir_if *f1F25 = new(mem_ctx) ir_if(operand(r1F26).val);
                                 exec_list *const f1F25_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1F25->then_instructions;

                                    body.emit(assign(r1F20, r1ECB, 0x01));

                                    body.emit(assign(r1F21, r1ECA, 0x01));

                                    body.emit(assign(r1F22, r1EC9, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1F25->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1F28 = less(r1F1F, body.constant(int(32)));
                                    ir_if *f1F27 = new(mem_ctx) ir_if(operand(r1F28).val);
                                    exec_list *const f1F27_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1F27->then_instructions;

                                       body.emit(assign(r1F20, lshift(r1ECA, r1F23), 0x01));

                                       ir_expression *const r1F29 = lshift(r1EC9, r1F23);
                                       ir_expression *const r1F2A = rshift(r1ECA, r1F1F);
                                       body.emit(assign(r1F21, bit_or(r1F29, r1F2A), 0x01));

                                       body.emit(assign(r1F22, rshift(r1EC9, r1F1F), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1F27->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1F2C = equal(r1F1F, body.constant(int(32)));
                                       ir_if *f1F2B = new(mem_ctx) ir_if(operand(r1F2C).val);
                                       exec_list *const f1F2B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1F2B->then_instructions;

                                          body.emit(assign(r1F20, r1ECA, 0x01));

                                          body.emit(assign(r1F21, r1EC9, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1F2B->else_instructions;

                                          body.emit(assign(r1F1E, bit_or(r1ECB, r1ECA), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1F2E = less(r1F1F, body.constant(int(64)));
                                          ir_if *f1F2D = new(mem_ctx) ir_if(operand(r1F2E).val);
                                          exec_list *const f1F2D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1F2D->then_instructions;

                                             body.emit(assign(r1F20, lshift(r1EC9, r1F23), 0x01));

                                             ir_expression *const r1F2F = bit_and(r1F1F, body.constant(int(31)));
                                             body.emit(assign(r1F21, rshift(r1EC9, r1F2F), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1F2D->else_instructions;

                                             ir_variable *const r1F30 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1F32 = equal(r1F1F, body.constant(int(64)));
                                             ir_if *f1F31 = new(mem_ctx) ir_if(operand(r1F32).val);
                                             exec_list *const f1F31_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1F31->then_instructions;

                                                body.emit(assign(r1F30, r1EC9, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1F31->else_instructions;

                                                ir_expression *const r1F33 = nequal(r1EC9, body.constant(0u));
                                                ir_expression *const r1F34 = expr(ir_unop_b2i, r1F33);
                                                body.emit(assign(r1F30, expr(ir_unop_i2u, r1F34), 0x01));


                                             body.instructions = f1F31_parent_instructions;
                                             body.emit(f1F31);

                                             /* END IF */

                                             body.emit(assign(r1F20, r1F30, 0x01));

                                             body.emit(assign(r1F21, body.constant(0u), 0x01));


                                          body.instructions = f1F2D_parent_instructions;
                                          body.emit(f1F2D);

                                          /* END IF */


                                       body.instructions = f1F2B_parent_instructions;
                                       body.emit(f1F2B);

                                       /* END IF */

                                       body.emit(assign(r1F22, body.constant(0u), 0x01));


                                    body.instructions = f1F27_parent_instructions;
                                    body.emit(f1F27);

                                    /* END IF */

                                    ir_expression *const r1F35 = nequal(r1F1E, body.constant(0u));
                                    ir_expression *const r1F36 = expr(ir_unop_b2i, r1F35);
                                    ir_expression *const r1F37 = expr(ir_unop_i2u, r1F36);
                                    body.emit(assign(r1F20, bit_or(r1F20, r1F37), 0x01));


                                 body.instructions = f1F25_parent_instructions;
                                 body.emit(f1F25);

                                 /* END IF */

                                 body.emit(assign(r1F08, r1F22, 0x01));

                                 body.emit(assign(r1F09, r1F21, 0x01));

                                 body.emit(assign(r1F0A, r1F20, 0x01));

                                 body.emit(assign(r1F07, body.constant(int(0)), 0x01));

                                 body.emit(assign(r1F0D, less(r1F20, body.constant(0u)), 0x01));


                              body.instructions = f1F1C_parent_instructions;
                              body.emit(f1F1C);

                              /* END IF */


                           body.instructions = f1F19_parent_instructions;
                           body.emit(f1F19);

                           /* END IF */


                        body.instructions = f1F0F_parent_instructions;
                        body.emit(f1F0F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1F38 = new(mem_ctx) ir_if(operand(r1F0B).val);
                        exec_list *const f1F38_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F38->then_instructions;

                           /* IF CONDITION */
                           ir_if *f1F39 = new(mem_ctx) ir_if(operand(r1F0D).val);
                           exec_list *const f1F39_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F39->then_instructions;

                              ir_variable *const r1F3A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r1F3A, add(r1F09, body.constant(1u)), 0x01));

                              ir_expression *const r1F3B = less(r1F3A, r1F09);
                              ir_expression *const r1F3C = expr(ir_unop_b2i, r1F3B);
                              ir_expression *const r1F3D = expr(ir_unop_i2u, r1F3C);
                              body.emit(assign(r1F08, add(r1F08, r1F3D), 0x01));

                              ir_expression *const r1F3E = equal(r1F0A, body.constant(0u));
                              ir_expression *const r1F3F = expr(ir_unop_b2i, r1F3E);
                              ir_expression *const r1F40 = expr(ir_unop_i2u, r1F3F);
                              ir_expression *const r1F41 = add(r1F0A, r1F40);
                              ir_expression *const r1F42 = bit_and(r1F41, body.constant(1u));
                              ir_expression *const r1F43 = expr(ir_unop_bit_not, r1F42);
                              body.emit(assign(r1F09, bit_and(r1F3A, r1F43), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F39->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1F45 = bit_or(r1F08, r1F09);
                              ir_expression *const r1F46 = equal(r1F45, body.constant(0u));
                              ir_if *f1F44 = new(mem_ctx) ir_if(operand(r1F46).val);
                              exec_list *const f1F44_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F44->then_instructions;

                                 body.emit(assign(r1F07, body.constant(int(0)), 0x01));


                              body.instructions = f1F44_parent_instructions;
                              body.emit(f1F44);

                              /* END IF */


                           body.instructions = f1F39_parent_instructions;
                           body.emit(f1F39);

                           /* END IF */

                           ir_variable *const r1F47 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1F47);
                           ir_expression *const r1F48 = lshift(r1CAA, body.constant(int(31)));
                           ir_expression *const r1F49 = expr(ir_unop_i2u, r1F07);
                           ir_expression *const r1F4A = lshift(r1F49, body.constant(int(20)));
                           ir_expression *const r1F4B = add(r1F48, r1F4A);
                           body.emit(assign(r1F47, add(r1F4B, r1F08), 0x02));

                           body.emit(assign(r1F47, r1F09, 0x01));

                           body.emit(assign(r1F0C, r1F47, 0x03));

                           body.emit(assign(r1F0B, body.constant(false), 0x01));


                        body.instructions = f1F38_parent_instructions;
                        body.emit(f1F38);

                        /* END IF */

                        body.emit(assign(r1CAB, r1F0C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1EC0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1F4D = less(r1CB0, r1CB2);
                        ir_if *f1F4C = new(mem_ctx) ir_if(operand(r1F4D).val);
                        exec_list *const f1F4C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F4C->then_instructions;

                           ir_variable *const r1F4E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r1F4F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1F4F, sub(r1CB2, r1CB0), 0x01));

                           ir_expression *const r1F50 = sub(r1CB1, r1CAF);
                           ir_expression *const r1F51 = less(r1CB2, r1CB0);
                           ir_expression *const r1F52 = expr(ir_unop_b2i, r1F51);
                           ir_expression *const r1F53 = expr(ir_unop_i2u, r1F52);
                           body.emit(assign(r1F4E, sub(r1F50, r1F53), 0x01));

                           body.emit(assign(r1CB3, add(r1CAE, body.constant(int(-1))), 0x01));

                           ir_variable *const r1F54 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1F54, add(r1CB3, body.constant(int(-10))), 0x01));

                           ir_variable *const r1F55 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1F55, r1F4E, 0x01));

                           ir_variable *const r1F56 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1F56, r1F4F, 0x01));

                           ir_variable *const r1F57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r1F57);
                           ir_variable *const r1F58 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1F58);
                           /* IF CONDITION */
                           ir_expression *const r1F5A = equal(r1F4E, body.constant(0u));
                           ir_if *f1F59 = new(mem_ctx) ir_if(operand(r1F5A).val);
                           exec_list *const f1F59_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F59->then_instructions;

                              body.emit(assign(r1F55, r1F4F, 0x01));

                              body.emit(assign(r1F56, body.constant(0u), 0x01));

                              body.emit(assign(r1F54, add(r1F54, body.constant(int(-32))), 0x01));


                           body.instructions = f1F59_parent_instructions;
                           body.emit(f1F59);

                           /* END IF */

                           ir_variable *const r1F5B = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r1F5B, r1F55, 0x01));

                           ir_variable *const r1F5C = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r1F5D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1F5D);
                           /* IF CONDITION */
                           ir_expression *const r1F5F = equal(r1F55, body.constant(0u));
                           ir_if *f1F5E = new(mem_ctx) ir_if(operand(r1F5F).val);
                           exec_list *const f1F5E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F5E->then_instructions;

                              body.emit(assign(r1F5C, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F5E->else_instructions;

                              body.emit(assign(r1F5D, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1F61 = bit_and(r1F55, body.constant(4294901760u));
                              ir_expression *const r1F62 = equal(r1F61, body.constant(0u));
                              ir_if *f1F60 = new(mem_ctx) ir_if(operand(r1F62).val);
                              exec_list *const f1F60_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F60->then_instructions;

                                 body.emit(assign(r1F5D, body.constant(int(16)), 0x01));

                                 body.emit(assign(r1F5B, lshift(r1F55, body.constant(int(16))), 0x01));


                              body.instructions = f1F60_parent_instructions;
                              body.emit(f1F60);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1F64 = bit_and(r1F5B, body.constant(4278190080u));
                              ir_expression *const r1F65 = equal(r1F64, body.constant(0u));
                              ir_if *f1F63 = new(mem_ctx) ir_if(operand(r1F65).val);
                              exec_list *const f1F63_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F63->then_instructions;

                                 body.emit(assign(r1F5D, add(r1F5D, body.constant(int(8))), 0x01));

                                 body.emit(assign(r1F5B, lshift(r1F5B, body.constant(int(8))), 0x01));


                              body.instructions = f1F63_parent_instructions;
                              body.emit(f1F63);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1F67 = bit_and(r1F5B, body.constant(4026531840u));
                              ir_expression *const r1F68 = equal(r1F67, body.constant(0u));
                              ir_if *f1F66 = new(mem_ctx) ir_if(operand(r1F68).val);
                              exec_list *const f1F66_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F66->then_instructions;

                                 body.emit(assign(r1F5D, add(r1F5D, body.constant(int(4))), 0x01));

                                 body.emit(assign(r1F5B, lshift(r1F5B, body.constant(int(4))), 0x01));


                              body.instructions = f1F66_parent_instructions;
                              body.emit(f1F66);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1F6A = bit_and(r1F5B, body.constant(3221225472u));
                              ir_expression *const r1F6B = equal(r1F6A, body.constant(0u));
                              ir_if *f1F69 = new(mem_ctx) ir_if(operand(r1F6B).val);
                              exec_list *const f1F69_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F69->then_instructions;

                                 body.emit(assign(r1F5D, add(r1F5D, body.constant(int(2))), 0x01));

                                 body.emit(assign(r1F5B, lshift(r1F5B, body.constant(int(2))), 0x01));


                              body.instructions = f1F69_parent_instructions;
                              body.emit(f1F69);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1F6D = bit_and(r1F5B, body.constant(2147483648u));
                              ir_expression *const r1F6E = equal(r1F6D, body.constant(0u));
                              ir_if *f1F6C = new(mem_ctx) ir_if(operand(r1F6E).val);
                              exec_list *const f1F6C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F6C->then_instructions;

                                 body.emit(assign(r1F5D, add(r1F5D, body.constant(int(1))), 0x01));


                              body.instructions = f1F6C_parent_instructions;
                              body.emit(f1F6C);

                              /* END IF */

                              body.emit(assign(r1F5C, r1F5D, 0x01));


                           body.instructions = f1F5E_parent_instructions;
                           body.emit(f1F5E);

                           /* END IF */

                           body.emit(assign(r1F58, add(r1F5C, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1F70 = lequal(body.constant(int(0)), r1F58);
                           ir_if *f1F6F = new(mem_ctx) ir_if(operand(r1F70).val);
                           exec_list *const f1F6F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F6F->then_instructions;

                              body.emit(assign(r1F57, body.constant(0u), 0x01));

                              ir_variable *const r1F71 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1F71, lshift(r1F56, r1F58), 0x01));

                              ir_variable *const r1F72 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1F74 = equal(r1F58, body.constant(int(0)));
                              ir_if *f1F73 = new(mem_ctx) ir_if(operand(r1F74).val);
                              exec_list *const f1F73_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F73->then_instructions;

                                 body.emit(assign(r1F72, r1F55, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F73->else_instructions;

                                 ir_expression *const r1F75 = lshift(r1F55, r1F58);
                                 ir_expression *const r1F76 = neg(r1F58);
                                 ir_expression *const r1F77 = bit_and(r1F76, body.constant(int(31)));
                                 ir_expression *const r1F78 = rshift(r1F56, r1F77);
                                 body.emit(assign(r1F72, bit_or(r1F75, r1F78), 0x01));


                              body.instructions = f1F73_parent_instructions;
                              body.emit(f1F73);

                              /* END IF */

                              body.emit(assign(r1F55, r1F72, 0x01));

                              body.emit(assign(r1F56, r1F71, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F6F->else_instructions;

                              ir_variable *const r1F79 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1F79, body.constant(0u), 0x01));

                              ir_variable *const r1F7A = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1F7A, neg(r1F58), 0x01));

                              ir_variable *const r1F7B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1F7B);
                              ir_variable *const r1F7C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1F7C);
                              ir_variable *const r1F7D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1F7D);
                              ir_variable *const r1F7E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1F7F = neg(r1F7A);
                              body.emit(assign(r1F7E, bit_and(r1F7F, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1F81 = equal(r1F7A, body.constant(int(0)));
                              ir_if *f1F80 = new(mem_ctx) ir_if(operand(r1F81).val);
                              exec_list *const f1F80_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F80->then_instructions;

                                 body.emit(assign(r1F7B, r1F79, 0x01));

                                 body.emit(assign(r1F7C, r1F56, 0x01));

                                 body.emit(assign(r1F7D, r1F55, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F80->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1F83 = less(r1F7A, body.constant(int(32)));
                                 ir_if *f1F82 = new(mem_ctx) ir_if(operand(r1F83).val);
                                 exec_list *const f1F82_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1F82->then_instructions;

                                    body.emit(assign(r1F7B, lshift(r1F56, r1F7E), 0x01));

                                    ir_expression *const r1F84 = lshift(r1F55, r1F7E);
                                    ir_expression *const r1F85 = rshift(r1F56, r1F7A);
                                    body.emit(assign(r1F7C, bit_or(r1F84, r1F85), 0x01));

                                    body.emit(assign(r1F7D, rshift(r1F55, r1F7A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1F82->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1F87 = equal(r1F7A, body.constant(int(32)));
                                    ir_if *f1F86 = new(mem_ctx) ir_if(operand(r1F87).val);
                                    exec_list *const f1F86_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1F86->then_instructions;

                                       body.emit(assign(r1F7B, r1F56, 0x01));

                                       body.emit(assign(r1F7C, r1F55, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1F86->else_instructions;

                                       body.emit(assign(r1F79, bit_or(body.constant(0u), r1F56), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1F89 = less(r1F7A, body.constant(int(64)));
                                       ir_if *f1F88 = new(mem_ctx) ir_if(operand(r1F89).val);
                                       exec_list *const f1F88_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1F88->then_instructions;

                                          body.emit(assign(r1F7B, lshift(r1F55, r1F7E), 0x01));

                                          ir_expression *const r1F8A = bit_and(r1F7A, body.constant(int(31)));
                                          body.emit(assign(r1F7C, rshift(r1F55, r1F8A), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1F88->else_instructions;

                                          ir_variable *const r1F8B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1F8D = equal(r1F7A, body.constant(int(64)));
                                          ir_if *f1F8C = new(mem_ctx) ir_if(operand(r1F8D).val);
                                          exec_list *const f1F8C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1F8C->then_instructions;

                                             body.emit(assign(r1F8B, r1F55, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1F8C->else_instructions;

                                             ir_expression *const r1F8E = nequal(r1F55, body.constant(0u));
                                             ir_expression *const r1F8F = expr(ir_unop_b2i, r1F8E);
                                             body.emit(assign(r1F8B, expr(ir_unop_i2u, r1F8F), 0x01));


                                          body.instructions = f1F8C_parent_instructions;
                                          body.emit(f1F8C);

                                          /* END IF */

                                          body.emit(assign(r1F7B, r1F8B, 0x01));

                                          body.emit(assign(r1F7C, body.constant(0u), 0x01));


                                       body.instructions = f1F88_parent_instructions;
                                       body.emit(f1F88);

                                       /* END IF */


                                    body.instructions = f1F86_parent_instructions;
                                    body.emit(f1F86);

                                    /* END IF */

                                    body.emit(assign(r1F7D, body.constant(0u), 0x01));


                                 body.instructions = f1F82_parent_instructions;
                                 body.emit(f1F82);

                                 /* END IF */

                                 ir_expression *const r1F90 = nequal(r1F79, body.constant(0u));
                                 ir_expression *const r1F91 = expr(ir_unop_b2i, r1F90);
                                 ir_expression *const r1F92 = expr(ir_unop_i2u, r1F91);
                                 body.emit(assign(r1F7B, bit_or(r1F7B, r1F92), 0x01));


                              body.instructions = f1F80_parent_instructions;
                              body.emit(f1F80);

                              /* END IF */

                              body.emit(assign(r1F55, r1F7D, 0x01));

                              body.emit(assign(r1F56, r1F7C, 0x01));

                              body.emit(assign(r1F57, r1F7B, 0x01));


                           body.instructions = f1F6F_parent_instructions;
                           body.emit(f1F6F);

                           /* END IF */

                           body.emit(assign(r1F54, sub(r1F54, r1F58), 0x01));

                           ir_variable *const r1F93 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1F93, r1F54, 0x01));

                           ir_variable *const r1F94 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1F94, r1F55, 0x01));

                           ir_variable *const r1F95 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1F95, r1F56, 0x01));

                           ir_variable *const r1F96 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r1F96, r1F57, 0x01));

                           ir_variable *const r1F97 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r1F97, body.constant(true), 0x01));

                           ir_variable *const r1F98 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r1F99 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r1F99);
                           ir_expression *const r1F9A = expr(ir_unop_u2i, r1F57);
                           body.emit(assign(r1F99, less(r1F9A, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1F9C = lequal(body.constant(int(2045)), r1F54);
                           ir_if *f1F9B = new(mem_ctx) ir_if(operand(r1F9C).val);
                           exec_list *const f1F9B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F9B->then_instructions;

                              ir_variable *const r1F9D = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1F9F = less(body.constant(int(2045)), r1F54);
                              ir_if *f1F9E = new(mem_ctx) ir_if(operand(r1F9F).val);
                              exec_list *const f1F9E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F9E->then_instructions;

                                 body.emit(assign(r1F9D, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F9E->else_instructions;

                                 ir_variable *const r1FA0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1FA2 = equal(r1F54, body.constant(int(2045)));
                                 ir_if *f1FA1 = new(mem_ctx) ir_if(operand(r1FA2).val);
                                 exec_list *const f1FA1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FA1->then_instructions;

                                    ir_expression *const r1FA3 = equal(body.constant(2097151u), r1F55);
                                    ir_expression *const r1FA4 = equal(body.constant(4294967295u), r1F56);
                                    body.emit(assign(r1FA0, logic_and(r1FA3, r1FA4), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1FA1->else_instructions;

                                    body.emit(assign(r1FA0, body.constant(false), 0x01));


                                 body.instructions = f1FA1_parent_instructions;
                                 body.emit(f1FA1);

                                 /* END IF */

                                 body.emit(assign(r1F9D, logic_and(r1FA0, r1F99), 0x01));


                              body.instructions = f1F9E_parent_instructions;
                              body.emit(f1F9E);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f1FA5 = new(mem_ctx) ir_if(operand(r1F9D).val);
                              exec_list *const f1FA5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FA5->then_instructions;

                                 ir_variable *const r1FA6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r1FA6);
                                 ir_expression *const r1FA7 = lshift(r1CAA, body.constant(int(31)));
                                 body.emit(assign(r1FA6, add(r1FA7, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r1FA6, body.constant(0u), 0x01));

                                 body.emit(assign(r1F98, r1FA6, 0x03));

                                 body.emit(assign(r1F97, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FA5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1FA9 = less(r1F54, body.constant(int(0)));
                                 ir_if *f1FA8 = new(mem_ctx) ir_if(operand(r1FA9).val);
                                 exec_list *const f1FA8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FA8->then_instructions;

                                    ir_variable *const r1FAA = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r1FAA, r1F57, 0x01));

                                    ir_variable *const r1FAB = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r1FAB, neg(r1F54), 0x01));

                                    ir_variable *const r1FAC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r1FAC);
                                    ir_variable *const r1FAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r1FAD);
                                    ir_variable *const r1FAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r1FAE);
                                    ir_variable *const r1FAF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r1FB0 = neg(r1FAB);
                                    body.emit(assign(r1FAF, bit_and(r1FB0, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1FB2 = equal(r1FAB, body.constant(int(0)));
                                    ir_if *f1FB1 = new(mem_ctx) ir_if(operand(r1FB2).val);
                                    exec_list *const f1FB1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1FB1->then_instructions;

                                       body.emit(assign(r1FAC, r1F57, 0x01));

                                       body.emit(assign(r1FAD, r1F56, 0x01));

                                       body.emit(assign(r1FAE, r1F55, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1FB1->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1FB4 = less(r1FAB, body.constant(int(32)));
                                       ir_if *f1FB3 = new(mem_ctx) ir_if(operand(r1FB4).val);
                                       exec_list *const f1FB3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1FB3->then_instructions;

                                          body.emit(assign(r1FAC, lshift(r1F56, r1FAF), 0x01));

                                          ir_expression *const r1FB5 = lshift(r1F55, r1FAF);
                                          ir_expression *const r1FB6 = rshift(r1F56, r1FAB);
                                          body.emit(assign(r1FAD, bit_or(r1FB5, r1FB6), 0x01));

                                          body.emit(assign(r1FAE, rshift(r1F55, r1FAB), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1FB3->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r1FB8 = equal(r1FAB, body.constant(int(32)));
                                          ir_if *f1FB7 = new(mem_ctx) ir_if(operand(r1FB8).val);
                                          exec_list *const f1FB7_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1FB7->then_instructions;

                                             body.emit(assign(r1FAC, r1F56, 0x01));

                                             body.emit(assign(r1FAD, r1F55, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1FB7->else_instructions;

                                             body.emit(assign(r1FAA, bit_or(r1F57, r1F56), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r1FBA = less(r1FAB, body.constant(int(64)));
                                             ir_if *f1FB9 = new(mem_ctx) ir_if(operand(r1FBA).val);
                                             exec_list *const f1FB9_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1FB9->then_instructions;

                                                body.emit(assign(r1FAC, lshift(r1F55, r1FAF), 0x01));

                                                ir_expression *const r1FBB = bit_and(r1FAB, body.constant(int(31)));
                                                body.emit(assign(r1FAD, rshift(r1F55, r1FBB), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1FB9->else_instructions;

                                                ir_variable *const r1FBC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r1FBE = equal(r1FAB, body.constant(int(64)));
                                                ir_if *f1FBD = new(mem_ctx) ir_if(operand(r1FBE).val);
                                                exec_list *const f1FBD_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f1FBD->then_instructions;

                                                   body.emit(assign(r1FBC, r1F55, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f1FBD->else_instructions;

                                                   ir_expression *const r1FBF = nequal(r1F55, body.constant(0u));
                                                   ir_expression *const r1FC0 = expr(ir_unop_b2i, r1FBF);
                                                   body.emit(assign(r1FBC, expr(ir_unop_i2u, r1FC0), 0x01));


                                                body.instructions = f1FBD_parent_instructions;
                                                body.emit(f1FBD);

                                                /* END IF */

                                                body.emit(assign(r1FAC, r1FBC, 0x01));

                                                body.emit(assign(r1FAD, body.constant(0u), 0x01));


                                             body.instructions = f1FB9_parent_instructions;
                                             body.emit(f1FB9);

                                             /* END IF */


                                          body.instructions = f1FB7_parent_instructions;
                                          body.emit(f1FB7);

                                          /* END IF */

                                          body.emit(assign(r1FAE, body.constant(0u), 0x01));


                                       body.instructions = f1FB3_parent_instructions;
                                       body.emit(f1FB3);

                                       /* END IF */

                                       ir_expression *const r1FC1 = nequal(r1FAA, body.constant(0u));
                                       ir_expression *const r1FC2 = expr(ir_unop_b2i, r1FC1);
                                       ir_expression *const r1FC3 = expr(ir_unop_i2u, r1FC2);
                                       body.emit(assign(r1FAC, bit_or(r1FAC, r1FC3), 0x01));


                                    body.instructions = f1FB1_parent_instructions;
                                    body.emit(f1FB1);

                                    /* END IF */

                                    body.emit(assign(r1F94, r1FAE, 0x01));

                                    body.emit(assign(r1F95, r1FAD, 0x01));

                                    body.emit(assign(r1F96, r1FAC, 0x01));

                                    body.emit(assign(r1F93, body.constant(int(0)), 0x01));

                                    body.emit(assign(r1F99, less(r1FAC, body.constant(0u)), 0x01));


                                 body.instructions = f1FA8_parent_instructions;
                                 body.emit(f1FA8);

                                 /* END IF */


                              body.instructions = f1FA5_parent_instructions;
                              body.emit(f1FA5);

                              /* END IF */


                           body.instructions = f1F9B_parent_instructions;
                           body.emit(f1F9B);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1FC4 = new(mem_ctx) ir_if(operand(r1F97).val);
                           exec_list *const f1FC4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1FC4->then_instructions;

                              /* IF CONDITION */
                              ir_if *f1FC5 = new(mem_ctx) ir_if(operand(r1F99).val);
                              exec_list *const f1FC5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FC5->then_instructions;

                                 ir_variable *const r1FC6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r1FC6, add(r1F95, body.constant(1u)), 0x01));

                                 ir_expression *const r1FC7 = less(r1FC6, r1F95);
                                 ir_expression *const r1FC8 = expr(ir_unop_b2i, r1FC7);
                                 ir_expression *const r1FC9 = expr(ir_unop_i2u, r1FC8);
                                 body.emit(assign(r1F94, add(r1F94, r1FC9), 0x01));

                                 ir_expression *const r1FCA = equal(r1F96, body.constant(0u));
                                 ir_expression *const r1FCB = expr(ir_unop_b2i, r1FCA);
                                 ir_expression *const r1FCC = expr(ir_unop_i2u, r1FCB);
                                 ir_expression *const r1FCD = add(r1F96, r1FCC);
                                 ir_expression *const r1FCE = bit_and(r1FCD, body.constant(1u));
                                 ir_expression *const r1FCF = expr(ir_unop_bit_not, r1FCE);
                                 body.emit(assign(r1F95, bit_and(r1FC6, r1FCF), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FC5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1FD1 = bit_or(r1F94, r1F95);
                                 ir_expression *const r1FD2 = equal(r1FD1, body.constant(0u));
                                 ir_if *f1FD0 = new(mem_ctx) ir_if(operand(r1FD2).val);
                                 exec_list *const f1FD0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FD0->then_instructions;

                                    body.emit(assign(r1F93, body.constant(int(0)), 0x01));


                                 body.instructions = f1FD0_parent_instructions;
                                 body.emit(f1FD0);

                                 /* END IF */


                              body.instructions = f1FC5_parent_instructions;
                              body.emit(f1FC5);

                              /* END IF */

                              ir_variable *const r1FD3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1FD3);
                              ir_expression *const r1FD4 = lshift(r1CAA, body.constant(int(31)));
                              ir_expression *const r1FD5 = expr(ir_unop_i2u, r1F93);
                              ir_expression *const r1FD6 = lshift(r1FD5, body.constant(int(20)));
                              ir_expression *const r1FD7 = add(r1FD4, r1FD6);
                              body.emit(assign(r1FD3, add(r1FD7, r1F94), 0x02));

                              body.emit(assign(r1FD3, r1F95, 0x01));

                              body.emit(assign(r1F98, r1FD3, 0x03));

                              body.emit(assign(r1F97, body.constant(false), 0x01));


                           body.instructions = f1FC4_parent_instructions;
                           body.emit(f1FC4);

                           /* END IF */

                           body.emit(assign(r1CAB, r1F98, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1F4C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1FD9 = less(r1CB2, r1CB0);
                           ir_if *f1FD8 = new(mem_ctx) ir_if(operand(r1FD9).val);
                           exec_list *const f1FD8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1FD8->then_instructions;

                              ir_variable *const r1FDA = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r1FDB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1FDB, sub(r1CB0, r1CB2), 0x01));

                              ir_expression *const r1FDC = sub(r1CAF, r1CB1);
                              ir_expression *const r1FDD = less(r1CB0, r1CB2);
                              ir_expression *const r1FDE = expr(ir_unop_b2i, r1FDD);
                              ir_expression *const r1FDF = expr(ir_unop_i2u, r1FDE);
                              body.emit(assign(r1FDA, sub(r1FDC, r1FDF), 0x01));

                              body.emit(assign(r1CAA, bit_xor(r1CAA, body.constant(1u)), 0x01));

                              body.emit(assign(r1CB3, add(r1CAD, body.constant(int(-1))), 0x01));

                              ir_variable *const r1FE0 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r1FE0, add(r1CB3, body.constant(int(-10))), 0x01));

                              ir_variable *const r1FE1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r1FE1, r1FDA, 0x01));

                              ir_variable *const r1FE2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r1FE2, r1FDB, 0x01));

                              ir_variable *const r1FE3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r1FE3);
                              ir_variable *const r1FE4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r1FE4);
                              /* IF CONDITION */
                              ir_expression *const r1FE6 = equal(r1FDA, body.constant(0u));
                              ir_if *f1FE5 = new(mem_ctx) ir_if(operand(r1FE6).val);
                              exec_list *const f1FE5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FE5->then_instructions;

                                 body.emit(assign(r1FE1, r1FDB, 0x01));

                                 body.emit(assign(r1FE2, body.constant(0u), 0x01));

                                 body.emit(assign(r1FE0, add(r1FE0, body.constant(int(-32))), 0x01));


                              body.instructions = f1FE5_parent_instructions;
                              body.emit(f1FE5);

                              /* END IF */

                              ir_variable *const r1FE7 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r1FE7, r1FE1, 0x01));

                              ir_variable *const r1FE8 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r1FE9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r1FE9);
                              /* IF CONDITION */
                              ir_expression *const r1FEB = equal(r1FE1, body.constant(0u));
                              ir_if *f1FEA = new(mem_ctx) ir_if(operand(r1FEB).val);
                              exec_list *const f1FEA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FEA->then_instructions;

                                 body.emit(assign(r1FE8, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FEA->else_instructions;

                                 body.emit(assign(r1FE9, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1FED = bit_and(r1FE1, body.constant(4294901760u));
                                 ir_expression *const r1FEE = equal(r1FED, body.constant(0u));
                                 ir_if *f1FEC = new(mem_ctx) ir_if(operand(r1FEE).val);
                                 exec_list *const f1FEC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FEC->then_instructions;

                                    body.emit(assign(r1FE9, body.constant(int(16)), 0x01));

                                    body.emit(assign(r1FE7, lshift(r1FE1, body.constant(int(16))), 0x01));


                                 body.instructions = f1FEC_parent_instructions;
                                 body.emit(f1FEC);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1FF0 = bit_and(r1FE7, body.constant(4278190080u));
                                 ir_expression *const r1FF1 = equal(r1FF0, body.constant(0u));
                                 ir_if *f1FEF = new(mem_ctx) ir_if(operand(r1FF1).val);
                                 exec_list *const f1FEF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FEF->then_instructions;

                                    body.emit(assign(r1FE9, add(r1FE9, body.constant(int(8))), 0x01));

                                    body.emit(assign(r1FE7, lshift(r1FE7, body.constant(int(8))), 0x01));


                                 body.instructions = f1FEF_parent_instructions;
                                 body.emit(f1FEF);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1FF3 = bit_and(r1FE7, body.constant(4026531840u));
                                 ir_expression *const r1FF4 = equal(r1FF3, body.constant(0u));
                                 ir_if *f1FF2 = new(mem_ctx) ir_if(operand(r1FF4).val);
                                 exec_list *const f1FF2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FF2->then_instructions;

                                    body.emit(assign(r1FE9, add(r1FE9, body.constant(int(4))), 0x01));

                                    body.emit(assign(r1FE7, lshift(r1FE7, body.constant(int(4))), 0x01));


                                 body.instructions = f1FF2_parent_instructions;
                                 body.emit(f1FF2);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1FF6 = bit_and(r1FE7, body.constant(3221225472u));
                                 ir_expression *const r1FF7 = equal(r1FF6, body.constant(0u));
                                 ir_if *f1FF5 = new(mem_ctx) ir_if(operand(r1FF7).val);
                                 exec_list *const f1FF5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FF5->then_instructions;

                                    body.emit(assign(r1FE9, add(r1FE9, body.constant(int(2))), 0x01));

                                    body.emit(assign(r1FE7, lshift(r1FE7, body.constant(int(2))), 0x01));


                                 body.instructions = f1FF5_parent_instructions;
                                 body.emit(f1FF5);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1FF9 = bit_and(r1FE7, body.constant(2147483648u));
                                 ir_expression *const r1FFA = equal(r1FF9, body.constant(0u));
                                 ir_if *f1FF8 = new(mem_ctx) ir_if(operand(r1FFA).val);
                                 exec_list *const f1FF8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FF8->then_instructions;

                                    body.emit(assign(r1FE9, add(r1FE9, body.constant(int(1))), 0x01));


                                 body.instructions = f1FF8_parent_instructions;
                                 body.emit(f1FF8);

                                 /* END IF */

                                 body.emit(assign(r1FE8, r1FE9, 0x01));


                              body.instructions = f1FEA_parent_instructions;
                              body.emit(f1FEA);

                              /* END IF */

                              body.emit(assign(r1FE4, add(r1FE8, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1FFC = lequal(body.constant(int(0)), r1FE4);
                              ir_if *f1FFB = new(mem_ctx) ir_if(operand(r1FFC).val);
                              exec_list *const f1FFB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FFB->then_instructions;

                                 body.emit(assign(r1FE3, body.constant(0u), 0x01));

                                 ir_variable *const r1FFD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r1FFD, lshift(r1FE2, r1FE4), 0x01));

                                 ir_variable *const r1FFE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2000 = equal(r1FE4, body.constant(int(0)));
                                 ir_if *f1FFF = new(mem_ctx) ir_if(operand(r2000).val);
                                 exec_list *const f1FFF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FFF->then_instructions;

                                    body.emit(assign(r1FFE, r1FE1, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1FFF->else_instructions;

                                    ir_expression *const r2001 = lshift(r1FE1, r1FE4);
                                    ir_expression *const r2002 = neg(r1FE4);
                                    ir_expression *const r2003 = bit_and(r2002, body.constant(int(31)));
                                    ir_expression *const r2004 = rshift(r1FE2, r2003);
                                    body.emit(assign(r1FFE, bit_or(r2001, r2004), 0x01));


                                 body.instructions = f1FFF_parent_instructions;
                                 body.emit(f1FFF);

                                 /* END IF */

                                 body.emit(assign(r1FE1, r1FFE, 0x01));

                                 body.emit(assign(r1FE2, r1FFD, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FFB->else_instructions;

                                 ir_variable *const r2005 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2005, body.constant(0u), 0x01));

                                 ir_variable *const r2006 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2006, neg(r1FE4), 0x01));

                                 ir_variable *const r2007 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2007);
                                 ir_variable *const r2008 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2008);
                                 ir_variable *const r2009 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2009);
                                 ir_variable *const r200A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r200B = neg(r2006);
                                 body.emit(assign(r200A, bit_and(r200B, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r200D = equal(r2006, body.constant(int(0)));
                                 ir_if *f200C = new(mem_ctx) ir_if(operand(r200D).val);
                                 exec_list *const f200C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f200C->then_instructions;

                                    body.emit(assign(r2007, r2005, 0x01));

                                    body.emit(assign(r2008, r1FE2, 0x01));

                                    body.emit(assign(r2009, r1FE1, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f200C->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r200F = less(r2006, body.constant(int(32)));
                                    ir_if *f200E = new(mem_ctx) ir_if(operand(r200F).val);
                                    exec_list *const f200E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f200E->then_instructions;

                                       body.emit(assign(r2007, lshift(r1FE2, r200A), 0x01));

                                       ir_expression *const r2010 = lshift(r1FE1, r200A);
                                       ir_expression *const r2011 = rshift(r1FE2, r2006);
                                       body.emit(assign(r2008, bit_or(r2010, r2011), 0x01));

                                       body.emit(assign(r2009, rshift(r1FE1, r2006), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f200E->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2013 = equal(r2006, body.constant(int(32)));
                                       ir_if *f2012 = new(mem_ctx) ir_if(operand(r2013).val);
                                       exec_list *const f2012_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2012->then_instructions;

                                          body.emit(assign(r2007, r1FE2, 0x01));

                                          body.emit(assign(r2008, r1FE1, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2012->else_instructions;

                                          body.emit(assign(r2005, bit_or(body.constant(0u), r1FE2), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2015 = less(r2006, body.constant(int(64)));
                                          ir_if *f2014 = new(mem_ctx) ir_if(operand(r2015).val);
                                          exec_list *const f2014_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2014->then_instructions;

                                             body.emit(assign(r2007, lshift(r1FE1, r200A), 0x01));

                                             ir_expression *const r2016 = bit_and(r2006, body.constant(int(31)));
                                             body.emit(assign(r2008, rshift(r1FE1, r2016), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2014->else_instructions;

                                             ir_variable *const r2017 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2019 = equal(r2006, body.constant(int(64)));
                                             ir_if *f2018 = new(mem_ctx) ir_if(operand(r2019).val);
                                             exec_list *const f2018_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2018->then_instructions;

                                                body.emit(assign(r2017, r1FE1, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2018->else_instructions;

                                                ir_expression *const r201A = nequal(r1FE1, body.constant(0u));
                                                ir_expression *const r201B = expr(ir_unop_b2i, r201A);
                                                body.emit(assign(r2017, expr(ir_unop_i2u, r201B), 0x01));


                                             body.instructions = f2018_parent_instructions;
                                             body.emit(f2018);

                                             /* END IF */

                                             body.emit(assign(r2007, r2017, 0x01));

                                             body.emit(assign(r2008, body.constant(0u), 0x01));


                                          body.instructions = f2014_parent_instructions;
                                          body.emit(f2014);

                                          /* END IF */


                                       body.instructions = f2012_parent_instructions;
                                       body.emit(f2012);

                                       /* END IF */

                                       body.emit(assign(r2009, body.constant(0u), 0x01));


                                    body.instructions = f200E_parent_instructions;
                                    body.emit(f200E);

                                    /* END IF */

                                    ir_expression *const r201C = nequal(r2005, body.constant(0u));
                                    ir_expression *const r201D = expr(ir_unop_b2i, r201C);
                                    ir_expression *const r201E = expr(ir_unop_i2u, r201D);
                                    body.emit(assign(r2007, bit_or(r2007, r201E), 0x01));


                                 body.instructions = f200C_parent_instructions;
                                 body.emit(f200C);

                                 /* END IF */

                                 body.emit(assign(r1FE1, r2009, 0x01));

                                 body.emit(assign(r1FE2, r2008, 0x01));

                                 body.emit(assign(r1FE3, r2007, 0x01));


                              body.instructions = f1FFB_parent_instructions;
                              body.emit(f1FFB);

                              /* END IF */

                              body.emit(assign(r1FE0, sub(r1FE0, r1FE4), 0x01));

                              ir_variable *const r201F = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r201F, r1FE0, 0x01));

                              ir_variable *const r2020 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2020, r1FE1, 0x01));

                              ir_variable *const r2021 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2021, r1FE2, 0x01));

                              ir_variable *const r2022 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r2022, r1FE3, 0x01));

                              ir_variable *const r2023 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r2023, body.constant(true), 0x01));

                              ir_variable *const r2024 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r2025 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r2025);
                              ir_expression *const r2026 = expr(ir_unop_u2i, r1FE3);
                              body.emit(assign(r2025, less(r2026, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2028 = lequal(body.constant(int(2045)), r1FE0);
                              ir_if *f2027 = new(mem_ctx) ir_if(operand(r2028).val);
                              exec_list *const f2027_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2027->then_instructions;

                                 ir_variable *const r2029 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r202B = less(body.constant(int(2045)), r1FE0);
                                 ir_if *f202A = new(mem_ctx) ir_if(operand(r202B).val);
                                 exec_list *const f202A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f202A->then_instructions;

                                    body.emit(assign(r2029, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f202A->else_instructions;

                                    ir_variable *const r202C = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r202E = equal(r1FE0, body.constant(int(2045)));
                                    ir_if *f202D = new(mem_ctx) ir_if(operand(r202E).val);
                                    exec_list *const f202D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f202D->then_instructions;

                                       ir_expression *const r202F = equal(body.constant(2097151u), r1FE1);
                                       ir_expression *const r2030 = equal(body.constant(4294967295u), r1FE2);
                                       body.emit(assign(r202C, logic_and(r202F, r2030), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f202D->else_instructions;

                                       body.emit(assign(r202C, body.constant(false), 0x01));


                                    body.instructions = f202D_parent_instructions;
                                    body.emit(f202D);

                                    /* END IF */

                                    body.emit(assign(r2029, logic_and(r202C, r2025), 0x01));


                                 body.instructions = f202A_parent_instructions;
                                 body.emit(f202A);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f2031 = new(mem_ctx) ir_if(operand(r2029).val);
                                 exec_list *const f2031_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2031->then_instructions;

                                    ir_variable *const r2032 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r2032);
                                    ir_expression *const r2033 = lshift(r1CAA, body.constant(int(31)));
                                    body.emit(assign(r2032, add(r2033, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r2032, body.constant(0u), 0x01));

                                    body.emit(assign(r2024, r2032, 0x03));

                                    body.emit(assign(r2023, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2031->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2035 = less(r1FE0, body.constant(int(0)));
                                    ir_if *f2034 = new(mem_ctx) ir_if(operand(r2035).val);
                                    exec_list *const f2034_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2034->then_instructions;

                                       ir_variable *const r2036 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r2036, r1FE3, 0x01));

                                       ir_variable *const r2037 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r2037, neg(r1FE0), 0x01));

                                       ir_variable *const r2038 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r2038);
                                       ir_variable *const r2039 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r2039);
                                       ir_variable *const r203A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r203A);
                                       ir_variable *const r203B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r203C = neg(r2037);
                                       body.emit(assign(r203B, bit_and(r203C, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r203E = equal(r2037, body.constant(int(0)));
                                       ir_if *f203D = new(mem_ctx) ir_if(operand(r203E).val);
                                       exec_list *const f203D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f203D->then_instructions;

                                          body.emit(assign(r2038, r1FE3, 0x01));

                                          body.emit(assign(r2039, r1FE2, 0x01));

                                          body.emit(assign(r203A, r1FE1, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f203D->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2040 = less(r2037, body.constant(int(32)));
                                          ir_if *f203F = new(mem_ctx) ir_if(operand(r2040).val);
                                          exec_list *const f203F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f203F->then_instructions;

                                             body.emit(assign(r2038, lshift(r1FE2, r203B), 0x01));

                                             ir_expression *const r2041 = lshift(r1FE1, r203B);
                                             ir_expression *const r2042 = rshift(r1FE2, r2037);
                                             body.emit(assign(r2039, bit_or(r2041, r2042), 0x01));

                                             body.emit(assign(r203A, rshift(r1FE1, r2037), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f203F->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r2044 = equal(r2037, body.constant(int(32)));
                                             ir_if *f2043 = new(mem_ctx) ir_if(operand(r2044).val);
                                             exec_list *const f2043_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2043->then_instructions;

                                                body.emit(assign(r2038, r1FE2, 0x01));

                                                body.emit(assign(r2039, r1FE1, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2043->else_instructions;

                                                body.emit(assign(r2036, bit_or(r1FE3, r1FE2), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r2046 = less(r2037, body.constant(int(64)));
                                                ir_if *f2045 = new(mem_ctx) ir_if(operand(r2046).val);
                                                exec_list *const f2045_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2045->then_instructions;

                                                   body.emit(assign(r2038, lshift(r1FE1, r203B), 0x01));

                                                   ir_expression *const r2047 = bit_and(r2037, body.constant(int(31)));
                                                   body.emit(assign(r2039, rshift(r1FE1, r2047), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2045->else_instructions;

                                                   ir_variable *const r2048 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r204A = equal(r2037, body.constant(int(64)));
                                                   ir_if *f2049 = new(mem_ctx) ir_if(operand(r204A).val);
                                                   exec_list *const f2049_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f2049->then_instructions;

                                                      body.emit(assign(r2048, r1FE1, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f2049->else_instructions;

                                                      ir_expression *const r204B = nequal(r1FE1, body.constant(0u));
                                                      ir_expression *const r204C = expr(ir_unop_b2i, r204B);
                                                      body.emit(assign(r2048, expr(ir_unop_i2u, r204C), 0x01));


                                                   body.instructions = f2049_parent_instructions;
                                                   body.emit(f2049);

                                                   /* END IF */

                                                   body.emit(assign(r2038, r2048, 0x01));

                                                   body.emit(assign(r2039, body.constant(0u), 0x01));


                                                body.instructions = f2045_parent_instructions;
                                                body.emit(f2045);

                                                /* END IF */


                                             body.instructions = f2043_parent_instructions;
                                             body.emit(f2043);

                                             /* END IF */

                                             body.emit(assign(r203A, body.constant(0u), 0x01));


                                          body.instructions = f203F_parent_instructions;
                                          body.emit(f203F);

                                          /* END IF */

                                          ir_expression *const r204D = nequal(r2036, body.constant(0u));
                                          ir_expression *const r204E = expr(ir_unop_b2i, r204D);
                                          ir_expression *const r204F = expr(ir_unop_i2u, r204E);
                                          body.emit(assign(r2038, bit_or(r2038, r204F), 0x01));


                                       body.instructions = f203D_parent_instructions;
                                       body.emit(f203D);

                                       /* END IF */

                                       body.emit(assign(r2020, r203A, 0x01));

                                       body.emit(assign(r2021, r2039, 0x01));

                                       body.emit(assign(r2022, r2038, 0x01));

                                       body.emit(assign(r201F, body.constant(int(0)), 0x01));

                                       body.emit(assign(r2025, less(r2038, body.constant(0u)), 0x01));


                                    body.instructions = f2034_parent_instructions;
                                    body.emit(f2034);

                                    /* END IF */


                                 body.instructions = f2031_parent_instructions;
                                 body.emit(f2031);

                                 /* END IF */


                              body.instructions = f2027_parent_instructions;
                              body.emit(f2027);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2050 = new(mem_ctx) ir_if(operand(r2023).val);
                              exec_list *const f2050_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2050->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f2051 = new(mem_ctx) ir_if(operand(r2025).val);
                                 exec_list *const f2051_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2051->then_instructions;

                                    ir_variable *const r2052 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r2052, add(r2021, body.constant(1u)), 0x01));

                                    ir_expression *const r2053 = less(r2052, r2021);
                                    ir_expression *const r2054 = expr(ir_unop_b2i, r2053);
                                    ir_expression *const r2055 = expr(ir_unop_i2u, r2054);
                                    body.emit(assign(r2020, add(r2020, r2055), 0x01));

                                    ir_expression *const r2056 = equal(r2022, body.constant(0u));
                                    ir_expression *const r2057 = expr(ir_unop_b2i, r2056);
                                    ir_expression *const r2058 = expr(ir_unop_i2u, r2057);
                                    ir_expression *const r2059 = add(r2022, r2058);
                                    ir_expression *const r205A = bit_and(r2059, body.constant(1u));
                                    ir_expression *const r205B = expr(ir_unop_bit_not, r205A);
                                    body.emit(assign(r2021, bit_and(r2052, r205B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2051->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r205D = bit_or(r2020, r2021);
                                    ir_expression *const r205E = equal(r205D, body.constant(0u));
                                    ir_if *f205C = new(mem_ctx) ir_if(operand(r205E).val);
                                    exec_list *const f205C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f205C->then_instructions;

                                       body.emit(assign(r201F, body.constant(int(0)), 0x01));


                                    body.instructions = f205C_parent_instructions;
                                    body.emit(f205C);

                                    /* END IF */


                                 body.instructions = f2051_parent_instructions;
                                 body.emit(f2051);

                                 /* END IF */

                                 ir_variable *const r205F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r205F);
                                 ir_expression *const r2060 = lshift(r1CAA, body.constant(int(31)));
                                 ir_expression *const r2061 = expr(ir_unop_i2u, r201F);
                                 ir_expression *const r2062 = lshift(r2061, body.constant(int(20)));
                                 ir_expression *const r2063 = add(r2060, r2062);
                                 body.emit(assign(r205F, add(r2063, r2020), 0x02));

                                 body.emit(assign(r205F, r2021, 0x01));

                                 body.emit(assign(r2024, r205F, 0x03));

                                 body.emit(assign(r2023, body.constant(false), 0x01));


                              body.instructions = f2050_parent_instructions;
                              body.emit(f2050);

                              /* END IF */

                              body.emit(assign(r1CAB, r2024, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1FD8->else_instructions;

                              ir_variable *const r2064 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2064);
                              body.emit(assign(r2064, body.constant(0u), 0x02));

                              body.emit(assign(r2064, body.constant(0u), 0x01));

                              body.emit(assign(r1CAB, r2064, 0x03));


                           body.instructions = f1FD8_parent_instructions;
                           body.emit(f1FD8);

                           /* END IF */


                        body.instructions = f1F4C_parent_instructions;
                        body.emit(f1F4C);

                        /* END IF */


                     body.instructions = f1EC0_parent_instructions;
                     body.emit(f1EC0);

                     /* END IF */


                  body.instructions = f1E34_parent_instructions;
                  body.emit(f1E34);

                  /* END IF */


               body.instructions = f1E1F_parent_instructions;
               body.emit(f1E1F);

               /* END IF */


            body.instructions = f1D70_parent_instructions;
            body.emit(f1D70);

            /* END IF */


         body.instructions = f1CBF_parent_instructions;
         body.emit(f1CBF);

         /* END IF */

         body.emit(assign(r1CA6, r1CAB, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1CA8->else_instructions;

         ir_variable *const r2065 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r2065, body.constant(true), 0x01));

         ir_variable *const r2066 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2067 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2067);
         ir_variable *const r2068 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r2068);
         ir_variable *const r2069 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r2069);
         ir_variable *const r206A = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r206A);
         ir_variable *const r206B = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r206B);
         ir_variable *const r206C = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r206C);
         ir_variable *const r206D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r206D);
         ir_variable *const r206E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r206E);
         body.emit(assign(r206E, body.constant(0u), 0x01));

         body.emit(assign(r206D, body.constant(0u), 0x01));

         ir_variable *const r206F = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r206F, swizzle_x(r1C71), 0x01));

         body.emit(assign(r206B, r206F, 0x01));

         ir_variable *const r2070 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r2070, bit_and(swizzle_y(r1C71), body.constant(1048575u)), 0x01));

         body.emit(assign(r206A, r2070, 0x01));

         ir_variable *const r2071 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2071, body.constant(0u), 0x01));

         body.emit(assign(r2069, body.constant(0u), 0x01));

         body.emit(assign(r2068, body.constant(0u), 0x01));

         ir_variable *const r2072 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2073 = rshift(swizzle_y(r1C71), body.constant(int(20)));
         ir_expression *const r2074 = bit_and(r2073, body.constant(2047u));
         body.emit(assign(r2072, expr(ir_unop_u2i, r2074), 0x01));

         ir_variable *const r2075 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r2075, body.constant(int(1023)), 0x01));

         ir_variable *const r2076 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2076, add(r2072, body.constant(int(-1023))), 0x01));

         body.emit(assign(r2067, r2076, 0x01));

         /* IF CONDITION */
         ir_expression *const r2078 = less(body.constant(int(0)), r2076);
         ir_if *f2077 = new(mem_ctx) ir_if(operand(r2078).val);
         exec_list *const f2077_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2077->then_instructions;

            /* IF CONDITION */
            ir_expression *const r207A = equal(r2072, body.constant(int(2047)));
            ir_if *f2079 = new(mem_ctx) ir_if(operand(r207A).val);
            exec_list *const f2079_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2079->then_instructions;

               /* IF CONDITION */
               ir_expression *const r207C = bit_or(r2070, swizzle_x(r1C71));
               ir_expression *const r207D = nequal(r207C, body.constant(0u));
               ir_if *f207B = new(mem_ctx) ir_if(operand(r207D).val);
               exec_list *const f207B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f207B->then_instructions;

                  ir_variable *const r207E = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r207E, swizzle_x(r1C71), 0x01));

                  ir_variable *const r207F = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r207F, body.constant(0u), 0x01));

                  ir_variable *const r2080 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r207E, bit_or(swizzle_y(r1C71), body.constant(524288u)), 0x02));

                  body.emit(assign(r207F, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2082 = lshift(swizzle_y(r1C71), body.constant(int(1)));
                  ir_expression *const r2083 = lequal(body.constant(4292870144u), r2082);
                  ir_expression *const r2084 = nequal(swizzle_x(r1C71), body.constant(0u));
                  ir_expression *const r2085 = bit_and(swizzle_y(r1C71), body.constant(1048575u));
                  ir_expression *const r2086 = nequal(r2085, body.constant(0u));
                  ir_expression *const r2087 = logic_or(r2084, r2086);
                  ir_expression *const r2088 = logic_and(r2083, r2087);
                  ir_if *f2081 = new(mem_ctx) ir_if(operand(r2088).val);
                  exec_list *const f2081_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2081->then_instructions;

                     body.emit(assign(r2080, r207E, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2081->else_instructions;

                     body.emit(assign(r2080, r207F, 0x03));


                  body.instructions = f2081_parent_instructions;
                  body.emit(f2081);

                  /* END IF */

                  body.emit(assign(r2066, r2080, 0x03));

                  body.emit(assign(r2065, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f207B->else_instructions;

                  body.emit(assign(r2066, r1C71, 0x03));

                  body.emit(assign(r2065, body.constant(false), 0x01));


               body.instructions = f207B_parent_instructions;
               body.emit(f207B);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2079->else_instructions;

               body.emit(assign(r2068, body.constant(1048576u), 0x01));

               ir_variable *const r2089 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2089, body.constant(0u), 0x01));

               ir_variable *const r208A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r208A);
               ir_variable *const r208B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r208B);
               ir_variable *const r208C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r208C);
               ir_variable *const r208D = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r208E = neg(r2076);
               body.emit(assign(r208D, bit_and(r208E, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2090 = equal(r2076, body.constant(int(0)));
               ir_if *f208F = new(mem_ctx) ir_if(operand(r2090).val);
               exec_list *const f208F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f208F->then_instructions;

                  body.emit(assign(r208A, r2089, 0x01));

                  body.emit(assign(r208B, body.constant(0u), 0x01));

                  body.emit(assign(r208C, r2068, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f208F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2092 = less(r2076, body.constant(int(32)));
                  ir_if *f2091 = new(mem_ctx) ir_if(operand(r2092).val);
                  exec_list *const f2091_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2091->then_instructions;

                     body.emit(assign(r208A, body.constant(0u), 0x01));

                     ir_expression *const r2093 = lshift(body.constant(1048576u), r208D);
                     body.emit(assign(r208B, bit_or(r2093, body.constant(0u)), 0x01));

                     body.emit(assign(r208C, rshift(body.constant(1048576u), r2076), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2091->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2095 = equal(r2076, body.constant(int(32)));
                     ir_if *f2094 = new(mem_ctx) ir_if(operand(r2095).val);
                     exec_list *const f2094_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2094->then_instructions;

                        body.emit(assign(r208A, body.constant(0u), 0x01));

                        body.emit(assign(r208B, r2068, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2094->else_instructions;

                        body.emit(assign(r2089, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2097 = less(r2076, body.constant(int(64)));
                        ir_if *f2096 = new(mem_ctx) ir_if(operand(r2097).val);
                        exec_list *const f2096_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2096->then_instructions;

                           body.emit(assign(r208A, lshift(body.constant(1048576u), r208D), 0x01));

                           ir_expression *const r2098 = bit_and(r2076, body.constant(int(31)));
                           body.emit(assign(r208B, rshift(body.constant(1048576u), r2098), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2096->else_instructions;

                           ir_variable *const r2099 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r209B = equal(r2076, body.constant(int(64)));
                           ir_if *f209A = new(mem_ctx) ir_if(operand(r209B).val);
                           exec_list *const f209A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f209A->then_instructions;

                              body.emit(assign(r2099, r2068, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f209A->else_instructions;

                              body.emit(assign(r2099, body.constant(1u), 0x01));


                           body.instructions = f209A_parent_instructions;
                           body.emit(f209A);

                           /* END IF */

                           body.emit(assign(r208A, r2099, 0x01));

                           body.emit(assign(r208B, body.constant(0u), 0x01));


                        body.instructions = f2096_parent_instructions;
                        body.emit(f2096);

                        /* END IF */


                     body.instructions = f2094_parent_instructions;
                     body.emit(f2094);

                     /* END IF */

                     body.emit(assign(r208C, body.constant(0u), 0x01));


                  body.instructions = f2091_parent_instructions;
                  body.emit(f2091);

                  /* END IF */

                  ir_expression *const r209C = nequal(r2089, body.constant(0u));
                  ir_expression *const r209D = expr(ir_unop_b2i, r209C);
                  ir_expression *const r209E = expr(ir_unop_i2u, r209D);
                  body.emit(assign(r208A, bit_or(r208A, r209E), 0x01));


               body.instructions = f208F_parent_instructions;
               body.emit(f208F);

               /* END IF */

               body.emit(assign(r2068, r208C, 0x01));

               body.emit(assign(r2069, r208B, 0x01));

               body.emit(assign(r206D, r208A, 0x01));

               body.emit(assign(r206C, r2072, 0x01));


            body.instructions = f2079_parent_instructions;
            body.emit(f2079);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2077->else_instructions;

            /* IF CONDITION */
            ir_expression *const r20A0 = less(r2076, body.constant(int(0)));
            ir_if *f209F = new(mem_ctx) ir_if(operand(r20A0).val);
            exec_list *const f209F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f209F->then_instructions;

               /* IF CONDITION */
               ir_expression *const r20A2 = equal(r2072, body.constant(int(0)));
               ir_if *f20A1 = new(mem_ctx) ir_if(operand(r20A2).val);
               exec_list *const f20A1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f20A1->then_instructions;

                  body.emit(assign(r2067, add(r2076, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f20A1->else_instructions;

                  body.emit(assign(r206A, bit_or(r2070, body.constant(1048576u)), 0x01));


               body.instructions = f20A1_parent_instructions;
               body.emit(f20A1);

               /* END IF */

               ir_variable *const r20A3 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r20A3, body.constant(0u), 0x01));

               ir_variable *const r20A4 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r20A4, neg(r2067), 0x01));

               ir_variable *const r20A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r20A5);
               ir_variable *const r20A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r20A6);
               ir_variable *const r20A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r20A7);
               ir_variable *const r20A8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r20A9 = neg(r20A4);
               body.emit(assign(r20A8, bit_and(r20A9, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r20AB = equal(r20A4, body.constant(int(0)));
               ir_if *f20AA = new(mem_ctx) ir_if(operand(r20AB).val);
               exec_list *const f20AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f20AA->then_instructions;

                  body.emit(assign(r20A5, r20A3, 0x01));

                  body.emit(assign(r20A6, r206F, 0x01));

                  body.emit(assign(r20A7, r206A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f20AA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r20AD = less(r20A4, body.constant(int(32)));
                  ir_if *f20AC = new(mem_ctx) ir_if(operand(r20AD).val);
                  exec_list *const f20AC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20AC->then_instructions;

                     body.emit(assign(r20A5, lshift(swizzle_x(r1C71), r20A8), 0x01));

                     ir_expression *const r20AE = lshift(r206A, r20A8);
                     ir_expression *const r20AF = rshift(swizzle_x(r1C71), r20A4);
                     body.emit(assign(r20A6, bit_or(r20AE, r20AF), 0x01));

                     body.emit(assign(r20A7, rshift(r206A, r20A4), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20AC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r20B1 = equal(r20A4, body.constant(int(32)));
                     ir_if *f20B0 = new(mem_ctx) ir_if(operand(r20B1).val);
                     exec_list *const f20B0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f20B0->then_instructions;

                        body.emit(assign(r20A5, r206F, 0x01));

                        body.emit(assign(r20A6, r206A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f20B0->else_instructions;

                        body.emit(assign(r20A3, bit_or(body.constant(0u), swizzle_x(r1C71)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r20B3 = less(r20A4, body.constant(int(64)));
                        ir_if *f20B2 = new(mem_ctx) ir_if(operand(r20B3).val);
                        exec_list *const f20B2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20B2->then_instructions;

                           body.emit(assign(r20A5, lshift(r206A, r20A8), 0x01));

                           ir_expression *const r20B4 = bit_and(r20A4, body.constant(int(31)));
                           body.emit(assign(r20A6, rshift(r206A, r20B4), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f20B2->else_instructions;

                           ir_variable *const r20B5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r20B7 = equal(r20A4, body.constant(int(64)));
                           ir_if *f20B6 = new(mem_ctx) ir_if(operand(r20B7).val);
                           exec_list *const f20B6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20B6->then_instructions;

                              body.emit(assign(r20B5, r206A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20B6->else_instructions;

                              ir_expression *const r20B8 = nequal(r206A, body.constant(0u));
                              ir_expression *const r20B9 = expr(ir_unop_b2i, r20B8);
                              body.emit(assign(r20B5, expr(ir_unop_i2u, r20B9), 0x01));


                           body.instructions = f20B6_parent_instructions;
                           body.emit(f20B6);

                           /* END IF */

                           body.emit(assign(r20A5, r20B5, 0x01));

                           body.emit(assign(r20A6, body.constant(0u), 0x01));


                        body.instructions = f20B2_parent_instructions;
                        body.emit(f20B2);

                        /* END IF */


                     body.instructions = f20B0_parent_instructions;
                     body.emit(f20B0);

                     /* END IF */

                     body.emit(assign(r20A7, body.constant(0u), 0x01));


                  body.instructions = f20AC_parent_instructions;
                  body.emit(f20AC);

                  /* END IF */

                  ir_expression *const r20BA = nequal(r20A3, body.constant(0u));
                  ir_expression *const r20BB = expr(ir_unop_b2i, r20BA);
                  ir_expression *const r20BC = expr(ir_unop_i2u, r20BB);
                  body.emit(assign(r20A5, bit_or(r20A5, r20BC), 0x01));


               body.instructions = f20AA_parent_instructions;
               body.emit(f20AA);

               /* END IF */

               body.emit(assign(r206A, r20A7, 0x01));

               body.emit(assign(r206B, r20A6, 0x01));

               body.emit(assign(r206D, r20A5, 0x01));

               body.emit(assign(r206C, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f209F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r20BE = equal(r2072, body.constant(int(2047)));
               ir_if *f20BD = new(mem_ctx) ir_if(operand(r20BE).val);
               exec_list *const f20BD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f20BD->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r20C0 = bit_or(r206A, r206B);
                  ir_expression *const r20C1 = bit_or(r2068, r2069);
                  ir_expression *const r20C2 = bit_or(r20C0, r20C1);
                  ir_expression *const r20C3 = nequal(r20C2, body.constant(0u));
                  ir_if *f20BF = new(mem_ctx) ir_if(operand(r20C3).val);
                  exec_list *const f20BF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20BF->then_instructions;

                     ir_variable *const r20C4 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r20C4, swizzle_x(r1C71), 0x01));

                     ir_variable *const r20C5 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r20C5, body.constant(0u), 0x01));

                     ir_variable *const r20C6 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r20C4, bit_or(swizzle_y(r1C71), body.constant(524288u)), 0x02));

                     body.emit(assign(r20C5, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r20C8 = lshift(swizzle_y(r1C71), body.constant(int(1)));
                     ir_expression *const r20C9 = lequal(body.constant(4292870144u), r20C8);
                     ir_expression *const r20CA = nequal(swizzle_x(r1C71), body.constant(0u));
                     ir_expression *const r20CB = bit_and(swizzle_y(r1C71), body.constant(1048575u));
                     ir_expression *const r20CC = nequal(r20CB, body.constant(0u));
                     ir_expression *const r20CD = logic_or(r20CA, r20CC);
                     ir_expression *const r20CE = logic_and(r20C9, r20CD);
                     ir_if *f20C7 = new(mem_ctx) ir_if(operand(r20CE).val);
                     exec_list *const f20C7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f20C7->then_instructions;

                        body.emit(assign(r20C6, r20C4, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f20C7->else_instructions;

                        body.emit(assign(r20C6, r20C5, 0x03));


                     body.instructions = f20C7_parent_instructions;
                     body.emit(f20C7);

                     /* END IF */

                     body.emit(assign(r2066, r20C6, 0x03));

                     body.emit(assign(r2065, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20BF->else_instructions;

                     body.emit(assign(r2066, r1C71, 0x03));

                     body.emit(assign(r2065, body.constant(false), 0x01));


                  body.instructions = f20BF_parent_instructions;
                  body.emit(f20BF);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f20BD->else_instructions;

                  ir_variable *const r20CF = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r20D0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r20D0, add(r206B, r2069), 0x01));

                  ir_expression *const r20D1 = add(r206A, r2068);
                  ir_expression *const r20D2 = less(r20D0, r206B);
                  ir_expression *const r20D3 = expr(ir_unop_b2i, r20D2);
                  ir_expression *const r20D4 = expr(ir_unop_i2u, r20D3);
                  body.emit(assign(r20CF, add(r20D1, r20D4), 0x01));

                  body.emit(assign(r206E, r20CF, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r20D6 = equal(r2072, body.constant(int(0)));
                  ir_if *f20D5 = new(mem_ctx) ir_if(operand(r20D6).val);
                  exec_list *const f20D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20D5->then_instructions;

                     ir_variable *const r20D7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r20D7);
                     ir_expression *const r20D8 = lshift(r1CA7, body.constant(int(31)));
                     body.emit(assign(r20D7, add(r20D8, r20CF), 0x02));

                     body.emit(assign(r20D7, r20D0, 0x01));

                     body.emit(assign(r2066, r20D7, 0x03));

                     body.emit(assign(r2065, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20D5->else_instructions;

                     body.emit(assign(r206E, bit_or(r20CF, body.constant(2097152u)), 0x01));

                     body.emit(assign(r206C, r2072, 0x01));

                     ir_variable *const r20D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r20D9);
                     ir_variable *const r20DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r20DA);
                     ir_variable *const r20DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r20DB);
                     body.emit(assign(r20D9, lshift(r20D0, body.constant(int(31))), 0x01));

                     ir_expression *const r20DC = lshift(r206E, body.constant(int(31)));
                     ir_expression *const r20DD = rshift(r20D0, body.constant(int(1)));
                     body.emit(assign(r20DA, bit_or(r20DC, r20DD), 0x01));

                     body.emit(assign(r20DB, rshift(r206E, body.constant(int(1))), 0x01));

                     body.emit(assign(r20D9, bit_or(r20D9, body.constant(0u)), 0x01));

                     body.emit(assign(r206E, r20DB, 0x01));

                     body.emit(assign(r206D, r20D9, 0x01));

                     ir_variable *const r20DE = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r20DE, r2072, 0x01));

                     ir_variable *const r20DF = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r20DF, r20DB, 0x01));

                     ir_variable *const r20E0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r20E0, r20DA, 0x01));

                     ir_variable *const r20E1 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r20E1, r20D9, 0x01));

                     ir_variable *const r20E2 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r20E2, body.constant(true), 0x01));

                     ir_variable *const r20E3 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r20E4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r20E4);
                     ir_expression *const r20E5 = expr(ir_unop_u2i, r20D9);
                     body.emit(assign(r20E4, less(r20E5, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r20E7 = lequal(body.constant(int(2045)), r2072);
                     ir_if *f20E6 = new(mem_ctx) ir_if(operand(r20E7).val);
                     exec_list *const f20E6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f20E6->then_instructions;

                        ir_variable *const r20E8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r20EA = less(body.constant(int(2045)), r2072);
                        ir_if *f20E9 = new(mem_ctx) ir_if(operand(r20EA).val);
                        exec_list *const f20E9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20E9->then_instructions;

                           body.emit(assign(r20E8, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f20E9->else_instructions;

                           ir_variable *const r20EB = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r20ED = equal(r2072, body.constant(int(2045)));
                           ir_if *f20EC = new(mem_ctx) ir_if(operand(r20ED).val);
                           exec_list *const f20EC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20EC->then_instructions;

                              ir_expression *const r20EE = equal(body.constant(2097151u), r20DB);
                              ir_expression *const r20EF = equal(body.constant(4294967295u), r20DA);
                              body.emit(assign(r20EB, logic_and(r20EE, r20EF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20EC->else_instructions;

                              body.emit(assign(r20EB, body.constant(false), 0x01));


                           body.instructions = f20EC_parent_instructions;
                           body.emit(f20EC);

                           /* END IF */

                           body.emit(assign(r20E8, logic_and(r20EB, r20E4), 0x01));


                        body.instructions = f20E9_parent_instructions;
                        body.emit(f20E9);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f20F0 = new(mem_ctx) ir_if(operand(r20E8).val);
                        exec_list *const f20F0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20F0->then_instructions;

                           ir_variable *const r20F1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r20F1);
                           ir_expression *const r20F2 = lshift(r1CA7, body.constant(int(31)));
                           body.emit(assign(r20F1, add(r20F2, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r20F1, body.constant(0u), 0x01));

                           body.emit(assign(r20E3, r20F1, 0x03));

                           body.emit(assign(r20E2, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f20F0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r20F4 = less(r2072, body.constant(int(0)));
                           ir_if *f20F3 = new(mem_ctx) ir_if(operand(r20F4).val);
                           exec_list *const f20F3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20F3->then_instructions;

                              ir_variable *const r20F5 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r20F5, r20D9, 0x01));

                              ir_variable *const r20F6 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r20F6, neg(r2072), 0x01));

                              ir_variable *const r20F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r20F7);
                              ir_variable *const r20F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r20F8);
                              ir_variable *const r20F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r20F9);
                              ir_variable *const r20FA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r20FB = neg(r20F6);
                              body.emit(assign(r20FA, bit_and(r20FB, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r20FD = equal(r20F6, body.constant(int(0)));
                              ir_if *f20FC = new(mem_ctx) ir_if(operand(r20FD).val);
                              exec_list *const f20FC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20FC->then_instructions;

                                 body.emit(assign(r20F7, r20D9, 0x01));

                                 body.emit(assign(r20F8, r20DA, 0x01));

                                 body.emit(assign(r20F9, r20DB, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f20FC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r20FF = less(r20F6, body.constant(int(32)));
                                 ir_if *f20FE = new(mem_ctx) ir_if(operand(r20FF).val);
                                 exec_list *const f20FE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f20FE->then_instructions;

                                    body.emit(assign(r20F7, lshift(r20DA, r20FA), 0x01));

                                    ir_expression *const r2100 = lshift(r20DB, r20FA);
                                    ir_expression *const r2101 = rshift(r20DA, r20F6);
                                    body.emit(assign(r20F8, bit_or(r2100, r2101), 0x01));

                                    body.emit(assign(r20F9, rshift(r20DB, r20F6), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f20FE->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2103 = equal(r20F6, body.constant(int(32)));
                                    ir_if *f2102 = new(mem_ctx) ir_if(operand(r2103).val);
                                    exec_list *const f2102_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2102->then_instructions;

                                       body.emit(assign(r20F7, r20DA, 0x01));

                                       body.emit(assign(r20F8, r20DB, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2102->else_instructions;

                                       body.emit(assign(r20F5, bit_or(r20D9, r20DA), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2105 = less(r20F6, body.constant(int(64)));
                                       ir_if *f2104 = new(mem_ctx) ir_if(operand(r2105).val);
                                       exec_list *const f2104_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2104->then_instructions;

                                          body.emit(assign(r20F7, lshift(r20DB, r20FA), 0x01));

                                          ir_expression *const r2106 = bit_and(r20F6, body.constant(int(31)));
                                          body.emit(assign(r20F8, rshift(r20DB, r2106), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2104->else_instructions;

                                          ir_variable *const r2107 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2109 = equal(r20F6, body.constant(int(64)));
                                          ir_if *f2108 = new(mem_ctx) ir_if(operand(r2109).val);
                                          exec_list *const f2108_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2108->then_instructions;

                                             body.emit(assign(r2107, r20DB, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2108->else_instructions;

                                             ir_expression *const r210A = nequal(r20DB, body.constant(0u));
                                             ir_expression *const r210B = expr(ir_unop_b2i, r210A);
                                             body.emit(assign(r2107, expr(ir_unop_i2u, r210B), 0x01));


                                          body.instructions = f2108_parent_instructions;
                                          body.emit(f2108);

                                          /* END IF */

                                          body.emit(assign(r20F7, r2107, 0x01));

                                          body.emit(assign(r20F8, body.constant(0u), 0x01));


                                       body.instructions = f2104_parent_instructions;
                                       body.emit(f2104);

                                       /* END IF */


                                    body.instructions = f2102_parent_instructions;
                                    body.emit(f2102);

                                    /* END IF */

                                    body.emit(assign(r20F9, body.constant(0u), 0x01));


                                 body.instructions = f20FE_parent_instructions;
                                 body.emit(f20FE);

                                 /* END IF */

                                 ir_expression *const r210C = nequal(r20F5, body.constant(0u));
                                 ir_expression *const r210D = expr(ir_unop_b2i, r210C);
                                 ir_expression *const r210E = expr(ir_unop_i2u, r210D);
                                 body.emit(assign(r20F7, bit_or(r20F7, r210E), 0x01));


                              body.instructions = f20FC_parent_instructions;
                              body.emit(f20FC);

                              /* END IF */

                              body.emit(assign(r20DF, r20F9, 0x01));

                              body.emit(assign(r20E0, r20F8, 0x01));

                              body.emit(assign(r20E1, r20F7, 0x01));

                              body.emit(assign(r20DE, body.constant(int(0)), 0x01));

                              body.emit(assign(r20E4, less(r20F7, body.constant(0u)), 0x01));


                           body.instructions = f20F3_parent_instructions;
                           body.emit(f20F3);

                           /* END IF */


                        body.instructions = f20F0_parent_instructions;
                        body.emit(f20F0);

                        /* END IF */


                     body.instructions = f20E6_parent_instructions;
                     body.emit(f20E6);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f210F = new(mem_ctx) ir_if(operand(r20E2).val);
                     exec_list *const f210F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f210F->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2110 = new(mem_ctx) ir_if(operand(r20E4).val);
                        exec_list *const f2110_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2110->then_instructions;

                           ir_variable *const r2111 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2111, add(r20E0, body.constant(1u)), 0x01));

                           ir_expression *const r2112 = less(r2111, r20E0);
                           ir_expression *const r2113 = expr(ir_unop_b2i, r2112);
                           ir_expression *const r2114 = expr(ir_unop_i2u, r2113);
                           body.emit(assign(r20DF, add(r20DF, r2114), 0x01));

                           ir_expression *const r2115 = equal(r20E1, body.constant(0u));
                           ir_expression *const r2116 = expr(ir_unop_b2i, r2115);
                           ir_expression *const r2117 = expr(ir_unop_i2u, r2116);
                           ir_expression *const r2118 = add(r20E1, r2117);
                           ir_expression *const r2119 = bit_and(r2118, body.constant(1u));
                           ir_expression *const r211A = expr(ir_unop_bit_not, r2119);
                           body.emit(assign(r20E0, bit_and(r2111, r211A), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2110->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r211C = bit_or(r20DF, r20E0);
                           ir_expression *const r211D = equal(r211C, body.constant(0u));
                           ir_if *f211B = new(mem_ctx) ir_if(operand(r211D).val);
                           exec_list *const f211B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f211B->then_instructions;

                              body.emit(assign(r20DE, body.constant(int(0)), 0x01));


                           body.instructions = f211B_parent_instructions;
                           body.emit(f211B);

                           /* END IF */


                        body.instructions = f2110_parent_instructions;
                        body.emit(f2110);

                        /* END IF */

                        ir_variable *const r211E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r211E);
                        ir_expression *const r211F = lshift(r1CA7, body.constant(int(31)));
                        ir_expression *const r2120 = expr(ir_unop_i2u, r20DE);
                        ir_expression *const r2121 = lshift(r2120, body.constant(int(20)));
                        ir_expression *const r2122 = add(r211F, r2121);
                        body.emit(assign(r211E, add(r2122, r20DF), 0x02));

                        body.emit(assign(r211E, r20E0, 0x01));

                        body.emit(assign(r20E3, r211E, 0x03));

                        body.emit(assign(r20E2, body.constant(false), 0x01));


                     body.instructions = f210F_parent_instructions;
                     body.emit(f210F);

                     /* END IF */

                     body.emit(assign(r2066, r20E3, 0x03));

                     body.emit(assign(r2065, body.constant(false), 0x01));


                  body.instructions = f20D5_parent_instructions;
                  body.emit(f20D5);

                  /* END IF */


               body.instructions = f20BD_parent_instructions;
               body.emit(f20BD);

               /* END IF */


            body.instructions = f209F_parent_instructions;
            body.emit(f209F);

            /* END IF */


         body.instructions = f2077_parent_instructions;
         body.emit(f2077);

         /* END IF */

         /* IF CONDITION */
         ir_if *f2123 = new(mem_ctx) ir_if(operand(r2065).val);
         exec_list *const f2123_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2123->then_instructions;

            body.emit(assign(r206A, bit_or(r206A, body.constant(1048576u)), 0x01));

            ir_variable *const r2124 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2125 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r2125, add(r206B, r2069), 0x01));

            ir_expression *const r2126 = add(r206A, r2068);
            ir_expression *const r2127 = less(r2125, r206B);
            ir_expression *const r2128 = expr(ir_unop_b2i, r2127);
            ir_expression *const r2129 = expr(ir_unop_i2u, r2128);
            body.emit(assign(r2124, add(r2126, r2129), 0x01));

            body.emit(assign(r206E, r2124, 0x01));

            body.emit(assign(r206C, add(r206C, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r212B = less(r2124, body.constant(2097152u));
            ir_if *f212A = new(mem_ctx) ir_if(operand(r212B).val);
            exec_list *const f212A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f212A->then_instructions;

               ir_variable *const r212C = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r212C, r206C, 0x01));

               ir_variable *const r212D = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r212D, r2124, 0x01));

               ir_variable *const r212E = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r212E, r2125, 0x01));

               ir_variable *const r212F = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r212F, r206D, 0x01));

               ir_variable *const r2130 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2130, body.constant(true), 0x01));

               ir_variable *const r2131 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2132 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2132);
               ir_expression *const r2133 = expr(ir_unop_u2i, r206D);
               body.emit(assign(r2132, less(r2133, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2135 = lequal(body.constant(int(2045)), r206C);
               ir_if *f2134 = new(mem_ctx) ir_if(operand(r2135).val);
               exec_list *const f2134_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2134->then_instructions;

                  ir_variable *const r2136 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2138 = less(body.constant(int(2045)), r206C);
                  ir_if *f2137 = new(mem_ctx) ir_if(operand(r2138).val);
                  exec_list *const f2137_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2137->then_instructions;

                     body.emit(assign(r2136, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2137->else_instructions;

                     ir_variable *const r2139 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r213B = equal(r206C, body.constant(int(2045)));
                     ir_if *f213A = new(mem_ctx) ir_if(operand(r213B).val);
                     exec_list *const f213A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f213A->then_instructions;

                        ir_expression *const r213C = equal(body.constant(2097151u), r2124);
                        ir_expression *const r213D = equal(body.constant(4294967295u), r2125);
                        body.emit(assign(r2139, logic_and(r213C, r213D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f213A->else_instructions;

                        body.emit(assign(r2139, body.constant(false), 0x01));


                     body.instructions = f213A_parent_instructions;
                     body.emit(f213A);

                     /* END IF */

                     body.emit(assign(r2136, logic_and(r2139, r2132), 0x01));


                  body.instructions = f2137_parent_instructions;
                  body.emit(f2137);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f213E = new(mem_ctx) ir_if(operand(r2136).val);
                  exec_list *const f213E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f213E->then_instructions;

                     ir_variable *const r213F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r213F);
                     ir_expression *const r2140 = lshift(r1CA7, body.constant(int(31)));
                     body.emit(assign(r213F, add(r2140, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r213F, body.constant(0u), 0x01));

                     body.emit(assign(r2131, r213F, 0x03));

                     body.emit(assign(r2130, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f213E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2142 = less(r206C, body.constant(int(0)));
                     ir_if *f2141 = new(mem_ctx) ir_if(operand(r2142).val);
                     exec_list *const f2141_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2141->then_instructions;

                        ir_variable *const r2143 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2143, r206D, 0x01));

                        ir_variable *const r2144 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2144, neg(r206C), 0x01));

                        ir_variable *const r2145 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2145);
                        ir_variable *const r2146 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2146);
                        ir_variable *const r2147 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2147);
                        ir_variable *const r2148 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2149 = neg(r2144);
                        body.emit(assign(r2148, bit_and(r2149, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r214B = equal(r2144, body.constant(int(0)));
                        ir_if *f214A = new(mem_ctx) ir_if(operand(r214B).val);
                        exec_list *const f214A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f214A->then_instructions;

                           body.emit(assign(r2145, r206D, 0x01));

                           body.emit(assign(r2146, r2125, 0x01));

                           body.emit(assign(r2147, r2124, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f214A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r214D = less(r2144, body.constant(int(32)));
                           ir_if *f214C = new(mem_ctx) ir_if(operand(r214D).val);
                           exec_list *const f214C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f214C->then_instructions;

                              body.emit(assign(r2145, lshift(r2125, r2148), 0x01));

                              ir_expression *const r214E = lshift(r2124, r2148);
                              ir_expression *const r214F = rshift(r2125, r2144);
                              body.emit(assign(r2146, bit_or(r214E, r214F), 0x01));

                              body.emit(assign(r2147, rshift(r2124, r2144), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f214C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2151 = equal(r2144, body.constant(int(32)));
                              ir_if *f2150 = new(mem_ctx) ir_if(operand(r2151).val);
                              exec_list *const f2150_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2150->then_instructions;

                                 body.emit(assign(r2145, r2125, 0x01));

                                 body.emit(assign(r2146, r2124, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2150->else_instructions;

                                 body.emit(assign(r2143, bit_or(r206D, r2125), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2153 = less(r2144, body.constant(int(64)));
                                 ir_if *f2152 = new(mem_ctx) ir_if(operand(r2153).val);
                                 exec_list *const f2152_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2152->then_instructions;

                                    body.emit(assign(r2145, lshift(r2124, r2148), 0x01));

                                    ir_expression *const r2154 = bit_and(r2144, body.constant(int(31)));
                                    body.emit(assign(r2146, rshift(r2124, r2154), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2152->else_instructions;

                                    ir_variable *const r2155 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2157 = equal(r2144, body.constant(int(64)));
                                    ir_if *f2156 = new(mem_ctx) ir_if(operand(r2157).val);
                                    exec_list *const f2156_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2156->then_instructions;

                                       body.emit(assign(r2155, r2124, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2156->else_instructions;

                                       ir_expression *const r2158 = nequal(r2124, body.constant(0u));
                                       ir_expression *const r2159 = expr(ir_unop_b2i, r2158);
                                       body.emit(assign(r2155, expr(ir_unop_i2u, r2159), 0x01));


                                    body.instructions = f2156_parent_instructions;
                                    body.emit(f2156);

                                    /* END IF */

                                    body.emit(assign(r2145, r2155, 0x01));

                                    body.emit(assign(r2146, body.constant(0u), 0x01));


                                 body.instructions = f2152_parent_instructions;
                                 body.emit(f2152);

                                 /* END IF */


                              body.instructions = f2150_parent_instructions;
                              body.emit(f2150);

                              /* END IF */

                              body.emit(assign(r2147, body.constant(0u), 0x01));


                           body.instructions = f214C_parent_instructions;
                           body.emit(f214C);

                           /* END IF */

                           ir_expression *const r215A = nequal(r2143, body.constant(0u));
                           ir_expression *const r215B = expr(ir_unop_b2i, r215A);
                           ir_expression *const r215C = expr(ir_unop_i2u, r215B);
                           body.emit(assign(r2145, bit_or(r2145, r215C), 0x01));


                        body.instructions = f214A_parent_instructions;
                        body.emit(f214A);

                        /* END IF */

                        body.emit(assign(r212D, r2147, 0x01));

                        body.emit(assign(r212E, r2146, 0x01));

                        body.emit(assign(r212F, r2145, 0x01));

                        body.emit(assign(r212C, body.constant(int(0)), 0x01));

                        body.emit(assign(r2132, less(r2145, body.constant(0u)), 0x01));


                     body.instructions = f2141_parent_instructions;
                     body.emit(f2141);

                     /* END IF */


                  body.instructions = f213E_parent_instructions;
                  body.emit(f213E);

                  /* END IF */


               body.instructions = f2134_parent_instructions;
               body.emit(f2134);

               /* END IF */

               /* IF CONDITION */
               ir_if *f215D = new(mem_ctx) ir_if(operand(r2130).val);
               exec_list *const f215D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f215D->then_instructions;

                  /* IF CONDITION */
                  ir_if *f215E = new(mem_ctx) ir_if(operand(r2132).val);
                  exec_list *const f215E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f215E->then_instructions;

                     ir_variable *const r215F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r215F, add(r212E, body.constant(1u)), 0x01));

                     ir_expression *const r2160 = less(r215F, r212E);
                     ir_expression *const r2161 = expr(ir_unop_b2i, r2160);
                     ir_expression *const r2162 = expr(ir_unop_i2u, r2161);
                     body.emit(assign(r212D, add(r212D, r2162), 0x01));

                     ir_expression *const r2163 = equal(r212F, body.constant(0u));
                     ir_expression *const r2164 = expr(ir_unop_b2i, r2163);
                     ir_expression *const r2165 = expr(ir_unop_i2u, r2164);
                     ir_expression *const r2166 = add(r212F, r2165);
                     ir_expression *const r2167 = bit_and(r2166, body.constant(1u));
                     ir_expression *const r2168 = expr(ir_unop_bit_not, r2167);
                     body.emit(assign(r212E, bit_and(r215F, r2168), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f215E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r216A = bit_or(r212D, r212E);
                     ir_expression *const r216B = equal(r216A, body.constant(0u));
                     ir_if *f2169 = new(mem_ctx) ir_if(operand(r216B).val);
                     exec_list *const f2169_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2169->then_instructions;

                        body.emit(assign(r212C, body.constant(int(0)), 0x01));


                     body.instructions = f2169_parent_instructions;
                     body.emit(f2169);

                     /* END IF */


                  body.instructions = f215E_parent_instructions;
                  body.emit(f215E);

                  /* END IF */

                  ir_variable *const r216C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r216C);
                  ir_expression *const r216D = lshift(r1CA7, body.constant(int(31)));
                  ir_expression *const r216E = expr(ir_unop_i2u, r212C);
                  ir_expression *const r216F = lshift(r216E, body.constant(int(20)));
                  ir_expression *const r2170 = add(r216D, r216F);
                  body.emit(assign(r216C, add(r2170, r212D), 0x02));

                  body.emit(assign(r216C, r212E, 0x01));

                  body.emit(assign(r2131, r216C, 0x03));

                  body.emit(assign(r2130, body.constant(false), 0x01));


               body.instructions = f215D_parent_instructions;
               body.emit(f215D);

               /* END IF */

               body.emit(assign(r2066, r2131, 0x03));

               body.emit(assign(r2065, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f212A->else_instructions;

               body.emit(assign(r206C, add(r206C, body.constant(int(1))), 0x01));

               ir_variable *const r2171 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2171);
               ir_variable *const r2172 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2172);
               ir_variable *const r2173 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2173);
               body.emit(assign(r2171, lshift(r2125, body.constant(int(31))), 0x01));

               ir_expression *const r2174 = lshift(r2124, body.constant(int(31)));
               ir_expression *const r2175 = rshift(r2125, body.constant(int(1)));
               body.emit(assign(r2172, bit_or(r2174, r2175), 0x01));

               body.emit(assign(r2173, rshift(r2124, body.constant(int(1))), 0x01));

               ir_expression *const r2176 = nequal(r206D, body.constant(0u));
               ir_expression *const r2177 = expr(ir_unop_b2i, r2176);
               ir_expression *const r2178 = expr(ir_unop_i2u, r2177);
               body.emit(assign(r2171, bit_or(r2171, r2178), 0x01));

               body.emit(assign(r206E, r2173, 0x01));

               body.emit(assign(r206D, r2171, 0x01));

               ir_variable *const r2179 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2179, r206C, 0x01));

               ir_variable *const r217A = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r217A, r2173, 0x01));

               ir_variable *const r217B = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r217B, r2172, 0x01));

               ir_variable *const r217C = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r217C, r2171, 0x01));

               ir_variable *const r217D = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r217D, body.constant(true), 0x01));

               ir_variable *const r217E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r217F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r217F);
               ir_expression *const r2180 = expr(ir_unop_u2i, r2171);
               body.emit(assign(r217F, less(r2180, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2182 = lequal(body.constant(int(2045)), r206C);
               ir_if *f2181 = new(mem_ctx) ir_if(operand(r2182).val);
               exec_list *const f2181_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2181->then_instructions;

                  ir_variable *const r2183 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2185 = less(body.constant(int(2045)), r206C);
                  ir_if *f2184 = new(mem_ctx) ir_if(operand(r2185).val);
                  exec_list *const f2184_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2184->then_instructions;

                     body.emit(assign(r2183, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2184->else_instructions;

                     ir_variable *const r2186 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2188 = equal(r206C, body.constant(int(2045)));
                     ir_if *f2187 = new(mem_ctx) ir_if(operand(r2188).val);
                     exec_list *const f2187_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2187->then_instructions;

                        ir_expression *const r2189 = equal(body.constant(2097151u), r2173);
                        ir_expression *const r218A = equal(body.constant(4294967295u), r2172);
                        body.emit(assign(r2186, logic_and(r2189, r218A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2187->else_instructions;

                        body.emit(assign(r2186, body.constant(false), 0x01));


                     body.instructions = f2187_parent_instructions;
                     body.emit(f2187);

                     /* END IF */

                     body.emit(assign(r2183, logic_and(r2186, r217F), 0x01));


                  body.instructions = f2184_parent_instructions;
                  body.emit(f2184);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f218B = new(mem_ctx) ir_if(operand(r2183).val);
                  exec_list *const f218B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f218B->then_instructions;

                     ir_variable *const r218C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r218C);
                     ir_expression *const r218D = lshift(r1CA7, body.constant(int(31)));
                     body.emit(assign(r218C, add(r218D, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r218C, body.constant(0u), 0x01));

                     body.emit(assign(r217E, r218C, 0x03));

                     body.emit(assign(r217D, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f218B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r218F = less(r206C, body.constant(int(0)));
                     ir_if *f218E = new(mem_ctx) ir_if(operand(r218F).val);
                     exec_list *const f218E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f218E->then_instructions;

                        ir_variable *const r2190 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2190, r2171, 0x01));

                        ir_variable *const r2191 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2191, neg(r206C), 0x01));

                        ir_variable *const r2192 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2192);
                        ir_variable *const r2193 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2193);
                        ir_variable *const r2194 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2194);
                        ir_variable *const r2195 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2196 = neg(r2191);
                        body.emit(assign(r2195, bit_and(r2196, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2198 = equal(r2191, body.constant(int(0)));
                        ir_if *f2197 = new(mem_ctx) ir_if(operand(r2198).val);
                        exec_list *const f2197_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2197->then_instructions;

                           body.emit(assign(r2192, r2171, 0x01));

                           body.emit(assign(r2193, r2172, 0x01));

                           body.emit(assign(r2194, r2173, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2197->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r219A = less(r2191, body.constant(int(32)));
                           ir_if *f2199 = new(mem_ctx) ir_if(operand(r219A).val);
                           exec_list *const f2199_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2199->then_instructions;

                              body.emit(assign(r2192, lshift(r2172, r2195), 0x01));

                              ir_expression *const r219B = lshift(r2173, r2195);
                              ir_expression *const r219C = rshift(r2172, r2191);
                              body.emit(assign(r2193, bit_or(r219B, r219C), 0x01));

                              body.emit(assign(r2194, rshift(r2173, r2191), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2199->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r219E = equal(r2191, body.constant(int(32)));
                              ir_if *f219D = new(mem_ctx) ir_if(operand(r219E).val);
                              exec_list *const f219D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f219D->then_instructions;

                                 body.emit(assign(r2192, r2172, 0x01));

                                 body.emit(assign(r2193, r2173, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f219D->else_instructions;

                                 body.emit(assign(r2190, bit_or(r2171, r2172), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r21A0 = less(r2191, body.constant(int(64)));
                                 ir_if *f219F = new(mem_ctx) ir_if(operand(r21A0).val);
                                 exec_list *const f219F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f219F->then_instructions;

                                    body.emit(assign(r2192, lshift(r2173, r2195), 0x01));

                                    ir_expression *const r21A1 = bit_and(r2191, body.constant(int(31)));
                                    body.emit(assign(r2193, rshift(r2173, r21A1), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f219F->else_instructions;

                                    ir_variable *const r21A2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r21A4 = equal(r2191, body.constant(int(64)));
                                    ir_if *f21A3 = new(mem_ctx) ir_if(operand(r21A4).val);
                                    exec_list *const f21A3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f21A3->then_instructions;

                                       body.emit(assign(r21A2, r2173, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f21A3->else_instructions;

                                       ir_expression *const r21A5 = nequal(r2173, body.constant(0u));
                                       ir_expression *const r21A6 = expr(ir_unop_b2i, r21A5);
                                       body.emit(assign(r21A2, expr(ir_unop_i2u, r21A6), 0x01));


                                    body.instructions = f21A3_parent_instructions;
                                    body.emit(f21A3);

                                    /* END IF */

                                    body.emit(assign(r2192, r21A2, 0x01));

                                    body.emit(assign(r2193, body.constant(0u), 0x01));


                                 body.instructions = f219F_parent_instructions;
                                 body.emit(f219F);

                                 /* END IF */


                              body.instructions = f219D_parent_instructions;
                              body.emit(f219D);

                              /* END IF */

                              body.emit(assign(r2194, body.constant(0u), 0x01));


                           body.instructions = f2199_parent_instructions;
                           body.emit(f2199);

                           /* END IF */

                           ir_expression *const r21A7 = nequal(r2190, body.constant(0u));
                           ir_expression *const r21A8 = expr(ir_unop_b2i, r21A7);
                           ir_expression *const r21A9 = expr(ir_unop_i2u, r21A8);
                           body.emit(assign(r2192, bit_or(r2192, r21A9), 0x01));


                        body.instructions = f2197_parent_instructions;
                        body.emit(f2197);

                        /* END IF */

                        body.emit(assign(r217A, r2194, 0x01));

                        body.emit(assign(r217B, r2193, 0x01));

                        body.emit(assign(r217C, r2192, 0x01));

                        body.emit(assign(r2179, body.constant(int(0)), 0x01));

                        body.emit(assign(r217F, less(r2192, body.constant(0u)), 0x01));


                     body.instructions = f218E_parent_instructions;
                     body.emit(f218E);

                     /* END IF */


                  body.instructions = f218B_parent_instructions;
                  body.emit(f218B);

                  /* END IF */


               body.instructions = f2181_parent_instructions;
               body.emit(f2181);

               /* END IF */

               /* IF CONDITION */
               ir_if *f21AA = new(mem_ctx) ir_if(operand(r217D).val);
               exec_list *const f21AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f21AA->then_instructions;

                  /* IF CONDITION */
                  ir_if *f21AB = new(mem_ctx) ir_if(operand(r217F).val);
                  exec_list *const f21AB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f21AB->then_instructions;

                     ir_variable *const r21AC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r21AC, add(r217B, body.constant(1u)), 0x01));

                     ir_expression *const r21AD = less(r21AC, r217B);
                     ir_expression *const r21AE = expr(ir_unop_b2i, r21AD);
                     ir_expression *const r21AF = expr(ir_unop_i2u, r21AE);
                     body.emit(assign(r217A, add(r217A, r21AF), 0x01));

                     ir_expression *const r21B0 = equal(r217C, body.constant(0u));
                     ir_expression *const r21B1 = expr(ir_unop_b2i, r21B0);
                     ir_expression *const r21B2 = expr(ir_unop_i2u, r21B1);
                     ir_expression *const r21B3 = add(r217C, r21B2);
                     ir_expression *const r21B4 = bit_and(r21B3, body.constant(1u));
                     ir_expression *const r21B5 = expr(ir_unop_bit_not, r21B4);
                     body.emit(assign(r217B, bit_and(r21AC, r21B5), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f21AB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r21B7 = bit_or(r217A, r217B);
                     ir_expression *const r21B8 = equal(r21B7, body.constant(0u));
                     ir_if *f21B6 = new(mem_ctx) ir_if(operand(r21B8).val);
                     exec_list *const f21B6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f21B6->then_instructions;

                        body.emit(assign(r2179, body.constant(int(0)), 0x01));


                     body.instructions = f21B6_parent_instructions;
                     body.emit(f21B6);

                     /* END IF */


                  body.instructions = f21AB_parent_instructions;
                  body.emit(f21AB);

                  /* END IF */

                  ir_variable *const r21B9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r21B9);
                  ir_expression *const r21BA = lshift(r1CA7, body.constant(int(31)));
                  ir_expression *const r21BB = expr(ir_unop_i2u, r2179);
                  ir_expression *const r21BC = lshift(r21BB, body.constant(int(20)));
                  ir_expression *const r21BD = add(r21BA, r21BC);
                  body.emit(assign(r21B9, add(r21BD, r217A), 0x02));

                  body.emit(assign(r21B9, r217B, 0x01));

                  body.emit(assign(r217E, r21B9, 0x03));

                  body.emit(assign(r217D, body.constant(false), 0x01));


               body.instructions = f21AA_parent_instructions;
               body.emit(f21AA);

               /* END IF */

               body.emit(assign(r2066, r217E, 0x03));

               body.emit(assign(r2065, body.constant(false), 0x01));


            body.instructions = f212A_parent_instructions;
            body.emit(f212A);

            /* END IF */


         body.instructions = f2123_parent_instructions;
         body.emit(f2123);

         /* END IF */

         body.emit(assign(r1CA6, r2066, 0x03));


      body.instructions = f1CA8_parent_instructions;
      body.emit(f1CA8);

      /* END IF */

      body.emit(assign(r1CA4, r1CA6, 0x03));


   body.instructions = f1CA5_parent_instructions;
   body.emit(f1CA5);

   /* END IF */

   body.emit(ret(r1CA4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fceil64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r21BE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r21BE);
   ir_variable *const r21BF = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r21C0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r21C1 = rshift(swizzle_y(r21BE), body.constant(int(20)));
   ir_expression *const r21C2 = bit_and(r21C1, body.constant(2047u));
   ir_expression *const r21C3 = expr(ir_unop_u2i, r21C2);
   body.emit(assign(r21C0, add(r21C3, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r21C5 = less(r21C0, body.constant(int(0)));
   ir_if *f21C4 = new(mem_ctx) ir_if(operand(r21C5).val);
   exec_list *const f21C4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f21C4->then_instructions;

      body.emit(assign(r21BF, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f21C4->else_instructions;

      /* IF CONDITION */
      ir_expression *const r21C7 = greater(r21C0, body.constant(int(52)));
      ir_if *f21C6 = new(mem_ctx) ir_if(operand(r21C7).val);
      exec_list *const f21C6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f21C6->then_instructions;

         body.emit(assign(r21BF, r21BE, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f21C6->else_instructions;

         ir_variable *const r21C8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r21C8, sub(body.constant(int(52)), r21C0), 0x01));

         ir_variable *const r21C9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r21CB = gequal(r21C8, body.constant(int(32)));
         ir_if *f21CA = new(mem_ctx) ir_if(operand(r21CB).val);
         exec_list *const f21CA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f21CA->then_instructions;

            body.emit(assign(r21C9, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f21CA->else_instructions;

            body.emit(assign(r21C9, lshift(body.constant(4294967295u), r21C8), 0x01));


         body.instructions = f21CA_parent_instructions;
         body.emit(f21CA);

         /* END IF */

         ir_variable *const r21CC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r21CE = less(r21C8, body.constant(int(33)));
         ir_if *f21CD = new(mem_ctx) ir_if(operand(r21CE).val);
         exec_list *const f21CD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f21CD->then_instructions;

            body.emit(assign(r21CC, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f21CD->else_instructions;

            ir_expression *const r21CF = add(r21C8, body.constant(int(-32)));
            body.emit(assign(r21CC, lshift(body.constant(4294967295u), r21CF), 0x01));


         body.instructions = f21CD_parent_instructions;
         body.emit(f21CD);

         /* END IF */

         ir_variable *const r21D0 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r21D0, bit_and(r21C9, swizzle_x(r21BE)), 0x01));

         body.emit(assign(r21D0, bit_and(r21CC, swizzle_y(r21BE)), 0x02));

         body.emit(assign(r21BF, r21D0, 0x03));


      body.instructions = f21C6_parent_instructions;
      body.emit(f21C6);

      /* END IF */


   body.instructions = f21C4_parent_instructions;
   body.emit(f21C4);

   /* END IF */

   ir_variable *const r21D1 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r21D1, rshift(swizzle_y(r21BE), body.constant(int(31))), 0x01));

   ir_variable *const r21D2 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r21D4 = expr(ir_unop_u2i, r21D1);
   ir_expression *const r21D5 = expr(ir_unop_i2b, r21D4);
   ir_if *f21D3 = new(mem_ctx) ir_if(operand(r21D5).val);
   exec_list *const f21D3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f21D3->then_instructions;

      body.emit(assign(r21D2, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f21D3->else_instructions;

      ir_variable *const r21D6 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r21D7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r21D7);
      ir_variable *const r21D8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r21D8);
      ir_expression *const r21D9 = rshift(swizzle_y(r21BE), body.constant(int(20)));
      ir_expression *const r21DA = bit_and(r21D9, body.constant(2047u));
      ir_expression *const r21DB = expr(ir_unop_u2i, r21DA);
      ir_expression *const r21DC = equal(r21DB, body.constant(int(2047)));
      ir_expression *const r21DD = bit_and(swizzle_y(r21BE), body.constant(1048575u));
      ir_expression *const r21DE = bit_or(r21DD, swizzle_x(r21BE));
      ir_expression *const r21DF = nequal(r21DE, body.constant(0u));
      body.emit(assign(r21D8, logic_and(r21DC, r21DF), 0x01));

      ir_expression *const r21E0 = rshift(swizzle_y(r21BF), body.constant(int(20)));
      ir_expression *const r21E1 = bit_and(r21E0, body.constant(2047u));
      ir_expression *const r21E2 = expr(ir_unop_u2i, r21E1);
      ir_expression *const r21E3 = equal(r21E2, body.constant(int(2047)));
      ir_expression *const r21E4 = bit_and(swizzle_y(r21BF), body.constant(1048575u));
      ir_expression *const r21E5 = bit_or(r21E4, swizzle_x(r21BF));
      ir_expression *const r21E6 = nequal(r21E5, body.constant(0u));
      body.emit(assign(r21D7, logic_and(r21E3, r21E6), 0x01));

      /* IF CONDITION */
      ir_expression *const r21E8 = logic_or(r21D8, r21D7);
      ir_if *f21E7 = new(mem_ctx) ir_if(operand(r21E8).val);
      exec_list *const f21E7_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f21E7->then_instructions;

         body.emit(assign(r21D6, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f21E7->else_instructions;

         ir_expression *const r21E9 = equal(swizzle_x(r21BE), swizzle_x(r21BF));
         ir_expression *const r21EA = equal(swizzle_y(r21BE), swizzle_y(r21BF));
         ir_expression *const r21EB = equal(swizzle_x(r21BE), body.constant(0u));
         ir_expression *const r21EC = bit_or(swizzle_y(r21BE), swizzle_y(r21BF));
         ir_expression *const r21ED = lshift(r21EC, body.constant(int(1)));
         ir_expression *const r21EE = equal(r21ED, body.constant(0u));
         ir_expression *const r21EF = logic_and(r21EB, r21EE);
         ir_expression *const r21F0 = logic_or(r21EA, r21EF);
         body.emit(assign(r21D6, logic_and(r21E9, r21F0), 0x01));


      body.instructions = f21E7_parent_instructions;
      body.emit(f21E7);

      /* END IF */

      body.emit(assign(r21D2, r21D6, 0x01));


   body.instructions = f21D3_parent_instructions;
   body.emit(f21D3);

   /* END IF */

   ir_variable *const r21F1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f21F2 = new(mem_ctx) ir_if(operand(r21D2).val);
   exec_list *const f21F2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f21F2->then_instructions;

      body.emit(assign(r21F1, r21BF, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f21F2->else_instructions;

      ir_variable *const r21F3 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r21F4 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r21F4, rshift(swizzle_y(r21BF), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r21F6 = equal(r21F4, body.constant(0u));
      ir_if *f21F5 = new(mem_ctx) ir_if(operand(r21F6).val);
      exec_list *const f21F5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f21F5->then_instructions;

         ir_variable *const r21F7 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r21F7, body.constant(true), 0x01));

         ir_variable *const r21F8 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r21F9 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r21F9);
         ir_variable *const r21FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r21FA);
         ir_variable *const r21FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r21FB);
         ir_variable *const r21FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r21FC);
         ir_variable *const r21FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r21FD);
         ir_variable *const r21FE = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r21FE);
         ir_variable *const r21FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r21FF);
         ir_variable *const r2200 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r2200);
         body.emit(assign(r2200, body.constant(0u), 0x01));

         body.emit(assign(r21FF, body.constant(0u), 0x01));

         ir_variable *const r2201 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2201, swizzle_x(r21BF), 0x01));

         body.emit(assign(r21FD, r2201, 0x01));

         ir_variable *const r2202 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r2202, bit_and(swizzle_y(r21BF), body.constant(1048575u)), 0x01));

         body.emit(assign(r21FC, r2202, 0x01));

         ir_variable *const r2203 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2203, body.constant(0u), 0x01));

         body.emit(assign(r21FB, body.constant(0u), 0x01));

         body.emit(assign(r21FA, body.constant(0u), 0x01));

         ir_variable *const r2204 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2205 = rshift(swizzle_y(r21BF), body.constant(int(20)));
         ir_expression *const r2206 = bit_and(r2205, body.constant(2047u));
         body.emit(assign(r2204, expr(ir_unop_u2i, r2206), 0x01));

         ir_variable *const r2207 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r2207, body.constant(int(1023)), 0x01));

         ir_variable *const r2208 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2208, add(r2204, body.constant(int(-1023))), 0x01));

         body.emit(assign(r21F9, r2208, 0x01));

         /* IF CONDITION */
         ir_expression *const r220A = less(body.constant(int(0)), r2208);
         ir_if *f2209 = new(mem_ctx) ir_if(operand(r220A).val);
         exec_list *const f2209_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2209->then_instructions;

            /* IF CONDITION */
            ir_expression *const r220C = equal(r2204, body.constant(int(2047)));
            ir_if *f220B = new(mem_ctx) ir_if(operand(r220C).val);
            exec_list *const f220B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f220B->then_instructions;

               /* IF CONDITION */
               ir_expression *const r220E = bit_or(r2202, swizzle_x(r21BF));
               ir_expression *const r220F = nequal(r220E, body.constant(0u));
               ir_if *f220D = new(mem_ctx) ir_if(operand(r220F).val);
               exec_list *const f220D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f220D->then_instructions;

                  ir_variable *const r2210 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2210, swizzle_x(r21BF), 0x01));

                  ir_variable *const r2211 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2211, body.constant(0u), 0x01));

                  ir_variable *const r2212 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2210, bit_or(swizzle_y(r21BF), body.constant(524288u)), 0x02));

                  body.emit(assign(r2211, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2214 = lshift(swizzle_y(r21BF), body.constant(int(1)));
                  ir_expression *const r2215 = lequal(body.constant(4292870144u), r2214);
                  ir_expression *const r2216 = nequal(swizzle_x(r21BF), body.constant(0u));
                  ir_expression *const r2217 = bit_and(swizzle_y(r21BF), body.constant(1048575u));
                  ir_expression *const r2218 = nequal(r2217, body.constant(0u));
                  ir_expression *const r2219 = logic_or(r2216, r2218);
                  ir_expression *const r221A = logic_and(r2215, r2219);
                  ir_if *f2213 = new(mem_ctx) ir_if(operand(r221A).val);
                  exec_list *const f2213_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2213->then_instructions;

                     body.emit(assign(r2212, r2210, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2213->else_instructions;

                     body.emit(assign(r2212, r2211, 0x03));


                  body.instructions = f2213_parent_instructions;
                  body.emit(f2213);

                  /* END IF */

                  body.emit(assign(r21F8, r2212, 0x03));

                  body.emit(assign(r21F7, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f220D->else_instructions;

                  body.emit(assign(r21F8, r21BF, 0x03));

                  body.emit(assign(r21F7, body.constant(false), 0x01));


               body.instructions = f220D_parent_instructions;
               body.emit(f220D);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f220B->else_instructions;

               body.emit(assign(r21FA, body.constant(1048576u), 0x01));

               ir_variable *const r221B = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r221B, body.constant(0u), 0x01));

               ir_variable *const r221C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r221C);
               ir_variable *const r221D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r221D);
               ir_variable *const r221E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r221E);
               ir_variable *const r221F = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2220 = neg(r2208);
               body.emit(assign(r221F, bit_and(r2220, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2222 = equal(r2208, body.constant(int(0)));
               ir_if *f2221 = new(mem_ctx) ir_if(operand(r2222).val);
               exec_list *const f2221_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2221->then_instructions;

                  body.emit(assign(r221C, r221B, 0x01));

                  body.emit(assign(r221D, body.constant(0u), 0x01));

                  body.emit(assign(r221E, r21FA, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2221->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2224 = less(r2208, body.constant(int(32)));
                  ir_if *f2223 = new(mem_ctx) ir_if(operand(r2224).val);
                  exec_list *const f2223_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2223->then_instructions;

                     body.emit(assign(r221C, body.constant(0u), 0x01));

                     ir_expression *const r2225 = lshift(body.constant(1048576u), r221F);
                     body.emit(assign(r221D, bit_or(r2225, body.constant(0u)), 0x01));

                     body.emit(assign(r221E, rshift(body.constant(1048576u), r2208), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2223->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2227 = equal(r2208, body.constant(int(32)));
                     ir_if *f2226 = new(mem_ctx) ir_if(operand(r2227).val);
                     exec_list *const f2226_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2226->then_instructions;

                        body.emit(assign(r221C, body.constant(0u), 0x01));

                        body.emit(assign(r221D, r21FA, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2226->else_instructions;

                        body.emit(assign(r221B, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2229 = less(r2208, body.constant(int(64)));
                        ir_if *f2228 = new(mem_ctx) ir_if(operand(r2229).val);
                        exec_list *const f2228_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2228->then_instructions;

                           body.emit(assign(r221C, lshift(body.constant(1048576u), r221F), 0x01));

                           ir_expression *const r222A = bit_and(r2208, body.constant(int(31)));
                           body.emit(assign(r221D, rshift(body.constant(1048576u), r222A), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2228->else_instructions;

                           ir_variable *const r222B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r222D = equal(r2208, body.constant(int(64)));
                           ir_if *f222C = new(mem_ctx) ir_if(operand(r222D).val);
                           exec_list *const f222C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f222C->then_instructions;

                              body.emit(assign(r222B, r21FA, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f222C->else_instructions;

                              body.emit(assign(r222B, body.constant(1u), 0x01));


                           body.instructions = f222C_parent_instructions;
                           body.emit(f222C);

                           /* END IF */

                           body.emit(assign(r221C, r222B, 0x01));

                           body.emit(assign(r221D, body.constant(0u), 0x01));


                        body.instructions = f2228_parent_instructions;
                        body.emit(f2228);

                        /* END IF */


                     body.instructions = f2226_parent_instructions;
                     body.emit(f2226);

                     /* END IF */

                     body.emit(assign(r221E, body.constant(0u), 0x01));


                  body.instructions = f2223_parent_instructions;
                  body.emit(f2223);

                  /* END IF */

                  ir_expression *const r222E = nequal(r221B, body.constant(0u));
                  ir_expression *const r222F = expr(ir_unop_b2i, r222E);
                  ir_expression *const r2230 = expr(ir_unop_i2u, r222F);
                  body.emit(assign(r221C, bit_or(r221C, r2230), 0x01));


               body.instructions = f2221_parent_instructions;
               body.emit(f2221);

               /* END IF */

               body.emit(assign(r21FA, r221E, 0x01));

               body.emit(assign(r21FB, r221D, 0x01));

               body.emit(assign(r21FF, r221C, 0x01));

               body.emit(assign(r21FE, r2204, 0x01));


            body.instructions = f220B_parent_instructions;
            body.emit(f220B);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2209->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2232 = less(r2208, body.constant(int(0)));
            ir_if *f2231 = new(mem_ctx) ir_if(operand(r2232).val);
            exec_list *const f2231_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2231->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2234 = equal(r2204, body.constant(int(0)));
               ir_if *f2233 = new(mem_ctx) ir_if(operand(r2234).val);
               exec_list *const f2233_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2233->then_instructions;

                  body.emit(assign(r21F9, add(r2208, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2233->else_instructions;

                  body.emit(assign(r21FC, bit_or(r2202, body.constant(1048576u)), 0x01));


               body.instructions = f2233_parent_instructions;
               body.emit(f2233);

               /* END IF */

               ir_variable *const r2235 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2235, body.constant(0u), 0x01));

               ir_variable *const r2236 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2236, neg(r21F9), 0x01));

               ir_variable *const r2237 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2237);
               ir_variable *const r2238 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2238);
               ir_variable *const r2239 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2239);
               ir_variable *const r223A = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r223B = neg(r2236);
               body.emit(assign(r223A, bit_and(r223B, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r223D = equal(r2236, body.constant(int(0)));
               ir_if *f223C = new(mem_ctx) ir_if(operand(r223D).val);
               exec_list *const f223C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f223C->then_instructions;

                  body.emit(assign(r2237, r2235, 0x01));

                  body.emit(assign(r2238, r2201, 0x01));

                  body.emit(assign(r2239, r21FC, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f223C->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r223F = less(r2236, body.constant(int(32)));
                  ir_if *f223E = new(mem_ctx) ir_if(operand(r223F).val);
                  exec_list *const f223E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f223E->then_instructions;

                     body.emit(assign(r2237, lshift(swizzle_x(r21BF), r223A), 0x01));

                     ir_expression *const r2240 = lshift(r21FC, r223A);
                     ir_expression *const r2241 = rshift(swizzle_x(r21BF), r2236);
                     body.emit(assign(r2238, bit_or(r2240, r2241), 0x01));

                     body.emit(assign(r2239, rshift(r21FC, r2236), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f223E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2243 = equal(r2236, body.constant(int(32)));
                     ir_if *f2242 = new(mem_ctx) ir_if(operand(r2243).val);
                     exec_list *const f2242_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2242->then_instructions;

                        body.emit(assign(r2237, r2201, 0x01));

                        body.emit(assign(r2238, r21FC, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2242->else_instructions;

                        body.emit(assign(r2235, bit_or(body.constant(0u), swizzle_x(r21BF)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2245 = less(r2236, body.constant(int(64)));
                        ir_if *f2244 = new(mem_ctx) ir_if(operand(r2245).val);
                        exec_list *const f2244_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2244->then_instructions;

                           body.emit(assign(r2237, lshift(r21FC, r223A), 0x01));

                           ir_expression *const r2246 = bit_and(r2236, body.constant(int(31)));
                           body.emit(assign(r2238, rshift(r21FC, r2246), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2244->else_instructions;

                           ir_variable *const r2247 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2249 = equal(r2236, body.constant(int(64)));
                           ir_if *f2248 = new(mem_ctx) ir_if(operand(r2249).val);
                           exec_list *const f2248_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2248->then_instructions;

                              body.emit(assign(r2247, r21FC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2248->else_instructions;

                              ir_expression *const r224A = nequal(r21FC, body.constant(0u));
                              ir_expression *const r224B = expr(ir_unop_b2i, r224A);
                              body.emit(assign(r2247, expr(ir_unop_i2u, r224B), 0x01));


                           body.instructions = f2248_parent_instructions;
                           body.emit(f2248);

                           /* END IF */

                           body.emit(assign(r2237, r2247, 0x01));

                           body.emit(assign(r2238, body.constant(0u), 0x01));


                        body.instructions = f2244_parent_instructions;
                        body.emit(f2244);

                        /* END IF */


                     body.instructions = f2242_parent_instructions;
                     body.emit(f2242);

                     /* END IF */

                     body.emit(assign(r2239, body.constant(0u), 0x01));


                  body.instructions = f223E_parent_instructions;
                  body.emit(f223E);

                  /* END IF */

                  ir_expression *const r224C = nequal(r2235, body.constant(0u));
                  ir_expression *const r224D = expr(ir_unop_b2i, r224C);
                  ir_expression *const r224E = expr(ir_unop_i2u, r224D);
                  body.emit(assign(r2237, bit_or(r2237, r224E), 0x01));


               body.instructions = f223C_parent_instructions;
               body.emit(f223C);

               /* END IF */

               body.emit(assign(r21FC, r2239, 0x01));

               body.emit(assign(r21FD, r2238, 0x01));

               body.emit(assign(r21FF, r2237, 0x01));

               body.emit(assign(r21FE, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2231->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2250 = equal(r2204, body.constant(int(2047)));
               ir_if *f224F = new(mem_ctx) ir_if(operand(r2250).val);
               exec_list *const f224F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f224F->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2252 = bit_or(r21FC, r21FD);
                  ir_expression *const r2253 = bit_or(r21FA, r21FB);
                  ir_expression *const r2254 = bit_or(r2252, r2253);
                  ir_expression *const r2255 = nequal(r2254, body.constant(0u));
                  ir_if *f2251 = new(mem_ctx) ir_if(operand(r2255).val);
                  exec_list *const f2251_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2251->then_instructions;

                     ir_variable *const r2256 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2256, swizzle_x(r21BF), 0x01));

                     ir_variable *const r2257 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2257, body.constant(0u), 0x01));

                     ir_variable *const r2258 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2256, bit_or(swizzle_y(r21BF), body.constant(524288u)), 0x02));

                     body.emit(assign(r2257, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r225A = lshift(swizzle_y(r21BF), body.constant(int(1)));
                     ir_expression *const r225B = lequal(body.constant(4292870144u), r225A);
                     ir_expression *const r225C = nequal(swizzle_x(r21BF), body.constant(0u));
                     ir_expression *const r225D = bit_and(swizzle_y(r21BF), body.constant(1048575u));
                     ir_expression *const r225E = nequal(r225D, body.constant(0u));
                     ir_expression *const r225F = logic_or(r225C, r225E);
                     ir_expression *const r2260 = logic_and(r225B, r225F);
                     ir_if *f2259 = new(mem_ctx) ir_if(operand(r2260).val);
                     exec_list *const f2259_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2259->then_instructions;

                        body.emit(assign(r2258, r2256, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2259->else_instructions;

                        body.emit(assign(r2258, r2257, 0x03));


                     body.instructions = f2259_parent_instructions;
                     body.emit(f2259);

                     /* END IF */

                     body.emit(assign(r21F8, r2258, 0x03));

                     body.emit(assign(r21F7, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2251->else_instructions;

                     body.emit(assign(r21F8, r21BF, 0x03));

                     body.emit(assign(r21F7, body.constant(false), 0x01));


                  body.instructions = f2251_parent_instructions;
                  body.emit(f2251);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f224F->else_instructions;

                  ir_variable *const r2261 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r2262 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2262, add(r21FD, r21FB), 0x01));

                  ir_expression *const r2263 = add(r21FC, r21FA);
                  ir_expression *const r2264 = less(r2262, r21FD);
                  ir_expression *const r2265 = expr(ir_unop_b2i, r2264);
                  ir_expression *const r2266 = expr(ir_unop_i2u, r2265);
                  body.emit(assign(r2261, add(r2263, r2266), 0x01));

                  body.emit(assign(r2200, r2261, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2268 = equal(r2204, body.constant(int(0)));
                  ir_if *f2267 = new(mem_ctx) ir_if(operand(r2268).val);
                  exec_list *const f2267_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2267->then_instructions;

                     ir_variable *const r2269 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2269);
                     ir_expression *const r226A = lshift(r21F4, body.constant(int(31)));
                     body.emit(assign(r2269, add(r226A, r2261), 0x02));

                     body.emit(assign(r2269, r2262, 0x01));

                     body.emit(assign(r21F8, r2269, 0x03));

                     body.emit(assign(r21F7, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2267->else_instructions;

                     body.emit(assign(r2200, bit_or(r2261, body.constant(2097152u)), 0x01));

                     body.emit(assign(r21FE, r2204, 0x01));

                     ir_variable *const r226B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r226B);
                     ir_variable *const r226C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r226C);
                     ir_variable *const r226D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r226D);
                     body.emit(assign(r226B, lshift(r2262, body.constant(int(31))), 0x01));

                     ir_expression *const r226E = lshift(r2200, body.constant(int(31)));
                     ir_expression *const r226F = rshift(r2262, body.constant(int(1)));
                     body.emit(assign(r226C, bit_or(r226E, r226F), 0x01));

                     body.emit(assign(r226D, rshift(r2200, body.constant(int(1))), 0x01));

                     body.emit(assign(r226B, bit_or(r226B, body.constant(0u)), 0x01));

                     body.emit(assign(r2200, r226D, 0x01));

                     body.emit(assign(r21FF, r226B, 0x01));

                     ir_variable *const r2270 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2270, r2204, 0x01));

                     ir_variable *const r2271 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2271, r226D, 0x01));

                     ir_variable *const r2272 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2272, r226C, 0x01));

                     ir_variable *const r2273 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2273, r226B, 0x01));

                     ir_variable *const r2274 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2274, body.constant(true), 0x01));

                     ir_variable *const r2275 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2276 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2276);
                     ir_expression *const r2277 = expr(ir_unop_u2i, r226B);
                     body.emit(assign(r2276, less(r2277, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2279 = lequal(body.constant(int(2045)), r2204);
                     ir_if *f2278 = new(mem_ctx) ir_if(operand(r2279).val);
                     exec_list *const f2278_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2278->then_instructions;

                        ir_variable *const r227A = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r227C = less(body.constant(int(2045)), r2204);
                        ir_if *f227B = new(mem_ctx) ir_if(operand(r227C).val);
                        exec_list *const f227B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f227B->then_instructions;

                           body.emit(assign(r227A, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f227B->else_instructions;

                           ir_variable *const r227D = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r227F = equal(r2204, body.constant(int(2045)));
                           ir_if *f227E = new(mem_ctx) ir_if(operand(r227F).val);
                           exec_list *const f227E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f227E->then_instructions;

                              ir_expression *const r2280 = equal(body.constant(2097151u), r226D);
                              ir_expression *const r2281 = equal(body.constant(4294967295u), r226C);
                              body.emit(assign(r227D, logic_and(r2280, r2281), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f227E->else_instructions;

                              body.emit(assign(r227D, body.constant(false), 0x01));


                           body.instructions = f227E_parent_instructions;
                           body.emit(f227E);

                           /* END IF */

                           body.emit(assign(r227A, logic_and(r227D, r2276), 0x01));


                        body.instructions = f227B_parent_instructions;
                        body.emit(f227B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2282 = new(mem_ctx) ir_if(operand(r227A).val);
                        exec_list *const f2282_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2282->then_instructions;

                           ir_variable *const r2283 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2283);
                           ir_expression *const r2284 = lshift(r21F4, body.constant(int(31)));
                           body.emit(assign(r2283, add(r2284, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2283, body.constant(0u), 0x01));

                           body.emit(assign(r2275, r2283, 0x03));

                           body.emit(assign(r2274, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2282->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2286 = less(r2204, body.constant(int(0)));
                           ir_if *f2285 = new(mem_ctx) ir_if(operand(r2286).val);
                           exec_list *const f2285_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2285->then_instructions;

                              ir_variable *const r2287 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2287, r226B, 0x01));

                              ir_variable *const r2288 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2288, neg(r2204), 0x01));

                              ir_variable *const r2289 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2289);
                              ir_variable *const r228A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r228A);
                              ir_variable *const r228B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r228B);
                              ir_variable *const r228C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r228D = neg(r2288);
                              body.emit(assign(r228C, bit_and(r228D, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r228F = equal(r2288, body.constant(int(0)));
                              ir_if *f228E = new(mem_ctx) ir_if(operand(r228F).val);
                              exec_list *const f228E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f228E->then_instructions;

                                 body.emit(assign(r2289, r226B, 0x01));

                                 body.emit(assign(r228A, r226C, 0x01));

                                 body.emit(assign(r228B, r226D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f228E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2291 = less(r2288, body.constant(int(32)));
                                 ir_if *f2290 = new(mem_ctx) ir_if(operand(r2291).val);
                                 exec_list *const f2290_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2290->then_instructions;

                                    body.emit(assign(r2289, lshift(r226C, r228C), 0x01));

                                    ir_expression *const r2292 = lshift(r226D, r228C);
                                    ir_expression *const r2293 = rshift(r226C, r2288);
                                    body.emit(assign(r228A, bit_or(r2292, r2293), 0x01));

                                    body.emit(assign(r228B, rshift(r226D, r2288), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2290->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2295 = equal(r2288, body.constant(int(32)));
                                    ir_if *f2294 = new(mem_ctx) ir_if(operand(r2295).val);
                                    exec_list *const f2294_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2294->then_instructions;

                                       body.emit(assign(r2289, r226C, 0x01));

                                       body.emit(assign(r228A, r226D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2294->else_instructions;

                                       body.emit(assign(r2287, bit_or(r226B, r226C), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2297 = less(r2288, body.constant(int(64)));
                                       ir_if *f2296 = new(mem_ctx) ir_if(operand(r2297).val);
                                       exec_list *const f2296_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2296->then_instructions;

                                          body.emit(assign(r2289, lshift(r226D, r228C), 0x01));

                                          ir_expression *const r2298 = bit_and(r2288, body.constant(int(31)));
                                          body.emit(assign(r228A, rshift(r226D, r2298), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2296->else_instructions;

                                          ir_variable *const r2299 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r229B = equal(r2288, body.constant(int(64)));
                                          ir_if *f229A = new(mem_ctx) ir_if(operand(r229B).val);
                                          exec_list *const f229A_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f229A->then_instructions;

                                             body.emit(assign(r2299, r226D, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f229A->else_instructions;

                                             ir_expression *const r229C = nequal(r226D, body.constant(0u));
                                             ir_expression *const r229D = expr(ir_unop_b2i, r229C);
                                             body.emit(assign(r2299, expr(ir_unop_i2u, r229D), 0x01));


                                          body.instructions = f229A_parent_instructions;
                                          body.emit(f229A);

                                          /* END IF */

                                          body.emit(assign(r2289, r2299, 0x01));

                                          body.emit(assign(r228A, body.constant(0u), 0x01));


                                       body.instructions = f2296_parent_instructions;
                                       body.emit(f2296);

                                       /* END IF */


                                    body.instructions = f2294_parent_instructions;
                                    body.emit(f2294);

                                    /* END IF */

                                    body.emit(assign(r228B, body.constant(0u), 0x01));


                                 body.instructions = f2290_parent_instructions;
                                 body.emit(f2290);

                                 /* END IF */

                                 ir_expression *const r229E = nequal(r2287, body.constant(0u));
                                 ir_expression *const r229F = expr(ir_unop_b2i, r229E);
                                 ir_expression *const r22A0 = expr(ir_unop_i2u, r229F);
                                 body.emit(assign(r2289, bit_or(r2289, r22A0), 0x01));


                              body.instructions = f228E_parent_instructions;
                              body.emit(f228E);

                              /* END IF */

                              body.emit(assign(r2271, r228B, 0x01));

                              body.emit(assign(r2272, r228A, 0x01));

                              body.emit(assign(r2273, r2289, 0x01));

                              body.emit(assign(r2270, body.constant(int(0)), 0x01));

                              body.emit(assign(r2276, less(r2289, body.constant(0u)), 0x01));


                           body.instructions = f2285_parent_instructions;
                           body.emit(f2285);

                           /* END IF */


                        body.instructions = f2282_parent_instructions;
                        body.emit(f2282);

                        /* END IF */


                     body.instructions = f2278_parent_instructions;
                     body.emit(f2278);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f22A1 = new(mem_ctx) ir_if(operand(r2274).val);
                     exec_list *const f22A1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22A1->then_instructions;

                        /* IF CONDITION */
                        ir_if *f22A2 = new(mem_ctx) ir_if(operand(r2276).val);
                        exec_list *const f22A2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22A2->then_instructions;

                           ir_variable *const r22A3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r22A3, add(r2272, body.constant(1u)), 0x01));

                           ir_expression *const r22A4 = less(r22A3, r2272);
                           ir_expression *const r22A5 = expr(ir_unop_b2i, r22A4);
                           ir_expression *const r22A6 = expr(ir_unop_i2u, r22A5);
                           body.emit(assign(r2271, add(r2271, r22A6), 0x01));

                           ir_expression *const r22A7 = equal(r2273, body.constant(0u));
                           ir_expression *const r22A8 = expr(ir_unop_b2i, r22A7);
                           ir_expression *const r22A9 = expr(ir_unop_i2u, r22A8);
                           ir_expression *const r22AA = add(r2273, r22A9);
                           ir_expression *const r22AB = bit_and(r22AA, body.constant(1u));
                           ir_expression *const r22AC = expr(ir_unop_bit_not, r22AB);
                           body.emit(assign(r2272, bit_and(r22A3, r22AC), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22A2->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r22AE = bit_or(r2271, r2272);
                           ir_expression *const r22AF = equal(r22AE, body.constant(0u));
                           ir_if *f22AD = new(mem_ctx) ir_if(operand(r22AF).val);
                           exec_list *const f22AD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22AD->then_instructions;

                              body.emit(assign(r2270, body.constant(int(0)), 0x01));


                           body.instructions = f22AD_parent_instructions;
                           body.emit(f22AD);

                           /* END IF */


                        body.instructions = f22A2_parent_instructions;
                        body.emit(f22A2);

                        /* END IF */

                        ir_variable *const r22B0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r22B0);
                        ir_expression *const r22B1 = lshift(r21F4, body.constant(int(31)));
                        ir_expression *const r22B2 = expr(ir_unop_i2u, r2270);
                        ir_expression *const r22B3 = lshift(r22B2, body.constant(int(20)));
                        ir_expression *const r22B4 = add(r22B1, r22B3);
                        body.emit(assign(r22B0, add(r22B4, r2271), 0x02));

                        body.emit(assign(r22B0, r2272, 0x01));

                        body.emit(assign(r2275, r22B0, 0x03));

                        body.emit(assign(r2274, body.constant(false), 0x01));


                     body.instructions = f22A1_parent_instructions;
                     body.emit(f22A1);

                     /* END IF */

                     body.emit(assign(r21F8, r2275, 0x03));

                     body.emit(assign(r21F7, body.constant(false), 0x01));


                  body.instructions = f2267_parent_instructions;
                  body.emit(f2267);

                  /* END IF */


               body.instructions = f224F_parent_instructions;
               body.emit(f224F);

               /* END IF */


            body.instructions = f2231_parent_instructions;
            body.emit(f2231);

            /* END IF */


         body.instructions = f2209_parent_instructions;
         body.emit(f2209);

         /* END IF */

         /* IF CONDITION */
         ir_if *f22B5 = new(mem_ctx) ir_if(operand(r21F7).val);
         exec_list *const f22B5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f22B5->then_instructions;

            body.emit(assign(r21FC, bit_or(r21FC, body.constant(1048576u)), 0x01));

            ir_variable *const r22B6 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r22B7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r22B7, add(r21FD, r21FB), 0x01));

            ir_expression *const r22B8 = add(r21FC, r21FA);
            ir_expression *const r22B9 = less(r22B7, r21FD);
            ir_expression *const r22BA = expr(ir_unop_b2i, r22B9);
            ir_expression *const r22BB = expr(ir_unop_i2u, r22BA);
            body.emit(assign(r22B6, add(r22B8, r22BB), 0x01));

            body.emit(assign(r2200, r22B6, 0x01));

            body.emit(assign(r21FE, add(r21FE, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r22BD = less(r22B6, body.constant(2097152u));
            ir_if *f22BC = new(mem_ctx) ir_if(operand(r22BD).val);
            exec_list *const f22BC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f22BC->then_instructions;

               ir_variable *const r22BE = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r22BE, r21FE, 0x01));

               ir_variable *const r22BF = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r22BF, r22B6, 0x01));

               ir_variable *const r22C0 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r22C0, r22B7, 0x01));

               ir_variable *const r22C1 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r22C1, r21FF, 0x01));

               ir_variable *const r22C2 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r22C2, body.constant(true), 0x01));

               ir_variable *const r22C3 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r22C4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r22C4);
               ir_expression *const r22C5 = expr(ir_unop_u2i, r21FF);
               body.emit(assign(r22C4, less(r22C5, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r22C7 = lequal(body.constant(int(2045)), r21FE);
               ir_if *f22C6 = new(mem_ctx) ir_if(operand(r22C7).val);
               exec_list *const f22C6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f22C6->then_instructions;

                  ir_variable *const r22C8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r22CA = less(body.constant(int(2045)), r21FE);
                  ir_if *f22C9 = new(mem_ctx) ir_if(operand(r22CA).val);
                  exec_list *const f22C9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f22C9->then_instructions;

                     body.emit(assign(r22C8, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f22C9->else_instructions;

                     ir_variable *const r22CB = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r22CD = equal(r21FE, body.constant(int(2045)));
                     ir_if *f22CC = new(mem_ctx) ir_if(operand(r22CD).val);
                     exec_list *const f22CC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22CC->then_instructions;

                        ir_expression *const r22CE = equal(body.constant(2097151u), r22B6);
                        ir_expression *const r22CF = equal(body.constant(4294967295u), r22B7);
                        body.emit(assign(r22CB, logic_and(r22CE, r22CF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f22CC->else_instructions;

                        body.emit(assign(r22CB, body.constant(false), 0x01));


                     body.instructions = f22CC_parent_instructions;
                     body.emit(f22CC);

                     /* END IF */

                     body.emit(assign(r22C8, logic_and(r22CB, r22C4), 0x01));


                  body.instructions = f22C9_parent_instructions;
                  body.emit(f22C9);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f22D0 = new(mem_ctx) ir_if(operand(r22C8).val);
                  exec_list *const f22D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f22D0->then_instructions;

                     ir_variable *const r22D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r22D1);
                     ir_expression *const r22D2 = lshift(r21F4, body.constant(int(31)));
                     body.emit(assign(r22D1, add(r22D2, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r22D1, body.constant(0u), 0x01));

                     body.emit(assign(r22C3, r22D1, 0x03));

                     body.emit(assign(r22C2, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f22D0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r22D4 = less(r21FE, body.constant(int(0)));
                     ir_if *f22D3 = new(mem_ctx) ir_if(operand(r22D4).val);
                     exec_list *const f22D3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22D3->then_instructions;

                        ir_variable *const r22D5 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r22D5, r21FF, 0x01));

                        ir_variable *const r22D6 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r22D6, neg(r21FE), 0x01));

                        ir_variable *const r22D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r22D7);
                        ir_variable *const r22D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r22D8);
                        ir_variable *const r22D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r22D9);
                        ir_variable *const r22DA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r22DB = neg(r22D6);
                        body.emit(assign(r22DA, bit_and(r22DB, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r22DD = equal(r22D6, body.constant(int(0)));
                        ir_if *f22DC = new(mem_ctx) ir_if(operand(r22DD).val);
                        exec_list *const f22DC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22DC->then_instructions;

                           body.emit(assign(r22D7, r21FF, 0x01));

                           body.emit(assign(r22D8, r22B7, 0x01));

                           body.emit(assign(r22D9, r22B6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22DC->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r22DF = less(r22D6, body.constant(int(32)));
                           ir_if *f22DE = new(mem_ctx) ir_if(operand(r22DF).val);
                           exec_list *const f22DE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22DE->then_instructions;

                              body.emit(assign(r22D7, lshift(r22B7, r22DA), 0x01));

                              ir_expression *const r22E0 = lshift(r22B6, r22DA);
                              ir_expression *const r22E1 = rshift(r22B7, r22D6);
                              body.emit(assign(r22D8, bit_or(r22E0, r22E1), 0x01));

                              body.emit(assign(r22D9, rshift(r22B6, r22D6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f22DE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r22E3 = equal(r22D6, body.constant(int(32)));
                              ir_if *f22E2 = new(mem_ctx) ir_if(operand(r22E3).val);
                              exec_list *const f22E2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f22E2->then_instructions;

                                 body.emit(assign(r22D7, r22B7, 0x01));

                                 body.emit(assign(r22D8, r22B6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f22E2->else_instructions;

                                 body.emit(assign(r22D5, bit_or(r21FF, r22B7), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r22E5 = less(r22D6, body.constant(int(64)));
                                 ir_if *f22E4 = new(mem_ctx) ir_if(operand(r22E5).val);
                                 exec_list *const f22E4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f22E4->then_instructions;

                                    body.emit(assign(r22D7, lshift(r22B6, r22DA), 0x01));

                                    ir_expression *const r22E6 = bit_and(r22D6, body.constant(int(31)));
                                    body.emit(assign(r22D8, rshift(r22B6, r22E6), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f22E4->else_instructions;

                                    ir_variable *const r22E7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r22E9 = equal(r22D6, body.constant(int(64)));
                                    ir_if *f22E8 = new(mem_ctx) ir_if(operand(r22E9).val);
                                    exec_list *const f22E8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f22E8->then_instructions;

                                       body.emit(assign(r22E7, r22B6, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f22E8->else_instructions;

                                       ir_expression *const r22EA = nequal(r22B6, body.constant(0u));
                                       ir_expression *const r22EB = expr(ir_unop_b2i, r22EA);
                                       body.emit(assign(r22E7, expr(ir_unop_i2u, r22EB), 0x01));


                                    body.instructions = f22E8_parent_instructions;
                                    body.emit(f22E8);

                                    /* END IF */

                                    body.emit(assign(r22D7, r22E7, 0x01));

                                    body.emit(assign(r22D8, body.constant(0u), 0x01));


                                 body.instructions = f22E4_parent_instructions;
                                 body.emit(f22E4);

                                 /* END IF */


                              body.instructions = f22E2_parent_instructions;
                              body.emit(f22E2);

                              /* END IF */

                              body.emit(assign(r22D9, body.constant(0u), 0x01));


                           body.instructions = f22DE_parent_instructions;
                           body.emit(f22DE);

                           /* END IF */

                           ir_expression *const r22EC = nequal(r22D5, body.constant(0u));
                           ir_expression *const r22ED = expr(ir_unop_b2i, r22EC);
                           ir_expression *const r22EE = expr(ir_unop_i2u, r22ED);
                           body.emit(assign(r22D7, bit_or(r22D7, r22EE), 0x01));


                        body.instructions = f22DC_parent_instructions;
                        body.emit(f22DC);

                        /* END IF */

                        body.emit(assign(r22BF, r22D9, 0x01));

                        body.emit(assign(r22C0, r22D8, 0x01));

                        body.emit(assign(r22C1, r22D7, 0x01));

                        body.emit(assign(r22BE, body.constant(int(0)), 0x01));

                        body.emit(assign(r22C4, less(r22D7, body.constant(0u)), 0x01));


                     body.instructions = f22D3_parent_instructions;
                     body.emit(f22D3);

                     /* END IF */


                  body.instructions = f22D0_parent_instructions;
                  body.emit(f22D0);

                  /* END IF */


               body.instructions = f22C6_parent_instructions;
               body.emit(f22C6);

               /* END IF */

               /* IF CONDITION */
               ir_if *f22EF = new(mem_ctx) ir_if(operand(r22C2).val);
               exec_list *const f22EF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f22EF->then_instructions;

                  /* IF CONDITION */
                  ir_if *f22F0 = new(mem_ctx) ir_if(operand(r22C4).val);
                  exec_list *const f22F0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f22F0->then_instructions;

                     ir_variable *const r22F1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r22F1, add(r22C0, body.constant(1u)), 0x01));

                     ir_expression *const r22F2 = less(r22F1, r22C0);
                     ir_expression *const r22F3 = expr(ir_unop_b2i, r22F2);
                     ir_expression *const r22F4 = expr(ir_unop_i2u, r22F3);
                     body.emit(assign(r22BF, add(r22BF, r22F4), 0x01));

                     ir_expression *const r22F5 = equal(r22C1, body.constant(0u));
                     ir_expression *const r22F6 = expr(ir_unop_b2i, r22F5);
                     ir_expression *const r22F7 = expr(ir_unop_i2u, r22F6);
                     ir_expression *const r22F8 = add(r22C1, r22F7);
                     ir_expression *const r22F9 = bit_and(r22F8, body.constant(1u));
                     ir_expression *const r22FA = expr(ir_unop_bit_not, r22F9);
                     body.emit(assign(r22C0, bit_and(r22F1, r22FA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f22F0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r22FC = bit_or(r22BF, r22C0);
                     ir_expression *const r22FD = equal(r22FC, body.constant(0u));
                     ir_if *f22FB = new(mem_ctx) ir_if(operand(r22FD).val);
                     exec_list *const f22FB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22FB->then_instructions;

                        body.emit(assign(r22BE, body.constant(int(0)), 0x01));


                     body.instructions = f22FB_parent_instructions;
                     body.emit(f22FB);

                     /* END IF */


                  body.instructions = f22F0_parent_instructions;
                  body.emit(f22F0);

                  /* END IF */

                  ir_variable *const r22FE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r22FE);
                  ir_expression *const r22FF = lshift(r21F4, body.constant(int(31)));
                  ir_expression *const r2300 = expr(ir_unop_i2u, r22BE);
                  ir_expression *const r2301 = lshift(r2300, body.constant(int(20)));
                  ir_expression *const r2302 = add(r22FF, r2301);
                  body.emit(assign(r22FE, add(r2302, r22BF), 0x02));

                  body.emit(assign(r22FE, r22C0, 0x01));

                  body.emit(assign(r22C3, r22FE, 0x03));

                  body.emit(assign(r22C2, body.constant(false), 0x01));


               body.instructions = f22EF_parent_instructions;
               body.emit(f22EF);

               /* END IF */

               body.emit(assign(r21F8, r22C3, 0x03));

               body.emit(assign(r21F7, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f22BC->else_instructions;

               body.emit(assign(r21FE, add(r21FE, body.constant(int(1))), 0x01));

               ir_variable *const r2303 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2303);
               ir_variable *const r2304 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2304);
               ir_variable *const r2305 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2305);
               body.emit(assign(r2303, lshift(r22B7, body.constant(int(31))), 0x01));

               ir_expression *const r2306 = lshift(r22B6, body.constant(int(31)));
               ir_expression *const r2307 = rshift(r22B7, body.constant(int(1)));
               body.emit(assign(r2304, bit_or(r2306, r2307), 0x01));

               body.emit(assign(r2305, rshift(r22B6, body.constant(int(1))), 0x01));

               ir_expression *const r2308 = nequal(r21FF, body.constant(0u));
               ir_expression *const r2309 = expr(ir_unop_b2i, r2308);
               ir_expression *const r230A = expr(ir_unop_i2u, r2309);
               body.emit(assign(r2303, bit_or(r2303, r230A), 0x01));

               body.emit(assign(r2200, r2305, 0x01));

               body.emit(assign(r21FF, r2303, 0x01));

               ir_variable *const r230B = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r230B, r21FE, 0x01));

               ir_variable *const r230C = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r230C, r2305, 0x01));

               ir_variable *const r230D = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r230D, r2304, 0x01));

               ir_variable *const r230E = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r230E, r2303, 0x01));

               ir_variable *const r230F = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r230F, body.constant(true), 0x01));

               ir_variable *const r2310 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2311 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2311);
               ir_expression *const r2312 = expr(ir_unop_u2i, r2303);
               body.emit(assign(r2311, less(r2312, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2314 = lequal(body.constant(int(2045)), r21FE);
               ir_if *f2313 = new(mem_ctx) ir_if(operand(r2314).val);
               exec_list *const f2313_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2313->then_instructions;

                  ir_variable *const r2315 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2317 = less(body.constant(int(2045)), r21FE);
                  ir_if *f2316 = new(mem_ctx) ir_if(operand(r2317).val);
                  exec_list *const f2316_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2316->then_instructions;

                     body.emit(assign(r2315, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2316->else_instructions;

                     ir_variable *const r2318 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r231A = equal(r21FE, body.constant(int(2045)));
                     ir_if *f2319 = new(mem_ctx) ir_if(operand(r231A).val);
                     exec_list *const f2319_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2319->then_instructions;

                        ir_expression *const r231B = equal(body.constant(2097151u), r2305);
                        ir_expression *const r231C = equal(body.constant(4294967295u), r2304);
                        body.emit(assign(r2318, logic_and(r231B, r231C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2319->else_instructions;

                        body.emit(assign(r2318, body.constant(false), 0x01));


                     body.instructions = f2319_parent_instructions;
                     body.emit(f2319);

                     /* END IF */

                     body.emit(assign(r2315, logic_and(r2318, r2311), 0x01));


                  body.instructions = f2316_parent_instructions;
                  body.emit(f2316);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f231D = new(mem_ctx) ir_if(operand(r2315).val);
                  exec_list *const f231D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f231D->then_instructions;

                     ir_variable *const r231E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r231E);
                     ir_expression *const r231F = lshift(r21F4, body.constant(int(31)));
                     body.emit(assign(r231E, add(r231F, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r231E, body.constant(0u), 0x01));

                     body.emit(assign(r2310, r231E, 0x03));

                     body.emit(assign(r230F, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f231D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2321 = less(r21FE, body.constant(int(0)));
                     ir_if *f2320 = new(mem_ctx) ir_if(operand(r2321).val);
                     exec_list *const f2320_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2320->then_instructions;

                        ir_variable *const r2322 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2322, r2303, 0x01));

                        ir_variable *const r2323 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2323, neg(r21FE), 0x01));

                        ir_variable *const r2324 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2324);
                        ir_variable *const r2325 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2325);
                        ir_variable *const r2326 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2326);
                        ir_variable *const r2327 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2328 = neg(r2323);
                        body.emit(assign(r2327, bit_and(r2328, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r232A = equal(r2323, body.constant(int(0)));
                        ir_if *f2329 = new(mem_ctx) ir_if(operand(r232A).val);
                        exec_list *const f2329_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2329->then_instructions;

                           body.emit(assign(r2324, r2303, 0x01));

                           body.emit(assign(r2325, r2304, 0x01));

                           body.emit(assign(r2326, r2305, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2329->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r232C = less(r2323, body.constant(int(32)));
                           ir_if *f232B = new(mem_ctx) ir_if(operand(r232C).val);
                           exec_list *const f232B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f232B->then_instructions;

                              body.emit(assign(r2324, lshift(r2304, r2327), 0x01));

                              ir_expression *const r232D = lshift(r2305, r2327);
                              ir_expression *const r232E = rshift(r2304, r2323);
                              body.emit(assign(r2325, bit_or(r232D, r232E), 0x01));

                              body.emit(assign(r2326, rshift(r2305, r2323), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f232B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2330 = equal(r2323, body.constant(int(32)));
                              ir_if *f232F = new(mem_ctx) ir_if(operand(r2330).val);
                              exec_list *const f232F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f232F->then_instructions;

                                 body.emit(assign(r2324, r2304, 0x01));

                                 body.emit(assign(r2325, r2305, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f232F->else_instructions;

                                 body.emit(assign(r2322, bit_or(r2303, r2304), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2332 = less(r2323, body.constant(int(64)));
                                 ir_if *f2331 = new(mem_ctx) ir_if(operand(r2332).val);
                                 exec_list *const f2331_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2331->then_instructions;

                                    body.emit(assign(r2324, lshift(r2305, r2327), 0x01));

                                    ir_expression *const r2333 = bit_and(r2323, body.constant(int(31)));
                                    body.emit(assign(r2325, rshift(r2305, r2333), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2331->else_instructions;

                                    ir_variable *const r2334 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2336 = equal(r2323, body.constant(int(64)));
                                    ir_if *f2335 = new(mem_ctx) ir_if(operand(r2336).val);
                                    exec_list *const f2335_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2335->then_instructions;

                                       body.emit(assign(r2334, r2305, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2335->else_instructions;

                                       ir_expression *const r2337 = nequal(r2305, body.constant(0u));
                                       ir_expression *const r2338 = expr(ir_unop_b2i, r2337);
                                       body.emit(assign(r2334, expr(ir_unop_i2u, r2338), 0x01));


                                    body.instructions = f2335_parent_instructions;
                                    body.emit(f2335);

                                    /* END IF */

                                    body.emit(assign(r2324, r2334, 0x01));

                                    body.emit(assign(r2325, body.constant(0u), 0x01));


                                 body.instructions = f2331_parent_instructions;
                                 body.emit(f2331);

                                 /* END IF */


                              body.instructions = f232F_parent_instructions;
                              body.emit(f232F);

                              /* END IF */

                              body.emit(assign(r2326, body.constant(0u), 0x01));


                           body.instructions = f232B_parent_instructions;
                           body.emit(f232B);

                           /* END IF */

                           ir_expression *const r2339 = nequal(r2322, body.constant(0u));
                           ir_expression *const r233A = expr(ir_unop_b2i, r2339);
                           ir_expression *const r233B = expr(ir_unop_i2u, r233A);
                           body.emit(assign(r2324, bit_or(r2324, r233B), 0x01));


                        body.instructions = f2329_parent_instructions;
                        body.emit(f2329);

                        /* END IF */

                        body.emit(assign(r230C, r2326, 0x01));

                        body.emit(assign(r230D, r2325, 0x01));

                        body.emit(assign(r230E, r2324, 0x01));

                        body.emit(assign(r230B, body.constant(int(0)), 0x01));

                        body.emit(assign(r2311, less(r2324, body.constant(0u)), 0x01));


                     body.instructions = f2320_parent_instructions;
                     body.emit(f2320);

                     /* END IF */


                  body.instructions = f231D_parent_instructions;
                  body.emit(f231D);

                  /* END IF */


               body.instructions = f2313_parent_instructions;
               body.emit(f2313);

               /* END IF */

               /* IF CONDITION */
               ir_if *f233C = new(mem_ctx) ir_if(operand(r230F).val);
               exec_list *const f233C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f233C->then_instructions;

                  /* IF CONDITION */
                  ir_if *f233D = new(mem_ctx) ir_if(operand(r2311).val);
                  exec_list *const f233D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f233D->then_instructions;

                     ir_variable *const r233E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r233E, add(r230D, body.constant(1u)), 0x01));

                     ir_expression *const r233F = less(r233E, r230D);
                     ir_expression *const r2340 = expr(ir_unop_b2i, r233F);
                     ir_expression *const r2341 = expr(ir_unop_i2u, r2340);
                     body.emit(assign(r230C, add(r230C, r2341), 0x01));

                     ir_expression *const r2342 = equal(r230E, body.constant(0u));
                     ir_expression *const r2343 = expr(ir_unop_b2i, r2342);
                     ir_expression *const r2344 = expr(ir_unop_i2u, r2343);
                     ir_expression *const r2345 = add(r230E, r2344);
                     ir_expression *const r2346 = bit_and(r2345, body.constant(1u));
                     ir_expression *const r2347 = expr(ir_unop_bit_not, r2346);
                     body.emit(assign(r230D, bit_and(r233E, r2347), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f233D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2349 = bit_or(r230C, r230D);
                     ir_expression *const r234A = equal(r2349, body.constant(0u));
                     ir_if *f2348 = new(mem_ctx) ir_if(operand(r234A).val);
                     exec_list *const f2348_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2348->then_instructions;

                        body.emit(assign(r230B, body.constant(int(0)), 0x01));


                     body.instructions = f2348_parent_instructions;
                     body.emit(f2348);

                     /* END IF */


                  body.instructions = f233D_parent_instructions;
                  body.emit(f233D);

                  /* END IF */

                  ir_variable *const r234B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r234B);
                  ir_expression *const r234C = lshift(r21F4, body.constant(int(31)));
                  ir_expression *const r234D = expr(ir_unop_i2u, r230B);
                  ir_expression *const r234E = lshift(r234D, body.constant(int(20)));
                  ir_expression *const r234F = add(r234C, r234E);
                  body.emit(assign(r234B, add(r234F, r230C), 0x02));

                  body.emit(assign(r234B, r230D, 0x01));

                  body.emit(assign(r2310, r234B, 0x03));

                  body.emit(assign(r230F, body.constant(false), 0x01));


               body.instructions = f233C_parent_instructions;
               body.emit(f233C);

               /* END IF */

               body.emit(assign(r21F8, r2310, 0x03));

               body.emit(assign(r21F7, body.constant(false), 0x01));


            body.instructions = f22BC_parent_instructions;
            body.emit(f22BC);

            /* END IF */


         body.instructions = f22B5_parent_instructions;
         body.emit(f22B5);

         /* END IF */

         body.emit(assign(r21F3, r21F8, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f21F5->else_instructions;

         ir_variable *const r2350 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r2350, r21F4, 0x01));

         ir_variable *const r2351 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2352 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2352);
         ir_variable *const r2353 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r2353);
         ir_variable *const r2354 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r2354);
         ir_variable *const r2355 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r2355);
         ir_variable *const r2356 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r2356);
         ir_variable *const r2357 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r2357);
         ir_variable *const r2358 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r2358);
         ir_variable *const r2359 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2359);
         ir_variable *const r235A = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r235A, body.constant(0u), 0x01));

         ir_variable *const r235B = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r235C = rshift(swizzle_y(r21BF), body.constant(int(20)));
         ir_expression *const r235D = bit_and(r235C, body.constant(2047u));
         body.emit(assign(r235B, expr(ir_unop_u2i, r235D), 0x01));

         body.emit(assign(r2354, r235B, 0x01));

         body.emit(assign(r2353, body.constant(int(1023)), 0x01));

         body.emit(assign(r2352, add(r235B, body.constant(int(-1023))), 0x01));

         ir_variable *const r235E = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r235E, lshift(swizzle_x(r21BF), body.constant(int(10))), 0x01));

         ir_variable *const r235F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r2360 = bit_and(swizzle_y(r21BF), body.constant(1048575u));
         ir_expression *const r2361 = lshift(r2360, body.constant(int(10)));
         ir_expression *const r2362 = rshift(swizzle_x(r21BF), body.constant(int(22)));
         body.emit(assign(r235F, bit_or(r2361, r2362), 0x01));

         body.emit(assign(r2357, r235F, 0x01));

         body.emit(assign(r2358, r235E, 0x01));

         ir_variable *const r2363 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r2363, body.constant(0u), 0x01));

         ir_variable *const r2364 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r2364, body.constant(0u), 0x01));

         body.emit(assign(r2355, r2364, 0x01));

         body.emit(assign(r2356, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r2366 = less(body.constant(int(0)), r2352);
         ir_if *f2365 = new(mem_ctx) ir_if(operand(r2366).val);
         exec_list *const f2365_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2365->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2368 = equal(r235B, body.constant(int(2047)));
            ir_if *f2367 = new(mem_ctx) ir_if(operand(r2368).val);
            exec_list *const f2367_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2367->then_instructions;

               /* IF CONDITION */
               ir_expression *const r236A = bit_or(r235F, r235E);
               ir_expression *const r236B = nequal(r236A, body.constant(0u));
               ir_if *f2369 = new(mem_ctx) ir_if(operand(r236B).val);
               exec_list *const f2369_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2369->then_instructions;

                  ir_variable *const r236C = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r236C, swizzle_x(r21BF), 0x01));

                  ir_variable *const r236D = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r236D, body.constant(0u), 0x01));

                  ir_variable *const r236E = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r236C, bit_or(swizzle_y(r21BF), body.constant(524288u)), 0x02));

                  body.emit(assign(r236D, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2370 = lshift(swizzle_y(r21BF), body.constant(int(1)));
                  ir_expression *const r2371 = lequal(body.constant(4292870144u), r2370);
                  ir_expression *const r2372 = nequal(swizzle_x(r21BF), body.constant(0u));
                  ir_expression *const r2373 = bit_and(swizzle_y(r21BF), body.constant(1048575u));
                  ir_expression *const r2374 = nequal(r2373, body.constant(0u));
                  ir_expression *const r2375 = logic_or(r2372, r2374);
                  ir_expression *const r2376 = logic_and(r2371, r2375);
                  ir_if *f236F = new(mem_ctx) ir_if(operand(r2376).val);
                  exec_list *const f236F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f236F->then_instructions;

                     body.emit(assign(r236E, r236C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f236F->else_instructions;

                     body.emit(assign(r236E, r236D, 0x03));


                  body.instructions = f236F_parent_instructions;
                  body.emit(f236F);

                  /* END IF */

                  body.emit(assign(r2351, r236E, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2369->else_instructions;

                  body.emit(assign(r2351, r21BF, 0x03));


               body.instructions = f2369_parent_instructions;
               body.emit(f2369);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2367->else_instructions;

               body.emit(assign(r2355, body.constant(1073741824u), 0x01));

               ir_variable *const r2377 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2377);
               ir_variable *const r2378 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2378);
               ir_variable *const r2379 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r237A = neg(r2352);
               body.emit(assign(r2379, bit_and(r237A, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r237C = equal(r2352, body.constant(int(0)));
               ir_if *f237B = new(mem_ctx) ir_if(operand(r237C).val);
               exec_list *const f237B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f237B->then_instructions;

                  body.emit(assign(r2377, body.constant(0u), 0x01));

                  body.emit(assign(r2378, r2355, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f237B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r237E = less(r2352, body.constant(int(32)));
                  ir_if *f237D = new(mem_ctx) ir_if(operand(r237E).val);
                  exec_list *const f237D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f237D->then_instructions;

                     ir_expression *const r237F = lshift(body.constant(1073741824u), r2379);
                     ir_expression *const r2380 = bit_or(r237F, body.constant(0u));
                     body.emit(assign(r2377, bit_or(r2380, body.constant(0u)), 0x01));

                     body.emit(assign(r2378, rshift(body.constant(1073741824u), r2352), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f237D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2382 = equal(r2352, body.constant(int(32)));
                     ir_if *f2381 = new(mem_ctx) ir_if(operand(r2382).val);
                     exec_list *const f2381_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2381->then_instructions;

                        body.emit(assign(r2377, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2381->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2384 = less(r2352, body.constant(int(64)));
                        ir_if *f2383 = new(mem_ctx) ir_if(operand(r2384).val);
                        exec_list *const f2383_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2383->then_instructions;

                           ir_expression *const r2385 = bit_and(r2352, body.constant(int(31)));
                           ir_expression *const r2386 = rshift(body.constant(1073741824u), r2385);
                           ir_expression *const r2387 = lshift(body.constant(1073741824u), r2379);
                           ir_expression *const r2388 = bit_or(r2387, body.constant(0u));
                           ir_expression *const r2389 = nequal(r2388, body.constant(0u));
                           ir_expression *const r238A = expr(ir_unop_b2i, r2389);
                           ir_expression *const r238B = expr(ir_unop_i2u, r238A);
                           body.emit(assign(r2377, bit_or(r2386, r238B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2383->else_instructions;

                           body.emit(assign(r2377, body.constant(1u), 0x01));


                        body.instructions = f2383_parent_instructions;
                        body.emit(f2383);

                        /* END IF */


                     body.instructions = f2381_parent_instructions;
                     body.emit(f2381);

                     /* END IF */

                     body.emit(assign(r2378, body.constant(0u), 0x01));


                  body.instructions = f237D_parent_instructions;
                  body.emit(f237D);

                  /* END IF */


               body.instructions = f237B_parent_instructions;
               body.emit(f237B);

               /* END IF */

               body.emit(assign(r2355, r2378, 0x01));

               body.emit(assign(r2356, r2377, 0x01));

               body.emit(assign(r2357, bit_or(r235F, body.constant(1073741824u)), 0x01));

               ir_variable *const r238C = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r238D = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r238D, sub(r235E, r2377), 0x01));

               ir_expression *const r238E = sub(r2357, r2378);
               ir_expression *const r238F = less(r235E, r2377);
               ir_expression *const r2390 = expr(ir_unop_b2i, r238F);
               ir_expression *const r2391 = expr(ir_unop_i2u, r2390);
               body.emit(assign(r238C, sub(r238E, r2391), 0x01));

               body.emit(assign(r2359, add(r235B, body.constant(int(-1))), 0x01));

               ir_variable *const r2392 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2392, add(r2359, body.constant(int(-10))), 0x01));

               ir_variable *const r2393 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2393, r238C, 0x01));

               ir_variable *const r2394 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2394, r238D, 0x01));

               ir_variable *const r2395 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2395);
               ir_variable *const r2396 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2396);
               /* IF CONDITION */
               ir_expression *const r2398 = equal(r238C, body.constant(0u));
               ir_if *f2397 = new(mem_ctx) ir_if(operand(r2398).val);
               exec_list *const f2397_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2397->then_instructions;

                  body.emit(assign(r2393, r238D, 0x01));

                  body.emit(assign(r2394, body.constant(0u), 0x01));

                  body.emit(assign(r2392, add(r2392, body.constant(int(-32))), 0x01));


               body.instructions = f2397_parent_instructions;
               body.emit(f2397);

               /* END IF */

               ir_variable *const r2399 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2399, r2393, 0x01));

               ir_variable *const r239A = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r239B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r239B);
               /* IF CONDITION */
               ir_expression *const r239D = equal(r2393, body.constant(0u));
               ir_if *f239C = new(mem_ctx) ir_if(operand(r239D).val);
               exec_list *const f239C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f239C->then_instructions;

                  body.emit(assign(r239A, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f239C->else_instructions;

                  body.emit(assign(r239B, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r239F = bit_and(r2393, body.constant(4294901760u));
                  ir_expression *const r23A0 = equal(r239F, body.constant(0u));
                  ir_if *f239E = new(mem_ctx) ir_if(operand(r23A0).val);
                  exec_list *const f239E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f239E->then_instructions;

                     body.emit(assign(r239B, body.constant(int(16)), 0x01));

                     body.emit(assign(r2399, lshift(r2393, body.constant(int(16))), 0x01));


                  body.instructions = f239E_parent_instructions;
                  body.emit(f239E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23A2 = bit_and(r2399, body.constant(4278190080u));
                  ir_expression *const r23A3 = equal(r23A2, body.constant(0u));
                  ir_if *f23A1 = new(mem_ctx) ir_if(operand(r23A3).val);
                  exec_list *const f23A1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23A1->then_instructions;

                     body.emit(assign(r239B, add(r239B, body.constant(int(8))), 0x01));

                     body.emit(assign(r2399, lshift(r2399, body.constant(int(8))), 0x01));


                  body.instructions = f23A1_parent_instructions;
                  body.emit(f23A1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23A5 = bit_and(r2399, body.constant(4026531840u));
                  ir_expression *const r23A6 = equal(r23A5, body.constant(0u));
                  ir_if *f23A4 = new(mem_ctx) ir_if(operand(r23A6).val);
                  exec_list *const f23A4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23A4->then_instructions;

                     body.emit(assign(r239B, add(r239B, body.constant(int(4))), 0x01));

                     body.emit(assign(r2399, lshift(r2399, body.constant(int(4))), 0x01));


                  body.instructions = f23A4_parent_instructions;
                  body.emit(f23A4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23A8 = bit_and(r2399, body.constant(3221225472u));
                  ir_expression *const r23A9 = equal(r23A8, body.constant(0u));
                  ir_if *f23A7 = new(mem_ctx) ir_if(operand(r23A9).val);
                  exec_list *const f23A7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23A7->then_instructions;

                     body.emit(assign(r239B, add(r239B, body.constant(int(2))), 0x01));

                     body.emit(assign(r2399, lshift(r2399, body.constant(int(2))), 0x01));


                  body.instructions = f23A7_parent_instructions;
                  body.emit(f23A7);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23AB = bit_and(r2399, body.constant(2147483648u));
                  ir_expression *const r23AC = equal(r23AB, body.constant(0u));
                  ir_if *f23AA = new(mem_ctx) ir_if(operand(r23AC).val);
                  exec_list *const f23AA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23AA->then_instructions;

                     body.emit(assign(r239B, add(r239B, body.constant(int(1))), 0x01));


                  body.instructions = f23AA_parent_instructions;
                  body.emit(f23AA);

                  /* END IF */

                  body.emit(assign(r239A, r239B, 0x01));


               body.instructions = f239C_parent_instructions;
               body.emit(f239C);

               /* END IF */

               body.emit(assign(r2396, add(r239A, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r23AE = lequal(body.constant(int(0)), r2396);
               ir_if *f23AD = new(mem_ctx) ir_if(operand(r23AE).val);
               exec_list *const f23AD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23AD->then_instructions;

                  body.emit(assign(r2395, body.constant(0u), 0x01));

                  ir_variable *const r23AF = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r23AF, lshift(r2394, r2396), 0x01));

                  ir_variable *const r23B0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r23B2 = equal(r2396, body.constant(int(0)));
                  ir_if *f23B1 = new(mem_ctx) ir_if(operand(r23B2).val);
                  exec_list *const f23B1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23B1->then_instructions;

                     body.emit(assign(r23B0, r2393, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23B1->else_instructions;

                     ir_expression *const r23B3 = lshift(r2393, r2396);
                     ir_expression *const r23B4 = neg(r2396);
                     ir_expression *const r23B5 = bit_and(r23B4, body.constant(int(31)));
                     ir_expression *const r23B6 = rshift(r2394, r23B5);
                     body.emit(assign(r23B0, bit_or(r23B3, r23B6), 0x01));


                  body.instructions = f23B1_parent_instructions;
                  body.emit(f23B1);

                  /* END IF */

                  body.emit(assign(r2393, r23B0, 0x01));

                  body.emit(assign(r2394, r23AF, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23AD->else_instructions;

                  ir_variable *const r23B7 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r23B7, body.constant(0u), 0x01));

                  ir_variable *const r23B8 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r23B8, neg(r2396), 0x01));

                  ir_variable *const r23B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r23B9);
                  ir_variable *const r23BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r23BA);
                  ir_variable *const r23BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r23BB);
                  ir_variable *const r23BC = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r23BD = neg(r23B8);
                  body.emit(assign(r23BC, bit_and(r23BD, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r23BF = equal(r23B8, body.constant(int(0)));
                  ir_if *f23BE = new(mem_ctx) ir_if(operand(r23BF).val);
                  exec_list *const f23BE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23BE->then_instructions;

                     body.emit(assign(r23B9, r23B7, 0x01));

                     body.emit(assign(r23BA, r2394, 0x01));

                     body.emit(assign(r23BB, r2393, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23BE->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r23C1 = less(r23B8, body.constant(int(32)));
                     ir_if *f23C0 = new(mem_ctx) ir_if(operand(r23C1).val);
                     exec_list *const f23C0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f23C0->then_instructions;

                        body.emit(assign(r23B9, lshift(r2394, r23BC), 0x01));

                        ir_expression *const r23C2 = lshift(r2393, r23BC);
                        ir_expression *const r23C3 = rshift(r2394, r23B8);
                        body.emit(assign(r23BA, bit_or(r23C2, r23C3), 0x01));

                        body.emit(assign(r23BB, rshift(r2393, r23B8), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f23C0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r23C5 = equal(r23B8, body.constant(int(32)));
                        ir_if *f23C4 = new(mem_ctx) ir_if(operand(r23C5).val);
                        exec_list *const f23C4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f23C4->then_instructions;

                           body.emit(assign(r23B9, r2394, 0x01));

                           body.emit(assign(r23BA, r2393, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f23C4->else_instructions;

                           body.emit(assign(r23B7, bit_or(body.constant(0u), r2394), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r23C7 = less(r23B8, body.constant(int(64)));
                           ir_if *f23C6 = new(mem_ctx) ir_if(operand(r23C7).val);
                           exec_list *const f23C6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f23C6->then_instructions;

                              body.emit(assign(r23B9, lshift(r2393, r23BC), 0x01));

                              ir_expression *const r23C8 = bit_and(r23B8, body.constant(int(31)));
                              body.emit(assign(r23BA, rshift(r2393, r23C8), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f23C6->else_instructions;

                              ir_variable *const r23C9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r23CB = equal(r23B8, body.constant(int(64)));
                              ir_if *f23CA = new(mem_ctx) ir_if(operand(r23CB).val);
                              exec_list *const f23CA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f23CA->then_instructions;

                                 body.emit(assign(r23C9, r2393, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f23CA->else_instructions;

                                 ir_expression *const r23CC = nequal(r2393, body.constant(0u));
                                 ir_expression *const r23CD = expr(ir_unop_b2i, r23CC);
                                 body.emit(assign(r23C9, expr(ir_unop_i2u, r23CD), 0x01));


                              body.instructions = f23CA_parent_instructions;
                              body.emit(f23CA);

                              /* END IF */

                              body.emit(assign(r23B9, r23C9, 0x01));

                              body.emit(assign(r23BA, body.constant(0u), 0x01));


                           body.instructions = f23C6_parent_instructions;
                           body.emit(f23C6);

                           /* END IF */


                        body.instructions = f23C4_parent_instructions;
                        body.emit(f23C4);

                        /* END IF */

                        body.emit(assign(r23BB, body.constant(0u), 0x01));


                     body.instructions = f23C0_parent_instructions;
                     body.emit(f23C0);

                     /* END IF */

                     ir_expression *const r23CE = nequal(r23B7, body.constant(0u));
                     ir_expression *const r23CF = expr(ir_unop_b2i, r23CE);
                     ir_expression *const r23D0 = expr(ir_unop_i2u, r23CF);
                     body.emit(assign(r23B9, bit_or(r23B9, r23D0), 0x01));


                  body.instructions = f23BE_parent_instructions;
                  body.emit(f23BE);

                  /* END IF */

                  body.emit(assign(r2393, r23BB, 0x01));

                  body.emit(assign(r2394, r23BA, 0x01));

                  body.emit(assign(r2395, r23B9, 0x01));


               body.instructions = f23AD_parent_instructions;
               body.emit(f23AD);

               /* END IF */

               body.emit(assign(r2392, sub(r2392, r2396), 0x01));

               ir_variable *const r23D1 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r23D1, r2392, 0x01));

               ir_variable *const r23D2 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r23D2, r2393, 0x01));

               ir_variable *const r23D3 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r23D3, r2394, 0x01));

               ir_variable *const r23D4 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r23D4, r2395, 0x01));

               ir_variable *const r23D5 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r23D5, body.constant(true), 0x01));

               ir_variable *const r23D6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r23D7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r23D7);
               ir_expression *const r23D8 = expr(ir_unop_u2i, r2395);
               body.emit(assign(r23D7, less(r23D8, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r23DA = lequal(body.constant(int(2045)), r2392);
               ir_if *f23D9 = new(mem_ctx) ir_if(operand(r23DA).val);
               exec_list *const f23D9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23D9->then_instructions;

                  ir_variable *const r23DB = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r23DD = less(body.constant(int(2045)), r2392);
                  ir_if *f23DC = new(mem_ctx) ir_if(operand(r23DD).val);
                  exec_list *const f23DC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23DC->then_instructions;

                     body.emit(assign(r23DB, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23DC->else_instructions;

                     ir_variable *const r23DE = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r23E0 = equal(r2392, body.constant(int(2045)));
                     ir_if *f23DF = new(mem_ctx) ir_if(operand(r23E0).val);
                     exec_list *const f23DF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f23DF->then_instructions;

                        ir_expression *const r23E1 = equal(body.constant(2097151u), r2393);
                        ir_expression *const r23E2 = equal(body.constant(4294967295u), r2394);
                        body.emit(assign(r23DE, logic_and(r23E1, r23E2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f23DF->else_instructions;

                        body.emit(assign(r23DE, body.constant(false), 0x01));


                     body.instructions = f23DF_parent_instructions;
                     body.emit(f23DF);

                     /* END IF */

                     body.emit(assign(r23DB, logic_and(r23DE, r23D7), 0x01));


                  body.instructions = f23DC_parent_instructions;
                  body.emit(f23DC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f23E3 = new(mem_ctx) ir_if(operand(r23DB).val);
                  exec_list *const f23E3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23E3->then_instructions;

                     ir_variable *const r23E4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r23E4);
                     ir_expression *const r23E5 = lshift(r21F4, body.constant(int(31)));
                     body.emit(assign(r23E4, add(r23E5, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r23E4, body.constant(0u), 0x01));

                     body.emit(assign(r23D6, r23E4, 0x03));

                     body.emit(assign(r23D5, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23E3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r23E7 = less(r2392, body.constant(int(0)));
                     ir_if *f23E6 = new(mem_ctx) ir_if(operand(r23E7).val);
                     exec_list *const f23E6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f23E6->then_instructions;

                        ir_variable *const r23E8 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r23E8, r2395, 0x01));

                        ir_variable *const r23E9 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r23E9, neg(r2392), 0x01));

                        ir_variable *const r23EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r23EA);
                        ir_variable *const r23EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r23EB);
                        ir_variable *const r23EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r23EC);
                        ir_variable *const r23ED = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r23EE = neg(r23E9);
                        body.emit(assign(r23ED, bit_and(r23EE, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r23F0 = equal(r23E9, body.constant(int(0)));
                        ir_if *f23EF = new(mem_ctx) ir_if(operand(r23F0).val);
                        exec_list *const f23EF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f23EF->then_instructions;

                           body.emit(assign(r23EA, r2395, 0x01));

                           body.emit(assign(r23EB, r2394, 0x01));

                           body.emit(assign(r23EC, r2393, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f23EF->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r23F2 = less(r23E9, body.constant(int(32)));
                           ir_if *f23F1 = new(mem_ctx) ir_if(operand(r23F2).val);
                           exec_list *const f23F1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f23F1->then_instructions;

                              body.emit(assign(r23EA, lshift(r2394, r23ED), 0x01));

                              ir_expression *const r23F3 = lshift(r2393, r23ED);
                              ir_expression *const r23F4 = rshift(r2394, r23E9);
                              body.emit(assign(r23EB, bit_or(r23F3, r23F4), 0x01));

                              body.emit(assign(r23EC, rshift(r2393, r23E9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f23F1->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r23F6 = equal(r23E9, body.constant(int(32)));
                              ir_if *f23F5 = new(mem_ctx) ir_if(operand(r23F6).val);
                              exec_list *const f23F5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f23F5->then_instructions;

                                 body.emit(assign(r23EA, r2394, 0x01));

                                 body.emit(assign(r23EB, r2393, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f23F5->else_instructions;

                                 body.emit(assign(r23E8, bit_or(r2395, r2394), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r23F8 = less(r23E9, body.constant(int(64)));
                                 ir_if *f23F7 = new(mem_ctx) ir_if(operand(r23F8).val);
                                 exec_list *const f23F7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f23F7->then_instructions;

                                    body.emit(assign(r23EA, lshift(r2393, r23ED), 0x01));

                                    ir_expression *const r23F9 = bit_and(r23E9, body.constant(int(31)));
                                    body.emit(assign(r23EB, rshift(r2393, r23F9), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f23F7->else_instructions;

                                    ir_variable *const r23FA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r23FC = equal(r23E9, body.constant(int(64)));
                                    ir_if *f23FB = new(mem_ctx) ir_if(operand(r23FC).val);
                                    exec_list *const f23FB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f23FB->then_instructions;

                                       body.emit(assign(r23FA, r2393, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f23FB->else_instructions;

                                       ir_expression *const r23FD = nequal(r2393, body.constant(0u));
                                       ir_expression *const r23FE = expr(ir_unop_b2i, r23FD);
                                       body.emit(assign(r23FA, expr(ir_unop_i2u, r23FE), 0x01));


                                    body.instructions = f23FB_parent_instructions;
                                    body.emit(f23FB);

                                    /* END IF */

                                    body.emit(assign(r23EA, r23FA, 0x01));

                                    body.emit(assign(r23EB, body.constant(0u), 0x01));


                                 body.instructions = f23F7_parent_instructions;
                                 body.emit(f23F7);

                                 /* END IF */


                              body.instructions = f23F5_parent_instructions;
                              body.emit(f23F5);

                              /* END IF */

                              body.emit(assign(r23EC, body.constant(0u), 0x01));


                           body.instructions = f23F1_parent_instructions;
                           body.emit(f23F1);

                           /* END IF */

                           ir_expression *const r23FF = nequal(r23E8, body.constant(0u));
                           ir_expression *const r2400 = expr(ir_unop_b2i, r23FF);
                           ir_expression *const r2401 = expr(ir_unop_i2u, r2400);
                           body.emit(assign(r23EA, bit_or(r23EA, r2401), 0x01));


                        body.instructions = f23EF_parent_instructions;
                        body.emit(f23EF);

                        /* END IF */

                        body.emit(assign(r23D2, r23EC, 0x01));

                        body.emit(assign(r23D3, r23EB, 0x01));

                        body.emit(assign(r23D4, r23EA, 0x01));

                        body.emit(assign(r23D1, body.constant(int(0)), 0x01));

                        body.emit(assign(r23D7, less(r23EA, body.constant(0u)), 0x01));


                     body.instructions = f23E6_parent_instructions;
                     body.emit(f23E6);

                     /* END IF */


                  body.instructions = f23E3_parent_instructions;
                  body.emit(f23E3);

                  /* END IF */


               body.instructions = f23D9_parent_instructions;
               body.emit(f23D9);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2402 = new(mem_ctx) ir_if(operand(r23D5).val);
               exec_list *const f2402_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2402->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2403 = new(mem_ctx) ir_if(operand(r23D7).val);
                  exec_list *const f2403_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2403->then_instructions;

                     ir_variable *const r2404 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2404, add(r23D3, body.constant(1u)), 0x01));

                     ir_expression *const r2405 = less(r2404, r23D3);
                     ir_expression *const r2406 = expr(ir_unop_b2i, r2405);
                     ir_expression *const r2407 = expr(ir_unop_i2u, r2406);
                     body.emit(assign(r23D2, add(r23D2, r2407), 0x01));

                     ir_expression *const r2408 = equal(r23D4, body.constant(0u));
                     ir_expression *const r2409 = expr(ir_unop_b2i, r2408);
                     ir_expression *const r240A = expr(ir_unop_i2u, r2409);
                     ir_expression *const r240B = add(r23D4, r240A);
                     ir_expression *const r240C = bit_and(r240B, body.constant(1u));
                     ir_expression *const r240D = expr(ir_unop_bit_not, r240C);
                     body.emit(assign(r23D3, bit_and(r2404, r240D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2403->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r240F = bit_or(r23D2, r23D3);
                     ir_expression *const r2410 = equal(r240F, body.constant(0u));
                     ir_if *f240E = new(mem_ctx) ir_if(operand(r2410).val);
                     exec_list *const f240E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f240E->then_instructions;

                        body.emit(assign(r23D1, body.constant(int(0)), 0x01));


                     body.instructions = f240E_parent_instructions;
                     body.emit(f240E);

                     /* END IF */


                  body.instructions = f2403_parent_instructions;
                  body.emit(f2403);

                  /* END IF */

                  ir_variable *const r2411 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2411);
                  ir_expression *const r2412 = lshift(r21F4, body.constant(int(31)));
                  ir_expression *const r2413 = expr(ir_unop_i2u, r23D1);
                  ir_expression *const r2414 = lshift(r2413, body.constant(int(20)));
                  ir_expression *const r2415 = add(r2412, r2414);
                  body.emit(assign(r2411, add(r2415, r23D2), 0x02));

                  body.emit(assign(r2411, r23D3, 0x01));

                  body.emit(assign(r23D6, r2411, 0x03));

                  body.emit(assign(r23D5, body.constant(false), 0x01));


               body.instructions = f2402_parent_instructions;
               body.emit(f2402);

               /* END IF */

               body.emit(assign(r2351, r23D6, 0x03));


            body.instructions = f2367_parent_instructions;
            body.emit(f2367);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2365->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2417 = less(r2352, body.constant(int(0)));
            ir_if *f2416 = new(mem_ctx) ir_if(operand(r2417).val);
            exec_list *const f2416_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2416->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2419 = equal(r235B, body.constant(int(0)));
               ir_if *f2418 = new(mem_ctx) ir_if(operand(r2419).val);
               exec_list *const f2418_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2418->then_instructions;

                  body.emit(assign(r2352, add(r2352, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2418->else_instructions;

                  body.emit(assign(r2357, bit_or(r2357, body.constant(1073741824u)), 0x01));


               body.instructions = f2418_parent_instructions;
               body.emit(f2418);

               /* END IF */

               ir_variable *const r241A = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r241A, neg(r2352), 0x01));

               ir_variable *const r241B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r241B);
               ir_variable *const r241C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r241C);
               ir_variable *const r241D = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r241E = neg(r241A);
               body.emit(assign(r241D, bit_and(r241E, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2420 = equal(r241A, body.constant(int(0)));
               ir_if *f241F = new(mem_ctx) ir_if(operand(r2420).val);
               exec_list *const f241F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f241F->then_instructions;

                  body.emit(assign(r241B, r235E, 0x01));

                  body.emit(assign(r241C, r2357, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f241F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2422 = less(r241A, body.constant(int(32)));
                  ir_if *f2421 = new(mem_ctx) ir_if(operand(r2422).val);
                  exec_list *const f2421_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2421->then_instructions;

                     ir_expression *const r2423 = lshift(r2357, r241D);
                     ir_expression *const r2424 = rshift(r235E, r241A);
                     ir_expression *const r2425 = bit_or(r2423, r2424);
                     ir_expression *const r2426 = lshift(r235E, r241D);
                     ir_expression *const r2427 = nequal(r2426, body.constant(0u));
                     ir_expression *const r2428 = expr(ir_unop_b2i, r2427);
                     ir_expression *const r2429 = expr(ir_unop_i2u, r2428);
                     body.emit(assign(r241B, bit_or(r2425, r2429), 0x01));

                     body.emit(assign(r241C, rshift(r2357, r241A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2421->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r242B = equal(r241A, body.constant(int(32)));
                     ir_if *f242A = new(mem_ctx) ir_if(operand(r242B).val);
                     exec_list *const f242A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f242A->then_instructions;

                        ir_expression *const r242C = nequal(r235E, body.constant(0u));
                        ir_expression *const r242D = expr(ir_unop_b2i, r242C);
                        ir_expression *const r242E = expr(ir_unop_i2u, r242D);
                        body.emit(assign(r241B, bit_or(r2357, r242E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f242A->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2430 = less(r241A, body.constant(int(64)));
                        ir_if *f242F = new(mem_ctx) ir_if(operand(r2430).val);
                        exec_list *const f242F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f242F->then_instructions;

                           ir_expression *const r2431 = bit_and(r241A, body.constant(int(31)));
                           ir_expression *const r2432 = rshift(r2357, r2431);
                           ir_expression *const r2433 = lshift(r2357, r241D);
                           ir_expression *const r2434 = bit_or(r2433, r235E);
                           ir_expression *const r2435 = nequal(r2434, body.constant(0u));
                           ir_expression *const r2436 = expr(ir_unop_b2i, r2435);
                           ir_expression *const r2437 = expr(ir_unop_i2u, r2436);
                           body.emit(assign(r241B, bit_or(r2432, r2437), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f242F->else_instructions;

                           ir_expression *const r2438 = bit_or(r2357, r235E);
                           ir_expression *const r2439 = nequal(r2438, body.constant(0u));
                           ir_expression *const r243A = expr(ir_unop_b2i, r2439);
                           body.emit(assign(r241B, expr(ir_unop_i2u, r243A), 0x01));


                        body.instructions = f242F_parent_instructions;
                        body.emit(f242F);

                        /* END IF */


                     body.instructions = f242A_parent_instructions;
                     body.emit(f242A);

                     /* END IF */

                     body.emit(assign(r241C, body.constant(0u), 0x01));


                  body.instructions = f2421_parent_instructions;
                  body.emit(f2421);

                  /* END IF */


               body.instructions = f241F_parent_instructions;
               body.emit(f241F);

               /* END IF */

               body.emit(assign(r2357, r241C, 0x01));

               body.emit(assign(r2358, r241B, 0x01));

               body.emit(assign(r2355, bit_or(r2355, body.constant(1073741824u)), 0x01));

               ir_variable *const r243B = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r243C = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r243C, sub(r2356, r241B), 0x01));

               ir_expression *const r243D = sub(r2355, r241C);
               ir_expression *const r243E = less(r2356, r241B);
               ir_expression *const r243F = expr(ir_unop_b2i, r243E);
               ir_expression *const r2440 = expr(ir_unop_i2u, r243F);
               body.emit(assign(r243B, sub(r243D, r2440), 0x01));

               body.emit(assign(r2350, bit_xor(r21F4, body.constant(1u)), 0x01));

               body.emit(assign(r2359, body.constant(int(1022)), 0x01));

               ir_variable *const r2441 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2441, body.constant(int(1012)), 0x01));

               ir_variable *const r2442 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2442, r243B, 0x01));

               ir_variable *const r2443 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2443, r243C, 0x01));

               ir_variable *const r2444 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2444);
               ir_variable *const r2445 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2445);
               /* IF CONDITION */
               ir_expression *const r2447 = equal(r243B, body.constant(0u));
               ir_if *f2446 = new(mem_ctx) ir_if(operand(r2447).val);
               exec_list *const f2446_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2446->then_instructions;

                  body.emit(assign(r2442, r243C, 0x01));

                  body.emit(assign(r2443, body.constant(0u), 0x01));

                  body.emit(assign(r2441, body.constant(int(980)), 0x01));


               body.instructions = f2446_parent_instructions;
               body.emit(f2446);

               /* END IF */

               ir_variable *const r2448 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2448, r2442, 0x01));

               ir_variable *const r2449 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r244A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r244A);
               /* IF CONDITION */
               ir_expression *const r244C = equal(r2442, body.constant(0u));
               ir_if *f244B = new(mem_ctx) ir_if(operand(r244C).val);
               exec_list *const f244B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f244B->then_instructions;

                  body.emit(assign(r2449, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f244B->else_instructions;

                  body.emit(assign(r244A, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r244E = bit_and(r2442, body.constant(4294901760u));
                  ir_expression *const r244F = equal(r244E, body.constant(0u));
                  ir_if *f244D = new(mem_ctx) ir_if(operand(r244F).val);
                  exec_list *const f244D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f244D->then_instructions;

                     body.emit(assign(r244A, body.constant(int(16)), 0x01));

                     body.emit(assign(r2448, lshift(r2442, body.constant(int(16))), 0x01));


                  body.instructions = f244D_parent_instructions;
                  body.emit(f244D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2451 = bit_and(r2448, body.constant(4278190080u));
                  ir_expression *const r2452 = equal(r2451, body.constant(0u));
                  ir_if *f2450 = new(mem_ctx) ir_if(operand(r2452).val);
                  exec_list *const f2450_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2450->then_instructions;

                     body.emit(assign(r244A, add(r244A, body.constant(int(8))), 0x01));

                     body.emit(assign(r2448, lshift(r2448, body.constant(int(8))), 0x01));


                  body.instructions = f2450_parent_instructions;
                  body.emit(f2450);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2454 = bit_and(r2448, body.constant(4026531840u));
                  ir_expression *const r2455 = equal(r2454, body.constant(0u));
                  ir_if *f2453 = new(mem_ctx) ir_if(operand(r2455).val);
                  exec_list *const f2453_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2453->then_instructions;

                     body.emit(assign(r244A, add(r244A, body.constant(int(4))), 0x01));

                     body.emit(assign(r2448, lshift(r2448, body.constant(int(4))), 0x01));


                  body.instructions = f2453_parent_instructions;
                  body.emit(f2453);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2457 = bit_and(r2448, body.constant(3221225472u));
                  ir_expression *const r2458 = equal(r2457, body.constant(0u));
                  ir_if *f2456 = new(mem_ctx) ir_if(operand(r2458).val);
                  exec_list *const f2456_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2456->then_instructions;

                     body.emit(assign(r244A, add(r244A, body.constant(int(2))), 0x01));

                     body.emit(assign(r2448, lshift(r2448, body.constant(int(2))), 0x01));


                  body.instructions = f2456_parent_instructions;
                  body.emit(f2456);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r245A = bit_and(r2448, body.constant(2147483648u));
                  ir_expression *const r245B = equal(r245A, body.constant(0u));
                  ir_if *f2459 = new(mem_ctx) ir_if(operand(r245B).val);
                  exec_list *const f2459_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2459->then_instructions;

                     body.emit(assign(r244A, add(r244A, body.constant(int(1))), 0x01));


                  body.instructions = f2459_parent_instructions;
                  body.emit(f2459);

                  /* END IF */

                  body.emit(assign(r2449, r244A, 0x01));


               body.instructions = f244B_parent_instructions;
               body.emit(f244B);

               /* END IF */

               body.emit(assign(r2445, add(r2449, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r245D = lequal(body.constant(int(0)), r2445);
               ir_if *f245C = new(mem_ctx) ir_if(operand(r245D).val);
               exec_list *const f245C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f245C->then_instructions;

                  body.emit(assign(r2444, body.constant(0u), 0x01));

                  ir_variable *const r245E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r245E, lshift(r2443, r2445), 0x01));

                  ir_variable *const r245F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2461 = equal(r2445, body.constant(int(0)));
                  ir_if *f2460 = new(mem_ctx) ir_if(operand(r2461).val);
                  exec_list *const f2460_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2460->then_instructions;

                     body.emit(assign(r245F, r2442, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2460->else_instructions;

                     ir_expression *const r2462 = lshift(r2442, r2445);
                     ir_expression *const r2463 = neg(r2445);
                     ir_expression *const r2464 = bit_and(r2463, body.constant(int(31)));
                     ir_expression *const r2465 = rshift(r2443, r2464);
                     body.emit(assign(r245F, bit_or(r2462, r2465), 0x01));


                  body.instructions = f2460_parent_instructions;
                  body.emit(f2460);

                  /* END IF */

                  body.emit(assign(r2442, r245F, 0x01));

                  body.emit(assign(r2443, r245E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f245C->else_instructions;

                  ir_variable *const r2466 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2466, body.constant(0u), 0x01));

                  ir_variable *const r2467 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2467, neg(r2445), 0x01));

                  ir_variable *const r2468 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2468);
                  ir_variable *const r2469 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2469);
                  ir_variable *const r246A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r246A);
                  ir_variable *const r246B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r246C = neg(r2467);
                  body.emit(assign(r246B, bit_and(r246C, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r246E = equal(r2467, body.constant(int(0)));
                  ir_if *f246D = new(mem_ctx) ir_if(operand(r246E).val);
                  exec_list *const f246D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f246D->then_instructions;

                     body.emit(assign(r2468, r2466, 0x01));

                     body.emit(assign(r2469, r2443, 0x01));

                     body.emit(assign(r246A, r2442, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f246D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2470 = less(r2467, body.constant(int(32)));
                     ir_if *f246F = new(mem_ctx) ir_if(operand(r2470).val);
                     exec_list *const f246F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f246F->then_instructions;

                        body.emit(assign(r2468, lshift(r2443, r246B), 0x01));

                        ir_expression *const r2471 = lshift(r2442, r246B);
                        ir_expression *const r2472 = rshift(r2443, r2467);
                        body.emit(assign(r2469, bit_or(r2471, r2472), 0x01));

                        body.emit(assign(r246A, rshift(r2442, r2467), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f246F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2474 = equal(r2467, body.constant(int(32)));
                        ir_if *f2473 = new(mem_ctx) ir_if(operand(r2474).val);
                        exec_list *const f2473_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2473->then_instructions;

                           body.emit(assign(r2468, r2443, 0x01));

                           body.emit(assign(r2469, r2442, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2473->else_instructions;

                           body.emit(assign(r2466, bit_or(body.constant(0u), r2443), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2476 = less(r2467, body.constant(int(64)));
                           ir_if *f2475 = new(mem_ctx) ir_if(operand(r2476).val);
                           exec_list *const f2475_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2475->then_instructions;

                              body.emit(assign(r2468, lshift(r2442, r246B), 0x01));

                              ir_expression *const r2477 = bit_and(r2467, body.constant(int(31)));
                              body.emit(assign(r2469, rshift(r2442, r2477), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2475->else_instructions;

                              ir_variable *const r2478 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r247A = equal(r2467, body.constant(int(64)));
                              ir_if *f2479 = new(mem_ctx) ir_if(operand(r247A).val);
                              exec_list *const f2479_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2479->then_instructions;

                                 body.emit(assign(r2478, r2442, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2479->else_instructions;

                                 ir_expression *const r247B = nequal(r2442, body.constant(0u));
                                 ir_expression *const r247C = expr(ir_unop_b2i, r247B);
                                 body.emit(assign(r2478, expr(ir_unop_i2u, r247C), 0x01));


                              body.instructions = f2479_parent_instructions;
                              body.emit(f2479);

                              /* END IF */

                              body.emit(assign(r2468, r2478, 0x01));

                              body.emit(assign(r2469, body.constant(0u), 0x01));


                           body.instructions = f2475_parent_instructions;
                           body.emit(f2475);

                           /* END IF */


                        body.instructions = f2473_parent_instructions;
                        body.emit(f2473);

                        /* END IF */

                        body.emit(assign(r246A, body.constant(0u), 0x01));


                     body.instructions = f246F_parent_instructions;
                     body.emit(f246F);

                     /* END IF */

                     ir_expression *const r247D = nequal(r2466, body.constant(0u));
                     ir_expression *const r247E = expr(ir_unop_b2i, r247D);
                     ir_expression *const r247F = expr(ir_unop_i2u, r247E);
                     body.emit(assign(r2468, bit_or(r2468, r247F), 0x01));


                  body.instructions = f246D_parent_instructions;
                  body.emit(f246D);

                  /* END IF */

                  body.emit(assign(r2442, r246A, 0x01));

                  body.emit(assign(r2443, r2469, 0x01));

                  body.emit(assign(r2444, r2468, 0x01));


               body.instructions = f245C_parent_instructions;
               body.emit(f245C);

               /* END IF */

               body.emit(assign(r2441, sub(r2441, r2445), 0x01));

               ir_variable *const r2480 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2480, r2441, 0x01));

               ir_variable *const r2481 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2481, r2442, 0x01));

               ir_variable *const r2482 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2482, r2443, 0x01));

               ir_variable *const r2483 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2483, r2444, 0x01));

               ir_variable *const r2484 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2484, body.constant(true), 0x01));

               ir_variable *const r2485 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2486 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2486);
               ir_expression *const r2487 = expr(ir_unop_u2i, r2444);
               body.emit(assign(r2486, less(r2487, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2489 = lequal(body.constant(int(2045)), r2441);
               ir_if *f2488 = new(mem_ctx) ir_if(operand(r2489).val);
               exec_list *const f2488_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2488->then_instructions;

                  ir_variable *const r248A = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r248C = less(body.constant(int(2045)), r2441);
                  ir_if *f248B = new(mem_ctx) ir_if(operand(r248C).val);
                  exec_list *const f248B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f248B->then_instructions;

                     body.emit(assign(r248A, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f248B->else_instructions;

                     ir_variable *const r248D = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r248F = equal(r2441, body.constant(int(2045)));
                     ir_if *f248E = new(mem_ctx) ir_if(operand(r248F).val);
                     exec_list *const f248E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f248E->then_instructions;

                        ir_expression *const r2490 = equal(body.constant(2097151u), r2442);
                        ir_expression *const r2491 = equal(body.constant(4294967295u), r2443);
                        body.emit(assign(r248D, logic_and(r2490, r2491), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f248E->else_instructions;

                        body.emit(assign(r248D, body.constant(false), 0x01));


                     body.instructions = f248E_parent_instructions;
                     body.emit(f248E);

                     /* END IF */

                     body.emit(assign(r248A, logic_and(r248D, r2486), 0x01));


                  body.instructions = f248B_parent_instructions;
                  body.emit(f248B);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2492 = new(mem_ctx) ir_if(operand(r248A).val);
                  exec_list *const f2492_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2492->then_instructions;

                     ir_variable *const r2493 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2493);
                     ir_expression *const r2494 = lshift(r2350, body.constant(int(31)));
                     body.emit(assign(r2493, add(r2494, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2493, body.constant(0u), 0x01));

                     body.emit(assign(r2485, r2493, 0x03));

                     body.emit(assign(r2484, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2492->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2496 = less(r2441, body.constant(int(0)));
                     ir_if *f2495 = new(mem_ctx) ir_if(operand(r2496).val);
                     exec_list *const f2495_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2495->then_instructions;

                        ir_variable *const r2497 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2497, r2444, 0x01));

                        ir_variable *const r2498 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2498, neg(r2441), 0x01));

                        ir_variable *const r2499 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2499);
                        ir_variable *const r249A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r249A);
                        ir_variable *const r249B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r249B);
                        ir_variable *const r249C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r249D = neg(r2498);
                        body.emit(assign(r249C, bit_and(r249D, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r249F = equal(r2498, body.constant(int(0)));
                        ir_if *f249E = new(mem_ctx) ir_if(operand(r249F).val);
                        exec_list *const f249E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f249E->then_instructions;

                           body.emit(assign(r2499, r2444, 0x01));

                           body.emit(assign(r249A, r2443, 0x01));

                           body.emit(assign(r249B, r2442, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f249E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r24A1 = less(r2498, body.constant(int(32)));
                           ir_if *f24A0 = new(mem_ctx) ir_if(operand(r24A1).val);
                           exec_list *const f24A0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f24A0->then_instructions;

                              body.emit(assign(r2499, lshift(r2443, r249C), 0x01));

                              ir_expression *const r24A2 = lshift(r2442, r249C);
                              ir_expression *const r24A3 = rshift(r2443, r2498);
                              body.emit(assign(r249A, bit_or(r24A2, r24A3), 0x01));

                              body.emit(assign(r249B, rshift(r2442, r2498), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f24A0->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r24A5 = equal(r2498, body.constant(int(32)));
                              ir_if *f24A4 = new(mem_ctx) ir_if(operand(r24A5).val);
                              exec_list *const f24A4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f24A4->then_instructions;

                                 body.emit(assign(r2499, r2443, 0x01));

                                 body.emit(assign(r249A, r2442, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f24A4->else_instructions;

                                 body.emit(assign(r2497, bit_or(r2444, r2443), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r24A7 = less(r2498, body.constant(int(64)));
                                 ir_if *f24A6 = new(mem_ctx) ir_if(operand(r24A7).val);
                                 exec_list *const f24A6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f24A6->then_instructions;

                                    body.emit(assign(r2499, lshift(r2442, r249C), 0x01));

                                    ir_expression *const r24A8 = bit_and(r2498, body.constant(int(31)));
                                    body.emit(assign(r249A, rshift(r2442, r24A8), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f24A6->else_instructions;

                                    ir_variable *const r24A9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r24AB = equal(r2498, body.constant(int(64)));
                                    ir_if *f24AA = new(mem_ctx) ir_if(operand(r24AB).val);
                                    exec_list *const f24AA_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f24AA->then_instructions;

                                       body.emit(assign(r24A9, r2442, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f24AA->else_instructions;

                                       ir_expression *const r24AC = nequal(r2442, body.constant(0u));
                                       ir_expression *const r24AD = expr(ir_unop_b2i, r24AC);
                                       body.emit(assign(r24A9, expr(ir_unop_i2u, r24AD), 0x01));


                                    body.instructions = f24AA_parent_instructions;
                                    body.emit(f24AA);

                                    /* END IF */

                                    body.emit(assign(r2499, r24A9, 0x01));

                                    body.emit(assign(r249A, body.constant(0u), 0x01));


                                 body.instructions = f24A6_parent_instructions;
                                 body.emit(f24A6);

                                 /* END IF */


                              body.instructions = f24A4_parent_instructions;
                              body.emit(f24A4);

                              /* END IF */

                              body.emit(assign(r249B, body.constant(0u), 0x01));


                           body.instructions = f24A0_parent_instructions;
                           body.emit(f24A0);

                           /* END IF */

                           ir_expression *const r24AE = nequal(r2497, body.constant(0u));
                           ir_expression *const r24AF = expr(ir_unop_b2i, r24AE);
                           ir_expression *const r24B0 = expr(ir_unop_i2u, r24AF);
                           body.emit(assign(r2499, bit_or(r2499, r24B0), 0x01));


                        body.instructions = f249E_parent_instructions;
                        body.emit(f249E);

                        /* END IF */

                        body.emit(assign(r2481, r249B, 0x01));

                        body.emit(assign(r2482, r249A, 0x01));

                        body.emit(assign(r2483, r2499, 0x01));

                        body.emit(assign(r2480, body.constant(int(0)), 0x01));

                        body.emit(assign(r2486, less(r2499, body.constant(0u)), 0x01));


                     body.instructions = f2495_parent_instructions;
                     body.emit(f2495);

                     /* END IF */


                  body.instructions = f2492_parent_instructions;
                  body.emit(f2492);

                  /* END IF */


               body.instructions = f2488_parent_instructions;
               body.emit(f2488);

               /* END IF */

               /* IF CONDITION */
               ir_if *f24B1 = new(mem_ctx) ir_if(operand(r2484).val);
               exec_list *const f24B1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f24B1->then_instructions;

                  /* IF CONDITION */
                  ir_if *f24B2 = new(mem_ctx) ir_if(operand(r2486).val);
                  exec_list *const f24B2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24B2->then_instructions;

                     ir_variable *const r24B3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r24B3, add(r2482, body.constant(1u)), 0x01));

                     ir_expression *const r24B4 = less(r24B3, r2482);
                     ir_expression *const r24B5 = expr(ir_unop_b2i, r24B4);
                     ir_expression *const r24B6 = expr(ir_unop_i2u, r24B5);
                     body.emit(assign(r2481, add(r2481, r24B6), 0x01));

                     ir_expression *const r24B7 = equal(r2483, body.constant(0u));
                     ir_expression *const r24B8 = expr(ir_unop_b2i, r24B7);
                     ir_expression *const r24B9 = expr(ir_unop_i2u, r24B8);
                     ir_expression *const r24BA = add(r2483, r24B9);
                     ir_expression *const r24BB = bit_and(r24BA, body.constant(1u));
                     ir_expression *const r24BC = expr(ir_unop_bit_not, r24BB);
                     body.emit(assign(r2482, bit_and(r24B3, r24BC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24B2->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r24BE = bit_or(r2481, r2482);
                     ir_expression *const r24BF = equal(r24BE, body.constant(0u));
                     ir_if *f24BD = new(mem_ctx) ir_if(operand(r24BF).val);
                     exec_list *const f24BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24BD->then_instructions;

                        body.emit(assign(r2480, body.constant(int(0)), 0x01));


                     body.instructions = f24BD_parent_instructions;
                     body.emit(f24BD);

                     /* END IF */


                  body.instructions = f24B2_parent_instructions;
                  body.emit(f24B2);

                  /* END IF */

                  ir_variable *const r24C0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r24C0);
                  ir_expression *const r24C1 = lshift(r2350, body.constant(int(31)));
                  ir_expression *const r24C2 = expr(ir_unop_i2u, r2480);
                  ir_expression *const r24C3 = lshift(r24C2, body.constant(int(20)));
                  ir_expression *const r24C4 = add(r24C1, r24C3);
                  body.emit(assign(r24C0, add(r24C4, r2481), 0x02));

                  body.emit(assign(r24C0, r2482, 0x01));

                  body.emit(assign(r2485, r24C0, 0x03));

                  body.emit(assign(r2484, body.constant(false), 0x01));


               body.instructions = f24B1_parent_instructions;
               body.emit(f24B1);

               /* END IF */

               body.emit(assign(r2351, r2485, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2416->else_instructions;

               /* IF CONDITION */
               ir_expression *const r24C6 = equal(r235B, body.constant(int(2047)));
               ir_if *f24C5 = new(mem_ctx) ir_if(operand(r24C6).val);
               exec_list *const f24C5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f24C5->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r24C8 = bit_or(r2357, r2358);
                  ir_expression *const r24C9 = bit_or(r2355, r2356);
                  ir_expression *const r24CA = bit_or(r24C8, r24C9);
                  ir_expression *const r24CB = nequal(r24CA, body.constant(0u));
                  ir_if *f24C7 = new(mem_ctx) ir_if(operand(r24CB).val);
                  exec_list *const f24C7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24C7->then_instructions;

                     ir_variable *const r24CC = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r24CC, swizzle_x(r21BF), 0x01));

                     ir_variable *const r24CD = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r24CD, body.constant(0u), 0x01));

                     ir_variable *const r24CE = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r24CC, bit_or(swizzle_y(r21BF), body.constant(524288u)), 0x02));

                     body.emit(assign(r24CD, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r24D0 = lshift(swizzle_y(r21BF), body.constant(int(1)));
                     ir_expression *const r24D1 = lequal(body.constant(4292870144u), r24D0);
                     ir_expression *const r24D2 = nequal(swizzle_x(r21BF), body.constant(0u));
                     ir_expression *const r24D3 = bit_and(swizzle_y(r21BF), body.constant(1048575u));
                     ir_expression *const r24D4 = nequal(r24D3, body.constant(0u));
                     ir_expression *const r24D5 = logic_or(r24D2, r24D4);
                     ir_expression *const r24D6 = logic_and(r24D1, r24D5);
                     ir_if *f24CF = new(mem_ctx) ir_if(operand(r24D6).val);
                     exec_list *const f24CF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24CF->then_instructions;

                        body.emit(assign(r24CE, r24CC, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f24CF->else_instructions;

                        body.emit(assign(r24CE, r24CD, 0x03));


                     body.instructions = f24CF_parent_instructions;
                     body.emit(f24CF);

                     /* END IF */

                     body.emit(assign(r2351, r24CE, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24C7->else_instructions;

                     ir_constant_data r24D7_data;
                     memset(&r24D7_data, 0, sizeof(ir_constant_data));
                     r24D7_data.u[0] = 4294967295;
                     r24D7_data.u[1] = 4294967295;
                     ir_constant *const r24D7 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r24D7_data);
                     body.emit(assign(r2351, r24D7, 0x03));


                  body.instructions = f24C7_parent_instructions;
                  body.emit(f24C7);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f24C5->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r24D9 = equal(r235B, body.constant(int(0)));
                  ir_if *f24D8 = new(mem_ctx) ir_if(operand(r24D9).val);
                  exec_list *const f24D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24D8->then_instructions;

                     body.emit(assign(r2354, body.constant(int(1)), 0x01));

                     body.emit(assign(r2353, body.constant(int(1)), 0x01));


                  body.instructions = f24D8_parent_instructions;
                  body.emit(f24D8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r24DB = less(r2355, r2357);
                  ir_if *f24DA = new(mem_ctx) ir_if(operand(r24DB).val);
                  exec_list *const f24DA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24DA->then_instructions;

                     ir_variable *const r24DC = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r24DD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r24DD, sub(r2358, r2356), 0x01));

                     ir_expression *const r24DE = sub(r2357, r2355);
                     ir_expression *const r24DF = less(r2358, r2356);
                     ir_expression *const r24E0 = expr(ir_unop_b2i, r24DF);
                     ir_expression *const r24E1 = expr(ir_unop_i2u, r24E0);
                     body.emit(assign(r24DC, sub(r24DE, r24E1), 0x01));

                     body.emit(assign(r2359, add(r2354, body.constant(int(-1))), 0x01));

                     ir_variable *const r24E2 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r24E2, add(r2359, body.constant(int(-10))), 0x01));

                     ir_variable *const r24E3 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r24E3, r24DC, 0x01));

                     ir_variable *const r24E4 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r24E4, r24DD, 0x01));

                     ir_variable *const r24E5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r24E5);
                     ir_variable *const r24E6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r24E6);
                     /* IF CONDITION */
                     ir_expression *const r24E8 = equal(r24DC, body.constant(0u));
                     ir_if *f24E7 = new(mem_ctx) ir_if(operand(r24E8).val);
                     exec_list *const f24E7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24E7->then_instructions;

                        body.emit(assign(r24E3, r24DD, 0x01));

                        body.emit(assign(r24E4, body.constant(0u), 0x01));

                        body.emit(assign(r24E2, add(r24E2, body.constant(int(-32))), 0x01));


                     body.instructions = f24E7_parent_instructions;
                     body.emit(f24E7);

                     /* END IF */

                     ir_variable *const r24E9 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r24E9, r24E3, 0x01));

                     ir_variable *const r24EA = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r24EB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r24EB);
                     /* IF CONDITION */
                     ir_expression *const r24ED = equal(r24E3, body.constant(0u));
                     ir_if *f24EC = new(mem_ctx) ir_if(operand(r24ED).val);
                     exec_list *const f24EC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24EC->then_instructions;

                        body.emit(assign(r24EA, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f24EC->else_instructions;

                        body.emit(assign(r24EB, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r24EF = bit_and(r24E3, body.constant(4294901760u));
                        ir_expression *const r24F0 = equal(r24EF, body.constant(0u));
                        ir_if *f24EE = new(mem_ctx) ir_if(operand(r24F0).val);
                        exec_list *const f24EE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24EE->then_instructions;

                           body.emit(assign(r24EB, body.constant(int(16)), 0x01));

                           body.emit(assign(r24E9, lshift(r24E3, body.constant(int(16))), 0x01));


                        body.instructions = f24EE_parent_instructions;
                        body.emit(f24EE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r24F2 = bit_and(r24E9, body.constant(4278190080u));
                        ir_expression *const r24F3 = equal(r24F2, body.constant(0u));
                        ir_if *f24F1 = new(mem_ctx) ir_if(operand(r24F3).val);
                        exec_list *const f24F1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24F1->then_instructions;

                           body.emit(assign(r24EB, add(r24EB, body.constant(int(8))), 0x01));

                           body.emit(assign(r24E9, lshift(r24E9, body.constant(int(8))), 0x01));


                        body.instructions = f24F1_parent_instructions;
                        body.emit(f24F1);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r24F5 = bit_and(r24E9, body.constant(4026531840u));
                        ir_expression *const r24F6 = equal(r24F5, body.constant(0u));
                        ir_if *f24F4 = new(mem_ctx) ir_if(operand(r24F6).val);
                        exec_list *const f24F4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24F4->then_instructions;

                           body.emit(assign(r24EB, add(r24EB, body.constant(int(4))), 0x01));

                           body.emit(assign(r24E9, lshift(r24E9, body.constant(int(4))), 0x01));


                        body.instructions = f24F4_parent_instructions;
                        body.emit(f24F4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r24F8 = bit_and(r24E9, body.constant(3221225472u));
                        ir_expression *const r24F9 = equal(r24F8, body.constant(0u));
                        ir_if *f24F7 = new(mem_ctx) ir_if(operand(r24F9).val);
                        exec_list *const f24F7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24F7->then_instructions;

                           body.emit(assign(r24EB, add(r24EB, body.constant(int(2))), 0x01));

                           body.emit(assign(r24E9, lshift(r24E9, body.constant(int(2))), 0x01));


                        body.instructions = f24F7_parent_instructions;
                        body.emit(f24F7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r24FB = bit_and(r24E9, body.constant(2147483648u));
                        ir_expression *const r24FC = equal(r24FB, body.constant(0u));
                        ir_if *f24FA = new(mem_ctx) ir_if(operand(r24FC).val);
                        exec_list *const f24FA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24FA->then_instructions;

                           body.emit(assign(r24EB, add(r24EB, body.constant(int(1))), 0x01));


                        body.instructions = f24FA_parent_instructions;
                        body.emit(f24FA);

                        /* END IF */

                        body.emit(assign(r24EA, r24EB, 0x01));


                     body.instructions = f24EC_parent_instructions;
                     body.emit(f24EC);

                     /* END IF */

                     body.emit(assign(r24E6, add(r24EA, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r24FE = lequal(body.constant(int(0)), r24E6);
                     ir_if *f24FD = new(mem_ctx) ir_if(operand(r24FE).val);
                     exec_list *const f24FD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24FD->then_instructions;

                        body.emit(assign(r24E5, body.constant(0u), 0x01));

                        ir_variable *const r24FF = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r24FF, lshift(r24E4, r24E6), 0x01));

                        ir_variable *const r2500 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2502 = equal(r24E6, body.constant(int(0)));
                        ir_if *f2501 = new(mem_ctx) ir_if(operand(r2502).val);
                        exec_list *const f2501_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2501->then_instructions;

                           body.emit(assign(r2500, r24E3, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2501->else_instructions;

                           ir_expression *const r2503 = lshift(r24E3, r24E6);
                           ir_expression *const r2504 = neg(r24E6);
                           ir_expression *const r2505 = bit_and(r2504, body.constant(int(31)));
                           ir_expression *const r2506 = rshift(r24E4, r2505);
                           body.emit(assign(r2500, bit_or(r2503, r2506), 0x01));


                        body.instructions = f2501_parent_instructions;
                        body.emit(f2501);

                        /* END IF */

                        body.emit(assign(r24E3, r2500, 0x01));

                        body.emit(assign(r24E4, r24FF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f24FD->else_instructions;

                        ir_variable *const r2507 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2507, body.constant(0u), 0x01));

                        ir_variable *const r2508 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2508, neg(r24E6), 0x01));

                        ir_variable *const r2509 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2509);
                        ir_variable *const r250A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r250A);
                        ir_variable *const r250B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r250B);
                        ir_variable *const r250C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r250D = neg(r2508);
                        body.emit(assign(r250C, bit_and(r250D, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r250F = equal(r2508, body.constant(int(0)));
                        ir_if *f250E = new(mem_ctx) ir_if(operand(r250F).val);
                        exec_list *const f250E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f250E->then_instructions;

                           body.emit(assign(r2509, r2507, 0x01));

                           body.emit(assign(r250A, r24E4, 0x01));

                           body.emit(assign(r250B, r24E3, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f250E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2511 = less(r2508, body.constant(int(32)));
                           ir_if *f2510 = new(mem_ctx) ir_if(operand(r2511).val);
                           exec_list *const f2510_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2510->then_instructions;

                              body.emit(assign(r2509, lshift(r24E4, r250C), 0x01));

                              ir_expression *const r2512 = lshift(r24E3, r250C);
                              ir_expression *const r2513 = rshift(r24E4, r2508);
                              body.emit(assign(r250A, bit_or(r2512, r2513), 0x01));

                              body.emit(assign(r250B, rshift(r24E3, r2508), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2510->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2515 = equal(r2508, body.constant(int(32)));
                              ir_if *f2514 = new(mem_ctx) ir_if(operand(r2515).val);
                              exec_list *const f2514_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2514->then_instructions;

                                 body.emit(assign(r2509, r24E4, 0x01));

                                 body.emit(assign(r250A, r24E3, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2514->else_instructions;

                                 body.emit(assign(r2507, bit_or(body.constant(0u), r24E4), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2517 = less(r2508, body.constant(int(64)));
                                 ir_if *f2516 = new(mem_ctx) ir_if(operand(r2517).val);
                                 exec_list *const f2516_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2516->then_instructions;

                                    body.emit(assign(r2509, lshift(r24E3, r250C), 0x01));

                                    ir_expression *const r2518 = bit_and(r2508, body.constant(int(31)));
                                    body.emit(assign(r250A, rshift(r24E3, r2518), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2516->else_instructions;

                                    ir_variable *const r2519 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r251B = equal(r2508, body.constant(int(64)));
                                    ir_if *f251A = new(mem_ctx) ir_if(operand(r251B).val);
                                    exec_list *const f251A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f251A->then_instructions;

                                       body.emit(assign(r2519, r24E3, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f251A->else_instructions;

                                       ir_expression *const r251C = nequal(r24E3, body.constant(0u));
                                       ir_expression *const r251D = expr(ir_unop_b2i, r251C);
                                       body.emit(assign(r2519, expr(ir_unop_i2u, r251D), 0x01));


                                    body.instructions = f251A_parent_instructions;
                                    body.emit(f251A);

                                    /* END IF */

                                    body.emit(assign(r2509, r2519, 0x01));

                                    body.emit(assign(r250A, body.constant(0u), 0x01));


                                 body.instructions = f2516_parent_instructions;
                                 body.emit(f2516);

                                 /* END IF */


                              body.instructions = f2514_parent_instructions;
                              body.emit(f2514);

                              /* END IF */

                              body.emit(assign(r250B, body.constant(0u), 0x01));


                           body.instructions = f2510_parent_instructions;
                           body.emit(f2510);

                           /* END IF */

                           ir_expression *const r251E = nequal(r2507, body.constant(0u));
                           ir_expression *const r251F = expr(ir_unop_b2i, r251E);
                           ir_expression *const r2520 = expr(ir_unop_i2u, r251F);
                           body.emit(assign(r2509, bit_or(r2509, r2520), 0x01));


                        body.instructions = f250E_parent_instructions;
                        body.emit(f250E);

                        /* END IF */

                        body.emit(assign(r24E3, r250B, 0x01));

                        body.emit(assign(r24E4, r250A, 0x01));

                        body.emit(assign(r24E5, r2509, 0x01));


                     body.instructions = f24FD_parent_instructions;
                     body.emit(f24FD);

                     /* END IF */

                     body.emit(assign(r24E2, sub(r24E2, r24E6), 0x01));

                     ir_variable *const r2521 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2521, r24E2, 0x01));

                     ir_variable *const r2522 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2522, r24E3, 0x01));

                     ir_variable *const r2523 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2523, r24E4, 0x01));

                     ir_variable *const r2524 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2524, r24E5, 0x01));

                     ir_variable *const r2525 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2525, body.constant(true), 0x01));

                     ir_variable *const r2526 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2527 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2527);
                     ir_expression *const r2528 = expr(ir_unop_u2i, r24E5);
                     body.emit(assign(r2527, less(r2528, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r252A = lequal(body.constant(int(2045)), r24E2);
                     ir_if *f2529 = new(mem_ctx) ir_if(operand(r252A).val);
                     exec_list *const f2529_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2529->then_instructions;

                        ir_variable *const r252B = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r252D = less(body.constant(int(2045)), r24E2);
                        ir_if *f252C = new(mem_ctx) ir_if(operand(r252D).val);
                        exec_list *const f252C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f252C->then_instructions;

                           body.emit(assign(r252B, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f252C->else_instructions;

                           ir_variable *const r252E = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2530 = equal(r24E2, body.constant(int(2045)));
                           ir_if *f252F = new(mem_ctx) ir_if(operand(r2530).val);
                           exec_list *const f252F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f252F->then_instructions;

                              ir_expression *const r2531 = equal(body.constant(2097151u), r24E3);
                              ir_expression *const r2532 = equal(body.constant(4294967295u), r24E4);
                              body.emit(assign(r252E, logic_and(r2531, r2532), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f252F->else_instructions;

                              body.emit(assign(r252E, body.constant(false), 0x01));


                           body.instructions = f252F_parent_instructions;
                           body.emit(f252F);

                           /* END IF */

                           body.emit(assign(r252B, logic_and(r252E, r2527), 0x01));


                        body.instructions = f252C_parent_instructions;
                        body.emit(f252C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2533 = new(mem_ctx) ir_if(operand(r252B).val);
                        exec_list *const f2533_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2533->then_instructions;

                           ir_variable *const r2534 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2534);
                           ir_expression *const r2535 = lshift(r2350, body.constant(int(31)));
                           body.emit(assign(r2534, add(r2535, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2534, body.constant(0u), 0x01));

                           body.emit(assign(r2526, r2534, 0x03));

                           body.emit(assign(r2525, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2533->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2537 = less(r24E2, body.constant(int(0)));
                           ir_if *f2536 = new(mem_ctx) ir_if(operand(r2537).val);
                           exec_list *const f2536_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2536->then_instructions;

                              ir_variable *const r2538 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2538, r24E5, 0x01));

                              ir_variable *const r2539 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2539, neg(r24E2), 0x01));

                              ir_variable *const r253A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r253A);
                              ir_variable *const r253B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r253B);
                              ir_variable *const r253C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r253C);
                              ir_variable *const r253D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r253E = neg(r2539);
                              body.emit(assign(r253D, bit_and(r253E, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2540 = equal(r2539, body.constant(int(0)));
                              ir_if *f253F = new(mem_ctx) ir_if(operand(r2540).val);
                              exec_list *const f253F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f253F->then_instructions;

                                 body.emit(assign(r253A, r24E5, 0x01));

                                 body.emit(assign(r253B, r24E4, 0x01));

                                 body.emit(assign(r253C, r24E3, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f253F->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2542 = less(r2539, body.constant(int(32)));
                                 ir_if *f2541 = new(mem_ctx) ir_if(operand(r2542).val);
                                 exec_list *const f2541_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2541->then_instructions;

                                    body.emit(assign(r253A, lshift(r24E4, r253D), 0x01));

                                    ir_expression *const r2543 = lshift(r24E3, r253D);
                                    ir_expression *const r2544 = rshift(r24E4, r2539);
                                    body.emit(assign(r253B, bit_or(r2543, r2544), 0x01));

                                    body.emit(assign(r253C, rshift(r24E3, r2539), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2541->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2546 = equal(r2539, body.constant(int(32)));
                                    ir_if *f2545 = new(mem_ctx) ir_if(operand(r2546).val);
                                    exec_list *const f2545_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2545->then_instructions;

                                       body.emit(assign(r253A, r24E4, 0x01));

                                       body.emit(assign(r253B, r24E3, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2545->else_instructions;

                                       body.emit(assign(r2538, bit_or(r24E5, r24E4), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2548 = less(r2539, body.constant(int(64)));
                                       ir_if *f2547 = new(mem_ctx) ir_if(operand(r2548).val);
                                       exec_list *const f2547_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2547->then_instructions;

                                          body.emit(assign(r253A, lshift(r24E3, r253D), 0x01));

                                          ir_expression *const r2549 = bit_and(r2539, body.constant(int(31)));
                                          body.emit(assign(r253B, rshift(r24E3, r2549), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2547->else_instructions;

                                          ir_variable *const r254A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r254C = equal(r2539, body.constant(int(64)));
                                          ir_if *f254B = new(mem_ctx) ir_if(operand(r254C).val);
                                          exec_list *const f254B_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f254B->then_instructions;

                                             body.emit(assign(r254A, r24E3, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f254B->else_instructions;

                                             ir_expression *const r254D = nequal(r24E3, body.constant(0u));
                                             ir_expression *const r254E = expr(ir_unop_b2i, r254D);
                                             body.emit(assign(r254A, expr(ir_unop_i2u, r254E), 0x01));


                                          body.instructions = f254B_parent_instructions;
                                          body.emit(f254B);

                                          /* END IF */

                                          body.emit(assign(r253A, r254A, 0x01));

                                          body.emit(assign(r253B, body.constant(0u), 0x01));


                                       body.instructions = f2547_parent_instructions;
                                       body.emit(f2547);

                                       /* END IF */


                                    body.instructions = f2545_parent_instructions;
                                    body.emit(f2545);

                                    /* END IF */

                                    body.emit(assign(r253C, body.constant(0u), 0x01));


                                 body.instructions = f2541_parent_instructions;
                                 body.emit(f2541);

                                 /* END IF */

                                 ir_expression *const r254F = nequal(r2538, body.constant(0u));
                                 ir_expression *const r2550 = expr(ir_unop_b2i, r254F);
                                 ir_expression *const r2551 = expr(ir_unop_i2u, r2550);
                                 body.emit(assign(r253A, bit_or(r253A, r2551), 0x01));


                              body.instructions = f253F_parent_instructions;
                              body.emit(f253F);

                              /* END IF */

                              body.emit(assign(r2522, r253C, 0x01));

                              body.emit(assign(r2523, r253B, 0x01));

                              body.emit(assign(r2524, r253A, 0x01));

                              body.emit(assign(r2521, body.constant(int(0)), 0x01));

                              body.emit(assign(r2527, less(r253A, body.constant(0u)), 0x01));


                           body.instructions = f2536_parent_instructions;
                           body.emit(f2536);

                           /* END IF */


                        body.instructions = f2533_parent_instructions;
                        body.emit(f2533);

                        /* END IF */


                     body.instructions = f2529_parent_instructions;
                     body.emit(f2529);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2552 = new(mem_ctx) ir_if(operand(r2525).val);
                     exec_list *const f2552_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2552->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2553 = new(mem_ctx) ir_if(operand(r2527).val);
                        exec_list *const f2553_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2553->then_instructions;

                           ir_variable *const r2554 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2554, add(r2523, body.constant(1u)), 0x01));

                           ir_expression *const r2555 = less(r2554, r2523);
                           ir_expression *const r2556 = expr(ir_unop_b2i, r2555);
                           ir_expression *const r2557 = expr(ir_unop_i2u, r2556);
                           body.emit(assign(r2522, add(r2522, r2557), 0x01));

                           ir_expression *const r2558 = equal(r2524, body.constant(0u));
                           ir_expression *const r2559 = expr(ir_unop_b2i, r2558);
                           ir_expression *const r255A = expr(ir_unop_i2u, r2559);
                           ir_expression *const r255B = add(r2524, r255A);
                           ir_expression *const r255C = bit_and(r255B, body.constant(1u));
                           ir_expression *const r255D = expr(ir_unop_bit_not, r255C);
                           body.emit(assign(r2523, bit_and(r2554, r255D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2553->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r255F = bit_or(r2522, r2523);
                           ir_expression *const r2560 = equal(r255F, body.constant(0u));
                           ir_if *f255E = new(mem_ctx) ir_if(operand(r2560).val);
                           exec_list *const f255E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f255E->then_instructions;

                              body.emit(assign(r2521, body.constant(int(0)), 0x01));


                           body.instructions = f255E_parent_instructions;
                           body.emit(f255E);

                           /* END IF */


                        body.instructions = f2553_parent_instructions;
                        body.emit(f2553);

                        /* END IF */

                        ir_variable *const r2561 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2561);
                        ir_expression *const r2562 = lshift(r2350, body.constant(int(31)));
                        ir_expression *const r2563 = expr(ir_unop_i2u, r2521);
                        ir_expression *const r2564 = lshift(r2563, body.constant(int(20)));
                        ir_expression *const r2565 = add(r2562, r2564);
                        body.emit(assign(r2561, add(r2565, r2522), 0x02));

                        body.emit(assign(r2561, r2523, 0x01));

                        body.emit(assign(r2526, r2561, 0x03));

                        body.emit(assign(r2525, body.constant(false), 0x01));


                     body.instructions = f2552_parent_instructions;
                     body.emit(f2552);

                     /* END IF */

                     body.emit(assign(r2351, r2526, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24DA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2567 = less(r2357, r2355);
                     ir_if *f2566 = new(mem_ctx) ir_if(operand(r2567).val);
                     exec_list *const f2566_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2566->then_instructions;

                        ir_variable *const r2568 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r2569 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2569, sub(r2356, r2358), 0x01));

                        ir_expression *const r256A = sub(r2355, r2357);
                        ir_expression *const r256B = less(r2356, r2358);
                        ir_expression *const r256C = expr(ir_unop_b2i, r256B);
                        ir_expression *const r256D = expr(ir_unop_i2u, r256C);
                        body.emit(assign(r2568, sub(r256A, r256D), 0x01));

                        body.emit(assign(r2350, bit_xor(r2350, body.constant(1u)), 0x01));

                        body.emit(assign(r2359, add(r2353, body.constant(int(-1))), 0x01));

                        ir_variable *const r256E = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r256E, add(r2359, body.constant(int(-10))), 0x01));

                        ir_variable *const r256F = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r256F, r2568, 0x01));

                        ir_variable *const r2570 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2570, r2569, 0x01));

                        ir_variable *const r2571 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2571);
                        ir_variable *const r2572 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2572);
                        /* IF CONDITION */
                        ir_expression *const r2574 = equal(r2568, body.constant(0u));
                        ir_if *f2573 = new(mem_ctx) ir_if(operand(r2574).val);
                        exec_list *const f2573_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2573->then_instructions;

                           body.emit(assign(r256F, r2569, 0x01));

                           body.emit(assign(r2570, body.constant(0u), 0x01));

                           body.emit(assign(r256E, add(r256E, body.constant(int(-32))), 0x01));


                        body.instructions = f2573_parent_instructions;
                        body.emit(f2573);

                        /* END IF */

                        ir_variable *const r2575 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2575, r256F, 0x01));

                        ir_variable *const r2576 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r2577 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2577);
                        /* IF CONDITION */
                        ir_expression *const r2579 = equal(r256F, body.constant(0u));
                        ir_if *f2578 = new(mem_ctx) ir_if(operand(r2579).val);
                        exec_list *const f2578_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2578->then_instructions;

                           body.emit(assign(r2576, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2578->else_instructions;

                           body.emit(assign(r2577, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r257B = bit_and(r256F, body.constant(4294901760u));
                           ir_expression *const r257C = equal(r257B, body.constant(0u));
                           ir_if *f257A = new(mem_ctx) ir_if(operand(r257C).val);
                           exec_list *const f257A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f257A->then_instructions;

                              body.emit(assign(r2577, body.constant(int(16)), 0x01));

                              body.emit(assign(r2575, lshift(r256F, body.constant(int(16))), 0x01));


                           body.instructions = f257A_parent_instructions;
                           body.emit(f257A);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r257E = bit_and(r2575, body.constant(4278190080u));
                           ir_expression *const r257F = equal(r257E, body.constant(0u));
                           ir_if *f257D = new(mem_ctx) ir_if(operand(r257F).val);
                           exec_list *const f257D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f257D->then_instructions;

                              body.emit(assign(r2577, add(r2577, body.constant(int(8))), 0x01));

                              body.emit(assign(r2575, lshift(r2575, body.constant(int(8))), 0x01));


                           body.instructions = f257D_parent_instructions;
                           body.emit(f257D);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2581 = bit_and(r2575, body.constant(4026531840u));
                           ir_expression *const r2582 = equal(r2581, body.constant(0u));
                           ir_if *f2580 = new(mem_ctx) ir_if(operand(r2582).val);
                           exec_list *const f2580_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2580->then_instructions;

                              body.emit(assign(r2577, add(r2577, body.constant(int(4))), 0x01));

                              body.emit(assign(r2575, lshift(r2575, body.constant(int(4))), 0x01));


                           body.instructions = f2580_parent_instructions;
                           body.emit(f2580);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2584 = bit_and(r2575, body.constant(3221225472u));
                           ir_expression *const r2585 = equal(r2584, body.constant(0u));
                           ir_if *f2583 = new(mem_ctx) ir_if(operand(r2585).val);
                           exec_list *const f2583_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2583->then_instructions;

                              body.emit(assign(r2577, add(r2577, body.constant(int(2))), 0x01));

                              body.emit(assign(r2575, lshift(r2575, body.constant(int(2))), 0x01));


                           body.instructions = f2583_parent_instructions;
                           body.emit(f2583);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2587 = bit_and(r2575, body.constant(2147483648u));
                           ir_expression *const r2588 = equal(r2587, body.constant(0u));
                           ir_if *f2586 = new(mem_ctx) ir_if(operand(r2588).val);
                           exec_list *const f2586_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2586->then_instructions;

                              body.emit(assign(r2577, add(r2577, body.constant(int(1))), 0x01));


                           body.instructions = f2586_parent_instructions;
                           body.emit(f2586);

                           /* END IF */

                           body.emit(assign(r2576, r2577, 0x01));


                        body.instructions = f2578_parent_instructions;
                        body.emit(f2578);

                        /* END IF */

                        body.emit(assign(r2572, add(r2576, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r258A = lequal(body.constant(int(0)), r2572);
                        ir_if *f2589 = new(mem_ctx) ir_if(operand(r258A).val);
                        exec_list *const f2589_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2589->then_instructions;

                           body.emit(assign(r2571, body.constant(0u), 0x01));

                           ir_variable *const r258B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r258B, lshift(r2570, r2572), 0x01));

                           ir_variable *const r258C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r258E = equal(r2572, body.constant(int(0)));
                           ir_if *f258D = new(mem_ctx) ir_if(operand(r258E).val);
                           exec_list *const f258D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f258D->then_instructions;

                              body.emit(assign(r258C, r256F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f258D->else_instructions;

                              ir_expression *const r258F = lshift(r256F, r2572);
                              ir_expression *const r2590 = neg(r2572);
                              ir_expression *const r2591 = bit_and(r2590, body.constant(int(31)));
                              ir_expression *const r2592 = rshift(r2570, r2591);
                              body.emit(assign(r258C, bit_or(r258F, r2592), 0x01));


                           body.instructions = f258D_parent_instructions;
                           body.emit(f258D);

                           /* END IF */

                           body.emit(assign(r256F, r258C, 0x01));

                           body.emit(assign(r2570, r258B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2589->else_instructions;

                           ir_variable *const r2593 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2593, body.constant(0u), 0x01));

                           ir_variable *const r2594 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2594, neg(r2572), 0x01));

                           ir_variable *const r2595 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2595);
                           ir_variable *const r2596 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2596);
                           ir_variable *const r2597 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2597);
                           ir_variable *const r2598 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2599 = neg(r2594);
                           body.emit(assign(r2598, bit_and(r2599, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r259B = equal(r2594, body.constant(int(0)));
                           ir_if *f259A = new(mem_ctx) ir_if(operand(r259B).val);
                           exec_list *const f259A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f259A->then_instructions;

                              body.emit(assign(r2595, r2593, 0x01));

                              body.emit(assign(r2596, r2570, 0x01));

                              body.emit(assign(r2597, r256F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f259A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r259D = less(r2594, body.constant(int(32)));
                              ir_if *f259C = new(mem_ctx) ir_if(operand(r259D).val);
                              exec_list *const f259C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f259C->then_instructions;

                                 body.emit(assign(r2595, lshift(r2570, r2598), 0x01));

                                 ir_expression *const r259E = lshift(r256F, r2598);
                                 ir_expression *const r259F = rshift(r2570, r2594);
                                 body.emit(assign(r2596, bit_or(r259E, r259F), 0x01));

                                 body.emit(assign(r2597, rshift(r256F, r2594), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f259C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r25A1 = equal(r2594, body.constant(int(32)));
                                 ir_if *f25A0 = new(mem_ctx) ir_if(operand(r25A1).val);
                                 exec_list *const f25A0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f25A0->then_instructions;

                                    body.emit(assign(r2595, r2570, 0x01));

                                    body.emit(assign(r2596, r256F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f25A0->else_instructions;

                                    body.emit(assign(r2593, bit_or(body.constant(0u), r2570), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r25A3 = less(r2594, body.constant(int(64)));
                                    ir_if *f25A2 = new(mem_ctx) ir_if(operand(r25A3).val);
                                    exec_list *const f25A2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f25A2->then_instructions;

                                       body.emit(assign(r2595, lshift(r256F, r2598), 0x01));

                                       ir_expression *const r25A4 = bit_and(r2594, body.constant(int(31)));
                                       body.emit(assign(r2596, rshift(r256F, r25A4), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f25A2->else_instructions;

                                       ir_variable *const r25A5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r25A7 = equal(r2594, body.constant(int(64)));
                                       ir_if *f25A6 = new(mem_ctx) ir_if(operand(r25A7).val);
                                       exec_list *const f25A6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f25A6->then_instructions;

                                          body.emit(assign(r25A5, r256F, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f25A6->else_instructions;

                                          ir_expression *const r25A8 = nequal(r256F, body.constant(0u));
                                          ir_expression *const r25A9 = expr(ir_unop_b2i, r25A8);
                                          body.emit(assign(r25A5, expr(ir_unop_i2u, r25A9), 0x01));


                                       body.instructions = f25A6_parent_instructions;
                                       body.emit(f25A6);

                                       /* END IF */

                                       body.emit(assign(r2595, r25A5, 0x01));

                                       body.emit(assign(r2596, body.constant(0u), 0x01));


                                    body.instructions = f25A2_parent_instructions;
                                    body.emit(f25A2);

                                    /* END IF */


                                 body.instructions = f25A0_parent_instructions;
                                 body.emit(f25A0);

                                 /* END IF */

                                 body.emit(assign(r2597, body.constant(0u), 0x01));


                              body.instructions = f259C_parent_instructions;
                              body.emit(f259C);

                              /* END IF */

                              ir_expression *const r25AA = nequal(r2593, body.constant(0u));
                              ir_expression *const r25AB = expr(ir_unop_b2i, r25AA);
                              ir_expression *const r25AC = expr(ir_unop_i2u, r25AB);
                              body.emit(assign(r2595, bit_or(r2595, r25AC), 0x01));


                           body.instructions = f259A_parent_instructions;
                           body.emit(f259A);

                           /* END IF */

                           body.emit(assign(r256F, r2597, 0x01));

                           body.emit(assign(r2570, r2596, 0x01));

                           body.emit(assign(r2571, r2595, 0x01));


                        body.instructions = f2589_parent_instructions;
                        body.emit(f2589);

                        /* END IF */

                        body.emit(assign(r256E, sub(r256E, r2572), 0x01));

                        ir_variable *const r25AD = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r25AD, r256E, 0x01));

                        ir_variable *const r25AE = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r25AE, r256F, 0x01));

                        ir_variable *const r25AF = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r25AF, r2570, 0x01));

                        ir_variable *const r25B0 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r25B0, r2571, 0x01));

                        ir_variable *const r25B1 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r25B1, body.constant(true), 0x01));

                        ir_variable *const r25B2 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r25B3 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r25B3);
                        ir_expression *const r25B4 = expr(ir_unop_u2i, r2571);
                        body.emit(assign(r25B3, less(r25B4, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r25B6 = lequal(body.constant(int(2045)), r256E);
                        ir_if *f25B5 = new(mem_ctx) ir_if(operand(r25B6).val);
                        exec_list *const f25B5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25B5->then_instructions;

                           ir_variable *const r25B7 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r25B9 = less(body.constant(int(2045)), r256E);
                           ir_if *f25B8 = new(mem_ctx) ir_if(operand(r25B9).val);
                           exec_list *const f25B8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25B8->then_instructions;

                              body.emit(assign(r25B7, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25B8->else_instructions;

                              ir_variable *const r25BA = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r25BC = equal(r256E, body.constant(int(2045)));
                              ir_if *f25BB = new(mem_ctx) ir_if(operand(r25BC).val);
                              exec_list *const f25BB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f25BB->then_instructions;

                                 ir_expression *const r25BD = equal(body.constant(2097151u), r256F);
                                 ir_expression *const r25BE = equal(body.constant(4294967295u), r2570);
                                 body.emit(assign(r25BA, logic_and(r25BD, r25BE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f25BB->else_instructions;

                                 body.emit(assign(r25BA, body.constant(false), 0x01));


                              body.instructions = f25BB_parent_instructions;
                              body.emit(f25BB);

                              /* END IF */

                              body.emit(assign(r25B7, logic_and(r25BA, r25B3), 0x01));


                           body.instructions = f25B8_parent_instructions;
                           body.emit(f25B8);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f25BF = new(mem_ctx) ir_if(operand(r25B7).val);
                           exec_list *const f25BF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25BF->then_instructions;

                              ir_variable *const r25C0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r25C0);
                              ir_expression *const r25C1 = lshift(r2350, body.constant(int(31)));
                              body.emit(assign(r25C0, add(r25C1, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r25C0, body.constant(0u), 0x01));

                              body.emit(assign(r25B2, r25C0, 0x03));

                              body.emit(assign(r25B1, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25BF->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r25C3 = less(r256E, body.constant(int(0)));
                              ir_if *f25C2 = new(mem_ctx) ir_if(operand(r25C3).val);
                              exec_list *const f25C2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f25C2->then_instructions;

                                 ir_variable *const r25C4 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r25C4, r2571, 0x01));

                                 ir_variable *const r25C5 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r25C5, neg(r256E), 0x01));

                                 ir_variable *const r25C6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r25C6);
                                 ir_variable *const r25C7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r25C7);
                                 ir_variable *const r25C8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r25C8);
                                 ir_variable *const r25C9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r25CA = neg(r25C5);
                                 body.emit(assign(r25C9, bit_and(r25CA, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r25CC = equal(r25C5, body.constant(int(0)));
                                 ir_if *f25CB = new(mem_ctx) ir_if(operand(r25CC).val);
                                 exec_list *const f25CB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f25CB->then_instructions;

                                    body.emit(assign(r25C6, r2571, 0x01));

                                    body.emit(assign(r25C7, r2570, 0x01));

                                    body.emit(assign(r25C8, r256F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f25CB->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r25CE = less(r25C5, body.constant(int(32)));
                                    ir_if *f25CD = new(mem_ctx) ir_if(operand(r25CE).val);
                                    exec_list *const f25CD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f25CD->then_instructions;

                                       body.emit(assign(r25C6, lshift(r2570, r25C9), 0x01));

                                       ir_expression *const r25CF = lshift(r256F, r25C9);
                                       ir_expression *const r25D0 = rshift(r2570, r25C5);
                                       body.emit(assign(r25C7, bit_or(r25CF, r25D0), 0x01));

                                       body.emit(assign(r25C8, rshift(r256F, r25C5), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f25CD->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r25D2 = equal(r25C5, body.constant(int(32)));
                                       ir_if *f25D1 = new(mem_ctx) ir_if(operand(r25D2).val);
                                       exec_list *const f25D1_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f25D1->then_instructions;

                                          body.emit(assign(r25C6, r2570, 0x01));

                                          body.emit(assign(r25C7, r256F, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f25D1->else_instructions;

                                          body.emit(assign(r25C4, bit_or(r2571, r2570), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r25D4 = less(r25C5, body.constant(int(64)));
                                          ir_if *f25D3 = new(mem_ctx) ir_if(operand(r25D4).val);
                                          exec_list *const f25D3_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f25D3->then_instructions;

                                             body.emit(assign(r25C6, lshift(r256F, r25C9), 0x01));

                                             ir_expression *const r25D5 = bit_and(r25C5, body.constant(int(31)));
                                             body.emit(assign(r25C7, rshift(r256F, r25D5), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f25D3->else_instructions;

                                             ir_variable *const r25D6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r25D8 = equal(r25C5, body.constant(int(64)));
                                             ir_if *f25D7 = new(mem_ctx) ir_if(operand(r25D8).val);
                                             exec_list *const f25D7_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f25D7->then_instructions;

                                                body.emit(assign(r25D6, r256F, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f25D7->else_instructions;

                                                ir_expression *const r25D9 = nequal(r256F, body.constant(0u));
                                                ir_expression *const r25DA = expr(ir_unop_b2i, r25D9);
                                                body.emit(assign(r25D6, expr(ir_unop_i2u, r25DA), 0x01));


                                             body.instructions = f25D7_parent_instructions;
                                             body.emit(f25D7);

                                             /* END IF */

                                             body.emit(assign(r25C6, r25D6, 0x01));

                                             body.emit(assign(r25C7, body.constant(0u), 0x01));


                                          body.instructions = f25D3_parent_instructions;
                                          body.emit(f25D3);

                                          /* END IF */


                                       body.instructions = f25D1_parent_instructions;
                                       body.emit(f25D1);

                                       /* END IF */

                                       body.emit(assign(r25C8, body.constant(0u), 0x01));


                                    body.instructions = f25CD_parent_instructions;
                                    body.emit(f25CD);

                                    /* END IF */

                                    ir_expression *const r25DB = nequal(r25C4, body.constant(0u));
                                    ir_expression *const r25DC = expr(ir_unop_b2i, r25DB);
                                    ir_expression *const r25DD = expr(ir_unop_i2u, r25DC);
                                    body.emit(assign(r25C6, bit_or(r25C6, r25DD), 0x01));


                                 body.instructions = f25CB_parent_instructions;
                                 body.emit(f25CB);

                                 /* END IF */

                                 body.emit(assign(r25AE, r25C8, 0x01));

                                 body.emit(assign(r25AF, r25C7, 0x01));

                                 body.emit(assign(r25B0, r25C6, 0x01));

                                 body.emit(assign(r25AD, body.constant(int(0)), 0x01));

                                 body.emit(assign(r25B3, less(r25C6, body.constant(0u)), 0x01));


                              body.instructions = f25C2_parent_instructions;
                              body.emit(f25C2);

                              /* END IF */


                           body.instructions = f25BF_parent_instructions;
                           body.emit(f25BF);

                           /* END IF */


                        body.instructions = f25B5_parent_instructions;
                        body.emit(f25B5);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f25DE = new(mem_ctx) ir_if(operand(r25B1).val);
                        exec_list *const f25DE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25DE->then_instructions;

                           /* IF CONDITION */
                           ir_if *f25DF = new(mem_ctx) ir_if(operand(r25B3).val);
                           exec_list *const f25DF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25DF->then_instructions;

                              ir_variable *const r25E0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r25E0, add(r25AF, body.constant(1u)), 0x01));

                              ir_expression *const r25E1 = less(r25E0, r25AF);
                              ir_expression *const r25E2 = expr(ir_unop_b2i, r25E1);
                              ir_expression *const r25E3 = expr(ir_unop_i2u, r25E2);
                              body.emit(assign(r25AE, add(r25AE, r25E3), 0x01));

                              ir_expression *const r25E4 = equal(r25B0, body.constant(0u));
                              ir_expression *const r25E5 = expr(ir_unop_b2i, r25E4);
                              ir_expression *const r25E6 = expr(ir_unop_i2u, r25E5);
                              ir_expression *const r25E7 = add(r25B0, r25E6);
                              ir_expression *const r25E8 = bit_and(r25E7, body.constant(1u));
                              ir_expression *const r25E9 = expr(ir_unop_bit_not, r25E8);
                              body.emit(assign(r25AF, bit_and(r25E0, r25E9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25DF->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r25EB = bit_or(r25AE, r25AF);
                              ir_expression *const r25EC = equal(r25EB, body.constant(0u));
                              ir_if *f25EA = new(mem_ctx) ir_if(operand(r25EC).val);
                              exec_list *const f25EA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f25EA->then_instructions;

                                 body.emit(assign(r25AD, body.constant(int(0)), 0x01));


                              body.instructions = f25EA_parent_instructions;
                              body.emit(f25EA);

                              /* END IF */


                           body.instructions = f25DF_parent_instructions;
                           body.emit(f25DF);

                           /* END IF */

                           ir_variable *const r25ED = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r25ED);
                           ir_expression *const r25EE = lshift(r2350, body.constant(int(31)));
                           ir_expression *const r25EF = expr(ir_unop_i2u, r25AD);
                           ir_expression *const r25F0 = lshift(r25EF, body.constant(int(20)));
                           ir_expression *const r25F1 = add(r25EE, r25F0);
                           body.emit(assign(r25ED, add(r25F1, r25AE), 0x02));

                           body.emit(assign(r25ED, r25AF, 0x01));

                           body.emit(assign(r25B2, r25ED, 0x03));

                           body.emit(assign(r25B1, body.constant(false), 0x01));


                        body.instructions = f25DE_parent_instructions;
                        body.emit(f25DE);

                        /* END IF */

                        body.emit(assign(r2351, r25B2, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2566->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r25F3 = less(r2356, r2358);
                        ir_if *f25F2 = new(mem_ctx) ir_if(operand(r25F3).val);
                        exec_list *const f25F2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25F2->then_instructions;

                           ir_variable *const r25F4 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r25F5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r25F5, sub(r2358, r2356), 0x01));

                           ir_expression *const r25F6 = sub(r2357, r2355);
                           ir_expression *const r25F7 = less(r2358, r2356);
                           ir_expression *const r25F8 = expr(ir_unop_b2i, r25F7);
                           ir_expression *const r25F9 = expr(ir_unop_i2u, r25F8);
                           body.emit(assign(r25F4, sub(r25F6, r25F9), 0x01));

                           body.emit(assign(r2359, add(r2354, body.constant(int(-1))), 0x01));

                           ir_variable *const r25FA = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r25FA, add(r2359, body.constant(int(-10))), 0x01));

                           ir_variable *const r25FB = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r25FB, r25F4, 0x01));

                           ir_variable *const r25FC = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r25FC, r25F5, 0x01));

                           ir_variable *const r25FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r25FD);
                           ir_variable *const r25FE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r25FE);
                           /* IF CONDITION */
                           ir_expression *const r2600 = equal(r25F4, body.constant(0u));
                           ir_if *f25FF = new(mem_ctx) ir_if(operand(r2600).val);
                           exec_list *const f25FF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25FF->then_instructions;

                              body.emit(assign(r25FB, r25F5, 0x01));

                              body.emit(assign(r25FC, body.constant(0u), 0x01));

                              body.emit(assign(r25FA, add(r25FA, body.constant(int(-32))), 0x01));


                           body.instructions = f25FF_parent_instructions;
                           body.emit(f25FF);

                           /* END IF */

                           ir_variable *const r2601 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r2601, r25FB, 0x01));

                           ir_variable *const r2602 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r2603 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2603);
                           /* IF CONDITION */
                           ir_expression *const r2605 = equal(r25FB, body.constant(0u));
                           ir_if *f2604 = new(mem_ctx) ir_if(operand(r2605).val);
                           exec_list *const f2604_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2604->then_instructions;

                              body.emit(assign(r2602, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2604->else_instructions;

                              body.emit(assign(r2603, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2607 = bit_and(r25FB, body.constant(4294901760u));
                              ir_expression *const r2608 = equal(r2607, body.constant(0u));
                              ir_if *f2606 = new(mem_ctx) ir_if(operand(r2608).val);
                              exec_list *const f2606_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2606->then_instructions;

                                 body.emit(assign(r2603, body.constant(int(16)), 0x01));

                                 body.emit(assign(r2601, lshift(r25FB, body.constant(int(16))), 0x01));


                              body.instructions = f2606_parent_instructions;
                              body.emit(f2606);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r260A = bit_and(r2601, body.constant(4278190080u));
                              ir_expression *const r260B = equal(r260A, body.constant(0u));
                              ir_if *f2609 = new(mem_ctx) ir_if(operand(r260B).val);
                              exec_list *const f2609_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2609->then_instructions;

                                 body.emit(assign(r2603, add(r2603, body.constant(int(8))), 0x01));

                                 body.emit(assign(r2601, lshift(r2601, body.constant(int(8))), 0x01));


                              body.instructions = f2609_parent_instructions;
                              body.emit(f2609);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r260D = bit_and(r2601, body.constant(4026531840u));
                              ir_expression *const r260E = equal(r260D, body.constant(0u));
                              ir_if *f260C = new(mem_ctx) ir_if(operand(r260E).val);
                              exec_list *const f260C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f260C->then_instructions;

                                 body.emit(assign(r2603, add(r2603, body.constant(int(4))), 0x01));

                                 body.emit(assign(r2601, lshift(r2601, body.constant(int(4))), 0x01));


                              body.instructions = f260C_parent_instructions;
                              body.emit(f260C);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2610 = bit_and(r2601, body.constant(3221225472u));
                              ir_expression *const r2611 = equal(r2610, body.constant(0u));
                              ir_if *f260F = new(mem_ctx) ir_if(operand(r2611).val);
                              exec_list *const f260F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f260F->then_instructions;

                                 body.emit(assign(r2603, add(r2603, body.constant(int(2))), 0x01));

                                 body.emit(assign(r2601, lshift(r2601, body.constant(int(2))), 0x01));


                              body.instructions = f260F_parent_instructions;
                              body.emit(f260F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2613 = bit_and(r2601, body.constant(2147483648u));
                              ir_expression *const r2614 = equal(r2613, body.constant(0u));
                              ir_if *f2612 = new(mem_ctx) ir_if(operand(r2614).val);
                              exec_list *const f2612_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2612->then_instructions;

                                 body.emit(assign(r2603, add(r2603, body.constant(int(1))), 0x01));


                              body.instructions = f2612_parent_instructions;
                              body.emit(f2612);

                              /* END IF */

                              body.emit(assign(r2602, r2603, 0x01));


                           body.instructions = f2604_parent_instructions;
                           body.emit(f2604);

                           /* END IF */

                           body.emit(assign(r25FE, add(r2602, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2616 = lequal(body.constant(int(0)), r25FE);
                           ir_if *f2615 = new(mem_ctx) ir_if(operand(r2616).val);
                           exec_list *const f2615_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2615->then_instructions;

                              body.emit(assign(r25FD, body.constant(0u), 0x01));

                              ir_variable *const r2617 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2617, lshift(r25FC, r25FE), 0x01));

                              ir_variable *const r2618 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r261A = equal(r25FE, body.constant(int(0)));
                              ir_if *f2619 = new(mem_ctx) ir_if(operand(r261A).val);
                              exec_list *const f2619_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2619->then_instructions;

                                 body.emit(assign(r2618, r25FB, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2619->else_instructions;

                                 ir_expression *const r261B = lshift(r25FB, r25FE);
                                 ir_expression *const r261C = neg(r25FE);
                                 ir_expression *const r261D = bit_and(r261C, body.constant(int(31)));
                                 ir_expression *const r261E = rshift(r25FC, r261D);
                                 body.emit(assign(r2618, bit_or(r261B, r261E), 0x01));


                              body.instructions = f2619_parent_instructions;
                              body.emit(f2619);

                              /* END IF */

                              body.emit(assign(r25FB, r2618, 0x01));

                              body.emit(assign(r25FC, r2617, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2615->else_instructions;

                              ir_variable *const r261F = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r261F, body.constant(0u), 0x01));

                              ir_variable *const r2620 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2620, neg(r25FE), 0x01));

                              ir_variable *const r2621 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2621);
                              ir_variable *const r2622 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2622);
                              ir_variable *const r2623 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2623);
                              ir_variable *const r2624 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2625 = neg(r2620);
                              body.emit(assign(r2624, bit_and(r2625, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2627 = equal(r2620, body.constant(int(0)));
                              ir_if *f2626 = new(mem_ctx) ir_if(operand(r2627).val);
                              exec_list *const f2626_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2626->then_instructions;

                                 body.emit(assign(r2621, r261F, 0x01));

                                 body.emit(assign(r2622, r25FC, 0x01));

                                 body.emit(assign(r2623, r25FB, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2626->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2629 = less(r2620, body.constant(int(32)));
                                 ir_if *f2628 = new(mem_ctx) ir_if(operand(r2629).val);
                                 exec_list *const f2628_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2628->then_instructions;

                                    body.emit(assign(r2621, lshift(r25FC, r2624), 0x01));

                                    ir_expression *const r262A = lshift(r25FB, r2624);
                                    ir_expression *const r262B = rshift(r25FC, r2620);
                                    body.emit(assign(r2622, bit_or(r262A, r262B), 0x01));

                                    body.emit(assign(r2623, rshift(r25FB, r2620), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2628->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r262D = equal(r2620, body.constant(int(32)));
                                    ir_if *f262C = new(mem_ctx) ir_if(operand(r262D).val);
                                    exec_list *const f262C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f262C->then_instructions;

                                       body.emit(assign(r2621, r25FC, 0x01));

                                       body.emit(assign(r2622, r25FB, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f262C->else_instructions;

                                       body.emit(assign(r261F, bit_or(body.constant(0u), r25FC), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r262F = less(r2620, body.constant(int(64)));
                                       ir_if *f262E = new(mem_ctx) ir_if(operand(r262F).val);
                                       exec_list *const f262E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f262E->then_instructions;

                                          body.emit(assign(r2621, lshift(r25FB, r2624), 0x01));

                                          ir_expression *const r2630 = bit_and(r2620, body.constant(int(31)));
                                          body.emit(assign(r2622, rshift(r25FB, r2630), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f262E->else_instructions;

                                          ir_variable *const r2631 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2633 = equal(r2620, body.constant(int(64)));
                                          ir_if *f2632 = new(mem_ctx) ir_if(operand(r2633).val);
                                          exec_list *const f2632_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2632->then_instructions;

                                             body.emit(assign(r2631, r25FB, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2632->else_instructions;

                                             ir_expression *const r2634 = nequal(r25FB, body.constant(0u));
                                             ir_expression *const r2635 = expr(ir_unop_b2i, r2634);
                                             body.emit(assign(r2631, expr(ir_unop_i2u, r2635), 0x01));


                                          body.instructions = f2632_parent_instructions;
                                          body.emit(f2632);

                                          /* END IF */

                                          body.emit(assign(r2621, r2631, 0x01));

                                          body.emit(assign(r2622, body.constant(0u), 0x01));


                                       body.instructions = f262E_parent_instructions;
                                       body.emit(f262E);

                                       /* END IF */


                                    body.instructions = f262C_parent_instructions;
                                    body.emit(f262C);

                                    /* END IF */

                                    body.emit(assign(r2623, body.constant(0u), 0x01));


                                 body.instructions = f2628_parent_instructions;
                                 body.emit(f2628);

                                 /* END IF */

                                 ir_expression *const r2636 = nequal(r261F, body.constant(0u));
                                 ir_expression *const r2637 = expr(ir_unop_b2i, r2636);
                                 ir_expression *const r2638 = expr(ir_unop_i2u, r2637);
                                 body.emit(assign(r2621, bit_or(r2621, r2638), 0x01));


                              body.instructions = f2626_parent_instructions;
                              body.emit(f2626);

                              /* END IF */

                              body.emit(assign(r25FB, r2623, 0x01));

                              body.emit(assign(r25FC, r2622, 0x01));

                              body.emit(assign(r25FD, r2621, 0x01));


                           body.instructions = f2615_parent_instructions;
                           body.emit(f2615);

                           /* END IF */

                           body.emit(assign(r25FA, sub(r25FA, r25FE), 0x01));

                           ir_variable *const r2639 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2639, r25FA, 0x01));

                           ir_variable *const r263A = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r263A, r25FB, 0x01));

                           ir_variable *const r263B = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r263B, r25FC, 0x01));

                           ir_variable *const r263C = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r263C, r25FD, 0x01));

                           ir_variable *const r263D = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r263D, body.constant(true), 0x01));

                           ir_variable *const r263E = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r263F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r263F);
                           ir_expression *const r2640 = expr(ir_unop_u2i, r25FD);
                           body.emit(assign(r263F, less(r2640, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2642 = lequal(body.constant(int(2045)), r25FA);
                           ir_if *f2641 = new(mem_ctx) ir_if(operand(r2642).val);
                           exec_list *const f2641_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2641->then_instructions;

                              ir_variable *const r2643 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2645 = less(body.constant(int(2045)), r25FA);
                              ir_if *f2644 = new(mem_ctx) ir_if(operand(r2645).val);
                              exec_list *const f2644_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2644->then_instructions;

                                 body.emit(assign(r2643, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2644->else_instructions;

                                 ir_variable *const r2646 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2648 = equal(r25FA, body.constant(int(2045)));
                                 ir_if *f2647 = new(mem_ctx) ir_if(operand(r2648).val);
                                 exec_list *const f2647_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2647->then_instructions;

                                    ir_expression *const r2649 = equal(body.constant(2097151u), r25FB);
                                    ir_expression *const r264A = equal(body.constant(4294967295u), r25FC);
                                    body.emit(assign(r2646, logic_and(r2649, r264A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2647->else_instructions;

                                    body.emit(assign(r2646, body.constant(false), 0x01));


                                 body.instructions = f2647_parent_instructions;
                                 body.emit(f2647);

                                 /* END IF */

                                 body.emit(assign(r2643, logic_and(r2646, r263F), 0x01));


                              body.instructions = f2644_parent_instructions;
                              body.emit(f2644);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f264B = new(mem_ctx) ir_if(operand(r2643).val);
                              exec_list *const f264B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f264B->then_instructions;

                                 ir_variable *const r264C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r264C);
                                 ir_expression *const r264D = lshift(r2350, body.constant(int(31)));
                                 body.emit(assign(r264C, add(r264D, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r264C, body.constant(0u), 0x01));

                                 body.emit(assign(r263E, r264C, 0x03));

                                 body.emit(assign(r263D, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f264B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r264F = less(r25FA, body.constant(int(0)));
                                 ir_if *f264E = new(mem_ctx) ir_if(operand(r264F).val);
                                 exec_list *const f264E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f264E->then_instructions;

                                    ir_variable *const r2650 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r2650, r25FD, 0x01));

                                    ir_variable *const r2651 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r2651, neg(r25FA), 0x01));

                                    ir_variable *const r2652 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r2652);
                                    ir_variable *const r2653 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r2653);
                                    ir_variable *const r2654 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2654);
                                    ir_variable *const r2655 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2656 = neg(r2651);
                                    body.emit(assign(r2655, bit_and(r2656, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2658 = equal(r2651, body.constant(int(0)));
                                    ir_if *f2657 = new(mem_ctx) ir_if(operand(r2658).val);
                                    exec_list *const f2657_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2657->then_instructions;

                                       body.emit(assign(r2652, r25FD, 0x01));

                                       body.emit(assign(r2653, r25FC, 0x01));

                                       body.emit(assign(r2654, r25FB, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2657->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r265A = less(r2651, body.constant(int(32)));
                                       ir_if *f2659 = new(mem_ctx) ir_if(operand(r265A).val);
                                       exec_list *const f2659_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2659->then_instructions;

                                          body.emit(assign(r2652, lshift(r25FC, r2655), 0x01));

                                          ir_expression *const r265B = lshift(r25FB, r2655);
                                          ir_expression *const r265C = rshift(r25FC, r2651);
                                          body.emit(assign(r2653, bit_or(r265B, r265C), 0x01));

                                          body.emit(assign(r2654, rshift(r25FB, r2651), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2659->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r265E = equal(r2651, body.constant(int(32)));
                                          ir_if *f265D = new(mem_ctx) ir_if(operand(r265E).val);
                                          exec_list *const f265D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f265D->then_instructions;

                                             body.emit(assign(r2652, r25FC, 0x01));

                                             body.emit(assign(r2653, r25FB, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f265D->else_instructions;

                                             body.emit(assign(r2650, bit_or(r25FD, r25FC), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r2660 = less(r2651, body.constant(int(64)));
                                             ir_if *f265F = new(mem_ctx) ir_if(operand(r2660).val);
                                             exec_list *const f265F_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f265F->then_instructions;

                                                body.emit(assign(r2652, lshift(r25FB, r2655), 0x01));

                                                ir_expression *const r2661 = bit_and(r2651, body.constant(int(31)));
                                                body.emit(assign(r2653, rshift(r25FB, r2661), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f265F->else_instructions;

                                                ir_variable *const r2662 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2664 = equal(r2651, body.constant(int(64)));
                                                ir_if *f2663 = new(mem_ctx) ir_if(operand(r2664).val);
                                                exec_list *const f2663_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2663->then_instructions;

                                                   body.emit(assign(r2662, r25FB, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2663->else_instructions;

                                                   ir_expression *const r2665 = nequal(r25FB, body.constant(0u));
                                                   ir_expression *const r2666 = expr(ir_unop_b2i, r2665);
                                                   body.emit(assign(r2662, expr(ir_unop_i2u, r2666), 0x01));


                                                body.instructions = f2663_parent_instructions;
                                                body.emit(f2663);

                                                /* END IF */

                                                body.emit(assign(r2652, r2662, 0x01));

                                                body.emit(assign(r2653, body.constant(0u), 0x01));


                                             body.instructions = f265F_parent_instructions;
                                             body.emit(f265F);

                                             /* END IF */


                                          body.instructions = f265D_parent_instructions;
                                          body.emit(f265D);

                                          /* END IF */

                                          body.emit(assign(r2654, body.constant(0u), 0x01));


                                       body.instructions = f2659_parent_instructions;
                                       body.emit(f2659);

                                       /* END IF */

                                       ir_expression *const r2667 = nequal(r2650, body.constant(0u));
                                       ir_expression *const r2668 = expr(ir_unop_b2i, r2667);
                                       ir_expression *const r2669 = expr(ir_unop_i2u, r2668);
                                       body.emit(assign(r2652, bit_or(r2652, r2669), 0x01));


                                    body.instructions = f2657_parent_instructions;
                                    body.emit(f2657);

                                    /* END IF */

                                    body.emit(assign(r263A, r2654, 0x01));

                                    body.emit(assign(r263B, r2653, 0x01));

                                    body.emit(assign(r263C, r2652, 0x01));

                                    body.emit(assign(r2639, body.constant(int(0)), 0x01));

                                    body.emit(assign(r263F, less(r2652, body.constant(0u)), 0x01));


                                 body.instructions = f264E_parent_instructions;
                                 body.emit(f264E);

                                 /* END IF */


                              body.instructions = f264B_parent_instructions;
                              body.emit(f264B);

                              /* END IF */


                           body.instructions = f2641_parent_instructions;
                           body.emit(f2641);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f266A = new(mem_ctx) ir_if(operand(r263D).val);
                           exec_list *const f266A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f266A->then_instructions;

                              /* IF CONDITION */
                              ir_if *f266B = new(mem_ctx) ir_if(operand(r263F).val);
                              exec_list *const f266B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f266B->then_instructions;

                                 ir_variable *const r266C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r266C, add(r263B, body.constant(1u)), 0x01));

                                 ir_expression *const r266D = less(r266C, r263B);
                                 ir_expression *const r266E = expr(ir_unop_b2i, r266D);
                                 ir_expression *const r266F = expr(ir_unop_i2u, r266E);
                                 body.emit(assign(r263A, add(r263A, r266F), 0x01));

                                 ir_expression *const r2670 = equal(r263C, body.constant(0u));
                                 ir_expression *const r2671 = expr(ir_unop_b2i, r2670);
                                 ir_expression *const r2672 = expr(ir_unop_i2u, r2671);
                                 ir_expression *const r2673 = add(r263C, r2672);
                                 ir_expression *const r2674 = bit_and(r2673, body.constant(1u));
                                 ir_expression *const r2675 = expr(ir_unop_bit_not, r2674);
                                 body.emit(assign(r263B, bit_and(r266C, r2675), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f266B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2677 = bit_or(r263A, r263B);
                                 ir_expression *const r2678 = equal(r2677, body.constant(0u));
                                 ir_if *f2676 = new(mem_ctx) ir_if(operand(r2678).val);
                                 exec_list *const f2676_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2676->then_instructions;

                                    body.emit(assign(r2639, body.constant(int(0)), 0x01));


                                 body.instructions = f2676_parent_instructions;
                                 body.emit(f2676);

                                 /* END IF */


                              body.instructions = f266B_parent_instructions;
                              body.emit(f266B);

                              /* END IF */

                              ir_variable *const r2679 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2679);
                              ir_expression *const r267A = lshift(r2350, body.constant(int(31)));
                              ir_expression *const r267B = expr(ir_unop_i2u, r2639);
                              ir_expression *const r267C = lshift(r267B, body.constant(int(20)));
                              ir_expression *const r267D = add(r267A, r267C);
                              body.emit(assign(r2679, add(r267D, r263A), 0x02));

                              body.emit(assign(r2679, r263B, 0x01));

                              body.emit(assign(r263E, r2679, 0x03));

                              body.emit(assign(r263D, body.constant(false), 0x01));


                           body.instructions = f266A_parent_instructions;
                           body.emit(f266A);

                           /* END IF */

                           body.emit(assign(r2351, r263E, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f25F2->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r267F = less(r2358, r2356);
                           ir_if *f267E = new(mem_ctx) ir_if(operand(r267F).val);
                           exec_list *const f267E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f267E->then_instructions;

                              ir_variable *const r2680 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r2681 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2681, sub(r2356, r2358), 0x01));

                              ir_expression *const r2682 = sub(r2355, r2357);
                              ir_expression *const r2683 = less(r2356, r2358);
                              ir_expression *const r2684 = expr(ir_unop_b2i, r2683);
                              ir_expression *const r2685 = expr(ir_unop_i2u, r2684);
                              body.emit(assign(r2680, sub(r2682, r2685), 0x01));

                              body.emit(assign(r2350, bit_xor(r2350, body.constant(1u)), 0x01));

                              body.emit(assign(r2359, add(r2353, body.constant(int(-1))), 0x01));

                              ir_variable *const r2686 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2686, add(r2359, body.constant(int(-10))), 0x01));

                              ir_variable *const r2687 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2687, r2680, 0x01));

                              ir_variable *const r2688 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2688, r2681, 0x01));

                              ir_variable *const r2689 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r2689);
                              ir_variable *const r268A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r268A);
                              /* IF CONDITION */
                              ir_expression *const r268C = equal(r2680, body.constant(0u));
                              ir_if *f268B = new(mem_ctx) ir_if(operand(r268C).val);
                              exec_list *const f268B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f268B->then_instructions;

                                 body.emit(assign(r2687, r2681, 0x01));

                                 body.emit(assign(r2688, body.constant(0u), 0x01));

                                 body.emit(assign(r2686, add(r2686, body.constant(int(-32))), 0x01));


                              body.instructions = f268B_parent_instructions;
                              body.emit(f268B);

                              /* END IF */

                              ir_variable *const r268D = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r268D, r2687, 0x01));

                              ir_variable *const r268E = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r268F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r268F);
                              /* IF CONDITION */
                              ir_expression *const r2691 = equal(r2687, body.constant(0u));
                              ir_if *f2690 = new(mem_ctx) ir_if(operand(r2691).val);
                              exec_list *const f2690_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2690->then_instructions;

                                 body.emit(assign(r268E, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2690->else_instructions;

                                 body.emit(assign(r268F, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2693 = bit_and(r2687, body.constant(4294901760u));
                                 ir_expression *const r2694 = equal(r2693, body.constant(0u));
                                 ir_if *f2692 = new(mem_ctx) ir_if(operand(r2694).val);
                                 exec_list *const f2692_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2692->then_instructions;

                                    body.emit(assign(r268F, body.constant(int(16)), 0x01));

                                    body.emit(assign(r268D, lshift(r2687, body.constant(int(16))), 0x01));


                                 body.instructions = f2692_parent_instructions;
                                 body.emit(f2692);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2696 = bit_and(r268D, body.constant(4278190080u));
                                 ir_expression *const r2697 = equal(r2696, body.constant(0u));
                                 ir_if *f2695 = new(mem_ctx) ir_if(operand(r2697).val);
                                 exec_list *const f2695_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2695->then_instructions;

                                    body.emit(assign(r268F, add(r268F, body.constant(int(8))), 0x01));

                                    body.emit(assign(r268D, lshift(r268D, body.constant(int(8))), 0x01));


                                 body.instructions = f2695_parent_instructions;
                                 body.emit(f2695);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2699 = bit_and(r268D, body.constant(4026531840u));
                                 ir_expression *const r269A = equal(r2699, body.constant(0u));
                                 ir_if *f2698 = new(mem_ctx) ir_if(operand(r269A).val);
                                 exec_list *const f2698_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2698->then_instructions;

                                    body.emit(assign(r268F, add(r268F, body.constant(int(4))), 0x01));

                                    body.emit(assign(r268D, lshift(r268D, body.constant(int(4))), 0x01));


                                 body.instructions = f2698_parent_instructions;
                                 body.emit(f2698);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r269C = bit_and(r268D, body.constant(3221225472u));
                                 ir_expression *const r269D = equal(r269C, body.constant(0u));
                                 ir_if *f269B = new(mem_ctx) ir_if(operand(r269D).val);
                                 exec_list *const f269B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f269B->then_instructions;

                                    body.emit(assign(r268F, add(r268F, body.constant(int(2))), 0x01));

                                    body.emit(assign(r268D, lshift(r268D, body.constant(int(2))), 0x01));


                                 body.instructions = f269B_parent_instructions;
                                 body.emit(f269B);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r269F = bit_and(r268D, body.constant(2147483648u));
                                 ir_expression *const r26A0 = equal(r269F, body.constant(0u));
                                 ir_if *f269E = new(mem_ctx) ir_if(operand(r26A0).val);
                                 exec_list *const f269E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f269E->then_instructions;

                                    body.emit(assign(r268F, add(r268F, body.constant(int(1))), 0x01));


                                 body.instructions = f269E_parent_instructions;
                                 body.emit(f269E);

                                 /* END IF */

                                 body.emit(assign(r268E, r268F, 0x01));


                              body.instructions = f2690_parent_instructions;
                              body.emit(f2690);

                              /* END IF */

                              body.emit(assign(r268A, add(r268E, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r26A2 = lequal(body.constant(int(0)), r268A);
                              ir_if *f26A1 = new(mem_ctx) ir_if(operand(r26A2).val);
                              exec_list *const f26A1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26A1->then_instructions;

                                 body.emit(assign(r2689, body.constant(0u), 0x01));

                                 ir_variable *const r26A3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r26A3, lshift(r2688, r268A), 0x01));

                                 ir_variable *const r26A4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r26A6 = equal(r268A, body.constant(int(0)));
                                 ir_if *f26A5 = new(mem_ctx) ir_if(operand(r26A6).val);
                                 exec_list *const f26A5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26A5->then_instructions;

                                    body.emit(assign(r26A4, r2687, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26A5->else_instructions;

                                    ir_expression *const r26A7 = lshift(r2687, r268A);
                                    ir_expression *const r26A8 = neg(r268A);
                                    ir_expression *const r26A9 = bit_and(r26A8, body.constant(int(31)));
                                    ir_expression *const r26AA = rshift(r2688, r26A9);
                                    body.emit(assign(r26A4, bit_or(r26A7, r26AA), 0x01));


                                 body.instructions = f26A5_parent_instructions;
                                 body.emit(f26A5);

                                 /* END IF */

                                 body.emit(assign(r2687, r26A4, 0x01));

                                 body.emit(assign(r2688, r26A3, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f26A1->else_instructions;

                                 ir_variable *const r26AB = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r26AB, body.constant(0u), 0x01));

                                 ir_variable *const r26AC = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r26AC, neg(r268A), 0x01));

                                 ir_variable *const r26AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r26AD);
                                 ir_variable *const r26AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r26AE);
                                 ir_variable *const r26AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r26AF);
                                 ir_variable *const r26B0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r26B1 = neg(r26AC);
                                 body.emit(assign(r26B0, bit_and(r26B1, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r26B3 = equal(r26AC, body.constant(int(0)));
                                 ir_if *f26B2 = new(mem_ctx) ir_if(operand(r26B3).val);
                                 exec_list *const f26B2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26B2->then_instructions;

                                    body.emit(assign(r26AD, r26AB, 0x01));

                                    body.emit(assign(r26AE, r2688, 0x01));

                                    body.emit(assign(r26AF, r2687, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26B2->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r26B5 = less(r26AC, body.constant(int(32)));
                                    ir_if *f26B4 = new(mem_ctx) ir_if(operand(r26B5).val);
                                    exec_list *const f26B4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f26B4->then_instructions;

                                       body.emit(assign(r26AD, lshift(r2688, r26B0), 0x01));

                                       ir_expression *const r26B6 = lshift(r2687, r26B0);
                                       ir_expression *const r26B7 = rshift(r2688, r26AC);
                                       body.emit(assign(r26AE, bit_or(r26B6, r26B7), 0x01));

                                       body.emit(assign(r26AF, rshift(r2687, r26AC), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f26B4->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r26B9 = equal(r26AC, body.constant(int(32)));
                                       ir_if *f26B8 = new(mem_ctx) ir_if(operand(r26B9).val);
                                       exec_list *const f26B8_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f26B8->then_instructions;

                                          body.emit(assign(r26AD, r2688, 0x01));

                                          body.emit(assign(r26AE, r2687, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f26B8->else_instructions;

                                          body.emit(assign(r26AB, bit_or(body.constant(0u), r2688), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r26BB = less(r26AC, body.constant(int(64)));
                                          ir_if *f26BA = new(mem_ctx) ir_if(operand(r26BB).val);
                                          exec_list *const f26BA_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f26BA->then_instructions;

                                             body.emit(assign(r26AD, lshift(r2687, r26B0), 0x01));

                                             ir_expression *const r26BC = bit_and(r26AC, body.constant(int(31)));
                                             body.emit(assign(r26AE, rshift(r2687, r26BC), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f26BA->else_instructions;

                                             ir_variable *const r26BD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r26BF = equal(r26AC, body.constant(int(64)));
                                             ir_if *f26BE = new(mem_ctx) ir_if(operand(r26BF).val);
                                             exec_list *const f26BE_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f26BE->then_instructions;

                                                body.emit(assign(r26BD, r2687, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f26BE->else_instructions;

                                                ir_expression *const r26C0 = nequal(r2687, body.constant(0u));
                                                ir_expression *const r26C1 = expr(ir_unop_b2i, r26C0);
                                                body.emit(assign(r26BD, expr(ir_unop_i2u, r26C1), 0x01));


                                             body.instructions = f26BE_parent_instructions;
                                             body.emit(f26BE);

                                             /* END IF */

                                             body.emit(assign(r26AD, r26BD, 0x01));

                                             body.emit(assign(r26AE, body.constant(0u), 0x01));


                                          body.instructions = f26BA_parent_instructions;
                                          body.emit(f26BA);

                                          /* END IF */


                                       body.instructions = f26B8_parent_instructions;
                                       body.emit(f26B8);

                                       /* END IF */

                                       body.emit(assign(r26AF, body.constant(0u), 0x01));


                                    body.instructions = f26B4_parent_instructions;
                                    body.emit(f26B4);

                                    /* END IF */

                                    ir_expression *const r26C2 = nequal(r26AB, body.constant(0u));
                                    ir_expression *const r26C3 = expr(ir_unop_b2i, r26C2);
                                    ir_expression *const r26C4 = expr(ir_unop_i2u, r26C3);
                                    body.emit(assign(r26AD, bit_or(r26AD, r26C4), 0x01));


                                 body.instructions = f26B2_parent_instructions;
                                 body.emit(f26B2);

                                 /* END IF */

                                 body.emit(assign(r2687, r26AF, 0x01));

                                 body.emit(assign(r2688, r26AE, 0x01));

                                 body.emit(assign(r2689, r26AD, 0x01));


                              body.instructions = f26A1_parent_instructions;
                              body.emit(f26A1);

                              /* END IF */

                              body.emit(assign(r2686, sub(r2686, r268A), 0x01));

                              ir_variable *const r26C5 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r26C5, r2686, 0x01));

                              ir_variable *const r26C6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r26C6, r2687, 0x01));

                              ir_variable *const r26C7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r26C7, r2688, 0x01));

                              ir_variable *const r26C8 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r26C8, r2689, 0x01));

                              ir_variable *const r26C9 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r26C9, body.constant(true), 0x01));

                              ir_variable *const r26CA = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r26CB = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r26CB);
                              ir_expression *const r26CC = expr(ir_unop_u2i, r2689);
                              body.emit(assign(r26CB, less(r26CC, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r26CE = lequal(body.constant(int(2045)), r2686);
                              ir_if *f26CD = new(mem_ctx) ir_if(operand(r26CE).val);
                              exec_list *const f26CD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26CD->then_instructions;

                                 ir_variable *const r26CF = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r26D1 = less(body.constant(int(2045)), r2686);
                                 ir_if *f26D0 = new(mem_ctx) ir_if(operand(r26D1).val);
                                 exec_list *const f26D0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26D0->then_instructions;

                                    body.emit(assign(r26CF, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26D0->else_instructions;

                                    ir_variable *const r26D2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r26D4 = equal(r2686, body.constant(int(2045)));
                                    ir_if *f26D3 = new(mem_ctx) ir_if(operand(r26D4).val);
                                    exec_list *const f26D3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f26D3->then_instructions;

                                       ir_expression *const r26D5 = equal(body.constant(2097151u), r2687);
                                       ir_expression *const r26D6 = equal(body.constant(4294967295u), r2688);
                                       body.emit(assign(r26D2, logic_and(r26D5, r26D6), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f26D3->else_instructions;

                                       body.emit(assign(r26D2, body.constant(false), 0x01));


                                    body.instructions = f26D3_parent_instructions;
                                    body.emit(f26D3);

                                    /* END IF */

                                    body.emit(assign(r26CF, logic_and(r26D2, r26CB), 0x01));


                                 body.instructions = f26D0_parent_instructions;
                                 body.emit(f26D0);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f26D7 = new(mem_ctx) ir_if(operand(r26CF).val);
                                 exec_list *const f26D7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26D7->then_instructions;

                                    ir_variable *const r26D8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r26D8);
                                    ir_expression *const r26D9 = lshift(r2350, body.constant(int(31)));
                                    body.emit(assign(r26D8, add(r26D9, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r26D8, body.constant(0u), 0x01));

                                    body.emit(assign(r26CA, r26D8, 0x03));

                                    body.emit(assign(r26C9, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26D7->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r26DB = less(r2686, body.constant(int(0)));
                                    ir_if *f26DA = new(mem_ctx) ir_if(operand(r26DB).val);
                                    exec_list *const f26DA_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f26DA->then_instructions;

                                       ir_variable *const r26DC = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r26DC, r2689, 0x01));

                                       ir_variable *const r26DD = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r26DD, neg(r2686), 0x01));

                                       ir_variable *const r26DE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r26DE);
                                       ir_variable *const r26DF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r26DF);
                                       ir_variable *const r26E0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r26E0);
                                       ir_variable *const r26E1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r26E2 = neg(r26DD);
                                       body.emit(assign(r26E1, bit_and(r26E2, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r26E4 = equal(r26DD, body.constant(int(0)));
                                       ir_if *f26E3 = new(mem_ctx) ir_if(operand(r26E4).val);
                                       exec_list *const f26E3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f26E3->then_instructions;

                                          body.emit(assign(r26DE, r2689, 0x01));

                                          body.emit(assign(r26DF, r2688, 0x01));

                                          body.emit(assign(r26E0, r2687, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f26E3->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r26E6 = less(r26DD, body.constant(int(32)));
                                          ir_if *f26E5 = new(mem_ctx) ir_if(operand(r26E6).val);
                                          exec_list *const f26E5_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f26E5->then_instructions;

                                             body.emit(assign(r26DE, lshift(r2688, r26E1), 0x01));

                                             ir_expression *const r26E7 = lshift(r2687, r26E1);
                                             ir_expression *const r26E8 = rshift(r2688, r26DD);
                                             body.emit(assign(r26DF, bit_or(r26E7, r26E8), 0x01));

                                             body.emit(assign(r26E0, rshift(r2687, r26DD), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f26E5->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r26EA = equal(r26DD, body.constant(int(32)));
                                             ir_if *f26E9 = new(mem_ctx) ir_if(operand(r26EA).val);
                                             exec_list *const f26E9_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f26E9->then_instructions;

                                                body.emit(assign(r26DE, r2688, 0x01));

                                                body.emit(assign(r26DF, r2687, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f26E9->else_instructions;

                                                body.emit(assign(r26DC, bit_or(r2689, r2688), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r26EC = less(r26DD, body.constant(int(64)));
                                                ir_if *f26EB = new(mem_ctx) ir_if(operand(r26EC).val);
                                                exec_list *const f26EB_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f26EB->then_instructions;

                                                   body.emit(assign(r26DE, lshift(r2687, r26E1), 0x01));

                                                   ir_expression *const r26ED = bit_and(r26DD, body.constant(int(31)));
                                                   body.emit(assign(r26DF, rshift(r2687, r26ED), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f26EB->else_instructions;

                                                   ir_variable *const r26EE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r26F0 = equal(r26DD, body.constant(int(64)));
                                                   ir_if *f26EF = new(mem_ctx) ir_if(operand(r26F0).val);
                                                   exec_list *const f26EF_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f26EF->then_instructions;

                                                      body.emit(assign(r26EE, r2687, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f26EF->else_instructions;

                                                      ir_expression *const r26F1 = nequal(r2687, body.constant(0u));
                                                      ir_expression *const r26F2 = expr(ir_unop_b2i, r26F1);
                                                      body.emit(assign(r26EE, expr(ir_unop_i2u, r26F2), 0x01));


                                                   body.instructions = f26EF_parent_instructions;
                                                   body.emit(f26EF);

                                                   /* END IF */

                                                   body.emit(assign(r26DE, r26EE, 0x01));

                                                   body.emit(assign(r26DF, body.constant(0u), 0x01));


                                                body.instructions = f26EB_parent_instructions;
                                                body.emit(f26EB);

                                                /* END IF */


                                             body.instructions = f26E9_parent_instructions;
                                             body.emit(f26E9);

                                             /* END IF */

                                             body.emit(assign(r26E0, body.constant(0u), 0x01));


                                          body.instructions = f26E5_parent_instructions;
                                          body.emit(f26E5);

                                          /* END IF */

                                          ir_expression *const r26F3 = nequal(r26DC, body.constant(0u));
                                          ir_expression *const r26F4 = expr(ir_unop_b2i, r26F3);
                                          ir_expression *const r26F5 = expr(ir_unop_i2u, r26F4);
                                          body.emit(assign(r26DE, bit_or(r26DE, r26F5), 0x01));


                                       body.instructions = f26E3_parent_instructions;
                                       body.emit(f26E3);

                                       /* END IF */

                                       body.emit(assign(r26C6, r26E0, 0x01));

                                       body.emit(assign(r26C7, r26DF, 0x01));

                                       body.emit(assign(r26C8, r26DE, 0x01));

                                       body.emit(assign(r26C5, body.constant(int(0)), 0x01));

                                       body.emit(assign(r26CB, less(r26DE, body.constant(0u)), 0x01));


                                    body.instructions = f26DA_parent_instructions;
                                    body.emit(f26DA);

                                    /* END IF */


                                 body.instructions = f26D7_parent_instructions;
                                 body.emit(f26D7);

                                 /* END IF */


                              body.instructions = f26CD_parent_instructions;
                              body.emit(f26CD);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f26F6 = new(mem_ctx) ir_if(operand(r26C9).val);
                              exec_list *const f26F6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26F6->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f26F7 = new(mem_ctx) ir_if(operand(r26CB).val);
                                 exec_list *const f26F7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26F7->then_instructions;

                                    ir_variable *const r26F8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r26F8, add(r26C7, body.constant(1u)), 0x01));

                                    ir_expression *const r26F9 = less(r26F8, r26C7);
                                    ir_expression *const r26FA = expr(ir_unop_b2i, r26F9);
                                    ir_expression *const r26FB = expr(ir_unop_i2u, r26FA);
                                    body.emit(assign(r26C6, add(r26C6, r26FB), 0x01));

                                    ir_expression *const r26FC = equal(r26C8, body.constant(0u));
                                    ir_expression *const r26FD = expr(ir_unop_b2i, r26FC);
                                    ir_expression *const r26FE = expr(ir_unop_i2u, r26FD);
                                    ir_expression *const r26FF = add(r26C8, r26FE);
                                    ir_expression *const r2700 = bit_and(r26FF, body.constant(1u));
                                    ir_expression *const r2701 = expr(ir_unop_bit_not, r2700);
                                    body.emit(assign(r26C7, bit_and(r26F8, r2701), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26F7->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2703 = bit_or(r26C6, r26C7);
                                    ir_expression *const r2704 = equal(r2703, body.constant(0u));
                                    ir_if *f2702 = new(mem_ctx) ir_if(operand(r2704).val);
                                    exec_list *const f2702_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2702->then_instructions;

                                       body.emit(assign(r26C5, body.constant(int(0)), 0x01));


                                    body.instructions = f2702_parent_instructions;
                                    body.emit(f2702);

                                    /* END IF */


                                 body.instructions = f26F7_parent_instructions;
                                 body.emit(f26F7);

                                 /* END IF */

                                 ir_variable *const r2705 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2705);
                                 ir_expression *const r2706 = lshift(r2350, body.constant(int(31)));
                                 ir_expression *const r2707 = expr(ir_unop_i2u, r26C5);
                                 ir_expression *const r2708 = lshift(r2707, body.constant(int(20)));
                                 ir_expression *const r2709 = add(r2706, r2708);
                                 body.emit(assign(r2705, add(r2709, r26C6), 0x02));

                                 body.emit(assign(r2705, r26C7, 0x01));

                                 body.emit(assign(r26CA, r2705, 0x03));

                                 body.emit(assign(r26C9, body.constant(false), 0x01));


                              body.instructions = f26F6_parent_instructions;
                              body.emit(f26F6);

                              /* END IF */

                              body.emit(assign(r2351, r26CA, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f267E->else_instructions;

                              ir_variable *const r270A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r270A);
                              body.emit(assign(r270A, body.constant(0u), 0x02));

                              body.emit(assign(r270A, body.constant(0u), 0x01));

                              body.emit(assign(r2351, r270A, 0x03));


                           body.instructions = f267E_parent_instructions;
                           body.emit(f267E);

                           /* END IF */


                        body.instructions = f25F2_parent_instructions;
                        body.emit(f25F2);

                        /* END IF */


                     body.instructions = f2566_parent_instructions;
                     body.emit(f2566);

                     /* END IF */


                  body.instructions = f24DA_parent_instructions;
                  body.emit(f24DA);

                  /* END IF */


               body.instructions = f24C5_parent_instructions;
               body.emit(f24C5);

               /* END IF */


            body.instructions = f2416_parent_instructions;
            body.emit(f2416);

            /* END IF */


         body.instructions = f2365_parent_instructions;
         body.emit(f2365);

         /* END IF */

         body.emit(assign(r21F3, r2351, 0x03));


      body.instructions = f21F5_parent_instructions;
      body.emit(f21F5);

      /* END IF */

      body.emit(assign(r21F1, r21F3, 0x03));


   body.instructions = f21F2_parent_instructions;
   body.emit(f21F2);

   /* END IF */

   body.emit(ret(r21F1));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffract64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r270B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r270B);
   ir_variable *const r270C = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r270D = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r270E = rshift(swizzle_y(r270B), body.constant(int(20)));
   ir_expression *const r270F = bit_and(r270E, body.constant(2047u));
   ir_expression *const r2710 = expr(ir_unop_u2i, r270F);
   body.emit(assign(r270D, add(r2710, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r2712 = less(r270D, body.constant(int(0)));
   ir_if *f2711 = new(mem_ctx) ir_if(operand(r2712).val);
   exec_list *const f2711_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2711->then_instructions;

      body.emit(assign(r270C, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2711->else_instructions;

      /* IF CONDITION */
      ir_expression *const r2714 = greater(r270D, body.constant(int(52)));
      ir_if *f2713 = new(mem_ctx) ir_if(operand(r2714).val);
      exec_list *const f2713_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2713->then_instructions;

         body.emit(assign(r270C, r270B, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2713->else_instructions;

         ir_variable *const r2715 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2715, sub(body.constant(int(52)), r270D), 0x01));

         ir_variable *const r2716 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r2718 = gequal(r2715, body.constant(int(32)));
         ir_if *f2717 = new(mem_ctx) ir_if(operand(r2718).val);
         exec_list *const f2717_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2717->then_instructions;

            body.emit(assign(r2716, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2717->else_instructions;

            body.emit(assign(r2716, lshift(body.constant(4294967295u), r2715), 0x01));


         body.instructions = f2717_parent_instructions;
         body.emit(f2717);

         /* END IF */

         ir_variable *const r2719 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r271B = less(r2715, body.constant(int(33)));
         ir_if *f271A = new(mem_ctx) ir_if(operand(r271B).val);
         exec_list *const f271A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f271A->then_instructions;

            body.emit(assign(r2719, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f271A->else_instructions;

            ir_expression *const r271C = add(r2715, body.constant(int(-32)));
            body.emit(assign(r2719, lshift(body.constant(4294967295u), r271C), 0x01));


         body.instructions = f271A_parent_instructions;
         body.emit(f271A);

         /* END IF */

         ir_variable *const r271D = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r271D, bit_and(r2716, swizzle_x(r270B)), 0x01));

         body.emit(assign(r271D, bit_and(r2719, swizzle_y(r270B)), 0x02));

         body.emit(assign(r270C, r271D, 0x03));


      body.instructions = f2713_parent_instructions;
      body.emit(f2713);

      /* END IF */


   body.instructions = f2711_parent_instructions;
   body.emit(f2711);

   /* END IF */

   ir_variable *const r271E = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r271F = rshift(swizzle_y(r270B), body.constant(int(31)));
   ir_expression *const r2720 = expr(ir_unop_u2i, r271F);
   body.emit(assign(r271E, expr(ir_unop_i2b, r2720), 0x01));

   ir_variable *const r2721 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r2723 = expr(ir_unop_logic_not, r271E);
   ir_if *f2722 = new(mem_ctx) ir_if(operand(r2723).val);
   exec_list *const f2722_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2722->then_instructions;

      body.emit(assign(r2721, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2722->else_instructions;

      ir_variable *const r2724 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r2725 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r2725);
      ir_variable *const r2726 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r2726);
      ir_expression *const r2727 = rshift(swizzle_y(r270B), body.constant(int(20)));
      ir_expression *const r2728 = bit_and(r2727, body.constant(2047u));
      ir_expression *const r2729 = expr(ir_unop_u2i, r2728);
      ir_expression *const r272A = equal(r2729, body.constant(int(2047)));
      ir_expression *const r272B = bit_and(swizzle_y(r270B), body.constant(1048575u));
      ir_expression *const r272C = bit_or(r272B, swizzle_x(r270B));
      ir_expression *const r272D = nequal(r272C, body.constant(0u));
      body.emit(assign(r2726, logic_and(r272A, r272D), 0x01));

      ir_expression *const r272E = rshift(swizzle_y(r270C), body.constant(int(20)));
      ir_expression *const r272F = bit_and(r272E, body.constant(2047u));
      ir_expression *const r2730 = expr(ir_unop_u2i, r272F);
      ir_expression *const r2731 = equal(r2730, body.constant(int(2047)));
      ir_expression *const r2732 = bit_and(swizzle_y(r270C), body.constant(1048575u));
      ir_expression *const r2733 = bit_or(r2732, swizzle_x(r270C));
      ir_expression *const r2734 = nequal(r2733, body.constant(0u));
      body.emit(assign(r2725, logic_and(r2731, r2734), 0x01));

      /* IF CONDITION */
      ir_expression *const r2736 = logic_or(r2726, r2725);
      ir_if *f2735 = new(mem_ctx) ir_if(operand(r2736).val);
      exec_list *const f2735_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2735->then_instructions;

         body.emit(assign(r2724, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2735->else_instructions;

         ir_expression *const r2737 = equal(swizzle_x(r270B), swizzle_x(r270C));
         ir_expression *const r2738 = equal(swizzle_y(r270B), swizzle_y(r270C));
         ir_expression *const r2739 = equal(swizzle_x(r270B), body.constant(0u));
         ir_expression *const r273A = bit_or(swizzle_y(r270B), swizzle_y(r270C));
         ir_expression *const r273B = lshift(r273A, body.constant(int(1)));
         ir_expression *const r273C = equal(r273B, body.constant(0u));
         ir_expression *const r273D = logic_and(r2739, r273C);
         ir_expression *const r273E = logic_or(r2738, r273D);
         body.emit(assign(r2724, logic_and(r2737, r273E), 0x01));


      body.instructions = f2735_parent_instructions;
      body.emit(f2735);

      /* END IF */

      body.emit(assign(r2721, r2724, 0x01));


   body.instructions = f2722_parent_instructions;
   body.emit(f2722);

   /* END IF */

   ir_variable *const r273F = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f2740 = new(mem_ctx) ir_if(operand(r2721).val);
   exec_list *const f2740_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2740->then_instructions;

      body.emit(assign(r273F, r270C, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2740->else_instructions;

      ir_variable *const r2741 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r2742 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r2742, rshift(swizzle_y(r270C), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r2744 = equal(r2742, body.constant(0u));
      ir_if *f2743 = new(mem_ctx) ir_if(operand(r2744).val);
      exec_list *const f2743_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2743->then_instructions;

         ir_variable *const r2745 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r2745, r2742, 0x01));

         ir_variable *const r2746 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2747 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2747);
         ir_variable *const r2748 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r2748);
         ir_variable *const r2749 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r2749);
         ir_variable *const r274A = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r274A);
         ir_variable *const r274B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r274B);
         ir_variable *const r274C = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r274C);
         ir_variable *const r274D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r274D);
         ir_variable *const r274E = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r274E);
         ir_variable *const r274F = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r274F, body.constant(0u), 0x01));

         ir_variable *const r2750 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2751 = rshift(swizzle_y(r270C), body.constant(int(20)));
         ir_expression *const r2752 = bit_and(r2751, body.constant(2047u));
         body.emit(assign(r2750, expr(ir_unop_u2i, r2752), 0x01));

         body.emit(assign(r2749, r2750, 0x01));

         body.emit(assign(r2748, body.constant(int(1023)), 0x01));

         body.emit(assign(r2747, add(r2750, body.constant(int(-1023))), 0x01));

         ir_variable *const r2753 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r2753, lshift(swizzle_x(r270C), body.constant(int(10))), 0x01));

         ir_variable *const r2754 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r2755 = bit_and(swizzle_y(r270C), body.constant(1048575u));
         ir_expression *const r2756 = lshift(r2755, body.constant(int(10)));
         ir_expression *const r2757 = rshift(swizzle_x(r270C), body.constant(int(22)));
         body.emit(assign(r2754, bit_or(r2756, r2757), 0x01));

         body.emit(assign(r274C, r2754, 0x01));

         body.emit(assign(r274D, r2753, 0x01));

         ir_variable *const r2758 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r2758, body.constant(0u), 0x01));

         ir_variable *const r2759 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r2759, body.constant(0u), 0x01));

         body.emit(assign(r274A, r2759, 0x01));

         body.emit(assign(r274B, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r275B = less(body.constant(int(0)), r2747);
         ir_if *f275A = new(mem_ctx) ir_if(operand(r275B).val);
         exec_list *const f275A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f275A->then_instructions;

            /* IF CONDITION */
            ir_expression *const r275D = equal(r2750, body.constant(int(2047)));
            ir_if *f275C = new(mem_ctx) ir_if(operand(r275D).val);
            exec_list *const f275C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f275C->then_instructions;

               /* IF CONDITION */
               ir_expression *const r275F = bit_or(r2754, r2753);
               ir_expression *const r2760 = nequal(r275F, body.constant(0u));
               ir_if *f275E = new(mem_ctx) ir_if(operand(r2760).val);
               exec_list *const f275E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f275E->then_instructions;

                  ir_variable *const r2761 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2761, swizzle_x(r270C), 0x01));

                  ir_variable *const r2762 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2762, body.constant(0u), 0x01));

                  ir_variable *const r2763 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2761, bit_or(swizzle_y(r270C), body.constant(524288u)), 0x02));

                  body.emit(assign(r2762, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2765 = lshift(swizzle_y(r270C), body.constant(int(1)));
                  ir_expression *const r2766 = lequal(body.constant(4292870144u), r2765);
                  ir_expression *const r2767 = nequal(swizzle_x(r270C), body.constant(0u));
                  ir_expression *const r2768 = bit_and(swizzle_y(r270C), body.constant(1048575u));
                  ir_expression *const r2769 = nequal(r2768, body.constant(0u));
                  ir_expression *const r276A = logic_or(r2767, r2769);
                  ir_expression *const r276B = logic_and(r2766, r276A);
                  ir_if *f2764 = new(mem_ctx) ir_if(operand(r276B).val);
                  exec_list *const f2764_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2764->then_instructions;

                     body.emit(assign(r2763, r2761, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2764->else_instructions;

                     body.emit(assign(r2763, r2762, 0x03));


                  body.instructions = f2764_parent_instructions;
                  body.emit(f2764);

                  /* END IF */

                  body.emit(assign(r2746, r2763, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f275E->else_instructions;

                  body.emit(assign(r2746, r270C, 0x03));


               body.instructions = f275E_parent_instructions;
               body.emit(f275E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f275C->else_instructions;

               body.emit(assign(r274A, body.constant(1073741824u), 0x01));

               ir_variable *const r276C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r276C);
               ir_variable *const r276D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r276D);
               ir_variable *const r276E = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r276F = neg(r2747);
               body.emit(assign(r276E, bit_and(r276F, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2771 = equal(r2747, body.constant(int(0)));
               ir_if *f2770 = new(mem_ctx) ir_if(operand(r2771).val);
               exec_list *const f2770_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2770->then_instructions;

                  body.emit(assign(r276C, body.constant(0u), 0x01));

                  body.emit(assign(r276D, r274A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2770->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2773 = less(r2747, body.constant(int(32)));
                  ir_if *f2772 = new(mem_ctx) ir_if(operand(r2773).val);
                  exec_list *const f2772_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2772->then_instructions;

                     ir_expression *const r2774 = lshift(body.constant(1073741824u), r276E);
                     ir_expression *const r2775 = bit_or(r2774, body.constant(0u));
                     body.emit(assign(r276C, bit_or(r2775, body.constant(0u)), 0x01));

                     body.emit(assign(r276D, rshift(body.constant(1073741824u), r2747), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2772->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2777 = equal(r2747, body.constant(int(32)));
                     ir_if *f2776 = new(mem_ctx) ir_if(operand(r2777).val);
                     exec_list *const f2776_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2776->then_instructions;

                        body.emit(assign(r276C, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2776->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2779 = less(r2747, body.constant(int(64)));
                        ir_if *f2778 = new(mem_ctx) ir_if(operand(r2779).val);
                        exec_list *const f2778_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2778->then_instructions;

                           ir_expression *const r277A = bit_and(r2747, body.constant(int(31)));
                           ir_expression *const r277B = rshift(body.constant(1073741824u), r277A);
                           ir_expression *const r277C = lshift(body.constant(1073741824u), r276E);
                           ir_expression *const r277D = bit_or(r277C, body.constant(0u));
                           ir_expression *const r277E = nequal(r277D, body.constant(0u));
                           ir_expression *const r277F = expr(ir_unop_b2i, r277E);
                           ir_expression *const r2780 = expr(ir_unop_i2u, r277F);
                           body.emit(assign(r276C, bit_or(r277B, r2780), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2778->else_instructions;

                           body.emit(assign(r276C, body.constant(1u), 0x01));


                        body.instructions = f2778_parent_instructions;
                        body.emit(f2778);

                        /* END IF */


                     body.instructions = f2776_parent_instructions;
                     body.emit(f2776);

                     /* END IF */

                     body.emit(assign(r276D, body.constant(0u), 0x01));


                  body.instructions = f2772_parent_instructions;
                  body.emit(f2772);

                  /* END IF */


               body.instructions = f2770_parent_instructions;
               body.emit(f2770);

               /* END IF */

               body.emit(assign(r274A, r276D, 0x01));

               body.emit(assign(r274B, r276C, 0x01));

               body.emit(assign(r274C, bit_or(r2754, body.constant(1073741824u)), 0x01));

               ir_variable *const r2781 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2782 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2782, sub(r2753, r276C), 0x01));

               ir_expression *const r2783 = sub(r274C, r276D);
               ir_expression *const r2784 = less(r2753, r276C);
               ir_expression *const r2785 = expr(ir_unop_b2i, r2784);
               ir_expression *const r2786 = expr(ir_unop_i2u, r2785);
               body.emit(assign(r2781, sub(r2783, r2786), 0x01));

               body.emit(assign(r274E, add(r2750, body.constant(int(-1))), 0x01));

               ir_variable *const r2787 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2787, add(r274E, body.constant(int(-10))), 0x01));

               ir_variable *const r2788 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2788, r2781, 0x01));

               ir_variable *const r2789 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2789, r2782, 0x01));

               ir_variable *const r278A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r278A);
               ir_variable *const r278B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r278B);
               /* IF CONDITION */
               ir_expression *const r278D = equal(r2781, body.constant(0u));
               ir_if *f278C = new(mem_ctx) ir_if(operand(r278D).val);
               exec_list *const f278C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f278C->then_instructions;

                  body.emit(assign(r2788, r2782, 0x01));

                  body.emit(assign(r2789, body.constant(0u), 0x01));

                  body.emit(assign(r2787, add(r2787, body.constant(int(-32))), 0x01));


               body.instructions = f278C_parent_instructions;
               body.emit(f278C);

               /* END IF */

               ir_variable *const r278E = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r278E, r2788, 0x01));

               ir_variable *const r278F = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2790 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2790);
               /* IF CONDITION */
               ir_expression *const r2792 = equal(r2788, body.constant(0u));
               ir_if *f2791 = new(mem_ctx) ir_if(operand(r2792).val);
               exec_list *const f2791_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2791->then_instructions;

                  body.emit(assign(r278F, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2791->else_instructions;

                  body.emit(assign(r2790, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2794 = bit_and(r2788, body.constant(4294901760u));
                  ir_expression *const r2795 = equal(r2794, body.constant(0u));
                  ir_if *f2793 = new(mem_ctx) ir_if(operand(r2795).val);
                  exec_list *const f2793_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2793->then_instructions;

                     body.emit(assign(r2790, body.constant(int(16)), 0x01));

                     body.emit(assign(r278E, lshift(r2788, body.constant(int(16))), 0x01));


                  body.instructions = f2793_parent_instructions;
                  body.emit(f2793);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2797 = bit_and(r278E, body.constant(4278190080u));
                  ir_expression *const r2798 = equal(r2797, body.constant(0u));
                  ir_if *f2796 = new(mem_ctx) ir_if(operand(r2798).val);
                  exec_list *const f2796_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2796->then_instructions;

                     body.emit(assign(r2790, add(r2790, body.constant(int(8))), 0x01));

                     body.emit(assign(r278E, lshift(r278E, body.constant(int(8))), 0x01));


                  body.instructions = f2796_parent_instructions;
                  body.emit(f2796);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r279A = bit_and(r278E, body.constant(4026531840u));
                  ir_expression *const r279B = equal(r279A, body.constant(0u));
                  ir_if *f2799 = new(mem_ctx) ir_if(operand(r279B).val);
                  exec_list *const f2799_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2799->then_instructions;

                     body.emit(assign(r2790, add(r2790, body.constant(int(4))), 0x01));

                     body.emit(assign(r278E, lshift(r278E, body.constant(int(4))), 0x01));


                  body.instructions = f2799_parent_instructions;
                  body.emit(f2799);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r279D = bit_and(r278E, body.constant(3221225472u));
                  ir_expression *const r279E = equal(r279D, body.constant(0u));
                  ir_if *f279C = new(mem_ctx) ir_if(operand(r279E).val);
                  exec_list *const f279C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f279C->then_instructions;

                     body.emit(assign(r2790, add(r2790, body.constant(int(2))), 0x01));

                     body.emit(assign(r278E, lshift(r278E, body.constant(int(2))), 0x01));


                  body.instructions = f279C_parent_instructions;
                  body.emit(f279C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r27A0 = bit_and(r278E, body.constant(2147483648u));
                  ir_expression *const r27A1 = equal(r27A0, body.constant(0u));
                  ir_if *f279F = new(mem_ctx) ir_if(operand(r27A1).val);
                  exec_list *const f279F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f279F->then_instructions;

                     body.emit(assign(r2790, add(r2790, body.constant(int(1))), 0x01));


                  body.instructions = f279F_parent_instructions;
                  body.emit(f279F);

                  /* END IF */

                  body.emit(assign(r278F, r2790, 0x01));


               body.instructions = f2791_parent_instructions;
               body.emit(f2791);

               /* END IF */

               body.emit(assign(r278B, add(r278F, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r27A3 = lequal(body.constant(int(0)), r278B);
               ir_if *f27A2 = new(mem_ctx) ir_if(operand(r27A3).val);
               exec_list *const f27A2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27A2->then_instructions;

                  body.emit(assign(r278A, body.constant(0u), 0x01));

                  ir_variable *const r27A4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r27A4, lshift(r2789, r278B), 0x01));

                  ir_variable *const r27A5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r27A7 = equal(r278B, body.constant(int(0)));
                  ir_if *f27A6 = new(mem_ctx) ir_if(operand(r27A7).val);
                  exec_list *const f27A6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27A6->then_instructions;

                     body.emit(assign(r27A5, r2788, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27A6->else_instructions;

                     ir_expression *const r27A8 = lshift(r2788, r278B);
                     ir_expression *const r27A9 = neg(r278B);
                     ir_expression *const r27AA = bit_and(r27A9, body.constant(int(31)));
                     ir_expression *const r27AB = rshift(r2789, r27AA);
                     body.emit(assign(r27A5, bit_or(r27A8, r27AB), 0x01));


                  body.instructions = f27A6_parent_instructions;
                  body.emit(f27A6);

                  /* END IF */

                  body.emit(assign(r2788, r27A5, 0x01));

                  body.emit(assign(r2789, r27A4, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f27A2->else_instructions;

                  ir_variable *const r27AC = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r27AC, body.constant(0u), 0x01));

                  ir_variable *const r27AD = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r27AD, neg(r278B), 0x01));

                  ir_variable *const r27AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r27AE);
                  ir_variable *const r27AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r27AF);
                  ir_variable *const r27B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r27B0);
                  ir_variable *const r27B1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r27B2 = neg(r27AD);
                  body.emit(assign(r27B1, bit_and(r27B2, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r27B4 = equal(r27AD, body.constant(int(0)));
                  ir_if *f27B3 = new(mem_ctx) ir_if(operand(r27B4).val);
                  exec_list *const f27B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27B3->then_instructions;

                     body.emit(assign(r27AE, r27AC, 0x01));

                     body.emit(assign(r27AF, r2789, 0x01));

                     body.emit(assign(r27B0, r2788, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27B3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r27B6 = less(r27AD, body.constant(int(32)));
                     ir_if *f27B5 = new(mem_ctx) ir_if(operand(r27B6).val);
                     exec_list *const f27B5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f27B5->then_instructions;

                        body.emit(assign(r27AE, lshift(r2789, r27B1), 0x01));

                        ir_expression *const r27B7 = lshift(r2788, r27B1);
                        ir_expression *const r27B8 = rshift(r2789, r27AD);
                        body.emit(assign(r27AF, bit_or(r27B7, r27B8), 0x01));

                        body.emit(assign(r27B0, rshift(r2788, r27AD), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f27B5->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r27BA = equal(r27AD, body.constant(int(32)));
                        ir_if *f27B9 = new(mem_ctx) ir_if(operand(r27BA).val);
                        exec_list *const f27B9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f27B9->then_instructions;

                           body.emit(assign(r27AE, r2789, 0x01));

                           body.emit(assign(r27AF, r2788, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f27B9->else_instructions;

                           body.emit(assign(r27AC, bit_or(body.constant(0u), r2789), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r27BC = less(r27AD, body.constant(int(64)));
                           ir_if *f27BB = new(mem_ctx) ir_if(operand(r27BC).val);
                           exec_list *const f27BB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f27BB->then_instructions;

                              body.emit(assign(r27AE, lshift(r2788, r27B1), 0x01));

                              ir_expression *const r27BD = bit_and(r27AD, body.constant(int(31)));
                              body.emit(assign(r27AF, rshift(r2788, r27BD), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f27BB->else_instructions;

                              ir_variable *const r27BE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r27C0 = equal(r27AD, body.constant(int(64)));
                              ir_if *f27BF = new(mem_ctx) ir_if(operand(r27C0).val);
                              exec_list *const f27BF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27BF->then_instructions;

                                 body.emit(assign(r27BE, r2788, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f27BF->else_instructions;

                                 ir_expression *const r27C1 = nequal(r2788, body.constant(0u));
                                 ir_expression *const r27C2 = expr(ir_unop_b2i, r27C1);
                                 body.emit(assign(r27BE, expr(ir_unop_i2u, r27C2), 0x01));


                              body.instructions = f27BF_parent_instructions;
                              body.emit(f27BF);

                              /* END IF */

                              body.emit(assign(r27AE, r27BE, 0x01));

                              body.emit(assign(r27AF, body.constant(0u), 0x01));


                           body.instructions = f27BB_parent_instructions;
                           body.emit(f27BB);

                           /* END IF */


                        body.instructions = f27B9_parent_instructions;
                        body.emit(f27B9);

                        /* END IF */

                        body.emit(assign(r27B0, body.constant(0u), 0x01));


                     body.instructions = f27B5_parent_instructions;
                     body.emit(f27B5);

                     /* END IF */

                     ir_expression *const r27C3 = nequal(r27AC, body.constant(0u));
                     ir_expression *const r27C4 = expr(ir_unop_b2i, r27C3);
                     ir_expression *const r27C5 = expr(ir_unop_i2u, r27C4);
                     body.emit(assign(r27AE, bit_or(r27AE, r27C5), 0x01));


                  body.instructions = f27B3_parent_instructions;
                  body.emit(f27B3);

                  /* END IF */

                  body.emit(assign(r2788, r27B0, 0x01));

                  body.emit(assign(r2789, r27AF, 0x01));

                  body.emit(assign(r278A, r27AE, 0x01));


               body.instructions = f27A2_parent_instructions;
               body.emit(f27A2);

               /* END IF */

               body.emit(assign(r2787, sub(r2787, r278B), 0x01));

               ir_variable *const r27C6 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r27C6, r2787, 0x01));

               ir_variable *const r27C7 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r27C7, r2788, 0x01));

               ir_variable *const r27C8 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r27C8, r2789, 0x01));

               ir_variable *const r27C9 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r27C9, r278A, 0x01));

               ir_variable *const r27CA = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r27CA, body.constant(true), 0x01));

               ir_variable *const r27CB = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r27CC = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r27CC);
               ir_expression *const r27CD = expr(ir_unop_u2i, r278A);
               body.emit(assign(r27CC, less(r27CD, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r27CF = lequal(body.constant(int(2045)), r2787);
               ir_if *f27CE = new(mem_ctx) ir_if(operand(r27CF).val);
               exec_list *const f27CE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27CE->then_instructions;

                  ir_variable *const r27D0 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r27D2 = less(body.constant(int(2045)), r2787);
                  ir_if *f27D1 = new(mem_ctx) ir_if(operand(r27D2).val);
                  exec_list *const f27D1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27D1->then_instructions;

                     body.emit(assign(r27D0, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27D1->else_instructions;

                     ir_variable *const r27D3 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r27D5 = equal(r2787, body.constant(int(2045)));
                     ir_if *f27D4 = new(mem_ctx) ir_if(operand(r27D5).val);
                     exec_list *const f27D4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f27D4->then_instructions;

                        ir_expression *const r27D6 = equal(body.constant(2097151u), r2788);
                        ir_expression *const r27D7 = equal(body.constant(4294967295u), r2789);
                        body.emit(assign(r27D3, logic_and(r27D6, r27D7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f27D4->else_instructions;

                        body.emit(assign(r27D3, body.constant(false), 0x01));


                     body.instructions = f27D4_parent_instructions;
                     body.emit(f27D4);

                     /* END IF */

                     body.emit(assign(r27D0, logic_and(r27D3, r27CC), 0x01));


                  body.instructions = f27D1_parent_instructions;
                  body.emit(f27D1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f27D8 = new(mem_ctx) ir_if(operand(r27D0).val);
                  exec_list *const f27D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27D8->then_instructions;

                     ir_variable *const r27D9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r27D9);
                     ir_expression *const r27DA = lshift(r2742, body.constant(int(31)));
                     body.emit(assign(r27D9, add(r27DA, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r27D9, body.constant(0u), 0x01));

                     body.emit(assign(r27CB, r27D9, 0x03));

                     body.emit(assign(r27CA, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27D8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r27DC = less(r2787, body.constant(int(0)));
                     ir_if *f27DB = new(mem_ctx) ir_if(operand(r27DC).val);
                     exec_list *const f27DB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f27DB->then_instructions;

                        ir_variable *const r27DD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r27DD, r278A, 0x01));

                        ir_variable *const r27DE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r27DE, neg(r2787), 0x01));

                        ir_variable *const r27DF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r27DF);
                        ir_variable *const r27E0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r27E0);
                        ir_variable *const r27E1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r27E1);
                        ir_variable *const r27E2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r27E3 = neg(r27DE);
                        body.emit(assign(r27E2, bit_and(r27E3, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r27E5 = equal(r27DE, body.constant(int(0)));
                        ir_if *f27E4 = new(mem_ctx) ir_if(operand(r27E5).val);
                        exec_list *const f27E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f27E4->then_instructions;

                           body.emit(assign(r27DF, r278A, 0x01));

                           body.emit(assign(r27E0, r2789, 0x01));

                           body.emit(assign(r27E1, r2788, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f27E4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r27E7 = less(r27DE, body.constant(int(32)));
                           ir_if *f27E6 = new(mem_ctx) ir_if(operand(r27E7).val);
                           exec_list *const f27E6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f27E6->then_instructions;

                              body.emit(assign(r27DF, lshift(r2789, r27E2), 0x01));

                              ir_expression *const r27E8 = lshift(r2788, r27E2);
                              ir_expression *const r27E9 = rshift(r2789, r27DE);
                              body.emit(assign(r27E0, bit_or(r27E8, r27E9), 0x01));

                              body.emit(assign(r27E1, rshift(r2788, r27DE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f27E6->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r27EB = equal(r27DE, body.constant(int(32)));
                              ir_if *f27EA = new(mem_ctx) ir_if(operand(r27EB).val);
                              exec_list *const f27EA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27EA->then_instructions;

                                 body.emit(assign(r27DF, r2789, 0x01));

                                 body.emit(assign(r27E0, r2788, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f27EA->else_instructions;

                                 body.emit(assign(r27DD, bit_or(r278A, r2789), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r27ED = less(r27DE, body.constant(int(64)));
                                 ir_if *f27EC = new(mem_ctx) ir_if(operand(r27ED).val);
                                 exec_list *const f27EC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f27EC->then_instructions;

                                    body.emit(assign(r27DF, lshift(r2788, r27E2), 0x01));

                                    ir_expression *const r27EE = bit_and(r27DE, body.constant(int(31)));
                                    body.emit(assign(r27E0, rshift(r2788, r27EE), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f27EC->else_instructions;

                                    ir_variable *const r27EF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r27F1 = equal(r27DE, body.constant(int(64)));
                                    ir_if *f27F0 = new(mem_ctx) ir_if(operand(r27F1).val);
                                    exec_list *const f27F0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f27F0->then_instructions;

                                       body.emit(assign(r27EF, r2788, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f27F0->else_instructions;

                                       ir_expression *const r27F2 = nequal(r2788, body.constant(0u));
                                       ir_expression *const r27F3 = expr(ir_unop_b2i, r27F2);
                                       body.emit(assign(r27EF, expr(ir_unop_i2u, r27F3), 0x01));


                                    body.instructions = f27F0_parent_instructions;
                                    body.emit(f27F0);

                                    /* END IF */

                                    body.emit(assign(r27DF, r27EF, 0x01));

                                    body.emit(assign(r27E0, body.constant(0u), 0x01));


                                 body.instructions = f27EC_parent_instructions;
                                 body.emit(f27EC);

                                 /* END IF */


                              body.instructions = f27EA_parent_instructions;
                              body.emit(f27EA);

                              /* END IF */

                              body.emit(assign(r27E1, body.constant(0u), 0x01));


                           body.instructions = f27E6_parent_instructions;
                           body.emit(f27E6);

                           /* END IF */

                           ir_expression *const r27F4 = nequal(r27DD, body.constant(0u));
                           ir_expression *const r27F5 = expr(ir_unop_b2i, r27F4);
                           ir_expression *const r27F6 = expr(ir_unop_i2u, r27F5);
                           body.emit(assign(r27DF, bit_or(r27DF, r27F6), 0x01));


                        body.instructions = f27E4_parent_instructions;
                        body.emit(f27E4);

                        /* END IF */

                        body.emit(assign(r27C7, r27E1, 0x01));

                        body.emit(assign(r27C8, r27E0, 0x01));

                        body.emit(assign(r27C9, r27DF, 0x01));

                        body.emit(assign(r27C6, body.constant(int(0)), 0x01));

                        body.emit(assign(r27CC, less(r27DF, body.constant(0u)), 0x01));


                     body.instructions = f27DB_parent_instructions;
                     body.emit(f27DB);

                     /* END IF */


                  body.instructions = f27D8_parent_instructions;
                  body.emit(f27D8);

                  /* END IF */


               body.instructions = f27CE_parent_instructions;
               body.emit(f27CE);

               /* END IF */

               /* IF CONDITION */
               ir_if *f27F7 = new(mem_ctx) ir_if(operand(r27CA).val);
               exec_list *const f27F7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27F7->then_instructions;

                  /* IF CONDITION */
                  ir_if *f27F8 = new(mem_ctx) ir_if(operand(r27CC).val);
                  exec_list *const f27F8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27F8->then_instructions;

                     ir_variable *const r27F9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r27F9, add(r27C8, body.constant(1u)), 0x01));

                     ir_expression *const r27FA = less(r27F9, r27C8);
                     ir_expression *const r27FB = expr(ir_unop_b2i, r27FA);
                     ir_expression *const r27FC = expr(ir_unop_i2u, r27FB);
                     body.emit(assign(r27C7, add(r27C7, r27FC), 0x01));

                     ir_expression *const r27FD = equal(r27C9, body.constant(0u));
                     ir_expression *const r27FE = expr(ir_unop_b2i, r27FD);
                     ir_expression *const r27FF = expr(ir_unop_i2u, r27FE);
                     ir_expression *const r2800 = add(r27C9, r27FF);
                     ir_expression *const r2801 = bit_and(r2800, body.constant(1u));
                     ir_expression *const r2802 = expr(ir_unop_bit_not, r2801);
                     body.emit(assign(r27C8, bit_and(r27F9, r2802), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27F8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2804 = bit_or(r27C7, r27C8);
                     ir_expression *const r2805 = equal(r2804, body.constant(0u));
                     ir_if *f2803 = new(mem_ctx) ir_if(operand(r2805).val);
                     exec_list *const f2803_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2803->then_instructions;

                        body.emit(assign(r27C6, body.constant(int(0)), 0x01));


                     body.instructions = f2803_parent_instructions;
                     body.emit(f2803);

                     /* END IF */


                  body.instructions = f27F8_parent_instructions;
                  body.emit(f27F8);

                  /* END IF */

                  ir_variable *const r2806 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2806);
                  ir_expression *const r2807 = lshift(r2742, body.constant(int(31)));
                  ir_expression *const r2808 = expr(ir_unop_i2u, r27C6);
                  ir_expression *const r2809 = lshift(r2808, body.constant(int(20)));
                  ir_expression *const r280A = add(r2807, r2809);
                  body.emit(assign(r2806, add(r280A, r27C7), 0x02));

                  body.emit(assign(r2806, r27C8, 0x01));

                  body.emit(assign(r27CB, r2806, 0x03));

                  body.emit(assign(r27CA, body.constant(false), 0x01));


               body.instructions = f27F7_parent_instructions;
               body.emit(f27F7);

               /* END IF */

               body.emit(assign(r2746, r27CB, 0x03));


            body.instructions = f275C_parent_instructions;
            body.emit(f275C);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f275A->else_instructions;

            /* IF CONDITION */
            ir_expression *const r280C = less(r2747, body.constant(int(0)));
            ir_if *f280B = new(mem_ctx) ir_if(operand(r280C).val);
            exec_list *const f280B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f280B->then_instructions;

               /* IF CONDITION */
               ir_expression *const r280E = equal(r2750, body.constant(int(0)));
               ir_if *f280D = new(mem_ctx) ir_if(operand(r280E).val);
               exec_list *const f280D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f280D->then_instructions;

                  body.emit(assign(r2747, add(r2747, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f280D->else_instructions;

                  body.emit(assign(r274C, bit_or(r274C, body.constant(1073741824u)), 0x01));


               body.instructions = f280D_parent_instructions;
               body.emit(f280D);

               /* END IF */

               ir_variable *const r280F = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r280F, neg(r2747), 0x01));

               ir_variable *const r2810 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2810);
               ir_variable *const r2811 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2811);
               ir_variable *const r2812 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2813 = neg(r280F);
               body.emit(assign(r2812, bit_and(r2813, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2815 = equal(r280F, body.constant(int(0)));
               ir_if *f2814 = new(mem_ctx) ir_if(operand(r2815).val);
               exec_list *const f2814_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2814->then_instructions;

                  body.emit(assign(r2810, r2753, 0x01));

                  body.emit(assign(r2811, r274C, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2814->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2817 = less(r280F, body.constant(int(32)));
                  ir_if *f2816 = new(mem_ctx) ir_if(operand(r2817).val);
                  exec_list *const f2816_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2816->then_instructions;

                     ir_expression *const r2818 = lshift(r274C, r2812);
                     ir_expression *const r2819 = rshift(r2753, r280F);
                     ir_expression *const r281A = bit_or(r2818, r2819);
                     ir_expression *const r281B = lshift(r2753, r2812);
                     ir_expression *const r281C = nequal(r281B, body.constant(0u));
                     ir_expression *const r281D = expr(ir_unop_b2i, r281C);
                     ir_expression *const r281E = expr(ir_unop_i2u, r281D);
                     body.emit(assign(r2810, bit_or(r281A, r281E), 0x01));

                     body.emit(assign(r2811, rshift(r274C, r280F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2816->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2820 = equal(r280F, body.constant(int(32)));
                     ir_if *f281F = new(mem_ctx) ir_if(operand(r2820).val);
                     exec_list *const f281F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f281F->then_instructions;

                        ir_expression *const r2821 = nequal(r2753, body.constant(0u));
                        ir_expression *const r2822 = expr(ir_unop_b2i, r2821);
                        ir_expression *const r2823 = expr(ir_unop_i2u, r2822);
                        body.emit(assign(r2810, bit_or(r274C, r2823), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f281F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2825 = less(r280F, body.constant(int(64)));
                        ir_if *f2824 = new(mem_ctx) ir_if(operand(r2825).val);
                        exec_list *const f2824_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2824->then_instructions;

                           ir_expression *const r2826 = bit_and(r280F, body.constant(int(31)));
                           ir_expression *const r2827 = rshift(r274C, r2826);
                           ir_expression *const r2828 = lshift(r274C, r2812);
                           ir_expression *const r2829 = bit_or(r2828, r2753);
                           ir_expression *const r282A = nequal(r2829, body.constant(0u));
                           ir_expression *const r282B = expr(ir_unop_b2i, r282A);
                           ir_expression *const r282C = expr(ir_unop_i2u, r282B);
                           body.emit(assign(r2810, bit_or(r2827, r282C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2824->else_instructions;

                           ir_expression *const r282D = bit_or(r274C, r2753);
                           ir_expression *const r282E = nequal(r282D, body.constant(0u));
                           ir_expression *const r282F = expr(ir_unop_b2i, r282E);
                           body.emit(assign(r2810, expr(ir_unop_i2u, r282F), 0x01));


                        body.instructions = f2824_parent_instructions;
                        body.emit(f2824);

                        /* END IF */


                     body.instructions = f281F_parent_instructions;
                     body.emit(f281F);

                     /* END IF */

                     body.emit(assign(r2811, body.constant(0u), 0x01));


                  body.instructions = f2816_parent_instructions;
                  body.emit(f2816);

                  /* END IF */


               body.instructions = f2814_parent_instructions;
               body.emit(f2814);

               /* END IF */

               body.emit(assign(r274C, r2811, 0x01));

               body.emit(assign(r274D, r2810, 0x01));

               body.emit(assign(r274A, bit_or(r274A, body.constant(1073741824u)), 0x01));

               ir_variable *const r2830 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2831 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2831, sub(r274B, r2810), 0x01));

               ir_expression *const r2832 = sub(r274A, r2811);
               ir_expression *const r2833 = less(r274B, r2810);
               ir_expression *const r2834 = expr(ir_unop_b2i, r2833);
               ir_expression *const r2835 = expr(ir_unop_i2u, r2834);
               body.emit(assign(r2830, sub(r2832, r2835), 0x01));

               body.emit(assign(r2745, bit_xor(r2742, body.constant(1u)), 0x01));

               body.emit(assign(r274E, body.constant(int(1022)), 0x01));

               ir_variable *const r2836 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2836, body.constant(int(1012)), 0x01));

               ir_variable *const r2837 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2837, r2830, 0x01));

               ir_variable *const r2838 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2838, r2831, 0x01));

               ir_variable *const r2839 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2839);
               ir_variable *const r283A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r283A);
               /* IF CONDITION */
               ir_expression *const r283C = equal(r2830, body.constant(0u));
               ir_if *f283B = new(mem_ctx) ir_if(operand(r283C).val);
               exec_list *const f283B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f283B->then_instructions;

                  body.emit(assign(r2837, r2831, 0x01));

                  body.emit(assign(r2838, body.constant(0u), 0x01));

                  body.emit(assign(r2836, body.constant(int(980)), 0x01));


               body.instructions = f283B_parent_instructions;
               body.emit(f283B);

               /* END IF */

               ir_variable *const r283D = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r283D, r2837, 0x01));

               ir_variable *const r283E = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r283F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r283F);
               /* IF CONDITION */
               ir_expression *const r2841 = equal(r2837, body.constant(0u));
               ir_if *f2840 = new(mem_ctx) ir_if(operand(r2841).val);
               exec_list *const f2840_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2840->then_instructions;

                  body.emit(assign(r283E, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2840->else_instructions;

                  body.emit(assign(r283F, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2843 = bit_and(r2837, body.constant(4294901760u));
                  ir_expression *const r2844 = equal(r2843, body.constant(0u));
                  ir_if *f2842 = new(mem_ctx) ir_if(operand(r2844).val);
                  exec_list *const f2842_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2842->then_instructions;

                     body.emit(assign(r283F, body.constant(int(16)), 0x01));

                     body.emit(assign(r283D, lshift(r2837, body.constant(int(16))), 0x01));


                  body.instructions = f2842_parent_instructions;
                  body.emit(f2842);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2846 = bit_and(r283D, body.constant(4278190080u));
                  ir_expression *const r2847 = equal(r2846, body.constant(0u));
                  ir_if *f2845 = new(mem_ctx) ir_if(operand(r2847).val);
                  exec_list *const f2845_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2845->then_instructions;

                     body.emit(assign(r283F, add(r283F, body.constant(int(8))), 0x01));

                     body.emit(assign(r283D, lshift(r283D, body.constant(int(8))), 0x01));


                  body.instructions = f2845_parent_instructions;
                  body.emit(f2845);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2849 = bit_and(r283D, body.constant(4026531840u));
                  ir_expression *const r284A = equal(r2849, body.constant(0u));
                  ir_if *f2848 = new(mem_ctx) ir_if(operand(r284A).val);
                  exec_list *const f2848_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2848->then_instructions;

                     body.emit(assign(r283F, add(r283F, body.constant(int(4))), 0x01));

                     body.emit(assign(r283D, lshift(r283D, body.constant(int(4))), 0x01));


                  body.instructions = f2848_parent_instructions;
                  body.emit(f2848);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r284C = bit_and(r283D, body.constant(3221225472u));
                  ir_expression *const r284D = equal(r284C, body.constant(0u));
                  ir_if *f284B = new(mem_ctx) ir_if(operand(r284D).val);
                  exec_list *const f284B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f284B->then_instructions;

                     body.emit(assign(r283F, add(r283F, body.constant(int(2))), 0x01));

                     body.emit(assign(r283D, lshift(r283D, body.constant(int(2))), 0x01));


                  body.instructions = f284B_parent_instructions;
                  body.emit(f284B);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r284F = bit_and(r283D, body.constant(2147483648u));
                  ir_expression *const r2850 = equal(r284F, body.constant(0u));
                  ir_if *f284E = new(mem_ctx) ir_if(operand(r2850).val);
                  exec_list *const f284E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f284E->then_instructions;

                     body.emit(assign(r283F, add(r283F, body.constant(int(1))), 0x01));


                  body.instructions = f284E_parent_instructions;
                  body.emit(f284E);

                  /* END IF */

                  body.emit(assign(r283E, r283F, 0x01));


               body.instructions = f2840_parent_instructions;
               body.emit(f2840);

               /* END IF */

               body.emit(assign(r283A, add(r283E, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2852 = lequal(body.constant(int(0)), r283A);
               ir_if *f2851 = new(mem_ctx) ir_if(operand(r2852).val);
               exec_list *const f2851_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2851->then_instructions;

                  body.emit(assign(r2839, body.constant(0u), 0x01));

                  ir_variable *const r2853 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2853, lshift(r2838, r283A), 0x01));

                  ir_variable *const r2854 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2856 = equal(r283A, body.constant(int(0)));
                  ir_if *f2855 = new(mem_ctx) ir_if(operand(r2856).val);
                  exec_list *const f2855_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2855->then_instructions;

                     body.emit(assign(r2854, r2837, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2855->else_instructions;

                     ir_expression *const r2857 = lshift(r2837, r283A);
                     ir_expression *const r2858 = neg(r283A);
                     ir_expression *const r2859 = bit_and(r2858, body.constant(int(31)));
                     ir_expression *const r285A = rshift(r2838, r2859);
                     body.emit(assign(r2854, bit_or(r2857, r285A), 0x01));


                  body.instructions = f2855_parent_instructions;
                  body.emit(f2855);

                  /* END IF */

                  body.emit(assign(r2837, r2854, 0x01));

                  body.emit(assign(r2838, r2853, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2851->else_instructions;

                  ir_variable *const r285B = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r285B, body.constant(0u), 0x01));

                  ir_variable *const r285C = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r285C, neg(r283A), 0x01));

                  ir_variable *const r285D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r285D);
                  ir_variable *const r285E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r285E);
                  ir_variable *const r285F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r285F);
                  ir_variable *const r2860 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2861 = neg(r285C);
                  body.emit(assign(r2860, bit_and(r2861, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2863 = equal(r285C, body.constant(int(0)));
                  ir_if *f2862 = new(mem_ctx) ir_if(operand(r2863).val);
                  exec_list *const f2862_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2862->then_instructions;

                     body.emit(assign(r285D, r285B, 0x01));

                     body.emit(assign(r285E, r2838, 0x01));

                     body.emit(assign(r285F, r2837, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2862->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2865 = less(r285C, body.constant(int(32)));
                     ir_if *f2864 = new(mem_ctx) ir_if(operand(r2865).val);
                     exec_list *const f2864_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2864->then_instructions;

                        body.emit(assign(r285D, lshift(r2838, r2860), 0x01));

                        ir_expression *const r2866 = lshift(r2837, r2860);
                        ir_expression *const r2867 = rshift(r2838, r285C);
                        body.emit(assign(r285E, bit_or(r2866, r2867), 0x01));

                        body.emit(assign(r285F, rshift(r2837, r285C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2864->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2869 = equal(r285C, body.constant(int(32)));
                        ir_if *f2868 = new(mem_ctx) ir_if(operand(r2869).val);
                        exec_list *const f2868_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2868->then_instructions;

                           body.emit(assign(r285D, r2838, 0x01));

                           body.emit(assign(r285E, r2837, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2868->else_instructions;

                           body.emit(assign(r285B, bit_or(body.constant(0u), r2838), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r286B = less(r285C, body.constant(int(64)));
                           ir_if *f286A = new(mem_ctx) ir_if(operand(r286B).val);
                           exec_list *const f286A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f286A->then_instructions;

                              body.emit(assign(r285D, lshift(r2837, r2860), 0x01));

                              ir_expression *const r286C = bit_and(r285C, body.constant(int(31)));
                              body.emit(assign(r285E, rshift(r2837, r286C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f286A->else_instructions;

                              ir_variable *const r286D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r286F = equal(r285C, body.constant(int(64)));
                              ir_if *f286E = new(mem_ctx) ir_if(operand(r286F).val);
                              exec_list *const f286E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f286E->then_instructions;

                                 body.emit(assign(r286D, r2837, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f286E->else_instructions;

                                 ir_expression *const r2870 = nequal(r2837, body.constant(0u));
                                 ir_expression *const r2871 = expr(ir_unop_b2i, r2870);
                                 body.emit(assign(r286D, expr(ir_unop_i2u, r2871), 0x01));


                              body.instructions = f286E_parent_instructions;
                              body.emit(f286E);

                              /* END IF */

                              body.emit(assign(r285D, r286D, 0x01));

                              body.emit(assign(r285E, body.constant(0u), 0x01));


                           body.instructions = f286A_parent_instructions;
                           body.emit(f286A);

                           /* END IF */


                        body.instructions = f2868_parent_instructions;
                        body.emit(f2868);

                        /* END IF */

                        body.emit(assign(r285F, body.constant(0u), 0x01));


                     body.instructions = f2864_parent_instructions;
                     body.emit(f2864);

                     /* END IF */

                     ir_expression *const r2872 = nequal(r285B, body.constant(0u));
                     ir_expression *const r2873 = expr(ir_unop_b2i, r2872);
                     ir_expression *const r2874 = expr(ir_unop_i2u, r2873);
                     body.emit(assign(r285D, bit_or(r285D, r2874), 0x01));


                  body.instructions = f2862_parent_instructions;
                  body.emit(f2862);

                  /* END IF */

                  body.emit(assign(r2837, r285F, 0x01));

                  body.emit(assign(r2838, r285E, 0x01));

                  body.emit(assign(r2839, r285D, 0x01));


               body.instructions = f2851_parent_instructions;
               body.emit(f2851);

               /* END IF */

               body.emit(assign(r2836, sub(r2836, r283A), 0x01));

               ir_variable *const r2875 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2875, r2836, 0x01));

               ir_variable *const r2876 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2876, r2837, 0x01));

               ir_variable *const r2877 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2877, r2838, 0x01));

               ir_variable *const r2878 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2878, r2839, 0x01));

               ir_variable *const r2879 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2879, body.constant(true), 0x01));

               ir_variable *const r287A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r287B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r287B);
               ir_expression *const r287C = expr(ir_unop_u2i, r2839);
               body.emit(assign(r287B, less(r287C, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r287E = lequal(body.constant(int(2045)), r2836);
               ir_if *f287D = new(mem_ctx) ir_if(operand(r287E).val);
               exec_list *const f287D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f287D->then_instructions;

                  ir_variable *const r287F = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2881 = less(body.constant(int(2045)), r2836);
                  ir_if *f2880 = new(mem_ctx) ir_if(operand(r2881).val);
                  exec_list *const f2880_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2880->then_instructions;

                     body.emit(assign(r287F, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2880->else_instructions;

                     ir_variable *const r2882 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2884 = equal(r2836, body.constant(int(2045)));
                     ir_if *f2883 = new(mem_ctx) ir_if(operand(r2884).val);
                     exec_list *const f2883_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2883->then_instructions;

                        ir_expression *const r2885 = equal(body.constant(2097151u), r2837);
                        ir_expression *const r2886 = equal(body.constant(4294967295u), r2838);
                        body.emit(assign(r2882, logic_and(r2885, r2886), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2883->else_instructions;

                        body.emit(assign(r2882, body.constant(false), 0x01));


                     body.instructions = f2883_parent_instructions;
                     body.emit(f2883);

                     /* END IF */

                     body.emit(assign(r287F, logic_and(r2882, r287B), 0x01));


                  body.instructions = f2880_parent_instructions;
                  body.emit(f2880);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2887 = new(mem_ctx) ir_if(operand(r287F).val);
                  exec_list *const f2887_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2887->then_instructions;

                     ir_variable *const r2888 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2888);
                     ir_expression *const r2889 = lshift(r2745, body.constant(int(31)));
                     body.emit(assign(r2888, add(r2889, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2888, body.constant(0u), 0x01));

                     body.emit(assign(r287A, r2888, 0x03));

                     body.emit(assign(r2879, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2887->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r288B = less(r2836, body.constant(int(0)));
                     ir_if *f288A = new(mem_ctx) ir_if(operand(r288B).val);
                     exec_list *const f288A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f288A->then_instructions;

                        ir_variable *const r288C = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r288C, r2839, 0x01));

                        ir_variable *const r288D = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r288D, neg(r2836), 0x01));

                        ir_variable *const r288E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r288E);
                        ir_variable *const r288F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r288F);
                        ir_variable *const r2890 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2890);
                        ir_variable *const r2891 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2892 = neg(r288D);
                        body.emit(assign(r2891, bit_and(r2892, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2894 = equal(r288D, body.constant(int(0)));
                        ir_if *f2893 = new(mem_ctx) ir_if(operand(r2894).val);
                        exec_list *const f2893_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2893->then_instructions;

                           body.emit(assign(r288E, r2839, 0x01));

                           body.emit(assign(r288F, r2838, 0x01));

                           body.emit(assign(r2890, r2837, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2893->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2896 = less(r288D, body.constant(int(32)));
                           ir_if *f2895 = new(mem_ctx) ir_if(operand(r2896).val);
                           exec_list *const f2895_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2895->then_instructions;

                              body.emit(assign(r288E, lshift(r2838, r2891), 0x01));

                              ir_expression *const r2897 = lshift(r2837, r2891);
                              ir_expression *const r2898 = rshift(r2838, r288D);
                              body.emit(assign(r288F, bit_or(r2897, r2898), 0x01));

                              body.emit(assign(r2890, rshift(r2837, r288D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2895->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r289A = equal(r288D, body.constant(int(32)));
                              ir_if *f2899 = new(mem_ctx) ir_if(operand(r289A).val);
                              exec_list *const f2899_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2899->then_instructions;

                                 body.emit(assign(r288E, r2838, 0x01));

                                 body.emit(assign(r288F, r2837, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2899->else_instructions;

                                 body.emit(assign(r288C, bit_or(r2839, r2838), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r289C = less(r288D, body.constant(int(64)));
                                 ir_if *f289B = new(mem_ctx) ir_if(operand(r289C).val);
                                 exec_list *const f289B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f289B->then_instructions;

                                    body.emit(assign(r288E, lshift(r2837, r2891), 0x01));

                                    ir_expression *const r289D = bit_and(r288D, body.constant(int(31)));
                                    body.emit(assign(r288F, rshift(r2837, r289D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f289B->else_instructions;

                                    ir_variable *const r289E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r28A0 = equal(r288D, body.constant(int(64)));
                                    ir_if *f289F = new(mem_ctx) ir_if(operand(r28A0).val);
                                    exec_list *const f289F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f289F->then_instructions;

                                       body.emit(assign(r289E, r2837, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f289F->else_instructions;

                                       ir_expression *const r28A1 = nequal(r2837, body.constant(0u));
                                       ir_expression *const r28A2 = expr(ir_unop_b2i, r28A1);
                                       body.emit(assign(r289E, expr(ir_unop_i2u, r28A2), 0x01));


                                    body.instructions = f289F_parent_instructions;
                                    body.emit(f289F);

                                    /* END IF */

                                    body.emit(assign(r288E, r289E, 0x01));

                                    body.emit(assign(r288F, body.constant(0u), 0x01));


                                 body.instructions = f289B_parent_instructions;
                                 body.emit(f289B);

                                 /* END IF */


                              body.instructions = f2899_parent_instructions;
                              body.emit(f2899);

                              /* END IF */

                              body.emit(assign(r2890, body.constant(0u), 0x01));


                           body.instructions = f2895_parent_instructions;
                           body.emit(f2895);

                           /* END IF */

                           ir_expression *const r28A3 = nequal(r288C, body.constant(0u));
                           ir_expression *const r28A4 = expr(ir_unop_b2i, r28A3);
                           ir_expression *const r28A5 = expr(ir_unop_i2u, r28A4);
                           body.emit(assign(r288E, bit_or(r288E, r28A5), 0x01));


                        body.instructions = f2893_parent_instructions;
                        body.emit(f2893);

                        /* END IF */

                        body.emit(assign(r2876, r2890, 0x01));

                        body.emit(assign(r2877, r288F, 0x01));

                        body.emit(assign(r2878, r288E, 0x01));

                        body.emit(assign(r2875, body.constant(int(0)), 0x01));

                        body.emit(assign(r287B, less(r288E, body.constant(0u)), 0x01));


                     body.instructions = f288A_parent_instructions;
                     body.emit(f288A);

                     /* END IF */


                  body.instructions = f2887_parent_instructions;
                  body.emit(f2887);

                  /* END IF */


               body.instructions = f287D_parent_instructions;
               body.emit(f287D);

               /* END IF */

               /* IF CONDITION */
               ir_if *f28A6 = new(mem_ctx) ir_if(operand(r2879).val);
               exec_list *const f28A6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f28A6->then_instructions;

                  /* IF CONDITION */
                  ir_if *f28A7 = new(mem_ctx) ir_if(operand(r287B).val);
                  exec_list *const f28A7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28A7->then_instructions;

                     ir_variable *const r28A8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r28A8, add(r2877, body.constant(1u)), 0x01));

                     ir_expression *const r28A9 = less(r28A8, r2877);
                     ir_expression *const r28AA = expr(ir_unop_b2i, r28A9);
                     ir_expression *const r28AB = expr(ir_unop_i2u, r28AA);
                     body.emit(assign(r2876, add(r2876, r28AB), 0x01));

                     ir_expression *const r28AC = equal(r2878, body.constant(0u));
                     ir_expression *const r28AD = expr(ir_unop_b2i, r28AC);
                     ir_expression *const r28AE = expr(ir_unop_i2u, r28AD);
                     ir_expression *const r28AF = add(r2878, r28AE);
                     ir_expression *const r28B0 = bit_and(r28AF, body.constant(1u));
                     ir_expression *const r28B1 = expr(ir_unop_bit_not, r28B0);
                     body.emit(assign(r2877, bit_and(r28A8, r28B1), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f28A7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r28B3 = bit_or(r2876, r2877);
                     ir_expression *const r28B4 = equal(r28B3, body.constant(0u));
                     ir_if *f28B2 = new(mem_ctx) ir_if(operand(r28B4).val);
                     exec_list *const f28B2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28B2->then_instructions;

                        body.emit(assign(r2875, body.constant(int(0)), 0x01));


                     body.instructions = f28B2_parent_instructions;
                     body.emit(f28B2);

                     /* END IF */


                  body.instructions = f28A7_parent_instructions;
                  body.emit(f28A7);

                  /* END IF */

                  ir_variable *const r28B5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r28B5);
                  ir_expression *const r28B6 = lshift(r2745, body.constant(int(31)));
                  ir_expression *const r28B7 = expr(ir_unop_i2u, r2875);
                  ir_expression *const r28B8 = lshift(r28B7, body.constant(int(20)));
                  ir_expression *const r28B9 = add(r28B6, r28B8);
                  body.emit(assign(r28B5, add(r28B9, r2876), 0x02));

                  body.emit(assign(r28B5, r2877, 0x01));

                  body.emit(assign(r287A, r28B5, 0x03));

                  body.emit(assign(r2879, body.constant(false), 0x01));


               body.instructions = f28A6_parent_instructions;
               body.emit(f28A6);

               /* END IF */

               body.emit(assign(r2746, r287A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f280B->else_instructions;

               /* IF CONDITION */
               ir_expression *const r28BB = equal(r2750, body.constant(int(2047)));
               ir_if *f28BA = new(mem_ctx) ir_if(operand(r28BB).val);
               exec_list *const f28BA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f28BA->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r28BD = bit_or(r274C, r274D);
                  ir_expression *const r28BE = bit_or(r274A, r274B);
                  ir_expression *const r28BF = bit_or(r28BD, r28BE);
                  ir_expression *const r28C0 = nequal(r28BF, body.constant(0u));
                  ir_if *f28BC = new(mem_ctx) ir_if(operand(r28C0).val);
                  exec_list *const f28BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28BC->then_instructions;

                     ir_variable *const r28C1 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r28C1, swizzle_x(r270C), 0x01));

                     ir_variable *const r28C2 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r28C2, body.constant(0u), 0x01));

                     ir_variable *const r28C3 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r28C1, bit_or(swizzle_y(r270C), body.constant(524288u)), 0x02));

                     body.emit(assign(r28C2, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r28C5 = lshift(swizzle_y(r270C), body.constant(int(1)));
                     ir_expression *const r28C6 = lequal(body.constant(4292870144u), r28C5);
                     ir_expression *const r28C7 = nequal(swizzle_x(r270C), body.constant(0u));
                     ir_expression *const r28C8 = bit_and(swizzle_y(r270C), body.constant(1048575u));
                     ir_expression *const r28C9 = nequal(r28C8, body.constant(0u));
                     ir_expression *const r28CA = logic_or(r28C7, r28C9);
                     ir_expression *const r28CB = logic_and(r28C6, r28CA);
                     ir_if *f28C4 = new(mem_ctx) ir_if(operand(r28CB).val);
                     exec_list *const f28C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28C4->then_instructions;

                        body.emit(assign(r28C3, r28C1, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28C4->else_instructions;

                        body.emit(assign(r28C3, r28C2, 0x03));


                     body.instructions = f28C4_parent_instructions;
                     body.emit(f28C4);

                     /* END IF */

                     body.emit(assign(r2746, r28C3, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f28BC->else_instructions;

                     ir_constant_data r28CC_data;
                     memset(&r28CC_data, 0, sizeof(ir_constant_data));
                     r28CC_data.u[0] = 4294967295;
                     r28CC_data.u[1] = 4294967295;
                     ir_constant *const r28CC = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r28CC_data);
                     body.emit(assign(r2746, r28CC, 0x03));


                  body.instructions = f28BC_parent_instructions;
                  body.emit(f28BC);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f28BA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r28CE = equal(r2750, body.constant(int(0)));
                  ir_if *f28CD = new(mem_ctx) ir_if(operand(r28CE).val);
                  exec_list *const f28CD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28CD->then_instructions;

                     body.emit(assign(r2749, body.constant(int(1)), 0x01));

                     body.emit(assign(r2748, body.constant(int(1)), 0x01));


                  body.instructions = f28CD_parent_instructions;
                  body.emit(f28CD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r28D0 = less(r274A, r274C);
                  ir_if *f28CF = new(mem_ctx) ir_if(operand(r28D0).val);
                  exec_list *const f28CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28CF->then_instructions;

                     ir_variable *const r28D1 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r28D2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r28D2, sub(r274D, r274B), 0x01));

                     ir_expression *const r28D3 = sub(r274C, r274A);
                     ir_expression *const r28D4 = less(r274D, r274B);
                     ir_expression *const r28D5 = expr(ir_unop_b2i, r28D4);
                     ir_expression *const r28D6 = expr(ir_unop_i2u, r28D5);
                     body.emit(assign(r28D1, sub(r28D3, r28D6), 0x01));

                     body.emit(assign(r274E, add(r2749, body.constant(int(-1))), 0x01));

                     ir_variable *const r28D7 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r28D7, add(r274E, body.constant(int(-10))), 0x01));

                     ir_variable *const r28D8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r28D8, r28D1, 0x01));

                     ir_variable *const r28D9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r28D9, r28D2, 0x01));

                     ir_variable *const r28DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r28DA);
                     ir_variable *const r28DB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r28DB);
                     /* IF CONDITION */
                     ir_expression *const r28DD = equal(r28D1, body.constant(0u));
                     ir_if *f28DC = new(mem_ctx) ir_if(operand(r28DD).val);
                     exec_list *const f28DC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28DC->then_instructions;

                        body.emit(assign(r28D8, r28D2, 0x01));

                        body.emit(assign(r28D9, body.constant(0u), 0x01));

                        body.emit(assign(r28D7, add(r28D7, body.constant(int(-32))), 0x01));


                     body.instructions = f28DC_parent_instructions;
                     body.emit(f28DC);

                     /* END IF */

                     ir_variable *const r28DE = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r28DE, r28D8, 0x01));

                     ir_variable *const r28DF = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r28E0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r28E0);
                     /* IF CONDITION */
                     ir_expression *const r28E2 = equal(r28D8, body.constant(0u));
                     ir_if *f28E1 = new(mem_ctx) ir_if(operand(r28E2).val);
                     exec_list *const f28E1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28E1->then_instructions;

                        body.emit(assign(r28DF, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28E1->else_instructions;

                        body.emit(assign(r28E0, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r28E4 = bit_and(r28D8, body.constant(4294901760u));
                        ir_expression *const r28E5 = equal(r28E4, body.constant(0u));
                        ir_if *f28E3 = new(mem_ctx) ir_if(operand(r28E5).val);
                        exec_list *const f28E3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28E3->then_instructions;

                           body.emit(assign(r28E0, body.constant(int(16)), 0x01));

                           body.emit(assign(r28DE, lshift(r28D8, body.constant(int(16))), 0x01));


                        body.instructions = f28E3_parent_instructions;
                        body.emit(f28E3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r28E7 = bit_and(r28DE, body.constant(4278190080u));
                        ir_expression *const r28E8 = equal(r28E7, body.constant(0u));
                        ir_if *f28E6 = new(mem_ctx) ir_if(operand(r28E8).val);
                        exec_list *const f28E6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28E6->then_instructions;

                           body.emit(assign(r28E0, add(r28E0, body.constant(int(8))), 0x01));

                           body.emit(assign(r28DE, lshift(r28DE, body.constant(int(8))), 0x01));


                        body.instructions = f28E6_parent_instructions;
                        body.emit(f28E6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r28EA = bit_and(r28DE, body.constant(4026531840u));
                        ir_expression *const r28EB = equal(r28EA, body.constant(0u));
                        ir_if *f28E9 = new(mem_ctx) ir_if(operand(r28EB).val);
                        exec_list *const f28E9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28E9->then_instructions;

                           body.emit(assign(r28E0, add(r28E0, body.constant(int(4))), 0x01));

                           body.emit(assign(r28DE, lshift(r28DE, body.constant(int(4))), 0x01));


                        body.instructions = f28E9_parent_instructions;
                        body.emit(f28E9);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r28ED = bit_and(r28DE, body.constant(3221225472u));
                        ir_expression *const r28EE = equal(r28ED, body.constant(0u));
                        ir_if *f28EC = new(mem_ctx) ir_if(operand(r28EE).val);
                        exec_list *const f28EC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28EC->then_instructions;

                           body.emit(assign(r28E0, add(r28E0, body.constant(int(2))), 0x01));

                           body.emit(assign(r28DE, lshift(r28DE, body.constant(int(2))), 0x01));


                        body.instructions = f28EC_parent_instructions;
                        body.emit(f28EC);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r28F0 = bit_and(r28DE, body.constant(2147483648u));
                        ir_expression *const r28F1 = equal(r28F0, body.constant(0u));
                        ir_if *f28EF = new(mem_ctx) ir_if(operand(r28F1).val);
                        exec_list *const f28EF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28EF->then_instructions;

                           body.emit(assign(r28E0, add(r28E0, body.constant(int(1))), 0x01));


                        body.instructions = f28EF_parent_instructions;
                        body.emit(f28EF);

                        /* END IF */

                        body.emit(assign(r28DF, r28E0, 0x01));


                     body.instructions = f28E1_parent_instructions;
                     body.emit(f28E1);

                     /* END IF */

                     body.emit(assign(r28DB, add(r28DF, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r28F3 = lequal(body.constant(int(0)), r28DB);
                     ir_if *f28F2 = new(mem_ctx) ir_if(operand(r28F3).val);
                     exec_list *const f28F2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28F2->then_instructions;

                        body.emit(assign(r28DA, body.constant(0u), 0x01));

                        ir_variable *const r28F4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r28F4, lshift(r28D9, r28DB), 0x01));

                        ir_variable *const r28F5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r28F7 = equal(r28DB, body.constant(int(0)));
                        ir_if *f28F6 = new(mem_ctx) ir_if(operand(r28F7).val);
                        exec_list *const f28F6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28F6->then_instructions;

                           body.emit(assign(r28F5, r28D8, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f28F6->else_instructions;

                           ir_expression *const r28F8 = lshift(r28D8, r28DB);
                           ir_expression *const r28F9 = neg(r28DB);
                           ir_expression *const r28FA = bit_and(r28F9, body.constant(int(31)));
                           ir_expression *const r28FB = rshift(r28D9, r28FA);
                           body.emit(assign(r28F5, bit_or(r28F8, r28FB), 0x01));


                        body.instructions = f28F6_parent_instructions;
                        body.emit(f28F6);

                        /* END IF */

                        body.emit(assign(r28D8, r28F5, 0x01));

                        body.emit(assign(r28D9, r28F4, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28F2->else_instructions;

                        ir_variable *const r28FC = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r28FC, body.constant(0u), 0x01));

                        ir_variable *const r28FD = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r28FD, neg(r28DB), 0x01));

                        ir_variable *const r28FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r28FE);
                        ir_variable *const r28FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r28FF);
                        ir_variable *const r2900 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2900);
                        ir_variable *const r2901 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2902 = neg(r28FD);
                        body.emit(assign(r2901, bit_and(r2902, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2904 = equal(r28FD, body.constant(int(0)));
                        ir_if *f2903 = new(mem_ctx) ir_if(operand(r2904).val);
                        exec_list *const f2903_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2903->then_instructions;

                           body.emit(assign(r28FE, r28FC, 0x01));

                           body.emit(assign(r28FF, r28D9, 0x01));

                           body.emit(assign(r2900, r28D8, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2903->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2906 = less(r28FD, body.constant(int(32)));
                           ir_if *f2905 = new(mem_ctx) ir_if(operand(r2906).val);
                           exec_list *const f2905_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2905->then_instructions;

                              body.emit(assign(r28FE, lshift(r28D9, r2901), 0x01));

                              ir_expression *const r2907 = lshift(r28D8, r2901);
                              ir_expression *const r2908 = rshift(r28D9, r28FD);
                              body.emit(assign(r28FF, bit_or(r2907, r2908), 0x01));

                              body.emit(assign(r2900, rshift(r28D8, r28FD), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2905->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r290A = equal(r28FD, body.constant(int(32)));
                              ir_if *f2909 = new(mem_ctx) ir_if(operand(r290A).val);
                              exec_list *const f2909_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2909->then_instructions;

                                 body.emit(assign(r28FE, r28D9, 0x01));

                                 body.emit(assign(r28FF, r28D8, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2909->else_instructions;

                                 body.emit(assign(r28FC, bit_or(body.constant(0u), r28D9), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r290C = less(r28FD, body.constant(int(64)));
                                 ir_if *f290B = new(mem_ctx) ir_if(operand(r290C).val);
                                 exec_list *const f290B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f290B->then_instructions;

                                    body.emit(assign(r28FE, lshift(r28D8, r2901), 0x01));

                                    ir_expression *const r290D = bit_and(r28FD, body.constant(int(31)));
                                    body.emit(assign(r28FF, rshift(r28D8, r290D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f290B->else_instructions;

                                    ir_variable *const r290E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2910 = equal(r28FD, body.constant(int(64)));
                                    ir_if *f290F = new(mem_ctx) ir_if(operand(r2910).val);
                                    exec_list *const f290F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f290F->then_instructions;

                                       body.emit(assign(r290E, r28D8, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f290F->else_instructions;

                                       ir_expression *const r2911 = nequal(r28D8, body.constant(0u));
                                       ir_expression *const r2912 = expr(ir_unop_b2i, r2911);
                                       body.emit(assign(r290E, expr(ir_unop_i2u, r2912), 0x01));


                                    body.instructions = f290F_parent_instructions;
                                    body.emit(f290F);

                                    /* END IF */

                                    body.emit(assign(r28FE, r290E, 0x01));

                                    body.emit(assign(r28FF, body.constant(0u), 0x01));


                                 body.instructions = f290B_parent_instructions;
                                 body.emit(f290B);

                                 /* END IF */


                              body.instructions = f2909_parent_instructions;
                              body.emit(f2909);

                              /* END IF */

                              body.emit(assign(r2900, body.constant(0u), 0x01));


                           body.instructions = f2905_parent_instructions;
                           body.emit(f2905);

                           /* END IF */

                           ir_expression *const r2913 = nequal(r28FC, body.constant(0u));
                           ir_expression *const r2914 = expr(ir_unop_b2i, r2913);
                           ir_expression *const r2915 = expr(ir_unop_i2u, r2914);
                           body.emit(assign(r28FE, bit_or(r28FE, r2915), 0x01));


                        body.instructions = f2903_parent_instructions;
                        body.emit(f2903);

                        /* END IF */

                        body.emit(assign(r28D8, r2900, 0x01));

                        body.emit(assign(r28D9, r28FF, 0x01));

                        body.emit(assign(r28DA, r28FE, 0x01));


                     body.instructions = f28F2_parent_instructions;
                     body.emit(f28F2);

                     /* END IF */

                     body.emit(assign(r28D7, sub(r28D7, r28DB), 0x01));

                     ir_variable *const r2916 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2916, r28D7, 0x01));

                     ir_variable *const r2917 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2917, r28D8, 0x01));

                     ir_variable *const r2918 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2918, r28D9, 0x01));

                     ir_variable *const r2919 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2919, r28DA, 0x01));

                     ir_variable *const r291A = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r291A, body.constant(true), 0x01));

                     ir_variable *const r291B = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r291C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r291C);
                     ir_expression *const r291D = expr(ir_unop_u2i, r28DA);
                     body.emit(assign(r291C, less(r291D, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r291F = lequal(body.constant(int(2045)), r28D7);
                     ir_if *f291E = new(mem_ctx) ir_if(operand(r291F).val);
                     exec_list *const f291E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f291E->then_instructions;

                        ir_variable *const r2920 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2922 = less(body.constant(int(2045)), r28D7);
                        ir_if *f2921 = new(mem_ctx) ir_if(operand(r2922).val);
                        exec_list *const f2921_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2921->then_instructions;

                           body.emit(assign(r2920, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2921->else_instructions;

                           ir_variable *const r2923 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2925 = equal(r28D7, body.constant(int(2045)));
                           ir_if *f2924 = new(mem_ctx) ir_if(operand(r2925).val);
                           exec_list *const f2924_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2924->then_instructions;

                              ir_expression *const r2926 = equal(body.constant(2097151u), r28D8);
                              ir_expression *const r2927 = equal(body.constant(4294967295u), r28D9);
                              body.emit(assign(r2923, logic_and(r2926, r2927), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2924->else_instructions;

                              body.emit(assign(r2923, body.constant(false), 0x01));


                           body.instructions = f2924_parent_instructions;
                           body.emit(f2924);

                           /* END IF */

                           body.emit(assign(r2920, logic_and(r2923, r291C), 0x01));


                        body.instructions = f2921_parent_instructions;
                        body.emit(f2921);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2928 = new(mem_ctx) ir_if(operand(r2920).val);
                        exec_list *const f2928_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2928->then_instructions;

                           ir_variable *const r2929 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2929);
                           ir_expression *const r292A = lshift(r2745, body.constant(int(31)));
                           body.emit(assign(r2929, add(r292A, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2929, body.constant(0u), 0x01));

                           body.emit(assign(r291B, r2929, 0x03));

                           body.emit(assign(r291A, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2928->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r292C = less(r28D7, body.constant(int(0)));
                           ir_if *f292B = new(mem_ctx) ir_if(operand(r292C).val);
                           exec_list *const f292B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f292B->then_instructions;

                              ir_variable *const r292D = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r292D, r28DA, 0x01));

                              ir_variable *const r292E = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r292E, neg(r28D7), 0x01));

                              ir_variable *const r292F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r292F);
                              ir_variable *const r2930 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2930);
                              ir_variable *const r2931 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2931);
                              ir_variable *const r2932 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2933 = neg(r292E);
                              body.emit(assign(r2932, bit_and(r2933, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2935 = equal(r292E, body.constant(int(0)));
                              ir_if *f2934 = new(mem_ctx) ir_if(operand(r2935).val);
                              exec_list *const f2934_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2934->then_instructions;

                                 body.emit(assign(r292F, r28DA, 0x01));

                                 body.emit(assign(r2930, r28D9, 0x01));

                                 body.emit(assign(r2931, r28D8, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2934->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2937 = less(r292E, body.constant(int(32)));
                                 ir_if *f2936 = new(mem_ctx) ir_if(operand(r2937).val);
                                 exec_list *const f2936_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2936->then_instructions;

                                    body.emit(assign(r292F, lshift(r28D9, r2932), 0x01));

                                    ir_expression *const r2938 = lshift(r28D8, r2932);
                                    ir_expression *const r2939 = rshift(r28D9, r292E);
                                    body.emit(assign(r2930, bit_or(r2938, r2939), 0x01));

                                    body.emit(assign(r2931, rshift(r28D8, r292E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2936->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r293B = equal(r292E, body.constant(int(32)));
                                    ir_if *f293A = new(mem_ctx) ir_if(operand(r293B).val);
                                    exec_list *const f293A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f293A->then_instructions;

                                       body.emit(assign(r292F, r28D9, 0x01));

                                       body.emit(assign(r2930, r28D8, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f293A->else_instructions;

                                       body.emit(assign(r292D, bit_or(r28DA, r28D9), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r293D = less(r292E, body.constant(int(64)));
                                       ir_if *f293C = new(mem_ctx) ir_if(operand(r293D).val);
                                       exec_list *const f293C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f293C->then_instructions;

                                          body.emit(assign(r292F, lshift(r28D8, r2932), 0x01));

                                          ir_expression *const r293E = bit_and(r292E, body.constant(int(31)));
                                          body.emit(assign(r2930, rshift(r28D8, r293E), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f293C->else_instructions;

                                          ir_variable *const r293F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2941 = equal(r292E, body.constant(int(64)));
                                          ir_if *f2940 = new(mem_ctx) ir_if(operand(r2941).val);
                                          exec_list *const f2940_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2940->then_instructions;

                                             body.emit(assign(r293F, r28D8, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2940->else_instructions;

                                             ir_expression *const r2942 = nequal(r28D8, body.constant(0u));
                                             ir_expression *const r2943 = expr(ir_unop_b2i, r2942);
                                             body.emit(assign(r293F, expr(ir_unop_i2u, r2943), 0x01));


                                          body.instructions = f2940_parent_instructions;
                                          body.emit(f2940);

                                          /* END IF */

                                          body.emit(assign(r292F, r293F, 0x01));

                                          body.emit(assign(r2930, body.constant(0u), 0x01));


                                       body.instructions = f293C_parent_instructions;
                                       body.emit(f293C);

                                       /* END IF */


                                    body.instructions = f293A_parent_instructions;
                                    body.emit(f293A);

                                    /* END IF */

                                    body.emit(assign(r2931, body.constant(0u), 0x01));


                                 body.instructions = f2936_parent_instructions;
                                 body.emit(f2936);

                                 /* END IF */

                                 ir_expression *const r2944 = nequal(r292D, body.constant(0u));
                                 ir_expression *const r2945 = expr(ir_unop_b2i, r2944);
                                 ir_expression *const r2946 = expr(ir_unop_i2u, r2945);
                                 body.emit(assign(r292F, bit_or(r292F, r2946), 0x01));


                              body.instructions = f2934_parent_instructions;
                              body.emit(f2934);

                              /* END IF */

                              body.emit(assign(r2917, r2931, 0x01));

                              body.emit(assign(r2918, r2930, 0x01));

                              body.emit(assign(r2919, r292F, 0x01));

                              body.emit(assign(r2916, body.constant(int(0)), 0x01));

                              body.emit(assign(r291C, less(r292F, body.constant(0u)), 0x01));


                           body.instructions = f292B_parent_instructions;
                           body.emit(f292B);

                           /* END IF */


                        body.instructions = f2928_parent_instructions;
                        body.emit(f2928);

                        /* END IF */


                     body.instructions = f291E_parent_instructions;
                     body.emit(f291E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2947 = new(mem_ctx) ir_if(operand(r291A).val);
                     exec_list *const f2947_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2947->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2948 = new(mem_ctx) ir_if(operand(r291C).val);
                        exec_list *const f2948_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2948->then_instructions;

                           ir_variable *const r2949 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2949, add(r2918, body.constant(1u)), 0x01));

                           ir_expression *const r294A = less(r2949, r2918);
                           ir_expression *const r294B = expr(ir_unop_b2i, r294A);
                           ir_expression *const r294C = expr(ir_unop_i2u, r294B);
                           body.emit(assign(r2917, add(r2917, r294C), 0x01));

                           ir_expression *const r294D = equal(r2919, body.constant(0u));
                           ir_expression *const r294E = expr(ir_unop_b2i, r294D);
                           ir_expression *const r294F = expr(ir_unop_i2u, r294E);
                           ir_expression *const r2950 = add(r2919, r294F);
                           ir_expression *const r2951 = bit_and(r2950, body.constant(1u));
                           ir_expression *const r2952 = expr(ir_unop_bit_not, r2951);
                           body.emit(assign(r2918, bit_and(r2949, r2952), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2948->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2954 = bit_or(r2917, r2918);
                           ir_expression *const r2955 = equal(r2954, body.constant(0u));
                           ir_if *f2953 = new(mem_ctx) ir_if(operand(r2955).val);
                           exec_list *const f2953_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2953->then_instructions;

                              body.emit(assign(r2916, body.constant(int(0)), 0x01));


                           body.instructions = f2953_parent_instructions;
                           body.emit(f2953);

                           /* END IF */


                        body.instructions = f2948_parent_instructions;
                        body.emit(f2948);

                        /* END IF */

                        ir_variable *const r2956 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2956);
                        ir_expression *const r2957 = lshift(r2745, body.constant(int(31)));
                        ir_expression *const r2958 = expr(ir_unop_i2u, r2916);
                        ir_expression *const r2959 = lshift(r2958, body.constant(int(20)));
                        ir_expression *const r295A = add(r2957, r2959);
                        body.emit(assign(r2956, add(r295A, r2917), 0x02));

                        body.emit(assign(r2956, r2918, 0x01));

                        body.emit(assign(r291B, r2956, 0x03));

                        body.emit(assign(r291A, body.constant(false), 0x01));


                     body.instructions = f2947_parent_instructions;
                     body.emit(f2947);

                     /* END IF */

                     body.emit(assign(r2746, r291B, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f28CF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r295C = less(r274C, r274A);
                     ir_if *f295B = new(mem_ctx) ir_if(operand(r295C).val);
                     exec_list *const f295B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f295B->then_instructions;

                        ir_variable *const r295D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r295E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r295E, sub(r274B, r274D), 0x01));

                        ir_expression *const r295F = sub(r274A, r274C);
                        ir_expression *const r2960 = less(r274B, r274D);
                        ir_expression *const r2961 = expr(ir_unop_b2i, r2960);
                        ir_expression *const r2962 = expr(ir_unop_i2u, r2961);
                        body.emit(assign(r295D, sub(r295F, r2962), 0x01));

                        body.emit(assign(r2745, bit_xor(r2745, body.constant(1u)), 0x01));

                        body.emit(assign(r274E, add(r2748, body.constant(int(-1))), 0x01));

                        ir_variable *const r2963 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2963, add(r274E, body.constant(int(-10))), 0x01));

                        ir_variable *const r2964 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2964, r295D, 0x01));

                        ir_variable *const r2965 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2965, r295E, 0x01));

                        ir_variable *const r2966 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2966);
                        ir_variable *const r2967 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2967);
                        /* IF CONDITION */
                        ir_expression *const r2969 = equal(r295D, body.constant(0u));
                        ir_if *f2968 = new(mem_ctx) ir_if(operand(r2969).val);
                        exec_list *const f2968_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2968->then_instructions;

                           body.emit(assign(r2964, r295E, 0x01));

                           body.emit(assign(r2965, body.constant(0u), 0x01));

                           body.emit(assign(r2963, add(r2963, body.constant(int(-32))), 0x01));


                        body.instructions = f2968_parent_instructions;
                        body.emit(f2968);

                        /* END IF */

                        ir_variable *const r296A = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r296A, r2964, 0x01));

                        ir_variable *const r296B = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r296C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r296C);
                        /* IF CONDITION */
                        ir_expression *const r296E = equal(r2964, body.constant(0u));
                        ir_if *f296D = new(mem_ctx) ir_if(operand(r296E).val);
                        exec_list *const f296D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f296D->then_instructions;

                           body.emit(assign(r296B, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f296D->else_instructions;

                           body.emit(assign(r296C, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2970 = bit_and(r2964, body.constant(4294901760u));
                           ir_expression *const r2971 = equal(r2970, body.constant(0u));
                           ir_if *f296F = new(mem_ctx) ir_if(operand(r2971).val);
                           exec_list *const f296F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f296F->then_instructions;

                              body.emit(assign(r296C, body.constant(int(16)), 0x01));

                              body.emit(assign(r296A, lshift(r2964, body.constant(int(16))), 0x01));


                           body.instructions = f296F_parent_instructions;
                           body.emit(f296F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2973 = bit_and(r296A, body.constant(4278190080u));
                           ir_expression *const r2974 = equal(r2973, body.constant(0u));
                           ir_if *f2972 = new(mem_ctx) ir_if(operand(r2974).val);
                           exec_list *const f2972_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2972->then_instructions;

                              body.emit(assign(r296C, add(r296C, body.constant(int(8))), 0x01));

                              body.emit(assign(r296A, lshift(r296A, body.constant(int(8))), 0x01));


                           body.instructions = f2972_parent_instructions;
                           body.emit(f2972);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2976 = bit_and(r296A, body.constant(4026531840u));
                           ir_expression *const r2977 = equal(r2976, body.constant(0u));
                           ir_if *f2975 = new(mem_ctx) ir_if(operand(r2977).val);
                           exec_list *const f2975_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2975->then_instructions;

                              body.emit(assign(r296C, add(r296C, body.constant(int(4))), 0x01));

                              body.emit(assign(r296A, lshift(r296A, body.constant(int(4))), 0x01));


                           body.instructions = f2975_parent_instructions;
                           body.emit(f2975);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2979 = bit_and(r296A, body.constant(3221225472u));
                           ir_expression *const r297A = equal(r2979, body.constant(0u));
                           ir_if *f2978 = new(mem_ctx) ir_if(operand(r297A).val);
                           exec_list *const f2978_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2978->then_instructions;

                              body.emit(assign(r296C, add(r296C, body.constant(int(2))), 0x01));

                              body.emit(assign(r296A, lshift(r296A, body.constant(int(2))), 0x01));


                           body.instructions = f2978_parent_instructions;
                           body.emit(f2978);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r297C = bit_and(r296A, body.constant(2147483648u));
                           ir_expression *const r297D = equal(r297C, body.constant(0u));
                           ir_if *f297B = new(mem_ctx) ir_if(operand(r297D).val);
                           exec_list *const f297B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f297B->then_instructions;

                              body.emit(assign(r296C, add(r296C, body.constant(int(1))), 0x01));


                           body.instructions = f297B_parent_instructions;
                           body.emit(f297B);

                           /* END IF */

                           body.emit(assign(r296B, r296C, 0x01));


                        body.instructions = f296D_parent_instructions;
                        body.emit(f296D);

                        /* END IF */

                        body.emit(assign(r2967, add(r296B, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r297F = lequal(body.constant(int(0)), r2967);
                        ir_if *f297E = new(mem_ctx) ir_if(operand(r297F).val);
                        exec_list *const f297E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f297E->then_instructions;

                           body.emit(assign(r2966, body.constant(0u), 0x01));

                           ir_variable *const r2980 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2980, lshift(r2965, r2967), 0x01));

                           ir_variable *const r2981 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2983 = equal(r2967, body.constant(int(0)));
                           ir_if *f2982 = new(mem_ctx) ir_if(operand(r2983).val);
                           exec_list *const f2982_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2982->then_instructions;

                              body.emit(assign(r2981, r2964, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2982->else_instructions;

                              ir_expression *const r2984 = lshift(r2964, r2967);
                              ir_expression *const r2985 = neg(r2967);
                              ir_expression *const r2986 = bit_and(r2985, body.constant(int(31)));
                              ir_expression *const r2987 = rshift(r2965, r2986);
                              body.emit(assign(r2981, bit_or(r2984, r2987), 0x01));


                           body.instructions = f2982_parent_instructions;
                           body.emit(f2982);

                           /* END IF */

                           body.emit(assign(r2964, r2981, 0x01));

                           body.emit(assign(r2965, r2980, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f297E->else_instructions;

                           ir_variable *const r2988 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2988, body.constant(0u), 0x01));

                           ir_variable *const r2989 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2989, neg(r2967), 0x01));

                           ir_variable *const r298A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r298A);
                           ir_variable *const r298B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r298B);
                           ir_variable *const r298C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r298C);
                           ir_variable *const r298D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r298E = neg(r2989);
                           body.emit(assign(r298D, bit_and(r298E, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2990 = equal(r2989, body.constant(int(0)));
                           ir_if *f298F = new(mem_ctx) ir_if(operand(r2990).val);
                           exec_list *const f298F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f298F->then_instructions;

                              body.emit(assign(r298A, r2988, 0x01));

                              body.emit(assign(r298B, r2965, 0x01));

                              body.emit(assign(r298C, r2964, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f298F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2992 = less(r2989, body.constant(int(32)));
                              ir_if *f2991 = new(mem_ctx) ir_if(operand(r2992).val);
                              exec_list *const f2991_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2991->then_instructions;

                                 body.emit(assign(r298A, lshift(r2965, r298D), 0x01));

                                 ir_expression *const r2993 = lshift(r2964, r298D);
                                 ir_expression *const r2994 = rshift(r2965, r2989);
                                 body.emit(assign(r298B, bit_or(r2993, r2994), 0x01));

                                 body.emit(assign(r298C, rshift(r2964, r2989), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2991->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2996 = equal(r2989, body.constant(int(32)));
                                 ir_if *f2995 = new(mem_ctx) ir_if(operand(r2996).val);
                                 exec_list *const f2995_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2995->then_instructions;

                                    body.emit(assign(r298A, r2965, 0x01));

                                    body.emit(assign(r298B, r2964, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2995->else_instructions;

                                    body.emit(assign(r2988, bit_or(body.constant(0u), r2965), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2998 = less(r2989, body.constant(int(64)));
                                    ir_if *f2997 = new(mem_ctx) ir_if(operand(r2998).val);
                                    exec_list *const f2997_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2997->then_instructions;

                                       body.emit(assign(r298A, lshift(r2964, r298D), 0x01));

                                       ir_expression *const r2999 = bit_and(r2989, body.constant(int(31)));
                                       body.emit(assign(r298B, rshift(r2964, r2999), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2997->else_instructions;

                                       ir_variable *const r299A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r299C = equal(r2989, body.constant(int(64)));
                                       ir_if *f299B = new(mem_ctx) ir_if(operand(r299C).val);
                                       exec_list *const f299B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f299B->then_instructions;

                                          body.emit(assign(r299A, r2964, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f299B->else_instructions;

                                          ir_expression *const r299D = nequal(r2964, body.constant(0u));
                                          ir_expression *const r299E = expr(ir_unop_b2i, r299D);
                                          body.emit(assign(r299A, expr(ir_unop_i2u, r299E), 0x01));


                                       body.instructions = f299B_parent_instructions;
                                       body.emit(f299B);

                                       /* END IF */

                                       body.emit(assign(r298A, r299A, 0x01));

                                       body.emit(assign(r298B, body.constant(0u), 0x01));


                                    body.instructions = f2997_parent_instructions;
                                    body.emit(f2997);

                                    /* END IF */


                                 body.instructions = f2995_parent_instructions;
                                 body.emit(f2995);

                                 /* END IF */

                                 body.emit(assign(r298C, body.constant(0u), 0x01));


                              body.instructions = f2991_parent_instructions;
                              body.emit(f2991);

                              /* END IF */

                              ir_expression *const r299F = nequal(r2988, body.constant(0u));
                              ir_expression *const r29A0 = expr(ir_unop_b2i, r299F);
                              ir_expression *const r29A1 = expr(ir_unop_i2u, r29A0);
                              body.emit(assign(r298A, bit_or(r298A, r29A1), 0x01));


                           body.instructions = f298F_parent_instructions;
                           body.emit(f298F);

                           /* END IF */

                           body.emit(assign(r2964, r298C, 0x01));

                           body.emit(assign(r2965, r298B, 0x01));

                           body.emit(assign(r2966, r298A, 0x01));


                        body.instructions = f297E_parent_instructions;
                        body.emit(f297E);

                        /* END IF */

                        body.emit(assign(r2963, sub(r2963, r2967), 0x01));

                        ir_variable *const r29A2 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r29A2, r2963, 0x01));

                        ir_variable *const r29A3 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r29A3, r2964, 0x01));

                        ir_variable *const r29A4 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r29A4, r2965, 0x01));

                        ir_variable *const r29A5 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r29A5, r2966, 0x01));

                        ir_variable *const r29A6 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r29A6, body.constant(true), 0x01));

                        ir_variable *const r29A7 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r29A8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r29A8);
                        ir_expression *const r29A9 = expr(ir_unop_u2i, r2966);
                        body.emit(assign(r29A8, less(r29A9, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r29AB = lequal(body.constant(int(2045)), r2963);
                        ir_if *f29AA = new(mem_ctx) ir_if(operand(r29AB).val);
                        exec_list *const f29AA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29AA->then_instructions;

                           ir_variable *const r29AC = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r29AE = less(body.constant(int(2045)), r2963);
                           ir_if *f29AD = new(mem_ctx) ir_if(operand(r29AE).val);
                           exec_list *const f29AD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29AD->then_instructions;

                              body.emit(assign(r29AC, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29AD->else_instructions;

                              ir_variable *const r29AF = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r29B1 = equal(r2963, body.constant(int(2045)));
                              ir_if *f29B0 = new(mem_ctx) ir_if(operand(r29B1).val);
                              exec_list *const f29B0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29B0->then_instructions;

                                 ir_expression *const r29B2 = equal(body.constant(2097151u), r2964);
                                 ir_expression *const r29B3 = equal(body.constant(4294967295u), r2965);
                                 body.emit(assign(r29AF, logic_and(r29B2, r29B3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f29B0->else_instructions;

                                 body.emit(assign(r29AF, body.constant(false), 0x01));


                              body.instructions = f29B0_parent_instructions;
                              body.emit(f29B0);

                              /* END IF */

                              body.emit(assign(r29AC, logic_and(r29AF, r29A8), 0x01));


                           body.instructions = f29AD_parent_instructions;
                           body.emit(f29AD);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f29B4 = new(mem_ctx) ir_if(operand(r29AC).val);
                           exec_list *const f29B4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29B4->then_instructions;

                              ir_variable *const r29B5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r29B5);
                              ir_expression *const r29B6 = lshift(r2745, body.constant(int(31)));
                              body.emit(assign(r29B5, add(r29B6, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r29B5, body.constant(0u), 0x01));

                              body.emit(assign(r29A7, r29B5, 0x03));

                              body.emit(assign(r29A6, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29B4->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r29B8 = less(r2963, body.constant(int(0)));
                              ir_if *f29B7 = new(mem_ctx) ir_if(operand(r29B8).val);
                              exec_list *const f29B7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29B7->then_instructions;

                                 ir_variable *const r29B9 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r29B9, r2966, 0x01));

                                 ir_variable *const r29BA = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r29BA, neg(r2963), 0x01));

                                 ir_variable *const r29BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r29BB);
                                 ir_variable *const r29BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r29BC);
                                 ir_variable *const r29BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r29BD);
                                 ir_variable *const r29BE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r29BF = neg(r29BA);
                                 body.emit(assign(r29BE, bit_and(r29BF, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r29C1 = equal(r29BA, body.constant(int(0)));
                                 ir_if *f29C0 = new(mem_ctx) ir_if(operand(r29C1).val);
                                 exec_list *const f29C0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f29C0->then_instructions;

                                    body.emit(assign(r29BB, r2966, 0x01));

                                    body.emit(assign(r29BC, r2965, 0x01));

                                    body.emit(assign(r29BD, r2964, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f29C0->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r29C3 = less(r29BA, body.constant(int(32)));
                                    ir_if *f29C2 = new(mem_ctx) ir_if(operand(r29C3).val);
                                    exec_list *const f29C2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f29C2->then_instructions;

                                       body.emit(assign(r29BB, lshift(r2965, r29BE), 0x01));

                                       ir_expression *const r29C4 = lshift(r2964, r29BE);
                                       ir_expression *const r29C5 = rshift(r2965, r29BA);
                                       body.emit(assign(r29BC, bit_or(r29C4, r29C5), 0x01));

                                       body.emit(assign(r29BD, rshift(r2964, r29BA), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f29C2->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r29C7 = equal(r29BA, body.constant(int(32)));
                                       ir_if *f29C6 = new(mem_ctx) ir_if(operand(r29C7).val);
                                       exec_list *const f29C6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f29C6->then_instructions;

                                          body.emit(assign(r29BB, r2965, 0x01));

                                          body.emit(assign(r29BC, r2964, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f29C6->else_instructions;

                                          body.emit(assign(r29B9, bit_or(r2966, r2965), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r29C9 = less(r29BA, body.constant(int(64)));
                                          ir_if *f29C8 = new(mem_ctx) ir_if(operand(r29C9).val);
                                          exec_list *const f29C8_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f29C8->then_instructions;

                                             body.emit(assign(r29BB, lshift(r2964, r29BE), 0x01));

                                             ir_expression *const r29CA = bit_and(r29BA, body.constant(int(31)));
                                             body.emit(assign(r29BC, rshift(r2964, r29CA), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f29C8->else_instructions;

                                             ir_variable *const r29CB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r29CD = equal(r29BA, body.constant(int(64)));
                                             ir_if *f29CC = new(mem_ctx) ir_if(operand(r29CD).val);
                                             exec_list *const f29CC_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f29CC->then_instructions;

                                                body.emit(assign(r29CB, r2964, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f29CC->else_instructions;

                                                ir_expression *const r29CE = nequal(r2964, body.constant(0u));
                                                ir_expression *const r29CF = expr(ir_unop_b2i, r29CE);
                                                body.emit(assign(r29CB, expr(ir_unop_i2u, r29CF), 0x01));


                                             body.instructions = f29CC_parent_instructions;
                                             body.emit(f29CC);

                                             /* END IF */

                                             body.emit(assign(r29BB, r29CB, 0x01));

                                             body.emit(assign(r29BC, body.constant(0u), 0x01));


                                          body.instructions = f29C8_parent_instructions;
                                          body.emit(f29C8);

                                          /* END IF */


                                       body.instructions = f29C6_parent_instructions;
                                       body.emit(f29C6);

                                       /* END IF */

                                       body.emit(assign(r29BD, body.constant(0u), 0x01));


                                    body.instructions = f29C2_parent_instructions;
                                    body.emit(f29C2);

                                    /* END IF */

                                    ir_expression *const r29D0 = nequal(r29B9, body.constant(0u));
                                    ir_expression *const r29D1 = expr(ir_unop_b2i, r29D0);
                                    ir_expression *const r29D2 = expr(ir_unop_i2u, r29D1);
                                    body.emit(assign(r29BB, bit_or(r29BB, r29D2), 0x01));


                                 body.instructions = f29C0_parent_instructions;
                                 body.emit(f29C0);

                                 /* END IF */

                                 body.emit(assign(r29A3, r29BD, 0x01));

                                 body.emit(assign(r29A4, r29BC, 0x01));

                                 body.emit(assign(r29A5, r29BB, 0x01));

                                 body.emit(assign(r29A2, body.constant(int(0)), 0x01));

                                 body.emit(assign(r29A8, less(r29BB, body.constant(0u)), 0x01));


                              body.instructions = f29B7_parent_instructions;
                              body.emit(f29B7);

                              /* END IF */


                           body.instructions = f29B4_parent_instructions;
                           body.emit(f29B4);

                           /* END IF */


                        body.instructions = f29AA_parent_instructions;
                        body.emit(f29AA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f29D3 = new(mem_ctx) ir_if(operand(r29A6).val);
                        exec_list *const f29D3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29D3->then_instructions;

                           /* IF CONDITION */
                           ir_if *f29D4 = new(mem_ctx) ir_if(operand(r29A8).val);
                           exec_list *const f29D4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29D4->then_instructions;

                              ir_variable *const r29D5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r29D5, add(r29A4, body.constant(1u)), 0x01));

                              ir_expression *const r29D6 = less(r29D5, r29A4);
                              ir_expression *const r29D7 = expr(ir_unop_b2i, r29D6);
                              ir_expression *const r29D8 = expr(ir_unop_i2u, r29D7);
                              body.emit(assign(r29A3, add(r29A3, r29D8), 0x01));

                              ir_expression *const r29D9 = equal(r29A5, body.constant(0u));
                              ir_expression *const r29DA = expr(ir_unop_b2i, r29D9);
                              ir_expression *const r29DB = expr(ir_unop_i2u, r29DA);
                              ir_expression *const r29DC = add(r29A5, r29DB);
                              ir_expression *const r29DD = bit_and(r29DC, body.constant(1u));
                              ir_expression *const r29DE = expr(ir_unop_bit_not, r29DD);
                              body.emit(assign(r29A4, bit_and(r29D5, r29DE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29D4->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r29E0 = bit_or(r29A3, r29A4);
                              ir_expression *const r29E1 = equal(r29E0, body.constant(0u));
                              ir_if *f29DF = new(mem_ctx) ir_if(operand(r29E1).val);
                              exec_list *const f29DF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29DF->then_instructions;

                                 body.emit(assign(r29A2, body.constant(int(0)), 0x01));


                              body.instructions = f29DF_parent_instructions;
                              body.emit(f29DF);

                              /* END IF */


                           body.instructions = f29D4_parent_instructions;
                           body.emit(f29D4);

                           /* END IF */

                           ir_variable *const r29E2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r29E2);
                           ir_expression *const r29E3 = lshift(r2745, body.constant(int(31)));
                           ir_expression *const r29E4 = expr(ir_unop_i2u, r29A2);
                           ir_expression *const r29E5 = lshift(r29E4, body.constant(int(20)));
                           ir_expression *const r29E6 = add(r29E3, r29E5);
                           body.emit(assign(r29E2, add(r29E6, r29A3), 0x02));

                           body.emit(assign(r29E2, r29A4, 0x01));

                           body.emit(assign(r29A7, r29E2, 0x03));

                           body.emit(assign(r29A6, body.constant(false), 0x01));


                        body.instructions = f29D3_parent_instructions;
                        body.emit(f29D3);

                        /* END IF */

                        body.emit(assign(r2746, r29A7, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f295B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r29E8 = less(r274B, r274D);
                        ir_if *f29E7 = new(mem_ctx) ir_if(operand(r29E8).val);
                        exec_list *const f29E7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29E7->then_instructions;

                           ir_variable *const r29E9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r29EA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r29EA, sub(r274D, r274B), 0x01));

                           ir_expression *const r29EB = sub(r274C, r274A);
                           ir_expression *const r29EC = less(r274D, r274B);
                           ir_expression *const r29ED = expr(ir_unop_b2i, r29EC);
                           ir_expression *const r29EE = expr(ir_unop_i2u, r29ED);
                           body.emit(assign(r29E9, sub(r29EB, r29EE), 0x01));

                           body.emit(assign(r274E, add(r2749, body.constant(int(-1))), 0x01));

                           ir_variable *const r29EF = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r29EF, add(r274E, body.constant(int(-10))), 0x01));

                           ir_variable *const r29F0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r29F0, r29E9, 0x01));

                           ir_variable *const r29F1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r29F1, r29EA, 0x01));

                           ir_variable *const r29F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r29F2);
                           ir_variable *const r29F3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r29F3);
                           /* IF CONDITION */
                           ir_expression *const r29F5 = equal(r29E9, body.constant(0u));
                           ir_if *f29F4 = new(mem_ctx) ir_if(operand(r29F5).val);
                           exec_list *const f29F4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29F4->then_instructions;

                              body.emit(assign(r29F0, r29EA, 0x01));

                              body.emit(assign(r29F1, body.constant(0u), 0x01));

                              body.emit(assign(r29EF, add(r29EF, body.constant(int(-32))), 0x01));


                           body.instructions = f29F4_parent_instructions;
                           body.emit(f29F4);

                           /* END IF */

                           ir_variable *const r29F6 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r29F6, r29F0, 0x01));

                           ir_variable *const r29F7 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r29F8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r29F8);
                           /* IF CONDITION */
                           ir_expression *const r29FA = equal(r29F0, body.constant(0u));
                           ir_if *f29F9 = new(mem_ctx) ir_if(operand(r29FA).val);
                           exec_list *const f29F9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29F9->then_instructions;

                              body.emit(assign(r29F7, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29F9->else_instructions;

                              body.emit(assign(r29F8, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r29FC = bit_and(r29F0, body.constant(4294901760u));
                              ir_expression *const r29FD = equal(r29FC, body.constant(0u));
                              ir_if *f29FB = new(mem_ctx) ir_if(operand(r29FD).val);
                              exec_list *const f29FB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29FB->then_instructions;

                                 body.emit(assign(r29F8, body.constant(int(16)), 0x01));

                                 body.emit(assign(r29F6, lshift(r29F0, body.constant(int(16))), 0x01));


                              body.instructions = f29FB_parent_instructions;
                              body.emit(f29FB);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r29FF = bit_and(r29F6, body.constant(4278190080u));
                              ir_expression *const r2A00 = equal(r29FF, body.constant(0u));
                              ir_if *f29FE = new(mem_ctx) ir_if(operand(r2A00).val);
                              exec_list *const f29FE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29FE->then_instructions;

                                 body.emit(assign(r29F8, add(r29F8, body.constant(int(8))), 0x01));

                                 body.emit(assign(r29F6, lshift(r29F6, body.constant(int(8))), 0x01));


                              body.instructions = f29FE_parent_instructions;
                              body.emit(f29FE);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A02 = bit_and(r29F6, body.constant(4026531840u));
                              ir_expression *const r2A03 = equal(r2A02, body.constant(0u));
                              ir_if *f2A01 = new(mem_ctx) ir_if(operand(r2A03).val);
                              exec_list *const f2A01_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A01->then_instructions;

                                 body.emit(assign(r29F8, add(r29F8, body.constant(int(4))), 0x01));

                                 body.emit(assign(r29F6, lshift(r29F6, body.constant(int(4))), 0x01));


                              body.instructions = f2A01_parent_instructions;
                              body.emit(f2A01);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A05 = bit_and(r29F6, body.constant(3221225472u));
                              ir_expression *const r2A06 = equal(r2A05, body.constant(0u));
                              ir_if *f2A04 = new(mem_ctx) ir_if(operand(r2A06).val);
                              exec_list *const f2A04_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A04->then_instructions;

                                 body.emit(assign(r29F8, add(r29F8, body.constant(int(2))), 0x01));

                                 body.emit(assign(r29F6, lshift(r29F6, body.constant(int(2))), 0x01));


                              body.instructions = f2A04_parent_instructions;
                              body.emit(f2A04);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A08 = bit_and(r29F6, body.constant(2147483648u));
                              ir_expression *const r2A09 = equal(r2A08, body.constant(0u));
                              ir_if *f2A07 = new(mem_ctx) ir_if(operand(r2A09).val);
                              exec_list *const f2A07_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A07->then_instructions;

                                 body.emit(assign(r29F8, add(r29F8, body.constant(int(1))), 0x01));


                              body.instructions = f2A07_parent_instructions;
                              body.emit(f2A07);

                              /* END IF */

                              body.emit(assign(r29F7, r29F8, 0x01));


                           body.instructions = f29F9_parent_instructions;
                           body.emit(f29F9);

                           /* END IF */

                           body.emit(assign(r29F3, add(r29F7, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2A0B = lequal(body.constant(int(0)), r29F3);
                           ir_if *f2A0A = new(mem_ctx) ir_if(operand(r2A0B).val);
                           exec_list *const f2A0A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A0A->then_instructions;

                              body.emit(assign(r29F2, body.constant(0u), 0x01));

                              ir_variable *const r2A0C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2A0C, lshift(r29F1, r29F3), 0x01));

                              ir_variable *const r2A0D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2A0F = equal(r29F3, body.constant(int(0)));
                              ir_if *f2A0E = new(mem_ctx) ir_if(operand(r2A0F).val);
                              exec_list *const f2A0E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A0E->then_instructions;

                                 body.emit(assign(r2A0D, r29F0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A0E->else_instructions;

                                 ir_expression *const r2A10 = lshift(r29F0, r29F3);
                                 ir_expression *const r2A11 = neg(r29F3);
                                 ir_expression *const r2A12 = bit_and(r2A11, body.constant(int(31)));
                                 ir_expression *const r2A13 = rshift(r29F1, r2A12);
                                 body.emit(assign(r2A0D, bit_or(r2A10, r2A13), 0x01));


                              body.instructions = f2A0E_parent_instructions;
                              body.emit(f2A0E);

                              /* END IF */

                              body.emit(assign(r29F0, r2A0D, 0x01));

                              body.emit(assign(r29F1, r2A0C, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A0A->else_instructions;

                              ir_variable *const r2A14 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2A14, body.constant(0u), 0x01));

                              ir_variable *const r2A15 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2A15, neg(r29F3), 0x01));

                              ir_variable *const r2A16 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2A16);
                              ir_variable *const r2A17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2A17);
                              ir_variable *const r2A18 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2A18);
                              ir_variable *const r2A19 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2A1A = neg(r2A15);
                              body.emit(assign(r2A19, bit_and(r2A1A, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2A1C = equal(r2A15, body.constant(int(0)));
                              ir_if *f2A1B = new(mem_ctx) ir_if(operand(r2A1C).val);
                              exec_list *const f2A1B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A1B->then_instructions;

                                 body.emit(assign(r2A16, r2A14, 0x01));

                                 body.emit(assign(r2A17, r29F1, 0x01));

                                 body.emit(assign(r2A18, r29F0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A1B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2A1E = less(r2A15, body.constant(int(32)));
                                 ir_if *f2A1D = new(mem_ctx) ir_if(operand(r2A1E).val);
                                 exec_list *const f2A1D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A1D->then_instructions;

                                    body.emit(assign(r2A16, lshift(r29F1, r2A19), 0x01));

                                    ir_expression *const r2A1F = lshift(r29F0, r2A19);
                                    ir_expression *const r2A20 = rshift(r29F1, r2A15);
                                    body.emit(assign(r2A17, bit_or(r2A1F, r2A20), 0x01));

                                    body.emit(assign(r2A18, rshift(r29F0, r2A15), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A1D->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2A22 = equal(r2A15, body.constant(int(32)));
                                    ir_if *f2A21 = new(mem_ctx) ir_if(operand(r2A22).val);
                                    exec_list *const f2A21_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2A21->then_instructions;

                                       body.emit(assign(r2A16, r29F1, 0x01));

                                       body.emit(assign(r2A17, r29F0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2A21->else_instructions;

                                       body.emit(assign(r2A14, bit_or(body.constant(0u), r29F1), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2A24 = less(r2A15, body.constant(int(64)));
                                       ir_if *f2A23 = new(mem_ctx) ir_if(operand(r2A24).val);
                                       exec_list *const f2A23_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2A23->then_instructions;

                                          body.emit(assign(r2A16, lshift(r29F0, r2A19), 0x01));

                                          ir_expression *const r2A25 = bit_and(r2A15, body.constant(int(31)));
                                          body.emit(assign(r2A17, rshift(r29F0, r2A25), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2A23->else_instructions;

                                          ir_variable *const r2A26 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2A28 = equal(r2A15, body.constant(int(64)));
                                          ir_if *f2A27 = new(mem_ctx) ir_if(operand(r2A28).val);
                                          exec_list *const f2A27_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2A27->then_instructions;

                                             body.emit(assign(r2A26, r29F0, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2A27->else_instructions;

                                             ir_expression *const r2A29 = nequal(r29F0, body.constant(0u));
                                             ir_expression *const r2A2A = expr(ir_unop_b2i, r2A29);
                                             body.emit(assign(r2A26, expr(ir_unop_i2u, r2A2A), 0x01));


                                          body.instructions = f2A27_parent_instructions;
                                          body.emit(f2A27);

                                          /* END IF */

                                          body.emit(assign(r2A16, r2A26, 0x01));

                                          body.emit(assign(r2A17, body.constant(0u), 0x01));


                                       body.instructions = f2A23_parent_instructions;
                                       body.emit(f2A23);

                                       /* END IF */


                                    body.instructions = f2A21_parent_instructions;
                                    body.emit(f2A21);

                                    /* END IF */

                                    body.emit(assign(r2A18, body.constant(0u), 0x01));


                                 body.instructions = f2A1D_parent_instructions;
                                 body.emit(f2A1D);

                                 /* END IF */

                                 ir_expression *const r2A2B = nequal(r2A14, body.constant(0u));
                                 ir_expression *const r2A2C = expr(ir_unop_b2i, r2A2B);
                                 ir_expression *const r2A2D = expr(ir_unop_i2u, r2A2C);
                                 body.emit(assign(r2A16, bit_or(r2A16, r2A2D), 0x01));


                              body.instructions = f2A1B_parent_instructions;
                              body.emit(f2A1B);

                              /* END IF */

                              body.emit(assign(r29F0, r2A18, 0x01));

                              body.emit(assign(r29F1, r2A17, 0x01));

                              body.emit(assign(r29F2, r2A16, 0x01));


                           body.instructions = f2A0A_parent_instructions;
                           body.emit(f2A0A);

                           /* END IF */

                           body.emit(assign(r29EF, sub(r29EF, r29F3), 0x01));

                           ir_variable *const r2A2E = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2A2E, r29EF, 0x01));

                           ir_variable *const r2A2F = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2A2F, r29F0, 0x01));

                           ir_variable *const r2A30 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2A30, r29F1, 0x01));

                           ir_variable *const r2A31 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r2A31, r29F2, 0x01));

                           ir_variable *const r2A32 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r2A32, body.constant(true), 0x01));

                           ir_variable *const r2A33 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r2A34 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r2A34);
                           ir_expression *const r2A35 = expr(ir_unop_u2i, r29F2);
                           body.emit(assign(r2A34, less(r2A35, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2A37 = lequal(body.constant(int(2045)), r29EF);
                           ir_if *f2A36 = new(mem_ctx) ir_if(operand(r2A37).val);
                           exec_list *const f2A36_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A36->then_instructions;

                              ir_variable *const r2A38 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2A3A = less(body.constant(int(2045)), r29EF);
                              ir_if *f2A39 = new(mem_ctx) ir_if(operand(r2A3A).val);
                              exec_list *const f2A39_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A39->then_instructions;

                                 body.emit(assign(r2A38, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A39->else_instructions;

                                 ir_variable *const r2A3B = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2A3D = equal(r29EF, body.constant(int(2045)));
                                 ir_if *f2A3C = new(mem_ctx) ir_if(operand(r2A3D).val);
                                 exec_list *const f2A3C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A3C->then_instructions;

                                    ir_expression *const r2A3E = equal(body.constant(2097151u), r29F0);
                                    ir_expression *const r2A3F = equal(body.constant(4294967295u), r29F1);
                                    body.emit(assign(r2A3B, logic_and(r2A3E, r2A3F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A3C->else_instructions;

                                    body.emit(assign(r2A3B, body.constant(false), 0x01));


                                 body.instructions = f2A3C_parent_instructions;
                                 body.emit(f2A3C);

                                 /* END IF */

                                 body.emit(assign(r2A38, logic_and(r2A3B, r2A34), 0x01));


                              body.instructions = f2A39_parent_instructions;
                              body.emit(f2A39);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2A40 = new(mem_ctx) ir_if(operand(r2A38).val);
                              exec_list *const f2A40_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A40->then_instructions;

                                 ir_variable *const r2A41 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2A41);
                                 ir_expression *const r2A42 = lshift(r2745, body.constant(int(31)));
                                 body.emit(assign(r2A41, add(r2A42, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r2A41, body.constant(0u), 0x01));

                                 body.emit(assign(r2A33, r2A41, 0x03));

                                 body.emit(assign(r2A32, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A40->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2A44 = less(r29EF, body.constant(int(0)));
                                 ir_if *f2A43 = new(mem_ctx) ir_if(operand(r2A44).val);
                                 exec_list *const f2A43_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A43->then_instructions;

                                    ir_variable *const r2A45 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r2A45, r29F2, 0x01));

                                    ir_variable *const r2A46 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r2A46, neg(r29EF), 0x01));

                                    ir_variable *const r2A47 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r2A47);
                                    ir_variable *const r2A48 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r2A48);
                                    ir_variable *const r2A49 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2A49);
                                    ir_variable *const r2A4A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2A4B = neg(r2A46);
                                    body.emit(assign(r2A4A, bit_and(r2A4B, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2A4D = equal(r2A46, body.constant(int(0)));
                                    ir_if *f2A4C = new(mem_ctx) ir_if(operand(r2A4D).val);
                                    exec_list *const f2A4C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2A4C->then_instructions;

                                       body.emit(assign(r2A47, r29F2, 0x01));

                                       body.emit(assign(r2A48, r29F1, 0x01));

                                       body.emit(assign(r2A49, r29F0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2A4C->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2A4F = less(r2A46, body.constant(int(32)));
                                       ir_if *f2A4E = new(mem_ctx) ir_if(operand(r2A4F).val);
                                       exec_list *const f2A4E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2A4E->then_instructions;

                                          body.emit(assign(r2A47, lshift(r29F1, r2A4A), 0x01));

                                          ir_expression *const r2A50 = lshift(r29F0, r2A4A);
                                          ir_expression *const r2A51 = rshift(r29F1, r2A46);
                                          body.emit(assign(r2A48, bit_or(r2A50, r2A51), 0x01));

                                          body.emit(assign(r2A49, rshift(r29F0, r2A46), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2A4E->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2A53 = equal(r2A46, body.constant(int(32)));
                                          ir_if *f2A52 = new(mem_ctx) ir_if(operand(r2A53).val);
                                          exec_list *const f2A52_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2A52->then_instructions;

                                             body.emit(assign(r2A47, r29F1, 0x01));

                                             body.emit(assign(r2A48, r29F0, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2A52->else_instructions;

                                             body.emit(assign(r2A45, bit_or(r29F2, r29F1), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r2A55 = less(r2A46, body.constant(int(64)));
                                             ir_if *f2A54 = new(mem_ctx) ir_if(operand(r2A55).val);
                                             exec_list *const f2A54_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2A54->then_instructions;

                                                body.emit(assign(r2A47, lshift(r29F0, r2A4A), 0x01));

                                                ir_expression *const r2A56 = bit_and(r2A46, body.constant(int(31)));
                                                body.emit(assign(r2A48, rshift(r29F0, r2A56), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2A54->else_instructions;

                                                ir_variable *const r2A57 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2A59 = equal(r2A46, body.constant(int(64)));
                                                ir_if *f2A58 = new(mem_ctx) ir_if(operand(r2A59).val);
                                                exec_list *const f2A58_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2A58->then_instructions;

                                                   body.emit(assign(r2A57, r29F0, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2A58->else_instructions;

                                                   ir_expression *const r2A5A = nequal(r29F0, body.constant(0u));
                                                   ir_expression *const r2A5B = expr(ir_unop_b2i, r2A5A);
                                                   body.emit(assign(r2A57, expr(ir_unop_i2u, r2A5B), 0x01));


                                                body.instructions = f2A58_parent_instructions;
                                                body.emit(f2A58);

                                                /* END IF */

                                                body.emit(assign(r2A47, r2A57, 0x01));

                                                body.emit(assign(r2A48, body.constant(0u), 0x01));


                                             body.instructions = f2A54_parent_instructions;
                                             body.emit(f2A54);

                                             /* END IF */


                                          body.instructions = f2A52_parent_instructions;
                                          body.emit(f2A52);

                                          /* END IF */

                                          body.emit(assign(r2A49, body.constant(0u), 0x01));


                                       body.instructions = f2A4E_parent_instructions;
                                       body.emit(f2A4E);

                                       /* END IF */

                                       ir_expression *const r2A5C = nequal(r2A45, body.constant(0u));
                                       ir_expression *const r2A5D = expr(ir_unop_b2i, r2A5C);
                                       ir_expression *const r2A5E = expr(ir_unop_i2u, r2A5D);
                                       body.emit(assign(r2A47, bit_or(r2A47, r2A5E), 0x01));


                                    body.instructions = f2A4C_parent_instructions;
                                    body.emit(f2A4C);

                                    /* END IF */

                                    body.emit(assign(r2A2F, r2A49, 0x01));

                                    body.emit(assign(r2A30, r2A48, 0x01));

                                    body.emit(assign(r2A31, r2A47, 0x01));

                                    body.emit(assign(r2A2E, body.constant(int(0)), 0x01));

                                    body.emit(assign(r2A34, less(r2A47, body.constant(0u)), 0x01));


                                 body.instructions = f2A43_parent_instructions;
                                 body.emit(f2A43);

                                 /* END IF */


                              body.instructions = f2A40_parent_instructions;
                              body.emit(f2A40);

                              /* END IF */


                           body.instructions = f2A36_parent_instructions;
                           body.emit(f2A36);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2A5F = new(mem_ctx) ir_if(operand(r2A32).val);
                           exec_list *const f2A5F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A5F->then_instructions;

                              /* IF CONDITION */
                              ir_if *f2A60 = new(mem_ctx) ir_if(operand(r2A34).val);
                              exec_list *const f2A60_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A60->then_instructions;

                                 ir_variable *const r2A61 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r2A61, add(r2A30, body.constant(1u)), 0x01));

                                 ir_expression *const r2A62 = less(r2A61, r2A30);
                                 ir_expression *const r2A63 = expr(ir_unop_b2i, r2A62);
                                 ir_expression *const r2A64 = expr(ir_unop_i2u, r2A63);
                                 body.emit(assign(r2A2F, add(r2A2F, r2A64), 0x01));

                                 ir_expression *const r2A65 = equal(r2A31, body.constant(0u));
                                 ir_expression *const r2A66 = expr(ir_unop_b2i, r2A65);
                                 ir_expression *const r2A67 = expr(ir_unop_i2u, r2A66);
                                 ir_expression *const r2A68 = add(r2A31, r2A67);
                                 ir_expression *const r2A69 = bit_and(r2A68, body.constant(1u));
                                 ir_expression *const r2A6A = expr(ir_unop_bit_not, r2A69);
                                 body.emit(assign(r2A30, bit_and(r2A61, r2A6A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A60->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2A6C = bit_or(r2A2F, r2A30);
                                 ir_expression *const r2A6D = equal(r2A6C, body.constant(0u));
                                 ir_if *f2A6B = new(mem_ctx) ir_if(operand(r2A6D).val);
                                 exec_list *const f2A6B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A6B->then_instructions;

                                    body.emit(assign(r2A2E, body.constant(int(0)), 0x01));


                                 body.instructions = f2A6B_parent_instructions;
                                 body.emit(f2A6B);

                                 /* END IF */


                              body.instructions = f2A60_parent_instructions;
                              body.emit(f2A60);

                              /* END IF */

                              ir_variable *const r2A6E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2A6E);
                              ir_expression *const r2A6F = lshift(r2745, body.constant(int(31)));
                              ir_expression *const r2A70 = expr(ir_unop_i2u, r2A2E);
                              ir_expression *const r2A71 = lshift(r2A70, body.constant(int(20)));
                              ir_expression *const r2A72 = add(r2A6F, r2A71);
                              body.emit(assign(r2A6E, add(r2A72, r2A2F), 0x02));

                              body.emit(assign(r2A6E, r2A30, 0x01));

                              body.emit(assign(r2A33, r2A6E, 0x03));

                              body.emit(assign(r2A32, body.constant(false), 0x01));


                           body.instructions = f2A5F_parent_instructions;
                           body.emit(f2A5F);

                           /* END IF */

                           body.emit(assign(r2746, r2A33, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f29E7->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2A74 = less(r274D, r274B);
                           ir_if *f2A73 = new(mem_ctx) ir_if(operand(r2A74).val);
                           exec_list *const f2A73_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A73->then_instructions;

                              ir_variable *const r2A75 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r2A76 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2A76, sub(r274B, r274D), 0x01));

                              ir_expression *const r2A77 = sub(r274A, r274C);
                              ir_expression *const r2A78 = less(r274B, r274D);
                              ir_expression *const r2A79 = expr(ir_unop_b2i, r2A78);
                              ir_expression *const r2A7A = expr(ir_unop_i2u, r2A79);
                              body.emit(assign(r2A75, sub(r2A77, r2A7A), 0x01));

                              body.emit(assign(r2745, bit_xor(r2745, body.constant(1u)), 0x01));

                              body.emit(assign(r274E, add(r2748, body.constant(int(-1))), 0x01));

                              ir_variable *const r2A7B = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2A7B, add(r274E, body.constant(int(-10))), 0x01));

                              ir_variable *const r2A7C = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2A7C, r2A75, 0x01));

                              ir_variable *const r2A7D = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2A7D, r2A76, 0x01));

                              ir_variable *const r2A7E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r2A7E);
                              ir_variable *const r2A7F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2A7F);
                              /* IF CONDITION */
                              ir_expression *const r2A81 = equal(r2A75, body.constant(0u));
                              ir_if *f2A80 = new(mem_ctx) ir_if(operand(r2A81).val);
                              exec_list *const f2A80_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A80->then_instructions;

                                 body.emit(assign(r2A7C, r2A76, 0x01));

                                 body.emit(assign(r2A7D, body.constant(0u), 0x01));

                                 body.emit(assign(r2A7B, add(r2A7B, body.constant(int(-32))), 0x01));


                              body.instructions = f2A80_parent_instructions;
                              body.emit(f2A80);

                              /* END IF */

                              ir_variable *const r2A82 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r2A82, r2A7C, 0x01));

                              ir_variable *const r2A83 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r2A84 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2A84);
                              /* IF CONDITION */
                              ir_expression *const r2A86 = equal(r2A7C, body.constant(0u));
                              ir_if *f2A85 = new(mem_ctx) ir_if(operand(r2A86).val);
                              exec_list *const f2A85_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A85->then_instructions;

                                 body.emit(assign(r2A83, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A85->else_instructions;

                                 body.emit(assign(r2A84, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2A88 = bit_and(r2A7C, body.constant(4294901760u));
                                 ir_expression *const r2A89 = equal(r2A88, body.constant(0u));
                                 ir_if *f2A87 = new(mem_ctx) ir_if(operand(r2A89).val);
                                 exec_list *const f2A87_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A87->then_instructions;

                                    body.emit(assign(r2A84, body.constant(int(16)), 0x01));

                                    body.emit(assign(r2A82, lshift(r2A7C, body.constant(int(16))), 0x01));


                                 body.instructions = f2A87_parent_instructions;
                                 body.emit(f2A87);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2A8B = bit_and(r2A82, body.constant(4278190080u));
                                 ir_expression *const r2A8C = equal(r2A8B, body.constant(0u));
                                 ir_if *f2A8A = new(mem_ctx) ir_if(operand(r2A8C).val);
                                 exec_list *const f2A8A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A8A->then_instructions;

                                    body.emit(assign(r2A84, add(r2A84, body.constant(int(8))), 0x01));

                                    body.emit(assign(r2A82, lshift(r2A82, body.constant(int(8))), 0x01));


                                 body.instructions = f2A8A_parent_instructions;
                                 body.emit(f2A8A);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2A8E = bit_and(r2A82, body.constant(4026531840u));
                                 ir_expression *const r2A8F = equal(r2A8E, body.constant(0u));
                                 ir_if *f2A8D = new(mem_ctx) ir_if(operand(r2A8F).val);
                                 exec_list *const f2A8D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A8D->then_instructions;

                                    body.emit(assign(r2A84, add(r2A84, body.constant(int(4))), 0x01));

                                    body.emit(assign(r2A82, lshift(r2A82, body.constant(int(4))), 0x01));


                                 body.instructions = f2A8D_parent_instructions;
                                 body.emit(f2A8D);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2A91 = bit_and(r2A82, body.constant(3221225472u));
                                 ir_expression *const r2A92 = equal(r2A91, body.constant(0u));
                                 ir_if *f2A90 = new(mem_ctx) ir_if(operand(r2A92).val);
                                 exec_list *const f2A90_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A90->then_instructions;

                                    body.emit(assign(r2A84, add(r2A84, body.constant(int(2))), 0x01));

                                    body.emit(assign(r2A82, lshift(r2A82, body.constant(int(2))), 0x01));


                                 body.instructions = f2A90_parent_instructions;
                                 body.emit(f2A90);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2A94 = bit_and(r2A82, body.constant(2147483648u));
                                 ir_expression *const r2A95 = equal(r2A94, body.constant(0u));
                                 ir_if *f2A93 = new(mem_ctx) ir_if(operand(r2A95).val);
                                 exec_list *const f2A93_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A93->then_instructions;

                                    body.emit(assign(r2A84, add(r2A84, body.constant(int(1))), 0x01));


                                 body.instructions = f2A93_parent_instructions;
                                 body.emit(f2A93);

                                 /* END IF */

                                 body.emit(assign(r2A83, r2A84, 0x01));


                              body.instructions = f2A85_parent_instructions;
                              body.emit(f2A85);

                              /* END IF */

                              body.emit(assign(r2A7F, add(r2A83, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2A97 = lequal(body.constant(int(0)), r2A7F);
                              ir_if *f2A96 = new(mem_ctx) ir_if(operand(r2A97).val);
                              exec_list *const f2A96_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A96->then_instructions;

                                 body.emit(assign(r2A7E, body.constant(0u), 0x01));

                                 ir_variable *const r2A98 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r2A98, lshift(r2A7D, r2A7F), 0x01));

                                 ir_variable *const r2A99 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2A9B = equal(r2A7F, body.constant(int(0)));
                                 ir_if *f2A9A = new(mem_ctx) ir_if(operand(r2A9B).val);
                                 exec_list *const f2A9A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A9A->then_instructions;

                                    body.emit(assign(r2A99, r2A7C, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A9A->else_instructions;

                                    ir_expression *const r2A9C = lshift(r2A7C, r2A7F);
                                    ir_expression *const r2A9D = neg(r2A7F);
                                    ir_expression *const r2A9E = bit_and(r2A9D, body.constant(int(31)));
                                    ir_expression *const r2A9F = rshift(r2A7D, r2A9E);
                                    body.emit(assign(r2A99, bit_or(r2A9C, r2A9F), 0x01));


                                 body.instructions = f2A9A_parent_instructions;
                                 body.emit(f2A9A);

                                 /* END IF */

                                 body.emit(assign(r2A7C, r2A99, 0x01));

                                 body.emit(assign(r2A7D, r2A98, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A96->else_instructions;

                                 ir_variable *const r2AA0 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2AA0, body.constant(0u), 0x01));

                                 ir_variable *const r2AA1 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2AA1, neg(r2A7F), 0x01));

                                 ir_variable *const r2AA2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2AA2);
                                 ir_variable *const r2AA3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2AA3);
                                 ir_variable *const r2AA4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2AA4);
                                 ir_variable *const r2AA5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2AA6 = neg(r2AA1);
                                 body.emit(assign(r2AA5, bit_and(r2AA6, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2AA8 = equal(r2AA1, body.constant(int(0)));
                                 ir_if *f2AA7 = new(mem_ctx) ir_if(operand(r2AA8).val);
                                 exec_list *const f2AA7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AA7->then_instructions;

                                    body.emit(assign(r2AA2, r2AA0, 0x01));

                                    body.emit(assign(r2AA3, r2A7D, 0x01));

                                    body.emit(assign(r2AA4, r2A7C, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AA7->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2AAA = less(r2AA1, body.constant(int(32)));
                                    ir_if *f2AA9 = new(mem_ctx) ir_if(operand(r2AAA).val);
                                    exec_list *const f2AA9_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2AA9->then_instructions;

                                       body.emit(assign(r2AA2, lshift(r2A7D, r2AA5), 0x01));

                                       ir_expression *const r2AAB = lshift(r2A7C, r2AA5);
                                       ir_expression *const r2AAC = rshift(r2A7D, r2AA1);
                                       body.emit(assign(r2AA3, bit_or(r2AAB, r2AAC), 0x01));

                                       body.emit(assign(r2AA4, rshift(r2A7C, r2AA1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2AA9->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2AAE = equal(r2AA1, body.constant(int(32)));
                                       ir_if *f2AAD = new(mem_ctx) ir_if(operand(r2AAE).val);
                                       exec_list *const f2AAD_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2AAD->then_instructions;

                                          body.emit(assign(r2AA2, r2A7D, 0x01));

                                          body.emit(assign(r2AA3, r2A7C, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2AAD->else_instructions;

                                          body.emit(assign(r2AA0, bit_or(body.constant(0u), r2A7D), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2AB0 = less(r2AA1, body.constant(int(64)));
                                          ir_if *f2AAF = new(mem_ctx) ir_if(operand(r2AB0).val);
                                          exec_list *const f2AAF_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2AAF->then_instructions;

                                             body.emit(assign(r2AA2, lshift(r2A7C, r2AA5), 0x01));

                                             ir_expression *const r2AB1 = bit_and(r2AA1, body.constant(int(31)));
                                             body.emit(assign(r2AA3, rshift(r2A7C, r2AB1), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2AAF->else_instructions;

                                             ir_variable *const r2AB2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2AB4 = equal(r2AA1, body.constant(int(64)));
                                             ir_if *f2AB3 = new(mem_ctx) ir_if(operand(r2AB4).val);
                                             exec_list *const f2AB3_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2AB3->then_instructions;

                                                body.emit(assign(r2AB2, r2A7C, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2AB3->else_instructions;

                                                ir_expression *const r2AB5 = nequal(r2A7C, body.constant(0u));
                                                ir_expression *const r2AB6 = expr(ir_unop_b2i, r2AB5);
                                                body.emit(assign(r2AB2, expr(ir_unop_i2u, r2AB6), 0x01));


                                             body.instructions = f2AB3_parent_instructions;
                                             body.emit(f2AB3);

                                             /* END IF */

                                             body.emit(assign(r2AA2, r2AB2, 0x01));

                                             body.emit(assign(r2AA3, body.constant(0u), 0x01));


                                          body.instructions = f2AAF_parent_instructions;
                                          body.emit(f2AAF);

                                          /* END IF */


                                       body.instructions = f2AAD_parent_instructions;
                                       body.emit(f2AAD);

                                       /* END IF */

                                       body.emit(assign(r2AA4, body.constant(0u), 0x01));


                                    body.instructions = f2AA9_parent_instructions;
                                    body.emit(f2AA9);

                                    /* END IF */

                                    ir_expression *const r2AB7 = nequal(r2AA0, body.constant(0u));
                                    ir_expression *const r2AB8 = expr(ir_unop_b2i, r2AB7);
                                    ir_expression *const r2AB9 = expr(ir_unop_i2u, r2AB8);
                                    body.emit(assign(r2AA2, bit_or(r2AA2, r2AB9), 0x01));


                                 body.instructions = f2AA7_parent_instructions;
                                 body.emit(f2AA7);

                                 /* END IF */

                                 body.emit(assign(r2A7C, r2AA4, 0x01));

                                 body.emit(assign(r2A7D, r2AA3, 0x01));

                                 body.emit(assign(r2A7E, r2AA2, 0x01));


                              body.instructions = f2A96_parent_instructions;
                              body.emit(f2A96);

                              /* END IF */

                              body.emit(assign(r2A7B, sub(r2A7B, r2A7F), 0x01));

                              ir_variable *const r2ABA = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2ABA, r2A7B, 0x01));

                              ir_variable *const r2ABB = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2ABB, r2A7C, 0x01));

                              ir_variable *const r2ABC = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2ABC, r2A7D, 0x01));

                              ir_variable *const r2ABD = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r2ABD, r2A7E, 0x01));

                              ir_variable *const r2ABE = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r2ABE, body.constant(true), 0x01));

                              ir_variable *const r2ABF = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r2AC0 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r2AC0);
                              ir_expression *const r2AC1 = expr(ir_unop_u2i, r2A7E);
                              body.emit(assign(r2AC0, less(r2AC1, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2AC3 = lequal(body.constant(int(2045)), r2A7B);
                              ir_if *f2AC2 = new(mem_ctx) ir_if(operand(r2AC3).val);
                              exec_list *const f2AC2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AC2->then_instructions;

                                 ir_variable *const r2AC4 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2AC6 = less(body.constant(int(2045)), r2A7B);
                                 ir_if *f2AC5 = new(mem_ctx) ir_if(operand(r2AC6).val);
                                 exec_list *const f2AC5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AC5->then_instructions;

                                    body.emit(assign(r2AC4, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AC5->else_instructions;

                                    ir_variable *const r2AC7 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2AC9 = equal(r2A7B, body.constant(int(2045)));
                                    ir_if *f2AC8 = new(mem_ctx) ir_if(operand(r2AC9).val);
                                    exec_list *const f2AC8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2AC8->then_instructions;

                                       ir_expression *const r2ACA = equal(body.constant(2097151u), r2A7C);
                                       ir_expression *const r2ACB = equal(body.constant(4294967295u), r2A7D);
                                       body.emit(assign(r2AC7, logic_and(r2ACA, r2ACB), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2AC8->else_instructions;

                                       body.emit(assign(r2AC7, body.constant(false), 0x01));


                                    body.instructions = f2AC8_parent_instructions;
                                    body.emit(f2AC8);

                                    /* END IF */

                                    body.emit(assign(r2AC4, logic_and(r2AC7, r2AC0), 0x01));


                                 body.instructions = f2AC5_parent_instructions;
                                 body.emit(f2AC5);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f2ACC = new(mem_ctx) ir_if(operand(r2AC4).val);
                                 exec_list *const f2ACC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2ACC->then_instructions;

                                    ir_variable *const r2ACD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r2ACD);
                                    ir_expression *const r2ACE = lshift(r2745, body.constant(int(31)));
                                    body.emit(assign(r2ACD, add(r2ACE, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r2ACD, body.constant(0u), 0x01));

                                    body.emit(assign(r2ABF, r2ACD, 0x03));

                                    body.emit(assign(r2ABE, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2ACC->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2AD0 = less(r2A7B, body.constant(int(0)));
                                    ir_if *f2ACF = new(mem_ctx) ir_if(operand(r2AD0).val);
                                    exec_list *const f2ACF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2ACF->then_instructions;

                                       ir_variable *const r2AD1 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r2AD1, r2A7E, 0x01));

                                       ir_variable *const r2AD2 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r2AD2, neg(r2A7B), 0x01));

                                       ir_variable *const r2AD3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r2AD3);
                                       ir_variable *const r2AD4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r2AD4);
                                       ir_variable *const r2AD5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r2AD5);
                                       ir_variable *const r2AD6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r2AD7 = neg(r2AD2);
                                       body.emit(assign(r2AD6, bit_and(r2AD7, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2AD9 = equal(r2AD2, body.constant(int(0)));
                                       ir_if *f2AD8 = new(mem_ctx) ir_if(operand(r2AD9).val);
                                       exec_list *const f2AD8_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2AD8->then_instructions;

                                          body.emit(assign(r2AD3, r2A7E, 0x01));

                                          body.emit(assign(r2AD4, r2A7D, 0x01));

                                          body.emit(assign(r2AD5, r2A7C, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2AD8->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2ADB = less(r2AD2, body.constant(int(32)));
                                          ir_if *f2ADA = new(mem_ctx) ir_if(operand(r2ADB).val);
                                          exec_list *const f2ADA_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2ADA->then_instructions;

                                             body.emit(assign(r2AD3, lshift(r2A7D, r2AD6), 0x01));

                                             ir_expression *const r2ADC = lshift(r2A7C, r2AD6);
                                             ir_expression *const r2ADD = rshift(r2A7D, r2AD2);
                                             body.emit(assign(r2AD4, bit_or(r2ADC, r2ADD), 0x01));

                                             body.emit(assign(r2AD5, rshift(r2A7C, r2AD2), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2ADA->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r2ADF = equal(r2AD2, body.constant(int(32)));
                                             ir_if *f2ADE = new(mem_ctx) ir_if(operand(r2ADF).val);
                                             exec_list *const f2ADE_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2ADE->then_instructions;

                                                body.emit(assign(r2AD3, r2A7D, 0x01));

                                                body.emit(assign(r2AD4, r2A7C, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2ADE->else_instructions;

                                                body.emit(assign(r2AD1, bit_or(r2A7E, r2A7D), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r2AE1 = less(r2AD2, body.constant(int(64)));
                                                ir_if *f2AE0 = new(mem_ctx) ir_if(operand(r2AE1).val);
                                                exec_list *const f2AE0_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2AE0->then_instructions;

                                                   body.emit(assign(r2AD3, lshift(r2A7C, r2AD6), 0x01));

                                                   ir_expression *const r2AE2 = bit_and(r2AD2, body.constant(int(31)));
                                                   body.emit(assign(r2AD4, rshift(r2A7C, r2AE2), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2AE0->else_instructions;

                                                   ir_variable *const r2AE3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r2AE5 = equal(r2AD2, body.constant(int(64)));
                                                   ir_if *f2AE4 = new(mem_ctx) ir_if(operand(r2AE5).val);
                                                   exec_list *const f2AE4_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f2AE4->then_instructions;

                                                      body.emit(assign(r2AE3, r2A7C, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f2AE4->else_instructions;

                                                      ir_expression *const r2AE6 = nequal(r2A7C, body.constant(0u));
                                                      ir_expression *const r2AE7 = expr(ir_unop_b2i, r2AE6);
                                                      body.emit(assign(r2AE3, expr(ir_unop_i2u, r2AE7), 0x01));


                                                   body.instructions = f2AE4_parent_instructions;
                                                   body.emit(f2AE4);

                                                   /* END IF */

                                                   body.emit(assign(r2AD3, r2AE3, 0x01));

                                                   body.emit(assign(r2AD4, body.constant(0u), 0x01));


                                                body.instructions = f2AE0_parent_instructions;
                                                body.emit(f2AE0);

                                                /* END IF */


                                             body.instructions = f2ADE_parent_instructions;
                                             body.emit(f2ADE);

                                             /* END IF */

                                             body.emit(assign(r2AD5, body.constant(0u), 0x01));


                                          body.instructions = f2ADA_parent_instructions;
                                          body.emit(f2ADA);

                                          /* END IF */

                                          ir_expression *const r2AE8 = nequal(r2AD1, body.constant(0u));
                                          ir_expression *const r2AE9 = expr(ir_unop_b2i, r2AE8);
                                          ir_expression *const r2AEA = expr(ir_unop_i2u, r2AE9);
                                          body.emit(assign(r2AD3, bit_or(r2AD3, r2AEA), 0x01));


                                       body.instructions = f2AD8_parent_instructions;
                                       body.emit(f2AD8);

                                       /* END IF */

                                       body.emit(assign(r2ABB, r2AD5, 0x01));

                                       body.emit(assign(r2ABC, r2AD4, 0x01));

                                       body.emit(assign(r2ABD, r2AD3, 0x01));

                                       body.emit(assign(r2ABA, body.constant(int(0)), 0x01));

                                       body.emit(assign(r2AC0, less(r2AD3, body.constant(0u)), 0x01));


                                    body.instructions = f2ACF_parent_instructions;
                                    body.emit(f2ACF);

                                    /* END IF */


                                 body.instructions = f2ACC_parent_instructions;
                                 body.emit(f2ACC);

                                 /* END IF */


                              body.instructions = f2AC2_parent_instructions;
                              body.emit(f2AC2);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2AEB = new(mem_ctx) ir_if(operand(r2ABE).val);
                              exec_list *const f2AEB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AEB->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f2AEC = new(mem_ctx) ir_if(operand(r2AC0).val);
                                 exec_list *const f2AEC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AEC->then_instructions;

                                    ir_variable *const r2AED = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r2AED, add(r2ABC, body.constant(1u)), 0x01));

                                    ir_expression *const r2AEE = less(r2AED, r2ABC);
                                    ir_expression *const r2AEF = expr(ir_unop_b2i, r2AEE);
                                    ir_expression *const r2AF0 = expr(ir_unop_i2u, r2AEF);
                                    body.emit(assign(r2ABB, add(r2ABB, r2AF0), 0x01));

                                    ir_expression *const r2AF1 = equal(r2ABD, body.constant(0u));
                                    ir_expression *const r2AF2 = expr(ir_unop_b2i, r2AF1);
                                    ir_expression *const r2AF3 = expr(ir_unop_i2u, r2AF2);
                                    ir_expression *const r2AF4 = add(r2ABD, r2AF3);
                                    ir_expression *const r2AF5 = bit_and(r2AF4, body.constant(1u));
                                    ir_expression *const r2AF6 = expr(ir_unop_bit_not, r2AF5);
                                    body.emit(assign(r2ABC, bit_and(r2AED, r2AF6), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AEC->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2AF8 = bit_or(r2ABB, r2ABC);
                                    ir_expression *const r2AF9 = equal(r2AF8, body.constant(0u));
                                    ir_if *f2AF7 = new(mem_ctx) ir_if(operand(r2AF9).val);
                                    exec_list *const f2AF7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2AF7->then_instructions;

                                       body.emit(assign(r2ABA, body.constant(int(0)), 0x01));


                                    body.instructions = f2AF7_parent_instructions;
                                    body.emit(f2AF7);

                                    /* END IF */


                                 body.instructions = f2AEC_parent_instructions;
                                 body.emit(f2AEC);

                                 /* END IF */

                                 ir_variable *const r2AFA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2AFA);
                                 ir_expression *const r2AFB = lshift(r2745, body.constant(int(31)));
                                 ir_expression *const r2AFC = expr(ir_unop_i2u, r2ABA);
                                 ir_expression *const r2AFD = lshift(r2AFC, body.constant(int(20)));
                                 ir_expression *const r2AFE = add(r2AFB, r2AFD);
                                 body.emit(assign(r2AFA, add(r2AFE, r2ABB), 0x02));

                                 body.emit(assign(r2AFA, r2ABC, 0x01));

                                 body.emit(assign(r2ABF, r2AFA, 0x03));

                                 body.emit(assign(r2ABE, body.constant(false), 0x01));


                              body.instructions = f2AEB_parent_instructions;
                              body.emit(f2AEB);

                              /* END IF */

                              body.emit(assign(r2746, r2ABF, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A73->else_instructions;

                              ir_variable *const r2AFF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2AFF);
                              body.emit(assign(r2AFF, body.constant(0u), 0x02));

                              body.emit(assign(r2AFF, body.constant(0u), 0x01));

                              body.emit(assign(r2746, r2AFF, 0x03));


                           body.instructions = f2A73_parent_instructions;
                           body.emit(f2A73);

                           /* END IF */


                        body.instructions = f29E7_parent_instructions;
                        body.emit(f29E7);

                        /* END IF */


                     body.instructions = f295B_parent_instructions;
                     body.emit(f295B);

                     /* END IF */


                  body.instructions = f28CF_parent_instructions;
                  body.emit(f28CF);

                  /* END IF */


               body.instructions = f28BA_parent_instructions;
               body.emit(f28BA);

               /* END IF */


            body.instructions = f280B_parent_instructions;
            body.emit(f280B);

            /* END IF */


         body.instructions = f275A_parent_instructions;
         body.emit(f275A);

         /* END IF */

         body.emit(assign(r2741, r2746, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2743->else_instructions;

         ir_variable *const r2B00 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r2B00, body.constant(true), 0x01));

         ir_variable *const r2B01 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2B02 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2B02);
         ir_variable *const r2B03 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r2B03);
         ir_variable *const r2B04 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r2B04);
         ir_variable *const r2B05 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r2B05);
         ir_variable *const r2B06 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r2B06);
         ir_variable *const r2B07 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2B07);
         ir_variable *const r2B08 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r2B08);
         ir_variable *const r2B09 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r2B09);
         body.emit(assign(r2B09, body.constant(0u), 0x01));

         body.emit(assign(r2B08, body.constant(0u), 0x01));

         ir_variable *const r2B0A = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2B0A, swizzle_x(r270C), 0x01));

         body.emit(assign(r2B06, r2B0A, 0x01));

         ir_variable *const r2B0B = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r2B0B, bit_and(swizzle_y(r270C), body.constant(1048575u)), 0x01));

         body.emit(assign(r2B05, r2B0B, 0x01));

         ir_variable *const r2B0C = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2B0C, body.constant(0u), 0x01));

         body.emit(assign(r2B04, body.constant(0u), 0x01));

         body.emit(assign(r2B03, body.constant(0u), 0x01));

         ir_variable *const r2B0D = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2B0E = rshift(swizzle_y(r270C), body.constant(int(20)));
         ir_expression *const r2B0F = bit_and(r2B0E, body.constant(2047u));
         body.emit(assign(r2B0D, expr(ir_unop_u2i, r2B0F), 0x01));

         ir_variable *const r2B10 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r2B10, body.constant(int(1023)), 0x01));

         ir_variable *const r2B11 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2B11, add(r2B0D, body.constant(int(-1023))), 0x01));

         body.emit(assign(r2B02, r2B11, 0x01));

         /* IF CONDITION */
         ir_expression *const r2B13 = less(body.constant(int(0)), r2B11);
         ir_if *f2B12 = new(mem_ctx) ir_if(operand(r2B13).val);
         exec_list *const f2B12_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2B12->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2B15 = equal(r2B0D, body.constant(int(2047)));
            ir_if *f2B14 = new(mem_ctx) ir_if(operand(r2B15).val);
            exec_list *const f2B14_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2B14->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2B17 = bit_or(r2B0B, swizzle_x(r270C));
               ir_expression *const r2B18 = nequal(r2B17, body.constant(0u));
               ir_if *f2B16 = new(mem_ctx) ir_if(operand(r2B18).val);
               exec_list *const f2B16_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B16->then_instructions;

                  ir_variable *const r2B19 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2B19, swizzle_x(r270C), 0x01));

                  ir_variable *const r2B1A = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2B1A, body.constant(0u), 0x01));

                  ir_variable *const r2B1B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2B19, bit_or(swizzle_y(r270C), body.constant(524288u)), 0x02));

                  body.emit(assign(r2B1A, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2B1D = lshift(swizzle_y(r270C), body.constant(int(1)));
                  ir_expression *const r2B1E = lequal(body.constant(4292870144u), r2B1D);
                  ir_expression *const r2B1F = nequal(swizzle_x(r270C), body.constant(0u));
                  ir_expression *const r2B20 = bit_and(swizzle_y(r270C), body.constant(1048575u));
                  ir_expression *const r2B21 = nequal(r2B20, body.constant(0u));
                  ir_expression *const r2B22 = logic_or(r2B1F, r2B21);
                  ir_expression *const r2B23 = logic_and(r2B1E, r2B22);
                  ir_if *f2B1C = new(mem_ctx) ir_if(operand(r2B23).val);
                  exec_list *const f2B1C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B1C->then_instructions;

                     body.emit(assign(r2B1B, r2B19, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B1C->else_instructions;

                     body.emit(assign(r2B1B, r2B1A, 0x03));


                  body.instructions = f2B1C_parent_instructions;
                  body.emit(f2B1C);

                  /* END IF */

                  body.emit(assign(r2B01, r2B1B, 0x03));

                  body.emit(assign(r2B00, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B16->else_instructions;

                  body.emit(assign(r2B01, r270C, 0x03));

                  body.emit(assign(r2B00, body.constant(false), 0x01));


               body.instructions = f2B16_parent_instructions;
               body.emit(f2B16);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2B14->else_instructions;

               body.emit(assign(r2B03, body.constant(1048576u), 0x01));

               ir_variable *const r2B24 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2B24, body.constant(0u), 0x01));

               ir_variable *const r2B25 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2B25);
               ir_variable *const r2B26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2B26);
               ir_variable *const r2B27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2B27);
               ir_variable *const r2B28 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2B29 = neg(r2B11);
               body.emit(assign(r2B28, bit_and(r2B29, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2B2B = equal(r2B11, body.constant(int(0)));
               ir_if *f2B2A = new(mem_ctx) ir_if(operand(r2B2B).val);
               exec_list *const f2B2A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B2A->then_instructions;

                  body.emit(assign(r2B25, r2B24, 0x01));

                  body.emit(assign(r2B26, body.constant(0u), 0x01));

                  body.emit(assign(r2B27, r2B03, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B2A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2B2D = less(r2B11, body.constant(int(32)));
                  ir_if *f2B2C = new(mem_ctx) ir_if(operand(r2B2D).val);
                  exec_list *const f2B2C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B2C->then_instructions;

                     body.emit(assign(r2B25, body.constant(0u), 0x01));

                     ir_expression *const r2B2E = lshift(body.constant(1048576u), r2B28);
                     body.emit(assign(r2B26, bit_or(r2B2E, body.constant(0u)), 0x01));

                     body.emit(assign(r2B27, rshift(body.constant(1048576u), r2B11), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B2C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2B30 = equal(r2B11, body.constant(int(32)));
                     ir_if *f2B2F = new(mem_ctx) ir_if(operand(r2B30).val);
                     exec_list *const f2B2F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B2F->then_instructions;

                        body.emit(assign(r2B25, body.constant(0u), 0x01));

                        body.emit(assign(r2B26, r2B03, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B2F->else_instructions;

                        body.emit(assign(r2B24, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2B32 = less(r2B11, body.constant(int(64)));
                        ir_if *f2B31 = new(mem_ctx) ir_if(operand(r2B32).val);
                        exec_list *const f2B31_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B31->then_instructions;

                           body.emit(assign(r2B25, lshift(body.constant(1048576u), r2B28), 0x01));

                           ir_expression *const r2B33 = bit_and(r2B11, body.constant(int(31)));
                           body.emit(assign(r2B26, rshift(body.constant(1048576u), r2B33), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B31->else_instructions;

                           ir_variable *const r2B34 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2B36 = equal(r2B11, body.constant(int(64)));
                           ir_if *f2B35 = new(mem_ctx) ir_if(operand(r2B36).val);
                           exec_list *const f2B35_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B35->then_instructions;

                              body.emit(assign(r2B34, r2B03, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B35->else_instructions;

                              body.emit(assign(r2B34, body.constant(1u), 0x01));


                           body.instructions = f2B35_parent_instructions;
                           body.emit(f2B35);

                           /* END IF */

                           body.emit(assign(r2B25, r2B34, 0x01));

                           body.emit(assign(r2B26, body.constant(0u), 0x01));


                        body.instructions = f2B31_parent_instructions;
                        body.emit(f2B31);

                        /* END IF */


                     body.instructions = f2B2F_parent_instructions;
                     body.emit(f2B2F);

                     /* END IF */

                     body.emit(assign(r2B27, body.constant(0u), 0x01));


                  body.instructions = f2B2C_parent_instructions;
                  body.emit(f2B2C);

                  /* END IF */

                  ir_expression *const r2B37 = nequal(r2B24, body.constant(0u));
                  ir_expression *const r2B38 = expr(ir_unop_b2i, r2B37);
                  ir_expression *const r2B39 = expr(ir_unop_i2u, r2B38);
                  body.emit(assign(r2B25, bit_or(r2B25, r2B39), 0x01));


               body.instructions = f2B2A_parent_instructions;
               body.emit(f2B2A);

               /* END IF */

               body.emit(assign(r2B03, r2B27, 0x01));

               body.emit(assign(r2B04, r2B26, 0x01));

               body.emit(assign(r2B08, r2B25, 0x01));

               body.emit(assign(r2B07, r2B0D, 0x01));


            body.instructions = f2B14_parent_instructions;
            body.emit(f2B14);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2B12->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2B3B = less(r2B11, body.constant(int(0)));
            ir_if *f2B3A = new(mem_ctx) ir_if(operand(r2B3B).val);
            exec_list *const f2B3A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2B3A->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2B3D = equal(r2B0D, body.constant(int(0)));
               ir_if *f2B3C = new(mem_ctx) ir_if(operand(r2B3D).val);
               exec_list *const f2B3C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B3C->then_instructions;

                  body.emit(assign(r2B02, add(r2B11, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B3C->else_instructions;

                  body.emit(assign(r2B05, bit_or(r2B0B, body.constant(1048576u)), 0x01));


               body.instructions = f2B3C_parent_instructions;
               body.emit(f2B3C);

               /* END IF */

               ir_variable *const r2B3E = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2B3E, body.constant(0u), 0x01));

               ir_variable *const r2B3F = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2B3F, neg(r2B02), 0x01));

               ir_variable *const r2B40 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2B40);
               ir_variable *const r2B41 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2B41);
               ir_variable *const r2B42 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2B42);
               ir_variable *const r2B43 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2B44 = neg(r2B3F);
               body.emit(assign(r2B43, bit_and(r2B44, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2B46 = equal(r2B3F, body.constant(int(0)));
               ir_if *f2B45 = new(mem_ctx) ir_if(operand(r2B46).val);
               exec_list *const f2B45_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B45->then_instructions;

                  body.emit(assign(r2B40, r2B3E, 0x01));

                  body.emit(assign(r2B41, r2B0A, 0x01));

                  body.emit(assign(r2B42, r2B05, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B45->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2B48 = less(r2B3F, body.constant(int(32)));
                  ir_if *f2B47 = new(mem_ctx) ir_if(operand(r2B48).val);
                  exec_list *const f2B47_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B47->then_instructions;

                     body.emit(assign(r2B40, lshift(swizzle_x(r270C), r2B43), 0x01));

                     ir_expression *const r2B49 = lshift(r2B05, r2B43);
                     ir_expression *const r2B4A = rshift(swizzle_x(r270C), r2B3F);
                     body.emit(assign(r2B41, bit_or(r2B49, r2B4A), 0x01));

                     body.emit(assign(r2B42, rshift(r2B05, r2B3F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B47->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2B4C = equal(r2B3F, body.constant(int(32)));
                     ir_if *f2B4B = new(mem_ctx) ir_if(operand(r2B4C).val);
                     exec_list *const f2B4B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B4B->then_instructions;

                        body.emit(assign(r2B40, r2B0A, 0x01));

                        body.emit(assign(r2B41, r2B05, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B4B->else_instructions;

                        body.emit(assign(r2B3E, bit_or(body.constant(0u), swizzle_x(r270C)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2B4E = less(r2B3F, body.constant(int(64)));
                        ir_if *f2B4D = new(mem_ctx) ir_if(operand(r2B4E).val);
                        exec_list *const f2B4D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B4D->then_instructions;

                           body.emit(assign(r2B40, lshift(r2B05, r2B43), 0x01));

                           ir_expression *const r2B4F = bit_and(r2B3F, body.constant(int(31)));
                           body.emit(assign(r2B41, rshift(r2B05, r2B4F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B4D->else_instructions;

                           ir_variable *const r2B50 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2B52 = equal(r2B3F, body.constant(int(64)));
                           ir_if *f2B51 = new(mem_ctx) ir_if(operand(r2B52).val);
                           exec_list *const f2B51_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B51->then_instructions;

                              body.emit(assign(r2B50, r2B05, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B51->else_instructions;

                              ir_expression *const r2B53 = nequal(r2B05, body.constant(0u));
                              ir_expression *const r2B54 = expr(ir_unop_b2i, r2B53);
                              body.emit(assign(r2B50, expr(ir_unop_i2u, r2B54), 0x01));


                           body.instructions = f2B51_parent_instructions;
                           body.emit(f2B51);

                           /* END IF */

                           body.emit(assign(r2B40, r2B50, 0x01));

                           body.emit(assign(r2B41, body.constant(0u), 0x01));


                        body.instructions = f2B4D_parent_instructions;
                        body.emit(f2B4D);

                        /* END IF */


                     body.instructions = f2B4B_parent_instructions;
                     body.emit(f2B4B);

                     /* END IF */

                     body.emit(assign(r2B42, body.constant(0u), 0x01));


                  body.instructions = f2B47_parent_instructions;
                  body.emit(f2B47);

                  /* END IF */

                  ir_expression *const r2B55 = nequal(r2B3E, body.constant(0u));
                  ir_expression *const r2B56 = expr(ir_unop_b2i, r2B55);
                  ir_expression *const r2B57 = expr(ir_unop_i2u, r2B56);
                  body.emit(assign(r2B40, bit_or(r2B40, r2B57), 0x01));


               body.instructions = f2B45_parent_instructions;
               body.emit(f2B45);

               /* END IF */

               body.emit(assign(r2B05, r2B42, 0x01));

               body.emit(assign(r2B06, r2B41, 0x01));

               body.emit(assign(r2B08, r2B40, 0x01));

               body.emit(assign(r2B07, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2B3A->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2B59 = equal(r2B0D, body.constant(int(2047)));
               ir_if *f2B58 = new(mem_ctx) ir_if(operand(r2B59).val);
               exec_list *const f2B58_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B58->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2B5B = bit_or(r2B05, r2B06);
                  ir_expression *const r2B5C = bit_or(r2B03, r2B04);
                  ir_expression *const r2B5D = bit_or(r2B5B, r2B5C);
                  ir_expression *const r2B5E = nequal(r2B5D, body.constant(0u));
                  ir_if *f2B5A = new(mem_ctx) ir_if(operand(r2B5E).val);
                  exec_list *const f2B5A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B5A->then_instructions;

                     ir_variable *const r2B5F = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2B5F, swizzle_x(r270C), 0x01));

                     ir_variable *const r2B60 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2B60, body.constant(0u), 0x01));

                     ir_variable *const r2B61 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2B5F, bit_or(swizzle_y(r270C), body.constant(524288u)), 0x02));

                     body.emit(assign(r2B60, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2B63 = lshift(swizzle_y(r270C), body.constant(int(1)));
                     ir_expression *const r2B64 = lequal(body.constant(4292870144u), r2B63);
                     ir_expression *const r2B65 = nequal(swizzle_x(r270C), body.constant(0u));
                     ir_expression *const r2B66 = bit_and(swizzle_y(r270C), body.constant(1048575u));
                     ir_expression *const r2B67 = nequal(r2B66, body.constant(0u));
                     ir_expression *const r2B68 = logic_or(r2B65, r2B67);
                     ir_expression *const r2B69 = logic_and(r2B64, r2B68);
                     ir_if *f2B62 = new(mem_ctx) ir_if(operand(r2B69).val);
                     exec_list *const f2B62_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B62->then_instructions;

                        body.emit(assign(r2B61, r2B5F, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B62->else_instructions;

                        body.emit(assign(r2B61, r2B60, 0x03));


                     body.instructions = f2B62_parent_instructions;
                     body.emit(f2B62);

                     /* END IF */

                     body.emit(assign(r2B01, r2B61, 0x03));

                     body.emit(assign(r2B00, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B5A->else_instructions;

                     body.emit(assign(r2B01, r270C, 0x03));

                     body.emit(assign(r2B00, body.constant(false), 0x01));


                  body.instructions = f2B5A_parent_instructions;
                  body.emit(f2B5A);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B58->else_instructions;

                  ir_variable *const r2B6A = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r2B6B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2B6B, add(r2B06, r2B04), 0x01));

                  ir_expression *const r2B6C = add(r2B05, r2B03);
                  ir_expression *const r2B6D = less(r2B6B, r2B06);
                  ir_expression *const r2B6E = expr(ir_unop_b2i, r2B6D);
                  ir_expression *const r2B6F = expr(ir_unop_i2u, r2B6E);
                  body.emit(assign(r2B6A, add(r2B6C, r2B6F), 0x01));

                  body.emit(assign(r2B09, r2B6A, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2B71 = equal(r2B0D, body.constant(int(0)));
                  ir_if *f2B70 = new(mem_ctx) ir_if(operand(r2B71).val);
                  exec_list *const f2B70_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B70->then_instructions;

                     ir_variable *const r2B72 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2B72);
                     ir_expression *const r2B73 = lshift(r2742, body.constant(int(31)));
                     body.emit(assign(r2B72, add(r2B73, r2B6A), 0x02));

                     body.emit(assign(r2B72, r2B6B, 0x01));

                     body.emit(assign(r2B01, r2B72, 0x03));

                     body.emit(assign(r2B00, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B70->else_instructions;

                     body.emit(assign(r2B09, bit_or(r2B6A, body.constant(2097152u)), 0x01));

                     body.emit(assign(r2B07, r2B0D, 0x01));

                     ir_variable *const r2B74 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2B74);
                     ir_variable *const r2B75 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2B75);
                     ir_variable *const r2B76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2B76);
                     body.emit(assign(r2B74, lshift(r2B6B, body.constant(int(31))), 0x01));

                     ir_expression *const r2B77 = lshift(r2B09, body.constant(int(31)));
                     ir_expression *const r2B78 = rshift(r2B6B, body.constant(int(1)));
                     body.emit(assign(r2B75, bit_or(r2B77, r2B78), 0x01));

                     body.emit(assign(r2B76, rshift(r2B09, body.constant(int(1))), 0x01));

                     body.emit(assign(r2B74, bit_or(r2B74, body.constant(0u)), 0x01));

                     body.emit(assign(r2B09, r2B76, 0x01));

                     body.emit(assign(r2B08, r2B74, 0x01));

                     ir_variable *const r2B79 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2B79, r2B0D, 0x01));

                     ir_variable *const r2B7A = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2B7A, r2B76, 0x01));

                     ir_variable *const r2B7B = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2B7B, r2B75, 0x01));

                     ir_variable *const r2B7C = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2B7C, r2B74, 0x01));

                     ir_variable *const r2B7D = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2B7D, body.constant(true), 0x01));

                     ir_variable *const r2B7E = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2B7F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2B7F);
                     ir_expression *const r2B80 = expr(ir_unop_u2i, r2B74);
                     body.emit(assign(r2B7F, less(r2B80, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2B82 = lequal(body.constant(int(2045)), r2B0D);
                     ir_if *f2B81 = new(mem_ctx) ir_if(operand(r2B82).val);
                     exec_list *const f2B81_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B81->then_instructions;

                        ir_variable *const r2B83 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2B85 = less(body.constant(int(2045)), r2B0D);
                        ir_if *f2B84 = new(mem_ctx) ir_if(operand(r2B85).val);
                        exec_list *const f2B84_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B84->then_instructions;

                           body.emit(assign(r2B83, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B84->else_instructions;

                           ir_variable *const r2B86 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2B88 = equal(r2B0D, body.constant(int(2045)));
                           ir_if *f2B87 = new(mem_ctx) ir_if(operand(r2B88).val);
                           exec_list *const f2B87_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B87->then_instructions;

                              ir_expression *const r2B89 = equal(body.constant(2097151u), r2B76);
                              ir_expression *const r2B8A = equal(body.constant(4294967295u), r2B75);
                              body.emit(assign(r2B86, logic_and(r2B89, r2B8A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B87->else_instructions;

                              body.emit(assign(r2B86, body.constant(false), 0x01));


                           body.instructions = f2B87_parent_instructions;
                           body.emit(f2B87);

                           /* END IF */

                           body.emit(assign(r2B83, logic_and(r2B86, r2B7F), 0x01));


                        body.instructions = f2B84_parent_instructions;
                        body.emit(f2B84);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2B8B = new(mem_ctx) ir_if(operand(r2B83).val);
                        exec_list *const f2B8B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B8B->then_instructions;

                           ir_variable *const r2B8C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2B8C);
                           ir_expression *const r2B8D = lshift(r2742, body.constant(int(31)));
                           body.emit(assign(r2B8C, add(r2B8D, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2B8C, body.constant(0u), 0x01));

                           body.emit(assign(r2B7E, r2B8C, 0x03));

                           body.emit(assign(r2B7D, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B8B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2B8F = less(r2B0D, body.constant(int(0)));
                           ir_if *f2B8E = new(mem_ctx) ir_if(operand(r2B8F).val);
                           exec_list *const f2B8E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B8E->then_instructions;

                              ir_variable *const r2B90 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2B90, r2B74, 0x01));

                              ir_variable *const r2B91 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2B91, neg(r2B0D), 0x01));

                              ir_variable *const r2B92 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2B92);
                              ir_variable *const r2B93 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2B93);
                              ir_variable *const r2B94 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2B94);
                              ir_variable *const r2B95 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2B96 = neg(r2B91);
                              body.emit(assign(r2B95, bit_and(r2B96, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2B98 = equal(r2B91, body.constant(int(0)));
                              ir_if *f2B97 = new(mem_ctx) ir_if(operand(r2B98).val);
                              exec_list *const f2B97_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2B97->then_instructions;

                                 body.emit(assign(r2B92, r2B74, 0x01));

                                 body.emit(assign(r2B93, r2B75, 0x01));

                                 body.emit(assign(r2B94, r2B76, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2B97->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2B9A = less(r2B91, body.constant(int(32)));
                                 ir_if *f2B99 = new(mem_ctx) ir_if(operand(r2B9A).val);
                                 exec_list *const f2B99_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2B99->then_instructions;

                                    body.emit(assign(r2B92, lshift(r2B75, r2B95), 0x01));

                                    ir_expression *const r2B9B = lshift(r2B76, r2B95);
                                    ir_expression *const r2B9C = rshift(r2B75, r2B91);
                                    body.emit(assign(r2B93, bit_or(r2B9B, r2B9C), 0x01));

                                    body.emit(assign(r2B94, rshift(r2B76, r2B91), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2B99->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2B9E = equal(r2B91, body.constant(int(32)));
                                    ir_if *f2B9D = new(mem_ctx) ir_if(operand(r2B9E).val);
                                    exec_list *const f2B9D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2B9D->then_instructions;

                                       body.emit(assign(r2B92, r2B75, 0x01));

                                       body.emit(assign(r2B93, r2B76, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2B9D->else_instructions;

                                       body.emit(assign(r2B90, bit_or(r2B74, r2B75), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2BA0 = less(r2B91, body.constant(int(64)));
                                       ir_if *f2B9F = new(mem_ctx) ir_if(operand(r2BA0).val);
                                       exec_list *const f2B9F_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2B9F->then_instructions;

                                          body.emit(assign(r2B92, lshift(r2B76, r2B95), 0x01));

                                          ir_expression *const r2BA1 = bit_and(r2B91, body.constant(int(31)));
                                          body.emit(assign(r2B93, rshift(r2B76, r2BA1), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2B9F->else_instructions;

                                          ir_variable *const r2BA2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2BA4 = equal(r2B91, body.constant(int(64)));
                                          ir_if *f2BA3 = new(mem_ctx) ir_if(operand(r2BA4).val);
                                          exec_list *const f2BA3_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2BA3->then_instructions;

                                             body.emit(assign(r2BA2, r2B76, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2BA3->else_instructions;

                                             ir_expression *const r2BA5 = nequal(r2B76, body.constant(0u));
                                             ir_expression *const r2BA6 = expr(ir_unop_b2i, r2BA5);
                                             body.emit(assign(r2BA2, expr(ir_unop_i2u, r2BA6), 0x01));


                                          body.instructions = f2BA3_parent_instructions;
                                          body.emit(f2BA3);

                                          /* END IF */

                                          body.emit(assign(r2B92, r2BA2, 0x01));

                                          body.emit(assign(r2B93, body.constant(0u), 0x01));


                                       body.instructions = f2B9F_parent_instructions;
                                       body.emit(f2B9F);

                                       /* END IF */


                                    body.instructions = f2B9D_parent_instructions;
                                    body.emit(f2B9D);

                                    /* END IF */

                                    body.emit(assign(r2B94, body.constant(0u), 0x01));


                                 body.instructions = f2B99_parent_instructions;
                                 body.emit(f2B99);

                                 /* END IF */

                                 ir_expression *const r2BA7 = nequal(r2B90, body.constant(0u));
                                 ir_expression *const r2BA8 = expr(ir_unop_b2i, r2BA7);
                                 ir_expression *const r2BA9 = expr(ir_unop_i2u, r2BA8);
                                 body.emit(assign(r2B92, bit_or(r2B92, r2BA9), 0x01));


                              body.instructions = f2B97_parent_instructions;
                              body.emit(f2B97);

                              /* END IF */

                              body.emit(assign(r2B7A, r2B94, 0x01));

                              body.emit(assign(r2B7B, r2B93, 0x01));

                              body.emit(assign(r2B7C, r2B92, 0x01));

                              body.emit(assign(r2B79, body.constant(int(0)), 0x01));

                              body.emit(assign(r2B7F, less(r2B92, body.constant(0u)), 0x01));


                           body.instructions = f2B8E_parent_instructions;
                           body.emit(f2B8E);

                           /* END IF */


                        body.instructions = f2B8B_parent_instructions;
                        body.emit(f2B8B);

                        /* END IF */


                     body.instructions = f2B81_parent_instructions;
                     body.emit(f2B81);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2BAA = new(mem_ctx) ir_if(operand(r2B7D).val);
                     exec_list *const f2BAA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2BAA->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2BAB = new(mem_ctx) ir_if(operand(r2B7F).val);
                        exec_list *const f2BAB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BAB->then_instructions;

                           ir_variable *const r2BAC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2BAC, add(r2B7B, body.constant(1u)), 0x01));

                           ir_expression *const r2BAD = less(r2BAC, r2B7B);
                           ir_expression *const r2BAE = expr(ir_unop_b2i, r2BAD);
                           ir_expression *const r2BAF = expr(ir_unop_i2u, r2BAE);
                           body.emit(assign(r2B7A, add(r2B7A, r2BAF), 0x01));

                           ir_expression *const r2BB0 = equal(r2B7C, body.constant(0u));
                           ir_expression *const r2BB1 = expr(ir_unop_b2i, r2BB0);
                           ir_expression *const r2BB2 = expr(ir_unop_i2u, r2BB1);
                           ir_expression *const r2BB3 = add(r2B7C, r2BB2);
                           ir_expression *const r2BB4 = bit_and(r2BB3, body.constant(1u));
                           ir_expression *const r2BB5 = expr(ir_unop_bit_not, r2BB4);
                           body.emit(assign(r2B7B, bit_and(r2BAC, r2BB5), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2BAB->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2BB7 = bit_or(r2B7A, r2B7B);
                           ir_expression *const r2BB8 = equal(r2BB7, body.constant(0u));
                           ir_if *f2BB6 = new(mem_ctx) ir_if(operand(r2BB8).val);
                           exec_list *const f2BB6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BB6->then_instructions;

                              body.emit(assign(r2B79, body.constant(int(0)), 0x01));


                           body.instructions = f2BB6_parent_instructions;
                           body.emit(f2BB6);

                           /* END IF */


                        body.instructions = f2BAB_parent_instructions;
                        body.emit(f2BAB);

                        /* END IF */

                        ir_variable *const r2BB9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2BB9);
                        ir_expression *const r2BBA = lshift(r2742, body.constant(int(31)));
                        ir_expression *const r2BBB = expr(ir_unop_i2u, r2B79);
                        ir_expression *const r2BBC = lshift(r2BBB, body.constant(int(20)));
                        ir_expression *const r2BBD = add(r2BBA, r2BBC);
                        body.emit(assign(r2BB9, add(r2BBD, r2B7A), 0x02));

                        body.emit(assign(r2BB9, r2B7B, 0x01));

                        body.emit(assign(r2B7E, r2BB9, 0x03));

                        body.emit(assign(r2B7D, body.constant(false), 0x01));


                     body.instructions = f2BAA_parent_instructions;
                     body.emit(f2BAA);

                     /* END IF */

                     body.emit(assign(r2B01, r2B7E, 0x03));

                     body.emit(assign(r2B00, body.constant(false), 0x01));


                  body.instructions = f2B70_parent_instructions;
                  body.emit(f2B70);

                  /* END IF */


               body.instructions = f2B58_parent_instructions;
               body.emit(f2B58);

               /* END IF */


            body.instructions = f2B3A_parent_instructions;
            body.emit(f2B3A);

            /* END IF */


         body.instructions = f2B12_parent_instructions;
         body.emit(f2B12);

         /* END IF */

         /* IF CONDITION */
         ir_if *f2BBE = new(mem_ctx) ir_if(operand(r2B00).val);
         exec_list *const f2BBE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2BBE->then_instructions;

            body.emit(assign(r2B05, bit_or(r2B05, body.constant(1048576u)), 0x01));

            ir_variable *const r2BBF = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2BC0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r2BC0, add(r2B06, r2B04), 0x01));

            ir_expression *const r2BC1 = add(r2B05, r2B03);
            ir_expression *const r2BC2 = less(r2BC0, r2B06);
            ir_expression *const r2BC3 = expr(ir_unop_b2i, r2BC2);
            ir_expression *const r2BC4 = expr(ir_unop_i2u, r2BC3);
            body.emit(assign(r2BBF, add(r2BC1, r2BC4), 0x01));

            body.emit(assign(r2B09, r2BBF, 0x01));

            body.emit(assign(r2B07, add(r2B07, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2BC6 = less(r2BBF, body.constant(2097152u));
            ir_if *f2BC5 = new(mem_ctx) ir_if(operand(r2BC6).val);
            exec_list *const f2BC5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2BC5->then_instructions;

               ir_variable *const r2BC7 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2BC7, r2B07, 0x01));

               ir_variable *const r2BC8 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2BC8, r2BBF, 0x01));

               ir_variable *const r2BC9 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2BC9, r2BC0, 0x01));

               ir_variable *const r2BCA = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2BCA, r2B08, 0x01));

               ir_variable *const r2BCB = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2BCB, body.constant(true), 0x01));

               ir_variable *const r2BCC = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2BCD = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2BCD);
               ir_expression *const r2BCE = expr(ir_unop_u2i, r2B08);
               body.emit(assign(r2BCD, less(r2BCE, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2BD0 = lequal(body.constant(int(2045)), r2B07);
               ir_if *f2BCF = new(mem_ctx) ir_if(operand(r2BD0).val);
               exec_list *const f2BCF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2BCF->then_instructions;

                  ir_variable *const r2BD1 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2BD3 = less(body.constant(int(2045)), r2B07);
                  ir_if *f2BD2 = new(mem_ctx) ir_if(operand(r2BD3).val);
                  exec_list *const f2BD2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2BD2->then_instructions;

                     body.emit(assign(r2BD1, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2BD2->else_instructions;

                     ir_variable *const r2BD4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2BD6 = equal(r2B07, body.constant(int(2045)));
                     ir_if *f2BD5 = new(mem_ctx) ir_if(operand(r2BD6).val);
                     exec_list *const f2BD5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2BD5->then_instructions;

                        ir_expression *const r2BD7 = equal(body.constant(2097151u), r2BBF);
                        ir_expression *const r2BD8 = equal(body.constant(4294967295u), r2BC0);
                        body.emit(assign(r2BD4, logic_and(r2BD7, r2BD8), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2BD5->else_instructions;

                        body.emit(assign(r2BD4, body.constant(false), 0x01));


                     body.instructions = f2BD5_parent_instructions;
                     body.emit(f2BD5);

                     /* END IF */

                     body.emit(assign(r2BD1, logic_and(r2BD4, r2BCD), 0x01));


                  body.instructions = f2BD2_parent_instructions;
                  body.emit(f2BD2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2BD9 = new(mem_ctx) ir_if(operand(r2BD1).val);
                  exec_list *const f2BD9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2BD9->then_instructions;

                     ir_variable *const r2BDA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2BDA);
                     ir_expression *const r2BDB = lshift(r2742, body.constant(int(31)));
                     body.emit(assign(r2BDA, add(r2BDB, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2BDA, body.constant(0u), 0x01));

                     body.emit(assign(r2BCC, r2BDA, 0x03));

                     body.emit(assign(r2BCB, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2BD9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2BDD = less(r2B07, body.constant(int(0)));
                     ir_if *f2BDC = new(mem_ctx) ir_if(operand(r2BDD).val);
                     exec_list *const f2BDC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2BDC->then_instructions;

                        ir_variable *const r2BDE = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2BDE, r2B08, 0x01));

                        ir_variable *const r2BDF = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2BDF, neg(r2B07), 0x01));

                        ir_variable *const r2BE0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2BE0);
                        ir_variable *const r2BE1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2BE1);
                        ir_variable *const r2BE2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2BE2);
                        ir_variable *const r2BE3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2BE4 = neg(r2BDF);
                        body.emit(assign(r2BE3, bit_and(r2BE4, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2BE6 = equal(r2BDF, body.constant(int(0)));
                        ir_if *f2BE5 = new(mem_ctx) ir_if(operand(r2BE6).val);
                        exec_list *const f2BE5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BE5->then_instructions;

                           body.emit(assign(r2BE0, r2B08, 0x01));

                           body.emit(assign(r2BE1, r2BC0, 0x01));

                           body.emit(assign(r2BE2, r2BBF, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2BE5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2BE8 = less(r2BDF, body.constant(int(32)));
                           ir_if *f2BE7 = new(mem_ctx) ir_if(operand(r2BE8).val);
                           exec_list *const f2BE7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BE7->then_instructions;

                              body.emit(assign(r2BE0, lshift(r2BC0, r2BE3), 0x01));

                              ir_expression *const r2BE9 = lshift(r2BBF, r2BE3);
                              ir_expression *const r2BEA = rshift(r2BC0, r2BDF);
                              body.emit(assign(r2BE1, bit_or(r2BE9, r2BEA), 0x01));

                              body.emit(assign(r2BE2, rshift(r2BBF, r2BDF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2BE7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2BEC = equal(r2BDF, body.constant(int(32)));
                              ir_if *f2BEB = new(mem_ctx) ir_if(operand(r2BEC).val);
                              exec_list *const f2BEB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BEB->then_instructions;

                                 body.emit(assign(r2BE0, r2BC0, 0x01));

                                 body.emit(assign(r2BE1, r2BBF, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2BEB->else_instructions;

                                 body.emit(assign(r2BDE, bit_or(r2B08, r2BC0), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2BEE = less(r2BDF, body.constant(int(64)));
                                 ir_if *f2BED = new(mem_ctx) ir_if(operand(r2BEE).val);
                                 exec_list *const f2BED_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2BED->then_instructions;

                                    body.emit(assign(r2BE0, lshift(r2BBF, r2BE3), 0x01));

                                    ir_expression *const r2BEF = bit_and(r2BDF, body.constant(int(31)));
                                    body.emit(assign(r2BE1, rshift(r2BBF, r2BEF), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2BED->else_instructions;

                                    ir_variable *const r2BF0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2BF2 = equal(r2BDF, body.constant(int(64)));
                                    ir_if *f2BF1 = new(mem_ctx) ir_if(operand(r2BF2).val);
                                    exec_list *const f2BF1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2BF1->then_instructions;

                                       body.emit(assign(r2BF0, r2BBF, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2BF1->else_instructions;

                                       ir_expression *const r2BF3 = nequal(r2BBF, body.constant(0u));
                                       ir_expression *const r2BF4 = expr(ir_unop_b2i, r2BF3);
                                       body.emit(assign(r2BF0, expr(ir_unop_i2u, r2BF4), 0x01));


                                    body.instructions = f2BF1_parent_instructions;
                                    body.emit(f2BF1);

                                    /* END IF */

                                    body.emit(assign(r2BE0, r2BF0, 0x01));

                                    body.emit(assign(r2BE1, body.constant(0u), 0x01));


                                 body.instructions = f2BED_parent_instructions;
                                 body.emit(f2BED);

                                 /* END IF */


                              body.instructions = f2BEB_parent_instructions;
                              body.emit(f2BEB);

                              /* END IF */

                              body.emit(assign(r2BE2, body.constant(0u), 0x01));


                           body.instructions = f2BE7_parent_instructions;
                           body.emit(f2BE7);

                           /* END IF */

                           ir_expression *const r2BF5 = nequal(r2BDE, body.constant(0u));
                           ir_expression *const r2BF6 = expr(ir_unop_b2i, r2BF5);
                           ir_expression *const r2BF7 = expr(ir_unop_i2u, r2BF6);
                           body.emit(assign(r2BE0, bit_or(r2BE0, r2BF7), 0x01));


                        body.instructions = f2BE5_parent_instructions;
                        body.emit(f2BE5);

                        /* END IF */

                        body.emit(assign(r2BC8, r2BE2, 0x01));

                        body.emit(assign(r2BC9, r2BE1, 0x01));

                        body.emit(assign(r2BCA, r2BE0, 0x01));

                        body.emit(assign(r2BC7, body.constant(int(0)), 0x01));

                        body.emit(assign(r2BCD, less(r2BE0, body.constant(0u)), 0x01));


                     body.instructions = f2BDC_parent_instructions;
                     body.emit(f2BDC);

                     /* END IF */


                  body.instructions = f2BD9_parent_instructions;
                  body.emit(f2BD9);

                  /* END IF */


               body.instructions = f2BCF_parent_instructions;
               body.emit(f2BCF);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2BF8 = new(mem_ctx) ir_if(operand(r2BCB).val);
               exec_list *const f2BF8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2BF8->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2BF9 = new(mem_ctx) ir_if(operand(r2BCD).val);
                  exec_list *const f2BF9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2BF9->then_instructions;

                     ir_variable *const r2BFA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2BFA, add(r2BC9, body.constant(1u)), 0x01));

                     ir_expression *const r2BFB = less(r2BFA, r2BC9);
                     ir_expression *const r2BFC = expr(ir_unop_b2i, r2BFB);
                     ir_expression *const r2BFD = expr(ir_unop_i2u, r2BFC);
                     body.emit(assign(r2BC8, add(r2BC8, r2BFD), 0x01));

                     ir_expression *const r2BFE = equal(r2BCA, body.constant(0u));
                     ir_expression *const r2BFF = expr(ir_unop_b2i, r2BFE);
                     ir_expression *const r2C00 = expr(ir_unop_i2u, r2BFF);
                     ir_expression *const r2C01 = add(r2BCA, r2C00);
                     ir_expression *const r2C02 = bit_and(r2C01, body.constant(1u));
                     ir_expression *const r2C03 = expr(ir_unop_bit_not, r2C02);
                     body.emit(assign(r2BC9, bit_and(r2BFA, r2C03), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2BF9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2C05 = bit_or(r2BC8, r2BC9);
                     ir_expression *const r2C06 = equal(r2C05, body.constant(0u));
                     ir_if *f2C04 = new(mem_ctx) ir_if(operand(r2C06).val);
                     exec_list *const f2C04_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C04->then_instructions;

                        body.emit(assign(r2BC7, body.constant(int(0)), 0x01));


                     body.instructions = f2C04_parent_instructions;
                     body.emit(f2C04);

                     /* END IF */


                  body.instructions = f2BF9_parent_instructions;
                  body.emit(f2BF9);

                  /* END IF */

                  ir_variable *const r2C07 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2C07);
                  ir_expression *const r2C08 = lshift(r2742, body.constant(int(31)));
                  ir_expression *const r2C09 = expr(ir_unop_i2u, r2BC7);
                  ir_expression *const r2C0A = lshift(r2C09, body.constant(int(20)));
                  ir_expression *const r2C0B = add(r2C08, r2C0A);
                  body.emit(assign(r2C07, add(r2C0B, r2BC8), 0x02));

                  body.emit(assign(r2C07, r2BC9, 0x01));

                  body.emit(assign(r2BCC, r2C07, 0x03));

                  body.emit(assign(r2BCB, body.constant(false), 0x01));


               body.instructions = f2BF8_parent_instructions;
               body.emit(f2BF8);

               /* END IF */

               body.emit(assign(r2B01, r2BCC, 0x03));

               body.emit(assign(r2B00, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2BC5->else_instructions;

               body.emit(assign(r2B07, add(r2B07, body.constant(int(1))), 0x01));

               ir_variable *const r2C0C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2C0C);
               ir_variable *const r2C0D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2C0D);
               ir_variable *const r2C0E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2C0E);
               body.emit(assign(r2C0C, lshift(r2BC0, body.constant(int(31))), 0x01));

               ir_expression *const r2C0F = lshift(r2BBF, body.constant(int(31)));
               ir_expression *const r2C10 = rshift(r2BC0, body.constant(int(1)));
               body.emit(assign(r2C0D, bit_or(r2C0F, r2C10), 0x01));

               body.emit(assign(r2C0E, rshift(r2BBF, body.constant(int(1))), 0x01));

               ir_expression *const r2C11 = nequal(r2B08, body.constant(0u));
               ir_expression *const r2C12 = expr(ir_unop_b2i, r2C11);
               ir_expression *const r2C13 = expr(ir_unop_i2u, r2C12);
               body.emit(assign(r2C0C, bit_or(r2C0C, r2C13), 0x01));

               body.emit(assign(r2B09, r2C0E, 0x01));

               body.emit(assign(r2B08, r2C0C, 0x01));

               ir_variable *const r2C14 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2C14, r2B07, 0x01));

               ir_variable *const r2C15 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2C15, r2C0E, 0x01));

               ir_variable *const r2C16 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2C16, r2C0D, 0x01));

               ir_variable *const r2C17 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2C17, r2C0C, 0x01));

               ir_variable *const r2C18 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2C18, body.constant(true), 0x01));

               ir_variable *const r2C19 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2C1A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2C1A);
               ir_expression *const r2C1B = expr(ir_unop_u2i, r2C0C);
               body.emit(assign(r2C1A, less(r2C1B, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2C1D = lequal(body.constant(int(2045)), r2B07);
               ir_if *f2C1C = new(mem_ctx) ir_if(operand(r2C1D).val);
               exec_list *const f2C1C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2C1C->then_instructions;

                  ir_variable *const r2C1E = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2C20 = less(body.constant(int(2045)), r2B07);
                  ir_if *f2C1F = new(mem_ctx) ir_if(operand(r2C20).val);
                  exec_list *const f2C1F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2C1F->then_instructions;

                     body.emit(assign(r2C1E, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2C1F->else_instructions;

                     ir_variable *const r2C21 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2C23 = equal(r2B07, body.constant(int(2045)));
                     ir_if *f2C22 = new(mem_ctx) ir_if(operand(r2C23).val);
                     exec_list *const f2C22_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C22->then_instructions;

                        ir_expression *const r2C24 = equal(body.constant(2097151u), r2C0E);
                        ir_expression *const r2C25 = equal(body.constant(4294967295u), r2C0D);
                        body.emit(assign(r2C21, logic_and(r2C24, r2C25), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2C22->else_instructions;

                        body.emit(assign(r2C21, body.constant(false), 0x01));


                     body.instructions = f2C22_parent_instructions;
                     body.emit(f2C22);

                     /* END IF */

                     body.emit(assign(r2C1E, logic_and(r2C21, r2C1A), 0x01));


                  body.instructions = f2C1F_parent_instructions;
                  body.emit(f2C1F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2C26 = new(mem_ctx) ir_if(operand(r2C1E).val);
                  exec_list *const f2C26_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2C26->then_instructions;

                     ir_variable *const r2C27 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2C27);
                     ir_expression *const r2C28 = lshift(r2742, body.constant(int(31)));
                     body.emit(assign(r2C27, add(r2C28, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2C27, body.constant(0u), 0x01));

                     body.emit(assign(r2C19, r2C27, 0x03));

                     body.emit(assign(r2C18, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2C26->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2C2A = less(r2B07, body.constant(int(0)));
                     ir_if *f2C29 = new(mem_ctx) ir_if(operand(r2C2A).val);
                     exec_list *const f2C29_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C29->then_instructions;

                        ir_variable *const r2C2B = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2C2B, r2C0C, 0x01));

                        ir_variable *const r2C2C = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2C2C, neg(r2B07), 0x01));

                        ir_variable *const r2C2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2C2D);
                        ir_variable *const r2C2E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2C2E);
                        ir_variable *const r2C2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2C2F);
                        ir_variable *const r2C30 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2C31 = neg(r2C2C);
                        body.emit(assign(r2C30, bit_and(r2C31, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2C33 = equal(r2C2C, body.constant(int(0)));
                        ir_if *f2C32 = new(mem_ctx) ir_if(operand(r2C33).val);
                        exec_list *const f2C32_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2C32->then_instructions;

                           body.emit(assign(r2C2D, r2C0C, 0x01));

                           body.emit(assign(r2C2E, r2C0D, 0x01));

                           body.emit(assign(r2C2F, r2C0E, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2C32->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2C35 = less(r2C2C, body.constant(int(32)));
                           ir_if *f2C34 = new(mem_ctx) ir_if(operand(r2C35).val);
                           exec_list *const f2C34_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C34->then_instructions;

                              body.emit(assign(r2C2D, lshift(r2C0D, r2C30), 0x01));

                              ir_expression *const r2C36 = lshift(r2C0E, r2C30);
                              ir_expression *const r2C37 = rshift(r2C0D, r2C2C);
                              body.emit(assign(r2C2E, bit_or(r2C36, r2C37), 0x01));

                              body.emit(assign(r2C2F, rshift(r2C0E, r2C2C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2C34->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2C39 = equal(r2C2C, body.constant(int(32)));
                              ir_if *f2C38 = new(mem_ctx) ir_if(operand(r2C39).val);
                              exec_list *const f2C38_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C38->then_instructions;

                                 body.emit(assign(r2C2D, r2C0D, 0x01));

                                 body.emit(assign(r2C2E, r2C0E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C38->else_instructions;

                                 body.emit(assign(r2C2B, bit_or(r2C0C, r2C0D), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2C3B = less(r2C2C, body.constant(int(64)));
                                 ir_if *f2C3A = new(mem_ctx) ir_if(operand(r2C3B).val);
                                 exec_list *const f2C3A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C3A->then_instructions;

                                    body.emit(assign(r2C2D, lshift(r2C0E, r2C30), 0x01));

                                    ir_expression *const r2C3C = bit_and(r2C2C, body.constant(int(31)));
                                    body.emit(assign(r2C2E, rshift(r2C0E, r2C3C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C3A->else_instructions;

                                    ir_variable *const r2C3D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2C3F = equal(r2C2C, body.constant(int(64)));
                                    ir_if *f2C3E = new(mem_ctx) ir_if(operand(r2C3F).val);
                                    exec_list *const f2C3E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C3E->then_instructions;

                                       body.emit(assign(r2C3D, r2C0E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2C3E->else_instructions;

                                       ir_expression *const r2C40 = nequal(r2C0E, body.constant(0u));
                                       ir_expression *const r2C41 = expr(ir_unop_b2i, r2C40);
                                       body.emit(assign(r2C3D, expr(ir_unop_i2u, r2C41), 0x01));


                                    body.instructions = f2C3E_parent_instructions;
                                    body.emit(f2C3E);

                                    /* END IF */

                                    body.emit(assign(r2C2D, r2C3D, 0x01));

                                    body.emit(assign(r2C2E, body.constant(0u), 0x01));


                                 body.instructions = f2C3A_parent_instructions;
                                 body.emit(f2C3A);

                                 /* END IF */


                              body.instructions = f2C38_parent_instructions;
                              body.emit(f2C38);

                              /* END IF */

                              body.emit(assign(r2C2F, body.constant(0u), 0x01));


                           body.instructions = f2C34_parent_instructions;
                           body.emit(f2C34);

                           /* END IF */

                           ir_expression *const r2C42 = nequal(r2C2B, body.constant(0u));
                           ir_expression *const r2C43 = expr(ir_unop_b2i, r2C42);
                           ir_expression *const r2C44 = expr(ir_unop_i2u, r2C43);
                           body.emit(assign(r2C2D, bit_or(r2C2D, r2C44), 0x01));


                        body.instructions = f2C32_parent_instructions;
                        body.emit(f2C32);

                        /* END IF */

                        body.emit(assign(r2C15, r2C2F, 0x01));

                        body.emit(assign(r2C16, r2C2E, 0x01));

                        body.emit(assign(r2C17, r2C2D, 0x01));

                        body.emit(assign(r2C14, body.constant(int(0)), 0x01));

                        body.emit(assign(r2C1A, less(r2C2D, body.constant(0u)), 0x01));


                     body.instructions = f2C29_parent_instructions;
                     body.emit(f2C29);

                     /* END IF */


                  body.instructions = f2C26_parent_instructions;
                  body.emit(f2C26);

                  /* END IF */


               body.instructions = f2C1C_parent_instructions;
               body.emit(f2C1C);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2C45 = new(mem_ctx) ir_if(operand(r2C18).val);
               exec_list *const f2C45_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2C45->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2C46 = new(mem_ctx) ir_if(operand(r2C1A).val);
                  exec_list *const f2C46_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2C46->then_instructions;

                     ir_variable *const r2C47 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2C47, add(r2C16, body.constant(1u)), 0x01));

                     ir_expression *const r2C48 = less(r2C47, r2C16);
                     ir_expression *const r2C49 = expr(ir_unop_b2i, r2C48);
                     ir_expression *const r2C4A = expr(ir_unop_i2u, r2C49);
                     body.emit(assign(r2C15, add(r2C15, r2C4A), 0x01));

                     ir_expression *const r2C4B = equal(r2C17, body.constant(0u));
                     ir_expression *const r2C4C = expr(ir_unop_b2i, r2C4B);
                     ir_expression *const r2C4D = expr(ir_unop_i2u, r2C4C);
                     ir_expression *const r2C4E = add(r2C17, r2C4D);
                     ir_expression *const r2C4F = bit_and(r2C4E, body.constant(1u));
                     ir_expression *const r2C50 = expr(ir_unop_bit_not, r2C4F);
                     body.emit(assign(r2C16, bit_and(r2C47, r2C50), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2C46->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2C52 = bit_or(r2C15, r2C16);
                     ir_expression *const r2C53 = equal(r2C52, body.constant(0u));
                     ir_if *f2C51 = new(mem_ctx) ir_if(operand(r2C53).val);
                     exec_list *const f2C51_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C51->then_instructions;

                        body.emit(assign(r2C14, body.constant(int(0)), 0x01));


                     body.instructions = f2C51_parent_instructions;
                     body.emit(f2C51);

                     /* END IF */


                  body.instructions = f2C46_parent_instructions;
                  body.emit(f2C46);

                  /* END IF */

                  ir_variable *const r2C54 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2C54);
                  ir_expression *const r2C55 = lshift(r2742, body.constant(int(31)));
                  ir_expression *const r2C56 = expr(ir_unop_i2u, r2C14);
                  ir_expression *const r2C57 = lshift(r2C56, body.constant(int(20)));
                  ir_expression *const r2C58 = add(r2C55, r2C57);
                  body.emit(assign(r2C54, add(r2C58, r2C15), 0x02));

                  body.emit(assign(r2C54, r2C16, 0x01));

                  body.emit(assign(r2C19, r2C54, 0x03));

                  body.emit(assign(r2C18, body.constant(false), 0x01));


               body.instructions = f2C45_parent_instructions;
               body.emit(f2C45);

               /* END IF */

               body.emit(assign(r2B01, r2C19, 0x03));

               body.emit(assign(r2B00, body.constant(false), 0x01));


            body.instructions = f2BC5_parent_instructions;
            body.emit(f2BC5);

            /* END IF */


         body.instructions = f2BBE_parent_instructions;
         body.emit(f2BBE);

         /* END IF */

         body.emit(assign(r2741, r2B01, 0x03));


      body.instructions = f2743_parent_instructions;
      body.emit(f2743);

      /* END IF */

      body.emit(assign(r273F, r2741, 0x03));


   body.instructions = f2740_parent_instructions;
   body.emit(f2740);

   /* END IF */

   ir_variable *const r2C59 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r2C5A = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r2C5A, rshift(swizzle_y(r270B), body.constant(int(31))), 0x01));

   ir_variable *const r2C5B = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r2C5B, rshift(swizzle_y(r273F), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r2C5D = equal(r2C5A, r2C5B);
   ir_if *f2C5C = new(mem_ctx) ir_if(operand(r2C5D).val);
   exec_list *const f2C5C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2C5C->then_instructions;

      ir_variable *const r2C5E = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r2C5E, r2C5A, 0x01));

      ir_variable *const r2C5F = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r2C60 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r2C60);
      ir_variable *const r2C61 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r2C61);
      ir_variable *const r2C62 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r2C62);
      ir_variable *const r2C63 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r2C63);
      ir_variable *const r2C64 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r2C64);
      ir_variable *const r2C65 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r2C65);
      ir_variable *const r2C66 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r2C66);
      ir_variable *const r2C67 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r2C67);
      ir_variable *const r2C68 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r2C69 = rshift(swizzle_y(r270B), body.constant(int(20)));
      ir_expression *const r2C6A = bit_and(r2C69, body.constant(2047u));
      body.emit(assign(r2C68, expr(ir_unop_u2i, r2C6A), 0x01));

      body.emit(assign(r2C62, r2C68, 0x01));

      ir_variable *const r2C6B = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r2C6C = rshift(swizzle_y(r273F), body.constant(int(20)));
      ir_expression *const r2C6D = bit_and(r2C6C, body.constant(2047u));
      body.emit(assign(r2C6B, expr(ir_unop_u2i, r2C6D), 0x01));

      body.emit(assign(r2C61, r2C6B, 0x01));

      body.emit(assign(r2C60, sub(r2C68, r2C6B), 0x01));

      ir_variable *const r2C6E = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r2C6E, lshift(swizzle_x(r270B), body.constant(int(10))), 0x01));

      ir_variable *const r2C6F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r2C70 = bit_and(swizzle_y(r270B), body.constant(1048575u));
      ir_expression *const r2C71 = lshift(r2C70, body.constant(int(10)));
      ir_expression *const r2C72 = rshift(swizzle_x(r270B), body.constant(int(22)));
      body.emit(assign(r2C6F, bit_or(r2C71, r2C72), 0x01));

      body.emit(assign(r2C65, r2C6F, 0x01));

      body.emit(assign(r2C66, r2C6E, 0x01));

      ir_variable *const r2C73 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r2C73, lshift(swizzle_x(r273F), body.constant(int(10))), 0x01));

      ir_variable *const r2C74 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r2C75 = bit_and(swizzle_y(r273F), body.constant(1048575u));
      ir_expression *const r2C76 = lshift(r2C75, body.constant(int(10)));
      ir_expression *const r2C77 = rshift(swizzle_x(r273F), body.constant(int(22)));
      body.emit(assign(r2C74, bit_or(r2C76, r2C77), 0x01));

      body.emit(assign(r2C63, r2C74, 0x01));

      body.emit(assign(r2C64, r2C73, 0x01));

      /* IF CONDITION */
      ir_expression *const r2C79 = less(body.constant(int(0)), r2C60);
      ir_if *f2C78 = new(mem_ctx) ir_if(operand(r2C79).val);
      exec_list *const f2C78_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2C78->then_instructions;

         /* IF CONDITION */
         ir_expression *const r2C7B = equal(r2C68, body.constant(int(2047)));
         ir_if *f2C7A = new(mem_ctx) ir_if(operand(r2C7B).val);
         exec_list *const f2C7A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2C7A->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2C7D = bit_or(r2C6F, r2C6E);
            ir_expression *const r2C7E = nequal(r2C7D, body.constant(0u));
            ir_if *f2C7C = new(mem_ctx) ir_if(operand(r2C7E).val);
            exec_list *const f2C7C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2C7C->then_instructions;

               ir_variable *const r2C7F = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r2C7F, swizzle_x(r270B), 0x01));

               ir_variable *const r2C80 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r2C80, swizzle_x(r273F), 0x01));

               ir_variable *const r2C81 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2C82 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r2C83 = rshift(swizzle_y(r270B), body.constant(int(19)));
               ir_expression *const r2C84 = bit_and(r2C83, body.constant(4095u));
               ir_expression *const r2C85 = equal(r2C84, body.constant(4094u));
               ir_expression *const r2C86 = nequal(swizzle_x(r270B), body.constant(0u));
               ir_expression *const r2C87 = bit_and(swizzle_y(r270B), body.constant(524287u));
               ir_expression *const r2C88 = nequal(r2C87, body.constant(0u));
               ir_expression *const r2C89 = logic_or(r2C86, r2C88);
               body.emit(assign(r2C82, logic_and(r2C85, r2C89), 0x01));

               ir_variable *const r2C8A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r2C8B = lshift(swizzle_y(r273F), body.constant(int(1)));
               ir_expression *const r2C8C = lequal(body.constant(4292870144u), r2C8B);
               ir_expression *const r2C8D = nequal(swizzle_x(r273F), body.constant(0u));
               ir_expression *const r2C8E = bit_and(swizzle_y(r273F), body.constant(1048575u));
               ir_expression *const r2C8F = nequal(r2C8E, body.constant(0u));
               ir_expression *const r2C90 = logic_or(r2C8D, r2C8F);
               body.emit(assign(r2C8A, logic_and(r2C8C, r2C90), 0x01));

               body.emit(assign(r2C7F, bit_or(swizzle_y(r270B), body.constant(524288u)), 0x02));

               body.emit(assign(r2C80, bit_or(swizzle_y(r273F), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r2C92 = lshift(swizzle_y(r270B), body.constant(int(1)));
               ir_expression *const r2C93 = lequal(body.constant(4292870144u), r2C92);
               ir_expression *const r2C94 = nequal(swizzle_x(r270B), body.constant(0u));
               ir_expression *const r2C95 = bit_and(swizzle_y(r270B), body.constant(1048575u));
               ir_expression *const r2C96 = nequal(r2C95, body.constant(0u));
               ir_expression *const r2C97 = logic_or(r2C94, r2C96);
               ir_expression *const r2C98 = logic_and(r2C93, r2C97);
               ir_if *f2C91 = new(mem_ctx) ir_if(operand(r2C98).val);
               exec_list *const f2C91_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2C91->then_instructions;

                  ir_variable *const r2C99 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2C9B = logic_and(r2C82, r2C8A);
                  ir_if *f2C9A = new(mem_ctx) ir_if(operand(r2C9B).val);
                  exec_list *const f2C9A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2C9A->then_instructions;

                     body.emit(assign(r2C99, r2C80, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2C9A->else_instructions;

                     body.emit(assign(r2C99, r2C7F, 0x03));


                  body.instructions = f2C9A_parent_instructions;
                  body.emit(f2C9A);

                  /* END IF */

                  body.emit(assign(r2C81, r2C99, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2C91->else_instructions;

                  body.emit(assign(r2C81, r2C80, 0x03));


               body.instructions = f2C91_parent_instructions;
               body.emit(f2C91);

               /* END IF */

               body.emit(assign(r2C5F, r2C81, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2C7C->else_instructions;

               body.emit(assign(r2C5F, r270B, 0x03));


            body.instructions = f2C7C_parent_instructions;
            body.emit(f2C7C);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2C7A->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2C9D = equal(r2C6B, body.constant(int(0)));
            ir_if *f2C9C = new(mem_ctx) ir_if(operand(r2C9D).val);
            exec_list *const f2C9C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2C9C->then_instructions;

               body.emit(assign(r2C60, add(r2C60, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2C9C->else_instructions;

               body.emit(assign(r2C63, bit_or(r2C74, body.constant(1073741824u)), 0x01));


            body.instructions = f2C9C_parent_instructions;
            body.emit(f2C9C);

            /* END IF */

            ir_variable *const r2C9E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r2C9E);
            ir_variable *const r2C9F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r2C9F);
            ir_variable *const r2CA0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r2CA1 = neg(r2C60);
            body.emit(assign(r2CA0, bit_and(r2CA1, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2CA3 = equal(r2C60, body.constant(int(0)));
            ir_if *f2CA2 = new(mem_ctx) ir_if(operand(r2CA3).val);
            exec_list *const f2CA2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CA2->then_instructions;

               body.emit(assign(r2C9E, r2C73, 0x01));

               body.emit(assign(r2C9F, r2C63, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2CA2->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2CA5 = less(r2C60, body.constant(int(32)));
               ir_if *f2CA4 = new(mem_ctx) ir_if(operand(r2CA5).val);
               exec_list *const f2CA4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CA4->then_instructions;

                  ir_expression *const r2CA6 = lshift(r2C63, r2CA0);
                  ir_expression *const r2CA7 = rshift(r2C73, r2C60);
                  ir_expression *const r2CA8 = bit_or(r2CA6, r2CA7);
                  ir_expression *const r2CA9 = lshift(r2C73, r2CA0);
                  ir_expression *const r2CAA = nequal(r2CA9, body.constant(0u));
                  ir_expression *const r2CAB = expr(ir_unop_b2i, r2CAA);
                  ir_expression *const r2CAC = expr(ir_unop_i2u, r2CAB);
                  body.emit(assign(r2C9E, bit_or(r2CA8, r2CAC), 0x01));

                  body.emit(assign(r2C9F, rshift(r2C63, r2C60), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2CA4->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2CAE = equal(r2C60, body.constant(int(32)));
                  ir_if *f2CAD = new(mem_ctx) ir_if(operand(r2CAE).val);
                  exec_list *const f2CAD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2CAD->then_instructions;

                     ir_expression *const r2CAF = nequal(r2C73, body.constant(0u));
                     ir_expression *const r2CB0 = expr(ir_unop_b2i, r2CAF);
                     ir_expression *const r2CB1 = expr(ir_unop_i2u, r2CB0);
                     body.emit(assign(r2C9E, bit_or(r2C63, r2CB1), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2CAD->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2CB3 = less(r2C60, body.constant(int(64)));
                     ir_if *f2CB2 = new(mem_ctx) ir_if(operand(r2CB3).val);
                     exec_list *const f2CB2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2CB2->then_instructions;

                        ir_expression *const r2CB4 = bit_and(r2C60, body.constant(int(31)));
                        ir_expression *const r2CB5 = rshift(r2C63, r2CB4);
                        ir_expression *const r2CB6 = lshift(r2C63, r2CA0);
                        ir_expression *const r2CB7 = bit_or(r2CB6, r2C73);
                        ir_expression *const r2CB8 = nequal(r2CB7, body.constant(0u));
                        ir_expression *const r2CB9 = expr(ir_unop_b2i, r2CB8);
                        ir_expression *const r2CBA = expr(ir_unop_i2u, r2CB9);
                        body.emit(assign(r2C9E, bit_or(r2CB5, r2CBA), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2CB2->else_instructions;

                        ir_expression *const r2CBB = bit_or(r2C63, r2C73);
                        ir_expression *const r2CBC = nequal(r2CBB, body.constant(0u));
                        ir_expression *const r2CBD = expr(ir_unop_b2i, r2CBC);
                        body.emit(assign(r2C9E, expr(ir_unop_i2u, r2CBD), 0x01));


                     body.instructions = f2CB2_parent_instructions;
                     body.emit(f2CB2);

                     /* END IF */


                  body.instructions = f2CAD_parent_instructions;
                  body.emit(f2CAD);

                  /* END IF */

                  body.emit(assign(r2C9F, body.constant(0u), 0x01));


               body.instructions = f2CA4_parent_instructions;
               body.emit(f2CA4);

               /* END IF */


            body.instructions = f2CA2_parent_instructions;
            body.emit(f2CA2);

            /* END IF */

            body.emit(assign(r2C63, r2C9F, 0x01));

            body.emit(assign(r2C64, r2C9E, 0x01));

            body.emit(assign(r2C65, bit_or(r2C6F, body.constant(1073741824u)), 0x01));

            ir_variable *const r2CBE = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2CBF = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r2CBF, sub(r2C6E, r2C9E), 0x01));

            ir_expression *const r2CC0 = sub(r2C65, r2C9F);
            ir_expression *const r2CC1 = less(r2C6E, r2C9E);
            ir_expression *const r2CC2 = expr(ir_unop_b2i, r2CC1);
            ir_expression *const r2CC3 = expr(ir_unop_i2u, r2CC2);
            body.emit(assign(r2CBE, sub(r2CC0, r2CC3), 0x01));

            body.emit(assign(r2C67, add(r2C68, body.constant(int(-1))), 0x01));

            ir_variable *const r2CC4 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r2CC4, add(r2C67, body.constant(int(-10))), 0x01));

            ir_variable *const r2CC5 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r2CC5, r2CBE, 0x01));

            ir_variable *const r2CC6 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2CC6, r2CBF, 0x01));

            ir_variable *const r2CC7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r2CC7);
            ir_variable *const r2CC8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r2CC8);
            /* IF CONDITION */
            ir_expression *const r2CCA = equal(r2CBE, body.constant(0u));
            ir_if *f2CC9 = new(mem_ctx) ir_if(operand(r2CCA).val);
            exec_list *const f2CC9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CC9->then_instructions;

               body.emit(assign(r2CC5, r2CBF, 0x01));

               body.emit(assign(r2CC6, body.constant(0u), 0x01));

               body.emit(assign(r2CC4, add(r2CC4, body.constant(int(-32))), 0x01));


            body.instructions = f2CC9_parent_instructions;
            body.emit(f2CC9);

            /* END IF */

            ir_variable *const r2CCB = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r2CCB, r2CC5, 0x01));

            ir_variable *const r2CCC = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r2CCD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r2CCD);
            /* IF CONDITION */
            ir_expression *const r2CCF = equal(r2CC5, body.constant(0u));
            ir_if *f2CCE = new(mem_ctx) ir_if(operand(r2CCF).val);
            exec_list *const f2CCE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CCE->then_instructions;

               body.emit(assign(r2CCC, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2CCE->else_instructions;

               body.emit(assign(r2CCD, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r2CD1 = bit_and(r2CC5, body.constant(4294901760u));
               ir_expression *const r2CD2 = equal(r2CD1, body.constant(0u));
               ir_if *f2CD0 = new(mem_ctx) ir_if(operand(r2CD2).val);
               exec_list *const f2CD0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CD0->then_instructions;

                  body.emit(assign(r2CCD, body.constant(int(16)), 0x01));

                  body.emit(assign(r2CCB, lshift(r2CC5, body.constant(int(16))), 0x01));


               body.instructions = f2CD0_parent_instructions;
               body.emit(f2CD0);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2CD4 = bit_and(r2CCB, body.constant(4278190080u));
               ir_expression *const r2CD5 = equal(r2CD4, body.constant(0u));
               ir_if *f2CD3 = new(mem_ctx) ir_if(operand(r2CD5).val);
               exec_list *const f2CD3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CD3->then_instructions;

                  body.emit(assign(r2CCD, add(r2CCD, body.constant(int(8))), 0x01));

                  body.emit(assign(r2CCB, lshift(r2CCB, body.constant(int(8))), 0x01));


               body.instructions = f2CD3_parent_instructions;
               body.emit(f2CD3);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2CD7 = bit_and(r2CCB, body.constant(4026531840u));
               ir_expression *const r2CD8 = equal(r2CD7, body.constant(0u));
               ir_if *f2CD6 = new(mem_ctx) ir_if(operand(r2CD8).val);
               exec_list *const f2CD6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CD6->then_instructions;

                  body.emit(assign(r2CCD, add(r2CCD, body.constant(int(4))), 0x01));

                  body.emit(assign(r2CCB, lshift(r2CCB, body.constant(int(4))), 0x01));


               body.instructions = f2CD6_parent_instructions;
               body.emit(f2CD6);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2CDA = bit_and(r2CCB, body.constant(3221225472u));
               ir_expression *const r2CDB = equal(r2CDA, body.constant(0u));
               ir_if *f2CD9 = new(mem_ctx) ir_if(operand(r2CDB).val);
               exec_list *const f2CD9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CD9->then_instructions;

                  body.emit(assign(r2CCD, add(r2CCD, body.constant(int(2))), 0x01));

                  body.emit(assign(r2CCB, lshift(r2CCB, body.constant(int(2))), 0x01));


               body.instructions = f2CD9_parent_instructions;
               body.emit(f2CD9);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2CDD = bit_and(r2CCB, body.constant(2147483648u));
               ir_expression *const r2CDE = equal(r2CDD, body.constant(0u));
               ir_if *f2CDC = new(mem_ctx) ir_if(operand(r2CDE).val);
               exec_list *const f2CDC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CDC->then_instructions;

                  body.emit(assign(r2CCD, add(r2CCD, body.constant(int(1))), 0x01));


               body.instructions = f2CDC_parent_instructions;
               body.emit(f2CDC);

               /* END IF */

               body.emit(assign(r2CCC, r2CCD, 0x01));


            body.instructions = f2CCE_parent_instructions;
            body.emit(f2CCE);

            /* END IF */

            body.emit(assign(r2CC8, add(r2CCC, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2CE0 = lequal(body.constant(int(0)), r2CC8);
            ir_if *f2CDF = new(mem_ctx) ir_if(operand(r2CE0).val);
            exec_list *const f2CDF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CDF->then_instructions;

               body.emit(assign(r2CC7, body.constant(0u), 0x01));

               ir_variable *const r2CE1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2CE1, lshift(r2CC6, r2CC8), 0x01));

               ir_variable *const r2CE2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r2CE4 = equal(r2CC8, body.constant(int(0)));
               ir_if *f2CE3 = new(mem_ctx) ir_if(operand(r2CE4).val);
               exec_list *const f2CE3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CE3->then_instructions;

                  body.emit(assign(r2CE2, r2CC5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2CE3->else_instructions;

                  ir_expression *const r2CE5 = lshift(r2CC5, r2CC8);
                  ir_expression *const r2CE6 = neg(r2CC8);
                  ir_expression *const r2CE7 = bit_and(r2CE6, body.constant(int(31)));
                  ir_expression *const r2CE8 = rshift(r2CC6, r2CE7);
                  body.emit(assign(r2CE2, bit_or(r2CE5, r2CE8), 0x01));


               body.instructions = f2CE3_parent_instructions;
               body.emit(f2CE3);

               /* END IF */

               body.emit(assign(r2CC5, r2CE2, 0x01));

               body.emit(assign(r2CC6, r2CE1, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2CDF->else_instructions;

               ir_variable *const r2CE9 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2CE9, body.constant(0u), 0x01));

               ir_variable *const r2CEA = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2CEA, neg(r2CC8), 0x01));

               ir_variable *const r2CEB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2CEB);
               ir_variable *const r2CEC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2CEC);
               ir_variable *const r2CED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2CED);
               ir_variable *const r2CEE = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2CEF = neg(r2CEA);
               body.emit(assign(r2CEE, bit_and(r2CEF, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2CF1 = equal(r2CEA, body.constant(int(0)));
               ir_if *f2CF0 = new(mem_ctx) ir_if(operand(r2CF1).val);
               exec_list *const f2CF0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CF0->then_instructions;

                  body.emit(assign(r2CEB, r2CE9, 0x01));

                  body.emit(assign(r2CEC, r2CC6, 0x01));

                  body.emit(assign(r2CED, r2CC5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2CF0->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2CF3 = less(r2CEA, body.constant(int(32)));
                  ir_if *f2CF2 = new(mem_ctx) ir_if(operand(r2CF3).val);
                  exec_list *const f2CF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2CF2->then_instructions;

                     body.emit(assign(r2CEB, lshift(r2CC6, r2CEE), 0x01));

                     ir_expression *const r2CF4 = lshift(r2CC5, r2CEE);
                     ir_expression *const r2CF5 = rshift(r2CC6, r2CEA);
                     body.emit(assign(r2CEC, bit_or(r2CF4, r2CF5), 0x01));

                     body.emit(assign(r2CED, rshift(r2CC5, r2CEA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2CF2->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2CF7 = equal(r2CEA, body.constant(int(32)));
                     ir_if *f2CF6 = new(mem_ctx) ir_if(operand(r2CF7).val);
                     exec_list *const f2CF6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2CF6->then_instructions;

                        body.emit(assign(r2CEB, r2CC6, 0x01));

                        body.emit(assign(r2CEC, r2CC5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2CF6->else_instructions;

                        body.emit(assign(r2CE9, bit_or(body.constant(0u), r2CC6), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2CF9 = less(r2CEA, body.constant(int(64)));
                        ir_if *f2CF8 = new(mem_ctx) ir_if(operand(r2CF9).val);
                        exec_list *const f2CF8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2CF8->then_instructions;

                           body.emit(assign(r2CEB, lshift(r2CC5, r2CEE), 0x01));

                           ir_expression *const r2CFA = bit_and(r2CEA, body.constant(int(31)));
                           body.emit(assign(r2CEC, rshift(r2CC5, r2CFA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2CF8->else_instructions;

                           ir_variable *const r2CFB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2CFD = equal(r2CEA, body.constant(int(64)));
                           ir_if *f2CFC = new(mem_ctx) ir_if(operand(r2CFD).val);
                           exec_list *const f2CFC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2CFC->then_instructions;

                              body.emit(assign(r2CFB, r2CC5, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2CFC->else_instructions;

                              ir_expression *const r2CFE = nequal(r2CC5, body.constant(0u));
                              ir_expression *const r2CFF = expr(ir_unop_b2i, r2CFE);
                              body.emit(assign(r2CFB, expr(ir_unop_i2u, r2CFF), 0x01));


                           body.instructions = f2CFC_parent_instructions;
                           body.emit(f2CFC);

                           /* END IF */

                           body.emit(assign(r2CEB, r2CFB, 0x01));

                           body.emit(assign(r2CEC, body.constant(0u), 0x01));


                        body.instructions = f2CF8_parent_instructions;
                        body.emit(f2CF8);

                        /* END IF */


                     body.instructions = f2CF6_parent_instructions;
                     body.emit(f2CF6);

                     /* END IF */

                     body.emit(assign(r2CED, body.constant(0u), 0x01));


                  body.instructions = f2CF2_parent_instructions;
                  body.emit(f2CF2);

                  /* END IF */

                  ir_expression *const r2D00 = nequal(r2CE9, body.constant(0u));
                  ir_expression *const r2D01 = expr(ir_unop_b2i, r2D00);
                  ir_expression *const r2D02 = expr(ir_unop_i2u, r2D01);
                  body.emit(assign(r2CEB, bit_or(r2CEB, r2D02), 0x01));


               body.instructions = f2CF0_parent_instructions;
               body.emit(f2CF0);

               /* END IF */

               body.emit(assign(r2CC5, r2CED, 0x01));

               body.emit(assign(r2CC6, r2CEC, 0x01));

               body.emit(assign(r2CC7, r2CEB, 0x01));


            body.instructions = f2CDF_parent_instructions;
            body.emit(f2CDF);

            /* END IF */

            body.emit(assign(r2CC4, sub(r2CC4, r2CC8), 0x01));

            ir_variable *const r2D03 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r2D03, r2CC4, 0x01));

            ir_variable *const r2D04 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r2D04, r2CC5, 0x01));

            ir_variable *const r2D05 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2D05, r2CC6, 0x01));

            ir_variable *const r2D06 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r2D06, r2CC7, 0x01));

            ir_variable *const r2D07 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r2D07, body.constant(true), 0x01));

            ir_variable *const r2D08 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r2D09 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r2D09);
            ir_expression *const r2D0A = expr(ir_unop_u2i, r2CC7);
            body.emit(assign(r2D09, less(r2D0A, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2D0C = lequal(body.constant(int(2045)), r2CC4);
            ir_if *f2D0B = new(mem_ctx) ir_if(operand(r2D0C).val);
            exec_list *const f2D0B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D0B->then_instructions;

               ir_variable *const r2D0D = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r2D0F = less(body.constant(int(2045)), r2CC4);
               ir_if *f2D0E = new(mem_ctx) ir_if(operand(r2D0F).val);
               exec_list *const f2D0E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D0E->then_instructions;

                  body.emit(assign(r2D0D, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D0E->else_instructions;

                  ir_variable *const r2D10 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2D12 = equal(r2CC4, body.constant(int(2045)));
                  ir_if *f2D11 = new(mem_ctx) ir_if(operand(r2D12).val);
                  exec_list *const f2D11_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D11->then_instructions;

                     ir_expression *const r2D13 = equal(body.constant(2097151u), r2CC5);
                     ir_expression *const r2D14 = equal(body.constant(4294967295u), r2CC6);
                     body.emit(assign(r2D10, logic_and(r2D13, r2D14), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D11->else_instructions;

                     body.emit(assign(r2D10, body.constant(false), 0x01));


                  body.instructions = f2D11_parent_instructions;
                  body.emit(f2D11);

                  /* END IF */

                  body.emit(assign(r2D0D, logic_and(r2D10, r2D09), 0x01));


               body.instructions = f2D0E_parent_instructions;
               body.emit(f2D0E);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2D15 = new(mem_ctx) ir_if(operand(r2D0D).val);
               exec_list *const f2D15_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D15->then_instructions;

                  ir_variable *const r2D16 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2D16);
                  ir_expression *const r2D17 = lshift(r2C5A, body.constant(int(31)));
                  body.emit(assign(r2D16, add(r2D17, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2D16, body.constant(0u), 0x01));

                  body.emit(assign(r2D08, r2D16, 0x03));

                  body.emit(assign(r2D07, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D15->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2D19 = less(r2CC4, body.constant(int(0)));
                  ir_if *f2D18 = new(mem_ctx) ir_if(operand(r2D19).val);
                  exec_list *const f2D18_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D18->then_instructions;

                     ir_variable *const r2D1A = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2D1A, r2CC7, 0x01));

                     ir_variable *const r2D1B = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2D1B, neg(r2CC4), 0x01));

                     ir_variable *const r2D1C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2D1C);
                     ir_variable *const r2D1D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2D1D);
                     ir_variable *const r2D1E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2D1E);
                     ir_variable *const r2D1F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r2D20 = neg(r2D1B);
                     body.emit(assign(r2D1F, bit_and(r2D20, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2D22 = equal(r2D1B, body.constant(int(0)));
                     ir_if *f2D21 = new(mem_ctx) ir_if(operand(r2D22).val);
                     exec_list *const f2D21_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D21->then_instructions;

                        body.emit(assign(r2D1C, r2CC7, 0x01));

                        body.emit(assign(r2D1D, r2CC6, 0x01));

                        body.emit(assign(r2D1E, r2CC5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D21->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2D24 = less(r2D1B, body.constant(int(32)));
                        ir_if *f2D23 = new(mem_ctx) ir_if(operand(r2D24).val);
                        exec_list *const f2D23_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D23->then_instructions;

                           body.emit(assign(r2D1C, lshift(r2CC6, r2D1F), 0x01));

                           ir_expression *const r2D25 = lshift(r2CC5, r2D1F);
                           ir_expression *const r2D26 = rshift(r2CC6, r2D1B);
                           body.emit(assign(r2D1D, bit_or(r2D25, r2D26), 0x01));

                           body.emit(assign(r2D1E, rshift(r2CC5, r2D1B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D23->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2D28 = equal(r2D1B, body.constant(int(32)));
                           ir_if *f2D27 = new(mem_ctx) ir_if(operand(r2D28).val);
                           exec_list *const f2D27_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D27->then_instructions;

                              body.emit(assign(r2D1C, r2CC6, 0x01));

                              body.emit(assign(r2D1D, r2CC5, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2D27->else_instructions;

                              body.emit(assign(r2D1A, bit_or(r2CC7, r2CC6), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2D2A = less(r2D1B, body.constant(int(64)));
                              ir_if *f2D29 = new(mem_ctx) ir_if(operand(r2D2A).val);
                              exec_list *const f2D29_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2D29->then_instructions;

                                 body.emit(assign(r2D1C, lshift(r2CC5, r2D1F), 0x01));

                                 ir_expression *const r2D2B = bit_and(r2D1B, body.constant(int(31)));
                                 body.emit(assign(r2D1D, rshift(r2CC5, r2D2B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2D29->else_instructions;

                                 ir_variable *const r2D2C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2D2E = equal(r2D1B, body.constant(int(64)));
                                 ir_if *f2D2D = new(mem_ctx) ir_if(operand(r2D2E).val);
                                 exec_list *const f2D2D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2D2D->then_instructions;

                                    body.emit(assign(r2D2C, r2CC5, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2D2D->else_instructions;

                                    ir_expression *const r2D2F = nequal(r2CC5, body.constant(0u));
                                    ir_expression *const r2D30 = expr(ir_unop_b2i, r2D2F);
                                    body.emit(assign(r2D2C, expr(ir_unop_i2u, r2D30), 0x01));


                                 body.instructions = f2D2D_parent_instructions;
                                 body.emit(f2D2D);

                                 /* END IF */

                                 body.emit(assign(r2D1C, r2D2C, 0x01));

                                 body.emit(assign(r2D1D, body.constant(0u), 0x01));


                              body.instructions = f2D29_parent_instructions;
                              body.emit(f2D29);

                              /* END IF */


                           body.instructions = f2D27_parent_instructions;
                           body.emit(f2D27);

                           /* END IF */

                           body.emit(assign(r2D1E, body.constant(0u), 0x01));


                        body.instructions = f2D23_parent_instructions;
                        body.emit(f2D23);

                        /* END IF */

                        ir_expression *const r2D31 = nequal(r2D1A, body.constant(0u));
                        ir_expression *const r2D32 = expr(ir_unop_b2i, r2D31);
                        ir_expression *const r2D33 = expr(ir_unop_i2u, r2D32);
                        body.emit(assign(r2D1C, bit_or(r2D1C, r2D33), 0x01));


                     body.instructions = f2D21_parent_instructions;
                     body.emit(f2D21);

                     /* END IF */

                     body.emit(assign(r2D04, r2D1E, 0x01));

                     body.emit(assign(r2D05, r2D1D, 0x01));

                     body.emit(assign(r2D06, r2D1C, 0x01));

                     body.emit(assign(r2D03, body.constant(int(0)), 0x01));

                     body.emit(assign(r2D09, less(r2D1C, body.constant(0u)), 0x01));


                  body.instructions = f2D18_parent_instructions;
                  body.emit(f2D18);

                  /* END IF */


               body.instructions = f2D15_parent_instructions;
               body.emit(f2D15);

               /* END IF */


            body.instructions = f2D0B_parent_instructions;
            body.emit(f2D0B);

            /* END IF */

            /* IF CONDITION */
            ir_if *f2D34 = new(mem_ctx) ir_if(operand(r2D07).val);
            exec_list *const f2D34_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D34->then_instructions;

               /* IF CONDITION */
               ir_if *f2D35 = new(mem_ctx) ir_if(operand(r2D09).val);
               exec_list *const f2D35_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D35->then_instructions;

                  ir_variable *const r2D36 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2D36, add(r2D05, body.constant(1u)), 0x01));

                  ir_expression *const r2D37 = less(r2D36, r2D05);
                  ir_expression *const r2D38 = expr(ir_unop_b2i, r2D37);
                  ir_expression *const r2D39 = expr(ir_unop_i2u, r2D38);
                  body.emit(assign(r2D04, add(r2D04, r2D39), 0x01));

                  ir_expression *const r2D3A = equal(r2D06, body.constant(0u));
                  ir_expression *const r2D3B = expr(ir_unop_b2i, r2D3A);
                  ir_expression *const r2D3C = expr(ir_unop_i2u, r2D3B);
                  ir_expression *const r2D3D = add(r2D06, r2D3C);
                  ir_expression *const r2D3E = bit_and(r2D3D, body.constant(1u));
                  ir_expression *const r2D3F = expr(ir_unop_bit_not, r2D3E);
                  body.emit(assign(r2D05, bit_and(r2D36, r2D3F), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D35->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2D41 = bit_or(r2D04, r2D05);
                  ir_expression *const r2D42 = equal(r2D41, body.constant(0u));
                  ir_if *f2D40 = new(mem_ctx) ir_if(operand(r2D42).val);
                  exec_list *const f2D40_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D40->then_instructions;

                     body.emit(assign(r2D03, body.constant(int(0)), 0x01));


                  body.instructions = f2D40_parent_instructions;
                  body.emit(f2D40);

                  /* END IF */


               body.instructions = f2D35_parent_instructions;
               body.emit(f2D35);

               /* END IF */

               ir_variable *const r2D43 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r2D43);
               ir_expression *const r2D44 = lshift(r2C5A, body.constant(int(31)));
               ir_expression *const r2D45 = expr(ir_unop_i2u, r2D03);
               ir_expression *const r2D46 = lshift(r2D45, body.constant(int(20)));
               ir_expression *const r2D47 = add(r2D44, r2D46);
               body.emit(assign(r2D43, add(r2D47, r2D04), 0x02));

               body.emit(assign(r2D43, r2D05, 0x01));

               body.emit(assign(r2D08, r2D43, 0x03));

               body.emit(assign(r2D07, body.constant(false), 0x01));


            body.instructions = f2D34_parent_instructions;
            body.emit(f2D34);

            /* END IF */

            body.emit(assign(r2C5F, r2D08, 0x03));


         body.instructions = f2C7A_parent_instructions;
         body.emit(f2C7A);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2C78->else_instructions;

         /* IF CONDITION */
         ir_expression *const r2D49 = less(r2C60, body.constant(int(0)));
         ir_if *f2D48 = new(mem_ctx) ir_if(operand(r2D49).val);
         exec_list *const f2D48_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2D48->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2D4B = equal(r2C6B, body.constant(int(2047)));
            ir_if *f2D4A = new(mem_ctx) ir_if(operand(r2D4B).val);
            exec_list *const f2D4A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D4A->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2D4D = bit_or(r2C63, r2C64);
               ir_expression *const r2D4E = nequal(r2D4D, body.constant(0u));
               ir_if *f2D4C = new(mem_ctx) ir_if(operand(r2D4E).val);
               exec_list *const f2D4C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D4C->then_instructions;

                  ir_variable *const r2D4F = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2D4F, swizzle_x(r270B), 0x01));

                  ir_variable *const r2D50 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2D50, swizzle_x(r273F), 0x01));

                  ir_variable *const r2D51 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2D52 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2D53 = rshift(swizzle_y(r270B), body.constant(int(19)));
                  ir_expression *const r2D54 = bit_and(r2D53, body.constant(4095u));
                  ir_expression *const r2D55 = equal(r2D54, body.constant(4094u));
                  ir_expression *const r2D56 = nequal(swizzle_x(r270B), body.constant(0u));
                  ir_expression *const r2D57 = bit_and(swizzle_y(r270B), body.constant(524287u));
                  ir_expression *const r2D58 = nequal(r2D57, body.constant(0u));
                  ir_expression *const r2D59 = logic_or(r2D56, r2D58);
                  body.emit(assign(r2D52, logic_and(r2D55, r2D59), 0x01));

                  ir_variable *const r2D5A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2D5B = lshift(swizzle_y(r273F), body.constant(int(1)));
                  ir_expression *const r2D5C = lequal(body.constant(4292870144u), r2D5B);
                  ir_expression *const r2D5D = nequal(swizzle_x(r273F), body.constant(0u));
                  ir_expression *const r2D5E = bit_and(swizzle_y(r273F), body.constant(1048575u));
                  ir_expression *const r2D5F = nequal(r2D5E, body.constant(0u));
                  ir_expression *const r2D60 = logic_or(r2D5D, r2D5F);
                  body.emit(assign(r2D5A, logic_and(r2D5C, r2D60), 0x01));

                  body.emit(assign(r2D4F, bit_or(swizzle_y(r270B), body.constant(524288u)), 0x02));

                  body.emit(assign(r2D50, bit_or(swizzle_y(r273F), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2D62 = lshift(swizzle_y(r270B), body.constant(int(1)));
                  ir_expression *const r2D63 = lequal(body.constant(4292870144u), r2D62);
                  ir_expression *const r2D64 = nequal(swizzle_x(r270B), body.constant(0u));
                  ir_expression *const r2D65 = bit_and(swizzle_y(r270B), body.constant(1048575u));
                  ir_expression *const r2D66 = nequal(r2D65, body.constant(0u));
                  ir_expression *const r2D67 = logic_or(r2D64, r2D66);
                  ir_expression *const r2D68 = logic_and(r2D63, r2D67);
                  ir_if *f2D61 = new(mem_ctx) ir_if(operand(r2D68).val);
                  exec_list *const f2D61_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D61->then_instructions;

                     ir_variable *const r2D69 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2D6B = logic_and(r2D52, r2D5A);
                     ir_if *f2D6A = new(mem_ctx) ir_if(operand(r2D6B).val);
                     exec_list *const f2D6A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D6A->then_instructions;

                        body.emit(assign(r2D69, r2D50, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D6A->else_instructions;

                        body.emit(assign(r2D69, r2D4F, 0x03));


                     body.instructions = f2D6A_parent_instructions;
                     body.emit(f2D6A);

                     /* END IF */

                     body.emit(assign(r2D51, r2D69, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D61->else_instructions;

                     body.emit(assign(r2D51, r2D50, 0x03));


                  body.instructions = f2D61_parent_instructions;
                  body.emit(f2D61);

                  /* END IF */

                  body.emit(assign(r2C5F, r2D51, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D4C->else_instructions;

                  ir_variable *const r2D6C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2D6C);
                  ir_expression *const r2D6D = bit_xor(r2C5A, body.constant(1u));
                  ir_expression *const r2D6E = lshift(r2D6D, body.constant(int(31)));
                  body.emit(assign(r2D6C, add(r2D6E, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2D6C, body.constant(0u), 0x01));

                  body.emit(assign(r2C5F, r2D6C, 0x03));


               body.instructions = f2D4C_parent_instructions;
               body.emit(f2D4C);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2D4A->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2D70 = equal(r2C68, body.constant(int(0)));
               ir_if *f2D6F = new(mem_ctx) ir_if(operand(r2D70).val);
               exec_list *const f2D6F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D6F->then_instructions;

                  body.emit(assign(r2C60, add(r2C60, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D6F->else_instructions;

                  body.emit(assign(r2C65, bit_or(r2C65, body.constant(1073741824u)), 0x01));


               body.instructions = f2D6F_parent_instructions;
               body.emit(f2D6F);

               /* END IF */

               ir_variable *const r2D71 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2D71, neg(r2C60), 0x01));

               ir_variable *const r2D72 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2D72);
               ir_variable *const r2D73 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2D73);
               ir_variable *const r2D74 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2D75 = neg(r2D71);
               body.emit(assign(r2D74, bit_and(r2D75, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2D77 = equal(r2D71, body.constant(int(0)));
               ir_if *f2D76 = new(mem_ctx) ir_if(operand(r2D77).val);
               exec_list *const f2D76_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D76->then_instructions;

                  body.emit(assign(r2D72, r2C6E, 0x01));

                  body.emit(assign(r2D73, r2C65, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D76->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2D79 = less(r2D71, body.constant(int(32)));
                  ir_if *f2D78 = new(mem_ctx) ir_if(operand(r2D79).val);
                  exec_list *const f2D78_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D78->then_instructions;

                     ir_expression *const r2D7A = lshift(r2C65, r2D74);
                     ir_expression *const r2D7B = rshift(r2C6E, r2D71);
                     ir_expression *const r2D7C = bit_or(r2D7A, r2D7B);
                     ir_expression *const r2D7D = lshift(r2C6E, r2D74);
                     ir_expression *const r2D7E = nequal(r2D7D, body.constant(0u));
                     ir_expression *const r2D7F = expr(ir_unop_b2i, r2D7E);
                     ir_expression *const r2D80 = expr(ir_unop_i2u, r2D7F);
                     body.emit(assign(r2D72, bit_or(r2D7C, r2D80), 0x01));

                     body.emit(assign(r2D73, rshift(r2C65, r2D71), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D78->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2D82 = equal(r2D71, body.constant(int(32)));
                     ir_if *f2D81 = new(mem_ctx) ir_if(operand(r2D82).val);
                     exec_list *const f2D81_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D81->then_instructions;

                        ir_expression *const r2D83 = nequal(r2C6E, body.constant(0u));
                        ir_expression *const r2D84 = expr(ir_unop_b2i, r2D83);
                        ir_expression *const r2D85 = expr(ir_unop_i2u, r2D84);
                        body.emit(assign(r2D72, bit_or(r2C65, r2D85), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D81->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2D87 = less(r2D71, body.constant(int(64)));
                        ir_if *f2D86 = new(mem_ctx) ir_if(operand(r2D87).val);
                        exec_list *const f2D86_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D86->then_instructions;

                           ir_expression *const r2D88 = bit_and(r2D71, body.constant(int(31)));
                           ir_expression *const r2D89 = rshift(r2C65, r2D88);
                           ir_expression *const r2D8A = lshift(r2C65, r2D74);
                           ir_expression *const r2D8B = bit_or(r2D8A, r2C6E);
                           ir_expression *const r2D8C = nequal(r2D8B, body.constant(0u));
                           ir_expression *const r2D8D = expr(ir_unop_b2i, r2D8C);
                           ir_expression *const r2D8E = expr(ir_unop_i2u, r2D8D);
                           body.emit(assign(r2D72, bit_or(r2D89, r2D8E), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D86->else_instructions;

                           ir_expression *const r2D8F = bit_or(r2C65, r2C6E);
                           ir_expression *const r2D90 = nequal(r2D8F, body.constant(0u));
                           ir_expression *const r2D91 = expr(ir_unop_b2i, r2D90);
                           body.emit(assign(r2D72, expr(ir_unop_i2u, r2D91), 0x01));


                        body.instructions = f2D86_parent_instructions;
                        body.emit(f2D86);

                        /* END IF */


                     body.instructions = f2D81_parent_instructions;
                     body.emit(f2D81);

                     /* END IF */

                     body.emit(assign(r2D73, body.constant(0u), 0x01));


                  body.instructions = f2D78_parent_instructions;
                  body.emit(f2D78);

                  /* END IF */


               body.instructions = f2D76_parent_instructions;
               body.emit(f2D76);

               /* END IF */

               body.emit(assign(r2C65, r2D73, 0x01));

               body.emit(assign(r2C66, r2D72, 0x01));

               body.emit(assign(r2C63, bit_or(r2C63, body.constant(1073741824u)), 0x01));

               ir_variable *const r2D92 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2D93 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2D93, sub(r2C64, r2D72), 0x01));

               ir_expression *const r2D94 = sub(r2C63, r2D73);
               ir_expression *const r2D95 = less(r2C64, r2D72);
               ir_expression *const r2D96 = expr(ir_unop_b2i, r2D95);
               ir_expression *const r2D97 = expr(ir_unop_i2u, r2D96);
               body.emit(assign(r2D92, sub(r2D94, r2D97), 0x01));

               body.emit(assign(r2C5E, bit_xor(r2C5A, body.constant(1u)), 0x01));

               body.emit(assign(r2C67, add(r2C6B, body.constant(int(-1))), 0x01));

               ir_variable *const r2D98 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2D98, add(r2C67, body.constant(int(-10))), 0x01));

               ir_variable *const r2D99 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2D99, r2D92, 0x01));

               ir_variable *const r2D9A = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2D9A, r2D93, 0x01));

               ir_variable *const r2D9B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2D9B);
               ir_variable *const r2D9C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2D9C);
               /* IF CONDITION */
               ir_expression *const r2D9E = equal(r2D92, body.constant(0u));
               ir_if *f2D9D = new(mem_ctx) ir_if(operand(r2D9E).val);
               exec_list *const f2D9D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D9D->then_instructions;

                  body.emit(assign(r2D99, r2D93, 0x01));

                  body.emit(assign(r2D9A, body.constant(0u), 0x01));

                  body.emit(assign(r2D98, add(r2D98, body.constant(int(-32))), 0x01));


               body.instructions = f2D9D_parent_instructions;
               body.emit(f2D9D);

               /* END IF */

               ir_variable *const r2D9F = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2D9F, r2D99, 0x01));

               ir_variable *const r2DA0 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2DA1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2DA1);
               /* IF CONDITION */
               ir_expression *const r2DA3 = equal(r2D99, body.constant(0u));
               ir_if *f2DA2 = new(mem_ctx) ir_if(operand(r2DA3).val);
               exec_list *const f2DA2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DA2->then_instructions;

                  body.emit(assign(r2DA0, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2DA2->else_instructions;

                  body.emit(assign(r2DA1, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2DA5 = bit_and(r2D99, body.constant(4294901760u));
                  ir_expression *const r2DA6 = equal(r2DA5, body.constant(0u));
                  ir_if *f2DA4 = new(mem_ctx) ir_if(operand(r2DA6).val);
                  exec_list *const f2DA4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DA4->then_instructions;

                     body.emit(assign(r2DA1, body.constant(int(16)), 0x01));

                     body.emit(assign(r2D9F, lshift(r2D99, body.constant(int(16))), 0x01));


                  body.instructions = f2DA4_parent_instructions;
                  body.emit(f2DA4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2DA8 = bit_and(r2D9F, body.constant(4278190080u));
                  ir_expression *const r2DA9 = equal(r2DA8, body.constant(0u));
                  ir_if *f2DA7 = new(mem_ctx) ir_if(operand(r2DA9).val);
                  exec_list *const f2DA7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DA7->then_instructions;

                     body.emit(assign(r2DA1, add(r2DA1, body.constant(int(8))), 0x01));

                     body.emit(assign(r2D9F, lshift(r2D9F, body.constant(int(8))), 0x01));


                  body.instructions = f2DA7_parent_instructions;
                  body.emit(f2DA7);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2DAB = bit_and(r2D9F, body.constant(4026531840u));
                  ir_expression *const r2DAC = equal(r2DAB, body.constant(0u));
                  ir_if *f2DAA = new(mem_ctx) ir_if(operand(r2DAC).val);
                  exec_list *const f2DAA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DAA->then_instructions;

                     body.emit(assign(r2DA1, add(r2DA1, body.constant(int(4))), 0x01));

                     body.emit(assign(r2D9F, lshift(r2D9F, body.constant(int(4))), 0x01));


                  body.instructions = f2DAA_parent_instructions;
                  body.emit(f2DAA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2DAE = bit_and(r2D9F, body.constant(3221225472u));
                  ir_expression *const r2DAF = equal(r2DAE, body.constant(0u));
                  ir_if *f2DAD = new(mem_ctx) ir_if(operand(r2DAF).val);
                  exec_list *const f2DAD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DAD->then_instructions;

                     body.emit(assign(r2DA1, add(r2DA1, body.constant(int(2))), 0x01));

                     body.emit(assign(r2D9F, lshift(r2D9F, body.constant(int(2))), 0x01));


                  body.instructions = f2DAD_parent_instructions;
                  body.emit(f2DAD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2DB1 = bit_and(r2D9F, body.constant(2147483648u));
                  ir_expression *const r2DB2 = equal(r2DB1, body.constant(0u));
                  ir_if *f2DB0 = new(mem_ctx) ir_if(operand(r2DB2).val);
                  exec_list *const f2DB0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DB0->then_instructions;

                     body.emit(assign(r2DA1, add(r2DA1, body.constant(int(1))), 0x01));


                  body.instructions = f2DB0_parent_instructions;
                  body.emit(f2DB0);

                  /* END IF */

                  body.emit(assign(r2DA0, r2DA1, 0x01));


               body.instructions = f2DA2_parent_instructions;
               body.emit(f2DA2);

               /* END IF */

               body.emit(assign(r2D9C, add(r2DA0, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2DB4 = lequal(body.constant(int(0)), r2D9C);
               ir_if *f2DB3 = new(mem_ctx) ir_if(operand(r2DB4).val);
               exec_list *const f2DB3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DB3->then_instructions;

                  body.emit(assign(r2D9B, body.constant(0u), 0x01));

                  ir_variable *const r2DB5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2DB5, lshift(r2D9A, r2D9C), 0x01));

                  ir_variable *const r2DB6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2DB8 = equal(r2D9C, body.constant(int(0)));
                  ir_if *f2DB7 = new(mem_ctx) ir_if(operand(r2DB8).val);
                  exec_list *const f2DB7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DB7->then_instructions;

                     body.emit(assign(r2DB6, r2D99, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DB7->else_instructions;

                     ir_expression *const r2DB9 = lshift(r2D99, r2D9C);
                     ir_expression *const r2DBA = neg(r2D9C);
                     ir_expression *const r2DBB = bit_and(r2DBA, body.constant(int(31)));
                     ir_expression *const r2DBC = rshift(r2D9A, r2DBB);
                     body.emit(assign(r2DB6, bit_or(r2DB9, r2DBC), 0x01));


                  body.instructions = f2DB7_parent_instructions;
                  body.emit(f2DB7);

                  /* END IF */

                  body.emit(assign(r2D99, r2DB6, 0x01));

                  body.emit(assign(r2D9A, r2DB5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2DB3->else_instructions;

                  ir_variable *const r2DBD = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2DBD, body.constant(0u), 0x01));

                  ir_variable *const r2DBE = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2DBE, neg(r2D9C), 0x01));

                  ir_variable *const r2DBF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2DBF);
                  ir_variable *const r2DC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2DC0);
                  ir_variable *const r2DC1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2DC1);
                  ir_variable *const r2DC2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2DC3 = neg(r2DBE);
                  body.emit(assign(r2DC2, bit_and(r2DC3, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2DC5 = equal(r2DBE, body.constant(int(0)));
                  ir_if *f2DC4 = new(mem_ctx) ir_if(operand(r2DC5).val);
                  exec_list *const f2DC4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DC4->then_instructions;

                     body.emit(assign(r2DBF, r2DBD, 0x01));

                     body.emit(assign(r2DC0, r2D9A, 0x01));

                     body.emit(assign(r2DC1, r2D99, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DC4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2DC7 = less(r2DBE, body.constant(int(32)));
                     ir_if *f2DC6 = new(mem_ctx) ir_if(operand(r2DC7).val);
                     exec_list *const f2DC6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DC6->then_instructions;

                        body.emit(assign(r2DBF, lshift(r2D9A, r2DC2), 0x01));

                        ir_expression *const r2DC8 = lshift(r2D99, r2DC2);
                        ir_expression *const r2DC9 = rshift(r2D9A, r2DBE);
                        body.emit(assign(r2DC0, bit_or(r2DC8, r2DC9), 0x01));

                        body.emit(assign(r2DC1, rshift(r2D99, r2DBE), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2DC6->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2DCB = equal(r2DBE, body.constant(int(32)));
                        ir_if *f2DCA = new(mem_ctx) ir_if(operand(r2DCB).val);
                        exec_list *const f2DCA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2DCA->then_instructions;

                           body.emit(assign(r2DBF, r2D9A, 0x01));

                           body.emit(assign(r2DC0, r2D99, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2DCA->else_instructions;

                           body.emit(assign(r2DBD, bit_or(body.constant(0u), r2D9A), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2DCD = less(r2DBE, body.constant(int(64)));
                           ir_if *f2DCC = new(mem_ctx) ir_if(operand(r2DCD).val);
                           exec_list *const f2DCC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2DCC->then_instructions;

                              body.emit(assign(r2DBF, lshift(r2D99, r2DC2), 0x01));

                              ir_expression *const r2DCE = bit_and(r2DBE, body.constant(int(31)));
                              body.emit(assign(r2DC0, rshift(r2D99, r2DCE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2DCC->else_instructions;

                              ir_variable *const r2DCF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2DD1 = equal(r2DBE, body.constant(int(64)));
                              ir_if *f2DD0 = new(mem_ctx) ir_if(operand(r2DD1).val);
                              exec_list *const f2DD0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2DD0->then_instructions;

                                 body.emit(assign(r2DCF, r2D99, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2DD0->else_instructions;

                                 ir_expression *const r2DD2 = nequal(r2D99, body.constant(0u));
                                 ir_expression *const r2DD3 = expr(ir_unop_b2i, r2DD2);
                                 body.emit(assign(r2DCF, expr(ir_unop_i2u, r2DD3), 0x01));


                              body.instructions = f2DD0_parent_instructions;
                              body.emit(f2DD0);

                              /* END IF */

                              body.emit(assign(r2DBF, r2DCF, 0x01));

                              body.emit(assign(r2DC0, body.constant(0u), 0x01));


                           body.instructions = f2DCC_parent_instructions;
                           body.emit(f2DCC);

                           /* END IF */


                        body.instructions = f2DCA_parent_instructions;
                        body.emit(f2DCA);

                        /* END IF */

                        body.emit(assign(r2DC1, body.constant(0u), 0x01));


                     body.instructions = f2DC6_parent_instructions;
                     body.emit(f2DC6);

                     /* END IF */

                     ir_expression *const r2DD4 = nequal(r2DBD, body.constant(0u));
                     ir_expression *const r2DD5 = expr(ir_unop_b2i, r2DD4);
                     ir_expression *const r2DD6 = expr(ir_unop_i2u, r2DD5);
                     body.emit(assign(r2DBF, bit_or(r2DBF, r2DD6), 0x01));


                  body.instructions = f2DC4_parent_instructions;
                  body.emit(f2DC4);

                  /* END IF */

                  body.emit(assign(r2D99, r2DC1, 0x01));

                  body.emit(assign(r2D9A, r2DC0, 0x01));

                  body.emit(assign(r2D9B, r2DBF, 0x01));


               body.instructions = f2DB3_parent_instructions;
               body.emit(f2DB3);

               /* END IF */

               body.emit(assign(r2D98, sub(r2D98, r2D9C), 0x01));

               ir_variable *const r2DD7 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2DD7, r2D98, 0x01));

               ir_variable *const r2DD8 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2DD8, r2D99, 0x01));

               ir_variable *const r2DD9 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2DD9, r2D9A, 0x01));

               ir_variable *const r2DDA = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2DDA, r2D9B, 0x01));

               ir_variable *const r2DDB = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2DDB, body.constant(true), 0x01));

               ir_variable *const r2DDC = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2DDD = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2DDD);
               ir_expression *const r2DDE = expr(ir_unop_u2i, r2D9B);
               body.emit(assign(r2DDD, less(r2DDE, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2DE0 = lequal(body.constant(int(2045)), r2D98);
               ir_if *f2DDF = new(mem_ctx) ir_if(operand(r2DE0).val);
               exec_list *const f2DDF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DDF->then_instructions;

                  ir_variable *const r2DE1 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2DE3 = less(body.constant(int(2045)), r2D98);
                  ir_if *f2DE2 = new(mem_ctx) ir_if(operand(r2DE3).val);
                  exec_list *const f2DE2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DE2->then_instructions;

                     body.emit(assign(r2DE1, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DE2->else_instructions;

                     ir_variable *const r2DE4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2DE6 = equal(r2D98, body.constant(int(2045)));
                     ir_if *f2DE5 = new(mem_ctx) ir_if(operand(r2DE6).val);
                     exec_list *const f2DE5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DE5->then_instructions;

                        ir_expression *const r2DE7 = equal(body.constant(2097151u), r2D99);
                        ir_expression *const r2DE8 = equal(body.constant(4294967295u), r2D9A);
                        body.emit(assign(r2DE4, logic_and(r2DE7, r2DE8), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2DE5->else_instructions;

                        body.emit(assign(r2DE4, body.constant(false), 0x01));


                     body.instructions = f2DE5_parent_instructions;
                     body.emit(f2DE5);

                     /* END IF */

                     body.emit(assign(r2DE1, logic_and(r2DE4, r2DDD), 0x01));


                  body.instructions = f2DE2_parent_instructions;
                  body.emit(f2DE2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2DE9 = new(mem_ctx) ir_if(operand(r2DE1).val);
                  exec_list *const f2DE9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DE9->then_instructions;

                     ir_variable *const r2DEA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2DEA);
                     ir_expression *const r2DEB = lshift(r2C5E, body.constant(int(31)));
                     body.emit(assign(r2DEA, add(r2DEB, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2DEA, body.constant(0u), 0x01));

                     body.emit(assign(r2DDC, r2DEA, 0x03));

                     body.emit(assign(r2DDB, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DE9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2DED = less(r2D98, body.constant(int(0)));
                     ir_if *f2DEC = new(mem_ctx) ir_if(operand(r2DED).val);
                     exec_list *const f2DEC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DEC->then_instructions;

                        ir_variable *const r2DEE = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2DEE, r2D9B, 0x01));

                        ir_variable *const r2DEF = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2DEF, neg(r2D98), 0x01));

                        ir_variable *const r2DF0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2DF0);
                        ir_variable *const r2DF1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2DF1);
                        ir_variable *const r2DF2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2DF2);
                        ir_variable *const r2DF3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2DF4 = neg(r2DEF);
                        body.emit(assign(r2DF3, bit_and(r2DF4, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2DF6 = equal(r2DEF, body.constant(int(0)));
                        ir_if *f2DF5 = new(mem_ctx) ir_if(operand(r2DF6).val);
                        exec_list *const f2DF5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2DF5->then_instructions;

                           body.emit(assign(r2DF0, r2D9B, 0x01));

                           body.emit(assign(r2DF1, r2D9A, 0x01));

                           body.emit(assign(r2DF2, r2D99, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2DF5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2DF8 = less(r2DEF, body.constant(int(32)));
                           ir_if *f2DF7 = new(mem_ctx) ir_if(operand(r2DF8).val);
                           exec_list *const f2DF7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2DF7->then_instructions;

                              body.emit(assign(r2DF0, lshift(r2D9A, r2DF3), 0x01));

                              ir_expression *const r2DF9 = lshift(r2D99, r2DF3);
                              ir_expression *const r2DFA = rshift(r2D9A, r2DEF);
                              body.emit(assign(r2DF1, bit_or(r2DF9, r2DFA), 0x01));

                              body.emit(assign(r2DF2, rshift(r2D99, r2DEF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2DF7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2DFC = equal(r2DEF, body.constant(int(32)));
                              ir_if *f2DFB = new(mem_ctx) ir_if(operand(r2DFC).val);
                              exec_list *const f2DFB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2DFB->then_instructions;

                                 body.emit(assign(r2DF0, r2D9A, 0x01));

                                 body.emit(assign(r2DF1, r2D99, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2DFB->else_instructions;

                                 body.emit(assign(r2DEE, bit_or(r2D9B, r2D9A), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2DFE = less(r2DEF, body.constant(int(64)));
                                 ir_if *f2DFD = new(mem_ctx) ir_if(operand(r2DFE).val);
                                 exec_list *const f2DFD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2DFD->then_instructions;

                                    body.emit(assign(r2DF0, lshift(r2D99, r2DF3), 0x01));

                                    ir_expression *const r2DFF = bit_and(r2DEF, body.constant(int(31)));
                                    body.emit(assign(r2DF1, rshift(r2D99, r2DFF), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2DFD->else_instructions;

                                    ir_variable *const r2E00 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2E02 = equal(r2DEF, body.constant(int(64)));
                                    ir_if *f2E01 = new(mem_ctx) ir_if(operand(r2E02).val);
                                    exec_list *const f2E01_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2E01->then_instructions;

                                       body.emit(assign(r2E00, r2D99, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2E01->else_instructions;

                                       ir_expression *const r2E03 = nequal(r2D99, body.constant(0u));
                                       ir_expression *const r2E04 = expr(ir_unop_b2i, r2E03);
                                       body.emit(assign(r2E00, expr(ir_unop_i2u, r2E04), 0x01));


                                    body.instructions = f2E01_parent_instructions;
                                    body.emit(f2E01);

                                    /* END IF */

                                    body.emit(assign(r2DF0, r2E00, 0x01));

                                    body.emit(assign(r2DF1, body.constant(0u), 0x01));


                                 body.instructions = f2DFD_parent_instructions;
                                 body.emit(f2DFD);

                                 /* END IF */


                              body.instructions = f2DFB_parent_instructions;
                              body.emit(f2DFB);

                              /* END IF */

                              body.emit(assign(r2DF2, body.constant(0u), 0x01));


                           body.instructions = f2DF7_parent_instructions;
                           body.emit(f2DF7);

                           /* END IF */

                           ir_expression *const r2E05 = nequal(r2DEE, body.constant(0u));
                           ir_expression *const r2E06 = expr(ir_unop_b2i, r2E05);
                           ir_expression *const r2E07 = expr(ir_unop_i2u, r2E06);
                           body.emit(assign(r2DF0, bit_or(r2DF0, r2E07), 0x01));


                        body.instructions = f2DF5_parent_instructions;
                        body.emit(f2DF5);

                        /* END IF */

                        body.emit(assign(r2DD8, r2DF2, 0x01));

                        body.emit(assign(r2DD9, r2DF1, 0x01));

                        body.emit(assign(r2DDA, r2DF0, 0x01));

                        body.emit(assign(r2DD7, body.constant(int(0)), 0x01));

                        body.emit(assign(r2DDD, less(r2DF0, body.constant(0u)), 0x01));


                     body.instructions = f2DEC_parent_instructions;
                     body.emit(f2DEC);

                     /* END IF */


                  body.instructions = f2DE9_parent_instructions;
                  body.emit(f2DE9);

                  /* END IF */


               body.instructions = f2DDF_parent_instructions;
               body.emit(f2DDF);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2E08 = new(mem_ctx) ir_if(operand(r2DDB).val);
               exec_list *const f2E08_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E08->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2E09 = new(mem_ctx) ir_if(operand(r2DDD).val);
                  exec_list *const f2E09_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E09->then_instructions;

                     ir_variable *const r2E0A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2E0A, add(r2DD9, body.constant(1u)), 0x01));

                     ir_expression *const r2E0B = less(r2E0A, r2DD9);
                     ir_expression *const r2E0C = expr(ir_unop_b2i, r2E0B);
                     ir_expression *const r2E0D = expr(ir_unop_i2u, r2E0C);
                     body.emit(assign(r2DD8, add(r2DD8, r2E0D), 0x01));

                     ir_expression *const r2E0E = equal(r2DDA, body.constant(0u));
                     ir_expression *const r2E0F = expr(ir_unop_b2i, r2E0E);
                     ir_expression *const r2E10 = expr(ir_unop_i2u, r2E0F);
                     ir_expression *const r2E11 = add(r2DDA, r2E10);
                     ir_expression *const r2E12 = bit_and(r2E11, body.constant(1u));
                     ir_expression *const r2E13 = expr(ir_unop_bit_not, r2E12);
                     body.emit(assign(r2DD9, bit_and(r2E0A, r2E13), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E09->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2E15 = bit_or(r2DD8, r2DD9);
                     ir_expression *const r2E16 = equal(r2E15, body.constant(0u));
                     ir_if *f2E14 = new(mem_ctx) ir_if(operand(r2E16).val);
                     exec_list *const f2E14_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E14->then_instructions;

                        body.emit(assign(r2DD7, body.constant(int(0)), 0x01));


                     body.instructions = f2E14_parent_instructions;
                     body.emit(f2E14);

                     /* END IF */


                  body.instructions = f2E09_parent_instructions;
                  body.emit(f2E09);

                  /* END IF */

                  ir_variable *const r2E17 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2E17);
                  ir_expression *const r2E18 = lshift(r2C5E, body.constant(int(31)));
                  ir_expression *const r2E19 = expr(ir_unop_i2u, r2DD7);
                  ir_expression *const r2E1A = lshift(r2E19, body.constant(int(20)));
                  ir_expression *const r2E1B = add(r2E18, r2E1A);
                  body.emit(assign(r2E17, add(r2E1B, r2DD8), 0x02));

                  body.emit(assign(r2E17, r2DD9, 0x01));

                  body.emit(assign(r2DDC, r2E17, 0x03));

                  body.emit(assign(r2DDB, body.constant(false), 0x01));


               body.instructions = f2E08_parent_instructions;
               body.emit(f2E08);

               /* END IF */

               body.emit(assign(r2C5F, r2DDC, 0x03));


            body.instructions = f2D4A_parent_instructions;
            body.emit(f2D4A);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2D48->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2E1D = equal(r2C68, body.constant(int(2047)));
            ir_if *f2E1C = new(mem_ctx) ir_if(operand(r2E1D).val);
            exec_list *const f2E1C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E1C->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2E1F = bit_or(r2C65, r2C66);
               ir_expression *const r2E20 = bit_or(r2C63, r2C64);
               ir_expression *const r2E21 = bit_or(r2E1F, r2E20);
               ir_expression *const r2E22 = nequal(r2E21, body.constant(0u));
               ir_if *f2E1E = new(mem_ctx) ir_if(operand(r2E22).val);
               exec_list *const f2E1E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E1E->then_instructions;

                  ir_variable *const r2E23 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2E23, swizzle_x(r270B), 0x01));

                  ir_variable *const r2E24 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2E24, swizzle_x(r273F), 0x01));

                  ir_variable *const r2E25 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2E26 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2E27 = rshift(swizzle_y(r270B), body.constant(int(19)));
                  ir_expression *const r2E28 = bit_and(r2E27, body.constant(4095u));
                  ir_expression *const r2E29 = equal(r2E28, body.constant(4094u));
                  ir_expression *const r2E2A = nequal(swizzle_x(r270B), body.constant(0u));
                  ir_expression *const r2E2B = bit_and(swizzle_y(r270B), body.constant(524287u));
                  ir_expression *const r2E2C = nequal(r2E2B, body.constant(0u));
                  ir_expression *const r2E2D = logic_or(r2E2A, r2E2C);
                  body.emit(assign(r2E26, logic_and(r2E29, r2E2D), 0x01));

                  ir_variable *const r2E2E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2E2F = lshift(swizzle_y(r273F), body.constant(int(1)));
                  ir_expression *const r2E30 = lequal(body.constant(4292870144u), r2E2F);
                  ir_expression *const r2E31 = nequal(swizzle_x(r273F), body.constant(0u));
                  ir_expression *const r2E32 = bit_and(swizzle_y(r273F), body.constant(1048575u));
                  ir_expression *const r2E33 = nequal(r2E32, body.constant(0u));
                  ir_expression *const r2E34 = logic_or(r2E31, r2E33);
                  body.emit(assign(r2E2E, logic_and(r2E30, r2E34), 0x01));

                  body.emit(assign(r2E23, bit_or(swizzle_y(r270B), body.constant(524288u)), 0x02));

                  body.emit(assign(r2E24, bit_or(swizzle_y(r273F), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2E36 = lshift(swizzle_y(r270B), body.constant(int(1)));
                  ir_expression *const r2E37 = lequal(body.constant(4292870144u), r2E36);
                  ir_expression *const r2E38 = nequal(swizzle_x(r270B), body.constant(0u));
                  ir_expression *const r2E39 = bit_and(swizzle_y(r270B), body.constant(1048575u));
                  ir_expression *const r2E3A = nequal(r2E39, body.constant(0u));
                  ir_expression *const r2E3B = logic_or(r2E38, r2E3A);
                  ir_expression *const r2E3C = logic_and(r2E37, r2E3B);
                  ir_if *f2E35 = new(mem_ctx) ir_if(operand(r2E3C).val);
                  exec_list *const f2E35_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E35->then_instructions;

                     ir_variable *const r2E3D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2E3F = logic_and(r2E26, r2E2E);
                     ir_if *f2E3E = new(mem_ctx) ir_if(operand(r2E3F).val);
                     exec_list *const f2E3E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E3E->then_instructions;

                        body.emit(assign(r2E3D, r2E24, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E3E->else_instructions;

                        body.emit(assign(r2E3D, r2E23, 0x03));


                     body.instructions = f2E3E_parent_instructions;
                     body.emit(f2E3E);

                     /* END IF */

                     body.emit(assign(r2E25, r2E3D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E35->else_instructions;

                     body.emit(assign(r2E25, r2E24, 0x03));


                  body.instructions = f2E35_parent_instructions;
                  body.emit(f2E35);

                  /* END IF */

                  body.emit(assign(r2C5F, r2E25, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2E1E->else_instructions;

                  ir_constant_data r2E40_data;
                  memset(&r2E40_data, 0, sizeof(ir_constant_data));
                  r2E40_data.u[0] = 4294967295;
                  r2E40_data.u[1] = 4294967295;
                  ir_constant *const r2E40 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r2E40_data);
                  body.emit(assign(r2C5F, r2E40, 0x03));


               body.instructions = f2E1E_parent_instructions;
               body.emit(f2E1E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2E1C->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2E42 = equal(r2C68, body.constant(int(0)));
               ir_if *f2E41 = new(mem_ctx) ir_if(operand(r2E42).val);
               exec_list *const f2E41_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E41->then_instructions;

                  body.emit(assign(r2C62, body.constant(int(1)), 0x01));

                  body.emit(assign(r2C61, body.constant(int(1)), 0x01));


               body.instructions = f2E41_parent_instructions;
               body.emit(f2E41);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2E44 = less(r2C63, r2C65);
               ir_if *f2E43 = new(mem_ctx) ir_if(operand(r2E44).val);
               exec_list *const f2E43_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E43->then_instructions;

                  ir_variable *const r2E45 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r2E46 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2E46, sub(r2C66, r2C64), 0x01));

                  ir_expression *const r2E47 = sub(r2C65, r2C63);
                  ir_expression *const r2E48 = less(r2C66, r2C64);
                  ir_expression *const r2E49 = expr(ir_unop_b2i, r2E48);
                  ir_expression *const r2E4A = expr(ir_unop_i2u, r2E49);
                  body.emit(assign(r2E45, sub(r2E47, r2E4A), 0x01));

                  body.emit(assign(r2C67, add(r2C62, body.constant(int(-1))), 0x01));

                  ir_variable *const r2E4B = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r2E4B, add(r2C67, body.constant(int(-10))), 0x01));

                  ir_variable *const r2E4C = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r2E4C, r2E45, 0x01));

                  ir_variable *const r2E4D = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r2E4D, r2E46, 0x01));

                  ir_variable *const r2E4E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r2E4E);
                  ir_variable *const r2E4F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2E4F);
                  /* IF CONDITION */
                  ir_expression *const r2E51 = equal(r2E45, body.constant(0u));
                  ir_if *f2E50 = new(mem_ctx) ir_if(operand(r2E51).val);
                  exec_list *const f2E50_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E50->then_instructions;

                     body.emit(assign(r2E4C, r2E46, 0x01));

                     body.emit(assign(r2E4D, body.constant(0u), 0x01));

                     body.emit(assign(r2E4B, add(r2E4B, body.constant(int(-32))), 0x01));


                  body.instructions = f2E50_parent_instructions;
                  body.emit(f2E50);

                  /* END IF */

                  ir_variable *const r2E52 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r2E52, r2E4C, 0x01));

                  ir_variable *const r2E53 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r2E54 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2E54);
                  /* IF CONDITION */
                  ir_expression *const r2E56 = equal(r2E4C, body.constant(0u));
                  ir_if *f2E55 = new(mem_ctx) ir_if(operand(r2E56).val);
                  exec_list *const f2E55_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E55->then_instructions;

                     body.emit(assign(r2E53, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E55->else_instructions;

                     body.emit(assign(r2E54, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2E58 = bit_and(r2E4C, body.constant(4294901760u));
                     ir_expression *const r2E59 = equal(r2E58, body.constant(0u));
                     ir_if *f2E57 = new(mem_ctx) ir_if(operand(r2E59).val);
                     exec_list *const f2E57_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E57->then_instructions;

                        body.emit(assign(r2E54, body.constant(int(16)), 0x01));

                        body.emit(assign(r2E52, lshift(r2E4C, body.constant(int(16))), 0x01));


                     body.instructions = f2E57_parent_instructions;
                     body.emit(f2E57);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E5B = bit_and(r2E52, body.constant(4278190080u));
                     ir_expression *const r2E5C = equal(r2E5B, body.constant(0u));
                     ir_if *f2E5A = new(mem_ctx) ir_if(operand(r2E5C).val);
                     exec_list *const f2E5A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E5A->then_instructions;

                        body.emit(assign(r2E54, add(r2E54, body.constant(int(8))), 0x01));

                        body.emit(assign(r2E52, lshift(r2E52, body.constant(int(8))), 0x01));


                     body.instructions = f2E5A_parent_instructions;
                     body.emit(f2E5A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E5E = bit_and(r2E52, body.constant(4026531840u));
                     ir_expression *const r2E5F = equal(r2E5E, body.constant(0u));
                     ir_if *f2E5D = new(mem_ctx) ir_if(operand(r2E5F).val);
                     exec_list *const f2E5D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E5D->then_instructions;

                        body.emit(assign(r2E54, add(r2E54, body.constant(int(4))), 0x01));

                        body.emit(assign(r2E52, lshift(r2E52, body.constant(int(4))), 0x01));


                     body.instructions = f2E5D_parent_instructions;
                     body.emit(f2E5D);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E61 = bit_and(r2E52, body.constant(3221225472u));
                     ir_expression *const r2E62 = equal(r2E61, body.constant(0u));
                     ir_if *f2E60 = new(mem_ctx) ir_if(operand(r2E62).val);
                     exec_list *const f2E60_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E60->then_instructions;

                        body.emit(assign(r2E54, add(r2E54, body.constant(int(2))), 0x01));

                        body.emit(assign(r2E52, lshift(r2E52, body.constant(int(2))), 0x01));


                     body.instructions = f2E60_parent_instructions;
                     body.emit(f2E60);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E64 = bit_and(r2E52, body.constant(2147483648u));
                     ir_expression *const r2E65 = equal(r2E64, body.constant(0u));
                     ir_if *f2E63 = new(mem_ctx) ir_if(operand(r2E65).val);
                     exec_list *const f2E63_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E63->then_instructions;

                        body.emit(assign(r2E54, add(r2E54, body.constant(int(1))), 0x01));


                     body.instructions = f2E63_parent_instructions;
                     body.emit(f2E63);

                     /* END IF */

                     body.emit(assign(r2E53, r2E54, 0x01));


                  body.instructions = f2E55_parent_instructions;
                  body.emit(f2E55);

                  /* END IF */

                  body.emit(assign(r2E4F, add(r2E53, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2E67 = lequal(body.constant(int(0)), r2E4F);
                  ir_if *f2E66 = new(mem_ctx) ir_if(operand(r2E67).val);
                  exec_list *const f2E66_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E66->then_instructions;

                     body.emit(assign(r2E4E, body.constant(0u), 0x01));

                     ir_variable *const r2E68 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2E68, lshift(r2E4D, r2E4F), 0x01));

                     ir_variable *const r2E69 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2E6B = equal(r2E4F, body.constant(int(0)));
                     ir_if *f2E6A = new(mem_ctx) ir_if(operand(r2E6B).val);
                     exec_list *const f2E6A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E6A->then_instructions;

                        body.emit(assign(r2E69, r2E4C, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E6A->else_instructions;

                        ir_expression *const r2E6C = lshift(r2E4C, r2E4F);
                        ir_expression *const r2E6D = neg(r2E4F);
                        ir_expression *const r2E6E = bit_and(r2E6D, body.constant(int(31)));
                        ir_expression *const r2E6F = rshift(r2E4D, r2E6E);
                        body.emit(assign(r2E69, bit_or(r2E6C, r2E6F), 0x01));


                     body.instructions = f2E6A_parent_instructions;
                     body.emit(f2E6A);

                     /* END IF */

                     body.emit(assign(r2E4C, r2E69, 0x01));

                     body.emit(assign(r2E4D, r2E68, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E66->else_instructions;

                     ir_variable *const r2E70 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2E70, body.constant(0u), 0x01));

                     ir_variable *const r2E71 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2E71, neg(r2E4F), 0x01));

                     ir_variable *const r2E72 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2E72);
                     ir_variable *const r2E73 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2E73);
                     ir_variable *const r2E74 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2E74);
                     ir_variable *const r2E75 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r2E76 = neg(r2E71);
                     body.emit(assign(r2E75, bit_and(r2E76, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2E78 = equal(r2E71, body.constant(int(0)));
                     ir_if *f2E77 = new(mem_ctx) ir_if(operand(r2E78).val);
                     exec_list *const f2E77_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E77->then_instructions;

                        body.emit(assign(r2E72, r2E70, 0x01));

                        body.emit(assign(r2E73, r2E4D, 0x01));

                        body.emit(assign(r2E74, r2E4C, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E77->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2E7A = less(r2E71, body.constant(int(32)));
                        ir_if *f2E79 = new(mem_ctx) ir_if(operand(r2E7A).val);
                        exec_list *const f2E79_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E79->then_instructions;

                           body.emit(assign(r2E72, lshift(r2E4D, r2E75), 0x01));

                           ir_expression *const r2E7B = lshift(r2E4C, r2E75);
                           ir_expression *const r2E7C = rshift(r2E4D, r2E71);
                           body.emit(assign(r2E73, bit_or(r2E7B, r2E7C), 0x01));

                           body.emit(assign(r2E74, rshift(r2E4C, r2E71), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2E79->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2E7E = equal(r2E71, body.constant(int(32)));
                           ir_if *f2E7D = new(mem_ctx) ir_if(operand(r2E7E).val);
                           exec_list *const f2E7D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2E7D->then_instructions;

                              body.emit(assign(r2E72, r2E4D, 0x01));

                              body.emit(assign(r2E73, r2E4C, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2E7D->else_instructions;

                              body.emit(assign(r2E70, bit_or(body.constant(0u), r2E4D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2E80 = less(r2E71, body.constant(int(64)));
                              ir_if *f2E7F = new(mem_ctx) ir_if(operand(r2E80).val);
                              exec_list *const f2E7F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2E7F->then_instructions;

                                 body.emit(assign(r2E72, lshift(r2E4C, r2E75), 0x01));

                                 ir_expression *const r2E81 = bit_and(r2E71, body.constant(int(31)));
                                 body.emit(assign(r2E73, rshift(r2E4C, r2E81), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2E7F->else_instructions;

                                 ir_variable *const r2E82 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2E84 = equal(r2E71, body.constant(int(64)));
                                 ir_if *f2E83 = new(mem_ctx) ir_if(operand(r2E84).val);
                                 exec_list *const f2E83_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2E83->then_instructions;

                                    body.emit(assign(r2E82, r2E4C, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2E83->else_instructions;

                                    ir_expression *const r2E85 = nequal(r2E4C, body.constant(0u));
                                    ir_expression *const r2E86 = expr(ir_unop_b2i, r2E85);
                                    body.emit(assign(r2E82, expr(ir_unop_i2u, r2E86), 0x01));


                                 body.instructions = f2E83_parent_instructions;
                                 body.emit(f2E83);

                                 /* END IF */

                                 body.emit(assign(r2E72, r2E82, 0x01));

                                 body.emit(assign(r2E73, body.constant(0u), 0x01));


                              body.instructions = f2E7F_parent_instructions;
                              body.emit(f2E7F);

                              /* END IF */


                           body.instructions = f2E7D_parent_instructions;
                           body.emit(f2E7D);

                           /* END IF */

                           body.emit(assign(r2E74, body.constant(0u), 0x01));


                        body.instructions = f2E79_parent_instructions;
                        body.emit(f2E79);

                        /* END IF */

                        ir_expression *const r2E87 = nequal(r2E70, body.constant(0u));
                        ir_expression *const r2E88 = expr(ir_unop_b2i, r2E87);
                        ir_expression *const r2E89 = expr(ir_unop_i2u, r2E88);
                        body.emit(assign(r2E72, bit_or(r2E72, r2E89), 0x01));


                     body.instructions = f2E77_parent_instructions;
                     body.emit(f2E77);

                     /* END IF */

                     body.emit(assign(r2E4C, r2E74, 0x01));

                     body.emit(assign(r2E4D, r2E73, 0x01));

                     body.emit(assign(r2E4E, r2E72, 0x01));


                  body.instructions = f2E66_parent_instructions;
                  body.emit(f2E66);

                  /* END IF */

                  body.emit(assign(r2E4B, sub(r2E4B, r2E4F), 0x01));

                  ir_variable *const r2E8A = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r2E8A, r2E4B, 0x01));

                  ir_variable *const r2E8B = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r2E8B, r2E4C, 0x01));

                  ir_variable *const r2E8C = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r2E8C, r2E4D, 0x01));

                  ir_variable *const r2E8D = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r2E8D, r2E4E, 0x01));

                  ir_variable *const r2E8E = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r2E8E, body.constant(true), 0x01));

                  ir_variable *const r2E8F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2E90 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r2E90);
                  ir_expression *const r2E91 = expr(ir_unop_u2i, r2E4E);
                  body.emit(assign(r2E90, less(r2E91, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2E93 = lequal(body.constant(int(2045)), r2E4B);
                  ir_if *f2E92 = new(mem_ctx) ir_if(operand(r2E93).val);
                  exec_list *const f2E92_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E92->then_instructions;

                     ir_variable *const r2E94 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2E96 = less(body.constant(int(2045)), r2E4B);
                     ir_if *f2E95 = new(mem_ctx) ir_if(operand(r2E96).val);
                     exec_list *const f2E95_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E95->then_instructions;

                        body.emit(assign(r2E94, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E95->else_instructions;

                        ir_variable *const r2E97 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2E99 = equal(r2E4B, body.constant(int(2045)));
                        ir_if *f2E98 = new(mem_ctx) ir_if(operand(r2E99).val);
                        exec_list *const f2E98_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E98->then_instructions;

                           ir_expression *const r2E9A = equal(body.constant(2097151u), r2E4C);
                           ir_expression *const r2E9B = equal(body.constant(4294967295u), r2E4D);
                           body.emit(assign(r2E97, logic_and(r2E9A, r2E9B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2E98->else_instructions;

                           body.emit(assign(r2E97, body.constant(false), 0x01));


                        body.instructions = f2E98_parent_instructions;
                        body.emit(f2E98);

                        /* END IF */

                        body.emit(assign(r2E94, logic_and(r2E97, r2E90), 0x01));


                     body.instructions = f2E95_parent_instructions;
                     body.emit(f2E95);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2E9C = new(mem_ctx) ir_if(operand(r2E94).val);
                     exec_list *const f2E9C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E9C->then_instructions;

                        ir_variable *const r2E9D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2E9D);
                        ir_expression *const r2E9E = lshift(r2C5E, body.constant(int(31)));
                        body.emit(assign(r2E9D, add(r2E9E, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r2E9D, body.constant(0u), 0x01));

                        body.emit(assign(r2E8F, r2E9D, 0x03));

                        body.emit(assign(r2E8E, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E9C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2EA0 = less(r2E4B, body.constant(int(0)));
                        ir_if *f2E9F = new(mem_ctx) ir_if(operand(r2EA0).val);
                        exec_list *const f2E9F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E9F->then_instructions;

                           ir_variable *const r2EA1 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2EA1, r2E4E, 0x01));

                           ir_variable *const r2EA2 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2EA2, neg(r2E4B), 0x01));

                           ir_variable *const r2EA3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2EA3);
                           ir_variable *const r2EA4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2EA4);
                           ir_variable *const r2EA5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2EA5);
                           ir_variable *const r2EA6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2EA7 = neg(r2EA2);
                           body.emit(assign(r2EA6, bit_and(r2EA7, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2EA9 = equal(r2EA2, body.constant(int(0)));
                           ir_if *f2EA8 = new(mem_ctx) ir_if(operand(r2EA9).val);
                           exec_list *const f2EA8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2EA8->then_instructions;

                              body.emit(assign(r2EA3, r2E4E, 0x01));

                              body.emit(assign(r2EA4, r2E4D, 0x01));

                              body.emit(assign(r2EA5, r2E4C, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2EA8->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2EAB = less(r2EA2, body.constant(int(32)));
                              ir_if *f2EAA = new(mem_ctx) ir_if(operand(r2EAB).val);
                              exec_list *const f2EAA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2EAA->then_instructions;

                                 body.emit(assign(r2EA3, lshift(r2E4D, r2EA6), 0x01));

                                 ir_expression *const r2EAC = lshift(r2E4C, r2EA6);
                                 ir_expression *const r2EAD = rshift(r2E4D, r2EA2);
                                 body.emit(assign(r2EA4, bit_or(r2EAC, r2EAD), 0x01));

                                 body.emit(assign(r2EA5, rshift(r2E4C, r2EA2), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2EAA->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2EAF = equal(r2EA2, body.constant(int(32)));
                                 ir_if *f2EAE = new(mem_ctx) ir_if(operand(r2EAF).val);
                                 exec_list *const f2EAE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2EAE->then_instructions;

                                    body.emit(assign(r2EA3, r2E4D, 0x01));

                                    body.emit(assign(r2EA4, r2E4C, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2EAE->else_instructions;

                                    body.emit(assign(r2EA1, bit_or(r2E4E, r2E4D), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2EB1 = less(r2EA2, body.constant(int(64)));
                                    ir_if *f2EB0 = new(mem_ctx) ir_if(operand(r2EB1).val);
                                    exec_list *const f2EB0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2EB0->then_instructions;

                                       body.emit(assign(r2EA3, lshift(r2E4C, r2EA6), 0x01));

                                       ir_expression *const r2EB2 = bit_and(r2EA2, body.constant(int(31)));
                                       body.emit(assign(r2EA4, rshift(r2E4C, r2EB2), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2EB0->else_instructions;

                                       ir_variable *const r2EB3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2EB5 = equal(r2EA2, body.constant(int(64)));
                                       ir_if *f2EB4 = new(mem_ctx) ir_if(operand(r2EB5).val);
                                       exec_list *const f2EB4_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2EB4->then_instructions;

                                          body.emit(assign(r2EB3, r2E4C, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2EB4->else_instructions;

                                          ir_expression *const r2EB6 = nequal(r2E4C, body.constant(0u));
                                          ir_expression *const r2EB7 = expr(ir_unop_b2i, r2EB6);
                                          body.emit(assign(r2EB3, expr(ir_unop_i2u, r2EB7), 0x01));


                                       body.instructions = f2EB4_parent_instructions;
                                       body.emit(f2EB4);

                                       /* END IF */

                                       body.emit(assign(r2EA3, r2EB3, 0x01));

                                       body.emit(assign(r2EA4, body.constant(0u), 0x01));


                                    body.instructions = f2EB0_parent_instructions;
                                    body.emit(f2EB0);

                                    /* END IF */


                                 body.instructions = f2EAE_parent_instructions;
                                 body.emit(f2EAE);

                                 /* END IF */

                                 body.emit(assign(r2EA5, body.constant(0u), 0x01));


                              body.instructions = f2EAA_parent_instructions;
                              body.emit(f2EAA);

                              /* END IF */

                              ir_expression *const r2EB8 = nequal(r2EA1, body.constant(0u));
                              ir_expression *const r2EB9 = expr(ir_unop_b2i, r2EB8);
                              ir_expression *const r2EBA = expr(ir_unop_i2u, r2EB9);
                              body.emit(assign(r2EA3, bit_or(r2EA3, r2EBA), 0x01));


                           body.instructions = f2EA8_parent_instructions;
                           body.emit(f2EA8);

                           /* END IF */

                           body.emit(assign(r2E8B, r2EA5, 0x01));

                           body.emit(assign(r2E8C, r2EA4, 0x01));

                           body.emit(assign(r2E8D, r2EA3, 0x01));

                           body.emit(assign(r2E8A, body.constant(int(0)), 0x01));

                           body.emit(assign(r2E90, less(r2EA3, body.constant(0u)), 0x01));


                        body.instructions = f2E9F_parent_instructions;
                        body.emit(f2E9F);

                        /* END IF */


                     body.instructions = f2E9C_parent_instructions;
                     body.emit(f2E9C);

                     /* END IF */


                  body.instructions = f2E92_parent_instructions;
                  body.emit(f2E92);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2EBB = new(mem_ctx) ir_if(operand(r2E8E).val);
                  exec_list *const f2EBB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2EBB->then_instructions;

                     /* IF CONDITION */
                     ir_if *f2EBC = new(mem_ctx) ir_if(operand(r2E90).val);
                     exec_list *const f2EBC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EBC->then_instructions;

                        ir_variable *const r2EBD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r2EBD, add(r2E8C, body.constant(1u)), 0x01));

                        ir_expression *const r2EBE = less(r2EBD, r2E8C);
                        ir_expression *const r2EBF = expr(ir_unop_b2i, r2EBE);
                        ir_expression *const r2EC0 = expr(ir_unop_i2u, r2EBF);
                        body.emit(assign(r2E8B, add(r2E8B, r2EC0), 0x01));

                        ir_expression *const r2EC1 = equal(r2E8D, body.constant(0u));
                        ir_expression *const r2EC2 = expr(ir_unop_b2i, r2EC1);
                        ir_expression *const r2EC3 = expr(ir_unop_i2u, r2EC2);
                        ir_expression *const r2EC4 = add(r2E8D, r2EC3);
                        ir_expression *const r2EC5 = bit_and(r2EC4, body.constant(1u));
                        ir_expression *const r2EC6 = expr(ir_unop_bit_not, r2EC5);
                        body.emit(assign(r2E8C, bit_and(r2EBD, r2EC6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EBC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2EC8 = bit_or(r2E8B, r2E8C);
                        ir_expression *const r2EC9 = equal(r2EC8, body.constant(0u));
                        ir_if *f2EC7 = new(mem_ctx) ir_if(operand(r2EC9).val);
                        exec_list *const f2EC7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EC7->then_instructions;

                           body.emit(assign(r2E8A, body.constant(int(0)), 0x01));


                        body.instructions = f2EC7_parent_instructions;
                        body.emit(f2EC7);

                        /* END IF */


                     body.instructions = f2EBC_parent_instructions;
                     body.emit(f2EBC);

                     /* END IF */

                     ir_variable *const r2ECA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2ECA);
                     ir_expression *const r2ECB = lshift(r2C5E, body.constant(int(31)));
                     ir_expression *const r2ECC = expr(ir_unop_i2u, r2E8A);
                     ir_expression *const r2ECD = lshift(r2ECC, body.constant(int(20)));
                     ir_expression *const r2ECE = add(r2ECB, r2ECD);
                     body.emit(assign(r2ECA, add(r2ECE, r2E8B), 0x02));

                     body.emit(assign(r2ECA, r2E8C, 0x01));

                     body.emit(assign(r2E8F, r2ECA, 0x03));

                     body.emit(assign(r2E8E, body.constant(false), 0x01));


                  body.instructions = f2EBB_parent_instructions;
                  body.emit(f2EBB);

                  /* END IF */

                  body.emit(assign(r2C5F, r2E8F, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2E43->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2ED0 = less(r2C65, r2C63);
                  ir_if *f2ECF = new(mem_ctx) ir_if(operand(r2ED0).val);
                  exec_list *const f2ECF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2ECF->then_instructions;

                     ir_variable *const r2ED1 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r2ED2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2ED2, sub(r2C64, r2C66), 0x01));

                     ir_expression *const r2ED3 = sub(r2C63, r2C65);
                     ir_expression *const r2ED4 = less(r2C64, r2C66);
                     ir_expression *const r2ED5 = expr(ir_unop_b2i, r2ED4);
                     ir_expression *const r2ED6 = expr(ir_unop_i2u, r2ED5);
                     body.emit(assign(r2ED1, sub(r2ED3, r2ED6), 0x01));

                     body.emit(assign(r2C5E, bit_xor(r2C5E, body.constant(1u)), 0x01));

                     body.emit(assign(r2C67, add(r2C61, body.constant(int(-1))), 0x01));

                     ir_variable *const r2ED7 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2ED7, add(r2C67, body.constant(int(-10))), 0x01));

                     ir_variable *const r2ED8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2ED8, r2ED1, 0x01));

                     ir_variable *const r2ED9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2ED9, r2ED2, 0x01));

                     ir_variable *const r2EDA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r2EDA);
                     ir_variable *const r2EDB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2EDB);
                     /* IF CONDITION */
                     ir_expression *const r2EDD = equal(r2ED1, body.constant(0u));
                     ir_if *f2EDC = new(mem_ctx) ir_if(operand(r2EDD).val);
                     exec_list *const f2EDC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EDC->then_instructions;

                        body.emit(assign(r2ED8, r2ED2, 0x01));

                        body.emit(assign(r2ED9, body.constant(0u), 0x01));

                        body.emit(assign(r2ED7, add(r2ED7, body.constant(int(-32))), 0x01));


                     body.instructions = f2EDC_parent_instructions;
                     body.emit(f2EDC);

                     /* END IF */

                     ir_variable *const r2EDE = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r2EDE, r2ED8, 0x01));

                     ir_variable *const r2EDF = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r2EE0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2EE0);
                     /* IF CONDITION */
                     ir_expression *const r2EE2 = equal(r2ED8, body.constant(0u));
                     ir_if *f2EE1 = new(mem_ctx) ir_if(operand(r2EE2).val);
                     exec_list *const f2EE1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EE1->then_instructions;

                        body.emit(assign(r2EDF, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EE1->else_instructions;

                        body.emit(assign(r2EE0, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2EE4 = bit_and(r2ED8, body.constant(4294901760u));
                        ir_expression *const r2EE5 = equal(r2EE4, body.constant(0u));
                        ir_if *f2EE3 = new(mem_ctx) ir_if(operand(r2EE5).val);
                        exec_list *const f2EE3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EE3->then_instructions;

                           body.emit(assign(r2EE0, body.constant(int(16)), 0x01));

                           body.emit(assign(r2EDE, lshift(r2ED8, body.constant(int(16))), 0x01));


                        body.instructions = f2EE3_parent_instructions;
                        body.emit(f2EE3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2EE7 = bit_and(r2EDE, body.constant(4278190080u));
                        ir_expression *const r2EE8 = equal(r2EE7, body.constant(0u));
                        ir_if *f2EE6 = new(mem_ctx) ir_if(operand(r2EE8).val);
                        exec_list *const f2EE6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EE6->then_instructions;

                           body.emit(assign(r2EE0, add(r2EE0, body.constant(int(8))), 0x01));

                           body.emit(assign(r2EDE, lshift(r2EDE, body.constant(int(8))), 0x01));


                        body.instructions = f2EE6_parent_instructions;
                        body.emit(f2EE6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2EEA = bit_and(r2EDE, body.constant(4026531840u));
                        ir_expression *const r2EEB = equal(r2EEA, body.constant(0u));
                        ir_if *f2EE9 = new(mem_ctx) ir_if(operand(r2EEB).val);
                        exec_list *const f2EE9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EE9->then_instructions;

                           body.emit(assign(r2EE0, add(r2EE0, body.constant(int(4))), 0x01));

                           body.emit(assign(r2EDE, lshift(r2EDE, body.constant(int(4))), 0x01));


                        body.instructions = f2EE9_parent_instructions;
                        body.emit(f2EE9);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2EED = bit_and(r2EDE, body.constant(3221225472u));
                        ir_expression *const r2EEE = equal(r2EED, body.constant(0u));
                        ir_if *f2EEC = new(mem_ctx) ir_if(operand(r2EEE).val);
                        exec_list *const f2EEC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EEC->then_instructions;

                           body.emit(assign(r2EE0, add(r2EE0, body.constant(int(2))), 0x01));

                           body.emit(assign(r2EDE, lshift(r2EDE, body.constant(int(2))), 0x01));


                        body.instructions = f2EEC_parent_instructions;
                        body.emit(f2EEC);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2EF0 = bit_and(r2EDE, body.constant(2147483648u));
                        ir_expression *const r2EF1 = equal(r2EF0, body.constant(0u));
                        ir_if *f2EEF = new(mem_ctx) ir_if(operand(r2EF1).val);
                        exec_list *const f2EEF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EEF->then_instructions;

                           body.emit(assign(r2EE0, add(r2EE0, body.constant(int(1))), 0x01));


                        body.instructions = f2EEF_parent_instructions;
                        body.emit(f2EEF);

                        /* END IF */

                        body.emit(assign(r2EDF, r2EE0, 0x01));


                     body.instructions = f2EE1_parent_instructions;
                     body.emit(f2EE1);

                     /* END IF */

                     body.emit(assign(r2EDB, add(r2EDF, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2EF3 = lequal(body.constant(int(0)), r2EDB);
                     ir_if *f2EF2 = new(mem_ctx) ir_if(operand(r2EF3).val);
                     exec_list *const f2EF2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EF2->then_instructions;

                        body.emit(assign(r2EDA, body.constant(0u), 0x01));

                        ir_variable *const r2EF4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2EF4, lshift(r2ED9, r2EDB), 0x01));

                        ir_variable *const r2EF5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2EF7 = equal(r2EDB, body.constant(int(0)));
                        ir_if *f2EF6 = new(mem_ctx) ir_if(operand(r2EF7).val);
                        exec_list *const f2EF6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EF6->then_instructions;

                           body.emit(assign(r2EF5, r2ED8, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2EF6->else_instructions;

                           ir_expression *const r2EF8 = lshift(r2ED8, r2EDB);
                           ir_expression *const r2EF9 = neg(r2EDB);
                           ir_expression *const r2EFA = bit_and(r2EF9, body.constant(int(31)));
                           ir_expression *const r2EFB = rshift(r2ED9, r2EFA);
                           body.emit(assign(r2EF5, bit_or(r2EF8, r2EFB), 0x01));


                        body.instructions = f2EF6_parent_instructions;
                        body.emit(f2EF6);

                        /* END IF */

                        body.emit(assign(r2ED8, r2EF5, 0x01));

                        body.emit(assign(r2ED9, r2EF4, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EF2->else_instructions;

                        ir_variable *const r2EFC = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2EFC, body.constant(0u), 0x01));

                        ir_variable *const r2EFD = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2EFD, neg(r2EDB), 0x01));

                        ir_variable *const r2EFE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2EFE);
                        ir_variable *const r2EFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2EFF);
                        ir_variable *const r2F00 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2F00);
                        ir_variable *const r2F01 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2F02 = neg(r2EFD);
                        body.emit(assign(r2F01, bit_and(r2F02, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2F04 = equal(r2EFD, body.constant(int(0)));
                        ir_if *f2F03 = new(mem_ctx) ir_if(operand(r2F04).val);
                        exec_list *const f2F03_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F03->then_instructions;

                           body.emit(assign(r2EFE, r2EFC, 0x01));

                           body.emit(assign(r2EFF, r2ED9, 0x01));

                           body.emit(assign(r2F00, r2ED8, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F03->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2F06 = less(r2EFD, body.constant(int(32)));
                           ir_if *f2F05 = new(mem_ctx) ir_if(operand(r2F06).val);
                           exec_list *const f2F05_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F05->then_instructions;

                              body.emit(assign(r2EFE, lshift(r2ED9, r2F01), 0x01));

                              ir_expression *const r2F07 = lshift(r2ED8, r2F01);
                              ir_expression *const r2F08 = rshift(r2ED9, r2EFD);
                              body.emit(assign(r2EFF, bit_or(r2F07, r2F08), 0x01));

                              body.emit(assign(r2F00, rshift(r2ED8, r2EFD), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2F05->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2F0A = equal(r2EFD, body.constant(int(32)));
                              ir_if *f2F09 = new(mem_ctx) ir_if(operand(r2F0A).val);
                              exec_list *const f2F09_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2F09->then_instructions;

                                 body.emit(assign(r2EFE, r2ED9, 0x01));

                                 body.emit(assign(r2EFF, r2ED8, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2F09->else_instructions;

                                 body.emit(assign(r2EFC, bit_or(body.constant(0u), r2ED9), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2F0C = less(r2EFD, body.constant(int(64)));
                                 ir_if *f2F0B = new(mem_ctx) ir_if(operand(r2F0C).val);
                                 exec_list *const f2F0B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2F0B->then_instructions;

                                    body.emit(assign(r2EFE, lshift(r2ED8, r2F01), 0x01));

                                    ir_expression *const r2F0D = bit_and(r2EFD, body.constant(int(31)));
                                    body.emit(assign(r2EFF, rshift(r2ED8, r2F0D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2F0B->else_instructions;

                                    ir_variable *const r2F0E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2F10 = equal(r2EFD, body.constant(int(64)));
                                    ir_if *f2F0F = new(mem_ctx) ir_if(operand(r2F10).val);
                                    exec_list *const f2F0F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2F0F->then_instructions;

                                       body.emit(assign(r2F0E, r2ED8, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2F0F->else_instructions;

                                       ir_expression *const r2F11 = nequal(r2ED8, body.constant(0u));
                                       ir_expression *const r2F12 = expr(ir_unop_b2i, r2F11);
                                       body.emit(assign(r2F0E, expr(ir_unop_i2u, r2F12), 0x01));


                                    body.instructions = f2F0F_parent_instructions;
                                    body.emit(f2F0F);

                                    /* END IF */

                                    body.emit(assign(r2EFE, r2F0E, 0x01));

                                    body.emit(assign(r2EFF, body.constant(0u), 0x01));


                                 body.instructions = f2F0B_parent_instructions;
                                 body.emit(f2F0B);

                                 /* END IF */


                              body.instructions = f2F09_parent_instructions;
                              body.emit(f2F09);

                              /* END IF */

                              body.emit(assign(r2F00, body.constant(0u), 0x01));


                           body.instructions = f2F05_parent_instructions;
                           body.emit(f2F05);

                           /* END IF */

                           ir_expression *const r2F13 = nequal(r2EFC, body.constant(0u));
                           ir_expression *const r2F14 = expr(ir_unop_b2i, r2F13);
                           ir_expression *const r2F15 = expr(ir_unop_i2u, r2F14);
                           body.emit(assign(r2EFE, bit_or(r2EFE, r2F15), 0x01));


                        body.instructions = f2F03_parent_instructions;
                        body.emit(f2F03);

                        /* END IF */

                        body.emit(assign(r2ED8, r2F00, 0x01));

                        body.emit(assign(r2ED9, r2EFF, 0x01));

                        body.emit(assign(r2EDA, r2EFE, 0x01));


                     body.instructions = f2EF2_parent_instructions;
                     body.emit(f2EF2);

                     /* END IF */

                     body.emit(assign(r2ED7, sub(r2ED7, r2EDB), 0x01));

                     ir_variable *const r2F16 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2F16, r2ED7, 0x01));

                     ir_variable *const r2F17 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2F17, r2ED8, 0x01));

                     ir_variable *const r2F18 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2F18, r2ED9, 0x01));

                     ir_variable *const r2F19 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2F19, r2EDA, 0x01));

                     ir_variable *const r2F1A = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2F1A, body.constant(true), 0x01));

                     ir_variable *const r2F1B = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2F1C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2F1C);
                     ir_expression *const r2F1D = expr(ir_unop_u2i, r2EDA);
                     body.emit(assign(r2F1C, less(r2F1D, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2F1F = lequal(body.constant(int(2045)), r2ED7);
                     ir_if *f2F1E = new(mem_ctx) ir_if(operand(r2F1F).val);
                     exec_list *const f2F1E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F1E->then_instructions;

                        ir_variable *const r2F20 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2F22 = less(body.constant(int(2045)), r2ED7);
                        ir_if *f2F21 = new(mem_ctx) ir_if(operand(r2F22).val);
                        exec_list *const f2F21_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F21->then_instructions;

                           body.emit(assign(r2F20, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F21->else_instructions;

                           ir_variable *const r2F23 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2F25 = equal(r2ED7, body.constant(int(2045)));
                           ir_if *f2F24 = new(mem_ctx) ir_if(operand(r2F25).val);
                           exec_list *const f2F24_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F24->then_instructions;

                              ir_expression *const r2F26 = equal(body.constant(2097151u), r2ED8);
                              ir_expression *const r2F27 = equal(body.constant(4294967295u), r2ED9);
                              body.emit(assign(r2F23, logic_and(r2F26, r2F27), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2F24->else_instructions;

                              body.emit(assign(r2F23, body.constant(false), 0x01));


                           body.instructions = f2F24_parent_instructions;
                           body.emit(f2F24);

                           /* END IF */

                           body.emit(assign(r2F20, logic_and(r2F23, r2F1C), 0x01));


                        body.instructions = f2F21_parent_instructions;
                        body.emit(f2F21);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2F28 = new(mem_ctx) ir_if(operand(r2F20).val);
                        exec_list *const f2F28_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F28->then_instructions;

                           ir_variable *const r2F29 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2F29);
                           ir_expression *const r2F2A = lshift(r2C5E, body.constant(int(31)));
                           body.emit(assign(r2F29, add(r2F2A, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2F29, body.constant(0u), 0x01));

                           body.emit(assign(r2F1B, r2F29, 0x03));

                           body.emit(assign(r2F1A, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F28->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2F2C = less(r2ED7, body.constant(int(0)));
                           ir_if *f2F2B = new(mem_ctx) ir_if(operand(r2F2C).val);
                           exec_list *const f2F2B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F2B->then_instructions;

                              ir_variable *const r2F2D = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2F2D, r2EDA, 0x01));

                              ir_variable *const r2F2E = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2F2E, neg(r2ED7), 0x01));

                              ir_variable *const r2F2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2F2F);
                              ir_variable *const r2F30 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2F30);
                              ir_variable *const r2F31 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2F31);
                              ir_variable *const r2F32 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2F33 = neg(r2F2E);
                              body.emit(assign(r2F32, bit_and(r2F33, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2F35 = equal(r2F2E, body.constant(int(0)));
                              ir_if *f2F34 = new(mem_ctx) ir_if(operand(r2F35).val);
                              exec_list *const f2F34_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2F34->then_instructions;

                                 body.emit(assign(r2F2F, r2EDA, 0x01));

                                 body.emit(assign(r2F30, r2ED9, 0x01));

                                 body.emit(assign(r2F31, r2ED8, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2F34->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2F37 = less(r2F2E, body.constant(int(32)));
                                 ir_if *f2F36 = new(mem_ctx) ir_if(operand(r2F37).val);
                                 exec_list *const f2F36_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2F36->then_instructions;

                                    body.emit(assign(r2F2F, lshift(r2ED9, r2F32), 0x01));

                                    ir_expression *const r2F38 = lshift(r2ED8, r2F32);
                                    ir_expression *const r2F39 = rshift(r2ED9, r2F2E);
                                    body.emit(assign(r2F30, bit_or(r2F38, r2F39), 0x01));

                                    body.emit(assign(r2F31, rshift(r2ED8, r2F2E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2F36->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2F3B = equal(r2F2E, body.constant(int(32)));
                                    ir_if *f2F3A = new(mem_ctx) ir_if(operand(r2F3B).val);
                                    exec_list *const f2F3A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2F3A->then_instructions;

                                       body.emit(assign(r2F2F, r2ED9, 0x01));

                                       body.emit(assign(r2F30, r2ED8, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2F3A->else_instructions;

                                       body.emit(assign(r2F2D, bit_or(r2EDA, r2ED9), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2F3D = less(r2F2E, body.constant(int(64)));
                                       ir_if *f2F3C = new(mem_ctx) ir_if(operand(r2F3D).val);
                                       exec_list *const f2F3C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2F3C->then_instructions;

                                          body.emit(assign(r2F2F, lshift(r2ED8, r2F32), 0x01));

                                          ir_expression *const r2F3E = bit_and(r2F2E, body.constant(int(31)));
                                          body.emit(assign(r2F30, rshift(r2ED8, r2F3E), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2F3C->else_instructions;

                                          ir_variable *const r2F3F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2F41 = equal(r2F2E, body.constant(int(64)));
                                          ir_if *f2F40 = new(mem_ctx) ir_if(operand(r2F41).val);
                                          exec_list *const f2F40_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2F40->then_instructions;

                                             body.emit(assign(r2F3F, r2ED8, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2F40->else_instructions;

                                             ir_expression *const r2F42 = nequal(r2ED8, body.constant(0u));
                                             ir_expression *const r2F43 = expr(ir_unop_b2i, r2F42);
                                             body.emit(assign(r2F3F, expr(ir_unop_i2u, r2F43), 0x01));


                                          body.instructions = f2F40_parent_instructions;
                                          body.emit(f2F40);

                                          /* END IF */

                                          body.emit(assign(r2F2F, r2F3F, 0x01));

                                          body.emit(assign(r2F30, body.constant(0u), 0x01));


                                       body.instructions = f2F3C_parent_instructions;
                                       body.emit(f2F3C);

                                       /* END IF */


                                    body.instructions = f2F3A_parent_instructions;
                                    body.emit(f2F3A);

                                    /* END IF */

                                    body.emit(assign(r2F31, body.constant(0u), 0x01));


                                 body.instructions = f2F36_parent_instructions;
                                 body.emit(f2F36);

                                 /* END IF */

                                 ir_expression *const r2F44 = nequal(r2F2D, body.constant(0u));
                                 ir_expression *const r2F45 = expr(ir_unop_b2i, r2F44);
                                 ir_expression *const r2F46 = expr(ir_unop_i2u, r2F45);
                                 body.emit(assign(r2F2F, bit_or(r2F2F, r2F46), 0x01));


                              body.instructions = f2F34_parent_instructions;
                              body.emit(f2F34);

                              /* END IF */

                              body.emit(assign(r2F17, r2F31, 0x01));

                              body.emit(assign(r2F18, r2F30, 0x01));

                              body.emit(assign(r2F19, r2F2F, 0x01));

                              body.emit(assign(r2F16, body.constant(int(0)), 0x01));

                              body.emit(assign(r2F1C, less(r2F2F, body.constant(0u)), 0x01));


                           body.instructions = f2F2B_parent_instructions;
                           body.emit(f2F2B);

                           /* END IF */


                        body.instructions = f2F28_parent_instructions;
                        body.emit(f2F28);

                        /* END IF */


                     body.instructions = f2F1E_parent_instructions;
                     body.emit(f2F1E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2F47 = new(mem_ctx) ir_if(operand(r2F1A).val);
                     exec_list *const f2F47_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F47->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2F48 = new(mem_ctx) ir_if(operand(r2F1C).val);
                        exec_list *const f2F48_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F48->then_instructions;

                           ir_variable *const r2F49 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2F49, add(r2F18, body.constant(1u)), 0x01));

                           ir_expression *const r2F4A = less(r2F49, r2F18);
                           ir_expression *const r2F4B = expr(ir_unop_b2i, r2F4A);
                           ir_expression *const r2F4C = expr(ir_unop_i2u, r2F4B);
                           body.emit(assign(r2F17, add(r2F17, r2F4C), 0x01));

                           ir_expression *const r2F4D = equal(r2F19, body.constant(0u));
                           ir_expression *const r2F4E = expr(ir_unop_b2i, r2F4D);
                           ir_expression *const r2F4F = expr(ir_unop_i2u, r2F4E);
                           ir_expression *const r2F50 = add(r2F19, r2F4F);
                           ir_expression *const r2F51 = bit_and(r2F50, body.constant(1u));
                           ir_expression *const r2F52 = expr(ir_unop_bit_not, r2F51);
                           body.emit(assign(r2F18, bit_and(r2F49, r2F52), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F48->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2F54 = bit_or(r2F17, r2F18);
                           ir_expression *const r2F55 = equal(r2F54, body.constant(0u));
                           ir_if *f2F53 = new(mem_ctx) ir_if(operand(r2F55).val);
                           exec_list *const f2F53_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F53->then_instructions;

                              body.emit(assign(r2F16, body.constant(int(0)), 0x01));


                           body.instructions = f2F53_parent_instructions;
                           body.emit(f2F53);

                           /* END IF */


                        body.instructions = f2F48_parent_instructions;
                        body.emit(f2F48);

                        /* END IF */

                        ir_variable *const r2F56 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2F56);
                        ir_expression *const r2F57 = lshift(r2C5E, body.constant(int(31)));
                        ir_expression *const r2F58 = expr(ir_unop_i2u, r2F16);
                        ir_expression *const r2F59 = lshift(r2F58, body.constant(int(20)));
                        ir_expression *const r2F5A = add(r2F57, r2F59);
                        body.emit(assign(r2F56, add(r2F5A, r2F17), 0x02));

                        body.emit(assign(r2F56, r2F18, 0x01));

                        body.emit(assign(r2F1B, r2F56, 0x03));

                        body.emit(assign(r2F1A, body.constant(false), 0x01));


                     body.instructions = f2F47_parent_instructions;
                     body.emit(f2F47);

                     /* END IF */

                     body.emit(assign(r2C5F, r2F1B, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2ECF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2F5C = less(r2C64, r2C66);
                     ir_if *f2F5B = new(mem_ctx) ir_if(operand(r2F5C).val);
                     exec_list *const f2F5B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F5B->then_instructions;

                        ir_variable *const r2F5D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r2F5E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2F5E, sub(r2C66, r2C64), 0x01));

                        ir_expression *const r2F5F = sub(r2C65, r2C63);
                        ir_expression *const r2F60 = less(r2C66, r2C64);
                        ir_expression *const r2F61 = expr(ir_unop_b2i, r2F60);
                        ir_expression *const r2F62 = expr(ir_unop_i2u, r2F61);
                        body.emit(assign(r2F5D, sub(r2F5F, r2F62), 0x01));

                        body.emit(assign(r2C67, add(r2C62, body.constant(int(-1))), 0x01));

                        ir_variable *const r2F63 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2F63, add(r2C67, body.constant(int(-10))), 0x01));

                        ir_variable *const r2F64 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2F64, r2F5D, 0x01));

                        ir_variable *const r2F65 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2F65, r2F5E, 0x01));

                        ir_variable *const r2F66 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2F66);
                        ir_variable *const r2F67 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2F67);
                        /* IF CONDITION */
                        ir_expression *const r2F69 = equal(r2F5D, body.constant(0u));
                        ir_if *f2F68 = new(mem_ctx) ir_if(operand(r2F69).val);
                        exec_list *const f2F68_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F68->then_instructions;

                           body.emit(assign(r2F64, r2F5E, 0x01));

                           body.emit(assign(r2F65, body.constant(0u), 0x01));

                           body.emit(assign(r2F63, add(r2F63, body.constant(int(-32))), 0x01));


                        body.instructions = f2F68_parent_instructions;
                        body.emit(f2F68);

                        /* END IF */

                        ir_variable *const r2F6A = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2F6A, r2F64, 0x01));

                        ir_variable *const r2F6B = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r2F6C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2F6C);
                        /* IF CONDITION */
                        ir_expression *const r2F6E = equal(r2F64, body.constant(0u));
                        ir_if *f2F6D = new(mem_ctx) ir_if(operand(r2F6E).val);
                        exec_list *const f2F6D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F6D->then_instructions;

                           body.emit(assign(r2F6B, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F6D->else_instructions;

                           body.emit(assign(r2F6C, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2F70 = bit_and(r2F64, body.constant(4294901760u));
                           ir_expression *const r2F71 = equal(r2F70, body.constant(0u));
                           ir_if *f2F6F = new(mem_ctx) ir_if(operand(r2F71).val);
                           exec_list *const f2F6F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F6F->then_instructions;

                              body.emit(assign(r2F6C, body.constant(int(16)), 0x01));

                              body.emit(assign(r2F6A, lshift(r2F64, body.constant(int(16))), 0x01));


                           body.instructions = f2F6F_parent_instructions;
                           body.emit(f2F6F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2F73 = bit_and(r2F6A, body.constant(4278190080u));
                           ir_expression *const r2F74 = equal(r2F73, body.constant(0u));
                           ir_if *f2F72 = new(mem_ctx) ir_if(operand(r2F74).val);
                           exec_list *const f2F72_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F72->then_instructions;

                              body.emit(assign(r2F6C, add(r2F6C, body.constant(int(8))), 0x01));

                              body.emit(assign(r2F6A, lshift(r2F6A, body.constant(int(8))), 0x01));


                           body.instructions = f2F72_parent_instructions;
                           body.emit(f2F72);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2F76 = bit_and(r2F6A, body.constant(4026531840u));
                           ir_expression *const r2F77 = equal(r2F76, body.constant(0u));
                           ir_if *f2F75 = new(mem_ctx) ir_if(operand(r2F77).val);
                           exec_list *const f2F75_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F75->then_instructions;

                              body.emit(assign(r2F6C, add(r2F6C, body.constant(int(4))), 0x01));

                              body.emit(assign(r2F6A, lshift(r2F6A, body.constant(int(4))), 0x01));


                           body.instructions = f2F75_parent_instructions;
                           body.emit(f2F75);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2F79 = bit_and(r2F6A, body.constant(3221225472u));
                           ir_expression *const r2F7A = equal(r2F79, body.constant(0u));
                           ir_if *f2F78 = new(mem_ctx) ir_if(operand(r2F7A).val);
                           exec_list *const f2F78_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F78->then_instructions;

                              body.emit(assign(r2F6C, add(r2F6C, body.constant(int(2))), 0x01));

                              body.emit(assign(r2F6A, lshift(r2F6A, body.constant(int(2))), 0x01));


                           body.instructions = f2F78_parent_instructions;
                           body.emit(f2F78);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2F7C = bit_and(r2F6A, body.constant(2147483648u));
                           ir_expression *const r2F7D = equal(r2F7C, body.constant(0u));
                           ir_if *f2F7B = new(mem_ctx) ir_if(operand(r2F7D).val);
                           exec_list *const f2F7B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F7B->then_instructions;

                              body.emit(assign(r2F6C, add(r2F6C, body.constant(int(1))), 0x01));


                           body.instructions = f2F7B_parent_instructions;
                           body.emit(f2F7B);

                           /* END IF */

                           body.emit(assign(r2F6B, r2F6C, 0x01));


                        body.instructions = f2F6D_parent_instructions;
                        body.emit(f2F6D);

                        /* END IF */

                        body.emit(assign(r2F67, add(r2F6B, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2F7F = lequal(body.constant(int(0)), r2F67);
                        ir_if *f2F7E = new(mem_ctx) ir_if(operand(r2F7F).val);
                        exec_list *const f2F7E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F7E->then_instructions;

                           body.emit(assign(r2F66, body.constant(0u), 0x01));

                           ir_variable *const r2F80 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2F80, lshift(r2F65, r2F67), 0x01));

                           ir_variable *const r2F81 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2F83 = equal(r2F67, body.constant(int(0)));
                           ir_if *f2F82 = new(mem_ctx) ir_if(operand(r2F83).val);
                           exec_list *const f2F82_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F82->then_instructions;

                              body.emit(assign(r2F81, r2F64, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2F82->else_instructions;

                              ir_expression *const r2F84 = lshift(r2F64, r2F67);
                              ir_expression *const r2F85 = neg(r2F67);
                              ir_expression *const r2F86 = bit_and(r2F85, body.constant(int(31)));
                              ir_expression *const r2F87 = rshift(r2F65, r2F86);
                              body.emit(assign(r2F81, bit_or(r2F84, r2F87), 0x01));


                           body.instructions = f2F82_parent_instructions;
                           body.emit(f2F82);

                           /* END IF */

                           body.emit(assign(r2F64, r2F81, 0x01));

                           body.emit(assign(r2F65, r2F80, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F7E->else_instructions;

                           ir_variable *const r2F88 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2F88, body.constant(0u), 0x01));

                           ir_variable *const r2F89 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2F89, neg(r2F67), 0x01));

                           ir_variable *const r2F8A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2F8A);
                           ir_variable *const r2F8B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2F8B);
                           ir_variable *const r2F8C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2F8C);
                           ir_variable *const r2F8D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2F8E = neg(r2F89);
                           body.emit(assign(r2F8D, bit_and(r2F8E, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2F90 = equal(r2F89, body.constant(int(0)));
                           ir_if *f2F8F = new(mem_ctx) ir_if(operand(r2F90).val);
                           exec_list *const f2F8F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F8F->then_instructions;

                              body.emit(assign(r2F8A, r2F88, 0x01));

                              body.emit(assign(r2F8B, r2F65, 0x01));

                              body.emit(assign(r2F8C, r2F64, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2F8F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2F92 = less(r2F89, body.constant(int(32)));
                              ir_if *f2F91 = new(mem_ctx) ir_if(operand(r2F92).val);
                              exec_list *const f2F91_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2F91->then_instructions;

                                 body.emit(assign(r2F8A, lshift(r2F65, r2F8D), 0x01));

                                 ir_expression *const r2F93 = lshift(r2F64, r2F8D);
                                 ir_expression *const r2F94 = rshift(r2F65, r2F89);
                                 body.emit(assign(r2F8B, bit_or(r2F93, r2F94), 0x01));

                                 body.emit(assign(r2F8C, rshift(r2F64, r2F89), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2F91->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2F96 = equal(r2F89, body.constant(int(32)));
                                 ir_if *f2F95 = new(mem_ctx) ir_if(operand(r2F96).val);
                                 exec_list *const f2F95_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2F95->then_instructions;

                                    body.emit(assign(r2F8A, r2F65, 0x01));

                                    body.emit(assign(r2F8B, r2F64, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2F95->else_instructions;

                                    body.emit(assign(r2F88, bit_or(body.constant(0u), r2F65), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2F98 = less(r2F89, body.constant(int(64)));
                                    ir_if *f2F97 = new(mem_ctx) ir_if(operand(r2F98).val);
                                    exec_list *const f2F97_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2F97->then_instructions;

                                       body.emit(assign(r2F8A, lshift(r2F64, r2F8D), 0x01));

                                       ir_expression *const r2F99 = bit_and(r2F89, body.constant(int(31)));
                                       body.emit(assign(r2F8B, rshift(r2F64, r2F99), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2F97->else_instructions;

                                       ir_variable *const r2F9A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2F9C = equal(r2F89, body.constant(int(64)));
                                       ir_if *f2F9B = new(mem_ctx) ir_if(operand(r2F9C).val);
                                       exec_list *const f2F9B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2F9B->then_instructions;

                                          body.emit(assign(r2F9A, r2F64, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2F9B->else_instructions;

                                          ir_expression *const r2F9D = nequal(r2F64, body.constant(0u));
                                          ir_expression *const r2F9E = expr(ir_unop_b2i, r2F9D);
                                          body.emit(assign(r2F9A, expr(ir_unop_i2u, r2F9E), 0x01));


                                       body.instructions = f2F9B_parent_instructions;
                                       body.emit(f2F9B);

                                       /* END IF */

                                       body.emit(assign(r2F8A, r2F9A, 0x01));

                                       body.emit(assign(r2F8B, body.constant(0u), 0x01));


                                    body.instructions = f2F97_parent_instructions;
                                    body.emit(f2F97);

                                    /* END IF */


                                 body.instructions = f2F95_parent_instructions;
                                 body.emit(f2F95);

                                 /* END IF */

                                 body.emit(assign(r2F8C, body.constant(0u), 0x01));


                              body.instructions = f2F91_parent_instructions;
                              body.emit(f2F91);

                              /* END IF */

                              ir_expression *const r2F9F = nequal(r2F88, body.constant(0u));
                              ir_expression *const r2FA0 = expr(ir_unop_b2i, r2F9F);
                              ir_expression *const r2FA1 = expr(ir_unop_i2u, r2FA0);
                              body.emit(assign(r2F8A, bit_or(r2F8A, r2FA1), 0x01));


                           body.instructions = f2F8F_parent_instructions;
                           body.emit(f2F8F);

                           /* END IF */

                           body.emit(assign(r2F64, r2F8C, 0x01));

                           body.emit(assign(r2F65, r2F8B, 0x01));

                           body.emit(assign(r2F66, r2F8A, 0x01));


                        body.instructions = f2F7E_parent_instructions;
                        body.emit(f2F7E);

                        /* END IF */

                        body.emit(assign(r2F63, sub(r2F63, r2F67), 0x01));

                        ir_variable *const r2FA2 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2FA2, r2F63, 0x01));

                        ir_variable *const r2FA3 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2FA3, r2F64, 0x01));

                        ir_variable *const r2FA4 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2FA4, r2F65, 0x01));

                        ir_variable *const r2FA5 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r2FA5, r2F66, 0x01));

                        ir_variable *const r2FA6 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r2FA6, body.constant(true), 0x01));

                        ir_variable *const r2FA7 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r2FA8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r2FA8);
                        ir_expression *const r2FA9 = expr(ir_unop_u2i, r2F66);
                        body.emit(assign(r2FA8, less(r2FA9, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2FAB = lequal(body.constant(int(2045)), r2F63);
                        ir_if *f2FAA = new(mem_ctx) ir_if(operand(r2FAB).val);
                        exec_list *const f2FAA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2FAA->then_instructions;

                           ir_variable *const r2FAC = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2FAE = less(body.constant(int(2045)), r2F63);
                           ir_if *f2FAD = new(mem_ctx) ir_if(operand(r2FAE).val);
                           exec_list *const f2FAD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FAD->then_instructions;

                              body.emit(assign(r2FAC, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FAD->else_instructions;

                              ir_variable *const r2FAF = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2FB1 = equal(r2F63, body.constant(int(2045)));
                              ir_if *f2FB0 = new(mem_ctx) ir_if(operand(r2FB1).val);
                              exec_list *const f2FB0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FB0->then_instructions;

                                 ir_expression *const r2FB2 = equal(body.constant(2097151u), r2F64);
                                 ir_expression *const r2FB3 = equal(body.constant(4294967295u), r2F65);
                                 body.emit(assign(r2FAF, logic_and(r2FB2, r2FB3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2FB0->else_instructions;

                                 body.emit(assign(r2FAF, body.constant(false), 0x01));


                              body.instructions = f2FB0_parent_instructions;
                              body.emit(f2FB0);

                              /* END IF */

                              body.emit(assign(r2FAC, logic_and(r2FAF, r2FA8), 0x01));


                           body.instructions = f2FAD_parent_instructions;
                           body.emit(f2FAD);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2FB4 = new(mem_ctx) ir_if(operand(r2FAC).val);
                           exec_list *const f2FB4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FB4->then_instructions;

                              ir_variable *const r2FB5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2FB5);
                              ir_expression *const r2FB6 = lshift(r2C5E, body.constant(int(31)));
                              body.emit(assign(r2FB5, add(r2FB6, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r2FB5, body.constant(0u), 0x01));

                              body.emit(assign(r2FA7, r2FB5, 0x03));

                              body.emit(assign(r2FA6, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FB4->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2FB8 = less(r2F63, body.constant(int(0)));
                              ir_if *f2FB7 = new(mem_ctx) ir_if(operand(r2FB8).val);
                              exec_list *const f2FB7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FB7->then_instructions;

                                 ir_variable *const r2FB9 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2FB9, r2F66, 0x01));

                                 ir_variable *const r2FBA = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2FBA, neg(r2F63), 0x01));

                                 ir_variable *const r2FBB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2FBB);
                                 ir_variable *const r2FBC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2FBC);
                                 ir_variable *const r2FBD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2FBD);
                                 ir_variable *const r2FBE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2FBF = neg(r2FBA);
                                 body.emit(assign(r2FBE, bit_and(r2FBF, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2FC1 = equal(r2FBA, body.constant(int(0)));
                                 ir_if *f2FC0 = new(mem_ctx) ir_if(operand(r2FC1).val);
                                 exec_list *const f2FC0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2FC0->then_instructions;

                                    body.emit(assign(r2FBB, r2F66, 0x01));

                                    body.emit(assign(r2FBC, r2F65, 0x01));

                                    body.emit(assign(r2FBD, r2F64, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2FC0->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2FC3 = less(r2FBA, body.constant(int(32)));
                                    ir_if *f2FC2 = new(mem_ctx) ir_if(operand(r2FC3).val);
                                    exec_list *const f2FC2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2FC2->then_instructions;

                                       body.emit(assign(r2FBB, lshift(r2F65, r2FBE), 0x01));

                                       ir_expression *const r2FC4 = lshift(r2F64, r2FBE);
                                       ir_expression *const r2FC5 = rshift(r2F65, r2FBA);
                                       body.emit(assign(r2FBC, bit_or(r2FC4, r2FC5), 0x01));

                                       body.emit(assign(r2FBD, rshift(r2F64, r2FBA), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2FC2->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2FC7 = equal(r2FBA, body.constant(int(32)));
                                       ir_if *f2FC6 = new(mem_ctx) ir_if(operand(r2FC7).val);
                                       exec_list *const f2FC6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2FC6->then_instructions;

                                          body.emit(assign(r2FBB, r2F65, 0x01));

                                          body.emit(assign(r2FBC, r2F64, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2FC6->else_instructions;

                                          body.emit(assign(r2FB9, bit_or(r2F66, r2F65), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2FC9 = less(r2FBA, body.constant(int(64)));
                                          ir_if *f2FC8 = new(mem_ctx) ir_if(operand(r2FC9).val);
                                          exec_list *const f2FC8_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2FC8->then_instructions;

                                             body.emit(assign(r2FBB, lshift(r2F64, r2FBE), 0x01));

                                             ir_expression *const r2FCA = bit_and(r2FBA, body.constant(int(31)));
                                             body.emit(assign(r2FBC, rshift(r2F64, r2FCA), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2FC8->else_instructions;

                                             ir_variable *const r2FCB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2FCD = equal(r2FBA, body.constant(int(64)));
                                             ir_if *f2FCC = new(mem_ctx) ir_if(operand(r2FCD).val);
                                             exec_list *const f2FCC_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2FCC->then_instructions;

                                                body.emit(assign(r2FCB, r2F64, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2FCC->else_instructions;

                                                ir_expression *const r2FCE = nequal(r2F64, body.constant(0u));
                                                ir_expression *const r2FCF = expr(ir_unop_b2i, r2FCE);
                                                body.emit(assign(r2FCB, expr(ir_unop_i2u, r2FCF), 0x01));


                                             body.instructions = f2FCC_parent_instructions;
                                             body.emit(f2FCC);

                                             /* END IF */

                                             body.emit(assign(r2FBB, r2FCB, 0x01));

                                             body.emit(assign(r2FBC, body.constant(0u), 0x01));


                                          body.instructions = f2FC8_parent_instructions;
                                          body.emit(f2FC8);

                                          /* END IF */


                                       body.instructions = f2FC6_parent_instructions;
                                       body.emit(f2FC6);

                                       /* END IF */

                                       body.emit(assign(r2FBD, body.constant(0u), 0x01));


                                    body.instructions = f2FC2_parent_instructions;
                                    body.emit(f2FC2);

                                    /* END IF */

                                    ir_expression *const r2FD0 = nequal(r2FB9, body.constant(0u));
                                    ir_expression *const r2FD1 = expr(ir_unop_b2i, r2FD0);
                                    ir_expression *const r2FD2 = expr(ir_unop_i2u, r2FD1);
                                    body.emit(assign(r2FBB, bit_or(r2FBB, r2FD2), 0x01));


                                 body.instructions = f2FC0_parent_instructions;
                                 body.emit(f2FC0);

                                 /* END IF */

                                 body.emit(assign(r2FA3, r2FBD, 0x01));

                                 body.emit(assign(r2FA4, r2FBC, 0x01));

                                 body.emit(assign(r2FA5, r2FBB, 0x01));

                                 body.emit(assign(r2FA2, body.constant(int(0)), 0x01));

                                 body.emit(assign(r2FA8, less(r2FBB, body.constant(0u)), 0x01));


                              body.instructions = f2FB7_parent_instructions;
                              body.emit(f2FB7);

                              /* END IF */


                           body.instructions = f2FB4_parent_instructions;
                           body.emit(f2FB4);

                           /* END IF */


                        body.instructions = f2FAA_parent_instructions;
                        body.emit(f2FAA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2FD3 = new(mem_ctx) ir_if(operand(r2FA6).val);
                        exec_list *const f2FD3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2FD3->then_instructions;

                           /* IF CONDITION */
                           ir_if *f2FD4 = new(mem_ctx) ir_if(operand(r2FA8).val);
                           exec_list *const f2FD4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FD4->then_instructions;

                              ir_variable *const r2FD5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r2FD5, add(r2FA4, body.constant(1u)), 0x01));

                              ir_expression *const r2FD6 = less(r2FD5, r2FA4);
                              ir_expression *const r2FD7 = expr(ir_unop_b2i, r2FD6);
                              ir_expression *const r2FD8 = expr(ir_unop_i2u, r2FD7);
                              body.emit(assign(r2FA3, add(r2FA3, r2FD8), 0x01));

                              ir_expression *const r2FD9 = equal(r2FA5, body.constant(0u));
                              ir_expression *const r2FDA = expr(ir_unop_b2i, r2FD9);
                              ir_expression *const r2FDB = expr(ir_unop_i2u, r2FDA);
                              ir_expression *const r2FDC = add(r2FA5, r2FDB);
                              ir_expression *const r2FDD = bit_and(r2FDC, body.constant(1u));
                              ir_expression *const r2FDE = expr(ir_unop_bit_not, r2FDD);
                              body.emit(assign(r2FA4, bit_and(r2FD5, r2FDE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FD4->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2FE0 = bit_or(r2FA3, r2FA4);
                              ir_expression *const r2FE1 = equal(r2FE0, body.constant(0u));
                              ir_if *f2FDF = new(mem_ctx) ir_if(operand(r2FE1).val);
                              exec_list *const f2FDF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FDF->then_instructions;

                                 body.emit(assign(r2FA2, body.constant(int(0)), 0x01));


                              body.instructions = f2FDF_parent_instructions;
                              body.emit(f2FDF);

                              /* END IF */


                           body.instructions = f2FD4_parent_instructions;
                           body.emit(f2FD4);

                           /* END IF */

                           ir_variable *const r2FE2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2FE2);
                           ir_expression *const r2FE3 = lshift(r2C5E, body.constant(int(31)));
                           ir_expression *const r2FE4 = expr(ir_unop_i2u, r2FA2);
                           ir_expression *const r2FE5 = lshift(r2FE4, body.constant(int(20)));
                           ir_expression *const r2FE6 = add(r2FE3, r2FE5);
                           body.emit(assign(r2FE2, add(r2FE6, r2FA3), 0x02));

                           body.emit(assign(r2FE2, r2FA4, 0x01));

                           body.emit(assign(r2FA7, r2FE2, 0x03));

                           body.emit(assign(r2FA6, body.constant(false), 0x01));


                        body.instructions = f2FD3_parent_instructions;
                        body.emit(f2FD3);

                        /* END IF */

                        body.emit(assign(r2C5F, r2FA7, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2F5B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2FE8 = less(r2C66, r2C64);
                        ir_if *f2FE7 = new(mem_ctx) ir_if(operand(r2FE8).val);
                        exec_list *const f2FE7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2FE7->then_instructions;

                           ir_variable *const r2FE9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r2FEA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2FEA, sub(r2C64, r2C66), 0x01));

                           ir_expression *const r2FEB = sub(r2C63, r2C65);
                           ir_expression *const r2FEC = less(r2C64, r2C66);
                           ir_expression *const r2FED = expr(ir_unop_b2i, r2FEC);
                           ir_expression *const r2FEE = expr(ir_unop_i2u, r2FED);
                           body.emit(assign(r2FE9, sub(r2FEB, r2FEE), 0x01));

                           body.emit(assign(r2C5E, bit_xor(r2C5E, body.constant(1u)), 0x01));

                           body.emit(assign(r2C67, add(r2C61, body.constant(int(-1))), 0x01));

                           ir_variable *const r2FEF = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2FEF, add(r2C67, body.constant(int(-10))), 0x01));

                           ir_variable *const r2FF0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2FF0, r2FE9, 0x01));

                           ir_variable *const r2FF1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2FF1, r2FEA, 0x01));

                           ir_variable *const r2FF2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r2FF2);
                           ir_variable *const r2FF3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2FF3);
                           /* IF CONDITION */
                           ir_expression *const r2FF5 = equal(r2FE9, body.constant(0u));
                           ir_if *f2FF4 = new(mem_ctx) ir_if(operand(r2FF5).val);
                           exec_list *const f2FF4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FF4->then_instructions;

                              body.emit(assign(r2FF0, r2FEA, 0x01));

                              body.emit(assign(r2FF1, body.constant(0u), 0x01));

                              body.emit(assign(r2FEF, add(r2FEF, body.constant(int(-32))), 0x01));


                           body.instructions = f2FF4_parent_instructions;
                           body.emit(f2FF4);

                           /* END IF */

                           ir_variable *const r2FF6 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r2FF6, r2FF0, 0x01));

                           ir_variable *const r2FF7 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r2FF8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2FF8);
                           /* IF CONDITION */
                           ir_expression *const r2FFA = equal(r2FF0, body.constant(0u));
                           ir_if *f2FF9 = new(mem_ctx) ir_if(operand(r2FFA).val);
                           exec_list *const f2FF9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FF9->then_instructions;

                              body.emit(assign(r2FF7, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FF9->else_instructions;

                              body.emit(assign(r2FF8, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2FFC = bit_and(r2FF0, body.constant(4294901760u));
                              ir_expression *const r2FFD = equal(r2FFC, body.constant(0u));
                              ir_if *f2FFB = new(mem_ctx) ir_if(operand(r2FFD).val);
                              exec_list *const f2FFB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FFB->then_instructions;

                                 body.emit(assign(r2FF8, body.constant(int(16)), 0x01));

                                 body.emit(assign(r2FF6, lshift(r2FF0, body.constant(int(16))), 0x01));


                              body.instructions = f2FFB_parent_instructions;
                              body.emit(f2FFB);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2FFF = bit_and(r2FF6, body.constant(4278190080u));
                              ir_expression *const r3000 = equal(r2FFF, body.constant(0u));
                              ir_if *f2FFE = new(mem_ctx) ir_if(operand(r3000).val);
                              exec_list *const f2FFE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FFE->then_instructions;

                                 body.emit(assign(r2FF8, add(r2FF8, body.constant(int(8))), 0x01));

                                 body.emit(assign(r2FF6, lshift(r2FF6, body.constant(int(8))), 0x01));


                              body.instructions = f2FFE_parent_instructions;
                              body.emit(f2FFE);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3002 = bit_and(r2FF6, body.constant(4026531840u));
                              ir_expression *const r3003 = equal(r3002, body.constant(0u));
                              ir_if *f3001 = new(mem_ctx) ir_if(operand(r3003).val);
                              exec_list *const f3001_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3001->then_instructions;

                                 body.emit(assign(r2FF8, add(r2FF8, body.constant(int(4))), 0x01));

                                 body.emit(assign(r2FF6, lshift(r2FF6, body.constant(int(4))), 0x01));


                              body.instructions = f3001_parent_instructions;
                              body.emit(f3001);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3005 = bit_and(r2FF6, body.constant(3221225472u));
                              ir_expression *const r3006 = equal(r3005, body.constant(0u));
                              ir_if *f3004 = new(mem_ctx) ir_if(operand(r3006).val);
                              exec_list *const f3004_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3004->then_instructions;

                                 body.emit(assign(r2FF8, add(r2FF8, body.constant(int(2))), 0x01));

                                 body.emit(assign(r2FF6, lshift(r2FF6, body.constant(int(2))), 0x01));


                              body.instructions = f3004_parent_instructions;
                              body.emit(f3004);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3008 = bit_and(r2FF6, body.constant(2147483648u));
                              ir_expression *const r3009 = equal(r3008, body.constant(0u));
                              ir_if *f3007 = new(mem_ctx) ir_if(operand(r3009).val);
                              exec_list *const f3007_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3007->then_instructions;

                                 body.emit(assign(r2FF8, add(r2FF8, body.constant(int(1))), 0x01));


                              body.instructions = f3007_parent_instructions;
                              body.emit(f3007);

                              /* END IF */

                              body.emit(assign(r2FF7, r2FF8, 0x01));


                           body.instructions = f2FF9_parent_instructions;
                           body.emit(f2FF9);

                           /* END IF */

                           body.emit(assign(r2FF3, add(r2FF7, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r300B = lequal(body.constant(int(0)), r2FF3);
                           ir_if *f300A = new(mem_ctx) ir_if(operand(r300B).val);
                           exec_list *const f300A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f300A->then_instructions;

                              body.emit(assign(r2FF2, body.constant(0u), 0x01));

                              ir_variable *const r300C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r300C, lshift(r2FF1, r2FF3), 0x01));

                              ir_variable *const r300D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r300F = equal(r2FF3, body.constant(int(0)));
                              ir_if *f300E = new(mem_ctx) ir_if(operand(r300F).val);
                              exec_list *const f300E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f300E->then_instructions;

                                 body.emit(assign(r300D, r2FF0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f300E->else_instructions;

                                 ir_expression *const r3010 = lshift(r2FF0, r2FF3);
                                 ir_expression *const r3011 = neg(r2FF3);
                                 ir_expression *const r3012 = bit_and(r3011, body.constant(int(31)));
                                 ir_expression *const r3013 = rshift(r2FF1, r3012);
                                 body.emit(assign(r300D, bit_or(r3010, r3013), 0x01));


                              body.instructions = f300E_parent_instructions;
                              body.emit(f300E);

                              /* END IF */

                              body.emit(assign(r2FF0, r300D, 0x01));

                              body.emit(assign(r2FF1, r300C, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f300A->else_instructions;

                              ir_variable *const r3014 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3014, body.constant(0u), 0x01));

                              ir_variable *const r3015 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3015, neg(r2FF3), 0x01));

                              ir_variable *const r3016 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3016);
                              ir_variable *const r3017 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3017);
                              ir_variable *const r3018 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3018);
                              ir_variable *const r3019 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r301A = neg(r3015);
                              body.emit(assign(r3019, bit_and(r301A, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r301C = equal(r3015, body.constant(int(0)));
                              ir_if *f301B = new(mem_ctx) ir_if(operand(r301C).val);
                              exec_list *const f301B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f301B->then_instructions;

                                 body.emit(assign(r3016, r3014, 0x01));

                                 body.emit(assign(r3017, r2FF1, 0x01));

                                 body.emit(assign(r3018, r2FF0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f301B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r301E = less(r3015, body.constant(int(32)));
                                 ir_if *f301D = new(mem_ctx) ir_if(operand(r301E).val);
                                 exec_list *const f301D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f301D->then_instructions;

                                    body.emit(assign(r3016, lshift(r2FF1, r3019), 0x01));

                                    ir_expression *const r301F = lshift(r2FF0, r3019);
                                    ir_expression *const r3020 = rshift(r2FF1, r3015);
                                    body.emit(assign(r3017, bit_or(r301F, r3020), 0x01));

                                    body.emit(assign(r3018, rshift(r2FF0, r3015), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f301D->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3022 = equal(r3015, body.constant(int(32)));
                                    ir_if *f3021 = new(mem_ctx) ir_if(operand(r3022).val);
                                    exec_list *const f3021_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3021->then_instructions;

                                       body.emit(assign(r3016, r2FF1, 0x01));

                                       body.emit(assign(r3017, r2FF0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3021->else_instructions;

                                       body.emit(assign(r3014, bit_or(body.constant(0u), r2FF1), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3024 = less(r3015, body.constant(int(64)));
                                       ir_if *f3023 = new(mem_ctx) ir_if(operand(r3024).val);
                                       exec_list *const f3023_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3023->then_instructions;

                                          body.emit(assign(r3016, lshift(r2FF0, r3019), 0x01));

                                          ir_expression *const r3025 = bit_and(r3015, body.constant(int(31)));
                                          body.emit(assign(r3017, rshift(r2FF0, r3025), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3023->else_instructions;

                                          ir_variable *const r3026 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3028 = equal(r3015, body.constant(int(64)));
                                          ir_if *f3027 = new(mem_ctx) ir_if(operand(r3028).val);
                                          exec_list *const f3027_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3027->then_instructions;

                                             body.emit(assign(r3026, r2FF0, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3027->else_instructions;

                                             ir_expression *const r3029 = nequal(r2FF0, body.constant(0u));
                                             ir_expression *const r302A = expr(ir_unop_b2i, r3029);
                                             body.emit(assign(r3026, expr(ir_unop_i2u, r302A), 0x01));


                                          body.instructions = f3027_parent_instructions;
                                          body.emit(f3027);

                                          /* END IF */

                                          body.emit(assign(r3016, r3026, 0x01));

                                          body.emit(assign(r3017, body.constant(0u), 0x01));


                                       body.instructions = f3023_parent_instructions;
                                       body.emit(f3023);

                                       /* END IF */


                                    body.instructions = f3021_parent_instructions;
                                    body.emit(f3021);

                                    /* END IF */

                                    body.emit(assign(r3018, body.constant(0u), 0x01));


                                 body.instructions = f301D_parent_instructions;
                                 body.emit(f301D);

                                 /* END IF */

                                 ir_expression *const r302B = nequal(r3014, body.constant(0u));
                                 ir_expression *const r302C = expr(ir_unop_b2i, r302B);
                                 ir_expression *const r302D = expr(ir_unop_i2u, r302C);
                                 body.emit(assign(r3016, bit_or(r3016, r302D), 0x01));


                              body.instructions = f301B_parent_instructions;
                              body.emit(f301B);

                              /* END IF */

                              body.emit(assign(r2FF0, r3018, 0x01));

                              body.emit(assign(r2FF1, r3017, 0x01));

                              body.emit(assign(r2FF2, r3016, 0x01));


                           body.instructions = f300A_parent_instructions;
                           body.emit(f300A);

                           /* END IF */

                           body.emit(assign(r2FEF, sub(r2FEF, r2FF3), 0x01));

                           ir_variable *const r302E = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r302E, r2FEF, 0x01));

                           ir_variable *const r302F = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r302F, r2FF0, 0x01));

                           ir_variable *const r3030 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3030, r2FF1, 0x01));

                           ir_variable *const r3031 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r3031, r2FF2, 0x01));

                           ir_variable *const r3032 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r3032, body.constant(true), 0x01));

                           ir_variable *const r3033 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r3034 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r3034);
                           ir_expression *const r3035 = expr(ir_unop_u2i, r2FF2);
                           body.emit(assign(r3034, less(r3035, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3037 = lequal(body.constant(int(2045)), r2FEF);
                           ir_if *f3036 = new(mem_ctx) ir_if(operand(r3037).val);
                           exec_list *const f3036_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3036->then_instructions;

                              ir_variable *const r3038 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r303A = less(body.constant(int(2045)), r2FEF);
                              ir_if *f3039 = new(mem_ctx) ir_if(operand(r303A).val);
                              exec_list *const f3039_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3039->then_instructions;

                                 body.emit(assign(r3038, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3039->else_instructions;

                                 ir_variable *const r303B = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r303D = equal(r2FEF, body.constant(int(2045)));
                                 ir_if *f303C = new(mem_ctx) ir_if(operand(r303D).val);
                                 exec_list *const f303C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f303C->then_instructions;

                                    ir_expression *const r303E = equal(body.constant(2097151u), r2FF0);
                                    ir_expression *const r303F = equal(body.constant(4294967295u), r2FF1);
                                    body.emit(assign(r303B, logic_and(r303E, r303F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f303C->else_instructions;

                                    body.emit(assign(r303B, body.constant(false), 0x01));


                                 body.instructions = f303C_parent_instructions;
                                 body.emit(f303C);

                                 /* END IF */

                                 body.emit(assign(r3038, logic_and(r303B, r3034), 0x01));


                              body.instructions = f3039_parent_instructions;
                              body.emit(f3039);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f3040 = new(mem_ctx) ir_if(operand(r3038).val);
                              exec_list *const f3040_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3040->then_instructions;

                                 ir_variable *const r3041 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r3041);
                                 ir_expression *const r3042 = lshift(r2C5E, body.constant(int(31)));
                                 body.emit(assign(r3041, add(r3042, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r3041, body.constant(0u), 0x01));

                                 body.emit(assign(r3033, r3041, 0x03));

                                 body.emit(assign(r3032, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3040->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3044 = less(r2FEF, body.constant(int(0)));
                                 ir_if *f3043 = new(mem_ctx) ir_if(operand(r3044).val);
                                 exec_list *const f3043_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3043->then_instructions;

                                    ir_variable *const r3045 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r3045, r2FF2, 0x01));

                                    ir_variable *const r3046 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r3046, neg(r2FEF), 0x01));

                                    ir_variable *const r3047 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r3047);
                                    ir_variable *const r3048 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r3048);
                                    ir_variable *const r3049 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r3049);
                                    ir_variable *const r304A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r304B = neg(r3046);
                                    body.emit(assign(r304A, bit_and(r304B, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r304D = equal(r3046, body.constant(int(0)));
                                    ir_if *f304C = new(mem_ctx) ir_if(operand(r304D).val);
                                    exec_list *const f304C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f304C->then_instructions;

                                       body.emit(assign(r3047, r2FF2, 0x01));

                                       body.emit(assign(r3048, r2FF1, 0x01));

                                       body.emit(assign(r3049, r2FF0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f304C->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r304F = less(r3046, body.constant(int(32)));
                                       ir_if *f304E = new(mem_ctx) ir_if(operand(r304F).val);
                                       exec_list *const f304E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f304E->then_instructions;

                                          body.emit(assign(r3047, lshift(r2FF1, r304A), 0x01));

                                          ir_expression *const r3050 = lshift(r2FF0, r304A);
                                          ir_expression *const r3051 = rshift(r2FF1, r3046);
                                          body.emit(assign(r3048, bit_or(r3050, r3051), 0x01));

                                          body.emit(assign(r3049, rshift(r2FF0, r3046), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f304E->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r3053 = equal(r3046, body.constant(int(32)));
                                          ir_if *f3052 = new(mem_ctx) ir_if(operand(r3053).val);
                                          exec_list *const f3052_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3052->then_instructions;

                                             body.emit(assign(r3047, r2FF1, 0x01));

                                             body.emit(assign(r3048, r2FF0, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3052->else_instructions;

                                             body.emit(assign(r3045, bit_or(r2FF2, r2FF1), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r3055 = less(r3046, body.constant(int(64)));
                                             ir_if *f3054 = new(mem_ctx) ir_if(operand(r3055).val);
                                             exec_list *const f3054_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3054->then_instructions;

                                                body.emit(assign(r3047, lshift(r2FF0, r304A), 0x01));

                                                ir_expression *const r3056 = bit_and(r3046, body.constant(int(31)));
                                                body.emit(assign(r3048, rshift(r2FF0, r3056), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3054->else_instructions;

                                                ir_variable *const r3057 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r3059 = equal(r3046, body.constant(int(64)));
                                                ir_if *f3058 = new(mem_ctx) ir_if(operand(r3059).val);
                                                exec_list *const f3058_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3058->then_instructions;

                                                   body.emit(assign(r3057, r2FF0, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3058->else_instructions;

                                                   ir_expression *const r305A = nequal(r2FF0, body.constant(0u));
                                                   ir_expression *const r305B = expr(ir_unop_b2i, r305A);
                                                   body.emit(assign(r3057, expr(ir_unop_i2u, r305B), 0x01));


                                                body.instructions = f3058_parent_instructions;
                                                body.emit(f3058);

                                                /* END IF */

                                                body.emit(assign(r3047, r3057, 0x01));

                                                body.emit(assign(r3048, body.constant(0u), 0x01));


                                             body.instructions = f3054_parent_instructions;
                                             body.emit(f3054);

                                             /* END IF */


                                          body.instructions = f3052_parent_instructions;
                                          body.emit(f3052);

                                          /* END IF */

                                          body.emit(assign(r3049, body.constant(0u), 0x01));


                                       body.instructions = f304E_parent_instructions;
                                       body.emit(f304E);

                                       /* END IF */

                                       ir_expression *const r305C = nequal(r3045, body.constant(0u));
                                       ir_expression *const r305D = expr(ir_unop_b2i, r305C);
                                       ir_expression *const r305E = expr(ir_unop_i2u, r305D);
                                       body.emit(assign(r3047, bit_or(r3047, r305E), 0x01));


                                    body.instructions = f304C_parent_instructions;
                                    body.emit(f304C);

                                    /* END IF */

                                    body.emit(assign(r302F, r3049, 0x01));

                                    body.emit(assign(r3030, r3048, 0x01));

                                    body.emit(assign(r3031, r3047, 0x01));

                                    body.emit(assign(r302E, body.constant(int(0)), 0x01));

                                    body.emit(assign(r3034, less(r3047, body.constant(0u)), 0x01));


                                 body.instructions = f3043_parent_instructions;
                                 body.emit(f3043);

                                 /* END IF */


                              body.instructions = f3040_parent_instructions;
                              body.emit(f3040);

                              /* END IF */


                           body.instructions = f3036_parent_instructions;
                           body.emit(f3036);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f305F = new(mem_ctx) ir_if(operand(r3032).val);
                           exec_list *const f305F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f305F->then_instructions;

                              /* IF CONDITION */
                              ir_if *f3060 = new(mem_ctx) ir_if(operand(r3034).val);
                              exec_list *const f3060_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3060->then_instructions;

                                 ir_variable *const r3061 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r3061, add(r3030, body.constant(1u)), 0x01));

                                 ir_expression *const r3062 = less(r3061, r3030);
                                 ir_expression *const r3063 = expr(ir_unop_b2i, r3062);
                                 ir_expression *const r3064 = expr(ir_unop_i2u, r3063);
                                 body.emit(assign(r302F, add(r302F, r3064), 0x01));

                                 ir_expression *const r3065 = equal(r3031, body.constant(0u));
                                 ir_expression *const r3066 = expr(ir_unop_b2i, r3065);
                                 ir_expression *const r3067 = expr(ir_unop_i2u, r3066);
                                 ir_expression *const r3068 = add(r3031, r3067);
                                 ir_expression *const r3069 = bit_and(r3068, body.constant(1u));
                                 ir_expression *const r306A = expr(ir_unop_bit_not, r3069);
                                 body.emit(assign(r3030, bit_and(r3061, r306A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3060->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r306C = bit_or(r302F, r3030);
                                 ir_expression *const r306D = equal(r306C, body.constant(0u));
                                 ir_if *f306B = new(mem_ctx) ir_if(operand(r306D).val);
                                 exec_list *const f306B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f306B->then_instructions;

                                    body.emit(assign(r302E, body.constant(int(0)), 0x01));


                                 body.instructions = f306B_parent_instructions;
                                 body.emit(f306B);

                                 /* END IF */


                              body.instructions = f3060_parent_instructions;
                              body.emit(f3060);

                              /* END IF */

                              ir_variable *const r306E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r306E);
                              ir_expression *const r306F = lshift(r2C5E, body.constant(int(31)));
                              ir_expression *const r3070 = expr(ir_unop_i2u, r302E);
                              ir_expression *const r3071 = lshift(r3070, body.constant(int(20)));
                              ir_expression *const r3072 = add(r306F, r3071);
                              body.emit(assign(r306E, add(r3072, r302F), 0x02));

                              body.emit(assign(r306E, r3030, 0x01));

                              body.emit(assign(r3033, r306E, 0x03));

                              body.emit(assign(r3032, body.constant(false), 0x01));


                           body.instructions = f305F_parent_instructions;
                           body.emit(f305F);

                           /* END IF */

                           body.emit(assign(r2C5F, r3033, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2FE7->else_instructions;

                           ir_variable *const r3073 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3073);
                           body.emit(assign(r3073, body.constant(0u), 0x02));

                           body.emit(assign(r3073, body.constant(0u), 0x01));

                           body.emit(assign(r2C5F, r3073, 0x03));


                        body.instructions = f2FE7_parent_instructions;
                        body.emit(f2FE7);

                        /* END IF */


                     body.instructions = f2F5B_parent_instructions;
                     body.emit(f2F5B);

                     /* END IF */


                  body.instructions = f2ECF_parent_instructions;
                  body.emit(f2ECF);

                  /* END IF */


               body.instructions = f2E43_parent_instructions;
               body.emit(f2E43);

               /* END IF */


            body.instructions = f2E1C_parent_instructions;
            body.emit(f2E1C);

            /* END IF */


         body.instructions = f2D48_parent_instructions;
         body.emit(f2D48);

         /* END IF */


      body.instructions = f2C78_parent_instructions;
      body.emit(f2C78);

      /* END IF */

      body.emit(assign(r2C59, r2C5F, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2C5C->else_instructions;

      ir_variable *const r3074 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r3074, body.constant(true), 0x01));

      ir_variable *const r3075 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3076 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r3076);
      ir_variable *const r3077 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r3077);
      ir_variable *const r3078 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r3078);
      ir_variable *const r3079 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r3079);
      ir_variable *const r307A = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r307A);
      ir_variable *const r307B = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r307B);
      ir_variable *const r307C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r307C);
      ir_variable *const r307D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r307D);
      body.emit(assign(r307D, body.constant(0u), 0x01));

      body.emit(assign(r307C, body.constant(0u), 0x01));

      ir_variable *const r307E = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r307E, swizzle_x(r270B), 0x01));

      body.emit(assign(r307A, r307E, 0x01));

      ir_variable *const r307F = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r307F, bit_and(swizzle_y(r270B), body.constant(1048575u)), 0x01));

      body.emit(assign(r3079, r307F, 0x01));

      ir_variable *const r3080 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r3080, swizzle_x(r273F), 0x01));

      body.emit(assign(r3078, r3080, 0x01));

      ir_variable *const r3081 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r3081, bit_and(swizzle_y(r273F), body.constant(1048575u)), 0x01));

      body.emit(assign(r3077, r3081, 0x01));

      ir_variable *const r3082 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3083 = rshift(swizzle_y(r270B), body.constant(int(20)));
      ir_expression *const r3084 = bit_and(r3083, body.constant(2047u));
      body.emit(assign(r3082, expr(ir_unop_u2i, r3084), 0x01));

      ir_variable *const r3085 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3086 = rshift(swizzle_y(r273F), body.constant(int(20)));
      ir_expression *const r3087 = bit_and(r3086, body.constant(2047u));
      body.emit(assign(r3085, expr(ir_unop_u2i, r3087), 0x01));

      ir_variable *const r3088 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r3088, sub(r3082, r3085), 0x01));

      body.emit(assign(r3076, r3088, 0x01));

      /* IF CONDITION */
      ir_expression *const r308A = less(body.constant(int(0)), r3088);
      ir_if *f3089 = new(mem_ctx) ir_if(operand(r308A).val);
      exec_list *const f3089_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3089->then_instructions;

         /* IF CONDITION */
         ir_expression *const r308C = equal(r3082, body.constant(int(2047)));
         ir_if *f308B = new(mem_ctx) ir_if(operand(r308C).val);
         exec_list *const f308B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f308B->then_instructions;

            /* IF CONDITION */
            ir_expression *const r308E = bit_or(r307F, swizzle_x(r270B));
            ir_expression *const r308F = nequal(r308E, body.constant(0u));
            ir_if *f308D = new(mem_ctx) ir_if(operand(r308F).val);
            exec_list *const f308D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f308D->then_instructions;

               ir_variable *const r3090 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r3090, swizzle_x(r270B), 0x01));

               ir_variable *const r3091 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r3091, swizzle_x(r273F), 0x01));

               ir_variable *const r3092 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3093 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3094 = rshift(swizzle_y(r270B), body.constant(int(19)));
               ir_expression *const r3095 = bit_and(r3094, body.constant(4095u));
               ir_expression *const r3096 = equal(r3095, body.constant(4094u));
               ir_expression *const r3097 = nequal(swizzle_x(r270B), body.constant(0u));
               ir_expression *const r3098 = bit_and(swizzle_y(r270B), body.constant(524287u));
               ir_expression *const r3099 = nequal(r3098, body.constant(0u));
               ir_expression *const r309A = logic_or(r3097, r3099);
               body.emit(assign(r3093, logic_and(r3096, r309A), 0x01));

               ir_variable *const r309B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r309C = lshift(swizzle_y(r273F), body.constant(int(1)));
               ir_expression *const r309D = lequal(body.constant(4292870144u), r309C);
               ir_expression *const r309E = nequal(swizzle_x(r273F), body.constant(0u));
               ir_expression *const r309F = bit_and(swizzle_y(r273F), body.constant(1048575u));
               ir_expression *const r30A0 = nequal(r309F, body.constant(0u));
               ir_expression *const r30A1 = logic_or(r309E, r30A0);
               body.emit(assign(r309B, logic_and(r309D, r30A1), 0x01));

               body.emit(assign(r3090, bit_or(swizzle_y(r270B), body.constant(524288u)), 0x02));

               body.emit(assign(r3091, bit_or(swizzle_y(r273F), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r30A3 = lshift(swizzle_y(r270B), body.constant(int(1)));
               ir_expression *const r30A4 = lequal(body.constant(4292870144u), r30A3);
               ir_expression *const r30A5 = nequal(swizzle_x(r270B), body.constant(0u));
               ir_expression *const r30A6 = bit_and(swizzle_y(r270B), body.constant(1048575u));
               ir_expression *const r30A7 = nequal(r30A6, body.constant(0u));
               ir_expression *const r30A8 = logic_or(r30A5, r30A7);
               ir_expression *const r30A9 = logic_and(r30A4, r30A8);
               ir_if *f30A2 = new(mem_ctx) ir_if(operand(r30A9).val);
               exec_list *const f30A2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f30A2->then_instructions;

                  ir_variable *const r30AA = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r30AC = logic_and(r3093, r309B);
                  ir_if *f30AB = new(mem_ctx) ir_if(operand(r30AC).val);
                  exec_list *const f30AB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f30AB->then_instructions;

                     body.emit(assign(r30AA, r3091, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f30AB->else_instructions;

                     body.emit(assign(r30AA, r3090, 0x03));


                  body.instructions = f30AB_parent_instructions;
                  body.emit(f30AB);

                  /* END IF */

                  body.emit(assign(r3092, r30AA, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f30A2->else_instructions;

                  body.emit(assign(r3092, r3091, 0x03));


               body.instructions = f30A2_parent_instructions;
               body.emit(f30A2);

               /* END IF */

               body.emit(assign(r3075, r3092, 0x03));

               body.emit(assign(r3074, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f308D->else_instructions;

               body.emit(assign(r3075, r270B, 0x03));

               body.emit(assign(r3074, body.constant(false), 0x01));


            body.instructions = f308D_parent_instructions;
            body.emit(f308D);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f308B->else_instructions;

            /* IF CONDITION */
            ir_expression *const r30AE = equal(r3085, body.constant(int(0)));
            ir_if *f30AD = new(mem_ctx) ir_if(operand(r30AE).val);
            exec_list *const f30AD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f30AD->then_instructions;

               body.emit(assign(r3076, add(r3088, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f30AD->else_instructions;

               body.emit(assign(r3077, bit_or(r3081, body.constant(1048576u)), 0x01));


            body.instructions = f30AD_parent_instructions;
            body.emit(f30AD);

            /* END IF */

            ir_variable *const r30AF = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r30AF, body.constant(0u), 0x01));

            ir_variable *const r30B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r30B0);
            ir_variable *const r30B1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r30B1);
            ir_variable *const r30B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r30B2);
            ir_variable *const r30B3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r30B4 = neg(r3076);
            body.emit(assign(r30B3, bit_and(r30B4, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r30B6 = equal(r3076, body.constant(int(0)));
            ir_if *f30B5 = new(mem_ctx) ir_if(operand(r30B6).val);
            exec_list *const f30B5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f30B5->then_instructions;

               body.emit(assign(r30B0, r30AF, 0x01));

               body.emit(assign(r30B1, r3080, 0x01));

               body.emit(assign(r30B2, r3077, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f30B5->else_instructions;

               /* IF CONDITION */
               ir_expression *const r30B8 = less(r3076, body.constant(int(32)));
               ir_if *f30B7 = new(mem_ctx) ir_if(operand(r30B8).val);
               exec_list *const f30B7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f30B7->then_instructions;

                  body.emit(assign(r30B0, lshift(swizzle_x(r273F), r30B3), 0x01));

                  ir_expression *const r30B9 = lshift(r3077, r30B3);
                  ir_expression *const r30BA = rshift(swizzle_x(r273F), r3076);
                  body.emit(assign(r30B1, bit_or(r30B9, r30BA), 0x01));

                  body.emit(assign(r30B2, rshift(r3077, r3076), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f30B7->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r30BC = equal(r3076, body.constant(int(32)));
                  ir_if *f30BB = new(mem_ctx) ir_if(operand(r30BC).val);
                  exec_list *const f30BB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f30BB->then_instructions;

                     body.emit(assign(r30B0, r3080, 0x01));

                     body.emit(assign(r30B1, r3077, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f30BB->else_instructions;

                     body.emit(assign(r30AF, bit_or(body.constant(0u), swizzle_x(r273F)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r30BE = less(r3076, body.constant(int(64)));
                     ir_if *f30BD = new(mem_ctx) ir_if(operand(r30BE).val);
                     exec_list *const f30BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30BD->then_instructions;

                        body.emit(assign(r30B0, lshift(r3077, r30B3), 0x01));

                        ir_expression *const r30BF = bit_and(r3076, body.constant(int(31)));
                        body.emit(assign(r30B1, rshift(r3077, r30BF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f30BD->else_instructions;

                        ir_variable *const r30C0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r30C2 = equal(r3076, body.constant(int(64)));
                        ir_if *f30C1 = new(mem_ctx) ir_if(operand(r30C2).val);
                        exec_list *const f30C1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30C1->then_instructions;

                           body.emit(assign(r30C0, r3077, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30C1->else_instructions;

                           ir_expression *const r30C3 = nequal(r3077, body.constant(0u));
                           ir_expression *const r30C4 = expr(ir_unop_b2i, r30C3);
                           body.emit(assign(r30C0, expr(ir_unop_i2u, r30C4), 0x01));


                        body.instructions = f30C1_parent_instructions;
                        body.emit(f30C1);

                        /* END IF */

                        body.emit(assign(r30B0, r30C0, 0x01));

                        body.emit(assign(r30B1, body.constant(0u), 0x01));


                     body.instructions = f30BD_parent_instructions;
                     body.emit(f30BD);

                     /* END IF */


                  body.instructions = f30BB_parent_instructions;
                  body.emit(f30BB);

                  /* END IF */

                  body.emit(assign(r30B2, body.constant(0u), 0x01));


               body.instructions = f30B7_parent_instructions;
               body.emit(f30B7);

               /* END IF */

               ir_expression *const r30C5 = nequal(r30AF, body.constant(0u));
               ir_expression *const r30C6 = expr(ir_unop_b2i, r30C5);
               ir_expression *const r30C7 = expr(ir_unop_i2u, r30C6);
               body.emit(assign(r30B0, bit_or(r30B0, r30C7), 0x01));


            body.instructions = f30B5_parent_instructions;
            body.emit(f30B5);

            /* END IF */

            body.emit(assign(r3077, r30B2, 0x01));

            body.emit(assign(r3078, r30B1, 0x01));

            body.emit(assign(r307C, r30B0, 0x01));

            body.emit(assign(r307B, r3082, 0x01));


         body.instructions = f308B_parent_instructions;
         body.emit(f308B);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3089->else_instructions;

         /* IF CONDITION */
         ir_expression *const r30C9 = less(r3076, body.constant(int(0)));
         ir_if *f30C8 = new(mem_ctx) ir_if(operand(r30C9).val);
         exec_list *const f30C8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f30C8->then_instructions;

            /* IF CONDITION */
            ir_expression *const r30CB = equal(r3085, body.constant(int(2047)));
            ir_if *f30CA = new(mem_ctx) ir_if(operand(r30CB).val);
            exec_list *const f30CA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f30CA->then_instructions;

               /* IF CONDITION */
               ir_expression *const r30CD = bit_or(r3077, r3078);
               ir_expression *const r30CE = nequal(r30CD, body.constant(0u));
               ir_if *f30CC = new(mem_ctx) ir_if(operand(r30CE).val);
               exec_list *const f30CC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f30CC->then_instructions;

                  ir_variable *const r30CF = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r30CF, swizzle_x(r270B), 0x01));

                  ir_variable *const r30D0 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r30D0, swizzle_x(r273F), 0x01));

                  ir_variable *const r30D1 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r30D2 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r30D3 = rshift(swizzle_y(r270B), body.constant(int(19)));
                  ir_expression *const r30D4 = bit_and(r30D3, body.constant(4095u));
                  ir_expression *const r30D5 = equal(r30D4, body.constant(4094u));
                  ir_expression *const r30D6 = nequal(swizzle_x(r270B), body.constant(0u));
                  ir_expression *const r30D7 = bit_and(swizzle_y(r270B), body.constant(524287u));
                  ir_expression *const r30D8 = nequal(r30D7, body.constant(0u));
                  ir_expression *const r30D9 = logic_or(r30D6, r30D8);
                  body.emit(assign(r30D2, logic_and(r30D5, r30D9), 0x01));

                  ir_variable *const r30DA = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r30DB = lshift(swizzle_y(r273F), body.constant(int(1)));
                  ir_expression *const r30DC = lequal(body.constant(4292870144u), r30DB);
                  ir_expression *const r30DD = nequal(swizzle_x(r273F), body.constant(0u));
                  ir_expression *const r30DE = bit_and(swizzle_y(r273F), body.constant(1048575u));
                  ir_expression *const r30DF = nequal(r30DE, body.constant(0u));
                  ir_expression *const r30E0 = logic_or(r30DD, r30DF);
                  body.emit(assign(r30DA, logic_and(r30DC, r30E0), 0x01));

                  body.emit(assign(r30CF, bit_or(swizzle_y(r270B), body.constant(524288u)), 0x02));

                  body.emit(assign(r30D0, bit_or(swizzle_y(r273F), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r30E2 = lshift(swizzle_y(r270B), body.constant(int(1)));
                  ir_expression *const r30E3 = lequal(body.constant(4292870144u), r30E2);
                  ir_expression *const r30E4 = nequal(swizzle_x(r270B), body.constant(0u));
                  ir_expression *const r30E5 = bit_and(swizzle_y(r270B), body.constant(1048575u));
                  ir_expression *const r30E6 = nequal(r30E5, body.constant(0u));
                  ir_expression *const r30E7 = logic_or(r30E4, r30E6);
                  ir_expression *const r30E8 = logic_and(r30E3, r30E7);
                  ir_if *f30E1 = new(mem_ctx) ir_if(operand(r30E8).val);
                  exec_list *const f30E1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f30E1->then_instructions;

                     ir_variable *const r30E9 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r30EB = logic_and(r30D2, r30DA);
                     ir_if *f30EA = new(mem_ctx) ir_if(operand(r30EB).val);
                     exec_list *const f30EA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30EA->then_instructions;

                        body.emit(assign(r30E9, r30D0, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f30EA->else_instructions;

                        body.emit(assign(r30E9, r30CF, 0x03));


                     body.instructions = f30EA_parent_instructions;
                     body.emit(f30EA);

                     /* END IF */

                     body.emit(assign(r30D1, r30E9, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f30E1->else_instructions;

                     body.emit(assign(r30D1, r30D0, 0x03));


                  body.instructions = f30E1_parent_instructions;
                  body.emit(f30E1);

                  /* END IF */

                  body.emit(assign(r3075, r30D1, 0x03));

                  body.emit(assign(r3074, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f30CC->else_instructions;

                  ir_variable *const r30EC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r30EC);
                  ir_expression *const r30ED = lshift(r2C5A, body.constant(int(31)));
                  body.emit(assign(r30EC, add(r30ED, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r30EC, body.constant(0u), 0x01));

                  body.emit(assign(r3075, r30EC, 0x03));

                  body.emit(assign(r3074, body.constant(false), 0x01));


               body.instructions = f30CC_parent_instructions;
               body.emit(f30CC);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f30CA->else_instructions;

               /* IF CONDITION */
               ir_expression *const r30EF = equal(r3082, body.constant(int(0)));
               ir_if *f30EE = new(mem_ctx) ir_if(operand(r30EF).val);
               exec_list *const f30EE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f30EE->then_instructions;

                  body.emit(assign(r3076, add(r3076, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f30EE->else_instructions;

                  body.emit(assign(r3079, bit_or(r307F, body.constant(1048576u)), 0x01));


               body.instructions = f30EE_parent_instructions;
               body.emit(f30EE);

               /* END IF */

               ir_variable *const r30F0 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r30F0, body.constant(0u), 0x01));

               ir_variable *const r30F1 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r30F1, neg(r3076), 0x01));

               ir_variable *const r30F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r30F2);
               ir_variable *const r30F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r30F3);
               ir_variable *const r30F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r30F4);
               ir_variable *const r30F5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r30F6 = neg(r30F1);
               body.emit(assign(r30F5, bit_and(r30F6, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r30F8 = equal(r30F1, body.constant(int(0)));
               ir_if *f30F7 = new(mem_ctx) ir_if(operand(r30F8).val);
               exec_list *const f30F7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f30F7->then_instructions;

                  body.emit(assign(r30F2, r30F0, 0x01));

                  body.emit(assign(r30F3, r307E, 0x01));

                  body.emit(assign(r30F4, r3079, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f30F7->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r30FA = less(r30F1, body.constant(int(32)));
                  ir_if *f30F9 = new(mem_ctx) ir_if(operand(r30FA).val);
                  exec_list *const f30F9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f30F9->then_instructions;

                     body.emit(assign(r30F2, lshift(swizzle_x(r270B), r30F5), 0x01));

                     ir_expression *const r30FB = lshift(r3079, r30F5);
                     ir_expression *const r30FC = rshift(swizzle_x(r270B), r30F1);
                     body.emit(assign(r30F3, bit_or(r30FB, r30FC), 0x01));

                     body.emit(assign(r30F4, rshift(r3079, r30F1), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f30F9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r30FE = equal(r30F1, body.constant(int(32)));
                     ir_if *f30FD = new(mem_ctx) ir_if(operand(r30FE).val);
                     exec_list *const f30FD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30FD->then_instructions;

                        body.emit(assign(r30F2, r307E, 0x01));

                        body.emit(assign(r30F3, r3079, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f30FD->else_instructions;

                        body.emit(assign(r30F0, bit_or(body.constant(0u), swizzle_x(r270B)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3100 = less(r30F1, body.constant(int(64)));
                        ir_if *f30FF = new(mem_ctx) ir_if(operand(r3100).val);
                        exec_list *const f30FF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30FF->then_instructions;

                           body.emit(assign(r30F2, lshift(r3079, r30F5), 0x01));

                           ir_expression *const r3101 = bit_and(r30F1, body.constant(int(31)));
                           body.emit(assign(r30F3, rshift(r3079, r3101), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30FF->else_instructions;

                           ir_variable *const r3102 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3104 = equal(r30F1, body.constant(int(64)));
                           ir_if *f3103 = new(mem_ctx) ir_if(operand(r3104).val);
                           exec_list *const f3103_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3103->then_instructions;

                              body.emit(assign(r3102, r3079, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3103->else_instructions;

                              ir_expression *const r3105 = nequal(r3079, body.constant(0u));
                              ir_expression *const r3106 = expr(ir_unop_b2i, r3105);
                              body.emit(assign(r3102, expr(ir_unop_i2u, r3106), 0x01));


                           body.instructions = f3103_parent_instructions;
                           body.emit(f3103);

                           /* END IF */

                           body.emit(assign(r30F2, r3102, 0x01));

                           body.emit(assign(r30F3, body.constant(0u), 0x01));


                        body.instructions = f30FF_parent_instructions;
                        body.emit(f30FF);

                        /* END IF */


                     body.instructions = f30FD_parent_instructions;
                     body.emit(f30FD);

                     /* END IF */

                     body.emit(assign(r30F4, body.constant(0u), 0x01));


                  body.instructions = f30F9_parent_instructions;
                  body.emit(f30F9);

                  /* END IF */

                  ir_expression *const r3107 = nequal(r30F0, body.constant(0u));
                  ir_expression *const r3108 = expr(ir_unop_b2i, r3107);
                  ir_expression *const r3109 = expr(ir_unop_i2u, r3108);
                  body.emit(assign(r30F2, bit_or(r30F2, r3109), 0x01));


               body.instructions = f30F7_parent_instructions;
               body.emit(f30F7);

               /* END IF */

               body.emit(assign(r3079, r30F4, 0x01));

               body.emit(assign(r307A, r30F3, 0x01));

               body.emit(assign(r307C, r30F2, 0x01));

               body.emit(assign(r307B, r3085, 0x01));


            body.instructions = f30CA_parent_instructions;
            body.emit(f30CA);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f30C8->else_instructions;

            /* IF CONDITION */
            ir_expression *const r310B = equal(r3082, body.constant(int(2047)));
            ir_if *f310A = new(mem_ctx) ir_if(operand(r310B).val);
            exec_list *const f310A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f310A->then_instructions;

               /* IF CONDITION */
               ir_expression *const r310D = bit_or(r3079, r307A);
               ir_expression *const r310E = bit_or(r3077, r3078);
               ir_expression *const r310F = bit_or(r310D, r310E);
               ir_expression *const r3110 = nequal(r310F, body.constant(0u));
               ir_if *f310C = new(mem_ctx) ir_if(operand(r3110).val);
               exec_list *const f310C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f310C->then_instructions;

                  ir_variable *const r3111 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r3111, swizzle_x(r270B), 0x01));

                  ir_variable *const r3112 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r3112, swizzle_x(r273F), 0x01));

                  ir_variable *const r3113 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3114 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r3115 = rshift(swizzle_y(r270B), body.constant(int(19)));
                  ir_expression *const r3116 = bit_and(r3115, body.constant(4095u));
                  ir_expression *const r3117 = equal(r3116, body.constant(4094u));
                  ir_expression *const r3118 = nequal(swizzle_x(r270B), body.constant(0u));
                  ir_expression *const r3119 = bit_and(swizzle_y(r270B), body.constant(524287u));
                  ir_expression *const r311A = nequal(r3119, body.constant(0u));
                  ir_expression *const r311B = logic_or(r3118, r311A);
                  body.emit(assign(r3114, logic_and(r3117, r311B), 0x01));

                  ir_variable *const r311C = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r311D = lshift(swizzle_y(r273F), body.constant(int(1)));
                  ir_expression *const r311E = lequal(body.constant(4292870144u), r311D);
                  ir_expression *const r311F = nequal(swizzle_x(r273F), body.constant(0u));
                  ir_expression *const r3120 = bit_and(swizzle_y(r273F), body.constant(1048575u));
                  ir_expression *const r3121 = nequal(r3120, body.constant(0u));
                  ir_expression *const r3122 = logic_or(r311F, r3121);
                  body.emit(assign(r311C, logic_and(r311E, r3122), 0x01));

                  body.emit(assign(r3111, bit_or(swizzle_y(r270B), body.constant(524288u)), 0x02));

                  body.emit(assign(r3112, bit_or(swizzle_y(r273F), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3124 = lshift(swizzle_y(r270B), body.constant(int(1)));
                  ir_expression *const r3125 = lequal(body.constant(4292870144u), r3124);
                  ir_expression *const r3126 = nequal(swizzle_x(r270B), body.constant(0u));
                  ir_expression *const r3127 = bit_and(swizzle_y(r270B), body.constant(1048575u));
                  ir_expression *const r3128 = nequal(r3127, body.constant(0u));
                  ir_expression *const r3129 = logic_or(r3126, r3128);
                  ir_expression *const r312A = logic_and(r3125, r3129);
                  ir_if *f3123 = new(mem_ctx) ir_if(operand(r312A).val);
                  exec_list *const f3123_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3123->then_instructions;

                     ir_variable *const r312B = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r312D = logic_and(r3114, r311C);
                     ir_if *f312C = new(mem_ctx) ir_if(operand(r312D).val);
                     exec_list *const f312C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f312C->then_instructions;

                        body.emit(assign(r312B, r3112, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f312C->else_instructions;

                        body.emit(assign(r312B, r3111, 0x03));


                     body.instructions = f312C_parent_instructions;
                     body.emit(f312C);

                     /* END IF */

                     body.emit(assign(r3113, r312B, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3123->else_instructions;

                     body.emit(assign(r3113, r3112, 0x03));


                  body.instructions = f3123_parent_instructions;
                  body.emit(f3123);

                  /* END IF */

                  body.emit(assign(r3075, r3113, 0x03));

                  body.emit(assign(r3074, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f310C->else_instructions;

                  body.emit(assign(r3075, r270B, 0x03));

                  body.emit(assign(r3074, body.constant(false), 0x01));


               body.instructions = f310C_parent_instructions;
               body.emit(f310C);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f310A->else_instructions;

               ir_variable *const r312E = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r312F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r312F, add(r307A, r3078), 0x01));

               ir_expression *const r3130 = add(r3079, r3077);
               ir_expression *const r3131 = less(r312F, r307A);
               ir_expression *const r3132 = expr(ir_unop_b2i, r3131);
               ir_expression *const r3133 = expr(ir_unop_i2u, r3132);
               body.emit(assign(r312E, add(r3130, r3133), 0x01));

               body.emit(assign(r307D, r312E, 0x01));

               /* IF CONDITION */
               ir_expression *const r3135 = equal(r3082, body.constant(int(0)));
               ir_if *f3134 = new(mem_ctx) ir_if(operand(r3135).val);
               exec_list *const f3134_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3134->then_instructions;

                  ir_variable *const r3136 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3136);
                  ir_expression *const r3137 = lshift(r2C5A, body.constant(int(31)));
                  body.emit(assign(r3136, add(r3137, r312E), 0x02));

                  body.emit(assign(r3136, r312F, 0x01));

                  body.emit(assign(r3075, r3136, 0x03));

                  body.emit(assign(r3074, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3134->else_instructions;

                  body.emit(assign(r307D, bit_or(r312E, body.constant(2097152u)), 0x01));

                  body.emit(assign(r307B, r3082, 0x01));

                  ir_variable *const r3138 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3138);
                  ir_variable *const r3139 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3139);
                  ir_variable *const r313A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r313A);
                  body.emit(assign(r3138, lshift(r312F, body.constant(int(31))), 0x01));

                  ir_expression *const r313B = lshift(r307D, body.constant(int(31)));
                  ir_expression *const r313C = rshift(r312F, body.constant(int(1)));
                  body.emit(assign(r3139, bit_or(r313B, r313C), 0x01));

                  body.emit(assign(r313A, rshift(r307D, body.constant(int(1))), 0x01));

                  body.emit(assign(r3138, bit_or(r3138, body.constant(0u)), 0x01));

                  body.emit(assign(r307D, r313A, 0x01));

                  body.emit(assign(r307C, r3138, 0x01));

                  ir_variable *const r313D = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r313D, r3082, 0x01));

                  ir_variable *const r313E = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r313E, r313A, 0x01));

                  ir_variable *const r313F = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r313F, r3139, 0x01));

                  ir_variable *const r3140 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r3140, r3138, 0x01));

                  ir_variable *const r3141 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r3141, body.constant(true), 0x01));

                  ir_variable *const r3142 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3143 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r3143);
                  ir_expression *const r3144 = expr(ir_unop_u2i, r3138);
                  body.emit(assign(r3143, less(r3144, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3146 = lequal(body.constant(int(2045)), r3082);
                  ir_if *f3145 = new(mem_ctx) ir_if(operand(r3146).val);
                  exec_list *const f3145_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3145->then_instructions;

                     ir_variable *const r3147 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3149 = less(body.constant(int(2045)), r3082);
                     ir_if *f3148 = new(mem_ctx) ir_if(operand(r3149).val);
                     exec_list *const f3148_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3148->then_instructions;

                        body.emit(assign(r3147, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3148->else_instructions;

                        ir_variable *const r314A = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r314C = equal(r3082, body.constant(int(2045)));
                        ir_if *f314B = new(mem_ctx) ir_if(operand(r314C).val);
                        exec_list *const f314B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f314B->then_instructions;

                           ir_expression *const r314D = equal(body.constant(2097151u), r313A);
                           ir_expression *const r314E = equal(body.constant(4294967295u), r3139);
                           body.emit(assign(r314A, logic_and(r314D, r314E), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f314B->else_instructions;

                           body.emit(assign(r314A, body.constant(false), 0x01));


                        body.instructions = f314B_parent_instructions;
                        body.emit(f314B);

                        /* END IF */

                        body.emit(assign(r3147, logic_and(r314A, r3143), 0x01));


                     body.instructions = f3148_parent_instructions;
                     body.emit(f3148);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f314F = new(mem_ctx) ir_if(operand(r3147).val);
                     exec_list *const f314F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f314F->then_instructions;

                        ir_variable *const r3150 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3150);
                        ir_expression *const r3151 = lshift(r2C5A, body.constant(int(31)));
                        body.emit(assign(r3150, add(r3151, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r3150, body.constant(0u), 0x01));

                        body.emit(assign(r3142, r3150, 0x03));

                        body.emit(assign(r3141, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f314F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3153 = less(r3082, body.constant(int(0)));
                        ir_if *f3152 = new(mem_ctx) ir_if(operand(r3153).val);
                        exec_list *const f3152_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3152->then_instructions;

                           ir_variable *const r3154 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3154, r3138, 0x01));

                           ir_variable *const r3155 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3155, neg(r3082), 0x01));

                           ir_variable *const r3156 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3156);
                           ir_variable *const r3157 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3157);
                           ir_variable *const r3158 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3158);
                           ir_variable *const r3159 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r315A = neg(r3155);
                           body.emit(assign(r3159, bit_and(r315A, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r315C = equal(r3155, body.constant(int(0)));
                           ir_if *f315B = new(mem_ctx) ir_if(operand(r315C).val);
                           exec_list *const f315B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f315B->then_instructions;

                              body.emit(assign(r3156, r3138, 0x01));

                              body.emit(assign(r3157, r3139, 0x01));

                              body.emit(assign(r3158, r313A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f315B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r315E = less(r3155, body.constant(int(32)));
                              ir_if *f315D = new(mem_ctx) ir_if(operand(r315E).val);
                              exec_list *const f315D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f315D->then_instructions;

                                 body.emit(assign(r3156, lshift(r3139, r3159), 0x01));

                                 ir_expression *const r315F = lshift(r313A, r3159);
                                 ir_expression *const r3160 = rshift(r3139, r3155);
                                 body.emit(assign(r3157, bit_or(r315F, r3160), 0x01));

                                 body.emit(assign(r3158, rshift(r313A, r3155), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f315D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3162 = equal(r3155, body.constant(int(32)));
                                 ir_if *f3161 = new(mem_ctx) ir_if(operand(r3162).val);
                                 exec_list *const f3161_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3161->then_instructions;

                                    body.emit(assign(r3156, r3139, 0x01));

                                    body.emit(assign(r3157, r313A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3161->else_instructions;

                                    body.emit(assign(r3154, bit_or(r3138, r3139), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3164 = less(r3155, body.constant(int(64)));
                                    ir_if *f3163 = new(mem_ctx) ir_if(operand(r3164).val);
                                    exec_list *const f3163_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3163->then_instructions;

                                       body.emit(assign(r3156, lshift(r313A, r3159), 0x01));

                                       ir_expression *const r3165 = bit_and(r3155, body.constant(int(31)));
                                       body.emit(assign(r3157, rshift(r313A, r3165), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3163->else_instructions;

                                       ir_variable *const r3166 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3168 = equal(r3155, body.constant(int(64)));
                                       ir_if *f3167 = new(mem_ctx) ir_if(operand(r3168).val);
                                       exec_list *const f3167_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3167->then_instructions;

                                          body.emit(assign(r3166, r313A, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3167->else_instructions;

                                          ir_expression *const r3169 = nequal(r313A, body.constant(0u));
                                          ir_expression *const r316A = expr(ir_unop_b2i, r3169);
                                          body.emit(assign(r3166, expr(ir_unop_i2u, r316A), 0x01));


                                       body.instructions = f3167_parent_instructions;
                                       body.emit(f3167);

                                       /* END IF */

                                       body.emit(assign(r3156, r3166, 0x01));

                                       body.emit(assign(r3157, body.constant(0u), 0x01));


                                    body.instructions = f3163_parent_instructions;
                                    body.emit(f3163);

                                    /* END IF */


                                 body.instructions = f3161_parent_instructions;
                                 body.emit(f3161);

                                 /* END IF */

                                 body.emit(assign(r3158, body.constant(0u), 0x01));


                              body.instructions = f315D_parent_instructions;
                              body.emit(f315D);

                              /* END IF */

                              ir_expression *const r316B = nequal(r3154, body.constant(0u));
                              ir_expression *const r316C = expr(ir_unop_b2i, r316B);
                              ir_expression *const r316D = expr(ir_unop_i2u, r316C);
                              body.emit(assign(r3156, bit_or(r3156, r316D), 0x01));


                           body.instructions = f315B_parent_instructions;
                           body.emit(f315B);

                           /* END IF */

                           body.emit(assign(r313E, r3158, 0x01));

                           body.emit(assign(r313F, r3157, 0x01));

                           body.emit(assign(r3140, r3156, 0x01));

                           body.emit(assign(r313D, body.constant(int(0)), 0x01));

                           body.emit(assign(r3143, less(r3156, body.constant(0u)), 0x01));


                        body.instructions = f3152_parent_instructions;
                        body.emit(f3152);

                        /* END IF */


                     body.instructions = f314F_parent_instructions;
                     body.emit(f314F);

                     /* END IF */


                  body.instructions = f3145_parent_instructions;
                  body.emit(f3145);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f316E = new(mem_ctx) ir_if(operand(r3141).val);
                  exec_list *const f316E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f316E->then_instructions;

                     /* IF CONDITION */
                     ir_if *f316F = new(mem_ctx) ir_if(operand(r3143).val);
                     exec_list *const f316F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f316F->then_instructions;

                        ir_variable *const r3170 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r3170, add(r313F, body.constant(1u)), 0x01));

                        ir_expression *const r3171 = less(r3170, r313F);
                        ir_expression *const r3172 = expr(ir_unop_b2i, r3171);
                        ir_expression *const r3173 = expr(ir_unop_i2u, r3172);
                        body.emit(assign(r313E, add(r313E, r3173), 0x01));

                        ir_expression *const r3174 = equal(r3140, body.constant(0u));
                        ir_expression *const r3175 = expr(ir_unop_b2i, r3174);
                        ir_expression *const r3176 = expr(ir_unop_i2u, r3175);
                        ir_expression *const r3177 = add(r3140, r3176);
                        ir_expression *const r3178 = bit_and(r3177, body.constant(1u));
                        ir_expression *const r3179 = expr(ir_unop_bit_not, r3178);
                        body.emit(assign(r313F, bit_and(r3170, r3179), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f316F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r317B = bit_or(r313E, r313F);
                        ir_expression *const r317C = equal(r317B, body.constant(0u));
                        ir_if *f317A = new(mem_ctx) ir_if(operand(r317C).val);
                        exec_list *const f317A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f317A->then_instructions;

                           body.emit(assign(r313D, body.constant(int(0)), 0x01));


                        body.instructions = f317A_parent_instructions;
                        body.emit(f317A);

                        /* END IF */


                     body.instructions = f316F_parent_instructions;
                     body.emit(f316F);

                     /* END IF */

                     ir_variable *const r317D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r317D);
                     ir_expression *const r317E = lshift(r2C5A, body.constant(int(31)));
                     ir_expression *const r317F = expr(ir_unop_i2u, r313D);
                     ir_expression *const r3180 = lshift(r317F, body.constant(int(20)));
                     ir_expression *const r3181 = add(r317E, r3180);
                     body.emit(assign(r317D, add(r3181, r313E), 0x02));

                     body.emit(assign(r317D, r313F, 0x01));

                     body.emit(assign(r3142, r317D, 0x03));

                     body.emit(assign(r3141, body.constant(false), 0x01));


                  body.instructions = f316E_parent_instructions;
                  body.emit(f316E);

                  /* END IF */

                  body.emit(assign(r3075, r3142, 0x03));

                  body.emit(assign(r3074, body.constant(false), 0x01));


               body.instructions = f3134_parent_instructions;
               body.emit(f3134);

               /* END IF */


            body.instructions = f310A_parent_instructions;
            body.emit(f310A);

            /* END IF */


         body.instructions = f30C8_parent_instructions;
         body.emit(f30C8);

         /* END IF */


      body.instructions = f3089_parent_instructions;
      body.emit(f3089);

      /* END IF */

      /* IF CONDITION */
      ir_if *f3182 = new(mem_ctx) ir_if(operand(r3074).val);
      exec_list *const f3182_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3182->then_instructions;

         body.emit(assign(r3079, bit_or(r3079, body.constant(1048576u)), 0x01));

         ir_variable *const r3183 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r3184 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r3184, add(r307A, r3078), 0x01));

         ir_expression *const r3185 = add(r3079, r3077);
         ir_expression *const r3186 = less(r3184, r307A);
         ir_expression *const r3187 = expr(ir_unop_b2i, r3186);
         ir_expression *const r3188 = expr(ir_unop_i2u, r3187);
         body.emit(assign(r3183, add(r3185, r3188), 0x01));

         body.emit(assign(r307D, r3183, 0x01));

         body.emit(assign(r307B, add(r307B, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r318A = less(r3183, body.constant(2097152u));
         ir_if *f3189 = new(mem_ctx) ir_if(operand(r318A).val);
         exec_list *const f3189_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3189->then_instructions;

            ir_variable *const r318B = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r318B, r307B, 0x01));

            ir_variable *const r318C = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r318C, r3183, 0x01));

            ir_variable *const r318D = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r318D, r3184, 0x01));

            ir_variable *const r318E = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r318E, r307C, 0x01));

            ir_variable *const r318F = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r318F, body.constant(true), 0x01));

            ir_variable *const r3190 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3191 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r3191);
            ir_expression *const r3192 = expr(ir_unop_u2i, r307C);
            body.emit(assign(r3191, less(r3192, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3194 = lequal(body.constant(int(2045)), r307B);
            ir_if *f3193 = new(mem_ctx) ir_if(operand(r3194).val);
            exec_list *const f3193_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3193->then_instructions;

               ir_variable *const r3195 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r3197 = less(body.constant(int(2045)), r307B);
               ir_if *f3196 = new(mem_ctx) ir_if(operand(r3197).val);
               exec_list *const f3196_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3196->then_instructions;

                  body.emit(assign(r3195, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3196->else_instructions;

                  ir_variable *const r3198 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r319A = equal(r307B, body.constant(int(2045)));
                  ir_if *f3199 = new(mem_ctx) ir_if(operand(r319A).val);
                  exec_list *const f3199_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3199->then_instructions;

                     ir_expression *const r319B = equal(body.constant(2097151u), r3183);
                     ir_expression *const r319C = equal(body.constant(4294967295u), r3184);
                     body.emit(assign(r3198, logic_and(r319B, r319C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3199->else_instructions;

                     body.emit(assign(r3198, body.constant(false), 0x01));


                  body.instructions = f3199_parent_instructions;
                  body.emit(f3199);

                  /* END IF */

                  body.emit(assign(r3195, logic_and(r3198, r3191), 0x01));


               body.instructions = f3196_parent_instructions;
               body.emit(f3196);

               /* END IF */

               /* IF CONDITION */
               ir_if *f319D = new(mem_ctx) ir_if(operand(r3195).val);
               exec_list *const f319D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f319D->then_instructions;

                  ir_variable *const r319E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r319E);
                  ir_expression *const r319F = lshift(r2C5A, body.constant(int(31)));
                  body.emit(assign(r319E, add(r319F, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r319E, body.constant(0u), 0x01));

                  body.emit(assign(r3190, r319E, 0x03));

                  body.emit(assign(r318F, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f319D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r31A1 = less(r307B, body.constant(int(0)));
                  ir_if *f31A0 = new(mem_ctx) ir_if(operand(r31A1).val);
                  exec_list *const f31A0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31A0->then_instructions;

                     ir_variable *const r31A2 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r31A2, r307C, 0x01));

                     ir_variable *const r31A3 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r31A3, neg(r307B), 0x01));

                     ir_variable *const r31A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r31A4);
                     ir_variable *const r31A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r31A5);
                     ir_variable *const r31A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r31A6);
                     ir_variable *const r31A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r31A8 = neg(r31A3);
                     body.emit(assign(r31A7, bit_and(r31A8, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r31AA = equal(r31A3, body.constant(int(0)));
                     ir_if *f31A9 = new(mem_ctx) ir_if(operand(r31AA).val);
                     exec_list *const f31A9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f31A9->then_instructions;

                        body.emit(assign(r31A4, r307C, 0x01));

                        body.emit(assign(r31A5, r3184, 0x01));

                        body.emit(assign(r31A6, r3183, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f31A9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r31AC = less(r31A3, body.constant(int(32)));
                        ir_if *f31AB = new(mem_ctx) ir_if(operand(r31AC).val);
                        exec_list *const f31AB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f31AB->then_instructions;

                           body.emit(assign(r31A4, lshift(r3184, r31A7), 0x01));

                           ir_expression *const r31AD = lshift(r3183, r31A7);
                           ir_expression *const r31AE = rshift(r3184, r31A3);
                           body.emit(assign(r31A5, bit_or(r31AD, r31AE), 0x01));

                           body.emit(assign(r31A6, rshift(r3183, r31A3), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f31AB->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r31B0 = equal(r31A3, body.constant(int(32)));
                           ir_if *f31AF = new(mem_ctx) ir_if(operand(r31B0).val);
                           exec_list *const f31AF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f31AF->then_instructions;

                              body.emit(assign(r31A4, r3184, 0x01));

                              body.emit(assign(r31A5, r3183, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f31AF->else_instructions;

                              body.emit(assign(r31A2, bit_or(r307C, r3184), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r31B2 = less(r31A3, body.constant(int(64)));
                              ir_if *f31B1 = new(mem_ctx) ir_if(operand(r31B2).val);
                              exec_list *const f31B1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31B1->then_instructions;

                                 body.emit(assign(r31A4, lshift(r3183, r31A7), 0x01));

                                 ir_expression *const r31B3 = bit_and(r31A3, body.constant(int(31)));
                                 body.emit(assign(r31A5, rshift(r3183, r31B3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f31B1->else_instructions;

                                 ir_variable *const r31B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r31B6 = equal(r31A3, body.constant(int(64)));
                                 ir_if *f31B5 = new(mem_ctx) ir_if(operand(r31B6).val);
                                 exec_list *const f31B5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f31B5->then_instructions;

                                    body.emit(assign(r31B4, r3183, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f31B5->else_instructions;

                                    ir_expression *const r31B7 = nequal(r3183, body.constant(0u));
                                    ir_expression *const r31B8 = expr(ir_unop_b2i, r31B7);
                                    body.emit(assign(r31B4, expr(ir_unop_i2u, r31B8), 0x01));


                                 body.instructions = f31B5_parent_instructions;
                                 body.emit(f31B5);

                                 /* END IF */

                                 body.emit(assign(r31A4, r31B4, 0x01));

                                 body.emit(assign(r31A5, body.constant(0u), 0x01));


                              body.instructions = f31B1_parent_instructions;
                              body.emit(f31B1);

                              /* END IF */


                           body.instructions = f31AF_parent_instructions;
                           body.emit(f31AF);

                           /* END IF */

                           body.emit(assign(r31A6, body.constant(0u), 0x01));


                        body.instructions = f31AB_parent_instructions;
                        body.emit(f31AB);

                        /* END IF */

                        ir_expression *const r31B9 = nequal(r31A2, body.constant(0u));
                        ir_expression *const r31BA = expr(ir_unop_b2i, r31B9);
                        ir_expression *const r31BB = expr(ir_unop_i2u, r31BA);
                        body.emit(assign(r31A4, bit_or(r31A4, r31BB), 0x01));


                     body.instructions = f31A9_parent_instructions;
                     body.emit(f31A9);

                     /* END IF */

                     body.emit(assign(r318C, r31A6, 0x01));

                     body.emit(assign(r318D, r31A5, 0x01));

                     body.emit(assign(r318E, r31A4, 0x01));

                     body.emit(assign(r318B, body.constant(int(0)), 0x01));

                     body.emit(assign(r3191, less(r31A4, body.constant(0u)), 0x01));


                  body.instructions = f31A0_parent_instructions;
                  body.emit(f31A0);

                  /* END IF */


               body.instructions = f319D_parent_instructions;
               body.emit(f319D);

               /* END IF */


            body.instructions = f3193_parent_instructions;
            body.emit(f3193);

            /* END IF */

            /* IF CONDITION */
            ir_if *f31BC = new(mem_ctx) ir_if(operand(r318F).val);
            exec_list *const f31BC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f31BC->then_instructions;

               /* IF CONDITION */
               ir_if *f31BD = new(mem_ctx) ir_if(operand(r3191).val);
               exec_list *const f31BD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31BD->then_instructions;

                  ir_variable *const r31BE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r31BE, add(r318D, body.constant(1u)), 0x01));

                  ir_expression *const r31BF = less(r31BE, r318D);
                  ir_expression *const r31C0 = expr(ir_unop_b2i, r31BF);
                  ir_expression *const r31C1 = expr(ir_unop_i2u, r31C0);
                  body.emit(assign(r318C, add(r318C, r31C1), 0x01));

                  ir_expression *const r31C2 = equal(r318E, body.constant(0u));
                  ir_expression *const r31C3 = expr(ir_unop_b2i, r31C2);
                  ir_expression *const r31C4 = expr(ir_unop_i2u, r31C3);
                  ir_expression *const r31C5 = add(r318E, r31C4);
                  ir_expression *const r31C6 = bit_and(r31C5, body.constant(1u));
                  ir_expression *const r31C7 = expr(ir_unop_bit_not, r31C6);
                  body.emit(assign(r318D, bit_and(r31BE, r31C7), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f31BD->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r31C9 = bit_or(r318C, r318D);
                  ir_expression *const r31CA = equal(r31C9, body.constant(0u));
                  ir_if *f31C8 = new(mem_ctx) ir_if(operand(r31CA).val);
                  exec_list *const f31C8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31C8->then_instructions;

                     body.emit(assign(r318B, body.constant(int(0)), 0x01));


                  body.instructions = f31C8_parent_instructions;
                  body.emit(f31C8);

                  /* END IF */


               body.instructions = f31BD_parent_instructions;
               body.emit(f31BD);

               /* END IF */

               ir_variable *const r31CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r31CB);
               ir_expression *const r31CC = lshift(r2C5A, body.constant(int(31)));
               ir_expression *const r31CD = expr(ir_unop_i2u, r318B);
               ir_expression *const r31CE = lshift(r31CD, body.constant(int(20)));
               ir_expression *const r31CF = add(r31CC, r31CE);
               body.emit(assign(r31CB, add(r31CF, r318C), 0x02));

               body.emit(assign(r31CB, r318D, 0x01));

               body.emit(assign(r3190, r31CB, 0x03));

               body.emit(assign(r318F, body.constant(false), 0x01));


            body.instructions = f31BC_parent_instructions;
            body.emit(f31BC);

            /* END IF */

            body.emit(assign(r3075, r3190, 0x03));

            body.emit(assign(r3074, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3189->else_instructions;

            body.emit(assign(r307B, add(r307B, body.constant(int(1))), 0x01));

            ir_variable *const r31D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r31D0);
            ir_variable *const r31D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r31D1);
            ir_variable *const r31D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r31D2);
            body.emit(assign(r31D0, lshift(r3184, body.constant(int(31))), 0x01));

            ir_expression *const r31D3 = lshift(r3183, body.constant(int(31)));
            ir_expression *const r31D4 = rshift(r3184, body.constant(int(1)));
            body.emit(assign(r31D1, bit_or(r31D3, r31D4), 0x01));

            body.emit(assign(r31D2, rshift(r3183, body.constant(int(1))), 0x01));

            ir_expression *const r31D5 = nequal(r307C, body.constant(0u));
            ir_expression *const r31D6 = expr(ir_unop_b2i, r31D5);
            ir_expression *const r31D7 = expr(ir_unop_i2u, r31D6);
            body.emit(assign(r31D0, bit_or(r31D0, r31D7), 0x01));

            body.emit(assign(r307D, r31D2, 0x01));

            body.emit(assign(r307C, r31D0, 0x01));

            ir_variable *const r31D8 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r31D8, r307B, 0x01));

            ir_variable *const r31D9 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r31D9, r31D2, 0x01));

            ir_variable *const r31DA = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r31DA, r31D1, 0x01));

            ir_variable *const r31DB = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r31DB, r31D0, 0x01));

            ir_variable *const r31DC = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r31DC, body.constant(true), 0x01));

            ir_variable *const r31DD = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r31DE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r31DE);
            ir_expression *const r31DF = expr(ir_unop_u2i, r31D0);
            body.emit(assign(r31DE, less(r31DF, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r31E1 = lequal(body.constant(int(2045)), r307B);
            ir_if *f31E0 = new(mem_ctx) ir_if(operand(r31E1).val);
            exec_list *const f31E0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f31E0->then_instructions;

               ir_variable *const r31E2 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r31E4 = less(body.constant(int(2045)), r307B);
               ir_if *f31E3 = new(mem_ctx) ir_if(operand(r31E4).val);
               exec_list *const f31E3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31E3->then_instructions;

                  body.emit(assign(r31E2, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f31E3->else_instructions;

                  ir_variable *const r31E5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r31E7 = equal(r307B, body.constant(int(2045)));
                  ir_if *f31E6 = new(mem_ctx) ir_if(operand(r31E7).val);
                  exec_list *const f31E6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31E6->then_instructions;

                     ir_expression *const r31E8 = equal(body.constant(2097151u), r31D2);
                     ir_expression *const r31E9 = equal(body.constant(4294967295u), r31D1);
                     body.emit(assign(r31E5, logic_and(r31E8, r31E9), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f31E6->else_instructions;

                     body.emit(assign(r31E5, body.constant(false), 0x01));


                  body.instructions = f31E6_parent_instructions;
                  body.emit(f31E6);

                  /* END IF */

                  body.emit(assign(r31E2, logic_and(r31E5, r31DE), 0x01));


               body.instructions = f31E3_parent_instructions;
               body.emit(f31E3);

               /* END IF */

               /* IF CONDITION */
               ir_if *f31EA = new(mem_ctx) ir_if(operand(r31E2).val);
               exec_list *const f31EA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31EA->then_instructions;

                  ir_variable *const r31EB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r31EB);
                  ir_expression *const r31EC = lshift(r2C5A, body.constant(int(31)));
                  body.emit(assign(r31EB, add(r31EC, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r31EB, body.constant(0u), 0x01));

                  body.emit(assign(r31DD, r31EB, 0x03));

                  body.emit(assign(r31DC, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f31EA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r31EE = less(r307B, body.constant(int(0)));
                  ir_if *f31ED = new(mem_ctx) ir_if(operand(r31EE).val);
                  exec_list *const f31ED_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31ED->then_instructions;

                     ir_variable *const r31EF = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r31EF, r31D0, 0x01));

                     ir_variable *const r31F0 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r31F0, neg(r307B), 0x01));

                     ir_variable *const r31F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r31F1);
                     ir_variable *const r31F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r31F2);
                     ir_variable *const r31F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r31F3);
                     ir_variable *const r31F4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r31F5 = neg(r31F0);
                     body.emit(assign(r31F4, bit_and(r31F5, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r31F7 = equal(r31F0, body.constant(int(0)));
                     ir_if *f31F6 = new(mem_ctx) ir_if(operand(r31F7).val);
                     exec_list *const f31F6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f31F6->then_instructions;

                        body.emit(assign(r31F1, r31D0, 0x01));

                        body.emit(assign(r31F2, r31D1, 0x01));

                        body.emit(assign(r31F3, r31D2, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f31F6->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r31F9 = less(r31F0, body.constant(int(32)));
                        ir_if *f31F8 = new(mem_ctx) ir_if(operand(r31F9).val);
                        exec_list *const f31F8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f31F8->then_instructions;

                           body.emit(assign(r31F1, lshift(r31D1, r31F4), 0x01));

                           ir_expression *const r31FA = lshift(r31D2, r31F4);
                           ir_expression *const r31FB = rshift(r31D1, r31F0);
                           body.emit(assign(r31F2, bit_or(r31FA, r31FB), 0x01));

                           body.emit(assign(r31F3, rshift(r31D2, r31F0), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f31F8->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r31FD = equal(r31F0, body.constant(int(32)));
                           ir_if *f31FC = new(mem_ctx) ir_if(operand(r31FD).val);
                           exec_list *const f31FC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f31FC->then_instructions;

                              body.emit(assign(r31F1, r31D1, 0x01));

                              body.emit(assign(r31F2, r31D2, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f31FC->else_instructions;

                              body.emit(assign(r31EF, bit_or(r31D0, r31D1), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r31FF = less(r31F0, body.constant(int(64)));
                              ir_if *f31FE = new(mem_ctx) ir_if(operand(r31FF).val);
                              exec_list *const f31FE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31FE->then_instructions;

                                 body.emit(assign(r31F1, lshift(r31D2, r31F4), 0x01));

                                 ir_expression *const r3200 = bit_and(r31F0, body.constant(int(31)));
                                 body.emit(assign(r31F2, rshift(r31D2, r3200), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f31FE->else_instructions;

                                 ir_variable *const r3201 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3203 = equal(r31F0, body.constant(int(64)));
                                 ir_if *f3202 = new(mem_ctx) ir_if(operand(r3203).val);
                                 exec_list *const f3202_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3202->then_instructions;

                                    body.emit(assign(r3201, r31D2, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3202->else_instructions;

                                    ir_expression *const r3204 = nequal(r31D2, body.constant(0u));
                                    ir_expression *const r3205 = expr(ir_unop_b2i, r3204);
                                    body.emit(assign(r3201, expr(ir_unop_i2u, r3205), 0x01));


                                 body.instructions = f3202_parent_instructions;
                                 body.emit(f3202);

                                 /* END IF */

                                 body.emit(assign(r31F1, r3201, 0x01));

                                 body.emit(assign(r31F2, body.constant(0u), 0x01));


                              body.instructions = f31FE_parent_instructions;
                              body.emit(f31FE);

                              /* END IF */


                           body.instructions = f31FC_parent_instructions;
                           body.emit(f31FC);

                           /* END IF */

                           body.emit(assign(r31F3, body.constant(0u), 0x01));


                        body.instructions = f31F8_parent_instructions;
                        body.emit(f31F8);

                        /* END IF */

                        ir_expression *const r3206 = nequal(r31EF, body.constant(0u));
                        ir_expression *const r3207 = expr(ir_unop_b2i, r3206);
                        ir_expression *const r3208 = expr(ir_unop_i2u, r3207);
                        body.emit(assign(r31F1, bit_or(r31F1, r3208), 0x01));


                     body.instructions = f31F6_parent_instructions;
                     body.emit(f31F6);

                     /* END IF */

                     body.emit(assign(r31D9, r31F3, 0x01));

                     body.emit(assign(r31DA, r31F2, 0x01));

                     body.emit(assign(r31DB, r31F1, 0x01));

                     body.emit(assign(r31D8, body.constant(int(0)), 0x01));

                     body.emit(assign(r31DE, less(r31F1, body.constant(0u)), 0x01));


                  body.instructions = f31ED_parent_instructions;
                  body.emit(f31ED);

                  /* END IF */


               body.instructions = f31EA_parent_instructions;
               body.emit(f31EA);

               /* END IF */


            body.instructions = f31E0_parent_instructions;
            body.emit(f31E0);

            /* END IF */

            /* IF CONDITION */
            ir_if *f3209 = new(mem_ctx) ir_if(operand(r31DC).val);
            exec_list *const f3209_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3209->then_instructions;

               /* IF CONDITION */
               ir_if *f320A = new(mem_ctx) ir_if(operand(r31DE).val);
               exec_list *const f320A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f320A->then_instructions;

                  ir_variable *const r320B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r320B, add(r31DA, body.constant(1u)), 0x01));

                  ir_expression *const r320C = less(r320B, r31DA);
                  ir_expression *const r320D = expr(ir_unop_b2i, r320C);
                  ir_expression *const r320E = expr(ir_unop_i2u, r320D);
                  body.emit(assign(r31D9, add(r31D9, r320E), 0x01));

                  ir_expression *const r320F = equal(r31DB, body.constant(0u));
                  ir_expression *const r3210 = expr(ir_unop_b2i, r320F);
                  ir_expression *const r3211 = expr(ir_unop_i2u, r3210);
                  ir_expression *const r3212 = add(r31DB, r3211);
                  ir_expression *const r3213 = bit_and(r3212, body.constant(1u));
                  ir_expression *const r3214 = expr(ir_unop_bit_not, r3213);
                  body.emit(assign(r31DA, bit_and(r320B, r3214), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f320A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3216 = bit_or(r31D9, r31DA);
                  ir_expression *const r3217 = equal(r3216, body.constant(0u));
                  ir_if *f3215 = new(mem_ctx) ir_if(operand(r3217).val);
                  exec_list *const f3215_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3215->then_instructions;

                     body.emit(assign(r31D8, body.constant(int(0)), 0x01));


                  body.instructions = f3215_parent_instructions;
                  body.emit(f3215);

                  /* END IF */


               body.instructions = f320A_parent_instructions;
               body.emit(f320A);

               /* END IF */

               ir_variable *const r3218 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3218);
               ir_expression *const r3219 = lshift(r2C5A, body.constant(int(31)));
               ir_expression *const r321A = expr(ir_unop_i2u, r31D8);
               ir_expression *const r321B = lshift(r321A, body.constant(int(20)));
               ir_expression *const r321C = add(r3219, r321B);
               body.emit(assign(r3218, add(r321C, r31D9), 0x02));

               body.emit(assign(r3218, r31DA, 0x01));

               body.emit(assign(r31DD, r3218, 0x03));

               body.emit(assign(r31DC, body.constant(false), 0x01));


            body.instructions = f3209_parent_instructions;
            body.emit(f3209);

            /* END IF */

            body.emit(assign(r3075, r31DD, 0x03));

            body.emit(assign(r3074, body.constant(false), 0x01));


         body.instructions = f3189_parent_instructions;
         body.emit(f3189);

         /* END IF */


      body.instructions = f3182_parent_instructions;
      body.emit(f3182);

      /* END IF */

      body.emit(assign(r2C59, r3075, 0x03));


   body.instructions = f2C5C_parent_instructions;
   body.emit(f2C5C);

   /* END IF */

   body.emit(ret(r2C59));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmod64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r321D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "x", ir_var_function_in);
   sig_parameters.push_tail(r321D);
   ir_variable *const r321E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "y", ir_var_function_in);
   sig_parameters.push_tail(r321E);
   ir_variable *const r321F = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r321F, body.constant(true), 0x01));

   ir_variable *const r3220 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3221 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r3221);
   ir_variable *const r3222 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r3222);
   ir_variable *const r3223 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r3223);
   ir_variable *const r3224 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r3224);
   ir_variable *const r3225 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r3225);
   ir_variable *const r3226 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r3226);
   ir_variable *const r3227 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r3227);
   ir_variable *const r3228 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r3228);
   ir_variable *const r3229 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r3229);
   ir_variable *const r322A = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r322A);
   ir_variable *const r322B = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r322B);
   ir_variable *const r322C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r322C);
   ir_variable *const r322D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r322D);
   ir_variable *const r322E = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r322E);
   body.emit(assign(r322D, body.constant(0u), 0x01));

   body.emit(assign(r322C, body.constant(0u), 0x01));

   body.emit(assign(r322B, body.constant(0u), 0x01));

   body.emit(assign(r322A, body.constant(0u), 0x01));

   body.emit(assign(r3229, body.constant(0u), 0x01));

   body.emit(assign(r3228, body.constant(0u), 0x01));

   ir_variable *const r322F = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r322F, swizzle_x(r321D), 0x01));

   body.emit(assign(r3227, r322F, 0x01));

   ir_variable *const r3230 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r3230, bit_and(swizzle_y(r321D), body.constant(1048575u)), 0x01));

   body.emit(assign(r3226, r3230, 0x01));

   ir_variable *const r3231 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r3231, swizzle_x(r321E), 0x01));

   body.emit(assign(r3225, r3231, 0x01));

   ir_variable *const r3232 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r3232, bit_and(swizzle_y(r321E), body.constant(1048575u)), 0x01));

   body.emit(assign(r3224, r3232, 0x01));

   ir_variable *const r3233 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r3234 = rshift(swizzle_y(r321D), body.constant(int(20)));
   ir_expression *const r3235 = bit_and(r3234, body.constant(2047u));
   body.emit(assign(r3233, expr(ir_unop_u2i, r3235), 0x01));

   body.emit(assign(r3223, r3233, 0x01));

   ir_variable *const r3236 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r3237 = rshift(swizzle_y(r321E), body.constant(int(20)));
   ir_expression *const r3238 = bit_and(r3237, body.constant(2047u));
   body.emit(assign(r3236, expr(ir_unop_u2i, r3238), 0x01));

   body.emit(assign(r3222, r3236, 0x01));

   ir_expression *const r3239 = rshift(swizzle_y(r321D), body.constant(int(31)));
   ir_expression *const r323A = rshift(swizzle_y(r321E), body.constant(int(31)));
   body.emit(assign(r3221, bit_xor(r3239, r323A), 0x01));

   /* IF CONDITION */
   ir_expression *const r323C = equal(r3233, body.constant(int(2047)));
   ir_if *f323B = new(mem_ctx) ir_if(operand(r323C).val);
   exec_list *const f323B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f323B->then_instructions;

      /* IF CONDITION */
      ir_expression *const r323E = bit_or(r3230, swizzle_x(r321D));
      ir_expression *const r323F = nequal(r323E, body.constant(0u));
      ir_if *f323D = new(mem_ctx) ir_if(operand(r323F).val);
      exec_list *const f323D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f323D->then_instructions;

         ir_variable *const r3240 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r3240, swizzle_x(r321D), 0x01));

         ir_variable *const r3241 = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r3241, swizzle_x(r321E), 0x01));

         ir_variable *const r3242 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r3243 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r3244 = rshift(swizzle_y(r321D), body.constant(int(19)));
         ir_expression *const r3245 = bit_and(r3244, body.constant(4095u));
         ir_expression *const r3246 = equal(r3245, body.constant(4094u));
         ir_expression *const r3247 = nequal(swizzle_x(r321D), body.constant(0u));
         ir_expression *const r3248 = bit_and(swizzle_y(r321D), body.constant(524287u));
         ir_expression *const r3249 = nequal(r3248, body.constant(0u));
         ir_expression *const r324A = logic_or(r3247, r3249);
         body.emit(assign(r3243, logic_and(r3246, r324A), 0x01));

         ir_variable *const r324B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r324C = lshift(swizzle_y(r321E), body.constant(int(1)));
         ir_expression *const r324D = lequal(body.constant(4292870144u), r324C);
         ir_expression *const r324E = nequal(swizzle_x(r321E), body.constant(0u));
         ir_expression *const r324F = bit_and(swizzle_y(r321E), body.constant(1048575u));
         ir_expression *const r3250 = nequal(r324F, body.constant(0u));
         ir_expression *const r3251 = logic_or(r324E, r3250);
         body.emit(assign(r324B, logic_and(r324D, r3251), 0x01));

         body.emit(assign(r3240, bit_or(swizzle_y(r321D), body.constant(524288u)), 0x02));

         body.emit(assign(r3241, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r3253 = lshift(swizzle_y(r321D), body.constant(int(1)));
         ir_expression *const r3254 = lequal(body.constant(4292870144u), r3253);
         ir_expression *const r3255 = nequal(swizzle_x(r321D), body.constant(0u));
         ir_expression *const r3256 = bit_and(swizzle_y(r321D), body.constant(1048575u));
         ir_expression *const r3257 = nequal(r3256, body.constant(0u));
         ir_expression *const r3258 = logic_or(r3255, r3257);
         ir_expression *const r3259 = logic_and(r3254, r3258);
         ir_if *f3252 = new(mem_ctx) ir_if(operand(r3259).val);
         exec_list *const f3252_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3252->then_instructions;

            ir_variable *const r325A = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r325C = logic_and(r3243, r324B);
            ir_if *f325B = new(mem_ctx) ir_if(operand(r325C).val);
            exec_list *const f325B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f325B->then_instructions;

               body.emit(assign(r325A, r3241, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f325B->else_instructions;

               body.emit(assign(r325A, r3240, 0x03));


            body.instructions = f325B_parent_instructions;
            body.emit(f325B);

            /* END IF */

            body.emit(assign(r3242, r325A, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3252->else_instructions;

            body.emit(assign(r3242, r3241, 0x03));


         body.instructions = f3252_parent_instructions;
         body.emit(f3252);

         /* END IF */

         body.emit(assign(r3220, r3242, 0x03));

         body.emit(assign(r321F, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f323D->else_instructions;

         /* IF CONDITION */
         ir_expression *const r325E = equal(r3236, body.constant(int(2047)));
         ir_if *f325D = new(mem_ctx) ir_if(operand(r325E).val);
         exec_list *const f325D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f325D->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3260 = bit_or(r3232, swizzle_x(r321E));
            ir_expression *const r3261 = nequal(r3260, body.constant(0u));
            ir_if *f325F = new(mem_ctx) ir_if(operand(r3261).val);
            exec_list *const f325F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f325F->then_instructions;

               ir_variable *const r3262 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r3262, swizzle_x(r321D), 0x01));

               ir_variable *const r3263 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r3263, swizzle_x(r321E), 0x01));

               ir_variable *const r3264 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3265 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3266 = rshift(swizzle_y(r321D), body.constant(int(19)));
               ir_expression *const r3267 = bit_and(r3266, body.constant(4095u));
               ir_expression *const r3268 = equal(r3267, body.constant(4094u));
               ir_expression *const r3269 = nequal(swizzle_x(r321D), body.constant(0u));
               ir_expression *const r326A = bit_and(swizzle_y(r321D), body.constant(524287u));
               ir_expression *const r326B = nequal(r326A, body.constant(0u));
               ir_expression *const r326C = logic_or(r3269, r326B);
               body.emit(assign(r3265, logic_and(r3268, r326C), 0x01));

               ir_variable *const r326D = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r326E = lshift(swizzle_y(r321E), body.constant(int(1)));
               ir_expression *const r326F = lequal(body.constant(4292870144u), r326E);
               ir_expression *const r3270 = nequal(swizzle_x(r321E), body.constant(0u));
               ir_expression *const r3271 = bit_and(swizzle_y(r321E), body.constant(1048575u));
               ir_expression *const r3272 = nequal(r3271, body.constant(0u));
               ir_expression *const r3273 = logic_or(r3270, r3272);
               body.emit(assign(r326D, logic_and(r326F, r3273), 0x01));

               body.emit(assign(r3262, bit_or(swizzle_y(r321D), body.constant(524288u)), 0x02));

               body.emit(assign(r3263, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r3275 = lshift(swizzle_y(r321D), body.constant(int(1)));
               ir_expression *const r3276 = lequal(body.constant(4292870144u), r3275);
               ir_expression *const r3277 = nequal(swizzle_x(r321D), body.constant(0u));
               ir_expression *const r3278 = bit_and(swizzle_y(r321D), body.constant(1048575u));
               ir_expression *const r3279 = nequal(r3278, body.constant(0u));
               ir_expression *const r327A = logic_or(r3277, r3279);
               ir_expression *const r327B = logic_and(r3276, r327A);
               ir_if *f3274 = new(mem_ctx) ir_if(operand(r327B).val);
               exec_list *const f3274_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3274->then_instructions;

                  ir_variable *const r327C = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r327E = logic_and(r3265, r326D);
                  ir_if *f327D = new(mem_ctx) ir_if(operand(r327E).val);
                  exec_list *const f327D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f327D->then_instructions;

                     body.emit(assign(r327C, r3263, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f327D->else_instructions;

                     body.emit(assign(r327C, r3262, 0x03));


                  body.instructions = f327D_parent_instructions;
                  body.emit(f327D);

                  /* END IF */

                  body.emit(assign(r3264, r327C, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3274->else_instructions;

                  body.emit(assign(r3264, r3263, 0x03));


               body.instructions = f3274_parent_instructions;
               body.emit(f3274);

               /* END IF */

               body.emit(assign(r3220, r3264, 0x03));

               body.emit(assign(r321F, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f325F->else_instructions;

               ir_constant_data r327F_data;
               memset(&r327F_data, 0, sizeof(ir_constant_data));
               r327F_data.u[0] = 4294967295;
               r327F_data.u[1] = 4294967295;
               ir_constant *const r327F = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r327F_data);
               body.emit(assign(r3220, r327F, 0x03));

               body.emit(assign(r321F, body.constant(false), 0x01));


            body.instructions = f325F_parent_instructions;
            body.emit(f325F);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f325D->else_instructions;

            ir_variable *const r3280 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r3280);
            ir_expression *const r3281 = lshift(r3221, body.constant(int(31)));
            body.emit(assign(r3280, add(r3281, body.constant(2146435072u)), 0x02));

            body.emit(assign(r3280, body.constant(0u), 0x01));

            body.emit(assign(r3220, r3280, 0x03));

            body.emit(assign(r321F, body.constant(false), 0x01));


         body.instructions = f325D_parent_instructions;
         body.emit(f325D);

         /* END IF */


      body.instructions = f323D_parent_instructions;
      body.emit(f323D);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f323B->else_instructions;

      /* IF CONDITION */
      ir_expression *const r3283 = equal(r3236, body.constant(int(2047)));
      ir_if *f3282 = new(mem_ctx) ir_if(operand(r3283).val);
      exec_list *const f3282_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3282->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3285 = bit_or(r3232, swizzle_x(r321E));
         ir_expression *const r3286 = nequal(r3285, body.constant(0u));
         ir_if *f3284 = new(mem_ctx) ir_if(operand(r3286).val);
         exec_list *const f3284_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3284->then_instructions;

            ir_variable *const r3287 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r3287, swizzle_x(r321D), 0x01));

            ir_variable *const r3288 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r3288, swizzle_x(r321E), 0x01));

            ir_variable *const r3289 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r328A = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r328B = rshift(swizzle_y(r321D), body.constant(int(19)));
            ir_expression *const r328C = bit_and(r328B, body.constant(4095u));
            ir_expression *const r328D = equal(r328C, body.constant(4094u));
            ir_expression *const r328E = nequal(swizzle_x(r321D), body.constant(0u));
            ir_expression *const r328F = bit_and(swizzle_y(r321D), body.constant(524287u));
            ir_expression *const r3290 = nequal(r328F, body.constant(0u));
            ir_expression *const r3291 = logic_or(r328E, r3290);
            body.emit(assign(r328A, logic_and(r328D, r3291), 0x01));

            ir_variable *const r3292 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r3293 = lshift(swizzle_y(r321E), body.constant(int(1)));
            ir_expression *const r3294 = lequal(body.constant(4292870144u), r3293);
            ir_expression *const r3295 = nequal(swizzle_x(r321E), body.constant(0u));
            ir_expression *const r3296 = bit_and(swizzle_y(r321E), body.constant(1048575u));
            ir_expression *const r3297 = nequal(r3296, body.constant(0u));
            ir_expression *const r3298 = logic_or(r3295, r3297);
            body.emit(assign(r3292, logic_and(r3294, r3298), 0x01));

            body.emit(assign(r3287, bit_or(swizzle_y(r321D), body.constant(524288u)), 0x02));

            body.emit(assign(r3288, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r329A = lshift(swizzle_y(r321D), body.constant(int(1)));
            ir_expression *const r329B = lequal(body.constant(4292870144u), r329A);
            ir_expression *const r329C = nequal(swizzle_x(r321D), body.constant(0u));
            ir_expression *const r329D = bit_and(swizzle_y(r321D), body.constant(1048575u));
            ir_expression *const r329E = nequal(r329D, body.constant(0u));
            ir_expression *const r329F = logic_or(r329C, r329E);
            ir_expression *const r32A0 = logic_and(r329B, r329F);
            ir_if *f3299 = new(mem_ctx) ir_if(operand(r32A0).val);
            exec_list *const f3299_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3299->then_instructions;

               ir_variable *const r32A1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r32A3 = logic_and(r328A, r3292);
               ir_if *f32A2 = new(mem_ctx) ir_if(operand(r32A3).val);
               exec_list *const f32A2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32A2->then_instructions;

                  body.emit(assign(r32A1, r3288, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32A2->else_instructions;

                  body.emit(assign(r32A1, r3287, 0x03));


               body.instructions = f32A2_parent_instructions;
               body.emit(f32A2);

               /* END IF */

               body.emit(assign(r3289, r32A1, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3299->else_instructions;

               body.emit(assign(r3289, r3288, 0x03));


            body.instructions = f3299_parent_instructions;
            body.emit(f3299);

            /* END IF */

            body.emit(assign(r3220, r3289, 0x03));

            body.emit(assign(r321F, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3284->else_instructions;

            ir_variable *const r32A4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r32A4);
            body.emit(assign(r32A4, lshift(r3221, body.constant(int(31))), 0x02));

            body.emit(assign(r32A4, body.constant(0u), 0x01));

            body.emit(assign(r3220, r32A4, 0x03));

            body.emit(assign(r321F, body.constant(false), 0x01));


         body.instructions = f3284_parent_instructions;
         body.emit(f3284);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3282->else_instructions;

         /* IF CONDITION */
         ir_expression *const r32A6 = equal(r3236, body.constant(int(0)));
         ir_if *f32A5 = new(mem_ctx) ir_if(operand(r32A6).val);
         exec_list *const f32A5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f32A5->then_instructions;

            /* IF CONDITION */
            ir_expression *const r32A8 = bit_or(r3232, swizzle_x(r321E));
            ir_expression *const r32A9 = equal(r32A8, body.constant(0u));
            ir_if *f32A7 = new(mem_ctx) ir_if(operand(r32A9).val);
            exec_list *const f32A7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f32A7->then_instructions;

               /* IF CONDITION */
               ir_expression *const r32AB = expr(ir_unop_i2u, r3233);
               ir_expression *const r32AC = bit_or(r32AB, r3230);
               ir_expression *const r32AD = bit_or(r32AC, swizzle_x(r321D));
               ir_expression *const r32AE = equal(r32AD, body.constant(0u));
               ir_if *f32AA = new(mem_ctx) ir_if(operand(r32AE).val);
               exec_list *const f32AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32AA->then_instructions;

                  ir_constant_data r32AF_data;
                  memset(&r32AF_data, 0, sizeof(ir_constant_data));
                  r32AF_data.u[0] = 4294967295;
                  r32AF_data.u[1] = 4294967295;
                  ir_constant *const r32AF = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r32AF_data);
                  body.emit(assign(r3220, r32AF, 0x03));

                  body.emit(assign(r321F, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32AA->else_instructions;

                  ir_variable *const r32B0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r32B0);
                  ir_expression *const r32B1 = lshift(r3221, body.constant(int(31)));
                  body.emit(assign(r32B0, add(r32B1, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r32B0, body.constant(0u), 0x01));

                  body.emit(assign(r3220, r32B0, 0x03));

                  body.emit(assign(r321F, body.constant(false), 0x01));


               body.instructions = f32AA_parent_instructions;
               body.emit(f32AA);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f32A7->else_instructions;

               ir_variable *const r32B2 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r32B2, r3236, 0x01));

               ir_variable *const r32B3 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r32B3, r3232, 0x01));

               ir_variable *const r32B4 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r32B4, r3231, 0x01));

               ir_variable *const r32B5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r32B5);
               /* IF CONDITION */
               ir_expression *const r32B7 = equal(r3232, body.constant(0u));
               ir_if *f32B6 = new(mem_ctx) ir_if(operand(r32B7).val);
               exec_list *const f32B6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32B6->then_instructions;

                  ir_variable *const r32B8 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r32B8, r3231, 0x01));

                  ir_variable *const r32B9 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r32BA = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r32BA);
                  /* IF CONDITION */
                  ir_expression *const r32BC = equal(swizzle_x(r321E), body.constant(0u));
                  ir_if *f32BB = new(mem_ctx) ir_if(operand(r32BC).val);
                  exec_list *const f32BB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32BB->then_instructions;

                     body.emit(assign(r32B9, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32BB->else_instructions;

                     body.emit(assign(r32BA, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r32BE = bit_and(swizzle_x(r321E), body.constant(4294901760u));
                     ir_expression *const r32BF = equal(r32BE, body.constant(0u));
                     ir_if *f32BD = new(mem_ctx) ir_if(operand(r32BF).val);
                     exec_list *const f32BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32BD->then_instructions;

                        body.emit(assign(r32BA, body.constant(int(16)), 0x01));

                        body.emit(assign(r32B8, lshift(swizzle_x(r321E), body.constant(int(16))), 0x01));


                     body.instructions = f32BD_parent_instructions;
                     body.emit(f32BD);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32C1 = bit_and(r32B8, body.constant(4278190080u));
                     ir_expression *const r32C2 = equal(r32C1, body.constant(0u));
                     ir_if *f32C0 = new(mem_ctx) ir_if(operand(r32C2).val);
                     exec_list *const f32C0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32C0->then_instructions;

                        body.emit(assign(r32BA, add(r32BA, body.constant(int(8))), 0x01));

                        body.emit(assign(r32B8, lshift(r32B8, body.constant(int(8))), 0x01));


                     body.instructions = f32C0_parent_instructions;
                     body.emit(f32C0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32C4 = bit_and(r32B8, body.constant(4026531840u));
                     ir_expression *const r32C5 = equal(r32C4, body.constant(0u));
                     ir_if *f32C3 = new(mem_ctx) ir_if(operand(r32C5).val);
                     exec_list *const f32C3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32C3->then_instructions;

                        body.emit(assign(r32BA, add(r32BA, body.constant(int(4))), 0x01));

                        body.emit(assign(r32B8, lshift(r32B8, body.constant(int(4))), 0x01));


                     body.instructions = f32C3_parent_instructions;
                     body.emit(f32C3);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32C7 = bit_and(r32B8, body.constant(3221225472u));
                     ir_expression *const r32C8 = equal(r32C7, body.constant(0u));
                     ir_if *f32C6 = new(mem_ctx) ir_if(operand(r32C8).val);
                     exec_list *const f32C6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32C6->then_instructions;

                        body.emit(assign(r32BA, add(r32BA, body.constant(int(2))), 0x01));

                        body.emit(assign(r32B8, lshift(r32B8, body.constant(int(2))), 0x01));


                     body.instructions = f32C6_parent_instructions;
                     body.emit(f32C6);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32CA = bit_and(r32B8, body.constant(2147483648u));
                     ir_expression *const r32CB = equal(r32CA, body.constant(0u));
                     ir_if *f32C9 = new(mem_ctx) ir_if(operand(r32CB).val);
                     exec_list *const f32C9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32C9->then_instructions;

                        body.emit(assign(r32BA, add(r32BA, body.constant(int(1))), 0x01));


                     body.instructions = f32C9_parent_instructions;
                     body.emit(f32C9);

                     /* END IF */

                     body.emit(assign(r32B9, r32BA, 0x01));


                  body.instructions = f32BB_parent_instructions;
                  body.emit(f32BB);

                  /* END IF */

                  body.emit(assign(r32B5, add(r32B9, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r32CD = less(r32B5, body.constant(int(0)));
                  ir_if *f32CC = new(mem_ctx) ir_if(operand(r32CD).val);
                  exec_list *const f32CC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32CC->then_instructions;

                     ir_expression *const r32CE = neg(r32B5);
                     body.emit(assign(r32B3, rshift(swizzle_x(r321E), r32CE), 0x01));

                     ir_expression *const r32CF = bit_and(r32B5, body.constant(int(31)));
                     body.emit(assign(r32B4, lshift(swizzle_x(r321E), r32CF), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32CC->else_instructions;

                     body.emit(assign(r32B3, lshift(swizzle_x(r321E), r32B5), 0x01));

                     body.emit(assign(r32B4, body.constant(0u), 0x01));


                  body.instructions = f32CC_parent_instructions;
                  body.emit(f32CC);

                  /* END IF */

                  body.emit(assign(r32B2, sub(body.constant(int(-31)), r32B5), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32B6->else_instructions;

                  ir_variable *const r32D0 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r32D0, r3232, 0x01));

                  ir_variable *const r32D1 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r32D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r32D2);
                  /* IF CONDITION */
                  ir_expression *const r32D4 = equal(r3232, body.constant(0u));
                  ir_if *f32D3 = new(mem_ctx) ir_if(operand(r32D4).val);
                  exec_list *const f32D3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32D3->then_instructions;

                     body.emit(assign(r32D1, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32D3->else_instructions;

                     body.emit(assign(r32D2, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r32D6 = bit_and(r3232, body.constant(4294901760u));
                     ir_expression *const r32D7 = equal(r32D6, body.constant(0u));
                     ir_if *f32D5 = new(mem_ctx) ir_if(operand(r32D7).val);
                     exec_list *const f32D5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32D5->then_instructions;

                        body.emit(assign(r32D2, body.constant(int(16)), 0x01));

                        body.emit(assign(r32D0, lshift(r3232, body.constant(int(16))), 0x01));


                     body.instructions = f32D5_parent_instructions;
                     body.emit(f32D5);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32D9 = bit_and(r32D0, body.constant(4278190080u));
                     ir_expression *const r32DA = equal(r32D9, body.constant(0u));
                     ir_if *f32D8 = new(mem_ctx) ir_if(operand(r32DA).val);
                     exec_list *const f32D8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32D8->then_instructions;

                        body.emit(assign(r32D2, add(r32D2, body.constant(int(8))), 0x01));

                        body.emit(assign(r32D0, lshift(r32D0, body.constant(int(8))), 0x01));


                     body.instructions = f32D8_parent_instructions;
                     body.emit(f32D8);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32DC = bit_and(r32D0, body.constant(4026531840u));
                     ir_expression *const r32DD = equal(r32DC, body.constant(0u));
                     ir_if *f32DB = new(mem_ctx) ir_if(operand(r32DD).val);
                     exec_list *const f32DB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32DB->then_instructions;

                        body.emit(assign(r32D2, add(r32D2, body.constant(int(4))), 0x01));

                        body.emit(assign(r32D0, lshift(r32D0, body.constant(int(4))), 0x01));


                     body.instructions = f32DB_parent_instructions;
                     body.emit(f32DB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32DF = bit_and(r32D0, body.constant(3221225472u));
                     ir_expression *const r32E0 = equal(r32DF, body.constant(0u));
                     ir_if *f32DE = new(mem_ctx) ir_if(operand(r32E0).val);
                     exec_list *const f32DE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32DE->then_instructions;

                        body.emit(assign(r32D2, add(r32D2, body.constant(int(2))), 0x01));

                        body.emit(assign(r32D0, lshift(r32D0, body.constant(int(2))), 0x01));


                     body.instructions = f32DE_parent_instructions;
                     body.emit(f32DE);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32E2 = bit_and(r32D0, body.constant(2147483648u));
                     ir_expression *const r32E3 = equal(r32E2, body.constant(0u));
                     ir_if *f32E1 = new(mem_ctx) ir_if(operand(r32E3).val);
                     exec_list *const f32E1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32E1->then_instructions;

                        body.emit(assign(r32D2, add(r32D2, body.constant(int(1))), 0x01));


                     body.instructions = f32E1_parent_instructions;
                     body.emit(f32E1);

                     /* END IF */

                     body.emit(assign(r32D1, r32D2, 0x01));


                  body.instructions = f32D3_parent_instructions;
                  body.emit(f32D3);

                  /* END IF */

                  body.emit(assign(r32B5, add(r32D1, body.constant(int(-11))), 0x01));

                  ir_variable *const r32E4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r32E4, lshift(swizzle_x(r321E), r32B5), 0x01));

                  ir_variable *const r32E5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r32E7 = equal(r32B5, body.constant(int(0)));
                  ir_if *f32E6 = new(mem_ctx) ir_if(operand(r32E7).val);
                  exec_list *const f32E6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32E6->then_instructions;

                     body.emit(assign(r32E5, r3232, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32E6->else_instructions;

                     ir_expression *const r32E8 = lshift(r3232, r32B5);
                     ir_expression *const r32E9 = neg(r32B5);
                     ir_expression *const r32EA = bit_and(r32E9, body.constant(int(31)));
                     ir_expression *const r32EB = rshift(swizzle_x(r321E), r32EA);
                     body.emit(assign(r32E5, bit_or(r32E8, r32EB), 0x01));


                  body.instructions = f32E6_parent_instructions;
                  body.emit(f32E6);

                  /* END IF */

                  body.emit(assign(r32B3, r32E5, 0x01));

                  body.emit(assign(r32B4, r32E4, 0x01));

                  body.emit(assign(r32B2, sub(body.constant(int(1)), r32B5), 0x01));


               body.instructions = f32B6_parent_instructions;
               body.emit(f32B6);

               /* END IF */

               body.emit(assign(r3222, r32B2, 0x01));

               body.emit(assign(r3224, r32B3, 0x01));

               body.emit(assign(r3225, r32B4, 0x01));


            body.instructions = f32A7_parent_instructions;
            body.emit(f32A7);

            /* END IF */


         body.instructions = f32A5_parent_instructions;
         body.emit(f32A5);

         /* END IF */

         /* IF CONDITION */
         ir_if *f32EC = new(mem_ctx) ir_if(operand(r321F).val);
         exec_list *const f32EC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f32EC->then_instructions;

            /* IF CONDITION */
            ir_expression *const r32EE = equal(r3233, body.constant(int(0)));
            ir_if *f32ED = new(mem_ctx) ir_if(operand(r32EE).val);
            exec_list *const f32ED_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f32ED->then_instructions;

               /* IF CONDITION */
               ir_expression *const r32F0 = bit_or(r3230, swizzle_x(r321D));
               ir_expression *const r32F1 = equal(r32F0, body.constant(0u));
               ir_if *f32EF = new(mem_ctx) ir_if(operand(r32F1).val);
               exec_list *const f32EF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32EF->then_instructions;

                  ir_variable *const r32F2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r32F2);
                  body.emit(assign(r32F2, lshift(r3221, body.constant(int(31))), 0x02));

                  body.emit(assign(r32F2, body.constant(0u), 0x01));

                  body.emit(assign(r3220, r32F2, 0x03));

                  body.emit(assign(r321F, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32EF->else_instructions;

                  ir_variable *const r32F3 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r32F3, r3233, 0x01));

                  ir_variable *const r32F4 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r32F4, r3230, 0x01));

                  ir_variable *const r32F5 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r32F5, r322F, 0x01));

                  ir_variable *const r32F6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r32F6);
                  /* IF CONDITION */
                  ir_expression *const r32F8 = equal(r3230, body.constant(0u));
                  ir_if *f32F7 = new(mem_ctx) ir_if(operand(r32F8).val);
                  exec_list *const f32F7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32F7->then_instructions;

                     ir_variable *const r32F9 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r32F9, r322F, 0x01));

                     ir_variable *const r32FA = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r32FB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r32FB);
                     /* IF CONDITION */
                     ir_expression *const r32FD = equal(swizzle_x(r321D), body.constant(0u));
                     ir_if *f32FC = new(mem_ctx) ir_if(operand(r32FD).val);
                     exec_list *const f32FC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32FC->then_instructions;

                        body.emit(assign(r32FA, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f32FC->else_instructions;

                        body.emit(assign(r32FB, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r32FF = bit_and(swizzle_x(r321D), body.constant(4294901760u));
                        ir_expression *const r3300 = equal(r32FF, body.constant(0u));
                        ir_if *f32FE = new(mem_ctx) ir_if(operand(r3300).val);
                        exec_list *const f32FE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f32FE->then_instructions;

                           body.emit(assign(r32FB, body.constant(int(16)), 0x01));

                           body.emit(assign(r32F9, lshift(swizzle_x(r321D), body.constant(int(16))), 0x01));


                        body.instructions = f32FE_parent_instructions;
                        body.emit(f32FE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3302 = bit_and(r32F9, body.constant(4278190080u));
                        ir_expression *const r3303 = equal(r3302, body.constant(0u));
                        ir_if *f3301 = new(mem_ctx) ir_if(operand(r3303).val);
                        exec_list *const f3301_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3301->then_instructions;

                           body.emit(assign(r32FB, add(r32FB, body.constant(int(8))), 0x01));

                           body.emit(assign(r32F9, lshift(r32F9, body.constant(int(8))), 0x01));


                        body.instructions = f3301_parent_instructions;
                        body.emit(f3301);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3305 = bit_and(r32F9, body.constant(4026531840u));
                        ir_expression *const r3306 = equal(r3305, body.constant(0u));
                        ir_if *f3304 = new(mem_ctx) ir_if(operand(r3306).val);
                        exec_list *const f3304_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3304->then_instructions;

                           body.emit(assign(r32FB, add(r32FB, body.constant(int(4))), 0x01));

                           body.emit(assign(r32F9, lshift(r32F9, body.constant(int(4))), 0x01));


                        body.instructions = f3304_parent_instructions;
                        body.emit(f3304);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3308 = bit_and(r32F9, body.constant(3221225472u));
                        ir_expression *const r3309 = equal(r3308, body.constant(0u));
                        ir_if *f3307 = new(mem_ctx) ir_if(operand(r3309).val);
                        exec_list *const f3307_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3307->then_instructions;

                           body.emit(assign(r32FB, add(r32FB, body.constant(int(2))), 0x01));

                           body.emit(assign(r32F9, lshift(r32F9, body.constant(int(2))), 0x01));


                        body.instructions = f3307_parent_instructions;
                        body.emit(f3307);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r330B = bit_and(r32F9, body.constant(2147483648u));
                        ir_expression *const r330C = equal(r330B, body.constant(0u));
                        ir_if *f330A = new(mem_ctx) ir_if(operand(r330C).val);
                        exec_list *const f330A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f330A->then_instructions;

                           body.emit(assign(r32FB, add(r32FB, body.constant(int(1))), 0x01));


                        body.instructions = f330A_parent_instructions;
                        body.emit(f330A);

                        /* END IF */

                        body.emit(assign(r32FA, r32FB, 0x01));


                     body.instructions = f32FC_parent_instructions;
                     body.emit(f32FC);

                     /* END IF */

                     body.emit(assign(r32F6, add(r32FA, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r330E = less(r32F6, body.constant(int(0)));
                     ir_if *f330D = new(mem_ctx) ir_if(operand(r330E).val);
                     exec_list *const f330D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f330D->then_instructions;

                        ir_expression *const r330F = neg(r32F6);
                        body.emit(assign(r32F4, rshift(swizzle_x(r321D), r330F), 0x01));

                        ir_expression *const r3310 = bit_and(r32F6, body.constant(int(31)));
                        body.emit(assign(r32F5, lshift(swizzle_x(r321D), r3310), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f330D->else_instructions;

                        body.emit(assign(r32F4, lshift(swizzle_x(r321D), r32F6), 0x01));

                        body.emit(assign(r32F5, body.constant(0u), 0x01));


                     body.instructions = f330D_parent_instructions;
                     body.emit(f330D);

                     /* END IF */

                     body.emit(assign(r32F3, sub(body.constant(int(-31)), r32F6), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32F7->else_instructions;

                     ir_variable *const r3311 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3311, r3230, 0x01));

                     ir_variable *const r3312 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3313 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3313);
                     /* IF CONDITION */
                     ir_expression *const r3315 = equal(r3230, body.constant(0u));
                     ir_if *f3314 = new(mem_ctx) ir_if(operand(r3315).val);
                     exec_list *const f3314_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3314->then_instructions;

                        body.emit(assign(r3312, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3314->else_instructions;

                        body.emit(assign(r3313, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3317 = bit_and(r3230, body.constant(4294901760u));
                        ir_expression *const r3318 = equal(r3317, body.constant(0u));
                        ir_if *f3316 = new(mem_ctx) ir_if(operand(r3318).val);
                        exec_list *const f3316_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3316->then_instructions;

                           body.emit(assign(r3313, body.constant(int(16)), 0x01));

                           body.emit(assign(r3311, lshift(r3230, body.constant(int(16))), 0x01));


                        body.instructions = f3316_parent_instructions;
                        body.emit(f3316);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r331A = bit_and(r3311, body.constant(4278190080u));
                        ir_expression *const r331B = equal(r331A, body.constant(0u));
                        ir_if *f3319 = new(mem_ctx) ir_if(operand(r331B).val);
                        exec_list *const f3319_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3319->then_instructions;

                           body.emit(assign(r3313, add(r3313, body.constant(int(8))), 0x01));

                           body.emit(assign(r3311, lshift(r3311, body.constant(int(8))), 0x01));


                        body.instructions = f3319_parent_instructions;
                        body.emit(f3319);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r331D = bit_and(r3311, body.constant(4026531840u));
                        ir_expression *const r331E = equal(r331D, body.constant(0u));
                        ir_if *f331C = new(mem_ctx) ir_if(operand(r331E).val);
                        exec_list *const f331C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f331C->then_instructions;

                           body.emit(assign(r3313, add(r3313, body.constant(int(4))), 0x01));

                           body.emit(assign(r3311, lshift(r3311, body.constant(int(4))), 0x01));


                        body.instructions = f331C_parent_instructions;
                        body.emit(f331C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3320 = bit_and(r3311, body.constant(3221225472u));
                        ir_expression *const r3321 = equal(r3320, body.constant(0u));
                        ir_if *f331F = new(mem_ctx) ir_if(operand(r3321).val);
                        exec_list *const f331F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f331F->then_instructions;

                           body.emit(assign(r3313, add(r3313, body.constant(int(2))), 0x01));

                           body.emit(assign(r3311, lshift(r3311, body.constant(int(2))), 0x01));


                        body.instructions = f331F_parent_instructions;
                        body.emit(f331F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3323 = bit_and(r3311, body.constant(2147483648u));
                        ir_expression *const r3324 = equal(r3323, body.constant(0u));
                        ir_if *f3322 = new(mem_ctx) ir_if(operand(r3324).val);
                        exec_list *const f3322_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3322->then_instructions;

                           body.emit(assign(r3313, add(r3313, body.constant(int(1))), 0x01));


                        body.instructions = f3322_parent_instructions;
                        body.emit(f3322);

                        /* END IF */

                        body.emit(assign(r3312, r3313, 0x01));


                     body.instructions = f3314_parent_instructions;
                     body.emit(f3314);

                     /* END IF */

                     body.emit(assign(r32F6, add(r3312, body.constant(int(-11))), 0x01));

                     ir_variable *const r3325 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3325, lshift(swizzle_x(r321D), r32F6), 0x01));

                     ir_variable *const r3326 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3328 = equal(r32F6, body.constant(int(0)));
                     ir_if *f3327 = new(mem_ctx) ir_if(operand(r3328).val);
                     exec_list *const f3327_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3327->then_instructions;

                        body.emit(assign(r3326, r3230, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3327->else_instructions;

                        ir_expression *const r3329 = lshift(r3230, r32F6);
                        ir_expression *const r332A = neg(r32F6);
                        ir_expression *const r332B = bit_and(r332A, body.constant(int(31)));
                        ir_expression *const r332C = rshift(swizzle_x(r321D), r332B);
                        body.emit(assign(r3326, bit_or(r3329, r332C), 0x01));


                     body.instructions = f3327_parent_instructions;
                     body.emit(f3327);

                     /* END IF */

                     body.emit(assign(r32F4, r3326, 0x01));

                     body.emit(assign(r32F5, r3325, 0x01));

                     body.emit(assign(r32F3, sub(body.constant(int(1)), r32F6), 0x01));


                  body.instructions = f32F7_parent_instructions;
                  body.emit(f32F7);

                  /* END IF */

                  body.emit(assign(r3223, r32F3, 0x01));

                  body.emit(assign(r3226, r32F4, 0x01));

                  body.emit(assign(r3227, r32F5, 0x01));


               body.instructions = f32EF_parent_instructions;
               body.emit(f32EF);

               /* END IF */


            body.instructions = f32ED_parent_instructions;
            body.emit(f32ED);

            /* END IF */

            /* IF CONDITION */
            ir_if *f332D = new(mem_ctx) ir_if(operand(r321F).val);
            exec_list *const f332D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f332D->then_instructions;

               ir_expression *const r332E = sub(r3223, r3222);
               body.emit(assign(r322E, add(r332E, body.constant(int(1021))), 0x01));

               ir_variable *const r332F = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r332F, lshift(r3227, body.constant(int(11))), 0x01));

               ir_variable *const r3330 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r3331 = bit_or(r3226, body.constant(1048576u));
               ir_expression *const r3332 = lshift(r3331, body.constant(int(11)));
               ir_expression *const r3333 = rshift(r3227, body.constant(int(21)));
               body.emit(assign(r3330, bit_or(r3332, r3333), 0x01));

               body.emit(assign(r3226, r3330, 0x01));

               body.emit(assign(r3227, r332F, 0x01));

               ir_variable *const r3334 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3334, lshift(r3225, body.constant(int(11))), 0x01));

               ir_variable *const r3335 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r3336 = bit_or(r3224, body.constant(1048576u));
               ir_expression *const r3337 = lshift(r3336, body.constant(int(11)));
               ir_expression *const r3338 = rshift(r3225, body.constant(int(21)));
               body.emit(assign(r3335, bit_or(r3337, r3338), 0x01));

               body.emit(assign(r3224, r3335, 0x01));

               body.emit(assign(r3225, r3334, 0x01));

               /* IF CONDITION */
               ir_expression *const r333A = less(r3335, r3330);
               ir_expression *const r333B = equal(r3335, r3330);
               ir_expression *const r333C = lequal(r3334, r332F);
               ir_expression *const r333D = logic_and(r333B, r333C);
               ir_expression *const r333E = logic_or(r333A, r333D);
               ir_if *f3339 = new(mem_ctx) ir_if(operand(r333E).val);
               exec_list *const f3339_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3339->then_instructions;

                  body.emit(assign(r3226, rshift(r3330, body.constant(int(1))), 0x01));

                  ir_expression *const r333F = lshift(r3330, body.constant(int(31)));
                  ir_expression *const r3340 = rshift(r332F, body.constant(int(1)));
                  body.emit(assign(r3227, bit_or(r333F, r3340), 0x01));

                  body.emit(assign(r322E, add(r322E, body.constant(int(1))), 0x01));


               body.instructions = f3339_parent_instructions;
               body.emit(f3339);

               /* END IF */

               ir_variable *const r3341 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r3342 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r3342);
               ir_variable *const r3343 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r3343);
               ir_variable *const r3344 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r3344);
               ir_variable *const r3345 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r3345);
               body.emit(assign(r3344, body.constant(0u), 0x01));

               body.emit(assign(r3343, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r3347 = lequal(r3335, r3226);
               ir_if *f3346 = new(mem_ctx) ir_if(operand(r3347).val);
               exec_list *const f3346_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3346->then_instructions;

                  body.emit(assign(r3341, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3346->else_instructions;

                  body.emit(assign(r3345, rshift(r3335, body.constant(int(16))), 0x01));

                  ir_variable *const r3348 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r334A = lshift(r3345, body.constant(int(16)));
                  ir_expression *const r334B = lequal(r334A, r3226);
                  ir_if *f3349 = new(mem_ctx) ir_if(operand(r334B).val);
                  exec_list *const f3349_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3349->then_instructions;

                     body.emit(assign(r3348, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3349->else_instructions;

                     ir_expression *const r334C = expr(ir_binop_div, r3226, r3345);
                     body.emit(assign(r3348, lshift(r334C, body.constant(int(16))), 0x01));


                  body.instructions = f3349_parent_instructions;
                  body.emit(f3349);

                  /* END IF */

                  body.emit(assign(r3342, r3348, 0x01));

                  ir_variable *const r334D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r334D);
                  ir_variable *const r334E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r334E);
                  ir_variable *const r334F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r334F);
                  ir_variable *const r3350 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3350, bit_and(r3335, body.constant(65535u)), 0x01));

                  ir_variable *const r3351 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3351, rshift(r3335, body.constant(int(16))), 0x01));

                  ir_variable *const r3352 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3352, bit_and(r3348, body.constant(65535u)), 0x01));

                  ir_variable *const r3353 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3353, rshift(r3348, body.constant(int(16))), 0x01));

                  ir_variable *const r3354 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3354, mul(r3351, r3352), 0x01));

                  ir_expression *const r3355 = mul(r3350, r3353);
                  body.emit(assign(r334E, add(r3355, r3354), 0x01));

                  ir_expression *const r3356 = mul(r3351, r3353);
                  ir_expression *const r3357 = less(r334E, r3354);
                  ir_expression *const r3358 = expr(ir_unop_b2i, r3357);
                  ir_expression *const r3359 = expr(ir_unop_i2u, r3358);
                  ir_expression *const r335A = lshift(r3359, body.constant(int(16)));
                  ir_expression *const r335B = rshift(r334E, body.constant(int(16)));
                  ir_expression *const r335C = add(r335A, r335B);
                  body.emit(assign(r334D, add(r3356, r335C), 0x01));

                  body.emit(assign(r334E, lshift(r334E, body.constant(int(16))), 0x01));

                  ir_expression *const r335D = mul(r3350, r3352);
                  body.emit(assign(r334F, add(r335D, r334E), 0x01));

                  ir_expression *const r335E = less(r334F, r334E);
                  ir_expression *const r335F = expr(ir_unop_b2i, r335E);
                  ir_expression *const r3360 = expr(ir_unop_i2u, r335F);
                  body.emit(assign(r334D, add(r334D, r3360), 0x01));

                  ir_expression *const r3361 = sub(r3226, r334D);
                  ir_expression *const r3362 = less(r3227, r334F);
                  ir_expression *const r3363 = expr(ir_unop_b2i, r3362);
                  ir_expression *const r3364 = expr(ir_unop_i2u, r3363);
                  body.emit(assign(r3344, sub(r3361, r3364), 0x01));

                  body.emit(assign(r3343, sub(r3227, r334F), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f3365 = new(mem_ctx) ir_loop();
                  exec_list *const f3365_parent_instructions = body.instructions;

                     body.instructions = &f3365->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3367 = expr(ir_unop_u2i, r3344);
                     ir_expression *const r3368 = gequal(r3367, body.constant(int(0)));
                     ir_if *f3366 = new(mem_ctx) ir_if(operand(r3368).val);
                     exec_list *const f3366_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3366->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f3366_parent_instructions;
                     body.emit(f3366);

                     /* END IF */

                     body.emit(assign(r3342, add(r3342, body.constant(4294901760u)), 0x01));

                     ir_variable *const r3369 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r336A = lshift(r3335, body.constant(int(16)));
                     body.emit(assign(r3369, add(r3343, r336A), 0x01));

                     ir_expression *const r336B = add(r3344, r3345);
                     ir_expression *const r336C = less(r3369, r3343);
                     ir_expression *const r336D = expr(ir_unop_b2i, r336C);
                     ir_expression *const r336E = expr(ir_unop_i2u, r336D);
                     body.emit(assign(r3344, add(r336B, r336E), 0x01));

                     body.emit(assign(r3343, r3369, 0x01));

                  /* LOOP END */

                  body.instructions = f3365_parent_instructions;
                  body.emit(f3365);

                  ir_expression *const r336F = lshift(r3344, body.constant(int(16)));
                  ir_expression *const r3370 = rshift(r3343, body.constant(int(16)));
                  body.emit(assign(r3344, bit_or(r336F, r3370), 0x01));

                  ir_variable *const r3371 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3373 = lshift(r3345, body.constant(int(16)));
                  ir_expression *const r3374 = lequal(r3373, r3344);
                  ir_if *f3372 = new(mem_ctx) ir_if(operand(r3374).val);
                  exec_list *const f3372_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3372->then_instructions;

                     body.emit(assign(r3371, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3372->else_instructions;

                     body.emit(assign(r3371, expr(ir_binop_div, r3344, r3345), 0x01));


                  body.instructions = f3372_parent_instructions;
                  body.emit(f3372);

                  /* END IF */

                  body.emit(assign(r3342, bit_or(r3342, r3371), 0x01));

                  body.emit(assign(r3341, r3342, 0x01));


               body.instructions = f3346_parent_instructions;
               body.emit(f3346);

               /* END IF */

               body.emit(assign(r322D, r3341, 0x01));

               ir_variable *const r3375 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3375);
               ir_variable *const r3376 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3376);
               ir_variable *const r3377 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3377);
               ir_variable *const r3378 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3378, bit_and(r3334, body.constant(65535u)), 0x01));

               ir_variable *const r3379 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3379, rshift(r3334, body.constant(int(16))), 0x01));

               ir_variable *const r337A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r337A, bit_and(r3341, body.constant(65535u)), 0x01));

               ir_variable *const r337B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r337B, rshift(r3341, body.constant(int(16))), 0x01));

               ir_variable *const r337C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r337C, mul(r3379, r337A), 0x01));

               ir_expression *const r337D = mul(r3378, r337B);
               body.emit(assign(r3376, add(r337D, r337C), 0x01));

               ir_expression *const r337E = mul(r3379, r337B);
               ir_expression *const r337F = less(r3376, r337C);
               ir_expression *const r3380 = expr(ir_unop_b2i, r337F);
               ir_expression *const r3381 = expr(ir_unop_i2u, r3380);
               ir_expression *const r3382 = lshift(r3381, body.constant(int(16)));
               ir_expression *const r3383 = rshift(r3376, body.constant(int(16)));
               ir_expression *const r3384 = add(r3382, r3383);
               body.emit(assign(r3375, add(r337E, r3384), 0x01));

               body.emit(assign(r3376, lshift(r3376, body.constant(int(16))), 0x01));

               ir_expression *const r3385 = mul(r3378, r337A);
               body.emit(assign(r3377, add(r3385, r3376), 0x01));

               ir_expression *const r3386 = less(r3377, r3376);
               ir_expression *const r3387 = expr(ir_unop_b2i, r3386);
               ir_expression *const r3388 = expr(ir_unop_i2u, r3387);
               body.emit(assign(r3375, add(r3375, r3388), 0x01));

               ir_variable *const r3389 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3389);
               ir_variable *const r338A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r338A);
               ir_variable *const r338B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r338B);
               ir_variable *const r338C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r338C, bit_and(r3335, body.constant(65535u)), 0x01));

               ir_variable *const r338D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r338D, rshift(r3335, body.constant(int(16))), 0x01));

               ir_variable *const r338E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r338E, bit_and(r3341, body.constant(65535u)), 0x01));

               ir_variable *const r338F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r338F, rshift(r3341, body.constant(int(16))), 0x01));

               ir_variable *const r3390 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3390, mul(r338D, r338E), 0x01));

               ir_expression *const r3391 = mul(r338C, r338F);
               body.emit(assign(r338A, add(r3391, r3390), 0x01));

               ir_expression *const r3392 = mul(r338D, r338F);
               ir_expression *const r3393 = less(r338A, r3390);
               ir_expression *const r3394 = expr(ir_unop_b2i, r3393);
               ir_expression *const r3395 = expr(ir_unop_i2u, r3394);
               ir_expression *const r3396 = lshift(r3395, body.constant(int(16)));
               ir_expression *const r3397 = rshift(r338A, body.constant(int(16)));
               ir_expression *const r3398 = add(r3396, r3397);
               body.emit(assign(r3389, add(r3392, r3398), 0x01));

               body.emit(assign(r338A, lshift(r338A, body.constant(int(16))), 0x01));

               ir_expression *const r3399 = mul(r338C, r338E);
               body.emit(assign(r338B, add(r3399, r338A), 0x01));

               ir_expression *const r339A = less(r338B, r338A);
               ir_expression *const r339B = expr(ir_unop_b2i, r339A);
               ir_expression *const r339C = expr(ir_unop_i2u, r339B);
               body.emit(assign(r3389, add(r3389, r339C), 0x01));

               ir_variable *const r339D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r339D, add(r338B, r3375), 0x01));

               ir_variable *const r339E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r339E);
               ir_variable *const r339F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r33A0 = less(body.constant(0u), r3377);
               ir_expression *const r33A1 = expr(ir_unop_b2i, r33A0);
               body.emit(assign(r339F, expr(ir_unop_i2u, r33A1), 0x01));

               ir_variable *const r33A2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33A2, sub(r3227, r339D), 0x01));

               ir_expression *const r33A3 = less(r339D, r338B);
               ir_expression *const r33A4 = expr(ir_unop_b2i, r33A3);
               ir_expression *const r33A5 = expr(ir_unop_i2u, r33A4);
               ir_expression *const r33A6 = add(r3389, r33A5);
               ir_expression *const r33A7 = sub(r3226, r33A6);
               ir_expression *const r33A8 = less(r33A2, r339F);
               ir_expression *const r33A9 = expr(ir_unop_b2i, r33A8);
               ir_expression *const r33AA = expr(ir_unop_i2u, r33A9);
               body.emit(assign(r339E, sub(r33A7, r33AA), 0x01));

               ir_expression *const r33AB = less(r3227, r339D);
               ir_expression *const r33AC = expr(ir_unop_b2i, r33AB);
               ir_expression *const r33AD = expr(ir_unop_i2u, r33AC);
               body.emit(assign(r339E, sub(r339E, r33AD), 0x01));

               body.emit(assign(r322B, r339E, 0x01));

               body.emit(assign(r322A, sub(r33A2, r339F), 0x01));

               body.emit(assign(r3229, neg(r3377), 0x01));

               /* LOOP BEGIN */
               ir_loop *f33AE = new(mem_ctx) ir_loop();
               exec_list *const f33AE_parent_instructions = body.instructions;

                  body.instructions = &f33AE->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r33B0 = expr(ir_unop_u2i, r322B);
                  ir_expression *const r33B1 = gequal(r33B0, body.constant(int(0)));
                  ir_if *f33AF = new(mem_ctx) ir_if(operand(r33B1).val);
                  exec_list *const f33AF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33AF->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f33AF_parent_instructions;
                  body.emit(f33AF);

                  /* END IF */

                  body.emit(assign(r322D, add(r322D, body.constant(4294967295u)), 0x01));

                  ir_variable *const r33B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r33B2);
                  ir_variable *const r33B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r33B3);
                  ir_variable *const r33B4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33B4, add(r3229, r3334), 0x01));

                  ir_variable *const r33B5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r33B6 = less(r33B4, r3229);
                  ir_expression *const r33B7 = expr(ir_unop_b2i, r33B6);
                  body.emit(assign(r33B5, expr(ir_unop_i2u, r33B7), 0x01));

                  ir_variable *const r33B8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33B8, add(r322A, r3335), 0x01));

                  body.emit(assign(r33B3, add(r33B8, r33B5), 0x01));

                  ir_expression *const r33B9 = less(r33B3, r33B5);
                  ir_expression *const r33BA = expr(ir_unop_b2i, r33B9);
                  ir_expression *const r33BB = expr(ir_unop_i2u, r33BA);
                  body.emit(assign(r33B2, add(r322B, r33BB), 0x01));

                  ir_expression *const r33BC = less(r33B8, r322A);
                  ir_expression *const r33BD = expr(ir_unop_b2i, r33BC);
                  ir_expression *const r33BE = expr(ir_unop_i2u, r33BD);
                  body.emit(assign(r33B2, add(r33B2, r33BE), 0x01));

                  body.emit(assign(r322B, r33B2, 0x01));

                  body.emit(assign(r322A, r33B3, 0x01));

                  body.emit(assign(r3229, r33B4, 0x01));

               /* LOOP END */

               body.instructions = f33AE_parent_instructions;
               body.emit(f33AE);

               ir_variable *const r33BF = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r33C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r33C0);
               ir_variable *const r33C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r33C1);
               ir_variable *const r33C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r33C2);
               ir_variable *const r33C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r33C3);
               body.emit(assign(r33C2, body.constant(0u), 0x01));

               body.emit(assign(r33C1, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r33C5 = lequal(r3335, r322A);
               ir_if *f33C4 = new(mem_ctx) ir_if(operand(r33C5).val);
               exec_list *const f33C4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f33C4->then_instructions;

                  body.emit(assign(r33BF, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f33C4->else_instructions;

                  body.emit(assign(r33C3, rshift(r3335, body.constant(int(16))), 0x01));

                  ir_variable *const r33C6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r33C8 = lshift(r33C3, body.constant(int(16)));
                  ir_expression *const r33C9 = lequal(r33C8, r322A);
                  ir_if *f33C7 = new(mem_ctx) ir_if(operand(r33C9).val);
                  exec_list *const f33C7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33C7->then_instructions;

                     body.emit(assign(r33C6, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f33C7->else_instructions;

                     ir_expression *const r33CA = expr(ir_binop_div, r322A, r33C3);
                     body.emit(assign(r33C6, lshift(r33CA, body.constant(int(16))), 0x01));


                  body.instructions = f33C7_parent_instructions;
                  body.emit(f33C7);

                  /* END IF */

                  body.emit(assign(r33C0, r33C6, 0x01));

                  ir_variable *const r33CB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r33CB);
                  ir_variable *const r33CC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r33CC);
                  ir_variable *const r33CD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r33CD);
                  ir_variable *const r33CE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33CE, bit_and(r3335, body.constant(65535u)), 0x01));

                  ir_variable *const r33CF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33CF, rshift(r3335, body.constant(int(16))), 0x01));

                  ir_variable *const r33D0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33D0, bit_and(r33C6, body.constant(65535u)), 0x01));

                  ir_variable *const r33D1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33D1, rshift(r33C6, body.constant(int(16))), 0x01));

                  ir_variable *const r33D2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33D2, mul(r33CF, r33D0), 0x01));

                  ir_expression *const r33D3 = mul(r33CE, r33D1);
                  body.emit(assign(r33CC, add(r33D3, r33D2), 0x01));

                  ir_expression *const r33D4 = mul(r33CF, r33D1);
                  ir_expression *const r33D5 = less(r33CC, r33D2);
                  ir_expression *const r33D6 = expr(ir_unop_b2i, r33D5);
                  ir_expression *const r33D7 = expr(ir_unop_i2u, r33D6);
                  ir_expression *const r33D8 = lshift(r33D7, body.constant(int(16)));
                  ir_expression *const r33D9 = rshift(r33CC, body.constant(int(16)));
                  ir_expression *const r33DA = add(r33D8, r33D9);
                  body.emit(assign(r33CB, add(r33D4, r33DA), 0x01));

                  body.emit(assign(r33CC, lshift(r33CC, body.constant(int(16))), 0x01));

                  ir_expression *const r33DB = mul(r33CE, r33D0);
                  body.emit(assign(r33CD, add(r33DB, r33CC), 0x01));

                  ir_expression *const r33DC = less(r33CD, r33CC);
                  ir_expression *const r33DD = expr(ir_unop_b2i, r33DC);
                  ir_expression *const r33DE = expr(ir_unop_i2u, r33DD);
                  body.emit(assign(r33CB, add(r33CB, r33DE), 0x01));

                  ir_expression *const r33DF = sub(r322A, r33CB);
                  ir_expression *const r33E0 = less(r3229, r33CD);
                  ir_expression *const r33E1 = expr(ir_unop_b2i, r33E0);
                  ir_expression *const r33E2 = expr(ir_unop_i2u, r33E1);
                  body.emit(assign(r33C2, sub(r33DF, r33E2), 0x01));

                  body.emit(assign(r33C1, sub(r3229, r33CD), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f33E3 = new(mem_ctx) ir_loop();
                  exec_list *const f33E3_parent_instructions = body.instructions;

                     body.instructions = &f33E3->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r33E5 = expr(ir_unop_u2i, r33C2);
                     ir_expression *const r33E6 = gequal(r33E5, body.constant(int(0)));
                     ir_if *f33E4 = new(mem_ctx) ir_if(operand(r33E6).val);
                     exec_list *const f33E4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f33E4->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f33E4_parent_instructions;
                     body.emit(f33E4);

                     /* END IF */

                     body.emit(assign(r33C0, add(r33C0, body.constant(4294901760u)), 0x01));

                     ir_variable *const r33E7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r33E8 = lshift(r3335, body.constant(int(16)));
                     body.emit(assign(r33E7, add(r33C1, r33E8), 0x01));

                     ir_expression *const r33E9 = add(r33C2, r33C3);
                     ir_expression *const r33EA = less(r33E7, r33C1);
                     ir_expression *const r33EB = expr(ir_unop_b2i, r33EA);
                     ir_expression *const r33EC = expr(ir_unop_i2u, r33EB);
                     body.emit(assign(r33C2, add(r33E9, r33EC), 0x01));

                     body.emit(assign(r33C1, r33E7, 0x01));

                  /* LOOP END */

                  body.instructions = f33E3_parent_instructions;
                  body.emit(f33E3);

                  ir_expression *const r33ED = lshift(r33C2, body.constant(int(16)));
                  ir_expression *const r33EE = rshift(r33C1, body.constant(int(16)));
                  body.emit(assign(r33C2, bit_or(r33ED, r33EE), 0x01));

                  ir_variable *const r33EF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r33F1 = lshift(r33C3, body.constant(int(16)));
                  ir_expression *const r33F2 = lequal(r33F1, r33C2);
                  ir_if *f33F0 = new(mem_ctx) ir_if(operand(r33F2).val);
                  exec_list *const f33F0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33F0->then_instructions;

                     body.emit(assign(r33EF, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f33F0->else_instructions;

                     body.emit(assign(r33EF, expr(ir_binop_div, r33C2, r33C3), 0x01));


                  body.instructions = f33F0_parent_instructions;
                  body.emit(f33F0);

                  /* END IF */

                  body.emit(assign(r33C0, bit_or(r33C0, r33EF), 0x01));

                  body.emit(assign(r33BF, r33C0, 0x01));


               body.instructions = f33C4_parent_instructions;
               body.emit(f33C4);

               /* END IF */

               body.emit(assign(r322C, r33BF, 0x01));

               /* IF CONDITION */
               ir_expression *const r33F4 = bit_and(r33BF, body.constant(1023u));
               ir_expression *const r33F5 = lequal(r33F4, body.constant(4u));
               ir_if *f33F3 = new(mem_ctx) ir_if(operand(r33F5).val);
               exec_list *const f33F3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f33F3->then_instructions;

                  ir_variable *const r33F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r33F6);
                  ir_variable *const r33F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r33F7);
                  ir_variable *const r33F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r33F8);
                  ir_variable *const r33F9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33F9, bit_and(r3334, body.constant(65535u)), 0x01));

                  ir_variable *const r33FA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33FA, rshift(r3334, body.constant(int(16))), 0x01));

                  ir_variable *const r33FB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33FB, bit_and(r33BF, body.constant(65535u)), 0x01));

                  ir_variable *const r33FC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33FC, rshift(r33BF, body.constant(int(16))), 0x01));

                  ir_variable *const r33FD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33FD, mul(r33FA, r33FB), 0x01));

                  ir_expression *const r33FE = mul(r33F9, r33FC);
                  body.emit(assign(r33F7, add(r33FE, r33FD), 0x01));

                  ir_expression *const r33FF = mul(r33FA, r33FC);
                  ir_expression *const r3400 = less(r33F7, r33FD);
                  ir_expression *const r3401 = expr(ir_unop_b2i, r3400);
                  ir_expression *const r3402 = expr(ir_unop_i2u, r3401);
                  ir_expression *const r3403 = lshift(r3402, body.constant(int(16)));
                  ir_expression *const r3404 = rshift(r33F7, body.constant(int(16)));
                  ir_expression *const r3405 = add(r3403, r3404);
                  body.emit(assign(r33F6, add(r33FF, r3405), 0x01));

                  body.emit(assign(r33F7, lshift(r33F7, body.constant(int(16))), 0x01));

                  ir_expression *const r3406 = mul(r33F9, r33FB);
                  body.emit(assign(r33F8, add(r3406, r33F7), 0x01));

                  ir_expression *const r3407 = less(r33F8, r33F7);
                  ir_expression *const r3408 = expr(ir_unop_b2i, r3407);
                  ir_expression *const r3409 = expr(ir_unop_i2u, r3408);
                  body.emit(assign(r33F6, add(r33F6, r3409), 0x01));

                  ir_variable *const r340A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r340A);
                  ir_variable *const r340B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r340B);
                  ir_variable *const r340C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r340C);
                  ir_variable *const r340D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r340D, bit_and(r3335, body.constant(65535u)), 0x01));

                  ir_variable *const r340E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r340E, rshift(r3335, body.constant(int(16))), 0x01));

                  ir_variable *const r340F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r340F, bit_and(r33BF, body.constant(65535u)), 0x01));

                  ir_variable *const r3410 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3410, rshift(r33BF, body.constant(int(16))), 0x01));

                  ir_variable *const r3411 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3411, mul(r340E, r340F), 0x01));

                  ir_expression *const r3412 = mul(r340D, r3410);
                  body.emit(assign(r340B, add(r3412, r3411), 0x01));

                  ir_expression *const r3413 = mul(r340E, r3410);
                  ir_expression *const r3414 = less(r340B, r3411);
                  ir_expression *const r3415 = expr(ir_unop_b2i, r3414);
                  ir_expression *const r3416 = expr(ir_unop_i2u, r3415);
                  ir_expression *const r3417 = lshift(r3416, body.constant(int(16)));
                  ir_expression *const r3418 = rshift(r340B, body.constant(int(16)));
                  ir_expression *const r3419 = add(r3417, r3418);
                  body.emit(assign(r340A, add(r3413, r3419), 0x01));

                  body.emit(assign(r340B, lshift(r340B, body.constant(int(16))), 0x01));

                  ir_expression *const r341A = mul(r340D, r340F);
                  body.emit(assign(r340C, add(r341A, r340B), 0x01));

                  ir_expression *const r341B = less(r340C, r340B);
                  ir_expression *const r341C = expr(ir_unop_b2i, r341B);
                  ir_expression *const r341D = expr(ir_unop_i2u, r341C);
                  body.emit(assign(r340A, add(r340A, r341D), 0x01));

                  ir_variable *const r341E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r341E, add(r340C, r33F6), 0x01));

                  ir_variable *const r341F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r341F);
                  ir_variable *const r3420 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r3421 = less(body.constant(0u), r33F8);
                  ir_expression *const r3422 = expr(ir_unop_b2i, r3421);
                  body.emit(assign(r3420, expr(ir_unop_i2u, r3422), 0x01));

                  ir_variable *const r3423 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3423, sub(r3229, r341E), 0x01));

                  ir_expression *const r3424 = less(r341E, r340C);
                  ir_expression *const r3425 = expr(ir_unop_b2i, r3424);
                  ir_expression *const r3426 = expr(ir_unop_i2u, r3425);
                  ir_expression *const r3427 = add(r340A, r3426);
                  ir_expression *const r3428 = sub(r322A, r3427);
                  ir_expression *const r3429 = less(r3423, r3420);
                  ir_expression *const r342A = expr(ir_unop_b2i, r3429);
                  ir_expression *const r342B = expr(ir_unop_i2u, r342A);
                  body.emit(assign(r341F, sub(r3428, r342B), 0x01));

                  ir_expression *const r342C = less(r3229, r341E);
                  ir_expression *const r342D = expr(ir_unop_b2i, r342C);
                  ir_expression *const r342E = expr(ir_unop_i2u, r342D);
                  body.emit(assign(r341F, sub(r341F, r342E), 0x01));

                  body.emit(assign(r322A, r341F, 0x01));

                  body.emit(assign(r3229, sub(r3423, r3420), 0x01));

                  body.emit(assign(r3228, neg(r33F8), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f342F = new(mem_ctx) ir_loop();
                  exec_list *const f342F_parent_instructions = body.instructions;

                     body.instructions = &f342F->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3431 = expr(ir_unop_u2i, r322A);
                     ir_expression *const r3432 = gequal(r3431, body.constant(int(0)));
                     ir_if *f3430 = new(mem_ctx) ir_if(operand(r3432).val);
                     exec_list *const f3430_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3430->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f3430_parent_instructions;
                     body.emit(f3430);

                     /* END IF */

                     body.emit(assign(r322C, add(r322C, body.constant(4294967295u)), 0x01));

                     ir_variable *const r3433 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3433);
                     ir_variable *const r3434 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3434);
                     ir_variable *const r3435 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3435, add(r3228, r3334), 0x01));

                     ir_variable *const r3436 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r3437 = less(r3435, r3228);
                     ir_expression *const r3438 = expr(ir_unop_b2i, r3437);
                     body.emit(assign(r3436, expr(ir_unop_i2u, r3438), 0x01));

                     ir_variable *const r3439 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3439, add(r3229, r3335), 0x01));

                     body.emit(assign(r3434, add(r3439, r3436), 0x01));

                     ir_expression *const r343A = less(r3434, r3436);
                     ir_expression *const r343B = expr(ir_unop_b2i, r343A);
                     ir_expression *const r343C = expr(ir_unop_i2u, r343B);
                     body.emit(assign(r3433, add(r322A, r343C), 0x01));

                     ir_expression *const r343D = less(r3439, r3229);
                     ir_expression *const r343E = expr(ir_unop_b2i, r343D);
                     ir_expression *const r343F = expr(ir_unop_i2u, r343E);
                     body.emit(assign(r3433, add(r3433, r343F), 0x01));

                     body.emit(assign(r322A, r3433, 0x01));

                     body.emit(assign(r3229, r3434, 0x01));

                     body.emit(assign(r3228, r3435, 0x01));

                  /* LOOP END */

                  body.instructions = f342F_parent_instructions;
                  body.emit(f342F);

                  ir_expression *const r3440 = bit_or(r322A, r3229);
                  ir_expression *const r3441 = bit_or(r3440, r3228);
                  ir_expression *const r3442 = nequal(r3441, body.constant(0u));
                  ir_expression *const r3443 = expr(ir_unop_b2i, r3442);
                  ir_expression *const r3444 = expr(ir_unop_i2u, r3443);
                  body.emit(assign(r322C, bit_or(r322C, r3444), 0x01));


               body.instructions = f33F3_parent_instructions;
               body.emit(f33F3);

               /* END IF */

               ir_variable *const r3445 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r3445);
               ir_variable *const r3446 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3446);
               ir_variable *const r3447 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3447);
               body.emit(assign(r3445, lshift(r322C, body.constant(int(21))), 0x01));

               ir_expression *const r3448 = lshift(r322D, body.constant(int(21)));
               ir_expression *const r3449 = rshift(r322C, body.constant(int(11)));
               body.emit(assign(r3446, bit_or(r3448, r3449), 0x01));

               body.emit(assign(r3447, rshift(r322D, body.constant(int(11))), 0x01));

               body.emit(assign(r3445, bit_or(r3445, body.constant(0u)), 0x01));

               body.emit(assign(r322D, r3447, 0x01));

               body.emit(assign(r322C, r3446, 0x01));

               ir_variable *const r344A = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r344A, r322E, 0x01));

               ir_variable *const r344B = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r344B, r3447, 0x01));

               ir_variable *const r344C = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r344C, r3446, 0x01));

               ir_variable *const r344D = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r344D, r3445, 0x01));

               ir_variable *const r344E = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r344E, body.constant(true), 0x01));

               ir_variable *const r344F = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3450 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3450);
               ir_expression *const r3451 = expr(ir_unop_u2i, r3445);
               body.emit(assign(r3450, less(r3451, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3453 = lequal(body.constant(int(2045)), r322E);
               ir_if *f3452 = new(mem_ctx) ir_if(operand(r3453).val);
               exec_list *const f3452_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3452->then_instructions;

                  ir_variable *const r3454 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3456 = less(body.constant(int(2045)), r322E);
                  ir_if *f3455 = new(mem_ctx) ir_if(operand(r3456).val);
                  exec_list *const f3455_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3455->then_instructions;

                     body.emit(assign(r3454, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3455->else_instructions;

                     ir_variable *const r3457 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3459 = equal(r322E, body.constant(int(2045)));
                     ir_if *f3458 = new(mem_ctx) ir_if(operand(r3459).val);
                     exec_list *const f3458_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3458->then_instructions;

                        ir_expression *const r345A = equal(body.constant(2097151u), r3447);
                        ir_expression *const r345B = equal(body.constant(4294967295u), r3446);
                        body.emit(assign(r3457, logic_and(r345A, r345B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3458->else_instructions;

                        body.emit(assign(r3457, body.constant(false), 0x01));


                     body.instructions = f3458_parent_instructions;
                     body.emit(f3458);

                     /* END IF */

                     body.emit(assign(r3454, logic_and(r3457, r3450), 0x01));


                  body.instructions = f3455_parent_instructions;
                  body.emit(f3455);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f345C = new(mem_ctx) ir_if(operand(r3454).val);
                  exec_list *const f345C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f345C->then_instructions;

                     ir_variable *const r345D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r345D);
                     ir_expression *const r345E = lshift(r3221, body.constant(int(31)));
                     body.emit(assign(r345D, add(r345E, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r345D, body.constant(0u), 0x01));

                     body.emit(assign(r344F, r345D, 0x03));

                     body.emit(assign(r344E, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f345C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3460 = less(r322E, body.constant(int(0)));
                     ir_if *f345F = new(mem_ctx) ir_if(operand(r3460).val);
                     exec_list *const f345F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f345F->then_instructions;

                        ir_variable *const r3461 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3461, r3445, 0x01));

                        ir_variable *const r3462 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3462, neg(r322E), 0x01));

                        ir_variable *const r3463 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3463);
                        ir_variable *const r3464 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3464);
                        ir_variable *const r3465 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3465);
                        ir_variable *const r3466 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3467 = neg(r3462);
                        body.emit(assign(r3466, bit_and(r3467, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3469 = equal(r3462, body.constant(int(0)));
                        ir_if *f3468 = new(mem_ctx) ir_if(operand(r3469).val);
                        exec_list *const f3468_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3468->then_instructions;

                           body.emit(assign(r3463, r3445, 0x01));

                           body.emit(assign(r3464, r3446, 0x01));

                           body.emit(assign(r3465, r3447, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3468->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r346B = less(r3462, body.constant(int(32)));
                           ir_if *f346A = new(mem_ctx) ir_if(operand(r346B).val);
                           exec_list *const f346A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f346A->then_instructions;

                              body.emit(assign(r3463, lshift(r3446, r3466), 0x01));

                              ir_expression *const r346C = lshift(r3447, r3466);
                              ir_expression *const r346D = rshift(r3446, r3462);
                              body.emit(assign(r3464, bit_or(r346C, r346D), 0x01));

                              body.emit(assign(r3465, rshift(r3447, r3462), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f346A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r346F = equal(r3462, body.constant(int(32)));
                              ir_if *f346E = new(mem_ctx) ir_if(operand(r346F).val);
                              exec_list *const f346E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f346E->then_instructions;

                                 body.emit(assign(r3463, r3446, 0x01));

                                 body.emit(assign(r3464, r3447, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f346E->else_instructions;

                                 body.emit(assign(r3461, bit_or(r3445, r3446), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3471 = less(r3462, body.constant(int(64)));
                                 ir_if *f3470 = new(mem_ctx) ir_if(operand(r3471).val);
                                 exec_list *const f3470_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3470->then_instructions;

                                    body.emit(assign(r3463, lshift(r3447, r3466), 0x01));

                                    ir_expression *const r3472 = bit_and(r3462, body.constant(int(31)));
                                    body.emit(assign(r3464, rshift(r3447, r3472), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3470->else_instructions;

                                    ir_variable *const r3473 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3475 = equal(r3462, body.constant(int(64)));
                                    ir_if *f3474 = new(mem_ctx) ir_if(operand(r3475).val);
                                    exec_list *const f3474_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3474->then_instructions;

                                       body.emit(assign(r3473, r3447, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3474->else_instructions;

                                       ir_expression *const r3476 = nequal(r3447, body.constant(0u));
                                       ir_expression *const r3477 = expr(ir_unop_b2i, r3476);
                                       body.emit(assign(r3473, expr(ir_unop_i2u, r3477), 0x01));


                                    body.instructions = f3474_parent_instructions;
                                    body.emit(f3474);

                                    /* END IF */

                                    body.emit(assign(r3463, r3473, 0x01));

                                    body.emit(assign(r3464, body.constant(0u), 0x01));


                                 body.instructions = f3470_parent_instructions;
                                 body.emit(f3470);

                                 /* END IF */


                              body.instructions = f346E_parent_instructions;
                              body.emit(f346E);

                              /* END IF */

                              body.emit(assign(r3465, body.constant(0u), 0x01));


                           body.instructions = f346A_parent_instructions;
                           body.emit(f346A);

                           /* END IF */

                           ir_expression *const r3478 = nequal(r3461, body.constant(0u));
                           ir_expression *const r3479 = expr(ir_unop_b2i, r3478);
                           ir_expression *const r347A = expr(ir_unop_i2u, r3479);
                           body.emit(assign(r3463, bit_or(r3463, r347A), 0x01));


                        body.instructions = f3468_parent_instructions;
                        body.emit(f3468);

                        /* END IF */

                        body.emit(assign(r344B, r3465, 0x01));

                        body.emit(assign(r344C, r3464, 0x01));

                        body.emit(assign(r344D, r3463, 0x01));

                        body.emit(assign(r344A, body.constant(int(0)), 0x01));

                        body.emit(assign(r3450, less(r3463, body.constant(0u)), 0x01));


                     body.instructions = f345F_parent_instructions;
                     body.emit(f345F);

                     /* END IF */


                  body.instructions = f345C_parent_instructions;
                  body.emit(f345C);

                  /* END IF */


               body.instructions = f3452_parent_instructions;
               body.emit(f3452);

               /* END IF */

               /* IF CONDITION */
               ir_if *f347B = new(mem_ctx) ir_if(operand(r344E).val);
               exec_list *const f347B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f347B->then_instructions;

                  /* IF CONDITION */
                  ir_if *f347C = new(mem_ctx) ir_if(operand(r3450).val);
                  exec_list *const f347C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f347C->then_instructions;

                     ir_variable *const r347D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r347D, add(r344C, body.constant(1u)), 0x01));

                     ir_expression *const r347E = less(r347D, r344C);
                     ir_expression *const r347F = expr(ir_unop_b2i, r347E);
                     ir_expression *const r3480 = expr(ir_unop_i2u, r347F);
                     body.emit(assign(r344B, add(r344B, r3480), 0x01));

                     ir_expression *const r3481 = equal(r344D, body.constant(0u));
                     ir_expression *const r3482 = expr(ir_unop_b2i, r3481);
                     ir_expression *const r3483 = expr(ir_unop_i2u, r3482);
                     ir_expression *const r3484 = add(r344D, r3483);
                     ir_expression *const r3485 = bit_and(r3484, body.constant(1u));
                     ir_expression *const r3486 = expr(ir_unop_bit_not, r3485);
                     body.emit(assign(r344C, bit_and(r347D, r3486), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f347C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3488 = bit_or(r344B, r344C);
                     ir_expression *const r3489 = equal(r3488, body.constant(0u));
                     ir_if *f3487 = new(mem_ctx) ir_if(operand(r3489).val);
                     exec_list *const f3487_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3487->then_instructions;

                        body.emit(assign(r344A, body.constant(int(0)), 0x01));


                     body.instructions = f3487_parent_instructions;
                     body.emit(f3487);

                     /* END IF */


                  body.instructions = f347C_parent_instructions;
                  body.emit(f347C);

                  /* END IF */

                  ir_variable *const r348A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r348A);
                  ir_expression *const r348B = lshift(r3221, body.constant(int(31)));
                  ir_expression *const r348C = expr(ir_unop_i2u, r344A);
                  ir_expression *const r348D = lshift(r348C, body.constant(int(20)));
                  ir_expression *const r348E = add(r348B, r348D);
                  body.emit(assign(r348A, add(r348E, r344B), 0x02));

                  body.emit(assign(r348A, r344C, 0x01));

                  body.emit(assign(r344F, r348A, 0x03));

                  body.emit(assign(r344E, body.constant(false), 0x01));


               body.instructions = f347B_parent_instructions;
               body.emit(f347B);

               /* END IF */

               body.emit(assign(r3220, r344F, 0x03));

               body.emit(assign(r321F, body.constant(false), 0x01));


            body.instructions = f332D_parent_instructions;
            body.emit(f332D);

            /* END IF */


         body.instructions = f32EC_parent_instructions;
         body.emit(f32EC);

         /* END IF */


      body.instructions = f3282_parent_instructions;
      body.emit(f3282);

      /* END IF */


   body.instructions = f323B_parent_instructions;
   body.emit(f323B);

   /* END IF */

   ir_variable *const r348F = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3490 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r3491 = rshift(swizzle_y(r3220), body.constant(int(20)));
   ir_expression *const r3492 = bit_and(r3491, body.constant(2047u));
   ir_expression *const r3493 = expr(ir_unop_u2i, r3492);
   body.emit(assign(r3490, add(r3493, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r3495 = less(r3490, body.constant(int(0)));
   ir_if *f3494 = new(mem_ctx) ir_if(operand(r3495).val);
   exec_list *const f3494_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3494->then_instructions;

      body.emit(assign(r348F, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3494->else_instructions;

      /* IF CONDITION */
      ir_expression *const r3497 = greater(r3490, body.constant(int(52)));
      ir_if *f3496 = new(mem_ctx) ir_if(operand(r3497).val);
      exec_list *const f3496_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3496->then_instructions;

         body.emit(assign(r348F, r3220, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3496->else_instructions;

         ir_variable *const r3498 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r3498, sub(body.constant(int(52)), r3490), 0x01));

         ir_variable *const r3499 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r349B = gequal(r3498, body.constant(int(32)));
         ir_if *f349A = new(mem_ctx) ir_if(operand(r349B).val);
         exec_list *const f349A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f349A->then_instructions;

            body.emit(assign(r3499, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f349A->else_instructions;

            body.emit(assign(r3499, lshift(body.constant(4294967295u), r3498), 0x01));


         body.instructions = f349A_parent_instructions;
         body.emit(f349A);

         /* END IF */

         ir_variable *const r349C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r349E = less(r3498, body.constant(int(33)));
         ir_if *f349D = new(mem_ctx) ir_if(operand(r349E).val);
         exec_list *const f349D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f349D->then_instructions;

            body.emit(assign(r349C, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f349D->else_instructions;

            ir_expression *const r349F = add(r3498, body.constant(int(-32)));
            body.emit(assign(r349C, lshift(body.constant(4294967295u), r349F), 0x01));


         body.instructions = f349D_parent_instructions;
         body.emit(f349D);

         /* END IF */

         ir_variable *const r34A0 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r34A0, bit_and(r3499, swizzle_x(r3220)), 0x01));

         body.emit(assign(r34A0, bit_and(r349C, swizzle_y(r3220)), 0x02));

         body.emit(assign(r348F, r34A0, 0x03));


      body.instructions = f3496_parent_instructions;
      body.emit(f3496);

      /* END IF */


   body.instructions = f3494_parent_instructions;
   body.emit(f3494);

   /* END IF */

   ir_variable *const r34A1 = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r34A2 = rshift(swizzle_y(r3220), body.constant(int(31)));
   ir_expression *const r34A3 = expr(ir_unop_u2i, r34A2);
   body.emit(assign(r34A1, expr(ir_unop_i2b, r34A3), 0x01));

   ir_variable *const r34A4 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r34A6 = expr(ir_unop_logic_not, r34A1);
   ir_if *f34A5 = new(mem_ctx) ir_if(operand(r34A6).val);
   exec_list *const f34A5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f34A5->then_instructions;

      body.emit(assign(r34A4, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f34A5->else_instructions;

      ir_variable *const r34A7 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r34A8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r34A8);
      ir_variable *const r34A9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r34A9);
      ir_expression *const r34AA = rshift(swizzle_y(r3220), body.constant(int(20)));
      ir_expression *const r34AB = bit_and(r34AA, body.constant(2047u));
      ir_expression *const r34AC = expr(ir_unop_u2i, r34AB);
      ir_expression *const r34AD = equal(r34AC, body.constant(int(2047)));
      ir_expression *const r34AE = bit_and(swizzle_y(r3220), body.constant(1048575u));
      ir_expression *const r34AF = bit_or(r34AE, swizzle_x(r3220));
      ir_expression *const r34B0 = nequal(r34AF, body.constant(0u));
      body.emit(assign(r34A9, logic_and(r34AD, r34B0), 0x01));

      ir_expression *const r34B1 = rshift(swizzle_y(r348F), body.constant(int(20)));
      ir_expression *const r34B2 = bit_and(r34B1, body.constant(2047u));
      ir_expression *const r34B3 = expr(ir_unop_u2i, r34B2);
      ir_expression *const r34B4 = equal(r34B3, body.constant(int(2047)));
      ir_expression *const r34B5 = bit_and(swizzle_y(r348F), body.constant(1048575u));
      ir_expression *const r34B6 = bit_or(r34B5, swizzle_x(r348F));
      ir_expression *const r34B7 = nequal(r34B6, body.constant(0u));
      body.emit(assign(r34A8, logic_and(r34B4, r34B7), 0x01));

      /* IF CONDITION */
      ir_expression *const r34B9 = logic_or(r34A9, r34A8);
      ir_if *f34B8 = new(mem_ctx) ir_if(operand(r34B9).val);
      exec_list *const f34B8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f34B8->then_instructions;

         body.emit(assign(r34A7, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f34B8->else_instructions;

         ir_expression *const r34BA = equal(swizzle_x(r3220), swizzle_x(r348F));
         ir_expression *const r34BB = equal(swizzle_y(r3220), swizzle_y(r348F));
         ir_expression *const r34BC = equal(swizzle_x(r3220), body.constant(0u));
         ir_expression *const r34BD = bit_or(swizzle_y(r3220), swizzle_y(r348F));
         ir_expression *const r34BE = lshift(r34BD, body.constant(int(1)));
         ir_expression *const r34BF = equal(r34BE, body.constant(0u));
         ir_expression *const r34C0 = logic_and(r34BC, r34BF);
         ir_expression *const r34C1 = logic_or(r34BB, r34C0);
         body.emit(assign(r34A7, logic_and(r34BA, r34C1), 0x01));


      body.instructions = f34B8_parent_instructions;
      body.emit(f34B8);

      /* END IF */

      body.emit(assign(r34A4, r34A7, 0x01));


   body.instructions = f34A5_parent_instructions;
   body.emit(f34A5);

   /* END IF */

   ir_variable *const r34C2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f34C3 = new(mem_ctx) ir_if(operand(r34A4).val);
   exec_list *const f34C3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f34C3->then_instructions;

      body.emit(assign(r34C2, r348F, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f34C3->else_instructions;

      ir_variable *const r34C4 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r34C5 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r34C5, rshift(swizzle_y(r348F), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r34C7 = equal(r34C5, body.constant(0u));
      ir_if *f34C6 = new(mem_ctx) ir_if(operand(r34C7).val);
      exec_list *const f34C6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f34C6->then_instructions;

         ir_variable *const r34C8 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r34C8, r34C5, 0x01));

         ir_variable *const r34C9 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r34CA = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r34CA);
         ir_variable *const r34CB = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r34CB);
         ir_variable *const r34CC = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r34CC);
         ir_variable *const r34CD = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r34CD);
         ir_variable *const r34CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r34CE);
         ir_variable *const r34CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r34CF);
         ir_variable *const r34D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r34D0);
         ir_variable *const r34D1 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r34D1);
         ir_variable *const r34D2 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r34D2, body.constant(0u), 0x01));

         ir_variable *const r34D3 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r34D4 = rshift(swizzle_y(r348F), body.constant(int(20)));
         ir_expression *const r34D5 = bit_and(r34D4, body.constant(2047u));
         body.emit(assign(r34D3, expr(ir_unop_u2i, r34D5), 0x01));

         body.emit(assign(r34CC, r34D3, 0x01));

         body.emit(assign(r34CB, body.constant(int(1023)), 0x01));

         body.emit(assign(r34CA, add(r34D3, body.constant(int(-1023))), 0x01));

         ir_variable *const r34D6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r34D6, lshift(swizzle_x(r348F), body.constant(int(10))), 0x01));

         ir_variable *const r34D7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r34D8 = bit_and(swizzle_y(r348F), body.constant(1048575u));
         ir_expression *const r34D9 = lshift(r34D8, body.constant(int(10)));
         ir_expression *const r34DA = rshift(swizzle_x(r348F), body.constant(int(22)));
         body.emit(assign(r34D7, bit_or(r34D9, r34DA), 0x01));

         body.emit(assign(r34CF, r34D7, 0x01));

         body.emit(assign(r34D0, r34D6, 0x01));

         ir_variable *const r34DB = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r34DB, body.constant(0u), 0x01));

         ir_variable *const r34DC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r34DC, body.constant(0u), 0x01));

         body.emit(assign(r34CD, r34DC, 0x01));

         body.emit(assign(r34CE, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r34DE = less(body.constant(int(0)), r34CA);
         ir_if *f34DD = new(mem_ctx) ir_if(operand(r34DE).val);
         exec_list *const f34DD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f34DD->then_instructions;

            /* IF CONDITION */
            ir_expression *const r34E0 = equal(r34D3, body.constant(int(2047)));
            ir_if *f34DF = new(mem_ctx) ir_if(operand(r34E0).val);
            exec_list *const f34DF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f34DF->then_instructions;

               /* IF CONDITION */
               ir_expression *const r34E2 = bit_or(r34D7, r34D6);
               ir_expression *const r34E3 = nequal(r34E2, body.constant(0u));
               ir_if *f34E1 = new(mem_ctx) ir_if(operand(r34E3).val);
               exec_list *const f34E1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f34E1->then_instructions;

                  ir_variable *const r34E4 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r34E4, swizzle_x(r348F), 0x01));

                  ir_variable *const r34E5 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r34E5, body.constant(0u), 0x01));

                  ir_variable *const r34E6 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r34E4, bit_or(swizzle_y(r348F), body.constant(524288u)), 0x02));

                  body.emit(assign(r34E5, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r34E8 = lshift(swizzle_y(r348F), body.constant(int(1)));
                  ir_expression *const r34E9 = lequal(body.constant(4292870144u), r34E8);
                  ir_expression *const r34EA = nequal(swizzle_x(r348F), body.constant(0u));
                  ir_expression *const r34EB = bit_and(swizzle_y(r348F), body.constant(1048575u));
                  ir_expression *const r34EC = nequal(r34EB, body.constant(0u));
                  ir_expression *const r34ED = logic_or(r34EA, r34EC);
                  ir_expression *const r34EE = logic_and(r34E9, r34ED);
                  ir_if *f34E7 = new(mem_ctx) ir_if(operand(r34EE).val);
                  exec_list *const f34E7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f34E7->then_instructions;

                     body.emit(assign(r34E6, r34E4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f34E7->else_instructions;

                     body.emit(assign(r34E6, r34E5, 0x03));


                  body.instructions = f34E7_parent_instructions;
                  body.emit(f34E7);

                  /* END IF */

                  body.emit(assign(r34C9, r34E6, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f34E1->else_instructions;

                  body.emit(assign(r34C9, r348F, 0x03));


               body.instructions = f34E1_parent_instructions;
               body.emit(f34E1);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f34DF->else_instructions;

               body.emit(assign(r34CD, body.constant(1073741824u), 0x01));

               ir_variable *const r34EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r34EF);
               ir_variable *const r34F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r34F0);
               ir_variable *const r34F1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r34F2 = neg(r34CA);
               body.emit(assign(r34F1, bit_and(r34F2, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r34F4 = equal(r34CA, body.constant(int(0)));
               ir_if *f34F3 = new(mem_ctx) ir_if(operand(r34F4).val);
               exec_list *const f34F3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f34F3->then_instructions;

                  body.emit(assign(r34EF, body.constant(0u), 0x01));

                  body.emit(assign(r34F0, r34CD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f34F3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r34F6 = less(r34CA, body.constant(int(32)));
                  ir_if *f34F5 = new(mem_ctx) ir_if(operand(r34F6).val);
                  exec_list *const f34F5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f34F5->then_instructions;

                     ir_expression *const r34F7 = lshift(body.constant(1073741824u), r34F1);
                     ir_expression *const r34F8 = bit_or(r34F7, body.constant(0u));
                     body.emit(assign(r34EF, bit_or(r34F8, body.constant(0u)), 0x01));

                     body.emit(assign(r34F0, rshift(body.constant(1073741824u), r34CA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f34F5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r34FA = equal(r34CA, body.constant(int(32)));
                     ir_if *f34F9 = new(mem_ctx) ir_if(operand(r34FA).val);
                     exec_list *const f34F9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f34F9->then_instructions;

                        body.emit(assign(r34EF, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f34F9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r34FC = less(r34CA, body.constant(int(64)));
                        ir_if *f34FB = new(mem_ctx) ir_if(operand(r34FC).val);
                        exec_list *const f34FB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f34FB->then_instructions;

                           ir_expression *const r34FD = bit_and(r34CA, body.constant(int(31)));
                           ir_expression *const r34FE = rshift(body.constant(1073741824u), r34FD);
                           ir_expression *const r34FF = lshift(body.constant(1073741824u), r34F1);
                           ir_expression *const r3500 = bit_or(r34FF, body.constant(0u));
                           ir_expression *const r3501 = nequal(r3500, body.constant(0u));
                           ir_expression *const r3502 = expr(ir_unop_b2i, r3501);
                           ir_expression *const r3503 = expr(ir_unop_i2u, r3502);
                           body.emit(assign(r34EF, bit_or(r34FE, r3503), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f34FB->else_instructions;

                           body.emit(assign(r34EF, body.constant(1u), 0x01));


                        body.instructions = f34FB_parent_instructions;
                        body.emit(f34FB);

                        /* END IF */


                     body.instructions = f34F9_parent_instructions;
                     body.emit(f34F9);

                     /* END IF */

                     body.emit(assign(r34F0, body.constant(0u), 0x01));


                  body.instructions = f34F5_parent_instructions;
                  body.emit(f34F5);

                  /* END IF */


               body.instructions = f34F3_parent_instructions;
               body.emit(f34F3);

               /* END IF */

               body.emit(assign(r34CD, r34F0, 0x01));

               body.emit(assign(r34CE, r34EF, 0x01));

               body.emit(assign(r34CF, bit_or(r34D7, body.constant(1073741824u)), 0x01));

               ir_variable *const r3504 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3505 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3505, sub(r34D6, r34EF), 0x01));

               ir_expression *const r3506 = sub(r34CF, r34F0);
               ir_expression *const r3507 = less(r34D6, r34EF);
               ir_expression *const r3508 = expr(ir_unop_b2i, r3507);
               ir_expression *const r3509 = expr(ir_unop_i2u, r3508);
               body.emit(assign(r3504, sub(r3506, r3509), 0x01));

               body.emit(assign(r34D1, add(r34D3, body.constant(int(-1))), 0x01));

               ir_variable *const r350A = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r350A, add(r34D1, body.constant(int(-10))), 0x01));

               ir_variable *const r350B = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r350B, r3504, 0x01));

               ir_variable *const r350C = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r350C, r3505, 0x01));

               ir_variable *const r350D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r350D);
               ir_variable *const r350E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r350E);
               /* IF CONDITION */
               ir_expression *const r3510 = equal(r3504, body.constant(0u));
               ir_if *f350F = new(mem_ctx) ir_if(operand(r3510).val);
               exec_list *const f350F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f350F->then_instructions;

                  body.emit(assign(r350B, r3505, 0x01));

                  body.emit(assign(r350C, body.constant(0u), 0x01));

                  body.emit(assign(r350A, add(r350A, body.constant(int(-32))), 0x01));


               body.instructions = f350F_parent_instructions;
               body.emit(f350F);

               /* END IF */

               ir_variable *const r3511 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r3511, r350B, 0x01));

               ir_variable *const r3512 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r3513 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3513);
               /* IF CONDITION */
               ir_expression *const r3515 = equal(r350B, body.constant(0u));
               ir_if *f3514 = new(mem_ctx) ir_if(operand(r3515).val);
               exec_list *const f3514_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3514->then_instructions;

                  body.emit(assign(r3512, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3514->else_instructions;

                  body.emit(assign(r3513, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3517 = bit_and(r350B, body.constant(4294901760u));
                  ir_expression *const r3518 = equal(r3517, body.constant(0u));
                  ir_if *f3516 = new(mem_ctx) ir_if(operand(r3518).val);
                  exec_list *const f3516_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3516->then_instructions;

                     body.emit(assign(r3513, body.constant(int(16)), 0x01));

                     body.emit(assign(r3511, lshift(r350B, body.constant(int(16))), 0x01));


                  body.instructions = f3516_parent_instructions;
                  body.emit(f3516);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r351A = bit_and(r3511, body.constant(4278190080u));
                  ir_expression *const r351B = equal(r351A, body.constant(0u));
                  ir_if *f3519 = new(mem_ctx) ir_if(operand(r351B).val);
                  exec_list *const f3519_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3519->then_instructions;

                     body.emit(assign(r3513, add(r3513, body.constant(int(8))), 0x01));

                     body.emit(assign(r3511, lshift(r3511, body.constant(int(8))), 0x01));


                  body.instructions = f3519_parent_instructions;
                  body.emit(f3519);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r351D = bit_and(r3511, body.constant(4026531840u));
                  ir_expression *const r351E = equal(r351D, body.constant(0u));
                  ir_if *f351C = new(mem_ctx) ir_if(operand(r351E).val);
                  exec_list *const f351C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f351C->then_instructions;

                     body.emit(assign(r3513, add(r3513, body.constant(int(4))), 0x01));

                     body.emit(assign(r3511, lshift(r3511, body.constant(int(4))), 0x01));


                  body.instructions = f351C_parent_instructions;
                  body.emit(f351C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3520 = bit_and(r3511, body.constant(3221225472u));
                  ir_expression *const r3521 = equal(r3520, body.constant(0u));
                  ir_if *f351F = new(mem_ctx) ir_if(operand(r3521).val);
                  exec_list *const f351F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f351F->then_instructions;

                     body.emit(assign(r3513, add(r3513, body.constant(int(2))), 0x01));

                     body.emit(assign(r3511, lshift(r3511, body.constant(int(2))), 0x01));


                  body.instructions = f351F_parent_instructions;
                  body.emit(f351F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3523 = bit_and(r3511, body.constant(2147483648u));
                  ir_expression *const r3524 = equal(r3523, body.constant(0u));
                  ir_if *f3522 = new(mem_ctx) ir_if(operand(r3524).val);
                  exec_list *const f3522_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3522->then_instructions;

                     body.emit(assign(r3513, add(r3513, body.constant(int(1))), 0x01));


                  body.instructions = f3522_parent_instructions;
                  body.emit(f3522);

                  /* END IF */

                  body.emit(assign(r3512, r3513, 0x01));


               body.instructions = f3514_parent_instructions;
               body.emit(f3514);

               /* END IF */

               body.emit(assign(r350E, add(r3512, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3526 = lequal(body.constant(int(0)), r350E);
               ir_if *f3525 = new(mem_ctx) ir_if(operand(r3526).val);
               exec_list *const f3525_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3525->then_instructions;

                  body.emit(assign(r350D, body.constant(0u), 0x01));

                  ir_variable *const r3527 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3527, lshift(r350C, r350E), 0x01));

                  ir_variable *const r3528 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r352A = equal(r350E, body.constant(int(0)));
                  ir_if *f3529 = new(mem_ctx) ir_if(operand(r352A).val);
                  exec_list *const f3529_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3529->then_instructions;

                     body.emit(assign(r3528, r350B, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3529->else_instructions;

                     ir_expression *const r352B = lshift(r350B, r350E);
                     ir_expression *const r352C = neg(r350E);
                     ir_expression *const r352D = bit_and(r352C, body.constant(int(31)));
                     ir_expression *const r352E = rshift(r350C, r352D);
                     body.emit(assign(r3528, bit_or(r352B, r352E), 0x01));


                  body.instructions = f3529_parent_instructions;
                  body.emit(f3529);

                  /* END IF */

                  body.emit(assign(r350B, r3528, 0x01));

                  body.emit(assign(r350C, r3527, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3525->else_instructions;

                  ir_variable *const r352F = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r352F, body.constant(0u), 0x01));

                  ir_variable *const r3530 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r3530, neg(r350E), 0x01));

                  ir_variable *const r3531 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3531);
                  ir_variable *const r3532 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3532);
                  ir_variable *const r3533 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3533);
                  ir_variable *const r3534 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r3535 = neg(r3530);
                  body.emit(assign(r3534, bit_and(r3535, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3537 = equal(r3530, body.constant(int(0)));
                  ir_if *f3536 = new(mem_ctx) ir_if(operand(r3537).val);
                  exec_list *const f3536_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3536->then_instructions;

                     body.emit(assign(r3531, r352F, 0x01));

                     body.emit(assign(r3532, r350C, 0x01));

                     body.emit(assign(r3533, r350B, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3536->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3539 = less(r3530, body.constant(int(32)));
                     ir_if *f3538 = new(mem_ctx) ir_if(operand(r3539).val);
                     exec_list *const f3538_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3538->then_instructions;

                        body.emit(assign(r3531, lshift(r350C, r3534), 0x01));

                        ir_expression *const r353A = lshift(r350B, r3534);
                        ir_expression *const r353B = rshift(r350C, r3530);
                        body.emit(assign(r3532, bit_or(r353A, r353B), 0x01));

                        body.emit(assign(r3533, rshift(r350B, r3530), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3538->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r353D = equal(r3530, body.constant(int(32)));
                        ir_if *f353C = new(mem_ctx) ir_if(operand(r353D).val);
                        exec_list *const f353C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f353C->then_instructions;

                           body.emit(assign(r3531, r350C, 0x01));

                           body.emit(assign(r3532, r350B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f353C->else_instructions;

                           body.emit(assign(r352F, bit_or(body.constant(0u), r350C), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r353F = less(r3530, body.constant(int(64)));
                           ir_if *f353E = new(mem_ctx) ir_if(operand(r353F).val);
                           exec_list *const f353E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f353E->then_instructions;

                              body.emit(assign(r3531, lshift(r350B, r3534), 0x01));

                              ir_expression *const r3540 = bit_and(r3530, body.constant(int(31)));
                              body.emit(assign(r3532, rshift(r350B, r3540), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f353E->else_instructions;

                              ir_variable *const r3541 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3543 = equal(r3530, body.constant(int(64)));
                              ir_if *f3542 = new(mem_ctx) ir_if(operand(r3543).val);
                              exec_list *const f3542_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3542->then_instructions;

                                 body.emit(assign(r3541, r350B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3542->else_instructions;

                                 ir_expression *const r3544 = nequal(r350B, body.constant(0u));
                                 ir_expression *const r3545 = expr(ir_unop_b2i, r3544);
                                 body.emit(assign(r3541, expr(ir_unop_i2u, r3545), 0x01));


                              body.instructions = f3542_parent_instructions;
                              body.emit(f3542);

                              /* END IF */

                              body.emit(assign(r3531, r3541, 0x01));

                              body.emit(assign(r3532, body.constant(0u), 0x01));


                           body.instructions = f353E_parent_instructions;
                           body.emit(f353E);

                           /* END IF */


                        body.instructions = f353C_parent_instructions;
                        body.emit(f353C);

                        /* END IF */

                        body.emit(assign(r3533, body.constant(0u), 0x01));


                     body.instructions = f3538_parent_instructions;
                     body.emit(f3538);

                     /* END IF */

                     ir_expression *const r3546 = nequal(r352F, body.constant(0u));
                     ir_expression *const r3547 = expr(ir_unop_b2i, r3546);
                     ir_expression *const r3548 = expr(ir_unop_i2u, r3547);
                     body.emit(assign(r3531, bit_or(r3531, r3548), 0x01));


                  body.instructions = f3536_parent_instructions;
                  body.emit(f3536);

                  /* END IF */

                  body.emit(assign(r350B, r3533, 0x01));

                  body.emit(assign(r350C, r3532, 0x01));

                  body.emit(assign(r350D, r3531, 0x01));


               body.instructions = f3525_parent_instructions;
               body.emit(f3525);

               /* END IF */

               body.emit(assign(r350A, sub(r350A, r350E), 0x01));

               ir_variable *const r3549 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3549, r350A, 0x01));

               ir_variable *const r354A = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r354A, r350B, 0x01));

               ir_variable *const r354B = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r354B, r350C, 0x01));

               ir_variable *const r354C = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r354C, r350D, 0x01));

               ir_variable *const r354D = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r354D, body.constant(true), 0x01));

               ir_variable *const r354E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r354F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r354F);
               ir_expression *const r3550 = expr(ir_unop_u2i, r350D);
               body.emit(assign(r354F, less(r3550, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3552 = lequal(body.constant(int(2045)), r350A);
               ir_if *f3551 = new(mem_ctx) ir_if(operand(r3552).val);
               exec_list *const f3551_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3551->then_instructions;

                  ir_variable *const r3553 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3555 = less(body.constant(int(2045)), r350A);
                  ir_if *f3554 = new(mem_ctx) ir_if(operand(r3555).val);
                  exec_list *const f3554_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3554->then_instructions;

                     body.emit(assign(r3553, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3554->else_instructions;

                     ir_variable *const r3556 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3558 = equal(r350A, body.constant(int(2045)));
                     ir_if *f3557 = new(mem_ctx) ir_if(operand(r3558).val);
                     exec_list *const f3557_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3557->then_instructions;

                        ir_expression *const r3559 = equal(body.constant(2097151u), r350B);
                        ir_expression *const r355A = equal(body.constant(4294967295u), r350C);
                        body.emit(assign(r3556, logic_and(r3559, r355A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3557->else_instructions;

                        body.emit(assign(r3556, body.constant(false), 0x01));


                     body.instructions = f3557_parent_instructions;
                     body.emit(f3557);

                     /* END IF */

                     body.emit(assign(r3553, logic_and(r3556, r354F), 0x01));


                  body.instructions = f3554_parent_instructions;
                  body.emit(f3554);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f355B = new(mem_ctx) ir_if(operand(r3553).val);
                  exec_list *const f355B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f355B->then_instructions;

                     ir_variable *const r355C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r355C);
                     ir_expression *const r355D = lshift(r34C5, body.constant(int(31)));
                     body.emit(assign(r355C, add(r355D, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r355C, body.constant(0u), 0x01));

                     body.emit(assign(r354E, r355C, 0x03));

                     body.emit(assign(r354D, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f355B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r355F = less(r350A, body.constant(int(0)));
                     ir_if *f355E = new(mem_ctx) ir_if(operand(r355F).val);
                     exec_list *const f355E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f355E->then_instructions;

                        ir_variable *const r3560 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3560, r350D, 0x01));

                        ir_variable *const r3561 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3561, neg(r350A), 0x01));

                        ir_variable *const r3562 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3562);
                        ir_variable *const r3563 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3563);
                        ir_variable *const r3564 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3564);
                        ir_variable *const r3565 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3566 = neg(r3561);
                        body.emit(assign(r3565, bit_and(r3566, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3568 = equal(r3561, body.constant(int(0)));
                        ir_if *f3567 = new(mem_ctx) ir_if(operand(r3568).val);
                        exec_list *const f3567_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3567->then_instructions;

                           body.emit(assign(r3562, r350D, 0x01));

                           body.emit(assign(r3563, r350C, 0x01));

                           body.emit(assign(r3564, r350B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3567->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r356A = less(r3561, body.constant(int(32)));
                           ir_if *f3569 = new(mem_ctx) ir_if(operand(r356A).val);
                           exec_list *const f3569_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3569->then_instructions;

                              body.emit(assign(r3562, lshift(r350C, r3565), 0x01));

                              ir_expression *const r356B = lshift(r350B, r3565);
                              ir_expression *const r356C = rshift(r350C, r3561);
                              body.emit(assign(r3563, bit_or(r356B, r356C), 0x01));

                              body.emit(assign(r3564, rshift(r350B, r3561), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3569->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r356E = equal(r3561, body.constant(int(32)));
                              ir_if *f356D = new(mem_ctx) ir_if(operand(r356E).val);
                              exec_list *const f356D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f356D->then_instructions;

                                 body.emit(assign(r3562, r350C, 0x01));

                                 body.emit(assign(r3563, r350B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f356D->else_instructions;

                                 body.emit(assign(r3560, bit_or(r350D, r350C), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3570 = less(r3561, body.constant(int(64)));
                                 ir_if *f356F = new(mem_ctx) ir_if(operand(r3570).val);
                                 exec_list *const f356F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f356F->then_instructions;

                                    body.emit(assign(r3562, lshift(r350B, r3565), 0x01));

                                    ir_expression *const r3571 = bit_and(r3561, body.constant(int(31)));
                                    body.emit(assign(r3563, rshift(r350B, r3571), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f356F->else_instructions;

                                    ir_variable *const r3572 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3574 = equal(r3561, body.constant(int(64)));
                                    ir_if *f3573 = new(mem_ctx) ir_if(operand(r3574).val);
                                    exec_list *const f3573_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3573->then_instructions;

                                       body.emit(assign(r3572, r350B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3573->else_instructions;

                                       ir_expression *const r3575 = nequal(r350B, body.constant(0u));
                                       ir_expression *const r3576 = expr(ir_unop_b2i, r3575);
                                       body.emit(assign(r3572, expr(ir_unop_i2u, r3576), 0x01));


                                    body.instructions = f3573_parent_instructions;
                                    body.emit(f3573);

                                    /* END IF */

                                    body.emit(assign(r3562, r3572, 0x01));

                                    body.emit(assign(r3563, body.constant(0u), 0x01));


                                 body.instructions = f356F_parent_instructions;
                                 body.emit(f356F);

                                 /* END IF */


                              body.instructions = f356D_parent_instructions;
                              body.emit(f356D);

                              /* END IF */

                              body.emit(assign(r3564, body.constant(0u), 0x01));


                           body.instructions = f3569_parent_instructions;
                           body.emit(f3569);

                           /* END IF */

                           ir_expression *const r3577 = nequal(r3560, body.constant(0u));
                           ir_expression *const r3578 = expr(ir_unop_b2i, r3577);
                           ir_expression *const r3579 = expr(ir_unop_i2u, r3578);
                           body.emit(assign(r3562, bit_or(r3562, r3579), 0x01));


                        body.instructions = f3567_parent_instructions;
                        body.emit(f3567);

                        /* END IF */

                        body.emit(assign(r354A, r3564, 0x01));

                        body.emit(assign(r354B, r3563, 0x01));

                        body.emit(assign(r354C, r3562, 0x01));

                        body.emit(assign(r3549, body.constant(int(0)), 0x01));

                        body.emit(assign(r354F, less(r3562, body.constant(0u)), 0x01));


                     body.instructions = f355E_parent_instructions;
                     body.emit(f355E);

                     /* END IF */


                  body.instructions = f355B_parent_instructions;
                  body.emit(f355B);

                  /* END IF */


               body.instructions = f3551_parent_instructions;
               body.emit(f3551);

               /* END IF */

               /* IF CONDITION */
               ir_if *f357A = new(mem_ctx) ir_if(operand(r354D).val);
               exec_list *const f357A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f357A->then_instructions;

                  /* IF CONDITION */
                  ir_if *f357B = new(mem_ctx) ir_if(operand(r354F).val);
                  exec_list *const f357B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f357B->then_instructions;

                     ir_variable *const r357C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r357C, add(r354B, body.constant(1u)), 0x01));

                     ir_expression *const r357D = less(r357C, r354B);
                     ir_expression *const r357E = expr(ir_unop_b2i, r357D);
                     ir_expression *const r357F = expr(ir_unop_i2u, r357E);
                     body.emit(assign(r354A, add(r354A, r357F), 0x01));

                     ir_expression *const r3580 = equal(r354C, body.constant(0u));
                     ir_expression *const r3581 = expr(ir_unop_b2i, r3580);
                     ir_expression *const r3582 = expr(ir_unop_i2u, r3581);
                     ir_expression *const r3583 = add(r354C, r3582);
                     ir_expression *const r3584 = bit_and(r3583, body.constant(1u));
                     ir_expression *const r3585 = expr(ir_unop_bit_not, r3584);
                     body.emit(assign(r354B, bit_and(r357C, r3585), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f357B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3587 = bit_or(r354A, r354B);
                     ir_expression *const r3588 = equal(r3587, body.constant(0u));
                     ir_if *f3586 = new(mem_ctx) ir_if(operand(r3588).val);
                     exec_list *const f3586_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3586->then_instructions;

                        body.emit(assign(r3549, body.constant(int(0)), 0x01));


                     body.instructions = f3586_parent_instructions;
                     body.emit(f3586);

                     /* END IF */


                  body.instructions = f357B_parent_instructions;
                  body.emit(f357B);

                  /* END IF */

                  ir_variable *const r3589 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3589);
                  ir_expression *const r358A = lshift(r34C5, body.constant(int(31)));
                  ir_expression *const r358B = expr(ir_unop_i2u, r3549);
                  ir_expression *const r358C = lshift(r358B, body.constant(int(20)));
                  ir_expression *const r358D = add(r358A, r358C);
                  body.emit(assign(r3589, add(r358D, r354A), 0x02));

                  body.emit(assign(r3589, r354B, 0x01));

                  body.emit(assign(r354E, r3589, 0x03));

                  body.emit(assign(r354D, body.constant(false), 0x01));


               body.instructions = f357A_parent_instructions;
               body.emit(f357A);

               /* END IF */

               body.emit(assign(r34C9, r354E, 0x03));


            body.instructions = f34DF_parent_instructions;
            body.emit(f34DF);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f34DD->else_instructions;

            /* IF CONDITION */
            ir_expression *const r358F = less(r34CA, body.constant(int(0)));
            ir_if *f358E = new(mem_ctx) ir_if(operand(r358F).val);
            exec_list *const f358E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f358E->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3591 = equal(r34D3, body.constant(int(0)));
               ir_if *f3590 = new(mem_ctx) ir_if(operand(r3591).val);
               exec_list *const f3590_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3590->then_instructions;

                  body.emit(assign(r34CA, add(r34CA, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3590->else_instructions;

                  body.emit(assign(r34CF, bit_or(r34CF, body.constant(1073741824u)), 0x01));


               body.instructions = f3590_parent_instructions;
               body.emit(f3590);

               /* END IF */

               ir_variable *const r3592 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r3592, neg(r34CA), 0x01));

               ir_variable *const r3593 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3593);
               ir_variable *const r3594 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3594);
               ir_variable *const r3595 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3596 = neg(r3592);
               body.emit(assign(r3595, bit_and(r3596, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3598 = equal(r3592, body.constant(int(0)));
               ir_if *f3597 = new(mem_ctx) ir_if(operand(r3598).val);
               exec_list *const f3597_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3597->then_instructions;

                  body.emit(assign(r3593, r34D6, 0x01));

                  body.emit(assign(r3594, r34CF, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3597->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r359A = less(r3592, body.constant(int(32)));
                  ir_if *f3599 = new(mem_ctx) ir_if(operand(r359A).val);
                  exec_list *const f3599_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3599->then_instructions;

                     ir_expression *const r359B = lshift(r34CF, r3595);
                     ir_expression *const r359C = rshift(r34D6, r3592);
                     ir_expression *const r359D = bit_or(r359B, r359C);
                     ir_expression *const r359E = lshift(r34D6, r3595);
                     ir_expression *const r359F = nequal(r359E, body.constant(0u));
                     ir_expression *const r35A0 = expr(ir_unop_b2i, r359F);
                     ir_expression *const r35A1 = expr(ir_unop_i2u, r35A0);
                     body.emit(assign(r3593, bit_or(r359D, r35A1), 0x01));

                     body.emit(assign(r3594, rshift(r34CF, r3592), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3599->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r35A3 = equal(r3592, body.constant(int(32)));
                     ir_if *f35A2 = new(mem_ctx) ir_if(operand(r35A3).val);
                     exec_list *const f35A2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f35A2->then_instructions;

                        ir_expression *const r35A4 = nequal(r34D6, body.constant(0u));
                        ir_expression *const r35A5 = expr(ir_unop_b2i, r35A4);
                        ir_expression *const r35A6 = expr(ir_unop_i2u, r35A5);
                        body.emit(assign(r3593, bit_or(r34CF, r35A6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f35A2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r35A8 = less(r3592, body.constant(int(64)));
                        ir_if *f35A7 = new(mem_ctx) ir_if(operand(r35A8).val);
                        exec_list *const f35A7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f35A7->then_instructions;

                           ir_expression *const r35A9 = bit_and(r3592, body.constant(int(31)));
                           ir_expression *const r35AA = rshift(r34CF, r35A9);
                           ir_expression *const r35AB = lshift(r34CF, r3595);
                           ir_expression *const r35AC = bit_or(r35AB, r34D6);
                           ir_expression *const r35AD = nequal(r35AC, body.constant(0u));
                           ir_expression *const r35AE = expr(ir_unop_b2i, r35AD);
                           ir_expression *const r35AF = expr(ir_unop_i2u, r35AE);
                           body.emit(assign(r3593, bit_or(r35AA, r35AF), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f35A7->else_instructions;

                           ir_expression *const r35B0 = bit_or(r34CF, r34D6);
                           ir_expression *const r35B1 = nequal(r35B0, body.constant(0u));
                           ir_expression *const r35B2 = expr(ir_unop_b2i, r35B1);
                           body.emit(assign(r3593, expr(ir_unop_i2u, r35B2), 0x01));


                        body.instructions = f35A7_parent_instructions;
                        body.emit(f35A7);

                        /* END IF */


                     body.instructions = f35A2_parent_instructions;
                     body.emit(f35A2);

                     /* END IF */

                     body.emit(assign(r3594, body.constant(0u), 0x01));


                  body.instructions = f3599_parent_instructions;
                  body.emit(f3599);

                  /* END IF */


               body.instructions = f3597_parent_instructions;
               body.emit(f3597);

               /* END IF */

               body.emit(assign(r34CF, r3594, 0x01));

               body.emit(assign(r34D0, r3593, 0x01));

               body.emit(assign(r34CD, bit_or(r34CD, body.constant(1073741824u)), 0x01));

               ir_variable *const r35B3 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r35B4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r35B4, sub(r34CE, r3593), 0x01));

               ir_expression *const r35B5 = sub(r34CD, r3594);
               ir_expression *const r35B6 = less(r34CE, r3593);
               ir_expression *const r35B7 = expr(ir_unop_b2i, r35B6);
               ir_expression *const r35B8 = expr(ir_unop_i2u, r35B7);
               body.emit(assign(r35B3, sub(r35B5, r35B8), 0x01));

               body.emit(assign(r34C8, bit_xor(r34C5, body.constant(1u)), 0x01));

               body.emit(assign(r34D1, body.constant(int(1022)), 0x01));

               ir_variable *const r35B9 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r35B9, body.constant(int(1012)), 0x01));

               ir_variable *const r35BA = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r35BA, r35B3, 0x01));

               ir_variable *const r35BB = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r35BB, r35B4, 0x01));

               ir_variable *const r35BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r35BC);
               ir_variable *const r35BD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r35BD);
               /* IF CONDITION */
               ir_expression *const r35BF = equal(r35B3, body.constant(0u));
               ir_if *f35BE = new(mem_ctx) ir_if(operand(r35BF).val);
               exec_list *const f35BE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35BE->then_instructions;

                  body.emit(assign(r35BA, r35B4, 0x01));

                  body.emit(assign(r35BB, body.constant(0u), 0x01));

                  body.emit(assign(r35B9, body.constant(int(980)), 0x01));


               body.instructions = f35BE_parent_instructions;
               body.emit(f35BE);

               /* END IF */

               ir_variable *const r35C0 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r35C0, r35BA, 0x01));

               ir_variable *const r35C1 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r35C2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r35C2);
               /* IF CONDITION */
               ir_expression *const r35C4 = equal(r35BA, body.constant(0u));
               ir_if *f35C3 = new(mem_ctx) ir_if(operand(r35C4).val);
               exec_list *const f35C3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35C3->then_instructions;

                  body.emit(assign(r35C1, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f35C3->else_instructions;

                  body.emit(assign(r35C2, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r35C6 = bit_and(r35BA, body.constant(4294901760u));
                  ir_expression *const r35C7 = equal(r35C6, body.constant(0u));
                  ir_if *f35C5 = new(mem_ctx) ir_if(operand(r35C7).val);
                  exec_list *const f35C5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35C5->then_instructions;

                     body.emit(assign(r35C2, body.constant(int(16)), 0x01));

                     body.emit(assign(r35C0, lshift(r35BA, body.constant(int(16))), 0x01));


                  body.instructions = f35C5_parent_instructions;
                  body.emit(f35C5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r35C9 = bit_and(r35C0, body.constant(4278190080u));
                  ir_expression *const r35CA = equal(r35C9, body.constant(0u));
                  ir_if *f35C8 = new(mem_ctx) ir_if(operand(r35CA).val);
                  exec_list *const f35C8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35C8->then_instructions;

                     body.emit(assign(r35C2, add(r35C2, body.constant(int(8))), 0x01));

                     body.emit(assign(r35C0, lshift(r35C0, body.constant(int(8))), 0x01));


                  body.instructions = f35C8_parent_instructions;
                  body.emit(f35C8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r35CC = bit_and(r35C0, body.constant(4026531840u));
                  ir_expression *const r35CD = equal(r35CC, body.constant(0u));
                  ir_if *f35CB = new(mem_ctx) ir_if(operand(r35CD).val);
                  exec_list *const f35CB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35CB->then_instructions;

                     body.emit(assign(r35C2, add(r35C2, body.constant(int(4))), 0x01));

                     body.emit(assign(r35C0, lshift(r35C0, body.constant(int(4))), 0x01));


                  body.instructions = f35CB_parent_instructions;
                  body.emit(f35CB);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r35CF = bit_and(r35C0, body.constant(3221225472u));
                  ir_expression *const r35D0 = equal(r35CF, body.constant(0u));
                  ir_if *f35CE = new(mem_ctx) ir_if(operand(r35D0).val);
                  exec_list *const f35CE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35CE->then_instructions;

                     body.emit(assign(r35C2, add(r35C2, body.constant(int(2))), 0x01));

                     body.emit(assign(r35C0, lshift(r35C0, body.constant(int(2))), 0x01));


                  body.instructions = f35CE_parent_instructions;
                  body.emit(f35CE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r35D2 = bit_and(r35C0, body.constant(2147483648u));
                  ir_expression *const r35D3 = equal(r35D2, body.constant(0u));
                  ir_if *f35D1 = new(mem_ctx) ir_if(operand(r35D3).val);
                  exec_list *const f35D1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35D1->then_instructions;

                     body.emit(assign(r35C2, add(r35C2, body.constant(int(1))), 0x01));


                  body.instructions = f35D1_parent_instructions;
                  body.emit(f35D1);

                  /* END IF */

                  body.emit(assign(r35C1, r35C2, 0x01));


               body.instructions = f35C3_parent_instructions;
               body.emit(f35C3);

               /* END IF */

               body.emit(assign(r35BD, add(r35C1, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r35D5 = lequal(body.constant(int(0)), r35BD);
               ir_if *f35D4 = new(mem_ctx) ir_if(operand(r35D5).val);
               exec_list *const f35D4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35D4->then_instructions;

                  body.emit(assign(r35BC, body.constant(0u), 0x01));

                  ir_variable *const r35D6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r35D6, lshift(r35BB, r35BD), 0x01));

                  ir_variable *const r35D7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r35D9 = equal(r35BD, body.constant(int(0)));
                  ir_if *f35D8 = new(mem_ctx) ir_if(operand(r35D9).val);
                  exec_list *const f35D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35D8->then_instructions;

                     body.emit(assign(r35D7, r35BA, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f35D8->else_instructions;

                     ir_expression *const r35DA = lshift(r35BA, r35BD);
                     ir_expression *const r35DB = neg(r35BD);
                     ir_expression *const r35DC = bit_and(r35DB, body.constant(int(31)));
                     ir_expression *const r35DD = rshift(r35BB, r35DC);
                     body.emit(assign(r35D7, bit_or(r35DA, r35DD), 0x01));


                  body.instructions = f35D8_parent_instructions;
                  body.emit(f35D8);

                  /* END IF */

                  body.emit(assign(r35BA, r35D7, 0x01));

                  body.emit(assign(r35BB, r35D6, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f35D4->else_instructions;

                  ir_variable *const r35DE = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r35DE, body.constant(0u), 0x01));

                  ir_variable *const r35DF = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r35DF, neg(r35BD), 0x01));

                  ir_variable *const r35E0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r35E0);
                  ir_variable *const r35E1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r35E1);
                  ir_variable *const r35E2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r35E2);
                  ir_variable *const r35E3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r35E4 = neg(r35DF);
                  body.emit(assign(r35E3, bit_and(r35E4, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r35E6 = equal(r35DF, body.constant(int(0)));
                  ir_if *f35E5 = new(mem_ctx) ir_if(operand(r35E6).val);
                  exec_list *const f35E5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35E5->then_instructions;

                     body.emit(assign(r35E0, r35DE, 0x01));

                     body.emit(assign(r35E1, r35BB, 0x01));

                     body.emit(assign(r35E2, r35BA, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f35E5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r35E8 = less(r35DF, body.constant(int(32)));
                     ir_if *f35E7 = new(mem_ctx) ir_if(operand(r35E8).val);
                     exec_list *const f35E7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f35E7->then_instructions;

                        body.emit(assign(r35E0, lshift(r35BB, r35E3), 0x01));

                        ir_expression *const r35E9 = lshift(r35BA, r35E3);
                        ir_expression *const r35EA = rshift(r35BB, r35DF);
                        body.emit(assign(r35E1, bit_or(r35E9, r35EA), 0x01));

                        body.emit(assign(r35E2, rshift(r35BA, r35DF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f35E7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r35EC = equal(r35DF, body.constant(int(32)));
                        ir_if *f35EB = new(mem_ctx) ir_if(operand(r35EC).val);
                        exec_list *const f35EB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f35EB->then_instructions;

                           body.emit(assign(r35E0, r35BB, 0x01));

                           body.emit(assign(r35E1, r35BA, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f35EB->else_instructions;

                           body.emit(assign(r35DE, bit_or(body.constant(0u), r35BB), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r35EE = less(r35DF, body.constant(int(64)));
                           ir_if *f35ED = new(mem_ctx) ir_if(operand(r35EE).val);
                           exec_list *const f35ED_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f35ED->then_instructions;

                              body.emit(assign(r35E0, lshift(r35BA, r35E3), 0x01));

                              ir_expression *const r35EF = bit_and(r35DF, body.constant(int(31)));
                              body.emit(assign(r35E1, rshift(r35BA, r35EF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f35ED->else_instructions;

                              ir_variable *const r35F0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r35F2 = equal(r35DF, body.constant(int(64)));
                              ir_if *f35F1 = new(mem_ctx) ir_if(operand(r35F2).val);
                              exec_list *const f35F1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f35F1->then_instructions;

                                 body.emit(assign(r35F0, r35BA, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f35F1->else_instructions;

                                 ir_expression *const r35F3 = nequal(r35BA, body.constant(0u));
                                 ir_expression *const r35F4 = expr(ir_unop_b2i, r35F3);
                                 body.emit(assign(r35F0, expr(ir_unop_i2u, r35F4), 0x01));


                              body.instructions = f35F1_parent_instructions;
                              body.emit(f35F1);

                              /* END IF */

                              body.emit(assign(r35E0, r35F0, 0x01));

                              body.emit(assign(r35E1, body.constant(0u), 0x01));


                           body.instructions = f35ED_parent_instructions;
                           body.emit(f35ED);

                           /* END IF */


                        body.instructions = f35EB_parent_instructions;
                        body.emit(f35EB);

                        /* END IF */

                        body.emit(assign(r35E2, body.constant(0u), 0x01));


                     body.instructions = f35E7_parent_instructions;
                     body.emit(f35E7);

                     /* END IF */

                     ir_expression *const r35F5 = nequal(r35DE, body.constant(0u));
                     ir_expression *const r35F6 = expr(ir_unop_b2i, r35F5);
                     ir_expression *const r35F7 = expr(ir_unop_i2u, r35F6);
                     body.emit(assign(r35E0, bit_or(r35E0, r35F7), 0x01));


                  body.instructions = f35E5_parent_instructions;
                  body.emit(f35E5);

                  /* END IF */

                  body.emit(assign(r35BA, r35E2, 0x01));

                  body.emit(assign(r35BB, r35E1, 0x01));

                  body.emit(assign(r35BC, r35E0, 0x01));


               body.instructions = f35D4_parent_instructions;
               body.emit(f35D4);

               /* END IF */

               body.emit(assign(r35B9, sub(r35B9, r35BD), 0x01));

               ir_variable *const r35F8 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r35F8, r35B9, 0x01));

               ir_variable *const r35F9 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r35F9, r35BA, 0x01));

               ir_variable *const r35FA = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r35FA, r35BB, 0x01));

               ir_variable *const r35FB = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r35FB, r35BC, 0x01));

               ir_variable *const r35FC = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r35FC, body.constant(true), 0x01));

               ir_variable *const r35FD = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r35FE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r35FE);
               ir_expression *const r35FF = expr(ir_unop_u2i, r35BC);
               body.emit(assign(r35FE, less(r35FF, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3601 = lequal(body.constant(int(2045)), r35B9);
               ir_if *f3600 = new(mem_ctx) ir_if(operand(r3601).val);
               exec_list *const f3600_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3600->then_instructions;

                  ir_variable *const r3602 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3604 = less(body.constant(int(2045)), r35B9);
                  ir_if *f3603 = new(mem_ctx) ir_if(operand(r3604).val);
                  exec_list *const f3603_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3603->then_instructions;

                     body.emit(assign(r3602, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3603->else_instructions;

                     ir_variable *const r3605 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3607 = equal(r35B9, body.constant(int(2045)));
                     ir_if *f3606 = new(mem_ctx) ir_if(operand(r3607).val);
                     exec_list *const f3606_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3606->then_instructions;

                        ir_expression *const r3608 = equal(body.constant(2097151u), r35BA);
                        ir_expression *const r3609 = equal(body.constant(4294967295u), r35BB);
                        body.emit(assign(r3605, logic_and(r3608, r3609), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3606->else_instructions;

                        body.emit(assign(r3605, body.constant(false), 0x01));


                     body.instructions = f3606_parent_instructions;
                     body.emit(f3606);

                     /* END IF */

                     body.emit(assign(r3602, logic_and(r3605, r35FE), 0x01));


                  body.instructions = f3603_parent_instructions;
                  body.emit(f3603);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f360A = new(mem_ctx) ir_if(operand(r3602).val);
                  exec_list *const f360A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f360A->then_instructions;

                     ir_variable *const r360B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r360B);
                     ir_expression *const r360C = lshift(r34C8, body.constant(int(31)));
                     body.emit(assign(r360B, add(r360C, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r360B, body.constant(0u), 0x01));

                     body.emit(assign(r35FD, r360B, 0x03));

                     body.emit(assign(r35FC, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f360A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r360E = less(r35B9, body.constant(int(0)));
                     ir_if *f360D = new(mem_ctx) ir_if(operand(r360E).val);
                     exec_list *const f360D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f360D->then_instructions;

                        ir_variable *const r360F = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r360F, r35BC, 0x01));

                        ir_variable *const r3610 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3610, neg(r35B9), 0x01));

                        ir_variable *const r3611 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3611);
                        ir_variable *const r3612 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3612);
                        ir_variable *const r3613 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3613);
                        ir_variable *const r3614 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3615 = neg(r3610);
                        body.emit(assign(r3614, bit_and(r3615, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3617 = equal(r3610, body.constant(int(0)));
                        ir_if *f3616 = new(mem_ctx) ir_if(operand(r3617).val);
                        exec_list *const f3616_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3616->then_instructions;

                           body.emit(assign(r3611, r35BC, 0x01));

                           body.emit(assign(r3612, r35BB, 0x01));

                           body.emit(assign(r3613, r35BA, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3616->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3619 = less(r3610, body.constant(int(32)));
                           ir_if *f3618 = new(mem_ctx) ir_if(operand(r3619).val);
                           exec_list *const f3618_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3618->then_instructions;

                              body.emit(assign(r3611, lshift(r35BB, r3614), 0x01));

                              ir_expression *const r361A = lshift(r35BA, r3614);
                              ir_expression *const r361B = rshift(r35BB, r3610);
                              body.emit(assign(r3612, bit_or(r361A, r361B), 0x01));

                              body.emit(assign(r3613, rshift(r35BA, r3610), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3618->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r361D = equal(r3610, body.constant(int(32)));
                              ir_if *f361C = new(mem_ctx) ir_if(operand(r361D).val);
                              exec_list *const f361C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f361C->then_instructions;

                                 body.emit(assign(r3611, r35BB, 0x01));

                                 body.emit(assign(r3612, r35BA, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f361C->else_instructions;

                                 body.emit(assign(r360F, bit_or(r35BC, r35BB), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r361F = less(r3610, body.constant(int(64)));
                                 ir_if *f361E = new(mem_ctx) ir_if(operand(r361F).val);
                                 exec_list *const f361E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f361E->then_instructions;

                                    body.emit(assign(r3611, lshift(r35BA, r3614), 0x01));

                                    ir_expression *const r3620 = bit_and(r3610, body.constant(int(31)));
                                    body.emit(assign(r3612, rshift(r35BA, r3620), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f361E->else_instructions;

                                    ir_variable *const r3621 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3623 = equal(r3610, body.constant(int(64)));
                                    ir_if *f3622 = new(mem_ctx) ir_if(operand(r3623).val);
                                    exec_list *const f3622_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3622->then_instructions;

                                       body.emit(assign(r3621, r35BA, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3622->else_instructions;

                                       ir_expression *const r3624 = nequal(r35BA, body.constant(0u));
                                       ir_expression *const r3625 = expr(ir_unop_b2i, r3624);
                                       body.emit(assign(r3621, expr(ir_unop_i2u, r3625), 0x01));


                                    body.instructions = f3622_parent_instructions;
                                    body.emit(f3622);

                                    /* END IF */

                                    body.emit(assign(r3611, r3621, 0x01));

                                    body.emit(assign(r3612, body.constant(0u), 0x01));


                                 body.instructions = f361E_parent_instructions;
                                 body.emit(f361E);

                                 /* END IF */


                              body.instructions = f361C_parent_instructions;
                              body.emit(f361C);

                              /* END IF */

                              body.emit(assign(r3613, body.constant(0u), 0x01));


                           body.instructions = f3618_parent_instructions;
                           body.emit(f3618);

                           /* END IF */

                           ir_expression *const r3626 = nequal(r360F, body.constant(0u));
                           ir_expression *const r3627 = expr(ir_unop_b2i, r3626);
                           ir_expression *const r3628 = expr(ir_unop_i2u, r3627);
                           body.emit(assign(r3611, bit_or(r3611, r3628), 0x01));


                        body.instructions = f3616_parent_instructions;
                        body.emit(f3616);

                        /* END IF */

                        body.emit(assign(r35F9, r3613, 0x01));

                        body.emit(assign(r35FA, r3612, 0x01));

                        body.emit(assign(r35FB, r3611, 0x01));

                        body.emit(assign(r35F8, body.constant(int(0)), 0x01));

                        body.emit(assign(r35FE, less(r3611, body.constant(0u)), 0x01));


                     body.instructions = f360D_parent_instructions;
                     body.emit(f360D);

                     /* END IF */


                  body.instructions = f360A_parent_instructions;
                  body.emit(f360A);

                  /* END IF */


               body.instructions = f3600_parent_instructions;
               body.emit(f3600);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3629 = new(mem_ctx) ir_if(operand(r35FC).val);
               exec_list *const f3629_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3629->then_instructions;

                  /* IF CONDITION */
                  ir_if *f362A = new(mem_ctx) ir_if(operand(r35FE).val);
                  exec_list *const f362A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f362A->then_instructions;

                     ir_variable *const r362B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r362B, add(r35FA, body.constant(1u)), 0x01));

                     ir_expression *const r362C = less(r362B, r35FA);
                     ir_expression *const r362D = expr(ir_unop_b2i, r362C);
                     ir_expression *const r362E = expr(ir_unop_i2u, r362D);
                     body.emit(assign(r35F9, add(r35F9, r362E), 0x01));

                     ir_expression *const r362F = equal(r35FB, body.constant(0u));
                     ir_expression *const r3630 = expr(ir_unop_b2i, r362F);
                     ir_expression *const r3631 = expr(ir_unop_i2u, r3630);
                     ir_expression *const r3632 = add(r35FB, r3631);
                     ir_expression *const r3633 = bit_and(r3632, body.constant(1u));
                     ir_expression *const r3634 = expr(ir_unop_bit_not, r3633);
                     body.emit(assign(r35FA, bit_and(r362B, r3634), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f362A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3636 = bit_or(r35F9, r35FA);
                     ir_expression *const r3637 = equal(r3636, body.constant(0u));
                     ir_if *f3635 = new(mem_ctx) ir_if(operand(r3637).val);
                     exec_list *const f3635_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3635->then_instructions;

                        body.emit(assign(r35F8, body.constant(int(0)), 0x01));


                     body.instructions = f3635_parent_instructions;
                     body.emit(f3635);

                     /* END IF */


                  body.instructions = f362A_parent_instructions;
                  body.emit(f362A);

                  /* END IF */

                  ir_variable *const r3638 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3638);
                  ir_expression *const r3639 = lshift(r34C8, body.constant(int(31)));
                  ir_expression *const r363A = expr(ir_unop_i2u, r35F8);
                  ir_expression *const r363B = lshift(r363A, body.constant(int(20)));
                  ir_expression *const r363C = add(r3639, r363B);
                  body.emit(assign(r3638, add(r363C, r35F9), 0x02));

                  body.emit(assign(r3638, r35FA, 0x01));

                  body.emit(assign(r35FD, r3638, 0x03));

                  body.emit(assign(r35FC, body.constant(false), 0x01));


               body.instructions = f3629_parent_instructions;
               body.emit(f3629);

               /* END IF */

               body.emit(assign(r34C9, r35FD, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f358E->else_instructions;

               /* IF CONDITION */
               ir_expression *const r363E = equal(r34D3, body.constant(int(2047)));
               ir_if *f363D = new(mem_ctx) ir_if(operand(r363E).val);
               exec_list *const f363D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f363D->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3640 = bit_or(r34CF, r34D0);
                  ir_expression *const r3641 = bit_or(r34CD, r34CE);
                  ir_expression *const r3642 = bit_or(r3640, r3641);
                  ir_expression *const r3643 = nequal(r3642, body.constant(0u));
                  ir_if *f363F = new(mem_ctx) ir_if(operand(r3643).val);
                  exec_list *const f363F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f363F->then_instructions;

                     ir_variable *const r3644 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r3644, swizzle_x(r348F), 0x01));

                     ir_variable *const r3645 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r3645, body.constant(0u), 0x01));

                     ir_variable *const r3646 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r3644, bit_or(swizzle_y(r348F), body.constant(524288u)), 0x02));

                     body.emit(assign(r3645, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r3648 = lshift(swizzle_y(r348F), body.constant(int(1)));
                     ir_expression *const r3649 = lequal(body.constant(4292870144u), r3648);
                     ir_expression *const r364A = nequal(swizzle_x(r348F), body.constant(0u));
                     ir_expression *const r364B = bit_and(swizzle_y(r348F), body.constant(1048575u));
                     ir_expression *const r364C = nequal(r364B, body.constant(0u));
                     ir_expression *const r364D = logic_or(r364A, r364C);
                     ir_expression *const r364E = logic_and(r3649, r364D);
                     ir_if *f3647 = new(mem_ctx) ir_if(operand(r364E).val);
                     exec_list *const f3647_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3647->then_instructions;

                        body.emit(assign(r3646, r3644, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3647->else_instructions;

                        body.emit(assign(r3646, r3645, 0x03));


                     body.instructions = f3647_parent_instructions;
                     body.emit(f3647);

                     /* END IF */

                     body.emit(assign(r34C9, r3646, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f363F->else_instructions;

                     ir_constant_data r364F_data;
                     memset(&r364F_data, 0, sizeof(ir_constant_data));
                     r364F_data.u[0] = 4294967295;
                     r364F_data.u[1] = 4294967295;
                     ir_constant *const r364F = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r364F_data);
                     body.emit(assign(r34C9, r364F, 0x03));


                  body.instructions = f363F_parent_instructions;
                  body.emit(f363F);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f363D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3651 = equal(r34D3, body.constant(int(0)));
                  ir_if *f3650 = new(mem_ctx) ir_if(operand(r3651).val);
                  exec_list *const f3650_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3650->then_instructions;

                     body.emit(assign(r34CC, body.constant(int(1)), 0x01));

                     body.emit(assign(r34CB, body.constant(int(1)), 0x01));


                  body.instructions = f3650_parent_instructions;
                  body.emit(f3650);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3653 = less(r34CD, r34CF);
                  ir_if *f3652 = new(mem_ctx) ir_if(operand(r3653).val);
                  exec_list *const f3652_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3652->then_instructions;

                     ir_variable *const r3654 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r3655 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3655, sub(r34D0, r34CE), 0x01));

                     ir_expression *const r3656 = sub(r34CF, r34CD);
                     ir_expression *const r3657 = less(r34D0, r34CE);
                     ir_expression *const r3658 = expr(ir_unop_b2i, r3657);
                     ir_expression *const r3659 = expr(ir_unop_i2u, r3658);
                     body.emit(assign(r3654, sub(r3656, r3659), 0x01));

                     body.emit(assign(r34D1, add(r34CC, body.constant(int(-1))), 0x01));

                     ir_variable *const r365A = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r365A, add(r34D1, body.constant(int(-10))), 0x01));

                     ir_variable *const r365B = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r365B, r3654, 0x01));

                     ir_variable *const r365C = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r365C, r3655, 0x01));

                     ir_variable *const r365D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r365D);
                     ir_variable *const r365E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r365E);
                     /* IF CONDITION */
                     ir_expression *const r3660 = equal(r3654, body.constant(0u));
                     ir_if *f365F = new(mem_ctx) ir_if(operand(r3660).val);
                     exec_list *const f365F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f365F->then_instructions;

                        body.emit(assign(r365B, r3655, 0x01));

                        body.emit(assign(r365C, body.constant(0u), 0x01));

                        body.emit(assign(r365A, add(r365A, body.constant(int(-32))), 0x01));


                     body.instructions = f365F_parent_instructions;
                     body.emit(f365F);

                     /* END IF */

                     ir_variable *const r3661 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3661, r365B, 0x01));

                     ir_variable *const r3662 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3663 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3663);
                     /* IF CONDITION */
                     ir_expression *const r3665 = equal(r365B, body.constant(0u));
                     ir_if *f3664 = new(mem_ctx) ir_if(operand(r3665).val);
                     exec_list *const f3664_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3664->then_instructions;

                        body.emit(assign(r3662, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3664->else_instructions;

                        body.emit(assign(r3663, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3667 = bit_and(r365B, body.constant(4294901760u));
                        ir_expression *const r3668 = equal(r3667, body.constant(0u));
                        ir_if *f3666 = new(mem_ctx) ir_if(operand(r3668).val);
                        exec_list *const f3666_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3666->then_instructions;

                           body.emit(assign(r3663, body.constant(int(16)), 0x01));

                           body.emit(assign(r3661, lshift(r365B, body.constant(int(16))), 0x01));


                        body.instructions = f3666_parent_instructions;
                        body.emit(f3666);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r366A = bit_and(r3661, body.constant(4278190080u));
                        ir_expression *const r366B = equal(r366A, body.constant(0u));
                        ir_if *f3669 = new(mem_ctx) ir_if(operand(r366B).val);
                        exec_list *const f3669_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3669->then_instructions;

                           body.emit(assign(r3663, add(r3663, body.constant(int(8))), 0x01));

                           body.emit(assign(r3661, lshift(r3661, body.constant(int(8))), 0x01));


                        body.instructions = f3669_parent_instructions;
                        body.emit(f3669);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r366D = bit_and(r3661, body.constant(4026531840u));
                        ir_expression *const r366E = equal(r366D, body.constant(0u));
                        ir_if *f366C = new(mem_ctx) ir_if(operand(r366E).val);
                        exec_list *const f366C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f366C->then_instructions;

                           body.emit(assign(r3663, add(r3663, body.constant(int(4))), 0x01));

                           body.emit(assign(r3661, lshift(r3661, body.constant(int(4))), 0x01));


                        body.instructions = f366C_parent_instructions;
                        body.emit(f366C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3670 = bit_and(r3661, body.constant(3221225472u));
                        ir_expression *const r3671 = equal(r3670, body.constant(0u));
                        ir_if *f366F = new(mem_ctx) ir_if(operand(r3671).val);
                        exec_list *const f366F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f366F->then_instructions;

                           body.emit(assign(r3663, add(r3663, body.constant(int(2))), 0x01));

                           body.emit(assign(r3661, lshift(r3661, body.constant(int(2))), 0x01));


                        body.instructions = f366F_parent_instructions;
                        body.emit(f366F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3673 = bit_and(r3661, body.constant(2147483648u));
                        ir_expression *const r3674 = equal(r3673, body.constant(0u));
                        ir_if *f3672 = new(mem_ctx) ir_if(operand(r3674).val);
                        exec_list *const f3672_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3672->then_instructions;

                           body.emit(assign(r3663, add(r3663, body.constant(int(1))), 0x01));


                        body.instructions = f3672_parent_instructions;
                        body.emit(f3672);

                        /* END IF */

                        body.emit(assign(r3662, r3663, 0x01));


                     body.instructions = f3664_parent_instructions;
                     body.emit(f3664);

                     /* END IF */

                     body.emit(assign(r365E, add(r3662, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3676 = lequal(body.constant(int(0)), r365E);
                     ir_if *f3675 = new(mem_ctx) ir_if(operand(r3676).val);
                     exec_list *const f3675_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3675->then_instructions;

                        body.emit(assign(r365D, body.constant(0u), 0x01));

                        ir_variable *const r3677 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r3677, lshift(r365C, r365E), 0x01));

                        ir_variable *const r3678 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r367A = equal(r365E, body.constant(int(0)));
                        ir_if *f3679 = new(mem_ctx) ir_if(operand(r367A).val);
                        exec_list *const f3679_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3679->then_instructions;

                           body.emit(assign(r3678, r365B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3679->else_instructions;

                           ir_expression *const r367B = lshift(r365B, r365E);
                           ir_expression *const r367C = neg(r365E);
                           ir_expression *const r367D = bit_and(r367C, body.constant(int(31)));
                           ir_expression *const r367E = rshift(r365C, r367D);
                           body.emit(assign(r3678, bit_or(r367B, r367E), 0x01));


                        body.instructions = f3679_parent_instructions;
                        body.emit(f3679);

                        /* END IF */

                        body.emit(assign(r365B, r3678, 0x01));

                        body.emit(assign(r365C, r3677, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3675->else_instructions;

                        ir_variable *const r367F = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r367F, body.constant(0u), 0x01));

                        ir_variable *const r3680 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3680, neg(r365E), 0x01));

                        ir_variable *const r3681 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3681);
                        ir_variable *const r3682 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3682);
                        ir_variable *const r3683 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3683);
                        ir_variable *const r3684 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3685 = neg(r3680);
                        body.emit(assign(r3684, bit_and(r3685, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3687 = equal(r3680, body.constant(int(0)));
                        ir_if *f3686 = new(mem_ctx) ir_if(operand(r3687).val);
                        exec_list *const f3686_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3686->then_instructions;

                           body.emit(assign(r3681, r367F, 0x01));

                           body.emit(assign(r3682, r365C, 0x01));

                           body.emit(assign(r3683, r365B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3686->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3689 = less(r3680, body.constant(int(32)));
                           ir_if *f3688 = new(mem_ctx) ir_if(operand(r3689).val);
                           exec_list *const f3688_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3688->then_instructions;

                              body.emit(assign(r3681, lshift(r365C, r3684), 0x01));

                              ir_expression *const r368A = lshift(r365B, r3684);
                              ir_expression *const r368B = rshift(r365C, r3680);
                              body.emit(assign(r3682, bit_or(r368A, r368B), 0x01));

                              body.emit(assign(r3683, rshift(r365B, r3680), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3688->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r368D = equal(r3680, body.constant(int(32)));
                              ir_if *f368C = new(mem_ctx) ir_if(operand(r368D).val);
                              exec_list *const f368C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f368C->then_instructions;

                                 body.emit(assign(r3681, r365C, 0x01));

                                 body.emit(assign(r3682, r365B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f368C->else_instructions;

                                 body.emit(assign(r367F, bit_or(body.constant(0u), r365C), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r368F = less(r3680, body.constant(int(64)));
                                 ir_if *f368E = new(mem_ctx) ir_if(operand(r368F).val);
                                 exec_list *const f368E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f368E->then_instructions;

                                    body.emit(assign(r3681, lshift(r365B, r3684), 0x01));

                                    ir_expression *const r3690 = bit_and(r3680, body.constant(int(31)));
                                    body.emit(assign(r3682, rshift(r365B, r3690), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f368E->else_instructions;

                                    ir_variable *const r3691 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3693 = equal(r3680, body.constant(int(64)));
                                    ir_if *f3692 = new(mem_ctx) ir_if(operand(r3693).val);
                                    exec_list *const f3692_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3692->then_instructions;

                                       body.emit(assign(r3691, r365B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3692->else_instructions;

                                       ir_expression *const r3694 = nequal(r365B, body.constant(0u));
                                       ir_expression *const r3695 = expr(ir_unop_b2i, r3694);
                                       body.emit(assign(r3691, expr(ir_unop_i2u, r3695), 0x01));


                                    body.instructions = f3692_parent_instructions;
                                    body.emit(f3692);

                                    /* END IF */

                                    body.emit(assign(r3681, r3691, 0x01));

                                    body.emit(assign(r3682, body.constant(0u), 0x01));


                                 body.instructions = f368E_parent_instructions;
                                 body.emit(f368E);

                                 /* END IF */


                              body.instructions = f368C_parent_instructions;
                              body.emit(f368C);

                              /* END IF */

                              body.emit(assign(r3683, body.constant(0u), 0x01));


                           body.instructions = f3688_parent_instructions;
                           body.emit(f3688);

                           /* END IF */

                           ir_expression *const r3696 = nequal(r367F, body.constant(0u));
                           ir_expression *const r3697 = expr(ir_unop_b2i, r3696);
                           ir_expression *const r3698 = expr(ir_unop_i2u, r3697);
                           body.emit(assign(r3681, bit_or(r3681, r3698), 0x01));


                        body.instructions = f3686_parent_instructions;
                        body.emit(f3686);

                        /* END IF */

                        body.emit(assign(r365B, r3683, 0x01));

                        body.emit(assign(r365C, r3682, 0x01));

                        body.emit(assign(r365D, r3681, 0x01));


                     body.instructions = f3675_parent_instructions;
                     body.emit(f3675);

                     /* END IF */

                     body.emit(assign(r365A, sub(r365A, r365E), 0x01));

                     ir_variable *const r3699 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3699, r365A, 0x01));

                     ir_variable *const r369A = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r369A, r365B, 0x01));

                     ir_variable *const r369B = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r369B, r365C, 0x01));

                     ir_variable *const r369C = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r369C, r365D, 0x01));

                     ir_variable *const r369D = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r369D, body.constant(true), 0x01));

                     ir_variable *const r369E = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r369F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r369F);
                     ir_expression *const r36A0 = expr(ir_unop_u2i, r365D);
                     body.emit(assign(r369F, less(r36A0, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r36A2 = lequal(body.constant(int(2045)), r365A);
                     ir_if *f36A1 = new(mem_ctx) ir_if(operand(r36A2).val);
                     exec_list *const f36A1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f36A1->then_instructions;

                        ir_variable *const r36A3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r36A5 = less(body.constant(int(2045)), r365A);
                        ir_if *f36A4 = new(mem_ctx) ir_if(operand(r36A5).val);
                        exec_list *const f36A4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36A4->then_instructions;

                           body.emit(assign(r36A3, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36A4->else_instructions;

                           ir_variable *const r36A6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r36A8 = equal(r365A, body.constant(int(2045)));
                           ir_if *f36A7 = new(mem_ctx) ir_if(operand(r36A8).val);
                           exec_list *const f36A7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36A7->then_instructions;

                              ir_expression *const r36A9 = equal(body.constant(2097151u), r365B);
                              ir_expression *const r36AA = equal(body.constant(4294967295u), r365C);
                              body.emit(assign(r36A6, logic_and(r36A9, r36AA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f36A7->else_instructions;

                              body.emit(assign(r36A6, body.constant(false), 0x01));


                           body.instructions = f36A7_parent_instructions;
                           body.emit(f36A7);

                           /* END IF */

                           body.emit(assign(r36A3, logic_and(r36A6, r369F), 0x01));


                        body.instructions = f36A4_parent_instructions;
                        body.emit(f36A4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f36AB = new(mem_ctx) ir_if(operand(r36A3).val);
                        exec_list *const f36AB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36AB->then_instructions;

                           ir_variable *const r36AC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r36AC);
                           ir_expression *const r36AD = lshift(r34C8, body.constant(int(31)));
                           body.emit(assign(r36AC, add(r36AD, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r36AC, body.constant(0u), 0x01));

                           body.emit(assign(r369E, r36AC, 0x03));

                           body.emit(assign(r369D, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36AB->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r36AF = less(r365A, body.constant(int(0)));
                           ir_if *f36AE = new(mem_ctx) ir_if(operand(r36AF).val);
                           exec_list *const f36AE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36AE->then_instructions;

                              ir_variable *const r36B0 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r36B0, r365D, 0x01));

                              ir_variable *const r36B1 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r36B1, neg(r365A), 0x01));

                              ir_variable *const r36B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r36B2);
                              ir_variable *const r36B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r36B3);
                              ir_variable *const r36B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r36B4);
                              ir_variable *const r36B5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r36B6 = neg(r36B1);
                              body.emit(assign(r36B5, bit_and(r36B6, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r36B8 = equal(r36B1, body.constant(int(0)));
                              ir_if *f36B7 = new(mem_ctx) ir_if(operand(r36B8).val);
                              exec_list *const f36B7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f36B7->then_instructions;

                                 body.emit(assign(r36B2, r365D, 0x01));

                                 body.emit(assign(r36B3, r365C, 0x01));

                                 body.emit(assign(r36B4, r365B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f36B7->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r36BA = less(r36B1, body.constant(int(32)));
                                 ir_if *f36B9 = new(mem_ctx) ir_if(operand(r36BA).val);
                                 exec_list *const f36B9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f36B9->then_instructions;

                                    body.emit(assign(r36B2, lshift(r365C, r36B5), 0x01));

                                    ir_expression *const r36BB = lshift(r365B, r36B5);
                                    ir_expression *const r36BC = rshift(r365C, r36B1);
                                    body.emit(assign(r36B3, bit_or(r36BB, r36BC), 0x01));

                                    body.emit(assign(r36B4, rshift(r365B, r36B1), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f36B9->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r36BE = equal(r36B1, body.constant(int(32)));
                                    ir_if *f36BD = new(mem_ctx) ir_if(operand(r36BE).val);
                                    exec_list *const f36BD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f36BD->then_instructions;

                                       body.emit(assign(r36B2, r365C, 0x01));

                                       body.emit(assign(r36B3, r365B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f36BD->else_instructions;

                                       body.emit(assign(r36B0, bit_or(r365D, r365C), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r36C0 = less(r36B1, body.constant(int(64)));
                                       ir_if *f36BF = new(mem_ctx) ir_if(operand(r36C0).val);
                                       exec_list *const f36BF_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f36BF->then_instructions;

                                          body.emit(assign(r36B2, lshift(r365B, r36B5), 0x01));

                                          ir_expression *const r36C1 = bit_and(r36B1, body.constant(int(31)));
                                          body.emit(assign(r36B3, rshift(r365B, r36C1), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f36BF->else_instructions;

                                          ir_variable *const r36C2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r36C4 = equal(r36B1, body.constant(int(64)));
                                          ir_if *f36C3 = new(mem_ctx) ir_if(operand(r36C4).val);
                                          exec_list *const f36C3_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f36C3->then_instructions;

                                             body.emit(assign(r36C2, r365B, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f36C3->else_instructions;

                                             ir_expression *const r36C5 = nequal(r365B, body.constant(0u));
                                             ir_expression *const r36C6 = expr(ir_unop_b2i, r36C5);
                                             body.emit(assign(r36C2, expr(ir_unop_i2u, r36C6), 0x01));


                                          body.instructions = f36C3_parent_instructions;
                                          body.emit(f36C3);

                                          /* END IF */

                                          body.emit(assign(r36B2, r36C2, 0x01));

                                          body.emit(assign(r36B3, body.constant(0u), 0x01));


                                       body.instructions = f36BF_parent_instructions;
                                       body.emit(f36BF);

                                       /* END IF */


                                    body.instructions = f36BD_parent_instructions;
                                    body.emit(f36BD);

                                    /* END IF */

                                    body.emit(assign(r36B4, body.constant(0u), 0x01));


                                 body.instructions = f36B9_parent_instructions;
                                 body.emit(f36B9);

                                 /* END IF */

                                 ir_expression *const r36C7 = nequal(r36B0, body.constant(0u));
                                 ir_expression *const r36C8 = expr(ir_unop_b2i, r36C7);
                                 ir_expression *const r36C9 = expr(ir_unop_i2u, r36C8);
                                 body.emit(assign(r36B2, bit_or(r36B2, r36C9), 0x01));


                              body.instructions = f36B7_parent_instructions;
                              body.emit(f36B7);

                              /* END IF */

                              body.emit(assign(r369A, r36B4, 0x01));

                              body.emit(assign(r369B, r36B3, 0x01));

                              body.emit(assign(r369C, r36B2, 0x01));

                              body.emit(assign(r3699, body.constant(int(0)), 0x01));

                              body.emit(assign(r369F, less(r36B2, body.constant(0u)), 0x01));


                           body.instructions = f36AE_parent_instructions;
                           body.emit(f36AE);

                           /* END IF */


                        body.instructions = f36AB_parent_instructions;
                        body.emit(f36AB);

                        /* END IF */


                     body.instructions = f36A1_parent_instructions;
                     body.emit(f36A1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f36CA = new(mem_ctx) ir_if(operand(r369D).val);
                     exec_list *const f36CA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f36CA->then_instructions;

                        /* IF CONDITION */
                        ir_if *f36CB = new(mem_ctx) ir_if(operand(r369F).val);
                        exec_list *const f36CB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36CB->then_instructions;

                           ir_variable *const r36CC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r36CC, add(r369B, body.constant(1u)), 0x01));

                           ir_expression *const r36CD = less(r36CC, r369B);
                           ir_expression *const r36CE = expr(ir_unop_b2i, r36CD);
                           ir_expression *const r36CF = expr(ir_unop_i2u, r36CE);
                           body.emit(assign(r369A, add(r369A, r36CF), 0x01));

                           ir_expression *const r36D0 = equal(r369C, body.constant(0u));
                           ir_expression *const r36D1 = expr(ir_unop_b2i, r36D0);
                           ir_expression *const r36D2 = expr(ir_unop_i2u, r36D1);
                           ir_expression *const r36D3 = add(r369C, r36D2);
                           ir_expression *const r36D4 = bit_and(r36D3, body.constant(1u));
                           ir_expression *const r36D5 = expr(ir_unop_bit_not, r36D4);
                           body.emit(assign(r369B, bit_and(r36CC, r36D5), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36CB->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r36D7 = bit_or(r369A, r369B);
                           ir_expression *const r36D8 = equal(r36D7, body.constant(0u));
                           ir_if *f36D6 = new(mem_ctx) ir_if(operand(r36D8).val);
                           exec_list *const f36D6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36D6->then_instructions;

                              body.emit(assign(r3699, body.constant(int(0)), 0x01));


                           body.instructions = f36D6_parent_instructions;
                           body.emit(f36D6);

                           /* END IF */


                        body.instructions = f36CB_parent_instructions;
                        body.emit(f36CB);

                        /* END IF */

                        ir_variable *const r36D9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r36D9);
                        ir_expression *const r36DA = lshift(r34C8, body.constant(int(31)));
                        ir_expression *const r36DB = expr(ir_unop_i2u, r3699);
                        ir_expression *const r36DC = lshift(r36DB, body.constant(int(20)));
                        ir_expression *const r36DD = add(r36DA, r36DC);
                        body.emit(assign(r36D9, add(r36DD, r369A), 0x02));

                        body.emit(assign(r36D9, r369B, 0x01));

                        body.emit(assign(r369E, r36D9, 0x03));

                        body.emit(assign(r369D, body.constant(false), 0x01));


                     body.instructions = f36CA_parent_instructions;
                     body.emit(f36CA);

                     /* END IF */

                     body.emit(assign(r34C9, r369E, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3652->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r36DF = less(r34CF, r34CD);
                     ir_if *f36DE = new(mem_ctx) ir_if(operand(r36DF).val);
                     exec_list *const f36DE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f36DE->then_instructions;

                        ir_variable *const r36E0 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r36E1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r36E1, sub(r34CE, r34D0), 0x01));

                        ir_expression *const r36E2 = sub(r34CD, r34CF);
                        ir_expression *const r36E3 = less(r34CE, r34D0);
                        ir_expression *const r36E4 = expr(ir_unop_b2i, r36E3);
                        ir_expression *const r36E5 = expr(ir_unop_i2u, r36E4);
                        body.emit(assign(r36E0, sub(r36E2, r36E5), 0x01));

                        body.emit(assign(r34C8, bit_xor(r34C8, body.constant(1u)), 0x01));

                        body.emit(assign(r34D1, add(r34CB, body.constant(int(-1))), 0x01));

                        ir_variable *const r36E6 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r36E6, add(r34D1, body.constant(int(-10))), 0x01));

                        ir_variable *const r36E7 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r36E7, r36E0, 0x01));

                        ir_variable *const r36E8 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r36E8, r36E1, 0x01));

                        ir_variable *const r36E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r36E9);
                        ir_variable *const r36EA = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r36EA);
                        /* IF CONDITION */
                        ir_expression *const r36EC = equal(r36E0, body.constant(0u));
                        ir_if *f36EB = new(mem_ctx) ir_if(operand(r36EC).val);
                        exec_list *const f36EB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36EB->then_instructions;

                           body.emit(assign(r36E7, r36E1, 0x01));

                           body.emit(assign(r36E8, body.constant(0u), 0x01));

                           body.emit(assign(r36E6, add(r36E6, body.constant(int(-32))), 0x01));


                        body.instructions = f36EB_parent_instructions;
                        body.emit(f36EB);

                        /* END IF */

                        ir_variable *const r36ED = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r36ED, r36E7, 0x01));

                        ir_variable *const r36EE = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r36EF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r36EF);
                        /* IF CONDITION */
                        ir_expression *const r36F1 = equal(r36E7, body.constant(0u));
                        ir_if *f36F0 = new(mem_ctx) ir_if(operand(r36F1).val);
                        exec_list *const f36F0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36F0->then_instructions;

                           body.emit(assign(r36EE, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36F0->else_instructions;

                           body.emit(assign(r36EF, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r36F3 = bit_and(r36E7, body.constant(4294901760u));
                           ir_expression *const r36F4 = equal(r36F3, body.constant(0u));
                           ir_if *f36F2 = new(mem_ctx) ir_if(operand(r36F4).val);
                           exec_list *const f36F2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36F2->then_instructions;

                              body.emit(assign(r36EF, body.constant(int(16)), 0x01));

                              body.emit(assign(r36ED, lshift(r36E7, body.constant(int(16))), 0x01));


                           body.instructions = f36F2_parent_instructions;
                           body.emit(f36F2);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r36F6 = bit_and(r36ED, body.constant(4278190080u));
                           ir_expression *const r36F7 = equal(r36F6, body.constant(0u));
                           ir_if *f36F5 = new(mem_ctx) ir_if(operand(r36F7).val);
                           exec_list *const f36F5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36F5->then_instructions;

                              body.emit(assign(r36EF, add(r36EF, body.constant(int(8))), 0x01));

                              body.emit(assign(r36ED, lshift(r36ED, body.constant(int(8))), 0x01));


                           body.instructions = f36F5_parent_instructions;
                           body.emit(f36F5);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r36F9 = bit_and(r36ED, body.constant(4026531840u));
                           ir_expression *const r36FA = equal(r36F9, body.constant(0u));
                           ir_if *f36F8 = new(mem_ctx) ir_if(operand(r36FA).val);
                           exec_list *const f36F8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36F8->then_instructions;

                              body.emit(assign(r36EF, add(r36EF, body.constant(int(4))), 0x01));

                              body.emit(assign(r36ED, lshift(r36ED, body.constant(int(4))), 0x01));


                           body.instructions = f36F8_parent_instructions;
                           body.emit(f36F8);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r36FC = bit_and(r36ED, body.constant(3221225472u));
                           ir_expression *const r36FD = equal(r36FC, body.constant(0u));
                           ir_if *f36FB = new(mem_ctx) ir_if(operand(r36FD).val);
                           exec_list *const f36FB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36FB->then_instructions;

                              body.emit(assign(r36EF, add(r36EF, body.constant(int(2))), 0x01));

                              body.emit(assign(r36ED, lshift(r36ED, body.constant(int(2))), 0x01));


                           body.instructions = f36FB_parent_instructions;
                           body.emit(f36FB);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r36FF = bit_and(r36ED, body.constant(2147483648u));
                           ir_expression *const r3700 = equal(r36FF, body.constant(0u));
                           ir_if *f36FE = new(mem_ctx) ir_if(operand(r3700).val);
                           exec_list *const f36FE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36FE->then_instructions;

                              body.emit(assign(r36EF, add(r36EF, body.constant(int(1))), 0x01));


                           body.instructions = f36FE_parent_instructions;
                           body.emit(f36FE);

                           /* END IF */

                           body.emit(assign(r36EE, r36EF, 0x01));


                        body.instructions = f36F0_parent_instructions;
                        body.emit(f36F0);

                        /* END IF */

                        body.emit(assign(r36EA, add(r36EE, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3702 = lequal(body.constant(int(0)), r36EA);
                        ir_if *f3701 = new(mem_ctx) ir_if(operand(r3702).val);
                        exec_list *const f3701_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3701->then_instructions;

                           body.emit(assign(r36E9, body.constant(0u), 0x01));

                           ir_variable *const r3703 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3703, lshift(r36E8, r36EA), 0x01));

                           ir_variable *const r3704 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3706 = equal(r36EA, body.constant(int(0)));
                           ir_if *f3705 = new(mem_ctx) ir_if(operand(r3706).val);
                           exec_list *const f3705_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3705->then_instructions;

                              body.emit(assign(r3704, r36E7, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3705->else_instructions;

                              ir_expression *const r3707 = lshift(r36E7, r36EA);
                              ir_expression *const r3708 = neg(r36EA);
                              ir_expression *const r3709 = bit_and(r3708, body.constant(int(31)));
                              ir_expression *const r370A = rshift(r36E8, r3709);
                              body.emit(assign(r3704, bit_or(r3707, r370A), 0x01));


                           body.instructions = f3705_parent_instructions;
                           body.emit(f3705);

                           /* END IF */

                           body.emit(assign(r36E7, r3704, 0x01));

                           body.emit(assign(r36E8, r3703, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3701->else_instructions;

                           ir_variable *const r370B = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r370B, body.constant(0u), 0x01));

                           ir_variable *const r370C = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r370C, neg(r36EA), 0x01));

                           ir_variable *const r370D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r370D);
                           ir_variable *const r370E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r370E);
                           ir_variable *const r370F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r370F);
                           ir_variable *const r3710 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3711 = neg(r370C);
                           body.emit(assign(r3710, bit_and(r3711, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3713 = equal(r370C, body.constant(int(0)));
                           ir_if *f3712 = new(mem_ctx) ir_if(operand(r3713).val);
                           exec_list *const f3712_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3712->then_instructions;

                              body.emit(assign(r370D, r370B, 0x01));

                              body.emit(assign(r370E, r36E8, 0x01));

                              body.emit(assign(r370F, r36E7, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3712->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3715 = less(r370C, body.constant(int(32)));
                              ir_if *f3714 = new(mem_ctx) ir_if(operand(r3715).val);
                              exec_list *const f3714_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3714->then_instructions;

                                 body.emit(assign(r370D, lshift(r36E8, r3710), 0x01));

                                 ir_expression *const r3716 = lshift(r36E7, r3710);
                                 ir_expression *const r3717 = rshift(r36E8, r370C);
                                 body.emit(assign(r370E, bit_or(r3716, r3717), 0x01));

                                 body.emit(assign(r370F, rshift(r36E7, r370C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3714->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3719 = equal(r370C, body.constant(int(32)));
                                 ir_if *f3718 = new(mem_ctx) ir_if(operand(r3719).val);
                                 exec_list *const f3718_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3718->then_instructions;

                                    body.emit(assign(r370D, r36E8, 0x01));

                                    body.emit(assign(r370E, r36E7, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3718->else_instructions;

                                    body.emit(assign(r370B, bit_or(body.constant(0u), r36E8), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r371B = less(r370C, body.constant(int(64)));
                                    ir_if *f371A = new(mem_ctx) ir_if(operand(r371B).val);
                                    exec_list *const f371A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f371A->then_instructions;

                                       body.emit(assign(r370D, lshift(r36E7, r3710), 0x01));

                                       ir_expression *const r371C = bit_and(r370C, body.constant(int(31)));
                                       body.emit(assign(r370E, rshift(r36E7, r371C), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f371A->else_instructions;

                                       ir_variable *const r371D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r371F = equal(r370C, body.constant(int(64)));
                                       ir_if *f371E = new(mem_ctx) ir_if(operand(r371F).val);
                                       exec_list *const f371E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f371E->then_instructions;

                                          body.emit(assign(r371D, r36E7, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f371E->else_instructions;

                                          ir_expression *const r3720 = nequal(r36E7, body.constant(0u));
                                          ir_expression *const r3721 = expr(ir_unop_b2i, r3720);
                                          body.emit(assign(r371D, expr(ir_unop_i2u, r3721), 0x01));


                                       body.instructions = f371E_parent_instructions;
                                       body.emit(f371E);

                                       /* END IF */

                                       body.emit(assign(r370D, r371D, 0x01));

                                       body.emit(assign(r370E, body.constant(0u), 0x01));


                                    body.instructions = f371A_parent_instructions;
                                    body.emit(f371A);

                                    /* END IF */


                                 body.instructions = f3718_parent_instructions;
                                 body.emit(f3718);

                                 /* END IF */

                                 body.emit(assign(r370F, body.constant(0u), 0x01));


                              body.instructions = f3714_parent_instructions;
                              body.emit(f3714);

                              /* END IF */

                              ir_expression *const r3722 = nequal(r370B, body.constant(0u));
                              ir_expression *const r3723 = expr(ir_unop_b2i, r3722);
                              ir_expression *const r3724 = expr(ir_unop_i2u, r3723);
                              body.emit(assign(r370D, bit_or(r370D, r3724), 0x01));


                           body.instructions = f3712_parent_instructions;
                           body.emit(f3712);

                           /* END IF */

                           body.emit(assign(r36E7, r370F, 0x01));

                           body.emit(assign(r36E8, r370E, 0x01));

                           body.emit(assign(r36E9, r370D, 0x01));


                        body.instructions = f3701_parent_instructions;
                        body.emit(f3701);

                        /* END IF */

                        body.emit(assign(r36E6, sub(r36E6, r36EA), 0x01));

                        ir_variable *const r3725 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3725, r36E6, 0x01));

                        ir_variable *const r3726 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3726, r36E7, 0x01));

                        ir_variable *const r3727 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3727, r36E8, 0x01));

                        ir_variable *const r3728 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r3728, r36E9, 0x01));

                        ir_variable *const r3729 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r3729, body.constant(true), 0x01));

                        ir_variable *const r372A = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r372B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r372B);
                        ir_expression *const r372C = expr(ir_unop_u2i, r36E9);
                        body.emit(assign(r372B, less(r372C, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r372E = lequal(body.constant(int(2045)), r36E6);
                        ir_if *f372D = new(mem_ctx) ir_if(operand(r372E).val);
                        exec_list *const f372D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f372D->then_instructions;

                           ir_variable *const r372F = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3731 = less(body.constant(int(2045)), r36E6);
                           ir_if *f3730 = new(mem_ctx) ir_if(operand(r3731).val);
                           exec_list *const f3730_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3730->then_instructions;

                              body.emit(assign(r372F, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3730->else_instructions;

                              ir_variable *const r3732 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3734 = equal(r36E6, body.constant(int(2045)));
                              ir_if *f3733 = new(mem_ctx) ir_if(operand(r3734).val);
                              exec_list *const f3733_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3733->then_instructions;

                                 ir_expression *const r3735 = equal(body.constant(2097151u), r36E7);
                                 ir_expression *const r3736 = equal(body.constant(4294967295u), r36E8);
                                 body.emit(assign(r3732, logic_and(r3735, r3736), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3733->else_instructions;

                                 body.emit(assign(r3732, body.constant(false), 0x01));


                              body.instructions = f3733_parent_instructions;
                              body.emit(f3733);

                              /* END IF */

                              body.emit(assign(r372F, logic_and(r3732, r372B), 0x01));


                           body.instructions = f3730_parent_instructions;
                           body.emit(f3730);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3737 = new(mem_ctx) ir_if(operand(r372F).val);
                           exec_list *const f3737_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3737->then_instructions;

                              ir_variable *const r3738 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3738);
                              ir_expression *const r3739 = lshift(r34C8, body.constant(int(31)));
                              body.emit(assign(r3738, add(r3739, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r3738, body.constant(0u), 0x01));

                              body.emit(assign(r372A, r3738, 0x03));

                              body.emit(assign(r3729, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3737->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r373B = less(r36E6, body.constant(int(0)));
                              ir_if *f373A = new(mem_ctx) ir_if(operand(r373B).val);
                              exec_list *const f373A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f373A->then_instructions;

                                 ir_variable *const r373C = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r373C, r36E9, 0x01));

                                 ir_variable *const r373D = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r373D, neg(r36E6), 0x01));

                                 ir_variable *const r373E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r373E);
                                 ir_variable *const r373F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r373F);
                                 ir_variable *const r3740 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r3740);
                                 ir_variable *const r3741 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r3742 = neg(r373D);
                                 body.emit(assign(r3741, bit_and(r3742, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3744 = equal(r373D, body.constant(int(0)));
                                 ir_if *f3743 = new(mem_ctx) ir_if(operand(r3744).val);
                                 exec_list *const f3743_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3743->then_instructions;

                                    body.emit(assign(r373E, r36E9, 0x01));

                                    body.emit(assign(r373F, r36E8, 0x01));

                                    body.emit(assign(r3740, r36E7, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3743->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3746 = less(r373D, body.constant(int(32)));
                                    ir_if *f3745 = new(mem_ctx) ir_if(operand(r3746).val);
                                    exec_list *const f3745_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3745->then_instructions;

                                       body.emit(assign(r373E, lshift(r36E8, r3741), 0x01));

                                       ir_expression *const r3747 = lshift(r36E7, r3741);
                                       ir_expression *const r3748 = rshift(r36E8, r373D);
                                       body.emit(assign(r373F, bit_or(r3747, r3748), 0x01));

                                       body.emit(assign(r3740, rshift(r36E7, r373D), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3745->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r374A = equal(r373D, body.constant(int(32)));
                                       ir_if *f3749 = new(mem_ctx) ir_if(operand(r374A).val);
                                       exec_list *const f3749_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3749->then_instructions;

                                          body.emit(assign(r373E, r36E8, 0x01));

                                          body.emit(assign(r373F, r36E7, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3749->else_instructions;

                                          body.emit(assign(r373C, bit_or(r36E9, r36E8), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r374C = less(r373D, body.constant(int(64)));
                                          ir_if *f374B = new(mem_ctx) ir_if(operand(r374C).val);
                                          exec_list *const f374B_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f374B->then_instructions;

                                             body.emit(assign(r373E, lshift(r36E7, r3741), 0x01));

                                             ir_expression *const r374D = bit_and(r373D, body.constant(int(31)));
                                             body.emit(assign(r373F, rshift(r36E7, r374D), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f374B->else_instructions;

                                             ir_variable *const r374E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r3750 = equal(r373D, body.constant(int(64)));
                                             ir_if *f374F = new(mem_ctx) ir_if(operand(r3750).val);
                                             exec_list *const f374F_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f374F->then_instructions;

                                                body.emit(assign(r374E, r36E7, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f374F->else_instructions;

                                                ir_expression *const r3751 = nequal(r36E7, body.constant(0u));
                                                ir_expression *const r3752 = expr(ir_unop_b2i, r3751);
                                                body.emit(assign(r374E, expr(ir_unop_i2u, r3752), 0x01));


                                             body.instructions = f374F_parent_instructions;
                                             body.emit(f374F);

                                             /* END IF */

                                             body.emit(assign(r373E, r374E, 0x01));

                                             body.emit(assign(r373F, body.constant(0u), 0x01));


                                          body.instructions = f374B_parent_instructions;
                                          body.emit(f374B);

                                          /* END IF */


                                       body.instructions = f3749_parent_instructions;
                                       body.emit(f3749);

                                       /* END IF */

                                       body.emit(assign(r3740, body.constant(0u), 0x01));


                                    body.instructions = f3745_parent_instructions;
                                    body.emit(f3745);

                                    /* END IF */

                                    ir_expression *const r3753 = nequal(r373C, body.constant(0u));
                                    ir_expression *const r3754 = expr(ir_unop_b2i, r3753);
                                    ir_expression *const r3755 = expr(ir_unop_i2u, r3754);
                                    body.emit(assign(r373E, bit_or(r373E, r3755), 0x01));


                                 body.instructions = f3743_parent_instructions;
                                 body.emit(f3743);

                                 /* END IF */

                                 body.emit(assign(r3726, r3740, 0x01));

                                 body.emit(assign(r3727, r373F, 0x01));

                                 body.emit(assign(r3728, r373E, 0x01));

                                 body.emit(assign(r3725, body.constant(int(0)), 0x01));

                                 body.emit(assign(r372B, less(r373E, body.constant(0u)), 0x01));


                              body.instructions = f373A_parent_instructions;
                              body.emit(f373A);

                              /* END IF */


                           body.instructions = f3737_parent_instructions;
                           body.emit(f3737);

                           /* END IF */


                        body.instructions = f372D_parent_instructions;
                        body.emit(f372D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3756 = new(mem_ctx) ir_if(operand(r3729).val);
                        exec_list *const f3756_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3756->then_instructions;

                           /* IF CONDITION */
                           ir_if *f3757 = new(mem_ctx) ir_if(operand(r372B).val);
                           exec_list *const f3757_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3757->then_instructions;

                              ir_variable *const r3758 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r3758, add(r3727, body.constant(1u)), 0x01));

                              ir_expression *const r3759 = less(r3758, r3727);
                              ir_expression *const r375A = expr(ir_unop_b2i, r3759);
                              ir_expression *const r375B = expr(ir_unop_i2u, r375A);
                              body.emit(assign(r3726, add(r3726, r375B), 0x01));

                              ir_expression *const r375C = equal(r3728, body.constant(0u));
                              ir_expression *const r375D = expr(ir_unop_b2i, r375C);
                              ir_expression *const r375E = expr(ir_unop_i2u, r375D);
                              ir_expression *const r375F = add(r3728, r375E);
                              ir_expression *const r3760 = bit_and(r375F, body.constant(1u));
                              ir_expression *const r3761 = expr(ir_unop_bit_not, r3760);
                              body.emit(assign(r3727, bit_and(r3758, r3761), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3757->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3763 = bit_or(r3726, r3727);
                              ir_expression *const r3764 = equal(r3763, body.constant(0u));
                              ir_if *f3762 = new(mem_ctx) ir_if(operand(r3764).val);
                              exec_list *const f3762_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3762->then_instructions;

                                 body.emit(assign(r3725, body.constant(int(0)), 0x01));


                              body.instructions = f3762_parent_instructions;
                              body.emit(f3762);

                              /* END IF */


                           body.instructions = f3757_parent_instructions;
                           body.emit(f3757);

                           /* END IF */

                           ir_variable *const r3765 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3765);
                           ir_expression *const r3766 = lshift(r34C8, body.constant(int(31)));
                           ir_expression *const r3767 = expr(ir_unop_i2u, r3725);
                           ir_expression *const r3768 = lshift(r3767, body.constant(int(20)));
                           ir_expression *const r3769 = add(r3766, r3768);
                           body.emit(assign(r3765, add(r3769, r3726), 0x02));

                           body.emit(assign(r3765, r3727, 0x01));

                           body.emit(assign(r372A, r3765, 0x03));

                           body.emit(assign(r3729, body.constant(false), 0x01));


                        body.instructions = f3756_parent_instructions;
                        body.emit(f3756);

                        /* END IF */

                        body.emit(assign(r34C9, r372A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f36DE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r376B = less(r34CE, r34D0);
                        ir_if *f376A = new(mem_ctx) ir_if(operand(r376B).val);
                        exec_list *const f376A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f376A->then_instructions;

                           ir_variable *const r376C = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r376D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r376D, sub(r34D0, r34CE), 0x01));

                           ir_expression *const r376E = sub(r34CF, r34CD);
                           ir_expression *const r376F = less(r34D0, r34CE);
                           ir_expression *const r3770 = expr(ir_unop_b2i, r376F);
                           ir_expression *const r3771 = expr(ir_unop_i2u, r3770);
                           body.emit(assign(r376C, sub(r376E, r3771), 0x01));

                           body.emit(assign(r34D1, add(r34CC, body.constant(int(-1))), 0x01));

                           ir_variable *const r3772 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3772, add(r34D1, body.constant(int(-10))), 0x01));

                           ir_variable *const r3773 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3773, r376C, 0x01));

                           ir_variable *const r3774 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3774, r376D, 0x01));

                           ir_variable *const r3775 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r3775);
                           ir_variable *const r3776 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r3776);
                           /* IF CONDITION */
                           ir_expression *const r3778 = equal(r376C, body.constant(0u));
                           ir_if *f3777 = new(mem_ctx) ir_if(operand(r3778).val);
                           exec_list *const f3777_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3777->then_instructions;

                              body.emit(assign(r3773, r376D, 0x01));

                              body.emit(assign(r3774, body.constant(0u), 0x01));

                              body.emit(assign(r3772, add(r3772, body.constant(int(-32))), 0x01));


                           body.instructions = f3777_parent_instructions;
                           body.emit(f3777);

                           /* END IF */

                           ir_variable *const r3779 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r3779, r3773, 0x01));

                           ir_variable *const r377A = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r377B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r377B);
                           /* IF CONDITION */
                           ir_expression *const r377D = equal(r3773, body.constant(0u));
                           ir_if *f377C = new(mem_ctx) ir_if(operand(r377D).val);
                           exec_list *const f377C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f377C->then_instructions;

                              body.emit(assign(r377A, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f377C->else_instructions;

                              body.emit(assign(r377B, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r377F = bit_and(r3773, body.constant(4294901760u));
                              ir_expression *const r3780 = equal(r377F, body.constant(0u));
                              ir_if *f377E = new(mem_ctx) ir_if(operand(r3780).val);
                              exec_list *const f377E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f377E->then_instructions;

                                 body.emit(assign(r377B, body.constant(int(16)), 0x01));

                                 body.emit(assign(r3779, lshift(r3773, body.constant(int(16))), 0x01));


                              body.instructions = f377E_parent_instructions;
                              body.emit(f377E);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3782 = bit_and(r3779, body.constant(4278190080u));
                              ir_expression *const r3783 = equal(r3782, body.constant(0u));
                              ir_if *f3781 = new(mem_ctx) ir_if(operand(r3783).val);
                              exec_list *const f3781_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3781->then_instructions;

                                 body.emit(assign(r377B, add(r377B, body.constant(int(8))), 0x01));

                                 body.emit(assign(r3779, lshift(r3779, body.constant(int(8))), 0x01));


                              body.instructions = f3781_parent_instructions;
                              body.emit(f3781);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3785 = bit_and(r3779, body.constant(4026531840u));
                              ir_expression *const r3786 = equal(r3785, body.constant(0u));
                              ir_if *f3784 = new(mem_ctx) ir_if(operand(r3786).val);
                              exec_list *const f3784_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3784->then_instructions;

                                 body.emit(assign(r377B, add(r377B, body.constant(int(4))), 0x01));

                                 body.emit(assign(r3779, lshift(r3779, body.constant(int(4))), 0x01));


                              body.instructions = f3784_parent_instructions;
                              body.emit(f3784);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3788 = bit_and(r3779, body.constant(3221225472u));
                              ir_expression *const r3789 = equal(r3788, body.constant(0u));
                              ir_if *f3787 = new(mem_ctx) ir_if(operand(r3789).val);
                              exec_list *const f3787_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3787->then_instructions;

                                 body.emit(assign(r377B, add(r377B, body.constant(int(2))), 0x01));

                                 body.emit(assign(r3779, lshift(r3779, body.constant(int(2))), 0x01));


                              body.instructions = f3787_parent_instructions;
                              body.emit(f3787);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r378B = bit_and(r3779, body.constant(2147483648u));
                              ir_expression *const r378C = equal(r378B, body.constant(0u));
                              ir_if *f378A = new(mem_ctx) ir_if(operand(r378C).val);
                              exec_list *const f378A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f378A->then_instructions;

                                 body.emit(assign(r377B, add(r377B, body.constant(int(1))), 0x01));


                              body.instructions = f378A_parent_instructions;
                              body.emit(f378A);

                              /* END IF */

                              body.emit(assign(r377A, r377B, 0x01));


                           body.instructions = f377C_parent_instructions;
                           body.emit(f377C);

                           /* END IF */

                           body.emit(assign(r3776, add(r377A, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r378E = lequal(body.constant(int(0)), r3776);
                           ir_if *f378D = new(mem_ctx) ir_if(operand(r378E).val);
                           exec_list *const f378D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f378D->then_instructions;

                              body.emit(assign(r3775, body.constant(0u), 0x01));

                              ir_variable *const r378F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r378F, lshift(r3774, r3776), 0x01));

                              ir_variable *const r3790 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3792 = equal(r3776, body.constant(int(0)));
                              ir_if *f3791 = new(mem_ctx) ir_if(operand(r3792).val);
                              exec_list *const f3791_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3791->then_instructions;

                                 body.emit(assign(r3790, r3773, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3791->else_instructions;

                                 ir_expression *const r3793 = lshift(r3773, r3776);
                                 ir_expression *const r3794 = neg(r3776);
                                 ir_expression *const r3795 = bit_and(r3794, body.constant(int(31)));
                                 ir_expression *const r3796 = rshift(r3774, r3795);
                                 body.emit(assign(r3790, bit_or(r3793, r3796), 0x01));


                              body.instructions = f3791_parent_instructions;
                              body.emit(f3791);

                              /* END IF */

                              body.emit(assign(r3773, r3790, 0x01));

                              body.emit(assign(r3774, r378F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f378D->else_instructions;

                              ir_variable *const r3797 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3797, body.constant(0u), 0x01));

                              ir_variable *const r3798 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3798, neg(r3776), 0x01));

                              ir_variable *const r3799 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3799);
                              ir_variable *const r379A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r379A);
                              ir_variable *const r379B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r379B);
                              ir_variable *const r379C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r379D = neg(r3798);
                              body.emit(assign(r379C, bit_and(r379D, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r379F = equal(r3798, body.constant(int(0)));
                              ir_if *f379E = new(mem_ctx) ir_if(operand(r379F).val);
                              exec_list *const f379E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f379E->then_instructions;

                                 body.emit(assign(r3799, r3797, 0x01));

                                 body.emit(assign(r379A, r3774, 0x01));

                                 body.emit(assign(r379B, r3773, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f379E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r37A1 = less(r3798, body.constant(int(32)));
                                 ir_if *f37A0 = new(mem_ctx) ir_if(operand(r37A1).val);
                                 exec_list *const f37A0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f37A0->then_instructions;

                                    body.emit(assign(r3799, lshift(r3774, r379C), 0x01));

                                    ir_expression *const r37A2 = lshift(r3773, r379C);
                                    ir_expression *const r37A3 = rshift(r3774, r3798);
                                    body.emit(assign(r379A, bit_or(r37A2, r37A3), 0x01));

                                    body.emit(assign(r379B, rshift(r3773, r3798), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f37A0->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r37A5 = equal(r3798, body.constant(int(32)));
                                    ir_if *f37A4 = new(mem_ctx) ir_if(operand(r37A5).val);
                                    exec_list *const f37A4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f37A4->then_instructions;

                                       body.emit(assign(r3799, r3774, 0x01));

                                       body.emit(assign(r379A, r3773, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f37A4->else_instructions;

                                       body.emit(assign(r3797, bit_or(body.constant(0u), r3774), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r37A7 = less(r3798, body.constant(int(64)));
                                       ir_if *f37A6 = new(mem_ctx) ir_if(operand(r37A7).val);
                                       exec_list *const f37A6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f37A6->then_instructions;

                                          body.emit(assign(r3799, lshift(r3773, r379C), 0x01));

                                          ir_expression *const r37A8 = bit_and(r3798, body.constant(int(31)));
                                          body.emit(assign(r379A, rshift(r3773, r37A8), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f37A6->else_instructions;

                                          ir_variable *const r37A9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r37AB = equal(r3798, body.constant(int(64)));
                                          ir_if *f37AA = new(mem_ctx) ir_if(operand(r37AB).val);
                                          exec_list *const f37AA_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f37AA->then_instructions;

                                             body.emit(assign(r37A9, r3773, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f37AA->else_instructions;

                                             ir_expression *const r37AC = nequal(r3773, body.constant(0u));
                                             ir_expression *const r37AD = expr(ir_unop_b2i, r37AC);
                                             body.emit(assign(r37A9, expr(ir_unop_i2u, r37AD), 0x01));


                                          body.instructions = f37AA_parent_instructions;
                                          body.emit(f37AA);

                                          /* END IF */

                                          body.emit(assign(r3799, r37A9, 0x01));

                                          body.emit(assign(r379A, body.constant(0u), 0x01));


                                       body.instructions = f37A6_parent_instructions;
                                       body.emit(f37A6);

                                       /* END IF */


                                    body.instructions = f37A4_parent_instructions;
                                    body.emit(f37A4);

                                    /* END IF */

                                    body.emit(assign(r379B, body.constant(0u), 0x01));


                                 body.instructions = f37A0_parent_instructions;
                                 body.emit(f37A0);

                                 /* END IF */

                                 ir_expression *const r37AE = nequal(r3797, body.constant(0u));
                                 ir_expression *const r37AF = expr(ir_unop_b2i, r37AE);
                                 ir_expression *const r37B0 = expr(ir_unop_i2u, r37AF);
                                 body.emit(assign(r3799, bit_or(r3799, r37B0), 0x01));


                              body.instructions = f379E_parent_instructions;
                              body.emit(f379E);

                              /* END IF */

                              body.emit(assign(r3773, r379B, 0x01));

                              body.emit(assign(r3774, r379A, 0x01));

                              body.emit(assign(r3775, r3799, 0x01));


                           body.instructions = f378D_parent_instructions;
                           body.emit(f378D);

                           /* END IF */

                           body.emit(assign(r3772, sub(r3772, r3776), 0x01));

                           ir_variable *const r37B1 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r37B1, r3772, 0x01));

                           ir_variable *const r37B2 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r37B2, r3773, 0x01));

                           ir_variable *const r37B3 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r37B3, r3774, 0x01));

                           ir_variable *const r37B4 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r37B4, r3775, 0x01));

                           ir_variable *const r37B5 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r37B5, body.constant(true), 0x01));

                           ir_variable *const r37B6 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r37B7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r37B7);
                           ir_expression *const r37B8 = expr(ir_unop_u2i, r3775);
                           body.emit(assign(r37B7, less(r37B8, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r37BA = lequal(body.constant(int(2045)), r3772);
                           ir_if *f37B9 = new(mem_ctx) ir_if(operand(r37BA).val);
                           exec_list *const f37B9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f37B9->then_instructions;

                              ir_variable *const r37BB = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r37BD = less(body.constant(int(2045)), r3772);
                              ir_if *f37BC = new(mem_ctx) ir_if(operand(r37BD).val);
                              exec_list *const f37BC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37BC->then_instructions;

                                 body.emit(assign(r37BB, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f37BC->else_instructions;

                                 ir_variable *const r37BE = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r37C0 = equal(r3772, body.constant(int(2045)));
                                 ir_if *f37BF = new(mem_ctx) ir_if(operand(r37C0).val);
                                 exec_list *const f37BF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f37BF->then_instructions;

                                    ir_expression *const r37C1 = equal(body.constant(2097151u), r3773);
                                    ir_expression *const r37C2 = equal(body.constant(4294967295u), r3774);
                                    body.emit(assign(r37BE, logic_and(r37C1, r37C2), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f37BF->else_instructions;

                                    body.emit(assign(r37BE, body.constant(false), 0x01));


                                 body.instructions = f37BF_parent_instructions;
                                 body.emit(f37BF);

                                 /* END IF */

                                 body.emit(assign(r37BB, logic_and(r37BE, r37B7), 0x01));


                              body.instructions = f37BC_parent_instructions;
                              body.emit(f37BC);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f37C3 = new(mem_ctx) ir_if(operand(r37BB).val);
                              exec_list *const f37C3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37C3->then_instructions;

                                 ir_variable *const r37C4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r37C4);
                                 ir_expression *const r37C5 = lshift(r34C8, body.constant(int(31)));
                                 body.emit(assign(r37C4, add(r37C5, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r37C4, body.constant(0u), 0x01));

                                 body.emit(assign(r37B6, r37C4, 0x03));

                                 body.emit(assign(r37B5, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f37C3->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r37C7 = less(r3772, body.constant(int(0)));
                                 ir_if *f37C6 = new(mem_ctx) ir_if(operand(r37C7).val);
                                 exec_list *const f37C6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f37C6->then_instructions;

                                    ir_variable *const r37C8 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r37C8, r3775, 0x01));

                                    ir_variable *const r37C9 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r37C9, neg(r3772), 0x01));

                                    ir_variable *const r37CA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r37CA);
                                    ir_variable *const r37CB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r37CB);
                                    ir_variable *const r37CC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r37CC);
                                    ir_variable *const r37CD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r37CE = neg(r37C9);
                                    body.emit(assign(r37CD, bit_and(r37CE, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r37D0 = equal(r37C9, body.constant(int(0)));
                                    ir_if *f37CF = new(mem_ctx) ir_if(operand(r37D0).val);
                                    exec_list *const f37CF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f37CF->then_instructions;

                                       body.emit(assign(r37CA, r3775, 0x01));

                                       body.emit(assign(r37CB, r3774, 0x01));

                                       body.emit(assign(r37CC, r3773, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f37CF->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r37D2 = less(r37C9, body.constant(int(32)));
                                       ir_if *f37D1 = new(mem_ctx) ir_if(operand(r37D2).val);
                                       exec_list *const f37D1_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f37D1->then_instructions;

                                          body.emit(assign(r37CA, lshift(r3774, r37CD), 0x01));

                                          ir_expression *const r37D3 = lshift(r3773, r37CD);
                                          ir_expression *const r37D4 = rshift(r3774, r37C9);
                                          body.emit(assign(r37CB, bit_or(r37D3, r37D4), 0x01));

                                          body.emit(assign(r37CC, rshift(r3773, r37C9), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f37D1->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r37D6 = equal(r37C9, body.constant(int(32)));
                                          ir_if *f37D5 = new(mem_ctx) ir_if(operand(r37D6).val);
                                          exec_list *const f37D5_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f37D5->then_instructions;

                                             body.emit(assign(r37CA, r3774, 0x01));

                                             body.emit(assign(r37CB, r3773, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f37D5->else_instructions;

                                             body.emit(assign(r37C8, bit_or(r3775, r3774), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r37D8 = less(r37C9, body.constant(int(64)));
                                             ir_if *f37D7 = new(mem_ctx) ir_if(operand(r37D8).val);
                                             exec_list *const f37D7_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f37D7->then_instructions;

                                                body.emit(assign(r37CA, lshift(r3773, r37CD), 0x01));

                                                ir_expression *const r37D9 = bit_and(r37C9, body.constant(int(31)));
                                                body.emit(assign(r37CB, rshift(r3773, r37D9), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f37D7->else_instructions;

                                                ir_variable *const r37DA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r37DC = equal(r37C9, body.constant(int(64)));
                                                ir_if *f37DB = new(mem_ctx) ir_if(operand(r37DC).val);
                                                exec_list *const f37DB_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f37DB->then_instructions;

                                                   body.emit(assign(r37DA, r3773, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f37DB->else_instructions;

                                                   ir_expression *const r37DD = nequal(r3773, body.constant(0u));
                                                   ir_expression *const r37DE = expr(ir_unop_b2i, r37DD);
                                                   body.emit(assign(r37DA, expr(ir_unop_i2u, r37DE), 0x01));


                                                body.instructions = f37DB_parent_instructions;
                                                body.emit(f37DB);

                                                /* END IF */

                                                body.emit(assign(r37CA, r37DA, 0x01));

                                                body.emit(assign(r37CB, body.constant(0u), 0x01));


                                             body.instructions = f37D7_parent_instructions;
                                             body.emit(f37D7);

                                             /* END IF */


                                          body.instructions = f37D5_parent_instructions;
                                          body.emit(f37D5);

                                          /* END IF */

                                          body.emit(assign(r37CC, body.constant(0u), 0x01));


                                       body.instructions = f37D1_parent_instructions;
                                       body.emit(f37D1);

                                       /* END IF */

                                       ir_expression *const r37DF = nequal(r37C8, body.constant(0u));
                                       ir_expression *const r37E0 = expr(ir_unop_b2i, r37DF);
                                       ir_expression *const r37E1 = expr(ir_unop_i2u, r37E0);
                                       body.emit(assign(r37CA, bit_or(r37CA, r37E1), 0x01));


                                    body.instructions = f37CF_parent_instructions;
                                    body.emit(f37CF);

                                    /* END IF */

                                    body.emit(assign(r37B2, r37CC, 0x01));

                                    body.emit(assign(r37B3, r37CB, 0x01));

                                    body.emit(assign(r37B4, r37CA, 0x01));

                                    body.emit(assign(r37B1, body.constant(int(0)), 0x01));

                                    body.emit(assign(r37B7, less(r37CA, body.constant(0u)), 0x01));


                                 body.instructions = f37C6_parent_instructions;
                                 body.emit(f37C6);

                                 /* END IF */


                              body.instructions = f37C3_parent_instructions;
                              body.emit(f37C3);

                              /* END IF */


                           body.instructions = f37B9_parent_instructions;
                           body.emit(f37B9);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f37E2 = new(mem_ctx) ir_if(operand(r37B5).val);
                           exec_list *const f37E2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f37E2->then_instructions;

                              /* IF CONDITION */
                              ir_if *f37E3 = new(mem_ctx) ir_if(operand(r37B7).val);
                              exec_list *const f37E3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37E3->then_instructions;

                                 ir_variable *const r37E4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r37E4, add(r37B3, body.constant(1u)), 0x01));

                                 ir_expression *const r37E5 = less(r37E4, r37B3);
                                 ir_expression *const r37E6 = expr(ir_unop_b2i, r37E5);
                                 ir_expression *const r37E7 = expr(ir_unop_i2u, r37E6);
                                 body.emit(assign(r37B2, add(r37B2, r37E7), 0x01));

                                 ir_expression *const r37E8 = equal(r37B4, body.constant(0u));
                                 ir_expression *const r37E9 = expr(ir_unop_b2i, r37E8);
                                 ir_expression *const r37EA = expr(ir_unop_i2u, r37E9);
                                 ir_expression *const r37EB = add(r37B4, r37EA);
                                 ir_expression *const r37EC = bit_and(r37EB, body.constant(1u));
                                 ir_expression *const r37ED = expr(ir_unop_bit_not, r37EC);
                                 body.emit(assign(r37B3, bit_and(r37E4, r37ED), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f37E3->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r37EF = bit_or(r37B2, r37B3);
                                 ir_expression *const r37F0 = equal(r37EF, body.constant(0u));
                                 ir_if *f37EE = new(mem_ctx) ir_if(operand(r37F0).val);
                                 exec_list *const f37EE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f37EE->then_instructions;

                                    body.emit(assign(r37B1, body.constant(int(0)), 0x01));


                                 body.instructions = f37EE_parent_instructions;
                                 body.emit(f37EE);

                                 /* END IF */


                              body.instructions = f37E3_parent_instructions;
                              body.emit(f37E3);

                              /* END IF */

                              ir_variable *const r37F1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r37F1);
                              ir_expression *const r37F2 = lshift(r34C8, body.constant(int(31)));
                              ir_expression *const r37F3 = expr(ir_unop_i2u, r37B1);
                              ir_expression *const r37F4 = lshift(r37F3, body.constant(int(20)));
                              ir_expression *const r37F5 = add(r37F2, r37F4);
                              body.emit(assign(r37F1, add(r37F5, r37B2), 0x02));

                              body.emit(assign(r37F1, r37B3, 0x01));

                              body.emit(assign(r37B6, r37F1, 0x03));

                              body.emit(assign(r37B5, body.constant(false), 0x01));


                           body.instructions = f37E2_parent_instructions;
                           body.emit(f37E2);

                           /* END IF */

                           body.emit(assign(r34C9, r37B6, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f376A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r37F7 = less(r34D0, r34CE);
                           ir_if *f37F6 = new(mem_ctx) ir_if(operand(r37F7).val);
                           exec_list *const f37F6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f37F6->then_instructions;

                              ir_variable *const r37F8 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r37F9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r37F9, sub(r34CE, r34D0), 0x01));

                              ir_expression *const r37FA = sub(r34CD, r34CF);
                              ir_expression *const r37FB = less(r34CE, r34D0);
                              ir_expression *const r37FC = expr(ir_unop_b2i, r37FB);
                              ir_expression *const r37FD = expr(ir_unop_i2u, r37FC);
                              body.emit(assign(r37F8, sub(r37FA, r37FD), 0x01));

                              body.emit(assign(r34C8, bit_xor(r34C8, body.constant(1u)), 0x01));

                              body.emit(assign(r34D1, add(r34CB, body.constant(int(-1))), 0x01));

                              ir_variable *const r37FE = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r37FE, add(r34D1, body.constant(int(-10))), 0x01));

                              ir_variable *const r37FF = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r37FF, r37F8, 0x01));

                              ir_variable *const r3800 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r3800, r37F9, 0x01));

                              ir_variable *const r3801 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r3801);
                              ir_variable *const r3802 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r3802);
                              /* IF CONDITION */
                              ir_expression *const r3804 = equal(r37F8, body.constant(0u));
                              ir_if *f3803 = new(mem_ctx) ir_if(operand(r3804).val);
                              exec_list *const f3803_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3803->then_instructions;

                                 body.emit(assign(r37FF, r37F9, 0x01));

                                 body.emit(assign(r3800, body.constant(0u), 0x01));

                                 body.emit(assign(r37FE, add(r37FE, body.constant(int(-32))), 0x01));


                              body.instructions = f3803_parent_instructions;
                              body.emit(f3803);

                              /* END IF */

                              ir_variable *const r3805 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r3805, r37FF, 0x01));

                              ir_variable *const r3806 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r3807 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r3807);
                              /* IF CONDITION */
                              ir_expression *const r3809 = equal(r37FF, body.constant(0u));
                              ir_if *f3808 = new(mem_ctx) ir_if(operand(r3809).val);
                              exec_list *const f3808_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3808->then_instructions;

                                 body.emit(assign(r3806, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3808->else_instructions;

                                 body.emit(assign(r3807, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r380B = bit_and(r37FF, body.constant(4294901760u));
                                 ir_expression *const r380C = equal(r380B, body.constant(0u));
                                 ir_if *f380A = new(mem_ctx) ir_if(operand(r380C).val);
                                 exec_list *const f380A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f380A->then_instructions;

                                    body.emit(assign(r3807, body.constant(int(16)), 0x01));

                                    body.emit(assign(r3805, lshift(r37FF, body.constant(int(16))), 0x01));


                                 body.instructions = f380A_parent_instructions;
                                 body.emit(f380A);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r380E = bit_and(r3805, body.constant(4278190080u));
                                 ir_expression *const r380F = equal(r380E, body.constant(0u));
                                 ir_if *f380D = new(mem_ctx) ir_if(operand(r380F).val);
                                 exec_list *const f380D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f380D->then_instructions;

                                    body.emit(assign(r3807, add(r3807, body.constant(int(8))), 0x01));

                                    body.emit(assign(r3805, lshift(r3805, body.constant(int(8))), 0x01));


                                 body.instructions = f380D_parent_instructions;
                                 body.emit(f380D);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r3811 = bit_and(r3805, body.constant(4026531840u));
                                 ir_expression *const r3812 = equal(r3811, body.constant(0u));
                                 ir_if *f3810 = new(mem_ctx) ir_if(operand(r3812).val);
                                 exec_list *const f3810_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3810->then_instructions;

                                    body.emit(assign(r3807, add(r3807, body.constant(int(4))), 0x01));

                                    body.emit(assign(r3805, lshift(r3805, body.constant(int(4))), 0x01));


                                 body.instructions = f3810_parent_instructions;
                                 body.emit(f3810);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r3814 = bit_and(r3805, body.constant(3221225472u));
                                 ir_expression *const r3815 = equal(r3814, body.constant(0u));
                                 ir_if *f3813 = new(mem_ctx) ir_if(operand(r3815).val);
                                 exec_list *const f3813_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3813->then_instructions;

                                    body.emit(assign(r3807, add(r3807, body.constant(int(2))), 0x01));

                                    body.emit(assign(r3805, lshift(r3805, body.constant(int(2))), 0x01));


                                 body.instructions = f3813_parent_instructions;
                                 body.emit(f3813);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r3817 = bit_and(r3805, body.constant(2147483648u));
                                 ir_expression *const r3818 = equal(r3817, body.constant(0u));
                                 ir_if *f3816 = new(mem_ctx) ir_if(operand(r3818).val);
                                 exec_list *const f3816_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3816->then_instructions;

                                    body.emit(assign(r3807, add(r3807, body.constant(int(1))), 0x01));


                                 body.instructions = f3816_parent_instructions;
                                 body.emit(f3816);

                                 /* END IF */

                                 body.emit(assign(r3806, r3807, 0x01));


                              body.instructions = f3808_parent_instructions;
                              body.emit(f3808);

                              /* END IF */

                              body.emit(assign(r3802, add(r3806, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r381A = lequal(body.constant(int(0)), r3802);
                              ir_if *f3819 = new(mem_ctx) ir_if(operand(r381A).val);
                              exec_list *const f3819_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3819->then_instructions;

                                 body.emit(assign(r3801, body.constant(0u), 0x01));

                                 ir_variable *const r381B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r381B, lshift(r3800, r3802), 0x01));

                                 ir_variable *const r381C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r381E = equal(r3802, body.constant(int(0)));
                                 ir_if *f381D = new(mem_ctx) ir_if(operand(r381E).val);
                                 exec_list *const f381D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f381D->then_instructions;

                                    body.emit(assign(r381C, r37FF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f381D->else_instructions;

                                    ir_expression *const r381F = lshift(r37FF, r3802);
                                    ir_expression *const r3820 = neg(r3802);
                                    ir_expression *const r3821 = bit_and(r3820, body.constant(int(31)));
                                    ir_expression *const r3822 = rshift(r3800, r3821);
                                    body.emit(assign(r381C, bit_or(r381F, r3822), 0x01));


                                 body.instructions = f381D_parent_instructions;
                                 body.emit(f381D);

                                 /* END IF */

                                 body.emit(assign(r37FF, r381C, 0x01));

                                 body.emit(assign(r3800, r381B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3819->else_instructions;

                                 ir_variable *const r3823 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r3823, body.constant(0u), 0x01));

                                 ir_variable *const r3824 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r3824, neg(r3802), 0x01));

                                 ir_variable *const r3825 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r3825);
                                 ir_variable *const r3826 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r3826);
                                 ir_variable *const r3827 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r3827);
                                 ir_variable *const r3828 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r3829 = neg(r3824);
                                 body.emit(assign(r3828, bit_and(r3829, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r382B = equal(r3824, body.constant(int(0)));
                                 ir_if *f382A = new(mem_ctx) ir_if(operand(r382B).val);
                                 exec_list *const f382A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f382A->then_instructions;

                                    body.emit(assign(r3825, r3823, 0x01));

                                    body.emit(assign(r3826, r3800, 0x01));

                                    body.emit(assign(r3827, r37FF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f382A->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r382D = less(r3824, body.constant(int(32)));
                                    ir_if *f382C = new(mem_ctx) ir_if(operand(r382D).val);
                                    exec_list *const f382C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f382C->then_instructions;

                                       body.emit(assign(r3825, lshift(r3800, r3828), 0x01));

                                       ir_expression *const r382E = lshift(r37FF, r3828);
                                       ir_expression *const r382F = rshift(r3800, r3824);
                                       body.emit(assign(r3826, bit_or(r382E, r382F), 0x01));

                                       body.emit(assign(r3827, rshift(r37FF, r3824), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f382C->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3831 = equal(r3824, body.constant(int(32)));
                                       ir_if *f3830 = new(mem_ctx) ir_if(operand(r3831).val);
                                       exec_list *const f3830_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3830->then_instructions;

                                          body.emit(assign(r3825, r3800, 0x01));

                                          body.emit(assign(r3826, r37FF, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3830->else_instructions;

                                          body.emit(assign(r3823, bit_or(body.constant(0u), r3800), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r3833 = less(r3824, body.constant(int(64)));
                                          ir_if *f3832 = new(mem_ctx) ir_if(operand(r3833).val);
                                          exec_list *const f3832_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3832->then_instructions;

                                             body.emit(assign(r3825, lshift(r37FF, r3828), 0x01));

                                             ir_expression *const r3834 = bit_and(r3824, body.constant(int(31)));
                                             body.emit(assign(r3826, rshift(r37FF, r3834), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3832->else_instructions;

                                             ir_variable *const r3835 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r3837 = equal(r3824, body.constant(int(64)));
                                             ir_if *f3836 = new(mem_ctx) ir_if(operand(r3837).val);
                                             exec_list *const f3836_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3836->then_instructions;

                                                body.emit(assign(r3835, r37FF, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3836->else_instructions;

                                                ir_expression *const r3838 = nequal(r37FF, body.constant(0u));
                                                ir_expression *const r3839 = expr(ir_unop_b2i, r3838);
                                                body.emit(assign(r3835, expr(ir_unop_i2u, r3839), 0x01));


                                             body.instructions = f3836_parent_instructions;
                                             body.emit(f3836);

                                             /* END IF */

                                             body.emit(assign(r3825, r3835, 0x01));

                                             body.emit(assign(r3826, body.constant(0u), 0x01));


                                          body.instructions = f3832_parent_instructions;
                                          body.emit(f3832);

                                          /* END IF */


                                       body.instructions = f3830_parent_instructions;
                                       body.emit(f3830);

                                       /* END IF */

                                       body.emit(assign(r3827, body.constant(0u), 0x01));


                                    body.instructions = f382C_parent_instructions;
                                    body.emit(f382C);

                                    /* END IF */

                                    ir_expression *const r383A = nequal(r3823, body.constant(0u));
                                    ir_expression *const r383B = expr(ir_unop_b2i, r383A);
                                    ir_expression *const r383C = expr(ir_unop_i2u, r383B);
                                    body.emit(assign(r3825, bit_or(r3825, r383C), 0x01));


                                 body.instructions = f382A_parent_instructions;
                                 body.emit(f382A);

                                 /* END IF */

                                 body.emit(assign(r37FF, r3827, 0x01));

                                 body.emit(assign(r3800, r3826, 0x01));

                                 body.emit(assign(r3801, r3825, 0x01));


                              body.instructions = f3819_parent_instructions;
                              body.emit(f3819);

                              /* END IF */

                              body.emit(assign(r37FE, sub(r37FE, r3802), 0x01));

                              ir_variable *const r383D = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r383D, r37FE, 0x01));

                              ir_variable *const r383E = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r383E, r37FF, 0x01));

                              ir_variable *const r383F = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r383F, r3800, 0x01));

                              ir_variable *const r3840 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r3840, r3801, 0x01));

                              ir_variable *const r3841 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r3841, body.constant(true), 0x01));

                              ir_variable *const r3842 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r3843 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r3843);
                              ir_expression *const r3844 = expr(ir_unop_u2i, r3801);
                              body.emit(assign(r3843, less(r3844, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3846 = lequal(body.constant(int(2045)), r37FE);
                              ir_if *f3845 = new(mem_ctx) ir_if(operand(r3846).val);
                              exec_list *const f3845_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3845->then_instructions;

                                 ir_variable *const r3847 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3849 = less(body.constant(int(2045)), r37FE);
                                 ir_if *f3848 = new(mem_ctx) ir_if(operand(r3849).val);
                                 exec_list *const f3848_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3848->then_instructions;

                                    body.emit(assign(r3847, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3848->else_instructions;

                                    ir_variable *const r384A = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r384C = equal(r37FE, body.constant(int(2045)));
                                    ir_if *f384B = new(mem_ctx) ir_if(operand(r384C).val);
                                    exec_list *const f384B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f384B->then_instructions;

                                       ir_expression *const r384D = equal(body.constant(2097151u), r37FF);
                                       ir_expression *const r384E = equal(body.constant(4294967295u), r3800);
                                       body.emit(assign(r384A, logic_and(r384D, r384E), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f384B->else_instructions;

                                       body.emit(assign(r384A, body.constant(false), 0x01));


                                    body.instructions = f384B_parent_instructions;
                                    body.emit(f384B);

                                    /* END IF */

                                    body.emit(assign(r3847, logic_and(r384A, r3843), 0x01));


                                 body.instructions = f3848_parent_instructions;
                                 body.emit(f3848);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f384F = new(mem_ctx) ir_if(operand(r3847).val);
                                 exec_list *const f384F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f384F->then_instructions;

                                    ir_variable *const r3850 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r3850);
                                    ir_expression *const r3851 = lshift(r34C8, body.constant(int(31)));
                                    body.emit(assign(r3850, add(r3851, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r3850, body.constant(0u), 0x01));

                                    body.emit(assign(r3842, r3850, 0x03));

                                    body.emit(assign(r3841, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f384F->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3853 = less(r37FE, body.constant(int(0)));
                                    ir_if *f3852 = new(mem_ctx) ir_if(operand(r3853).val);
                                    exec_list *const f3852_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3852->then_instructions;

                                       ir_variable *const r3854 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r3854, r3801, 0x01));

                                       ir_variable *const r3855 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r3855, neg(r37FE), 0x01));

                                       ir_variable *const r3856 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r3856);
                                       ir_variable *const r3857 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r3857);
                                       ir_variable *const r3858 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r3858);
                                       ir_variable *const r3859 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r385A = neg(r3855);
                                       body.emit(assign(r3859, bit_and(r385A, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r385C = equal(r3855, body.constant(int(0)));
                                       ir_if *f385B = new(mem_ctx) ir_if(operand(r385C).val);
                                       exec_list *const f385B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f385B->then_instructions;

                                          body.emit(assign(r3856, r3801, 0x01));

                                          body.emit(assign(r3857, r3800, 0x01));

                                          body.emit(assign(r3858, r37FF, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f385B->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r385E = less(r3855, body.constant(int(32)));
                                          ir_if *f385D = new(mem_ctx) ir_if(operand(r385E).val);
                                          exec_list *const f385D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f385D->then_instructions;

                                             body.emit(assign(r3856, lshift(r3800, r3859), 0x01));

                                             ir_expression *const r385F = lshift(r37FF, r3859);
                                             ir_expression *const r3860 = rshift(r3800, r3855);
                                             body.emit(assign(r3857, bit_or(r385F, r3860), 0x01));

                                             body.emit(assign(r3858, rshift(r37FF, r3855), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f385D->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r3862 = equal(r3855, body.constant(int(32)));
                                             ir_if *f3861 = new(mem_ctx) ir_if(operand(r3862).val);
                                             exec_list *const f3861_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3861->then_instructions;

                                                body.emit(assign(r3856, r3800, 0x01));

                                                body.emit(assign(r3857, r37FF, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3861->else_instructions;

                                                body.emit(assign(r3854, bit_or(r3801, r3800), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r3864 = less(r3855, body.constant(int(64)));
                                                ir_if *f3863 = new(mem_ctx) ir_if(operand(r3864).val);
                                                exec_list *const f3863_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3863->then_instructions;

                                                   body.emit(assign(r3856, lshift(r37FF, r3859), 0x01));

                                                   ir_expression *const r3865 = bit_and(r3855, body.constant(int(31)));
                                                   body.emit(assign(r3857, rshift(r37FF, r3865), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3863->else_instructions;

                                                   ir_variable *const r3866 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r3868 = equal(r3855, body.constant(int(64)));
                                                   ir_if *f3867 = new(mem_ctx) ir_if(operand(r3868).val);
                                                   exec_list *const f3867_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f3867->then_instructions;

                                                      body.emit(assign(r3866, r37FF, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f3867->else_instructions;

                                                      ir_expression *const r3869 = nequal(r37FF, body.constant(0u));
                                                      ir_expression *const r386A = expr(ir_unop_b2i, r3869);
                                                      body.emit(assign(r3866, expr(ir_unop_i2u, r386A), 0x01));


                                                   body.instructions = f3867_parent_instructions;
                                                   body.emit(f3867);

                                                   /* END IF */

                                                   body.emit(assign(r3856, r3866, 0x01));

                                                   body.emit(assign(r3857, body.constant(0u), 0x01));


                                                body.instructions = f3863_parent_instructions;
                                                body.emit(f3863);

                                                /* END IF */


                                             body.instructions = f3861_parent_instructions;
                                             body.emit(f3861);

                                             /* END IF */

                                             body.emit(assign(r3858, body.constant(0u), 0x01));


                                          body.instructions = f385D_parent_instructions;
                                          body.emit(f385D);

                                          /* END IF */

                                          ir_expression *const r386B = nequal(r3854, body.constant(0u));
                                          ir_expression *const r386C = expr(ir_unop_b2i, r386B);
                                          ir_expression *const r386D = expr(ir_unop_i2u, r386C);
                                          body.emit(assign(r3856, bit_or(r3856, r386D), 0x01));


                                       body.instructions = f385B_parent_instructions;
                                       body.emit(f385B);

                                       /* END IF */

                                       body.emit(assign(r383E, r3858, 0x01));

                                       body.emit(assign(r383F, r3857, 0x01));

                                       body.emit(assign(r3840, r3856, 0x01));

                                       body.emit(assign(r383D, body.constant(int(0)), 0x01));

                                       body.emit(assign(r3843, less(r3856, body.constant(0u)), 0x01));


                                    body.instructions = f3852_parent_instructions;
                                    body.emit(f3852);

                                    /* END IF */


                                 body.instructions = f384F_parent_instructions;
                                 body.emit(f384F);

                                 /* END IF */


                              body.instructions = f3845_parent_instructions;
                              body.emit(f3845);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f386E = new(mem_ctx) ir_if(operand(r3841).val);
                              exec_list *const f386E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f386E->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f386F = new(mem_ctx) ir_if(operand(r3843).val);
                                 exec_list *const f386F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f386F->then_instructions;

                                    ir_variable *const r3870 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r3870, add(r383F, body.constant(1u)), 0x01));

                                    ir_expression *const r3871 = less(r3870, r383F);
                                    ir_expression *const r3872 = expr(ir_unop_b2i, r3871);
                                    ir_expression *const r3873 = expr(ir_unop_i2u, r3872);
                                    body.emit(assign(r383E, add(r383E, r3873), 0x01));

                                    ir_expression *const r3874 = equal(r3840, body.constant(0u));
                                    ir_expression *const r3875 = expr(ir_unop_b2i, r3874);
                                    ir_expression *const r3876 = expr(ir_unop_i2u, r3875);
                                    ir_expression *const r3877 = add(r3840, r3876);
                                    ir_expression *const r3878 = bit_and(r3877, body.constant(1u));
                                    ir_expression *const r3879 = expr(ir_unop_bit_not, r3878);
                                    body.emit(assign(r383F, bit_and(r3870, r3879), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f386F->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r387B = bit_or(r383E, r383F);
                                    ir_expression *const r387C = equal(r387B, body.constant(0u));
                                    ir_if *f387A = new(mem_ctx) ir_if(operand(r387C).val);
                                    exec_list *const f387A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f387A->then_instructions;

                                       body.emit(assign(r383D, body.constant(int(0)), 0x01));


                                    body.instructions = f387A_parent_instructions;
                                    body.emit(f387A);

                                    /* END IF */


                                 body.instructions = f386F_parent_instructions;
                                 body.emit(f386F);

                                 /* END IF */

                                 ir_variable *const r387D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r387D);
                                 ir_expression *const r387E = lshift(r34C8, body.constant(int(31)));
                                 ir_expression *const r387F = expr(ir_unop_i2u, r383D);
                                 ir_expression *const r3880 = lshift(r387F, body.constant(int(20)));
                                 ir_expression *const r3881 = add(r387E, r3880);
                                 body.emit(assign(r387D, add(r3881, r383E), 0x02));

                                 body.emit(assign(r387D, r383F, 0x01));

                                 body.emit(assign(r3842, r387D, 0x03));

                                 body.emit(assign(r3841, body.constant(false), 0x01));


                              body.instructions = f386E_parent_instructions;
                              body.emit(f386E);

                              /* END IF */

                              body.emit(assign(r34C9, r3842, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f37F6->else_instructions;

                              ir_variable *const r3882 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3882);
                              body.emit(assign(r3882, body.constant(0u), 0x02));

                              body.emit(assign(r3882, body.constant(0u), 0x01));

                              body.emit(assign(r34C9, r3882, 0x03));


                           body.instructions = f37F6_parent_instructions;
                           body.emit(f37F6);

                           /* END IF */


                        body.instructions = f376A_parent_instructions;
                        body.emit(f376A);

                        /* END IF */


                     body.instructions = f36DE_parent_instructions;
                     body.emit(f36DE);

                     /* END IF */


                  body.instructions = f3652_parent_instructions;
                  body.emit(f3652);

                  /* END IF */


               body.instructions = f363D_parent_instructions;
               body.emit(f363D);

               /* END IF */


            body.instructions = f358E_parent_instructions;
            body.emit(f358E);

            /* END IF */


         body.instructions = f34DD_parent_instructions;
         body.emit(f34DD);

         /* END IF */

         body.emit(assign(r34C4, r34C9, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f34C6->else_instructions;

         ir_variable *const r3883 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r3883, body.constant(true), 0x01));

         ir_variable *const r3884 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r3885 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r3885);
         ir_variable *const r3886 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r3886);
         ir_variable *const r3887 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r3887);
         ir_variable *const r3888 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r3888);
         ir_variable *const r3889 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r3889);
         ir_variable *const r388A = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r388A);
         ir_variable *const r388B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r388B);
         ir_variable *const r388C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r388C);
         body.emit(assign(r388C, body.constant(0u), 0x01));

         body.emit(assign(r388B, body.constant(0u), 0x01));

         ir_variable *const r388D = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r388D, swizzle_x(r348F), 0x01));

         body.emit(assign(r3889, r388D, 0x01));

         ir_variable *const r388E = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r388E, bit_and(swizzle_y(r348F), body.constant(1048575u)), 0x01));

         body.emit(assign(r3888, r388E, 0x01));

         ir_variable *const r388F = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r388F, body.constant(0u), 0x01));

         body.emit(assign(r3887, body.constant(0u), 0x01));

         body.emit(assign(r3886, body.constant(0u), 0x01));

         ir_variable *const r3890 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r3891 = rshift(swizzle_y(r348F), body.constant(int(20)));
         ir_expression *const r3892 = bit_and(r3891, body.constant(2047u));
         body.emit(assign(r3890, expr(ir_unop_u2i, r3892), 0x01));

         ir_variable *const r3893 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r3893, body.constant(int(1023)), 0x01));

         ir_variable *const r3894 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r3894, add(r3890, body.constant(int(-1023))), 0x01));

         body.emit(assign(r3885, r3894, 0x01));

         /* IF CONDITION */
         ir_expression *const r3896 = less(body.constant(int(0)), r3894);
         ir_if *f3895 = new(mem_ctx) ir_if(operand(r3896).val);
         exec_list *const f3895_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3895->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3898 = equal(r3890, body.constant(int(2047)));
            ir_if *f3897 = new(mem_ctx) ir_if(operand(r3898).val);
            exec_list *const f3897_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3897->then_instructions;

               /* IF CONDITION */
               ir_expression *const r389A = bit_or(r388E, swizzle_x(r348F));
               ir_expression *const r389B = nequal(r389A, body.constant(0u));
               ir_if *f3899 = new(mem_ctx) ir_if(operand(r389B).val);
               exec_list *const f3899_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3899->then_instructions;

                  ir_variable *const r389C = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r389C, swizzle_x(r348F), 0x01));

                  ir_variable *const r389D = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r389D, body.constant(0u), 0x01));

                  ir_variable *const r389E = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r389C, bit_or(swizzle_y(r348F), body.constant(524288u)), 0x02));

                  body.emit(assign(r389D, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r38A0 = lshift(swizzle_y(r348F), body.constant(int(1)));
                  ir_expression *const r38A1 = lequal(body.constant(4292870144u), r38A0);
                  ir_expression *const r38A2 = nequal(swizzle_x(r348F), body.constant(0u));
                  ir_expression *const r38A3 = bit_and(swizzle_y(r348F), body.constant(1048575u));
                  ir_expression *const r38A4 = nequal(r38A3, body.constant(0u));
                  ir_expression *const r38A5 = logic_or(r38A2, r38A4);
                  ir_expression *const r38A6 = logic_and(r38A1, r38A5);
                  ir_if *f389F = new(mem_ctx) ir_if(operand(r38A6).val);
                  exec_list *const f389F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f389F->then_instructions;

                     body.emit(assign(r389E, r389C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f389F->else_instructions;

                     body.emit(assign(r389E, r389D, 0x03));


                  body.instructions = f389F_parent_instructions;
                  body.emit(f389F);

                  /* END IF */

                  body.emit(assign(r3884, r389E, 0x03));

                  body.emit(assign(r3883, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3899->else_instructions;

                  body.emit(assign(r3884, r348F, 0x03));

                  body.emit(assign(r3883, body.constant(false), 0x01));


               body.instructions = f3899_parent_instructions;
               body.emit(f3899);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3897->else_instructions;

               body.emit(assign(r3886, body.constant(1048576u), 0x01));

               ir_variable *const r38A7 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r38A7, body.constant(0u), 0x01));

               ir_variable *const r38A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r38A8);
               ir_variable *const r38A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r38A9);
               ir_variable *const r38AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r38AA);
               ir_variable *const r38AB = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r38AC = neg(r3894);
               body.emit(assign(r38AB, bit_and(r38AC, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r38AE = equal(r3894, body.constant(int(0)));
               ir_if *f38AD = new(mem_ctx) ir_if(operand(r38AE).val);
               exec_list *const f38AD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38AD->then_instructions;

                  body.emit(assign(r38A8, r38A7, 0x01));

                  body.emit(assign(r38A9, body.constant(0u), 0x01));

                  body.emit(assign(r38AA, r3886, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38AD->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r38B0 = less(r3894, body.constant(int(32)));
                  ir_if *f38AF = new(mem_ctx) ir_if(operand(r38B0).val);
                  exec_list *const f38AF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38AF->then_instructions;

                     body.emit(assign(r38A8, body.constant(0u), 0x01));

                     ir_expression *const r38B1 = lshift(body.constant(1048576u), r38AB);
                     body.emit(assign(r38A9, bit_or(r38B1, body.constant(0u)), 0x01));

                     body.emit(assign(r38AA, rshift(body.constant(1048576u), r3894), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f38AF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r38B3 = equal(r3894, body.constant(int(32)));
                     ir_if *f38B2 = new(mem_ctx) ir_if(operand(r38B3).val);
                     exec_list *const f38B2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f38B2->then_instructions;

                        body.emit(assign(r38A8, body.constant(0u), 0x01));

                        body.emit(assign(r38A9, r3886, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f38B2->else_instructions;

                        body.emit(assign(r38A7, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r38B5 = less(r3894, body.constant(int(64)));
                        ir_if *f38B4 = new(mem_ctx) ir_if(operand(r38B5).val);
                        exec_list *const f38B4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f38B4->then_instructions;

                           body.emit(assign(r38A8, lshift(body.constant(1048576u), r38AB), 0x01));

                           ir_expression *const r38B6 = bit_and(r3894, body.constant(int(31)));
                           body.emit(assign(r38A9, rshift(body.constant(1048576u), r38B6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f38B4->else_instructions;

                           ir_variable *const r38B7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r38B9 = equal(r3894, body.constant(int(64)));
                           ir_if *f38B8 = new(mem_ctx) ir_if(operand(r38B9).val);
                           exec_list *const f38B8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38B8->then_instructions;

                              body.emit(assign(r38B7, r3886, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f38B8->else_instructions;

                              body.emit(assign(r38B7, body.constant(1u), 0x01));


                           body.instructions = f38B8_parent_instructions;
                           body.emit(f38B8);

                           /* END IF */

                           body.emit(assign(r38A8, r38B7, 0x01));

                           body.emit(assign(r38A9, body.constant(0u), 0x01));


                        body.instructions = f38B4_parent_instructions;
                        body.emit(f38B4);

                        /* END IF */


                     body.instructions = f38B2_parent_instructions;
                     body.emit(f38B2);

                     /* END IF */

                     body.emit(assign(r38AA, body.constant(0u), 0x01));


                  body.instructions = f38AF_parent_instructions;
                  body.emit(f38AF);

                  /* END IF */

                  ir_expression *const r38BA = nequal(r38A7, body.constant(0u));
                  ir_expression *const r38BB = expr(ir_unop_b2i, r38BA);
                  ir_expression *const r38BC = expr(ir_unop_i2u, r38BB);
                  body.emit(assign(r38A8, bit_or(r38A8, r38BC), 0x01));


               body.instructions = f38AD_parent_instructions;
               body.emit(f38AD);

               /* END IF */

               body.emit(assign(r3886, r38AA, 0x01));

               body.emit(assign(r3887, r38A9, 0x01));

               body.emit(assign(r388B, r38A8, 0x01));

               body.emit(assign(r388A, r3890, 0x01));


            body.instructions = f3897_parent_instructions;
            body.emit(f3897);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3895->else_instructions;

            /* IF CONDITION */
            ir_expression *const r38BE = less(r3894, body.constant(int(0)));
            ir_if *f38BD = new(mem_ctx) ir_if(operand(r38BE).val);
            exec_list *const f38BD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f38BD->then_instructions;

               /* IF CONDITION */
               ir_expression *const r38C0 = equal(r3890, body.constant(int(0)));
               ir_if *f38BF = new(mem_ctx) ir_if(operand(r38C0).val);
               exec_list *const f38BF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38BF->then_instructions;

                  body.emit(assign(r3885, add(r3894, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38BF->else_instructions;

                  body.emit(assign(r3888, bit_or(r388E, body.constant(1048576u)), 0x01));


               body.instructions = f38BF_parent_instructions;
               body.emit(f38BF);

               /* END IF */

               ir_variable *const r38C1 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r38C1, body.constant(0u), 0x01));

               ir_variable *const r38C2 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r38C2, neg(r3885), 0x01));

               ir_variable *const r38C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r38C3);
               ir_variable *const r38C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r38C4);
               ir_variable *const r38C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r38C5);
               ir_variable *const r38C6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r38C7 = neg(r38C2);
               body.emit(assign(r38C6, bit_and(r38C7, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r38C9 = equal(r38C2, body.constant(int(0)));
               ir_if *f38C8 = new(mem_ctx) ir_if(operand(r38C9).val);
               exec_list *const f38C8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38C8->then_instructions;

                  body.emit(assign(r38C3, r38C1, 0x01));

                  body.emit(assign(r38C4, r388D, 0x01));

                  body.emit(assign(r38C5, r3888, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38C8->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r38CB = less(r38C2, body.constant(int(32)));
                  ir_if *f38CA = new(mem_ctx) ir_if(operand(r38CB).val);
                  exec_list *const f38CA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38CA->then_instructions;

                     body.emit(assign(r38C3, lshift(swizzle_x(r348F), r38C6), 0x01));

                     ir_expression *const r38CC = lshift(r3888, r38C6);
                     ir_expression *const r38CD = rshift(swizzle_x(r348F), r38C2);
                     body.emit(assign(r38C4, bit_or(r38CC, r38CD), 0x01));

                     body.emit(assign(r38C5, rshift(r3888, r38C2), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f38CA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r38CF = equal(r38C2, body.constant(int(32)));
                     ir_if *f38CE = new(mem_ctx) ir_if(operand(r38CF).val);
                     exec_list *const f38CE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f38CE->then_instructions;

                        body.emit(assign(r38C3, r388D, 0x01));

                        body.emit(assign(r38C4, r3888, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f38CE->else_instructions;

                        body.emit(assign(r38C1, bit_or(body.constant(0u), swizzle_x(r348F)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r38D1 = less(r38C2, body.constant(int(64)));
                        ir_if *f38D0 = new(mem_ctx) ir_if(operand(r38D1).val);
                        exec_list *const f38D0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f38D0->then_instructions;

                           body.emit(assign(r38C3, lshift(r3888, r38C6), 0x01));

                           ir_expression *const r38D2 = bit_and(r38C2, body.constant(int(31)));
                           body.emit(assign(r38C4, rshift(r3888, r38D2), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f38D0->else_instructions;

                           ir_variable *const r38D3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r38D5 = equal(r38C2, body.constant(int(64)));
                           ir_if *f38D4 = new(mem_ctx) ir_if(operand(r38D5).val);
                           exec_list *const f38D4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38D4->then_instructions;

                              body.emit(assign(r38D3, r3888, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f38D4->else_instructions;

                              ir_expression *const r38D6 = nequal(r3888, body.constant(0u));
                              ir_expression *const r38D7 = expr(ir_unop_b2i, r38D6);
                              body.emit(assign(r38D3, expr(ir_unop_i2u, r38D7), 0x01));


                           body.instructions = f38D4_parent_instructions;
                           body.emit(f38D4);

                           /* END IF */

                           body.emit(assign(r38C3, r38D3, 0x01));

                           body.emit(assign(r38C4, body.constant(0u), 0x01));


                        body.instructions = f38D0_parent_instructions;
                        body.emit(f38D0);

                        /* END IF */


                     body.instructions = f38CE_parent_instructions;
                     body.emit(f38CE);

                     /* END IF */

                     body.emit(assign(r38C5, body.constant(0u), 0x01));


                  body.instructions = f38CA_parent_instructions;
                  body.emit(f38CA);

                  /* END IF */

                  ir_expression *const r38D8 = nequal(r38C1, body.constant(0u));
                  ir_expression *const r38D9 = expr(ir_unop_b2i, r38D8);
                  ir_expression *const r38DA = expr(ir_unop_i2u, r38D9);
                  body.emit(assign(r38C3, bit_or(r38C3, r38DA), 0x01));


               body.instructions = f38C8_parent_instructions;
               body.emit(f38C8);

               /* END IF */

               body.emit(assign(r3888, r38C5, 0x01));

               body.emit(assign(r3889, r38C4, 0x01));

               body.emit(assign(r388B, r38C3, 0x01));

               body.emit(assign(r388A, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f38BD->else_instructions;

               /* IF CONDITION */
               ir_expression *const r38DC = equal(r3890, body.constant(int(2047)));
               ir_if *f38DB = new(mem_ctx) ir_if(operand(r38DC).val);
               exec_list *const f38DB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38DB->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r38DE = bit_or(r3888, r3889);
                  ir_expression *const r38DF = bit_or(r3886, r3887);
                  ir_expression *const r38E0 = bit_or(r38DE, r38DF);
                  ir_expression *const r38E1 = nequal(r38E0, body.constant(0u));
                  ir_if *f38DD = new(mem_ctx) ir_if(operand(r38E1).val);
                  exec_list *const f38DD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38DD->then_instructions;

                     ir_variable *const r38E2 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r38E2, swizzle_x(r348F), 0x01));

                     ir_variable *const r38E3 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r38E3, body.constant(0u), 0x01));

                     ir_variable *const r38E4 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r38E2, bit_or(swizzle_y(r348F), body.constant(524288u)), 0x02));

                     body.emit(assign(r38E3, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r38E6 = lshift(swizzle_y(r348F), body.constant(int(1)));
                     ir_expression *const r38E7 = lequal(body.constant(4292870144u), r38E6);
                     ir_expression *const r38E8 = nequal(swizzle_x(r348F), body.constant(0u));
                     ir_expression *const r38E9 = bit_and(swizzle_y(r348F), body.constant(1048575u));
                     ir_expression *const r38EA = nequal(r38E9, body.constant(0u));
                     ir_expression *const r38EB = logic_or(r38E8, r38EA);
                     ir_expression *const r38EC = logic_and(r38E7, r38EB);
                     ir_if *f38E5 = new(mem_ctx) ir_if(operand(r38EC).val);
                     exec_list *const f38E5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f38E5->then_instructions;

                        body.emit(assign(r38E4, r38E2, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f38E5->else_instructions;

                        body.emit(assign(r38E4, r38E3, 0x03));


                     body.instructions = f38E5_parent_instructions;
                     body.emit(f38E5);

                     /* END IF */

                     body.emit(assign(r3884, r38E4, 0x03));

                     body.emit(assign(r3883, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f38DD->else_instructions;

                     body.emit(assign(r3884, r348F, 0x03));

                     body.emit(assign(r3883, body.constant(false), 0x01));


                  body.instructions = f38DD_parent_instructions;
                  body.emit(f38DD);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38DB->else_instructions;

                  ir_variable *const r38ED = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r38EE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r38EE, add(r3889, r3887), 0x01));

                  ir_expression *const r38EF = add(r3888, r3886);
                  ir_expression *const r38F0 = less(r38EE, r3889);
                  ir_expression *const r38F1 = expr(ir_unop_b2i, r38F0);
                  ir_expression *const r38F2 = expr(ir_unop_i2u, r38F1);
                  body.emit(assign(r38ED, add(r38EF, r38F2), 0x01));

                  body.emit(assign(r388C, r38ED, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r38F4 = equal(r3890, body.constant(int(0)));
                  ir_if *f38F3 = new(mem_ctx) ir_if(operand(r38F4).val);
                  exec_list *const f38F3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38F3->then_instructions;

                     ir_variable *const r38F5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r38F5);
                     ir_expression *const r38F6 = lshift(r34C5, body.constant(int(31)));
                     body.emit(assign(r38F5, add(r38F6, r38ED), 0x02));

                     body.emit(assign(r38F5, r38EE, 0x01));

                     body.emit(assign(r3884, r38F5, 0x03));

                     body.emit(assign(r3883, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f38F3->else_instructions;

                     body.emit(assign(r388C, bit_or(r38ED, body.constant(2097152u)), 0x01));

                     body.emit(assign(r388A, r3890, 0x01));

                     ir_variable *const r38F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r38F7);
                     ir_variable *const r38F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r38F8);
                     ir_variable *const r38F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r38F9);
                     body.emit(assign(r38F7, lshift(r38EE, body.constant(int(31))), 0x01));

                     ir_expression *const r38FA = lshift(r388C, body.constant(int(31)));
                     ir_expression *const r38FB = rshift(r38EE, body.constant(int(1)));
                     body.emit(assign(r38F8, bit_or(r38FA, r38FB), 0x01));

                     body.emit(assign(r38F9, rshift(r388C, body.constant(int(1))), 0x01));

                     body.emit(assign(r38F7, bit_or(r38F7, body.constant(0u)), 0x01));

                     body.emit(assign(r388C, r38F9, 0x01));

                     body.emit(assign(r388B, r38F7, 0x01));

                     ir_variable *const r38FC = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r38FC, r3890, 0x01));

                     ir_variable *const r38FD = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r38FD, r38F9, 0x01));

                     ir_variable *const r38FE = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r38FE, r38F8, 0x01));

                     ir_variable *const r38FF = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r38FF, r38F7, 0x01));

                     ir_variable *const r3900 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r3900, body.constant(true), 0x01));

                     ir_variable *const r3901 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r3902 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r3902);
                     ir_expression *const r3903 = expr(ir_unop_u2i, r38F7);
                     body.emit(assign(r3902, less(r3903, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3905 = lequal(body.constant(int(2045)), r3890);
                     ir_if *f3904 = new(mem_ctx) ir_if(operand(r3905).val);
                     exec_list *const f3904_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3904->then_instructions;

                        ir_variable *const r3906 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3908 = less(body.constant(int(2045)), r3890);
                        ir_if *f3907 = new(mem_ctx) ir_if(operand(r3908).val);
                        exec_list *const f3907_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3907->then_instructions;

                           body.emit(assign(r3906, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3907->else_instructions;

                           ir_variable *const r3909 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r390B = equal(r3890, body.constant(int(2045)));
                           ir_if *f390A = new(mem_ctx) ir_if(operand(r390B).val);
                           exec_list *const f390A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f390A->then_instructions;

                              ir_expression *const r390C = equal(body.constant(2097151u), r38F9);
                              ir_expression *const r390D = equal(body.constant(4294967295u), r38F8);
                              body.emit(assign(r3909, logic_and(r390C, r390D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f390A->else_instructions;

                              body.emit(assign(r3909, body.constant(false), 0x01));


                           body.instructions = f390A_parent_instructions;
                           body.emit(f390A);

                           /* END IF */

                           body.emit(assign(r3906, logic_and(r3909, r3902), 0x01));


                        body.instructions = f3907_parent_instructions;
                        body.emit(f3907);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f390E = new(mem_ctx) ir_if(operand(r3906).val);
                        exec_list *const f390E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f390E->then_instructions;

                           ir_variable *const r390F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r390F);
                           ir_expression *const r3910 = lshift(r34C5, body.constant(int(31)));
                           body.emit(assign(r390F, add(r3910, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r390F, body.constant(0u), 0x01));

                           body.emit(assign(r3901, r390F, 0x03));

                           body.emit(assign(r3900, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f390E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3912 = less(r3890, body.constant(int(0)));
                           ir_if *f3911 = new(mem_ctx) ir_if(operand(r3912).val);
                           exec_list *const f3911_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3911->then_instructions;

                              ir_variable *const r3913 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3913, r38F7, 0x01));

                              ir_variable *const r3914 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3914, neg(r3890), 0x01));

                              ir_variable *const r3915 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3915);
                              ir_variable *const r3916 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3916);
                              ir_variable *const r3917 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3917);
                              ir_variable *const r3918 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3919 = neg(r3914);
                              body.emit(assign(r3918, bit_and(r3919, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r391B = equal(r3914, body.constant(int(0)));
                              ir_if *f391A = new(mem_ctx) ir_if(operand(r391B).val);
                              exec_list *const f391A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f391A->then_instructions;

                                 body.emit(assign(r3915, r38F7, 0x01));

                                 body.emit(assign(r3916, r38F8, 0x01));

                                 body.emit(assign(r3917, r38F9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f391A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r391D = less(r3914, body.constant(int(32)));
                                 ir_if *f391C = new(mem_ctx) ir_if(operand(r391D).val);
                                 exec_list *const f391C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f391C->then_instructions;

                                    body.emit(assign(r3915, lshift(r38F8, r3918), 0x01));

                                    ir_expression *const r391E = lshift(r38F9, r3918);
                                    ir_expression *const r391F = rshift(r38F8, r3914);
                                    body.emit(assign(r3916, bit_or(r391E, r391F), 0x01));

                                    body.emit(assign(r3917, rshift(r38F9, r3914), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f391C->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3921 = equal(r3914, body.constant(int(32)));
                                    ir_if *f3920 = new(mem_ctx) ir_if(operand(r3921).val);
                                    exec_list *const f3920_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3920->then_instructions;

                                       body.emit(assign(r3915, r38F8, 0x01));

                                       body.emit(assign(r3916, r38F9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3920->else_instructions;

                                       body.emit(assign(r3913, bit_or(r38F7, r38F8), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3923 = less(r3914, body.constant(int(64)));
                                       ir_if *f3922 = new(mem_ctx) ir_if(operand(r3923).val);
                                       exec_list *const f3922_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3922->then_instructions;

                                          body.emit(assign(r3915, lshift(r38F9, r3918), 0x01));

                                          ir_expression *const r3924 = bit_and(r3914, body.constant(int(31)));
                                          body.emit(assign(r3916, rshift(r38F9, r3924), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3922->else_instructions;

                                          ir_variable *const r3925 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3927 = equal(r3914, body.constant(int(64)));
                                          ir_if *f3926 = new(mem_ctx) ir_if(operand(r3927).val);
                                          exec_list *const f3926_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3926->then_instructions;

                                             body.emit(assign(r3925, r38F9, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3926->else_instructions;

                                             ir_expression *const r3928 = nequal(r38F9, body.constant(0u));
                                             ir_expression *const r3929 = expr(ir_unop_b2i, r3928);
                                             body.emit(assign(r3925, expr(ir_unop_i2u, r3929), 0x01));


                                          body.instructions = f3926_parent_instructions;
                                          body.emit(f3926);

                                          /* END IF */

                                          body.emit(assign(r3915, r3925, 0x01));

                                          body.emit(assign(r3916, body.constant(0u), 0x01));


                                       body.instructions = f3922_parent_instructions;
                                       body.emit(f3922);

                                       /* END IF */


                                    body.instructions = f3920_parent_instructions;
                                    body.emit(f3920);

                                    /* END IF */

                                    body.emit(assign(r3917, body.constant(0u), 0x01));


                                 body.instructions = f391C_parent_instructions;
                                 body.emit(f391C);

                                 /* END IF */

                                 ir_expression *const r392A = nequal(r3913, body.constant(0u));
                                 ir_expression *const r392B = expr(ir_unop_b2i, r392A);
                                 ir_expression *const r392C = expr(ir_unop_i2u, r392B);
                                 body.emit(assign(r3915, bit_or(r3915, r392C), 0x01));


                              body.instructions = f391A_parent_instructions;
                              body.emit(f391A);

                              /* END IF */

                              body.emit(assign(r38FD, r3917, 0x01));

                              body.emit(assign(r38FE, r3916, 0x01));

                              body.emit(assign(r38FF, r3915, 0x01));

                              body.emit(assign(r38FC, body.constant(int(0)), 0x01));

                              body.emit(assign(r3902, less(r3915, body.constant(0u)), 0x01));


                           body.instructions = f3911_parent_instructions;
                           body.emit(f3911);

                           /* END IF */


                        body.instructions = f390E_parent_instructions;
                        body.emit(f390E);

                        /* END IF */


                     body.instructions = f3904_parent_instructions;
                     body.emit(f3904);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f392D = new(mem_ctx) ir_if(operand(r3900).val);
                     exec_list *const f392D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f392D->then_instructions;

                        /* IF CONDITION */
                        ir_if *f392E = new(mem_ctx) ir_if(operand(r3902).val);
                        exec_list *const f392E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f392E->then_instructions;

                           ir_variable *const r392F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r392F, add(r38FE, body.constant(1u)), 0x01));

                           ir_expression *const r3930 = less(r392F, r38FE);
                           ir_expression *const r3931 = expr(ir_unop_b2i, r3930);
                           ir_expression *const r3932 = expr(ir_unop_i2u, r3931);
                           body.emit(assign(r38FD, add(r38FD, r3932), 0x01));

                           ir_expression *const r3933 = equal(r38FF, body.constant(0u));
                           ir_expression *const r3934 = expr(ir_unop_b2i, r3933);
                           ir_expression *const r3935 = expr(ir_unop_i2u, r3934);
                           ir_expression *const r3936 = add(r38FF, r3935);
                           ir_expression *const r3937 = bit_and(r3936, body.constant(1u));
                           ir_expression *const r3938 = expr(ir_unop_bit_not, r3937);
                           body.emit(assign(r38FE, bit_and(r392F, r3938), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f392E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r393A = bit_or(r38FD, r38FE);
                           ir_expression *const r393B = equal(r393A, body.constant(0u));
                           ir_if *f3939 = new(mem_ctx) ir_if(operand(r393B).val);
                           exec_list *const f3939_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3939->then_instructions;

                              body.emit(assign(r38FC, body.constant(int(0)), 0x01));


                           body.instructions = f3939_parent_instructions;
                           body.emit(f3939);

                           /* END IF */


                        body.instructions = f392E_parent_instructions;
                        body.emit(f392E);

                        /* END IF */

                        ir_variable *const r393C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r393C);
                        ir_expression *const r393D = lshift(r34C5, body.constant(int(31)));
                        ir_expression *const r393E = expr(ir_unop_i2u, r38FC);
                        ir_expression *const r393F = lshift(r393E, body.constant(int(20)));
                        ir_expression *const r3940 = add(r393D, r393F);
                        body.emit(assign(r393C, add(r3940, r38FD), 0x02));

                        body.emit(assign(r393C, r38FE, 0x01));

                        body.emit(assign(r3901, r393C, 0x03));

                        body.emit(assign(r3900, body.constant(false), 0x01));


                     body.instructions = f392D_parent_instructions;
                     body.emit(f392D);

                     /* END IF */

                     body.emit(assign(r3884, r3901, 0x03));

                     body.emit(assign(r3883, body.constant(false), 0x01));


                  body.instructions = f38F3_parent_instructions;
                  body.emit(f38F3);

                  /* END IF */


               body.instructions = f38DB_parent_instructions;
               body.emit(f38DB);

               /* END IF */


            body.instructions = f38BD_parent_instructions;
            body.emit(f38BD);

            /* END IF */


         body.instructions = f3895_parent_instructions;
         body.emit(f3895);

         /* END IF */

         /* IF CONDITION */
         ir_if *f3941 = new(mem_ctx) ir_if(operand(r3883).val);
         exec_list *const f3941_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3941->then_instructions;

            body.emit(assign(r3888, bit_or(r3888, body.constant(1048576u)), 0x01));

            ir_variable *const r3942 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r3943 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r3943, add(r3889, r3887), 0x01));

            ir_expression *const r3944 = add(r3888, r3886);
            ir_expression *const r3945 = less(r3943, r3889);
            ir_expression *const r3946 = expr(ir_unop_b2i, r3945);
            ir_expression *const r3947 = expr(ir_unop_i2u, r3946);
            body.emit(assign(r3942, add(r3944, r3947), 0x01));

            body.emit(assign(r388C, r3942, 0x01));

            body.emit(assign(r388A, add(r388A, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3949 = less(r3942, body.constant(2097152u));
            ir_if *f3948 = new(mem_ctx) ir_if(operand(r3949).val);
            exec_list *const f3948_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3948->then_instructions;

               ir_variable *const r394A = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r394A, r388A, 0x01));

               ir_variable *const r394B = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r394B, r3942, 0x01));

               ir_variable *const r394C = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r394C, r3943, 0x01));

               ir_variable *const r394D = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r394D, r388B, 0x01));

               ir_variable *const r394E = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r394E, body.constant(true), 0x01));

               ir_variable *const r394F = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3950 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3950);
               ir_expression *const r3951 = expr(ir_unop_u2i, r388B);
               body.emit(assign(r3950, less(r3951, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3953 = lequal(body.constant(int(2045)), r388A);
               ir_if *f3952 = new(mem_ctx) ir_if(operand(r3953).val);
               exec_list *const f3952_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3952->then_instructions;

                  ir_variable *const r3954 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3956 = less(body.constant(int(2045)), r388A);
                  ir_if *f3955 = new(mem_ctx) ir_if(operand(r3956).val);
                  exec_list *const f3955_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3955->then_instructions;

                     body.emit(assign(r3954, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3955->else_instructions;

                     ir_variable *const r3957 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3959 = equal(r388A, body.constant(int(2045)));
                     ir_if *f3958 = new(mem_ctx) ir_if(operand(r3959).val);
                     exec_list *const f3958_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3958->then_instructions;

                        ir_expression *const r395A = equal(body.constant(2097151u), r3942);
                        ir_expression *const r395B = equal(body.constant(4294967295u), r3943);
                        body.emit(assign(r3957, logic_and(r395A, r395B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3958->else_instructions;

                        body.emit(assign(r3957, body.constant(false), 0x01));


                     body.instructions = f3958_parent_instructions;
                     body.emit(f3958);

                     /* END IF */

                     body.emit(assign(r3954, logic_and(r3957, r3950), 0x01));


                  body.instructions = f3955_parent_instructions;
                  body.emit(f3955);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f395C = new(mem_ctx) ir_if(operand(r3954).val);
                  exec_list *const f395C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f395C->then_instructions;

                     ir_variable *const r395D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r395D);
                     ir_expression *const r395E = lshift(r34C5, body.constant(int(31)));
                     body.emit(assign(r395D, add(r395E, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r395D, body.constant(0u), 0x01));

                     body.emit(assign(r394F, r395D, 0x03));

                     body.emit(assign(r394E, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f395C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3960 = less(r388A, body.constant(int(0)));
                     ir_if *f395F = new(mem_ctx) ir_if(operand(r3960).val);
                     exec_list *const f395F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f395F->then_instructions;

                        ir_variable *const r3961 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3961, r388B, 0x01));

                        ir_variable *const r3962 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3962, neg(r388A), 0x01));

                        ir_variable *const r3963 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3963);
                        ir_variable *const r3964 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3964);
                        ir_variable *const r3965 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3965);
                        ir_variable *const r3966 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3967 = neg(r3962);
                        body.emit(assign(r3966, bit_and(r3967, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3969 = equal(r3962, body.constant(int(0)));
                        ir_if *f3968 = new(mem_ctx) ir_if(operand(r3969).val);
                        exec_list *const f3968_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3968->then_instructions;

                           body.emit(assign(r3963, r388B, 0x01));

                           body.emit(assign(r3964, r3943, 0x01));

                           body.emit(assign(r3965, r3942, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3968->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r396B = less(r3962, body.constant(int(32)));
                           ir_if *f396A = new(mem_ctx) ir_if(operand(r396B).val);
                           exec_list *const f396A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f396A->then_instructions;

                              body.emit(assign(r3963, lshift(r3943, r3966), 0x01));

                              ir_expression *const r396C = lshift(r3942, r3966);
                              ir_expression *const r396D = rshift(r3943, r3962);
                              body.emit(assign(r3964, bit_or(r396C, r396D), 0x01));

                              body.emit(assign(r3965, rshift(r3942, r3962), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f396A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r396F = equal(r3962, body.constant(int(32)));
                              ir_if *f396E = new(mem_ctx) ir_if(operand(r396F).val);
                              exec_list *const f396E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f396E->then_instructions;

                                 body.emit(assign(r3963, r3943, 0x01));

                                 body.emit(assign(r3964, r3942, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f396E->else_instructions;

                                 body.emit(assign(r3961, bit_or(r388B, r3943), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3971 = less(r3962, body.constant(int(64)));
                                 ir_if *f3970 = new(mem_ctx) ir_if(operand(r3971).val);
                                 exec_list *const f3970_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3970->then_instructions;

                                    body.emit(assign(r3963, lshift(r3942, r3966), 0x01));

                                    ir_expression *const r3972 = bit_and(r3962, body.constant(int(31)));
                                    body.emit(assign(r3964, rshift(r3942, r3972), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3970->else_instructions;

                                    ir_variable *const r3973 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3975 = equal(r3962, body.constant(int(64)));
                                    ir_if *f3974 = new(mem_ctx) ir_if(operand(r3975).val);
                                    exec_list *const f3974_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3974->then_instructions;

                                       body.emit(assign(r3973, r3942, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3974->else_instructions;

                                       ir_expression *const r3976 = nequal(r3942, body.constant(0u));
                                       ir_expression *const r3977 = expr(ir_unop_b2i, r3976);
                                       body.emit(assign(r3973, expr(ir_unop_i2u, r3977), 0x01));


                                    body.instructions = f3974_parent_instructions;
                                    body.emit(f3974);

                                    /* END IF */

                                    body.emit(assign(r3963, r3973, 0x01));

                                    body.emit(assign(r3964, body.constant(0u), 0x01));


                                 body.instructions = f3970_parent_instructions;
                                 body.emit(f3970);

                                 /* END IF */


                              body.instructions = f396E_parent_instructions;
                              body.emit(f396E);

                              /* END IF */

                              body.emit(assign(r3965, body.constant(0u), 0x01));


                           body.instructions = f396A_parent_instructions;
                           body.emit(f396A);

                           /* END IF */

                           ir_expression *const r3978 = nequal(r3961, body.constant(0u));
                           ir_expression *const r3979 = expr(ir_unop_b2i, r3978);
                           ir_expression *const r397A = expr(ir_unop_i2u, r3979);
                           body.emit(assign(r3963, bit_or(r3963, r397A), 0x01));


                        body.instructions = f3968_parent_instructions;
                        body.emit(f3968);

                        /* END IF */

                        body.emit(assign(r394B, r3965, 0x01));

                        body.emit(assign(r394C, r3964, 0x01));

                        body.emit(assign(r394D, r3963, 0x01));

                        body.emit(assign(r394A, body.constant(int(0)), 0x01));

                        body.emit(assign(r3950, less(r3963, body.constant(0u)), 0x01));


                     body.instructions = f395F_parent_instructions;
                     body.emit(f395F);

                     /* END IF */


                  body.instructions = f395C_parent_instructions;
                  body.emit(f395C);

                  /* END IF */


               body.instructions = f3952_parent_instructions;
               body.emit(f3952);

               /* END IF */

               /* IF CONDITION */
               ir_if *f397B = new(mem_ctx) ir_if(operand(r394E).val);
               exec_list *const f397B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f397B->then_instructions;

                  /* IF CONDITION */
                  ir_if *f397C = new(mem_ctx) ir_if(operand(r3950).val);
                  exec_list *const f397C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f397C->then_instructions;

                     ir_variable *const r397D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r397D, add(r394C, body.constant(1u)), 0x01));

                     ir_expression *const r397E = less(r397D, r394C);
                     ir_expression *const r397F = expr(ir_unop_b2i, r397E);
                     ir_expression *const r3980 = expr(ir_unop_i2u, r397F);
                     body.emit(assign(r394B, add(r394B, r3980), 0x01));

                     ir_expression *const r3981 = equal(r394D, body.constant(0u));
                     ir_expression *const r3982 = expr(ir_unop_b2i, r3981);
                     ir_expression *const r3983 = expr(ir_unop_i2u, r3982);
                     ir_expression *const r3984 = add(r394D, r3983);
                     ir_expression *const r3985 = bit_and(r3984, body.constant(1u));
                     ir_expression *const r3986 = expr(ir_unop_bit_not, r3985);
                     body.emit(assign(r394C, bit_and(r397D, r3986), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f397C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3988 = bit_or(r394B, r394C);
                     ir_expression *const r3989 = equal(r3988, body.constant(0u));
                     ir_if *f3987 = new(mem_ctx) ir_if(operand(r3989).val);
                     exec_list *const f3987_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3987->then_instructions;

                        body.emit(assign(r394A, body.constant(int(0)), 0x01));


                     body.instructions = f3987_parent_instructions;
                     body.emit(f3987);

                     /* END IF */


                  body.instructions = f397C_parent_instructions;
                  body.emit(f397C);

                  /* END IF */

                  ir_variable *const r398A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r398A);
                  ir_expression *const r398B = lshift(r34C5, body.constant(int(31)));
                  ir_expression *const r398C = expr(ir_unop_i2u, r394A);
                  ir_expression *const r398D = lshift(r398C, body.constant(int(20)));
                  ir_expression *const r398E = add(r398B, r398D);
                  body.emit(assign(r398A, add(r398E, r394B), 0x02));

                  body.emit(assign(r398A, r394C, 0x01));

                  body.emit(assign(r394F, r398A, 0x03));

                  body.emit(assign(r394E, body.constant(false), 0x01));


               body.instructions = f397B_parent_instructions;
               body.emit(f397B);

               /* END IF */

               body.emit(assign(r3884, r394F, 0x03));

               body.emit(assign(r3883, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3948->else_instructions;

               body.emit(assign(r388A, add(r388A, body.constant(int(1))), 0x01));

               ir_variable *const r398F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r398F);
               ir_variable *const r3990 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3990);
               ir_variable *const r3991 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3991);
               body.emit(assign(r398F, lshift(r3943, body.constant(int(31))), 0x01));

               ir_expression *const r3992 = lshift(r3942, body.constant(int(31)));
               ir_expression *const r3993 = rshift(r3943, body.constant(int(1)));
               body.emit(assign(r3990, bit_or(r3992, r3993), 0x01));

               body.emit(assign(r3991, rshift(r3942, body.constant(int(1))), 0x01));

               ir_expression *const r3994 = nequal(r388B, body.constant(0u));
               ir_expression *const r3995 = expr(ir_unop_b2i, r3994);
               ir_expression *const r3996 = expr(ir_unop_i2u, r3995);
               body.emit(assign(r398F, bit_or(r398F, r3996), 0x01));

               body.emit(assign(r388C, r3991, 0x01));

               body.emit(assign(r388B, r398F, 0x01));

               ir_variable *const r3997 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3997, r388A, 0x01));

               ir_variable *const r3998 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3998, r3991, 0x01));

               ir_variable *const r3999 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3999, r3990, 0x01));

               ir_variable *const r399A = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r399A, r398F, 0x01));

               ir_variable *const r399B = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r399B, body.constant(true), 0x01));

               ir_variable *const r399C = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r399D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r399D);
               ir_expression *const r399E = expr(ir_unop_u2i, r398F);
               body.emit(assign(r399D, less(r399E, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r39A0 = lequal(body.constant(int(2045)), r388A);
               ir_if *f399F = new(mem_ctx) ir_if(operand(r39A0).val);
               exec_list *const f399F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f399F->then_instructions;

                  ir_variable *const r39A1 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r39A3 = less(body.constant(int(2045)), r388A);
                  ir_if *f39A2 = new(mem_ctx) ir_if(operand(r39A3).val);
                  exec_list *const f39A2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f39A2->then_instructions;

                     body.emit(assign(r39A1, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f39A2->else_instructions;

                     ir_variable *const r39A4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r39A6 = equal(r388A, body.constant(int(2045)));
                     ir_if *f39A5 = new(mem_ctx) ir_if(operand(r39A6).val);
                     exec_list *const f39A5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f39A5->then_instructions;

                        ir_expression *const r39A7 = equal(body.constant(2097151u), r3991);
                        ir_expression *const r39A8 = equal(body.constant(4294967295u), r3990);
                        body.emit(assign(r39A4, logic_and(r39A7, r39A8), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f39A5->else_instructions;

                        body.emit(assign(r39A4, body.constant(false), 0x01));


                     body.instructions = f39A5_parent_instructions;
                     body.emit(f39A5);

                     /* END IF */

                     body.emit(assign(r39A1, logic_and(r39A4, r399D), 0x01));


                  body.instructions = f39A2_parent_instructions;
                  body.emit(f39A2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f39A9 = new(mem_ctx) ir_if(operand(r39A1).val);
                  exec_list *const f39A9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f39A9->then_instructions;

                     ir_variable *const r39AA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r39AA);
                     ir_expression *const r39AB = lshift(r34C5, body.constant(int(31)));
                     body.emit(assign(r39AA, add(r39AB, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r39AA, body.constant(0u), 0x01));

                     body.emit(assign(r399C, r39AA, 0x03));

                     body.emit(assign(r399B, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f39A9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r39AD = less(r388A, body.constant(int(0)));
                     ir_if *f39AC = new(mem_ctx) ir_if(operand(r39AD).val);
                     exec_list *const f39AC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f39AC->then_instructions;

                        ir_variable *const r39AE = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r39AE, r398F, 0x01));

                        ir_variable *const r39AF = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r39AF, neg(r388A), 0x01));

                        ir_variable *const r39B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r39B0);
                        ir_variable *const r39B1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r39B1);
                        ir_variable *const r39B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r39B2);
                        ir_variable *const r39B3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r39B4 = neg(r39AF);
                        body.emit(assign(r39B3, bit_and(r39B4, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r39B6 = equal(r39AF, body.constant(int(0)));
                        ir_if *f39B5 = new(mem_ctx) ir_if(operand(r39B6).val);
                        exec_list *const f39B5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f39B5->then_instructions;

                           body.emit(assign(r39B0, r398F, 0x01));

                           body.emit(assign(r39B1, r3990, 0x01));

                           body.emit(assign(r39B2, r3991, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f39B5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r39B8 = less(r39AF, body.constant(int(32)));
                           ir_if *f39B7 = new(mem_ctx) ir_if(operand(r39B8).val);
                           exec_list *const f39B7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f39B7->then_instructions;

                              body.emit(assign(r39B0, lshift(r3990, r39B3), 0x01));

                              ir_expression *const r39B9 = lshift(r3991, r39B3);
                              ir_expression *const r39BA = rshift(r3990, r39AF);
                              body.emit(assign(r39B1, bit_or(r39B9, r39BA), 0x01));

                              body.emit(assign(r39B2, rshift(r3991, r39AF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f39B7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r39BC = equal(r39AF, body.constant(int(32)));
                              ir_if *f39BB = new(mem_ctx) ir_if(operand(r39BC).val);
                              exec_list *const f39BB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f39BB->then_instructions;

                                 body.emit(assign(r39B0, r3990, 0x01));

                                 body.emit(assign(r39B1, r3991, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f39BB->else_instructions;

                                 body.emit(assign(r39AE, bit_or(r398F, r3990), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r39BE = less(r39AF, body.constant(int(64)));
                                 ir_if *f39BD = new(mem_ctx) ir_if(operand(r39BE).val);
                                 exec_list *const f39BD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f39BD->then_instructions;

                                    body.emit(assign(r39B0, lshift(r3991, r39B3), 0x01));

                                    ir_expression *const r39BF = bit_and(r39AF, body.constant(int(31)));
                                    body.emit(assign(r39B1, rshift(r3991, r39BF), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f39BD->else_instructions;

                                    ir_variable *const r39C0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r39C2 = equal(r39AF, body.constant(int(64)));
                                    ir_if *f39C1 = new(mem_ctx) ir_if(operand(r39C2).val);
                                    exec_list *const f39C1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f39C1->then_instructions;

                                       body.emit(assign(r39C0, r3991, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f39C1->else_instructions;

                                       ir_expression *const r39C3 = nequal(r3991, body.constant(0u));
                                       ir_expression *const r39C4 = expr(ir_unop_b2i, r39C3);
                                       body.emit(assign(r39C0, expr(ir_unop_i2u, r39C4), 0x01));


                                    body.instructions = f39C1_parent_instructions;
                                    body.emit(f39C1);

                                    /* END IF */

                                    body.emit(assign(r39B0, r39C0, 0x01));

                                    body.emit(assign(r39B1, body.constant(0u), 0x01));


                                 body.instructions = f39BD_parent_instructions;
                                 body.emit(f39BD);

                                 /* END IF */


                              body.instructions = f39BB_parent_instructions;
                              body.emit(f39BB);

                              /* END IF */

                              body.emit(assign(r39B2, body.constant(0u), 0x01));


                           body.instructions = f39B7_parent_instructions;
                           body.emit(f39B7);

                           /* END IF */

                           ir_expression *const r39C5 = nequal(r39AE, body.constant(0u));
                           ir_expression *const r39C6 = expr(ir_unop_b2i, r39C5);
                           ir_expression *const r39C7 = expr(ir_unop_i2u, r39C6);
                           body.emit(assign(r39B0, bit_or(r39B0, r39C7), 0x01));


                        body.instructions = f39B5_parent_instructions;
                        body.emit(f39B5);

                        /* END IF */

                        body.emit(assign(r3998, r39B2, 0x01));

                        body.emit(assign(r3999, r39B1, 0x01));

                        body.emit(assign(r399A, r39B0, 0x01));

                        body.emit(assign(r3997, body.constant(int(0)), 0x01));

                        body.emit(assign(r399D, less(r39B0, body.constant(0u)), 0x01));


                     body.instructions = f39AC_parent_instructions;
                     body.emit(f39AC);

                     /* END IF */


                  body.instructions = f39A9_parent_instructions;
                  body.emit(f39A9);

                  /* END IF */


               body.instructions = f399F_parent_instructions;
               body.emit(f399F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f39C8 = new(mem_ctx) ir_if(operand(r399B).val);
               exec_list *const f39C8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f39C8->then_instructions;

                  /* IF CONDITION */
                  ir_if *f39C9 = new(mem_ctx) ir_if(operand(r399D).val);
                  exec_list *const f39C9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f39C9->then_instructions;

                     ir_variable *const r39CA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r39CA, add(r3999, body.constant(1u)), 0x01));

                     ir_expression *const r39CB = less(r39CA, r3999);
                     ir_expression *const r39CC = expr(ir_unop_b2i, r39CB);
                     ir_expression *const r39CD = expr(ir_unop_i2u, r39CC);
                     body.emit(assign(r3998, add(r3998, r39CD), 0x01));

                     ir_expression *const r39CE = equal(r399A, body.constant(0u));
                     ir_expression *const r39CF = expr(ir_unop_b2i, r39CE);
                     ir_expression *const r39D0 = expr(ir_unop_i2u, r39CF);
                     ir_expression *const r39D1 = add(r399A, r39D0);
                     ir_expression *const r39D2 = bit_and(r39D1, body.constant(1u));
                     ir_expression *const r39D3 = expr(ir_unop_bit_not, r39D2);
                     body.emit(assign(r3999, bit_and(r39CA, r39D3), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f39C9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r39D5 = bit_or(r3998, r3999);
                     ir_expression *const r39D6 = equal(r39D5, body.constant(0u));
                     ir_if *f39D4 = new(mem_ctx) ir_if(operand(r39D6).val);
                     exec_list *const f39D4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f39D4->then_instructions;

                        body.emit(assign(r3997, body.constant(int(0)), 0x01));


                     body.instructions = f39D4_parent_instructions;
                     body.emit(f39D4);

                     /* END IF */


                  body.instructions = f39C9_parent_instructions;
                  body.emit(f39C9);

                  /* END IF */

                  ir_variable *const r39D7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r39D7);
                  ir_expression *const r39D8 = lshift(r34C5, body.constant(int(31)));
                  ir_expression *const r39D9 = expr(ir_unop_i2u, r3997);
                  ir_expression *const r39DA = lshift(r39D9, body.constant(int(20)));
                  ir_expression *const r39DB = add(r39D8, r39DA);
                  body.emit(assign(r39D7, add(r39DB, r3998), 0x02));

                  body.emit(assign(r39D7, r3999, 0x01));

                  body.emit(assign(r399C, r39D7, 0x03));

                  body.emit(assign(r399B, body.constant(false), 0x01));


               body.instructions = f39C8_parent_instructions;
               body.emit(f39C8);

               /* END IF */

               body.emit(assign(r3884, r399C, 0x03));

               body.emit(assign(r3883, body.constant(false), 0x01));


            body.instructions = f3948_parent_instructions;
            body.emit(f3948);

            /* END IF */


         body.instructions = f3941_parent_instructions;
         body.emit(f3941);

         /* END IF */

         body.emit(assign(r34C4, r3884, 0x03));


      body.instructions = f34C6_parent_instructions;
      body.emit(f34C6);

      /* END IF */

      body.emit(assign(r34C2, r34C4, 0x03));


   body.instructions = f34C3_parent_instructions;
   body.emit(f34C3);

   /* END IF */

   ir_variable *const r39DC = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r39DC, body.constant(true), 0x01));

   ir_variable *const r39DD = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r39DE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r39DE);
   ir_variable *const r39DF = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r39DF);
   ir_variable *const r39E0 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r39E0);
   ir_variable *const r39E1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r39E1);
   ir_variable *const r39E2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r39E2);
   ir_variable *const r39E3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r39E3);
   ir_variable *const r39E4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r39E4);
   ir_variable *const r39E5 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r39E5);
   ir_variable *const r39E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r39E6);
   ir_variable *const r39E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r39E7);
   ir_variable *const r39E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r39E8);
   body.emit(assign(r39E8, body.constant(0u), 0x01));

   body.emit(assign(r39E7, body.constant(0u), 0x01));

   body.emit(assign(r39E6, body.constant(0u), 0x01));

   ir_variable *const r39E9 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r39E9, swizzle_x(r321E), 0x01));

   body.emit(assign(r39E4, r39E9, 0x01));

   ir_variable *const r39EA = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r39EA, bit_and(swizzle_y(r321E), body.constant(1048575u)), 0x01));

   body.emit(assign(r39E3, r39EA, 0x01));

   ir_variable *const r39EB = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r39EB, swizzle_x(r34C2), 0x01));

   body.emit(assign(r39E2, r39EB, 0x01));

   ir_variable *const r39EC = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r39EC, bit_and(swizzle_y(r34C2), body.constant(1048575u)), 0x01));

   body.emit(assign(r39E1, r39EC, 0x01));

   ir_variable *const r39ED = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r39EE = rshift(swizzle_y(r321E), body.constant(int(20)));
   ir_expression *const r39EF = bit_and(r39EE, body.constant(2047u));
   body.emit(assign(r39ED, expr(ir_unop_u2i, r39EF), 0x01));

   body.emit(assign(r39E0, r39ED, 0x01));

   ir_variable *const r39F0 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r39F1 = rshift(swizzle_y(r34C2), body.constant(int(20)));
   ir_expression *const r39F2 = bit_and(r39F1, body.constant(2047u));
   body.emit(assign(r39F0, expr(ir_unop_u2i, r39F2), 0x01));

   body.emit(assign(r39DF, r39F0, 0x01));

   ir_expression *const r39F3 = rshift(swizzle_y(r321E), body.constant(int(31)));
   ir_expression *const r39F4 = rshift(swizzle_y(r34C2), body.constant(int(31)));
   body.emit(assign(r39DE, bit_xor(r39F3, r39F4), 0x01));

   /* IF CONDITION */
   ir_expression *const r39F6 = equal(r39ED, body.constant(int(2047)));
   ir_if *f39F5 = new(mem_ctx) ir_if(operand(r39F6).val);
   exec_list *const f39F5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f39F5->then_instructions;

      /* IF CONDITION */
      ir_expression *const r39F8 = bit_or(r39EA, swizzle_x(r321E));
      ir_expression *const r39F9 = nequal(r39F8, body.constant(0u));
      ir_expression *const r39FA = equal(r39F0, body.constant(int(2047)));
      ir_expression *const r39FB = bit_or(r39EC, swizzle_x(r34C2));
      ir_expression *const r39FC = nequal(r39FB, body.constant(0u));
      ir_expression *const r39FD = logic_and(r39FA, r39FC);
      ir_expression *const r39FE = logic_or(r39F9, r39FD);
      ir_if *f39F7 = new(mem_ctx) ir_if(operand(r39FE).val);
      exec_list *const f39F7_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f39F7->then_instructions;

         ir_variable *const r39FF = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r39FF, swizzle_x(r321E), 0x01));

         ir_variable *const r3A00 = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r3A00, swizzle_x(r34C2), 0x01));

         ir_variable *const r3A01 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r3A02 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r3A03 = rshift(swizzle_y(r321E), body.constant(int(19)));
         ir_expression *const r3A04 = bit_and(r3A03, body.constant(4095u));
         ir_expression *const r3A05 = equal(r3A04, body.constant(4094u));
         ir_expression *const r3A06 = nequal(swizzle_x(r321E), body.constant(0u));
         ir_expression *const r3A07 = bit_and(swizzle_y(r321E), body.constant(524287u));
         ir_expression *const r3A08 = nequal(r3A07, body.constant(0u));
         ir_expression *const r3A09 = logic_or(r3A06, r3A08);
         body.emit(assign(r3A02, logic_and(r3A05, r3A09), 0x01));

         ir_variable *const r3A0A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r3A0B = lshift(swizzle_y(r34C2), body.constant(int(1)));
         ir_expression *const r3A0C = lequal(body.constant(4292870144u), r3A0B);
         ir_expression *const r3A0D = nequal(swizzle_x(r34C2), body.constant(0u));
         ir_expression *const r3A0E = bit_and(swizzle_y(r34C2), body.constant(1048575u));
         ir_expression *const r3A0F = nequal(r3A0E, body.constant(0u));
         ir_expression *const r3A10 = logic_or(r3A0D, r3A0F);
         body.emit(assign(r3A0A, logic_and(r3A0C, r3A10), 0x01));

         body.emit(assign(r39FF, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

         body.emit(assign(r3A00, bit_or(swizzle_y(r34C2), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r3A12 = lshift(swizzle_y(r321E), body.constant(int(1)));
         ir_expression *const r3A13 = lequal(body.constant(4292870144u), r3A12);
         ir_expression *const r3A14 = nequal(swizzle_x(r321E), body.constant(0u));
         ir_expression *const r3A15 = bit_and(swizzle_y(r321E), body.constant(1048575u));
         ir_expression *const r3A16 = nequal(r3A15, body.constant(0u));
         ir_expression *const r3A17 = logic_or(r3A14, r3A16);
         ir_expression *const r3A18 = logic_and(r3A13, r3A17);
         ir_if *f3A11 = new(mem_ctx) ir_if(operand(r3A18).val);
         exec_list *const f3A11_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A11->then_instructions;

            ir_variable *const r3A19 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r3A1B = logic_and(r3A02, r3A0A);
            ir_if *f3A1A = new(mem_ctx) ir_if(operand(r3A1B).val);
            exec_list *const f3A1A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A1A->then_instructions;

               body.emit(assign(r3A19, r3A00, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A1A->else_instructions;

               body.emit(assign(r3A19, r39FF, 0x03));


            body.instructions = f3A1A_parent_instructions;
            body.emit(f3A1A);

            /* END IF */

            body.emit(assign(r3A01, r3A19, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3A11->else_instructions;

            body.emit(assign(r3A01, r3A00, 0x03));


         body.instructions = f3A11_parent_instructions;
         body.emit(f3A11);

         /* END IF */

         body.emit(assign(r39DD, r3A01, 0x03));

         body.emit(assign(r39DC, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f39F7->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3A1D = expr(ir_unop_i2u, r39F0);
         ir_expression *const r3A1E = bit_or(r3A1D, r39EC);
         ir_expression *const r3A1F = bit_or(r3A1E, swizzle_x(r34C2));
         ir_expression *const r3A20 = equal(r3A1F, body.constant(0u));
         ir_if *f3A1C = new(mem_ctx) ir_if(operand(r3A20).val);
         exec_list *const f3A1C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A1C->then_instructions;

            ir_constant_data r3A21_data;
            memset(&r3A21_data, 0, sizeof(ir_constant_data));
            r3A21_data.u[0] = 4294967295;
            r3A21_data.u[1] = 4294967295;
            ir_constant *const r3A21 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3A21_data);
            body.emit(assign(r39DD, r3A21, 0x03));

            body.emit(assign(r39DC, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3A1C->else_instructions;

            ir_variable *const r3A22 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r3A22);
            ir_expression *const r3A23 = lshift(r39DE, body.constant(int(31)));
            body.emit(assign(r3A22, add(r3A23, body.constant(2146435072u)), 0x02));

            body.emit(assign(r3A22, body.constant(0u), 0x01));

            body.emit(assign(r39DD, r3A22, 0x03));

            body.emit(assign(r39DC, body.constant(false), 0x01));


         body.instructions = f3A1C_parent_instructions;
         body.emit(f3A1C);

         /* END IF */


      body.instructions = f39F7_parent_instructions;
      body.emit(f39F7);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f39F5->else_instructions;

      /* IF CONDITION */
      ir_expression *const r3A25 = equal(r39F0, body.constant(int(2047)));
      ir_if *f3A24 = new(mem_ctx) ir_if(operand(r3A25).val);
      exec_list *const f3A24_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3A24->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3A27 = bit_or(r39EC, swizzle_x(r34C2));
         ir_expression *const r3A28 = nequal(r3A27, body.constant(0u));
         ir_if *f3A26 = new(mem_ctx) ir_if(operand(r3A28).val);
         exec_list *const f3A26_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A26->then_instructions;

            ir_variable *const r3A29 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r3A29, swizzle_x(r321E), 0x01));

            ir_variable *const r3A2A = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r3A2A, swizzle_x(r34C2), 0x01));

            ir_variable *const r3A2B = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3A2C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r3A2D = rshift(swizzle_y(r321E), body.constant(int(19)));
            ir_expression *const r3A2E = bit_and(r3A2D, body.constant(4095u));
            ir_expression *const r3A2F = equal(r3A2E, body.constant(4094u));
            ir_expression *const r3A30 = nequal(swizzle_x(r321E), body.constant(0u));
            ir_expression *const r3A31 = bit_and(swizzle_y(r321E), body.constant(524287u));
            ir_expression *const r3A32 = nequal(r3A31, body.constant(0u));
            ir_expression *const r3A33 = logic_or(r3A30, r3A32);
            body.emit(assign(r3A2C, logic_and(r3A2F, r3A33), 0x01));

            ir_variable *const r3A34 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r3A35 = lshift(swizzle_y(r34C2), body.constant(int(1)));
            ir_expression *const r3A36 = lequal(body.constant(4292870144u), r3A35);
            ir_expression *const r3A37 = nequal(swizzle_x(r34C2), body.constant(0u));
            ir_expression *const r3A38 = bit_and(swizzle_y(r34C2), body.constant(1048575u));
            ir_expression *const r3A39 = nequal(r3A38, body.constant(0u));
            ir_expression *const r3A3A = logic_or(r3A37, r3A39);
            body.emit(assign(r3A34, logic_and(r3A36, r3A3A), 0x01));

            body.emit(assign(r3A29, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

            body.emit(assign(r3A2A, bit_or(swizzle_y(r34C2), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r3A3C = lshift(swizzle_y(r321E), body.constant(int(1)));
            ir_expression *const r3A3D = lequal(body.constant(4292870144u), r3A3C);
            ir_expression *const r3A3E = nequal(swizzle_x(r321E), body.constant(0u));
            ir_expression *const r3A3F = bit_and(swizzle_y(r321E), body.constant(1048575u));
            ir_expression *const r3A40 = nequal(r3A3F, body.constant(0u));
            ir_expression *const r3A41 = logic_or(r3A3E, r3A40);
            ir_expression *const r3A42 = logic_and(r3A3D, r3A41);
            ir_if *f3A3B = new(mem_ctx) ir_if(operand(r3A42).val);
            exec_list *const f3A3B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A3B->then_instructions;

               ir_variable *const r3A43 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r3A45 = logic_and(r3A2C, r3A34);
               ir_if *f3A44 = new(mem_ctx) ir_if(operand(r3A45).val);
               exec_list *const f3A44_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A44->then_instructions;

                  body.emit(assign(r3A43, r3A2A, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A44->else_instructions;

                  body.emit(assign(r3A43, r3A29, 0x03));


               body.instructions = f3A44_parent_instructions;
               body.emit(f3A44);

               /* END IF */

               body.emit(assign(r3A2B, r3A43, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A3B->else_instructions;

               body.emit(assign(r3A2B, r3A2A, 0x03));


            body.instructions = f3A3B_parent_instructions;
            body.emit(f3A3B);

            /* END IF */

            body.emit(assign(r39DD, r3A2B, 0x03));

            body.emit(assign(r39DC, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3A26->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3A47 = expr(ir_unop_i2u, r39ED);
            ir_expression *const r3A48 = bit_or(r3A47, r39EA);
            ir_expression *const r3A49 = bit_or(r3A48, swizzle_x(r321E));
            ir_expression *const r3A4A = equal(r3A49, body.constant(0u));
            ir_if *f3A46 = new(mem_ctx) ir_if(operand(r3A4A).val);
            exec_list *const f3A46_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A46->then_instructions;

               ir_constant_data r3A4B_data;
               memset(&r3A4B_data, 0, sizeof(ir_constant_data));
               r3A4B_data.u[0] = 4294967295;
               r3A4B_data.u[1] = 4294967295;
               ir_constant *const r3A4B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3A4B_data);
               body.emit(assign(r39DD, r3A4B, 0x03));

               body.emit(assign(r39DC, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A46->else_instructions;

               ir_variable *const r3A4C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3A4C);
               ir_expression *const r3A4D = lshift(r39DE, body.constant(int(31)));
               body.emit(assign(r3A4C, add(r3A4D, body.constant(2146435072u)), 0x02));

               body.emit(assign(r3A4C, body.constant(0u), 0x01));

               body.emit(assign(r39DD, r3A4C, 0x03));

               body.emit(assign(r39DC, body.constant(false), 0x01));


            body.instructions = f3A46_parent_instructions;
            body.emit(f3A46);

            /* END IF */


         body.instructions = f3A26_parent_instructions;
         body.emit(f3A26);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3A24->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3A4F = equal(r39ED, body.constant(int(0)));
         ir_if *f3A4E = new(mem_ctx) ir_if(operand(r3A4F).val);
         exec_list *const f3A4E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A4E->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3A51 = bit_or(r39EA, swizzle_x(r321E));
            ir_expression *const r3A52 = equal(r3A51, body.constant(0u));
            ir_if *f3A50 = new(mem_ctx) ir_if(operand(r3A52).val);
            exec_list *const f3A50_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A50->then_instructions;

               ir_variable *const r3A53 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3A53);
               body.emit(assign(r3A53, lshift(r39DE, body.constant(int(31))), 0x02));

               body.emit(assign(r3A53, body.constant(0u), 0x01));

               body.emit(assign(r39DD, r3A53, 0x03));

               body.emit(assign(r39DC, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A50->else_instructions;

               ir_variable *const r3A54 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r3A54, r39ED, 0x01));

               ir_variable *const r3A55 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r3A55, r39EA, 0x01));

               ir_variable *const r3A56 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r3A56, r39E9, 0x01));

               ir_variable *const r3A57 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3A57);
               /* IF CONDITION */
               ir_expression *const r3A59 = equal(r39EA, body.constant(0u));
               ir_if *f3A58 = new(mem_ctx) ir_if(operand(r3A59).val);
               exec_list *const f3A58_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A58->then_instructions;

                  ir_variable *const r3A5A = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3A5A, r39E9, 0x01));

                  ir_variable *const r3A5B = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3A5C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3A5C);
                  /* IF CONDITION */
                  ir_expression *const r3A5E = equal(swizzle_x(r321E), body.constant(0u));
                  ir_if *f3A5D = new(mem_ctx) ir_if(operand(r3A5E).val);
                  exec_list *const f3A5D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A5D->then_instructions;

                     body.emit(assign(r3A5B, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A5D->else_instructions;

                     body.emit(assign(r3A5C, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3A60 = bit_and(swizzle_x(r321E), body.constant(4294901760u));
                     ir_expression *const r3A61 = equal(r3A60, body.constant(0u));
                     ir_if *f3A5F = new(mem_ctx) ir_if(operand(r3A61).val);
                     exec_list *const f3A5F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A5F->then_instructions;

                        body.emit(assign(r3A5C, body.constant(int(16)), 0x01));

                        body.emit(assign(r3A5A, lshift(swizzle_x(r321E), body.constant(int(16))), 0x01));


                     body.instructions = f3A5F_parent_instructions;
                     body.emit(f3A5F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A63 = bit_and(r3A5A, body.constant(4278190080u));
                     ir_expression *const r3A64 = equal(r3A63, body.constant(0u));
                     ir_if *f3A62 = new(mem_ctx) ir_if(operand(r3A64).val);
                     exec_list *const f3A62_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A62->then_instructions;

                        body.emit(assign(r3A5C, add(r3A5C, body.constant(int(8))), 0x01));

                        body.emit(assign(r3A5A, lshift(r3A5A, body.constant(int(8))), 0x01));


                     body.instructions = f3A62_parent_instructions;
                     body.emit(f3A62);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A66 = bit_and(r3A5A, body.constant(4026531840u));
                     ir_expression *const r3A67 = equal(r3A66, body.constant(0u));
                     ir_if *f3A65 = new(mem_ctx) ir_if(operand(r3A67).val);
                     exec_list *const f3A65_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A65->then_instructions;

                        body.emit(assign(r3A5C, add(r3A5C, body.constant(int(4))), 0x01));

                        body.emit(assign(r3A5A, lshift(r3A5A, body.constant(int(4))), 0x01));


                     body.instructions = f3A65_parent_instructions;
                     body.emit(f3A65);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A69 = bit_and(r3A5A, body.constant(3221225472u));
                     ir_expression *const r3A6A = equal(r3A69, body.constant(0u));
                     ir_if *f3A68 = new(mem_ctx) ir_if(operand(r3A6A).val);
                     exec_list *const f3A68_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A68->then_instructions;

                        body.emit(assign(r3A5C, add(r3A5C, body.constant(int(2))), 0x01));

                        body.emit(assign(r3A5A, lshift(r3A5A, body.constant(int(2))), 0x01));


                     body.instructions = f3A68_parent_instructions;
                     body.emit(f3A68);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A6C = bit_and(r3A5A, body.constant(2147483648u));
                     ir_expression *const r3A6D = equal(r3A6C, body.constant(0u));
                     ir_if *f3A6B = new(mem_ctx) ir_if(operand(r3A6D).val);
                     exec_list *const f3A6B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A6B->then_instructions;

                        body.emit(assign(r3A5C, add(r3A5C, body.constant(int(1))), 0x01));


                     body.instructions = f3A6B_parent_instructions;
                     body.emit(f3A6B);

                     /* END IF */

                     body.emit(assign(r3A5B, r3A5C, 0x01));


                  body.instructions = f3A5D_parent_instructions;
                  body.emit(f3A5D);

                  /* END IF */

                  body.emit(assign(r3A57, add(r3A5B, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3A6F = less(r3A57, body.constant(int(0)));
                  ir_if *f3A6E = new(mem_ctx) ir_if(operand(r3A6F).val);
                  exec_list *const f3A6E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A6E->then_instructions;

                     ir_expression *const r3A70 = neg(r3A57);
                     body.emit(assign(r3A55, rshift(swizzle_x(r321E), r3A70), 0x01));

                     ir_expression *const r3A71 = bit_and(r3A57, body.constant(int(31)));
                     body.emit(assign(r3A56, lshift(swizzle_x(r321E), r3A71), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A6E->else_instructions;

                     body.emit(assign(r3A55, lshift(swizzle_x(r321E), r3A57), 0x01));

                     body.emit(assign(r3A56, body.constant(0u), 0x01));


                  body.instructions = f3A6E_parent_instructions;
                  body.emit(f3A6E);

                  /* END IF */

                  body.emit(assign(r3A54, sub(body.constant(int(-31)), r3A57), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A58->else_instructions;

                  ir_variable *const r3A72 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3A72, r39EA, 0x01));

                  ir_variable *const r3A73 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3A74 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3A74);
                  /* IF CONDITION */
                  ir_expression *const r3A76 = equal(r39EA, body.constant(0u));
                  ir_if *f3A75 = new(mem_ctx) ir_if(operand(r3A76).val);
                  exec_list *const f3A75_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A75->then_instructions;

                     body.emit(assign(r3A73, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A75->else_instructions;

                     body.emit(assign(r3A74, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3A78 = bit_and(r39EA, body.constant(4294901760u));
                     ir_expression *const r3A79 = equal(r3A78, body.constant(0u));
                     ir_if *f3A77 = new(mem_ctx) ir_if(operand(r3A79).val);
                     exec_list *const f3A77_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A77->then_instructions;

                        body.emit(assign(r3A74, body.constant(int(16)), 0x01));

                        body.emit(assign(r3A72, lshift(r39EA, body.constant(int(16))), 0x01));


                     body.instructions = f3A77_parent_instructions;
                     body.emit(f3A77);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A7B = bit_and(r3A72, body.constant(4278190080u));
                     ir_expression *const r3A7C = equal(r3A7B, body.constant(0u));
                     ir_if *f3A7A = new(mem_ctx) ir_if(operand(r3A7C).val);
                     exec_list *const f3A7A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A7A->then_instructions;

                        body.emit(assign(r3A74, add(r3A74, body.constant(int(8))), 0x01));

                        body.emit(assign(r3A72, lshift(r3A72, body.constant(int(8))), 0x01));


                     body.instructions = f3A7A_parent_instructions;
                     body.emit(f3A7A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A7E = bit_and(r3A72, body.constant(4026531840u));
                     ir_expression *const r3A7F = equal(r3A7E, body.constant(0u));
                     ir_if *f3A7D = new(mem_ctx) ir_if(operand(r3A7F).val);
                     exec_list *const f3A7D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A7D->then_instructions;

                        body.emit(assign(r3A74, add(r3A74, body.constant(int(4))), 0x01));

                        body.emit(assign(r3A72, lshift(r3A72, body.constant(int(4))), 0x01));


                     body.instructions = f3A7D_parent_instructions;
                     body.emit(f3A7D);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A81 = bit_and(r3A72, body.constant(3221225472u));
                     ir_expression *const r3A82 = equal(r3A81, body.constant(0u));
                     ir_if *f3A80 = new(mem_ctx) ir_if(operand(r3A82).val);
                     exec_list *const f3A80_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A80->then_instructions;

                        body.emit(assign(r3A74, add(r3A74, body.constant(int(2))), 0x01));

                        body.emit(assign(r3A72, lshift(r3A72, body.constant(int(2))), 0x01));


                     body.instructions = f3A80_parent_instructions;
                     body.emit(f3A80);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A84 = bit_and(r3A72, body.constant(2147483648u));
                     ir_expression *const r3A85 = equal(r3A84, body.constant(0u));
                     ir_if *f3A83 = new(mem_ctx) ir_if(operand(r3A85).val);
                     exec_list *const f3A83_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A83->then_instructions;

                        body.emit(assign(r3A74, add(r3A74, body.constant(int(1))), 0x01));


                     body.instructions = f3A83_parent_instructions;
                     body.emit(f3A83);

                     /* END IF */

                     body.emit(assign(r3A73, r3A74, 0x01));


                  body.instructions = f3A75_parent_instructions;
                  body.emit(f3A75);

                  /* END IF */

                  body.emit(assign(r3A57, add(r3A73, body.constant(int(-11))), 0x01));

                  ir_variable *const r3A86 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3A86, lshift(swizzle_x(r321E), r3A57), 0x01));

                  ir_variable *const r3A87 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3A89 = equal(r3A57, body.constant(int(0)));
                  ir_if *f3A88 = new(mem_ctx) ir_if(operand(r3A89).val);
                  exec_list *const f3A88_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A88->then_instructions;

                     body.emit(assign(r3A87, r39EA, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A88->else_instructions;

                     ir_expression *const r3A8A = lshift(r39EA, r3A57);
                     ir_expression *const r3A8B = neg(r3A57);
                     ir_expression *const r3A8C = bit_and(r3A8B, body.constant(int(31)));
                     ir_expression *const r3A8D = rshift(swizzle_x(r321E), r3A8C);
                     body.emit(assign(r3A87, bit_or(r3A8A, r3A8D), 0x01));


                  body.instructions = f3A88_parent_instructions;
                  body.emit(f3A88);

                  /* END IF */

                  body.emit(assign(r3A55, r3A87, 0x01));

                  body.emit(assign(r3A56, r3A86, 0x01));

                  body.emit(assign(r3A54, sub(body.constant(int(1)), r3A57), 0x01));


               body.instructions = f3A58_parent_instructions;
               body.emit(f3A58);

               /* END IF */

               body.emit(assign(r39E0, r3A54, 0x01));

               body.emit(assign(r39E3, r3A55, 0x01));

               body.emit(assign(r39E4, r3A56, 0x01));


            body.instructions = f3A50_parent_instructions;
            body.emit(f3A50);

            /* END IF */


         body.instructions = f3A4E_parent_instructions;
         body.emit(f3A4E);

         /* END IF */

         /* IF CONDITION */
         ir_if *f3A8E = new(mem_ctx) ir_if(operand(r39DC).val);
         exec_list *const f3A8E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A8E->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3A90 = equal(r39F0, body.constant(int(0)));
            ir_if *f3A8F = new(mem_ctx) ir_if(operand(r3A90).val);
            exec_list *const f3A8F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A8F->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3A92 = bit_or(r39EC, swizzle_x(r34C2));
               ir_expression *const r3A93 = equal(r3A92, body.constant(0u));
               ir_if *f3A91 = new(mem_ctx) ir_if(operand(r3A93).val);
               exec_list *const f3A91_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A91->then_instructions;

                  ir_variable *const r3A94 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3A94);
                  body.emit(assign(r3A94, lshift(r39DE, body.constant(int(31))), 0x02));

                  body.emit(assign(r3A94, body.constant(0u), 0x01));

                  body.emit(assign(r39DD, r3A94, 0x03));

                  body.emit(assign(r39DC, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A91->else_instructions;

                  ir_variable *const r3A95 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r3A95, r39F0, 0x01));

                  ir_variable *const r3A96 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r3A96, r39EC, 0x01));

                  ir_variable *const r3A97 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r3A97, r39EB, 0x01));

                  ir_variable *const r3A98 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3A98);
                  /* IF CONDITION */
                  ir_expression *const r3A9A = equal(r39EC, body.constant(0u));
                  ir_if *f3A99 = new(mem_ctx) ir_if(operand(r3A9A).val);
                  exec_list *const f3A99_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A99->then_instructions;

                     ir_variable *const r3A9B = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3A9B, r39EB, 0x01));

                     ir_variable *const r3A9C = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3A9D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3A9D);
                     /* IF CONDITION */
                     ir_expression *const r3A9F = equal(swizzle_x(r34C2), body.constant(0u));
                     ir_if *f3A9E = new(mem_ctx) ir_if(operand(r3A9F).val);
                     exec_list *const f3A9E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A9E->then_instructions;

                        body.emit(assign(r3A9C, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3A9E->else_instructions;

                        body.emit(assign(r3A9D, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3AA1 = bit_and(swizzle_x(r34C2), body.constant(4294901760u));
                        ir_expression *const r3AA2 = equal(r3AA1, body.constant(0u));
                        ir_if *f3AA0 = new(mem_ctx) ir_if(operand(r3AA2).val);
                        exec_list *const f3AA0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AA0->then_instructions;

                           body.emit(assign(r3A9D, body.constant(int(16)), 0x01));

                           body.emit(assign(r3A9B, lshift(swizzle_x(r34C2), body.constant(int(16))), 0x01));


                        body.instructions = f3AA0_parent_instructions;
                        body.emit(f3AA0);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AA4 = bit_and(r3A9B, body.constant(4278190080u));
                        ir_expression *const r3AA5 = equal(r3AA4, body.constant(0u));
                        ir_if *f3AA3 = new(mem_ctx) ir_if(operand(r3AA5).val);
                        exec_list *const f3AA3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AA3->then_instructions;

                           body.emit(assign(r3A9D, add(r3A9D, body.constant(int(8))), 0x01));

                           body.emit(assign(r3A9B, lshift(r3A9B, body.constant(int(8))), 0x01));


                        body.instructions = f3AA3_parent_instructions;
                        body.emit(f3AA3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AA7 = bit_and(r3A9B, body.constant(4026531840u));
                        ir_expression *const r3AA8 = equal(r3AA7, body.constant(0u));
                        ir_if *f3AA6 = new(mem_ctx) ir_if(operand(r3AA8).val);
                        exec_list *const f3AA6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AA6->then_instructions;

                           body.emit(assign(r3A9D, add(r3A9D, body.constant(int(4))), 0x01));

                           body.emit(assign(r3A9B, lshift(r3A9B, body.constant(int(4))), 0x01));


                        body.instructions = f3AA6_parent_instructions;
                        body.emit(f3AA6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AAA = bit_and(r3A9B, body.constant(3221225472u));
                        ir_expression *const r3AAB = equal(r3AAA, body.constant(0u));
                        ir_if *f3AA9 = new(mem_ctx) ir_if(operand(r3AAB).val);
                        exec_list *const f3AA9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AA9->then_instructions;

                           body.emit(assign(r3A9D, add(r3A9D, body.constant(int(2))), 0x01));

                           body.emit(assign(r3A9B, lshift(r3A9B, body.constant(int(2))), 0x01));


                        body.instructions = f3AA9_parent_instructions;
                        body.emit(f3AA9);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AAD = bit_and(r3A9B, body.constant(2147483648u));
                        ir_expression *const r3AAE = equal(r3AAD, body.constant(0u));
                        ir_if *f3AAC = new(mem_ctx) ir_if(operand(r3AAE).val);
                        exec_list *const f3AAC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AAC->then_instructions;

                           body.emit(assign(r3A9D, add(r3A9D, body.constant(int(1))), 0x01));


                        body.instructions = f3AAC_parent_instructions;
                        body.emit(f3AAC);

                        /* END IF */

                        body.emit(assign(r3A9C, r3A9D, 0x01));


                     body.instructions = f3A9E_parent_instructions;
                     body.emit(f3A9E);

                     /* END IF */

                     body.emit(assign(r3A98, add(r3A9C, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3AB0 = less(r3A98, body.constant(int(0)));
                     ir_if *f3AAF = new(mem_ctx) ir_if(operand(r3AB0).val);
                     exec_list *const f3AAF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AAF->then_instructions;

                        ir_expression *const r3AB1 = neg(r3A98);
                        body.emit(assign(r3A96, rshift(swizzle_x(r34C2), r3AB1), 0x01));

                        ir_expression *const r3AB2 = bit_and(r3A98, body.constant(int(31)));
                        body.emit(assign(r3A97, lshift(swizzle_x(r34C2), r3AB2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3AAF->else_instructions;

                        body.emit(assign(r3A96, lshift(swizzle_x(r34C2), r3A98), 0x01));

                        body.emit(assign(r3A97, body.constant(0u), 0x01));


                     body.instructions = f3AAF_parent_instructions;
                     body.emit(f3AAF);

                     /* END IF */

                     body.emit(assign(r3A95, sub(body.constant(int(-31)), r3A98), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A99->else_instructions;

                     ir_variable *const r3AB3 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3AB3, r39EC, 0x01));

                     ir_variable *const r3AB4 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3AB5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3AB5);
                     /* IF CONDITION */
                     ir_expression *const r3AB7 = equal(r39EC, body.constant(0u));
                     ir_if *f3AB6 = new(mem_ctx) ir_if(operand(r3AB7).val);
                     exec_list *const f3AB6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AB6->then_instructions;

                        body.emit(assign(r3AB4, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3AB6->else_instructions;

                        body.emit(assign(r3AB5, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3AB9 = bit_and(r39EC, body.constant(4294901760u));
                        ir_expression *const r3ABA = equal(r3AB9, body.constant(0u));
                        ir_if *f3AB8 = new(mem_ctx) ir_if(operand(r3ABA).val);
                        exec_list *const f3AB8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AB8->then_instructions;

                           body.emit(assign(r3AB5, body.constant(int(16)), 0x01));

                           body.emit(assign(r3AB3, lshift(r39EC, body.constant(int(16))), 0x01));


                        body.instructions = f3AB8_parent_instructions;
                        body.emit(f3AB8);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3ABC = bit_and(r3AB3, body.constant(4278190080u));
                        ir_expression *const r3ABD = equal(r3ABC, body.constant(0u));
                        ir_if *f3ABB = new(mem_ctx) ir_if(operand(r3ABD).val);
                        exec_list *const f3ABB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3ABB->then_instructions;

                           body.emit(assign(r3AB5, add(r3AB5, body.constant(int(8))), 0x01));

                           body.emit(assign(r3AB3, lshift(r3AB3, body.constant(int(8))), 0x01));


                        body.instructions = f3ABB_parent_instructions;
                        body.emit(f3ABB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3ABF = bit_and(r3AB3, body.constant(4026531840u));
                        ir_expression *const r3AC0 = equal(r3ABF, body.constant(0u));
                        ir_if *f3ABE = new(mem_ctx) ir_if(operand(r3AC0).val);
                        exec_list *const f3ABE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3ABE->then_instructions;

                           body.emit(assign(r3AB5, add(r3AB5, body.constant(int(4))), 0x01));

                           body.emit(assign(r3AB3, lshift(r3AB3, body.constant(int(4))), 0x01));


                        body.instructions = f3ABE_parent_instructions;
                        body.emit(f3ABE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AC2 = bit_and(r3AB3, body.constant(3221225472u));
                        ir_expression *const r3AC3 = equal(r3AC2, body.constant(0u));
                        ir_if *f3AC1 = new(mem_ctx) ir_if(operand(r3AC3).val);
                        exec_list *const f3AC1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AC1->then_instructions;

                           body.emit(assign(r3AB5, add(r3AB5, body.constant(int(2))), 0x01));

                           body.emit(assign(r3AB3, lshift(r3AB3, body.constant(int(2))), 0x01));


                        body.instructions = f3AC1_parent_instructions;
                        body.emit(f3AC1);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AC5 = bit_and(r3AB3, body.constant(2147483648u));
                        ir_expression *const r3AC6 = equal(r3AC5, body.constant(0u));
                        ir_if *f3AC4 = new(mem_ctx) ir_if(operand(r3AC6).val);
                        exec_list *const f3AC4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AC4->then_instructions;

                           body.emit(assign(r3AB5, add(r3AB5, body.constant(int(1))), 0x01));


                        body.instructions = f3AC4_parent_instructions;
                        body.emit(f3AC4);

                        /* END IF */

                        body.emit(assign(r3AB4, r3AB5, 0x01));


                     body.instructions = f3AB6_parent_instructions;
                     body.emit(f3AB6);

                     /* END IF */

                     body.emit(assign(r3A98, add(r3AB4, body.constant(int(-11))), 0x01));

                     ir_variable *const r3AC7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3AC7, lshift(swizzle_x(r34C2), r3A98), 0x01));

                     ir_variable *const r3AC8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3ACA = equal(r3A98, body.constant(int(0)));
                     ir_if *f3AC9 = new(mem_ctx) ir_if(operand(r3ACA).val);
                     exec_list *const f3AC9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AC9->then_instructions;

                        body.emit(assign(r3AC8, r39EC, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3AC9->else_instructions;

                        ir_expression *const r3ACB = lshift(r39EC, r3A98);
                        ir_expression *const r3ACC = neg(r3A98);
                        ir_expression *const r3ACD = bit_and(r3ACC, body.constant(int(31)));
                        ir_expression *const r3ACE = rshift(swizzle_x(r34C2), r3ACD);
                        body.emit(assign(r3AC8, bit_or(r3ACB, r3ACE), 0x01));


                     body.instructions = f3AC9_parent_instructions;
                     body.emit(f3AC9);

                     /* END IF */

                     body.emit(assign(r3A96, r3AC8, 0x01));

                     body.emit(assign(r3A97, r3AC7, 0x01));

                     body.emit(assign(r3A95, sub(body.constant(int(1)), r3A98), 0x01));


                  body.instructions = f3A99_parent_instructions;
                  body.emit(f3A99);

                  /* END IF */

                  body.emit(assign(r39DF, r3A95, 0x01));

                  body.emit(assign(r39E1, r3A96, 0x01));

                  body.emit(assign(r39E2, r3A97, 0x01));


               body.instructions = f3A91_parent_instructions;
               body.emit(f3A91);

               /* END IF */


            body.instructions = f3A8F_parent_instructions;
            body.emit(f3A8F);

            /* END IF */

            /* IF CONDITION */
            ir_if *f3ACF = new(mem_ctx) ir_if(operand(r39DC).val);
            exec_list *const f3ACF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3ACF->then_instructions;

               ir_expression *const r3AD0 = add(r39E0, r39DF);
               body.emit(assign(r39E5, add(r3AD0, body.constant(int(-1024))), 0x01));

               body.emit(assign(r39E3, bit_or(r39E3, body.constant(1048576u)), 0x01));

               ir_variable *const r3AD1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3AD1, lshift(r39E2, body.constant(int(12))), 0x01));

               ir_variable *const r3AD2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r3AD3 = lshift(r39E1, body.constant(int(12)));
               ir_expression *const r3AD4 = rshift(r39E2, body.constant(int(20)));
               body.emit(assign(r3AD2, bit_or(r3AD3, r3AD4), 0x01));

               body.emit(assign(r39E1, r3AD2, 0x01));

               body.emit(assign(r39E2, r3AD1, 0x01));

               ir_variable *const r3AD5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3AD5);
               ir_variable *const r3AD6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3AD6);
               ir_variable *const r3AD7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3AD7);
               ir_variable *const r3AD8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AD8, bit_and(r39E4, body.constant(65535u)), 0x01));

               ir_variable *const r3AD9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AD9, rshift(r39E4, body.constant(int(16))), 0x01));

               ir_variable *const r3ADA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3ADA, bit_and(r3AD1, body.constant(65535u)), 0x01));

               ir_variable *const r3ADB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3ADB, rshift(r3AD1, body.constant(int(16))), 0x01));

               ir_variable *const r3ADC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3ADC, mul(r3AD9, r3ADA), 0x01));

               ir_expression *const r3ADD = mul(r3AD8, r3ADB);
               body.emit(assign(r3AD6, add(r3ADD, r3ADC), 0x01));

               ir_expression *const r3ADE = mul(r3AD9, r3ADB);
               ir_expression *const r3ADF = less(r3AD6, r3ADC);
               ir_expression *const r3AE0 = expr(ir_unop_b2i, r3ADF);
               ir_expression *const r3AE1 = expr(ir_unop_i2u, r3AE0);
               ir_expression *const r3AE2 = lshift(r3AE1, body.constant(int(16)));
               ir_expression *const r3AE3 = rshift(r3AD6, body.constant(int(16)));
               ir_expression *const r3AE4 = add(r3AE2, r3AE3);
               body.emit(assign(r3AD5, add(r3ADE, r3AE4), 0x01));

               body.emit(assign(r3AD6, lshift(r3AD6, body.constant(int(16))), 0x01));

               ir_expression *const r3AE5 = mul(r3AD8, r3ADA);
               body.emit(assign(r3AD7, add(r3AE5, r3AD6), 0x01));

               ir_expression *const r3AE6 = less(r3AD7, r3AD6);
               ir_expression *const r3AE7 = expr(ir_unop_b2i, r3AE6);
               ir_expression *const r3AE8 = expr(ir_unop_i2u, r3AE7);
               body.emit(assign(r3AD5, add(r3AD5, r3AE8), 0x01));

               ir_variable *const r3AE9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3AE9);
               ir_variable *const r3AEA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3AEA);
               ir_variable *const r3AEB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3AEB);
               ir_variable *const r3AEC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AEC, bit_and(r39E4, body.constant(65535u)), 0x01));

               ir_variable *const r3AED = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AED, rshift(r39E4, body.constant(int(16))), 0x01));

               ir_variable *const r3AEE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AEE, bit_and(r3AD2, body.constant(65535u)), 0x01));

               ir_variable *const r3AEF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AEF, rshift(r3AD2, body.constant(int(16))), 0x01));

               ir_variable *const r3AF0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AF0, mul(r3AED, r3AEE), 0x01));

               ir_expression *const r3AF1 = mul(r3AEC, r3AEF);
               body.emit(assign(r3AEA, add(r3AF1, r3AF0), 0x01));

               ir_expression *const r3AF2 = mul(r3AED, r3AEF);
               ir_expression *const r3AF3 = less(r3AEA, r3AF0);
               ir_expression *const r3AF4 = expr(ir_unop_b2i, r3AF3);
               ir_expression *const r3AF5 = expr(ir_unop_i2u, r3AF4);
               ir_expression *const r3AF6 = lshift(r3AF5, body.constant(int(16)));
               ir_expression *const r3AF7 = rshift(r3AEA, body.constant(int(16)));
               ir_expression *const r3AF8 = add(r3AF6, r3AF7);
               body.emit(assign(r3AE9, add(r3AF2, r3AF8), 0x01));

               body.emit(assign(r3AEA, lshift(r3AEA, body.constant(int(16))), 0x01));

               ir_expression *const r3AF9 = mul(r3AEC, r3AEE);
               body.emit(assign(r3AEB, add(r3AF9, r3AEA), 0x01));

               ir_expression *const r3AFA = less(r3AEB, r3AEA);
               ir_expression *const r3AFB = expr(ir_unop_b2i, r3AFA);
               ir_expression *const r3AFC = expr(ir_unop_i2u, r3AFB);
               body.emit(assign(r3AE9, add(r3AE9, r3AFC), 0x01));

               ir_variable *const r3AFD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AFD, add(r3AEB, r3AD5), 0x01));

               ir_variable *const r3AFE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3AFE);
               ir_variable *const r3AFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3AFF);
               ir_variable *const r3B00 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3B00);
               ir_variable *const r3B01 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B01, bit_and(r39E3, body.constant(65535u)), 0x01));

               ir_variable *const r3B02 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B02, rshift(r39E3, body.constant(int(16))), 0x01));

               ir_variable *const r3B03 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B03, bit_and(r3AD2, body.constant(65535u)), 0x01));

               ir_variable *const r3B04 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B04, rshift(r3AD2, body.constant(int(16))), 0x01));

               ir_variable *const r3B05 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B05, mul(r3B02, r3B03), 0x01));

               ir_expression *const r3B06 = mul(r3B01, r3B04);
               body.emit(assign(r3AFF, add(r3B06, r3B05), 0x01));

               ir_expression *const r3B07 = mul(r3B02, r3B04);
               ir_expression *const r3B08 = less(r3AFF, r3B05);
               ir_expression *const r3B09 = expr(ir_unop_b2i, r3B08);
               ir_expression *const r3B0A = expr(ir_unop_i2u, r3B09);
               ir_expression *const r3B0B = lshift(r3B0A, body.constant(int(16)));
               ir_expression *const r3B0C = rshift(r3AFF, body.constant(int(16)));
               ir_expression *const r3B0D = add(r3B0B, r3B0C);
               body.emit(assign(r3AFE, add(r3B07, r3B0D), 0x01));

               body.emit(assign(r3AFF, lshift(r3AFF, body.constant(int(16))), 0x01));

               ir_expression *const r3B0E = mul(r3B01, r3B03);
               body.emit(assign(r3B00, add(r3B0E, r3AFF), 0x01));

               ir_expression *const r3B0F = less(r3B00, r3AFF);
               ir_expression *const r3B10 = expr(ir_unop_b2i, r3B0F);
               ir_expression *const r3B11 = expr(ir_unop_i2u, r3B10);
               body.emit(assign(r3AFE, add(r3AFE, r3B11), 0x01));

               ir_variable *const r3B12 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r3B13 = less(r3AFD, r3AEB);
               ir_expression *const r3B14 = expr(ir_unop_b2i, r3B13);
               ir_expression *const r3B15 = expr(ir_unop_i2u, r3B14);
               ir_expression *const r3B16 = add(r3AE9, r3B15);
               body.emit(assign(r3B12, add(r3B00, r3B16), 0x01));

               ir_variable *const r3B17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3B17);
               ir_variable *const r3B18 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3B18);
               ir_variable *const r3B19 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3B19);
               ir_variable *const r3B1A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B1A, bit_and(r39E3, body.constant(65535u)), 0x01));

               ir_variable *const r3B1B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B1B, rshift(r39E3, body.constant(int(16))), 0x01));

               ir_variable *const r3B1C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B1C, bit_and(r3AD1, body.constant(65535u)), 0x01));

               ir_variable *const r3B1D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B1D, rshift(r3AD1, body.constant(int(16))), 0x01));

               ir_variable *const r3B1E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B1E, mul(r3B1B, r3B1C), 0x01));

               ir_expression *const r3B1F = mul(r3B1A, r3B1D);
               body.emit(assign(r3B18, add(r3B1F, r3B1E), 0x01));

               ir_expression *const r3B20 = mul(r3B1B, r3B1D);
               ir_expression *const r3B21 = less(r3B18, r3B1E);
               ir_expression *const r3B22 = expr(ir_unop_b2i, r3B21);
               ir_expression *const r3B23 = expr(ir_unop_i2u, r3B22);
               ir_expression *const r3B24 = lshift(r3B23, body.constant(int(16)));
               ir_expression *const r3B25 = rshift(r3B18, body.constant(int(16)));
               ir_expression *const r3B26 = add(r3B24, r3B25);
               body.emit(assign(r3B17, add(r3B20, r3B26), 0x01));

               body.emit(assign(r3B18, lshift(r3B18, body.constant(int(16))), 0x01));

               ir_expression *const r3B27 = mul(r3B1A, r3B1C);
               body.emit(assign(r3B19, add(r3B27, r3B18), 0x01));

               ir_expression *const r3B28 = less(r3B19, r3B18);
               ir_expression *const r3B29 = expr(ir_unop_b2i, r3B28);
               ir_expression *const r3B2A = expr(ir_unop_i2u, r3B29);
               body.emit(assign(r3B17, add(r3B17, r3B2A), 0x01));

               ir_variable *const r3B2B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B2B, add(r3B19, r3AFD), 0x01));

               ir_variable *const r3B2C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r3B2D = less(r3B2B, r3B19);
               ir_expression *const r3B2E = expr(ir_unop_b2i, r3B2D);
               ir_expression *const r3B2F = expr(ir_unop_i2u, r3B2E);
               ir_expression *const r3B30 = add(r3B17, r3B2F);
               body.emit(assign(r3B2C, add(r3B12, r3B30), 0x01));

               ir_variable *const r3B31 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3B32 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B32, add(r3B2C, r39E4), 0x01));

               ir_expression *const r3B33 = less(r3B12, r3B00);
               ir_expression *const r3B34 = expr(ir_unop_b2i, r3B33);
               ir_expression *const r3B35 = expr(ir_unop_i2u, r3B34);
               ir_expression *const r3B36 = add(r3AFE, r3B35);
               ir_expression *const r3B37 = less(r3B2C, r3B12);
               ir_expression *const r3B38 = expr(ir_unop_b2i, r3B37);
               ir_expression *const r3B39 = expr(ir_unop_i2u, r3B38);
               ir_expression *const r3B3A = add(r3B36, r3B39);
               ir_expression *const r3B3B = add(r3B3A, r39E3);
               ir_expression *const r3B3C = less(r3B32, r3B2C);
               ir_expression *const r3B3D = expr(ir_unop_b2i, r3B3C);
               ir_expression *const r3B3E = expr(ir_unop_i2u, r3B3D);
               body.emit(assign(r3B31, add(r3B3B, r3B3E), 0x01));

               body.emit(assign(r39E8, r3B31, 0x01));

               body.emit(assign(r39E7, r3B32, 0x01));

               ir_expression *const r3B3F = nequal(r3AD7, body.constant(0u));
               ir_expression *const r3B40 = expr(ir_unop_b2i, r3B3F);
               ir_expression *const r3B41 = expr(ir_unop_i2u, r3B40);
               body.emit(assign(r39E6, bit_or(r3B2B, r3B41), 0x01));

               /* IF CONDITION */
               ir_expression *const r3B43 = lequal(body.constant(2097152u), r3B31);
               ir_if *f3B42 = new(mem_ctx) ir_if(operand(r3B43).val);
               exec_list *const f3B42_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3B42->then_instructions;

                  ir_variable *const r3B44 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3B44);
                  body.emit(assign(r3B44, lshift(r3B32, body.constant(int(31))), 0x01));

                  ir_expression *const r3B45 = nequal(r39E6, body.constant(0u));
                  ir_expression *const r3B46 = expr(ir_unop_b2i, r3B45);
                  ir_expression *const r3B47 = expr(ir_unop_i2u, r3B46);
                  body.emit(assign(r3B44, bit_or(r3B44, r3B47), 0x01));

                  body.emit(assign(r39E8, rshift(r3B31, body.constant(int(1))), 0x01));

                  ir_expression *const r3B48 = lshift(r3B31, body.constant(int(31)));
                  ir_expression *const r3B49 = rshift(r3B32, body.constant(int(1)));
                  body.emit(assign(r39E7, bit_or(r3B48, r3B49), 0x01));

                  body.emit(assign(r39E6, r3B44, 0x01));

                  body.emit(assign(r39E5, add(r39E5, body.constant(int(1))), 0x01));


               body.instructions = f3B42_parent_instructions;
               body.emit(f3B42);

               /* END IF */

               ir_variable *const r3B4A = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3B4A, r39E5, 0x01));

               ir_variable *const r3B4B = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3B4B, r39E8, 0x01));

               ir_variable *const r3B4C = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3B4C, r39E7, 0x01));

               ir_variable *const r3B4D = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3B4D, r39E6, 0x01));

               ir_variable *const r3B4E = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3B4E, body.constant(true), 0x01));

               ir_variable *const r3B4F = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3B50 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3B50);
               ir_expression *const r3B51 = expr(ir_unop_u2i, r39E6);
               body.emit(assign(r3B50, less(r3B51, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3B53 = lequal(body.constant(int(2045)), r39E5);
               ir_if *f3B52 = new(mem_ctx) ir_if(operand(r3B53).val);
               exec_list *const f3B52_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3B52->then_instructions;

                  ir_variable *const r3B54 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3B56 = less(body.constant(int(2045)), r39E5);
                  ir_if *f3B55 = new(mem_ctx) ir_if(operand(r3B56).val);
                  exec_list *const f3B55_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B55->then_instructions;

                     body.emit(assign(r3B54, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B55->else_instructions;

                     ir_variable *const r3B57 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3B59 = equal(r39E5, body.constant(int(2045)));
                     ir_if *f3B58 = new(mem_ctx) ir_if(operand(r3B59).val);
                     exec_list *const f3B58_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B58->then_instructions;

                        ir_expression *const r3B5A = equal(body.constant(2097151u), r39E8);
                        ir_expression *const r3B5B = equal(body.constant(4294967295u), r39E7);
                        body.emit(assign(r3B57, logic_and(r3B5A, r3B5B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3B58->else_instructions;

                        body.emit(assign(r3B57, body.constant(false), 0x01));


                     body.instructions = f3B58_parent_instructions;
                     body.emit(f3B58);

                     /* END IF */

                     body.emit(assign(r3B54, logic_and(r3B57, r3B50), 0x01));


                  body.instructions = f3B55_parent_instructions;
                  body.emit(f3B55);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3B5C = new(mem_ctx) ir_if(operand(r3B54).val);
                  exec_list *const f3B5C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B5C->then_instructions;

                     ir_variable *const r3B5D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3B5D);
                     ir_expression *const r3B5E = lshift(r39DE, body.constant(int(31)));
                     body.emit(assign(r3B5D, add(r3B5E, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3B5D, body.constant(0u), 0x01));

                     body.emit(assign(r3B4F, r3B5D, 0x03));

                     body.emit(assign(r3B4E, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B5C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3B60 = less(r39E5, body.constant(int(0)));
                     ir_if *f3B5F = new(mem_ctx) ir_if(operand(r3B60).val);
                     exec_list *const f3B5F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B5F->then_instructions;

                        ir_variable *const r3B61 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3B61, r39E6, 0x01));

                        ir_variable *const r3B62 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3B62, neg(r39E5), 0x01));

                        ir_variable *const r3B63 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3B63);
                        ir_variable *const r3B64 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3B64);
                        ir_variable *const r3B65 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3B65);
                        ir_variable *const r3B66 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3B67 = neg(r3B62);
                        body.emit(assign(r3B66, bit_and(r3B67, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3B69 = equal(r3B62, body.constant(int(0)));
                        ir_if *f3B68 = new(mem_ctx) ir_if(operand(r3B69).val);
                        exec_list *const f3B68_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B68->then_instructions;

                           body.emit(assign(r3B63, r39E6, 0x01));

                           body.emit(assign(r3B64, r39E7, 0x01));

                           body.emit(assign(r3B65, r39E8, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3B68->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3B6B = less(r3B62, body.constant(int(32)));
                           ir_if *f3B6A = new(mem_ctx) ir_if(operand(r3B6B).val);
                           exec_list *const f3B6A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3B6A->then_instructions;

                              body.emit(assign(r3B63, lshift(r39E7, r3B66), 0x01));

                              ir_expression *const r3B6C = lshift(r39E8, r3B66);
                              ir_expression *const r3B6D = rshift(r39E7, r3B62);
                              body.emit(assign(r3B64, bit_or(r3B6C, r3B6D), 0x01));

                              body.emit(assign(r3B65, rshift(r39E8, r3B62), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3B6A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3B6F = equal(r3B62, body.constant(int(32)));
                              ir_if *f3B6E = new(mem_ctx) ir_if(operand(r3B6F).val);
                              exec_list *const f3B6E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3B6E->then_instructions;

                                 body.emit(assign(r3B63, r39E7, 0x01));

                                 body.emit(assign(r3B64, r39E8, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3B6E->else_instructions;

                                 body.emit(assign(r3B61, bit_or(r39E6, r39E7), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3B71 = less(r3B62, body.constant(int(64)));
                                 ir_if *f3B70 = new(mem_ctx) ir_if(operand(r3B71).val);
                                 exec_list *const f3B70_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3B70->then_instructions;

                                    body.emit(assign(r3B63, lshift(r39E8, r3B66), 0x01));

                                    ir_expression *const r3B72 = bit_and(r3B62, body.constant(int(31)));
                                    body.emit(assign(r3B64, rshift(r39E8, r3B72), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3B70->else_instructions;

                                    ir_variable *const r3B73 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3B75 = equal(r3B62, body.constant(int(64)));
                                    ir_if *f3B74 = new(mem_ctx) ir_if(operand(r3B75).val);
                                    exec_list *const f3B74_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3B74->then_instructions;

                                       body.emit(assign(r3B73, r39E8, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3B74->else_instructions;

                                       ir_expression *const r3B76 = nequal(r39E8, body.constant(0u));
                                       ir_expression *const r3B77 = expr(ir_unop_b2i, r3B76);
                                       body.emit(assign(r3B73, expr(ir_unop_i2u, r3B77), 0x01));


                                    body.instructions = f3B74_parent_instructions;
                                    body.emit(f3B74);

                                    /* END IF */

                                    body.emit(assign(r3B63, r3B73, 0x01));

                                    body.emit(assign(r3B64, body.constant(0u), 0x01));


                                 body.instructions = f3B70_parent_instructions;
                                 body.emit(f3B70);

                                 /* END IF */


                              body.instructions = f3B6E_parent_instructions;
                              body.emit(f3B6E);

                              /* END IF */

                              body.emit(assign(r3B65, body.constant(0u), 0x01));


                           body.instructions = f3B6A_parent_instructions;
                           body.emit(f3B6A);

                           /* END IF */

                           ir_expression *const r3B78 = nequal(r3B61, body.constant(0u));
                           ir_expression *const r3B79 = expr(ir_unop_b2i, r3B78);
                           ir_expression *const r3B7A = expr(ir_unop_i2u, r3B79);
                           body.emit(assign(r3B63, bit_or(r3B63, r3B7A), 0x01));


                        body.instructions = f3B68_parent_instructions;
                        body.emit(f3B68);

                        /* END IF */

                        body.emit(assign(r3B4B, r3B65, 0x01));

                        body.emit(assign(r3B4C, r3B64, 0x01));

                        body.emit(assign(r3B4D, r3B63, 0x01));

                        body.emit(assign(r3B4A, body.constant(int(0)), 0x01));

                        body.emit(assign(r3B50, less(r3B63, body.constant(0u)), 0x01));


                     body.instructions = f3B5F_parent_instructions;
                     body.emit(f3B5F);

                     /* END IF */


                  body.instructions = f3B5C_parent_instructions;
                  body.emit(f3B5C);

                  /* END IF */


               body.instructions = f3B52_parent_instructions;
               body.emit(f3B52);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3B7B = new(mem_ctx) ir_if(operand(r3B4E).val);
               exec_list *const f3B7B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3B7B->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3B7C = new(mem_ctx) ir_if(operand(r3B50).val);
                  exec_list *const f3B7C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B7C->then_instructions;

                     ir_variable *const r3B7D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3B7D, add(r3B4C, body.constant(1u)), 0x01));

                     ir_expression *const r3B7E = less(r3B7D, r3B4C);
                     ir_expression *const r3B7F = expr(ir_unop_b2i, r3B7E);
                     ir_expression *const r3B80 = expr(ir_unop_i2u, r3B7F);
                     body.emit(assign(r3B4B, add(r3B4B, r3B80), 0x01));

                     ir_expression *const r3B81 = equal(r3B4D, body.constant(0u));
                     ir_expression *const r3B82 = expr(ir_unop_b2i, r3B81);
                     ir_expression *const r3B83 = expr(ir_unop_i2u, r3B82);
                     ir_expression *const r3B84 = add(r3B4D, r3B83);
                     ir_expression *const r3B85 = bit_and(r3B84, body.constant(1u));
                     ir_expression *const r3B86 = expr(ir_unop_bit_not, r3B85);
                     body.emit(assign(r3B4C, bit_and(r3B7D, r3B86), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B7C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3B88 = bit_or(r3B4B, r3B4C);
                     ir_expression *const r3B89 = equal(r3B88, body.constant(0u));
                     ir_if *f3B87 = new(mem_ctx) ir_if(operand(r3B89).val);
                     exec_list *const f3B87_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B87->then_instructions;

                        body.emit(assign(r3B4A, body.constant(int(0)), 0x01));


                     body.instructions = f3B87_parent_instructions;
                     body.emit(f3B87);

                     /* END IF */


                  body.instructions = f3B7C_parent_instructions;
                  body.emit(f3B7C);

                  /* END IF */

                  ir_variable *const r3B8A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3B8A);
                  ir_expression *const r3B8B = lshift(r39DE, body.constant(int(31)));
                  ir_expression *const r3B8C = expr(ir_unop_i2u, r3B4A);
                  ir_expression *const r3B8D = lshift(r3B8C, body.constant(int(20)));
                  ir_expression *const r3B8E = add(r3B8B, r3B8D);
                  body.emit(assign(r3B8A, add(r3B8E, r3B4B), 0x02));

                  body.emit(assign(r3B8A, r3B4C, 0x01));

                  body.emit(assign(r3B4F, r3B8A, 0x03));

                  body.emit(assign(r3B4E, body.constant(false), 0x01));


               body.instructions = f3B7B_parent_instructions;
               body.emit(f3B7B);

               /* END IF */

               body.emit(assign(r39DD, r3B4F, 0x03));

               body.emit(assign(r39DC, body.constant(false), 0x01));


            body.instructions = f3ACF_parent_instructions;
            body.emit(f3ACF);

            /* END IF */


         body.instructions = f3A8E_parent_instructions;
         body.emit(f3A8E);

         /* END IF */


      body.instructions = f3A24_parent_instructions;
      body.emit(f3A24);

      /* END IF */


   body.instructions = f39F5_parent_instructions;
   body.emit(f39F5);

   /* END IF */

   ir_variable *const r3B8F = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3B90 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r3B90, rshift(swizzle_y(r321D), body.constant(int(31))), 0x01));

   ir_variable *const r3B91 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r3B91, rshift(swizzle_y(r39DD), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r3B93 = equal(r3B90, r3B91);
   ir_if *f3B92 = new(mem_ctx) ir_if(operand(r3B93).val);
   exec_list *const f3B92_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3B92->then_instructions;

      ir_variable *const r3B94 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r3B94, r3B90, 0x01));

      ir_variable *const r3B95 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3B96 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r3B96);
      ir_variable *const r3B97 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r3B97);
      ir_variable *const r3B98 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r3B98);
      ir_variable *const r3B99 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r3B99);
      ir_variable *const r3B9A = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r3B9A);
      ir_variable *const r3B9B = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r3B9B);
      ir_variable *const r3B9C = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r3B9C);
      ir_variable *const r3B9D = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r3B9D);
      ir_variable *const r3B9E = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3B9F = rshift(swizzle_y(r321D), body.constant(int(20)));
      ir_expression *const r3BA0 = bit_and(r3B9F, body.constant(2047u));
      body.emit(assign(r3B9E, expr(ir_unop_u2i, r3BA0), 0x01));

      body.emit(assign(r3B98, r3B9E, 0x01));

      ir_variable *const r3BA1 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3BA2 = rshift(swizzle_y(r39DD), body.constant(int(20)));
      ir_expression *const r3BA3 = bit_and(r3BA2, body.constant(2047u));
      body.emit(assign(r3BA1, expr(ir_unop_u2i, r3BA3), 0x01));

      body.emit(assign(r3B97, r3BA1, 0x01));

      body.emit(assign(r3B96, sub(r3B9E, r3BA1), 0x01));

      ir_variable *const r3BA4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r3BA4, lshift(swizzle_x(r321D), body.constant(int(10))), 0x01));

      ir_variable *const r3BA5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r3BA6 = bit_and(swizzle_y(r321D), body.constant(1048575u));
      ir_expression *const r3BA7 = lshift(r3BA6, body.constant(int(10)));
      ir_expression *const r3BA8 = rshift(swizzle_x(r321D), body.constant(int(22)));
      body.emit(assign(r3BA5, bit_or(r3BA7, r3BA8), 0x01));

      body.emit(assign(r3B9B, r3BA5, 0x01));

      body.emit(assign(r3B9C, r3BA4, 0x01));

      ir_variable *const r3BA9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r3BA9, lshift(swizzle_x(r39DD), body.constant(int(10))), 0x01));

      ir_variable *const r3BAA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r3BAB = bit_and(swizzle_y(r39DD), body.constant(1048575u));
      ir_expression *const r3BAC = lshift(r3BAB, body.constant(int(10)));
      ir_expression *const r3BAD = rshift(swizzle_x(r39DD), body.constant(int(22)));
      body.emit(assign(r3BAA, bit_or(r3BAC, r3BAD), 0x01));

      body.emit(assign(r3B99, r3BAA, 0x01));

      body.emit(assign(r3B9A, r3BA9, 0x01));

      /* IF CONDITION */
      ir_expression *const r3BAF = less(body.constant(int(0)), r3B96);
      ir_if *f3BAE = new(mem_ctx) ir_if(operand(r3BAF).val);
      exec_list *const f3BAE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3BAE->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3BB1 = equal(r3B9E, body.constant(int(2047)));
         ir_if *f3BB0 = new(mem_ctx) ir_if(operand(r3BB1).val);
         exec_list *const f3BB0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3BB0->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3BB3 = bit_or(r3BA5, r3BA4);
            ir_expression *const r3BB4 = nequal(r3BB3, body.constant(0u));
            ir_if *f3BB2 = new(mem_ctx) ir_if(operand(r3BB4).val);
            exec_list *const f3BB2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3BB2->then_instructions;

               ir_variable *const r3BB5 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r3BB5, swizzle_x(r321D), 0x01));

               ir_variable *const r3BB6 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r3BB6, swizzle_x(r39DD), 0x01));

               ir_variable *const r3BB7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3BB8 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3BB9 = rshift(swizzle_y(r321D), body.constant(int(19)));
               ir_expression *const r3BBA = bit_and(r3BB9, body.constant(4095u));
               ir_expression *const r3BBB = equal(r3BBA, body.constant(4094u));
               ir_expression *const r3BBC = nequal(swizzle_x(r321D), body.constant(0u));
               ir_expression *const r3BBD = bit_and(swizzle_y(r321D), body.constant(524287u));
               ir_expression *const r3BBE = nequal(r3BBD, body.constant(0u));
               ir_expression *const r3BBF = logic_or(r3BBC, r3BBE);
               body.emit(assign(r3BB8, logic_and(r3BBB, r3BBF), 0x01));

               ir_variable *const r3BC0 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r3BC1 = lshift(swizzle_y(r39DD), body.constant(int(1)));
               ir_expression *const r3BC2 = lequal(body.constant(4292870144u), r3BC1);
               ir_expression *const r3BC3 = nequal(swizzle_x(r39DD), body.constant(0u));
               ir_expression *const r3BC4 = bit_and(swizzle_y(r39DD), body.constant(1048575u));
               ir_expression *const r3BC5 = nequal(r3BC4, body.constant(0u));
               ir_expression *const r3BC6 = logic_or(r3BC3, r3BC5);
               body.emit(assign(r3BC0, logic_and(r3BC2, r3BC6), 0x01));

               body.emit(assign(r3BB5, bit_or(swizzle_y(r321D), body.constant(524288u)), 0x02));

               body.emit(assign(r3BB6, bit_or(swizzle_y(r39DD), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r3BC8 = lshift(swizzle_y(r321D), body.constant(int(1)));
               ir_expression *const r3BC9 = lequal(body.constant(4292870144u), r3BC8);
               ir_expression *const r3BCA = nequal(swizzle_x(r321D), body.constant(0u));
               ir_expression *const r3BCB = bit_and(swizzle_y(r321D), body.constant(1048575u));
               ir_expression *const r3BCC = nequal(r3BCB, body.constant(0u));
               ir_expression *const r3BCD = logic_or(r3BCA, r3BCC);
               ir_expression *const r3BCE = logic_and(r3BC9, r3BCD);
               ir_if *f3BC7 = new(mem_ctx) ir_if(operand(r3BCE).val);
               exec_list *const f3BC7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3BC7->then_instructions;

                  ir_variable *const r3BCF = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3BD1 = logic_and(r3BB8, r3BC0);
                  ir_if *f3BD0 = new(mem_ctx) ir_if(operand(r3BD1).val);
                  exec_list *const f3BD0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3BD0->then_instructions;

                     body.emit(assign(r3BCF, r3BB6, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3BD0->else_instructions;

                     body.emit(assign(r3BCF, r3BB5, 0x03));


                  body.instructions = f3BD0_parent_instructions;
                  body.emit(f3BD0);

                  /* END IF */

                  body.emit(assign(r3BB7, r3BCF, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3BC7->else_instructions;

                  body.emit(assign(r3BB7, r3BB6, 0x03));


               body.instructions = f3BC7_parent_instructions;
               body.emit(f3BC7);

               /* END IF */

               body.emit(assign(r3B95, r3BB7, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3BB2->else_instructions;

               body.emit(assign(r3B95, r321D, 0x03));


            body.instructions = f3BB2_parent_instructions;
            body.emit(f3BB2);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3BB0->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3BD3 = equal(r3BA1, body.constant(int(0)));
            ir_if *f3BD2 = new(mem_ctx) ir_if(operand(r3BD3).val);
            exec_list *const f3BD2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3BD2->then_instructions;

               body.emit(assign(r3B96, add(r3B96, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3BD2->else_instructions;

               body.emit(assign(r3B99, bit_or(r3BAA, body.constant(1073741824u)), 0x01));


            body.instructions = f3BD2_parent_instructions;
            body.emit(f3BD2);

            /* END IF */

            ir_variable *const r3BD4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r3BD4);
            ir_variable *const r3BD5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r3BD5);
            ir_variable *const r3BD6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r3BD7 = neg(r3B96);
            body.emit(assign(r3BD6, bit_and(r3BD7, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3BD9 = equal(r3B96, body.constant(int(0)));
            ir_if *f3BD8 = new(mem_ctx) ir_if(operand(r3BD9).val);
            exec_list *const f3BD8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3BD8->then_instructions;

               body.emit(assign(r3BD4, r3BA9, 0x01));

               body.emit(assign(r3BD5, r3B99, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3BD8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3BDB = less(r3B96, body.constant(int(32)));
               ir_if *f3BDA = new(mem_ctx) ir_if(operand(r3BDB).val);
               exec_list *const f3BDA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3BDA->then_instructions;

                  ir_expression *const r3BDC = lshift(r3B99, r3BD6);
                  ir_expression *const r3BDD = rshift(r3BA9, r3B96);
                  ir_expression *const r3BDE = bit_or(r3BDC, r3BDD);
                  ir_expression *const r3BDF = lshift(r3BA9, r3BD6);
                  ir_expression *const r3BE0 = nequal(r3BDF, body.constant(0u));
                  ir_expression *const r3BE1 = expr(ir_unop_b2i, r3BE0);
                  ir_expression *const r3BE2 = expr(ir_unop_i2u, r3BE1);
                  body.emit(assign(r3BD4, bit_or(r3BDE, r3BE2), 0x01));

                  body.emit(assign(r3BD5, rshift(r3B99, r3B96), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3BDA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3BE4 = equal(r3B96, body.constant(int(32)));
                  ir_if *f3BE3 = new(mem_ctx) ir_if(operand(r3BE4).val);
                  exec_list *const f3BE3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3BE3->then_instructions;

                     ir_expression *const r3BE5 = nequal(r3BA9, body.constant(0u));
                     ir_expression *const r3BE6 = expr(ir_unop_b2i, r3BE5);
                     ir_expression *const r3BE7 = expr(ir_unop_i2u, r3BE6);
                     body.emit(assign(r3BD4, bit_or(r3B99, r3BE7), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3BE3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3BE9 = less(r3B96, body.constant(int(64)));
                     ir_if *f3BE8 = new(mem_ctx) ir_if(operand(r3BE9).val);
                     exec_list *const f3BE8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3BE8->then_instructions;

                        ir_expression *const r3BEA = bit_and(r3B96, body.constant(int(31)));
                        ir_expression *const r3BEB = rshift(r3B99, r3BEA);
                        ir_expression *const r3BEC = lshift(r3B99, r3BD6);
                        ir_expression *const r3BED = bit_or(r3BEC, r3BA9);
                        ir_expression *const r3BEE = nequal(r3BED, body.constant(0u));
                        ir_expression *const r3BEF = expr(ir_unop_b2i, r3BEE);
                        ir_expression *const r3BF0 = expr(ir_unop_i2u, r3BEF);
                        body.emit(assign(r3BD4, bit_or(r3BEB, r3BF0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3BE8->else_instructions;

                        ir_expression *const r3BF1 = bit_or(r3B99, r3BA9);
                        ir_expression *const r3BF2 = nequal(r3BF1, body.constant(0u));
                        ir_expression *const r3BF3 = expr(ir_unop_b2i, r3BF2);
                        body.emit(assign(r3BD4, expr(ir_unop_i2u, r3BF3), 0x01));


                     body.instructions = f3BE8_parent_instructions;
                     body.emit(f3BE8);

                     /* END IF */


                  body.instructions = f3BE3_parent_instructions;
                  body.emit(f3BE3);

                  /* END IF */

                  body.emit(assign(r3BD5, body.constant(0u), 0x01));


               body.instructions = f3BDA_parent_instructions;
               body.emit(f3BDA);

               /* END IF */


            body.instructions = f3BD8_parent_instructions;
            body.emit(f3BD8);

            /* END IF */

            body.emit(assign(r3B99, r3BD5, 0x01));

            body.emit(assign(r3B9A, r3BD4, 0x01));

            body.emit(assign(r3B9B, bit_or(r3BA5, body.constant(1073741824u)), 0x01));

            ir_variable *const r3BF4 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r3BF5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r3BF5, sub(r3BA4, r3BD4), 0x01));

            ir_expression *const r3BF6 = sub(r3B9B, r3BD5);
            ir_expression *const r3BF7 = less(r3BA4, r3BD4);
            ir_expression *const r3BF8 = expr(ir_unop_b2i, r3BF7);
            ir_expression *const r3BF9 = expr(ir_unop_i2u, r3BF8);
            body.emit(assign(r3BF4, sub(r3BF6, r3BF9), 0x01));

            body.emit(assign(r3B9D, add(r3B9E, body.constant(int(-1))), 0x01));

            ir_variable *const r3BFA = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r3BFA, add(r3B9D, body.constant(int(-10))), 0x01));

            ir_variable *const r3BFB = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r3BFB, r3BF4, 0x01));

            ir_variable *const r3BFC = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r3BFC, r3BF5, 0x01));

            ir_variable *const r3BFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r3BFD);
            ir_variable *const r3BFE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r3BFE);
            /* IF CONDITION */
            ir_expression *const r3C00 = equal(r3BF4, body.constant(0u));
            ir_if *f3BFF = new(mem_ctx) ir_if(operand(r3C00).val);
            exec_list *const f3BFF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3BFF->then_instructions;

               body.emit(assign(r3BFB, r3BF5, 0x01));

               body.emit(assign(r3BFC, body.constant(0u), 0x01));

               body.emit(assign(r3BFA, add(r3BFA, body.constant(int(-32))), 0x01));


            body.instructions = f3BFF_parent_instructions;
            body.emit(f3BFF);

            /* END IF */

            ir_variable *const r3C01 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r3C01, r3BFB, 0x01));

            ir_variable *const r3C02 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r3C03 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r3C03);
            /* IF CONDITION */
            ir_expression *const r3C05 = equal(r3BFB, body.constant(0u));
            ir_if *f3C04 = new(mem_ctx) ir_if(operand(r3C05).val);
            exec_list *const f3C04_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C04->then_instructions;

               body.emit(assign(r3C02, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3C04->else_instructions;

               body.emit(assign(r3C03, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r3C07 = bit_and(r3BFB, body.constant(4294901760u));
               ir_expression *const r3C08 = equal(r3C07, body.constant(0u));
               ir_if *f3C06 = new(mem_ctx) ir_if(operand(r3C08).val);
               exec_list *const f3C06_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C06->then_instructions;

                  body.emit(assign(r3C03, body.constant(int(16)), 0x01));

                  body.emit(assign(r3C01, lshift(r3BFB, body.constant(int(16))), 0x01));


               body.instructions = f3C06_parent_instructions;
               body.emit(f3C06);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3C0A = bit_and(r3C01, body.constant(4278190080u));
               ir_expression *const r3C0B = equal(r3C0A, body.constant(0u));
               ir_if *f3C09 = new(mem_ctx) ir_if(operand(r3C0B).val);
               exec_list *const f3C09_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C09->then_instructions;

                  body.emit(assign(r3C03, add(r3C03, body.constant(int(8))), 0x01));

                  body.emit(assign(r3C01, lshift(r3C01, body.constant(int(8))), 0x01));


               body.instructions = f3C09_parent_instructions;
               body.emit(f3C09);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3C0D = bit_and(r3C01, body.constant(4026531840u));
               ir_expression *const r3C0E = equal(r3C0D, body.constant(0u));
               ir_if *f3C0C = new(mem_ctx) ir_if(operand(r3C0E).val);
               exec_list *const f3C0C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C0C->then_instructions;

                  body.emit(assign(r3C03, add(r3C03, body.constant(int(4))), 0x01));

                  body.emit(assign(r3C01, lshift(r3C01, body.constant(int(4))), 0x01));


               body.instructions = f3C0C_parent_instructions;
               body.emit(f3C0C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3C10 = bit_and(r3C01, body.constant(3221225472u));
               ir_expression *const r3C11 = equal(r3C10, body.constant(0u));
               ir_if *f3C0F = new(mem_ctx) ir_if(operand(r3C11).val);
               exec_list *const f3C0F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C0F->then_instructions;

                  body.emit(assign(r3C03, add(r3C03, body.constant(int(2))), 0x01));

                  body.emit(assign(r3C01, lshift(r3C01, body.constant(int(2))), 0x01));


               body.instructions = f3C0F_parent_instructions;
               body.emit(f3C0F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3C13 = bit_and(r3C01, body.constant(2147483648u));
               ir_expression *const r3C14 = equal(r3C13, body.constant(0u));
               ir_if *f3C12 = new(mem_ctx) ir_if(operand(r3C14).val);
               exec_list *const f3C12_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C12->then_instructions;

                  body.emit(assign(r3C03, add(r3C03, body.constant(int(1))), 0x01));


               body.instructions = f3C12_parent_instructions;
               body.emit(f3C12);

               /* END IF */

               body.emit(assign(r3C02, r3C03, 0x01));


            body.instructions = f3C04_parent_instructions;
            body.emit(f3C04);

            /* END IF */

            body.emit(assign(r3BFE, add(r3C02, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3C16 = lequal(body.constant(int(0)), r3BFE);
            ir_if *f3C15 = new(mem_ctx) ir_if(operand(r3C16).val);
            exec_list *const f3C15_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C15->then_instructions;

               body.emit(assign(r3BFD, body.constant(0u), 0x01));

               ir_variable *const r3C17 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3C17, lshift(r3BFC, r3BFE), 0x01));

               ir_variable *const r3C18 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r3C1A = equal(r3BFE, body.constant(int(0)));
               ir_if *f3C19 = new(mem_ctx) ir_if(operand(r3C1A).val);
               exec_list *const f3C19_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C19->then_instructions;

                  body.emit(assign(r3C18, r3BFB, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C19->else_instructions;

                  ir_expression *const r3C1B = lshift(r3BFB, r3BFE);
                  ir_expression *const r3C1C = neg(r3BFE);
                  ir_expression *const r3C1D = bit_and(r3C1C, body.constant(int(31)));
                  ir_expression *const r3C1E = rshift(r3BFC, r3C1D);
                  body.emit(assign(r3C18, bit_or(r3C1B, r3C1E), 0x01));


               body.instructions = f3C19_parent_instructions;
               body.emit(f3C19);

               /* END IF */

               body.emit(assign(r3BFB, r3C18, 0x01));

               body.emit(assign(r3BFC, r3C17, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3C15->else_instructions;

               ir_variable *const r3C1F = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r3C1F, body.constant(0u), 0x01));

               ir_variable *const r3C20 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r3C20, neg(r3BFE), 0x01));

               ir_variable *const r3C21 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r3C21);
               ir_variable *const r3C22 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3C22);
               ir_variable *const r3C23 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3C23);
               ir_variable *const r3C24 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3C25 = neg(r3C20);
               body.emit(assign(r3C24, bit_and(r3C25, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3C27 = equal(r3C20, body.constant(int(0)));
               ir_if *f3C26 = new(mem_ctx) ir_if(operand(r3C27).val);
               exec_list *const f3C26_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C26->then_instructions;

                  body.emit(assign(r3C21, r3C1F, 0x01));

                  body.emit(assign(r3C22, r3BFC, 0x01));

                  body.emit(assign(r3C23, r3BFB, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C26->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3C29 = less(r3C20, body.constant(int(32)));
                  ir_if *f3C28 = new(mem_ctx) ir_if(operand(r3C29).val);
                  exec_list *const f3C28_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C28->then_instructions;

                     body.emit(assign(r3C21, lshift(r3BFC, r3C24), 0x01));

                     ir_expression *const r3C2A = lshift(r3BFB, r3C24);
                     ir_expression *const r3C2B = rshift(r3BFC, r3C20);
                     body.emit(assign(r3C22, bit_or(r3C2A, r3C2B), 0x01));

                     body.emit(assign(r3C23, rshift(r3BFB, r3C20), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C28->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3C2D = equal(r3C20, body.constant(int(32)));
                     ir_if *f3C2C = new(mem_ctx) ir_if(operand(r3C2D).val);
                     exec_list *const f3C2C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C2C->then_instructions;

                        body.emit(assign(r3C21, r3BFC, 0x01));

                        body.emit(assign(r3C22, r3BFB, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3C2C->else_instructions;

                        body.emit(assign(r3C1F, bit_or(body.constant(0u), r3BFC), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3C2F = less(r3C20, body.constant(int(64)));
                        ir_if *f3C2E = new(mem_ctx) ir_if(operand(r3C2F).val);
                        exec_list *const f3C2E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C2E->then_instructions;

                           body.emit(assign(r3C21, lshift(r3BFB, r3C24), 0x01));

                           ir_expression *const r3C30 = bit_and(r3C20, body.constant(int(31)));
                           body.emit(assign(r3C22, rshift(r3BFB, r3C30), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3C2E->else_instructions;

                           ir_variable *const r3C31 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3C33 = equal(r3C20, body.constant(int(64)));
                           ir_if *f3C32 = new(mem_ctx) ir_if(operand(r3C33).val);
                           exec_list *const f3C32_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C32->then_instructions;

                              body.emit(assign(r3C31, r3BFB, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3C32->else_instructions;

                              ir_expression *const r3C34 = nequal(r3BFB, body.constant(0u));
                              ir_expression *const r3C35 = expr(ir_unop_b2i, r3C34);
                              body.emit(assign(r3C31, expr(ir_unop_i2u, r3C35), 0x01));


                           body.instructions = f3C32_parent_instructions;
                           body.emit(f3C32);

                           /* END IF */

                           body.emit(assign(r3C21, r3C31, 0x01));

                           body.emit(assign(r3C22, body.constant(0u), 0x01));


                        body.instructions = f3C2E_parent_instructions;
                        body.emit(f3C2E);

                        /* END IF */


                     body.instructions = f3C2C_parent_instructions;
                     body.emit(f3C2C);

                     /* END IF */

                     body.emit(assign(r3C23, body.constant(0u), 0x01));


                  body.instructions = f3C28_parent_instructions;
                  body.emit(f3C28);

                  /* END IF */

                  ir_expression *const r3C36 = nequal(r3C1F, body.constant(0u));
                  ir_expression *const r3C37 = expr(ir_unop_b2i, r3C36);
                  ir_expression *const r3C38 = expr(ir_unop_i2u, r3C37);
                  body.emit(assign(r3C21, bit_or(r3C21, r3C38), 0x01));


               body.instructions = f3C26_parent_instructions;
               body.emit(f3C26);

               /* END IF */

               body.emit(assign(r3BFB, r3C23, 0x01));

               body.emit(assign(r3BFC, r3C22, 0x01));

               body.emit(assign(r3BFD, r3C21, 0x01));


            body.instructions = f3C15_parent_instructions;
            body.emit(f3C15);

            /* END IF */

            body.emit(assign(r3BFA, sub(r3BFA, r3BFE), 0x01));

            ir_variable *const r3C39 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r3C39, r3BFA, 0x01));

            ir_variable *const r3C3A = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r3C3A, r3BFB, 0x01));

            ir_variable *const r3C3B = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r3C3B, r3BFC, 0x01));

            ir_variable *const r3C3C = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r3C3C, r3BFD, 0x01));

            ir_variable *const r3C3D = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r3C3D, body.constant(true), 0x01));

            ir_variable *const r3C3E = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3C3F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r3C3F);
            ir_expression *const r3C40 = expr(ir_unop_u2i, r3BFD);
            body.emit(assign(r3C3F, less(r3C40, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3C42 = lequal(body.constant(int(2045)), r3BFA);
            ir_if *f3C41 = new(mem_ctx) ir_if(operand(r3C42).val);
            exec_list *const f3C41_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C41->then_instructions;

               ir_variable *const r3C43 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r3C45 = less(body.constant(int(2045)), r3BFA);
               ir_if *f3C44 = new(mem_ctx) ir_if(operand(r3C45).val);
               exec_list *const f3C44_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C44->then_instructions;

                  body.emit(assign(r3C43, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C44->else_instructions;

                  ir_variable *const r3C46 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3C48 = equal(r3BFA, body.constant(int(2045)));
                  ir_if *f3C47 = new(mem_ctx) ir_if(operand(r3C48).val);
                  exec_list *const f3C47_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C47->then_instructions;

                     ir_expression *const r3C49 = equal(body.constant(2097151u), r3BFB);
                     ir_expression *const r3C4A = equal(body.constant(4294967295u), r3BFC);
                     body.emit(assign(r3C46, logic_and(r3C49, r3C4A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C47->else_instructions;

                     body.emit(assign(r3C46, body.constant(false), 0x01));


                  body.instructions = f3C47_parent_instructions;
                  body.emit(f3C47);

                  /* END IF */

                  body.emit(assign(r3C43, logic_and(r3C46, r3C3F), 0x01));


               body.instructions = f3C44_parent_instructions;
               body.emit(f3C44);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3C4B = new(mem_ctx) ir_if(operand(r3C43).val);
               exec_list *const f3C4B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C4B->then_instructions;

                  ir_variable *const r3C4C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3C4C);
                  ir_expression *const r3C4D = lshift(r3B90, body.constant(int(31)));
                  body.emit(assign(r3C4C, add(r3C4D, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r3C4C, body.constant(0u), 0x01));

                  body.emit(assign(r3C3E, r3C4C, 0x03));

                  body.emit(assign(r3C3D, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C4B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3C4F = less(r3BFA, body.constant(int(0)));
                  ir_if *f3C4E = new(mem_ctx) ir_if(operand(r3C4F).val);
                  exec_list *const f3C4E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C4E->then_instructions;

                     ir_variable *const r3C50 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3C50, r3BFD, 0x01));

                     ir_variable *const r3C51 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3C51, neg(r3BFA), 0x01));

                     ir_variable *const r3C52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3C52);
                     ir_variable *const r3C53 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3C53);
                     ir_variable *const r3C54 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3C54);
                     ir_variable *const r3C55 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r3C56 = neg(r3C51);
                     body.emit(assign(r3C55, bit_and(r3C56, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3C58 = equal(r3C51, body.constant(int(0)));
                     ir_if *f3C57 = new(mem_ctx) ir_if(operand(r3C58).val);
                     exec_list *const f3C57_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C57->then_instructions;

                        body.emit(assign(r3C52, r3BFD, 0x01));

                        body.emit(assign(r3C53, r3BFC, 0x01));

                        body.emit(assign(r3C54, r3BFB, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3C57->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3C5A = less(r3C51, body.constant(int(32)));
                        ir_if *f3C59 = new(mem_ctx) ir_if(operand(r3C5A).val);
                        exec_list *const f3C59_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C59->then_instructions;

                           body.emit(assign(r3C52, lshift(r3BFC, r3C55), 0x01));

                           ir_expression *const r3C5B = lshift(r3BFB, r3C55);
                           ir_expression *const r3C5C = rshift(r3BFC, r3C51);
                           body.emit(assign(r3C53, bit_or(r3C5B, r3C5C), 0x01));

                           body.emit(assign(r3C54, rshift(r3BFB, r3C51), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3C59->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3C5E = equal(r3C51, body.constant(int(32)));
                           ir_if *f3C5D = new(mem_ctx) ir_if(operand(r3C5E).val);
                           exec_list *const f3C5D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C5D->then_instructions;

                              body.emit(assign(r3C52, r3BFC, 0x01));

                              body.emit(assign(r3C53, r3BFB, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3C5D->else_instructions;

                              body.emit(assign(r3C50, bit_or(r3BFD, r3BFC), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3C60 = less(r3C51, body.constant(int(64)));
                              ir_if *f3C5F = new(mem_ctx) ir_if(operand(r3C60).val);
                              exec_list *const f3C5F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3C5F->then_instructions;

                                 body.emit(assign(r3C52, lshift(r3BFB, r3C55), 0x01));

                                 ir_expression *const r3C61 = bit_and(r3C51, body.constant(int(31)));
                                 body.emit(assign(r3C53, rshift(r3BFB, r3C61), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3C5F->else_instructions;

                                 ir_variable *const r3C62 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3C64 = equal(r3C51, body.constant(int(64)));
                                 ir_if *f3C63 = new(mem_ctx) ir_if(operand(r3C64).val);
                                 exec_list *const f3C63_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3C63->then_instructions;

                                    body.emit(assign(r3C62, r3BFB, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3C63->else_instructions;

                                    ir_expression *const r3C65 = nequal(r3BFB, body.constant(0u));
                                    ir_expression *const r3C66 = expr(ir_unop_b2i, r3C65);
                                    body.emit(assign(r3C62, expr(ir_unop_i2u, r3C66), 0x01));


                                 body.instructions = f3C63_parent_instructions;
                                 body.emit(f3C63);

                                 /* END IF */

                                 body.emit(assign(r3C52, r3C62, 0x01));

                                 body.emit(assign(r3C53, body.constant(0u), 0x01));


                              body.instructions = f3C5F_parent_instructions;
                              body.emit(f3C5F);

                              /* END IF */


                           body.instructions = f3C5D_parent_instructions;
                           body.emit(f3C5D);

                           /* END IF */

                           body.emit(assign(r3C54, body.constant(0u), 0x01));


                        body.instructions = f3C59_parent_instructions;
                        body.emit(f3C59);

                        /* END IF */

                        ir_expression *const r3C67 = nequal(r3C50, body.constant(0u));
                        ir_expression *const r3C68 = expr(ir_unop_b2i, r3C67);
                        ir_expression *const r3C69 = expr(ir_unop_i2u, r3C68);
                        body.emit(assign(r3C52, bit_or(r3C52, r3C69), 0x01));


                     body.instructions = f3C57_parent_instructions;
                     body.emit(f3C57);

                     /* END IF */

                     body.emit(assign(r3C3A, r3C54, 0x01));

                     body.emit(assign(r3C3B, r3C53, 0x01));

                     body.emit(assign(r3C3C, r3C52, 0x01));

                     body.emit(assign(r3C39, body.constant(int(0)), 0x01));

                     body.emit(assign(r3C3F, less(r3C52, body.constant(0u)), 0x01));


                  body.instructions = f3C4E_parent_instructions;
                  body.emit(f3C4E);

                  /* END IF */


               body.instructions = f3C4B_parent_instructions;
               body.emit(f3C4B);

               /* END IF */


            body.instructions = f3C41_parent_instructions;
            body.emit(f3C41);

            /* END IF */

            /* IF CONDITION */
            ir_if *f3C6A = new(mem_ctx) ir_if(operand(r3C3D).val);
            exec_list *const f3C6A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C6A->then_instructions;

               /* IF CONDITION */
               ir_if *f3C6B = new(mem_ctx) ir_if(operand(r3C3F).val);
               exec_list *const f3C6B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C6B->then_instructions;

                  ir_variable *const r3C6C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3C6C, add(r3C3B, body.constant(1u)), 0x01));

                  ir_expression *const r3C6D = less(r3C6C, r3C3B);
                  ir_expression *const r3C6E = expr(ir_unop_b2i, r3C6D);
                  ir_expression *const r3C6F = expr(ir_unop_i2u, r3C6E);
                  body.emit(assign(r3C3A, add(r3C3A, r3C6F), 0x01));

                  ir_expression *const r3C70 = equal(r3C3C, body.constant(0u));
                  ir_expression *const r3C71 = expr(ir_unop_b2i, r3C70);
                  ir_expression *const r3C72 = expr(ir_unop_i2u, r3C71);
                  ir_expression *const r3C73 = add(r3C3C, r3C72);
                  ir_expression *const r3C74 = bit_and(r3C73, body.constant(1u));
                  ir_expression *const r3C75 = expr(ir_unop_bit_not, r3C74);
                  body.emit(assign(r3C3B, bit_and(r3C6C, r3C75), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C6B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3C77 = bit_or(r3C3A, r3C3B);
                  ir_expression *const r3C78 = equal(r3C77, body.constant(0u));
                  ir_if *f3C76 = new(mem_ctx) ir_if(operand(r3C78).val);
                  exec_list *const f3C76_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C76->then_instructions;

                     body.emit(assign(r3C39, body.constant(int(0)), 0x01));


                  body.instructions = f3C76_parent_instructions;
                  body.emit(f3C76);

                  /* END IF */


               body.instructions = f3C6B_parent_instructions;
               body.emit(f3C6B);

               /* END IF */

               ir_variable *const r3C79 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3C79);
               ir_expression *const r3C7A = lshift(r3B90, body.constant(int(31)));
               ir_expression *const r3C7B = expr(ir_unop_i2u, r3C39);
               ir_expression *const r3C7C = lshift(r3C7B, body.constant(int(20)));
               ir_expression *const r3C7D = add(r3C7A, r3C7C);
               body.emit(assign(r3C79, add(r3C7D, r3C3A), 0x02));

               body.emit(assign(r3C79, r3C3B, 0x01));

               body.emit(assign(r3C3E, r3C79, 0x03));

               body.emit(assign(r3C3D, body.constant(false), 0x01));


            body.instructions = f3C6A_parent_instructions;
            body.emit(f3C6A);

            /* END IF */

            body.emit(assign(r3B95, r3C3E, 0x03));


         body.instructions = f3BB0_parent_instructions;
         body.emit(f3BB0);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3BAE->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3C7F = less(r3B96, body.constant(int(0)));
         ir_if *f3C7E = new(mem_ctx) ir_if(operand(r3C7F).val);
         exec_list *const f3C7E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3C7E->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3C81 = equal(r3BA1, body.constant(int(2047)));
            ir_if *f3C80 = new(mem_ctx) ir_if(operand(r3C81).val);
            exec_list *const f3C80_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C80->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3C83 = bit_or(r3B99, r3B9A);
               ir_expression *const r3C84 = nequal(r3C83, body.constant(0u));
               ir_if *f3C82 = new(mem_ctx) ir_if(operand(r3C84).val);
               exec_list *const f3C82_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C82->then_instructions;

                  ir_variable *const r3C85 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r3C85, swizzle_x(r321D), 0x01));

                  ir_variable *const r3C86 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r3C86, swizzle_x(r39DD), 0x01));

                  ir_variable *const r3C87 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3C88 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r3C89 = rshift(swizzle_y(r321D), body.constant(int(19)));
                  ir_expression *const r3C8A = bit_and(r3C89, body.constant(4095u));
                  ir_expression *const r3C8B = equal(r3C8A, body.constant(4094u));
                  ir_expression *const r3C8C = nequal(swizzle_x(r321D), body.constant(0u));
                  ir_expression *const r3C8D = bit_and(swizzle_y(r321D), body.constant(524287u));
                  ir_expression *const r3C8E = nequal(r3C8D, body.constant(0u));
                  ir_expression *const r3C8F = logic_or(r3C8C, r3C8E);
                  body.emit(assign(r3C88, logic_and(r3C8B, r3C8F), 0x01));

                  ir_variable *const r3C90 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r3C91 = lshift(swizzle_y(r39DD), body.constant(int(1)));
                  ir_expression *const r3C92 = lequal(body.constant(4292870144u), r3C91);
                  ir_expression *const r3C93 = nequal(swizzle_x(r39DD), body.constant(0u));
                  ir_expression *const r3C94 = bit_and(swizzle_y(r39DD), body.constant(1048575u));
                  ir_expression *const r3C95 = nequal(r3C94, body.constant(0u));
                  ir_expression *const r3C96 = logic_or(r3C93, r3C95);
                  body.emit(assign(r3C90, logic_and(r3C92, r3C96), 0x01));

                  body.emit(assign(r3C85, bit_or(swizzle_y(r321D), body.constant(524288u)), 0x02));

                  body.emit(assign(r3C86, bit_or(swizzle_y(r39DD), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3C98 = lshift(swizzle_y(r321D), body.constant(int(1)));
                  ir_expression *const r3C99 = lequal(body.constant(4292870144u), r3C98);
                  ir_expression *const r3C9A = nequal(swizzle_x(r321D), body.constant(0u));
                  ir_expression *const r3C9B = bit_and(swizzle_y(r321D), body.constant(1048575u));
                  ir_expression *const r3C9C = nequal(r3C9B, body.constant(0u));
                  ir_expression *const r3C9D = logic_or(r3C9A, r3C9C);
                  ir_expression *const r3C9E = logic_and(r3C99, r3C9D);
                  ir_if *f3C97 = new(mem_ctx) ir_if(operand(r3C9E).val);
                  exec_list *const f3C97_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C97->then_instructions;

                     ir_variable *const r3C9F = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3CA1 = logic_and(r3C88, r3C90);
                     ir_if *f3CA0 = new(mem_ctx) ir_if(operand(r3CA1).val);
                     exec_list *const f3CA0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3CA0->then_instructions;

                        body.emit(assign(r3C9F, r3C86, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3CA0->else_instructions;

                        body.emit(assign(r3C9F, r3C85, 0x03));


                     body.instructions = f3CA0_parent_instructions;
                     body.emit(f3CA0);

                     /* END IF */

                     body.emit(assign(r3C87, r3C9F, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C97->else_instructions;

                     body.emit(assign(r3C87, r3C86, 0x03));


                  body.instructions = f3C97_parent_instructions;
                  body.emit(f3C97);

                  /* END IF */

                  body.emit(assign(r3B95, r3C87, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C82->else_instructions;

                  ir_variable *const r3CA2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3CA2);
                  ir_expression *const r3CA3 = bit_xor(r3B90, body.constant(1u));
                  ir_expression *const r3CA4 = lshift(r3CA3, body.constant(int(31)));
                  body.emit(assign(r3CA2, add(r3CA4, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r3CA2, body.constant(0u), 0x01));

                  body.emit(assign(r3B95, r3CA2, 0x03));


               body.instructions = f3C82_parent_instructions;
               body.emit(f3C82);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3C80->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3CA6 = equal(r3B9E, body.constant(int(0)));
               ir_if *f3CA5 = new(mem_ctx) ir_if(operand(r3CA6).val);
               exec_list *const f3CA5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CA5->then_instructions;

                  body.emit(assign(r3B96, add(r3B96, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3CA5->else_instructions;

                  body.emit(assign(r3B9B, bit_or(r3B9B, body.constant(1073741824u)), 0x01));


               body.instructions = f3CA5_parent_instructions;
               body.emit(f3CA5);

               /* END IF */

               ir_variable *const r3CA7 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r3CA7, neg(r3B96), 0x01));

               ir_variable *const r3CA8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3CA8);
               ir_variable *const r3CA9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3CA9);
               ir_variable *const r3CAA = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3CAB = neg(r3CA7);
               body.emit(assign(r3CAA, bit_and(r3CAB, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3CAD = equal(r3CA7, body.constant(int(0)));
               ir_if *f3CAC = new(mem_ctx) ir_if(operand(r3CAD).val);
               exec_list *const f3CAC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CAC->then_instructions;

                  body.emit(assign(r3CA8, r3BA4, 0x01));

                  body.emit(assign(r3CA9, r3B9B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3CAC->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3CAF = less(r3CA7, body.constant(int(32)));
                  ir_if *f3CAE = new(mem_ctx) ir_if(operand(r3CAF).val);
                  exec_list *const f3CAE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CAE->then_instructions;

                     ir_expression *const r3CB0 = lshift(r3B9B, r3CAA);
                     ir_expression *const r3CB1 = rshift(r3BA4, r3CA7);
                     ir_expression *const r3CB2 = bit_or(r3CB0, r3CB1);
                     ir_expression *const r3CB3 = lshift(r3BA4, r3CAA);
                     ir_expression *const r3CB4 = nequal(r3CB3, body.constant(0u));
                     ir_expression *const r3CB5 = expr(ir_unop_b2i, r3CB4);
                     ir_expression *const r3CB6 = expr(ir_unop_i2u, r3CB5);
                     body.emit(assign(r3CA8, bit_or(r3CB2, r3CB6), 0x01));

                     body.emit(assign(r3CA9, rshift(r3B9B, r3CA7), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3CAE->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3CB8 = equal(r3CA7, body.constant(int(32)));
                     ir_if *f3CB7 = new(mem_ctx) ir_if(operand(r3CB8).val);
                     exec_list *const f3CB7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3CB7->then_instructions;

                        ir_expression *const r3CB9 = nequal(r3BA4, body.constant(0u));
                        ir_expression *const r3CBA = expr(ir_unop_b2i, r3CB9);
                        ir_expression *const r3CBB = expr(ir_unop_i2u, r3CBA);
                        body.emit(assign(r3CA8, bit_or(r3B9B, r3CBB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3CB7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3CBD = less(r3CA7, body.constant(int(64)));
                        ir_if *f3CBC = new(mem_ctx) ir_if(operand(r3CBD).val);
                        exec_list *const f3CBC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3CBC->then_instructions;

                           ir_expression *const r3CBE = bit_and(r3CA7, body.constant(int(31)));
                           ir_expression *const r3CBF = rshift(r3B9B, r3CBE);
                           ir_expression *const r3CC0 = lshift(r3B9B, r3CAA);
                           ir_expression *const r3CC1 = bit_or(r3CC0, r3BA4);
                           ir_expression *const r3CC2 = nequal(r3CC1, body.constant(0u));
                           ir_expression *const r3CC3 = expr(ir_unop_b2i, r3CC2);
                           ir_expression *const r3CC4 = expr(ir_unop_i2u, r3CC3);
                           body.emit(assign(r3CA8, bit_or(r3CBF, r3CC4), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3CBC->else_instructions;

                           ir_expression *const r3CC5 = bit_or(r3B9B, r3BA4);
                           ir_expression *const r3CC6 = nequal(r3CC5, body.constant(0u));
                           ir_expression *const r3CC7 = expr(ir_unop_b2i, r3CC6);
                           body.emit(assign(r3CA8, expr(ir_unop_i2u, r3CC7), 0x01));


                        body.instructions = f3CBC_parent_instructions;
                        body.emit(f3CBC);

                        /* END IF */


                     body.instructions = f3CB7_parent_instructions;
                     body.emit(f3CB7);

                     /* END IF */

                     body.emit(assign(r3CA9, body.constant(0u), 0x01));


                  body.instructions = f3CAE_parent_instructions;
                  body.emit(f3CAE);

                  /* END IF */


               body.instructions = f3CAC_parent_instructions;
               body.emit(f3CAC);

               /* END IF */

               body.emit(assign(r3B9B, r3CA9, 0x01));

               body.emit(assign(r3B9C, r3CA8, 0x01));

               body.emit(assign(r3B99, bit_or(r3B99, body.constant(1073741824u)), 0x01));

               ir_variable *const r3CC8 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3CC9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3CC9, sub(r3B9A, r3CA8), 0x01));

               ir_expression *const r3CCA = sub(r3B99, r3CA9);
               ir_expression *const r3CCB = less(r3B9A, r3CA8);
               ir_expression *const r3CCC = expr(ir_unop_b2i, r3CCB);
               ir_expression *const r3CCD = expr(ir_unop_i2u, r3CCC);
               body.emit(assign(r3CC8, sub(r3CCA, r3CCD), 0x01));

               body.emit(assign(r3B94, bit_xor(r3B90, body.constant(1u)), 0x01));

               body.emit(assign(r3B9D, add(r3BA1, body.constant(int(-1))), 0x01));

               ir_variable *const r3CCE = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3CCE, add(r3B9D, body.constant(int(-10))), 0x01));

               ir_variable *const r3CCF = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3CCF, r3CC8, 0x01));

               ir_variable *const r3CD0 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3CD0, r3CC9, 0x01));

               ir_variable *const r3CD1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r3CD1);
               ir_variable *const r3CD2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3CD2);
               /* IF CONDITION */
               ir_expression *const r3CD4 = equal(r3CC8, body.constant(0u));
               ir_if *f3CD3 = new(mem_ctx) ir_if(operand(r3CD4).val);
               exec_list *const f3CD3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CD3->then_instructions;

                  body.emit(assign(r3CCF, r3CC9, 0x01));

                  body.emit(assign(r3CD0, body.constant(0u), 0x01));

                  body.emit(assign(r3CCE, add(r3CCE, body.constant(int(-32))), 0x01));


               body.instructions = f3CD3_parent_instructions;
               body.emit(f3CD3);

               /* END IF */

               ir_variable *const r3CD5 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r3CD5, r3CCF, 0x01));

               ir_variable *const r3CD6 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r3CD7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3CD7);
               /* IF CONDITION */
               ir_expression *const r3CD9 = equal(r3CCF, body.constant(0u));
               ir_if *f3CD8 = new(mem_ctx) ir_if(operand(r3CD9).val);
               exec_list *const f3CD8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CD8->then_instructions;

                  body.emit(assign(r3CD6, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3CD8->else_instructions;

                  body.emit(assign(r3CD7, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3CDB = bit_and(r3CCF, body.constant(4294901760u));
                  ir_expression *const r3CDC = equal(r3CDB, body.constant(0u));
                  ir_if *f3CDA = new(mem_ctx) ir_if(operand(r3CDC).val);
                  exec_list *const f3CDA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CDA->then_instructions;

                     body.emit(assign(r3CD7, body.constant(int(16)), 0x01));

                     body.emit(assign(r3CD5, lshift(r3CCF, body.constant(int(16))), 0x01));


                  body.instructions = f3CDA_parent_instructions;
                  body.emit(f3CDA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3CDE = bit_and(r3CD5, body.constant(4278190080u));
                  ir_expression *const r3CDF = equal(r3CDE, body.constant(0u));
                  ir_if *f3CDD = new(mem_ctx) ir_if(operand(r3CDF).val);
                  exec_list *const f3CDD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CDD->then_instructions;

                     body.emit(assign(r3CD7, add(r3CD7, body.constant(int(8))), 0x01));

                     body.emit(assign(r3CD5, lshift(r3CD5, body.constant(int(8))), 0x01));


                  body.instructions = f3CDD_parent_instructions;
                  body.emit(f3CDD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3CE1 = bit_and(r3CD5, body.constant(4026531840u));
                  ir_expression *const r3CE2 = equal(r3CE1, body.constant(0u));
                  ir_if *f3CE0 = new(mem_ctx) ir_if(operand(r3CE2).val);
                  exec_list *const f3CE0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CE0->then_instructions;

                     body.emit(assign(r3CD7, add(r3CD7, body.constant(int(4))), 0x01));

                     body.emit(assign(r3CD5, lshift(r3CD5, body.constant(int(4))), 0x01));


                  body.instructions = f3CE0_parent_instructions;
                  body.emit(f3CE0);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3CE4 = bit_and(r3CD5, body.constant(3221225472u));
                  ir_expression *const r3CE5 = equal(r3CE4, body.constant(0u));
                  ir_if *f3CE3 = new(mem_ctx) ir_if(operand(r3CE5).val);
                  exec_list *const f3CE3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CE3->then_instructions;

                     body.emit(assign(r3CD7, add(r3CD7, body.constant(int(2))), 0x01));

                     body.emit(assign(r3CD5, lshift(r3CD5, body.constant(int(2))), 0x01));


                  body.instructions = f3CE3_parent_instructions;
                  body.emit(f3CE3);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3CE7 = bit_and(r3CD5, body.constant(2147483648u));
                  ir_expression *const r3CE8 = equal(r3CE7, body.constant(0u));
                  ir_if *f3CE6 = new(mem_ctx) ir_if(operand(r3CE8).val);
                  exec_list *const f3CE6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CE6->then_instructions;

                     body.emit(assign(r3CD7, add(r3CD7, body.constant(int(1))), 0x01));


                  body.instructions = f3CE6_parent_instructions;
                  body.emit(f3CE6);

                  /* END IF */

                  body.emit(assign(r3CD6, r3CD7, 0x01));


               body.instructions = f3CD8_parent_instructions;
               body.emit(f3CD8);

               /* END IF */

               body.emit(assign(r3CD2, add(r3CD6, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3CEA = lequal(body.constant(int(0)), r3CD2);
               ir_if *f3CE9 = new(mem_ctx) ir_if(operand(r3CEA).val);
               exec_list *const f3CE9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CE9->then_instructions;

                  body.emit(assign(r3CD1, body.constant(0u), 0x01));

                  ir_variable *const r3CEB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3CEB, lshift(r3CD0, r3CD2), 0x01));

                  ir_variable *const r3CEC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3CEE = equal(r3CD2, body.constant(int(0)));
                  ir_if *f3CED = new(mem_ctx) ir_if(operand(r3CEE).val);
                  exec_list *const f3CED_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CED->then_instructions;

                     body.emit(assign(r3CEC, r3CCF, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3CED->else_instructions;

                     ir_expression *const r3CEF = lshift(r3CCF, r3CD2);
                     ir_expression *const r3CF0 = neg(r3CD2);
                     ir_expression *const r3CF1 = bit_and(r3CF0, body.constant(int(31)));
                     ir_expression *const r3CF2 = rshift(r3CD0, r3CF1);
                     body.emit(assign(r3CEC, bit_or(r3CEF, r3CF2), 0x01));


                  body.instructions = f3CED_parent_instructions;
                  body.emit(f3CED);

                  /* END IF */

                  body.emit(assign(r3CCF, r3CEC, 0x01));

                  body.emit(assign(r3CD0, r3CEB, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3CE9->else_instructions;

                  ir_variable *const r3CF3 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r3CF3, body.constant(0u), 0x01));

                  ir_variable *const r3CF4 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r3CF4, neg(r3CD2), 0x01));

                  ir_variable *const r3CF5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3CF5);
                  ir_variable *const r3CF6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3CF6);
                  ir_variable *const r3CF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3CF7);
                  ir_variable *const r3CF8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r3CF9 = neg(r3CF4);
                  body.emit(assign(r3CF8, bit_and(r3CF9, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3CFB = equal(r3CF4, body.constant(int(0)));
                  ir_if *f3CFA = new(mem_ctx) ir_if(operand(r3CFB).val);
                  exec_list *const f3CFA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CFA->then_instructions;

                     body.emit(assign(r3CF5, r3CF3, 0x01));

                     body.emit(assign(r3CF6, r3CD0, 0x01));

                     body.emit(assign(r3CF7, r3CCF, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3CFA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3CFD = less(r3CF4, body.constant(int(32)));
                     ir_if *f3CFC = new(mem_ctx) ir_if(operand(r3CFD).val);
                     exec_list *const f3CFC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3CFC->then_instructions;

                        body.emit(assign(r3CF5, lshift(r3CD0, r3CF8), 0x01));

                        ir_expression *const r3CFE = lshift(r3CCF, r3CF8);
                        ir_expression *const r3CFF = rshift(r3CD0, r3CF4);
                        body.emit(assign(r3CF6, bit_or(r3CFE, r3CFF), 0x01));

                        body.emit(assign(r3CF7, rshift(r3CCF, r3CF4), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3CFC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3D01 = equal(r3CF4, body.constant(int(32)));
                        ir_if *f3D00 = new(mem_ctx) ir_if(operand(r3D01).val);
                        exec_list *const f3D00_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3D00->then_instructions;

                           body.emit(assign(r3CF5, r3CD0, 0x01));

                           body.emit(assign(r3CF6, r3CCF, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3D00->else_instructions;

                           body.emit(assign(r3CF3, bit_or(body.constant(0u), r3CD0), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3D03 = less(r3CF4, body.constant(int(64)));
                           ir_if *f3D02 = new(mem_ctx) ir_if(operand(r3D03).val);
                           exec_list *const f3D02_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3D02->then_instructions;

                              body.emit(assign(r3CF5, lshift(r3CCF, r3CF8), 0x01));

                              ir_expression *const r3D04 = bit_and(r3CF4, body.constant(int(31)));
                              body.emit(assign(r3CF6, rshift(r3CCF, r3D04), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3D02->else_instructions;

                              ir_variable *const r3D05 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3D07 = equal(r3CF4, body.constant(int(64)));
                              ir_if *f3D06 = new(mem_ctx) ir_if(operand(r3D07).val);
                              exec_list *const f3D06_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3D06->then_instructions;

                                 body.emit(assign(r3D05, r3CCF, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3D06->else_instructions;

                                 ir_expression *const r3D08 = nequal(r3CCF, body.constant(0u));
                                 ir_expression *const r3D09 = expr(ir_unop_b2i, r3D08);
                                 body.emit(assign(r3D05, expr(ir_unop_i2u, r3D09), 0x01));


                              body.instructions = f3D06_parent_instructions;
                              body.emit(f3D06);

                              /* END IF */

                              body.emit(assign(r3CF5, r3D05, 0x01));

                              body.emit(assign(r3CF6, body.constant(0u), 0x01));


                           body.instructions = f3D02_parent_instructions;
                           body.emit(f3D02);

                           /* END IF */


                        body.instructions = f3D00_parent_instructions;
                        body.emit(f3D00);

                        /* END IF */

                        body.emit(assign(r3CF7, body.constant(0u), 0x01));


                     body.instructions = f3CFC_parent_instructions;
                     body.emit(f3CFC);

                     /* END IF */

                     ir_expression *const r3D0A = nequal(r3CF3, body.constant(0u));
                     ir_expression *const r3D0B = expr(ir_unop_b2i, r3D0A);
                     ir_expression *const r3D0C = expr(ir_unop_i2u, r3D0B);
                     body.emit(assign(r3CF5, bit_or(r3CF5, r3D0C), 0x01));


                  body.instructions = f3CFA_parent_instructions;
                  body.emit(f3CFA);

                  /* END IF */

                  body.emit(assign(r3CCF, r3CF7, 0x01));

                  body.emit(assign(r3CD0, r3CF6, 0x01));

                  body.emit(assign(r3CD1, r3CF5, 0x01));


               body.instructions = f3CE9_parent_instructions;
               body.emit(f3CE9);

               /* END IF */

               body.emit(assign(r3CCE, sub(r3CCE, r3CD2), 0x01));

               ir_variable *const r3D0D = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3D0D, r3CCE, 0x01));

               ir_variable *const r3D0E = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3D0E, r3CCF, 0x01));

               ir_variable *const r3D0F = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3D0F, r3CD0, 0x01));

               ir_variable *const r3D10 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3D10, r3CD1, 0x01));

               ir_variable *const r3D11 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3D11, body.constant(true), 0x01));

               ir_variable *const r3D12 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3D13 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3D13);
               ir_expression *const r3D14 = expr(ir_unop_u2i, r3CD1);
               body.emit(assign(r3D13, less(r3D14, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3D16 = lequal(body.constant(int(2045)), r3CCE);
               ir_if *f3D15 = new(mem_ctx) ir_if(operand(r3D16).val);
               exec_list *const f3D15_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D15->then_instructions;

                  ir_variable *const r3D17 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3D19 = less(body.constant(int(2045)), r3CCE);
                  ir_if *f3D18 = new(mem_ctx) ir_if(operand(r3D19).val);
                  exec_list *const f3D18_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D18->then_instructions;

                     body.emit(assign(r3D17, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D18->else_instructions;

                     ir_variable *const r3D1A = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3D1C = equal(r3CCE, body.constant(int(2045)));
                     ir_if *f3D1B = new(mem_ctx) ir_if(operand(r3D1C).val);
                     exec_list *const f3D1B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D1B->then_instructions;

                        ir_expression *const r3D1D = equal(body.constant(2097151u), r3CCF);
                        ir_expression *const r3D1E = equal(body.constant(4294967295u), r3CD0);
                        body.emit(assign(r3D1A, logic_and(r3D1D, r3D1E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3D1B->else_instructions;

                        body.emit(assign(r3D1A, body.constant(false), 0x01));


                     body.instructions = f3D1B_parent_instructions;
                     body.emit(f3D1B);

                     /* END IF */

                     body.emit(assign(r3D17, logic_and(r3D1A, r3D13), 0x01));


                  body.instructions = f3D18_parent_instructions;
                  body.emit(f3D18);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3D1F = new(mem_ctx) ir_if(operand(r3D17).val);
                  exec_list *const f3D1F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D1F->then_instructions;

                     ir_variable *const r3D20 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3D20);
                     ir_expression *const r3D21 = lshift(r3B94, body.constant(int(31)));
                     body.emit(assign(r3D20, add(r3D21, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3D20, body.constant(0u), 0x01));

                     body.emit(assign(r3D12, r3D20, 0x03));

                     body.emit(assign(r3D11, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D1F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3D23 = less(r3CCE, body.constant(int(0)));
                     ir_if *f3D22 = new(mem_ctx) ir_if(operand(r3D23).val);
                     exec_list *const f3D22_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D22->then_instructions;

                        ir_variable *const r3D24 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3D24, r3CD1, 0x01));

                        ir_variable *const r3D25 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3D25, neg(r3CCE), 0x01));

                        ir_variable *const r3D26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3D26);
                        ir_variable *const r3D27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3D27);
                        ir_variable *const r3D28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3D28);
                        ir_variable *const r3D29 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3D2A = neg(r3D25);
                        body.emit(assign(r3D29, bit_and(r3D2A, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3D2C = equal(r3D25, body.constant(int(0)));
                        ir_if *f3D2B = new(mem_ctx) ir_if(operand(r3D2C).val);
                        exec_list *const f3D2B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3D2B->then_instructions;

                           body.emit(assign(r3D26, r3CD1, 0x01));

                           body.emit(assign(r3D27, r3CD0, 0x01));

                           body.emit(assign(r3D28, r3CCF, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3D2B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3D2E = less(r3D25, body.constant(int(32)));
                           ir_if *f3D2D = new(mem_ctx) ir_if(operand(r3D2E).val);
                           exec_list *const f3D2D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3D2D->then_instructions;

                              body.emit(assign(r3D26, lshift(r3CD0, r3D29), 0x01));

                              ir_expression *const r3D2F = lshift(r3CCF, r3D29);
                              ir_expression *const r3D30 = rshift(r3CD0, r3D25);
                              body.emit(assign(r3D27, bit_or(r3D2F, r3D30), 0x01));

                              body.emit(assign(r3D28, rshift(r3CCF, r3D25), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3D2D->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3D32 = equal(r3D25, body.constant(int(32)));
                              ir_if *f3D31 = new(mem_ctx) ir_if(operand(r3D32).val);
                              exec_list *const f3D31_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3D31->then_instructions;

                                 body.emit(assign(r3D26, r3CD0, 0x01));

                                 body.emit(assign(r3D27, r3CCF, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3D31->else_instructions;

                                 body.emit(assign(r3D24, bit_or(r3CD1, r3CD0), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3D34 = less(r3D25, body.constant(int(64)));
                                 ir_if *f3D33 = new(mem_ctx) ir_if(operand(r3D34).val);
                                 exec_list *const f3D33_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3D33->then_instructions;

                                    body.emit(assign(r3D26, lshift(r3CCF, r3D29), 0x01));

                                    ir_expression *const r3D35 = bit_and(r3D25, body.constant(int(31)));
                                    body.emit(assign(r3D27, rshift(r3CCF, r3D35), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3D33->else_instructions;

                                    ir_variable *const r3D36 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3D38 = equal(r3D25, body.constant(int(64)));
                                    ir_if *f3D37 = new(mem_ctx) ir_if(operand(r3D38).val);
                                    exec_list *const f3D37_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3D37->then_instructions;

                                       body.emit(assign(r3D36, r3CCF, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3D37->else_instructions;

                                       ir_expression *const r3D39 = nequal(r3CCF, body.constant(0u));
                                       ir_expression *const r3D3A = expr(ir_unop_b2i, r3D39);
                                       body.emit(assign(r3D36, expr(ir_unop_i2u, r3D3A), 0x01));


                                    body.instructions = f3D37_parent_instructions;
                                    body.emit(f3D37);

                                    /* END IF */

                                    body.emit(assign(r3D26, r3D36, 0x01));

                                    body.emit(assign(r3D27, body.constant(0u), 0x01));


                                 body.instructions = f3D33_parent_instructions;
                                 body.emit(f3D33);

                                 /* END IF */


                              body.instructions = f3D31_parent_instructions;
                              body.emit(f3D31);

                              /* END IF */

                              body.emit(assign(r3D28, body.constant(0u), 0x01));


                           body.instructions = f3D2D_parent_instructions;
                           body.emit(f3D2D);

                           /* END IF */

                           ir_expression *const r3D3B = nequal(r3D24, body.constant(0u));
                           ir_expression *const r3D3C = expr(ir_unop_b2i, r3D3B);
                           ir_expression *const r3D3D = expr(ir_unop_i2u, r3D3C);
                           body.emit(assign(r3D26, bit_or(r3D26, r3D3D), 0x01));


                        body.instructions = f3D2B_parent_instructions;
                        body.emit(f3D2B);

                        /* END IF */

                        body.emit(assign(r3D0E, r3D28, 0x01));

                        body.emit(assign(r3D0F, r3D27, 0x01));

                        body.emit(assign(r3D10, r3D26, 0x01));

                        body.emit(assign(r3D0D, body.constant(int(0)), 0x01));

                        body.emit(assign(r3D13, less(r3D26, body.constant(0u)), 0x01));


                     body.instructions = f3D22_parent_instructions;
                     body.emit(f3D22);

                     /* END IF */


                  body.instructions = f3D1F_parent_instructions;
                  body.emit(f3D1F);

                  /* END IF */


               body.instructions = f3D15_parent_instructions;
               body.emit(f3D15);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3D3E = new(mem_ctx) ir_if(operand(r3D11).val);
               exec_list *const f3D3E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D3E->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3D3F = new(mem_ctx) ir_if(operand(r3D13).val);
                  exec_list *const f3D3F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D3F->then_instructions;

                     ir_variable *const r3D40 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3D40, add(r3D0F, body.constant(1u)), 0x01));

                     ir_expression *const r3D41 = less(r3D40, r3D0F);
                     ir_expression *const r3D42 = expr(ir_unop_b2i, r3D41);
                     ir_expression *const r3D43 = expr(ir_unop_i2u, r3D42);
                     body.emit(assign(r3D0E, add(r3D0E, r3D43), 0x01));

                     ir_expression *const r3D44 = equal(r3D10, body.constant(0u));
                     ir_expression *const r3D45 = expr(ir_unop_b2i, r3D44);
                     ir_expression *const r3D46 = expr(ir_unop_i2u, r3D45);
                     ir_expression *const r3D47 = add(r3D10, r3D46);
                     ir_expression *const r3D48 = bit_and(r3D47, body.constant(1u));
                     ir_expression *const r3D49 = expr(ir_unop_bit_not, r3D48);
                     body.emit(assign(r3D0F, bit_and(r3D40, r3D49), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D3F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3D4B = bit_or(r3D0E, r3D0F);
                     ir_expression *const r3D4C = equal(r3D4B, body.constant(0u));
                     ir_if *f3D4A = new(mem_ctx) ir_if(operand(r3D4C).val);
                     exec_list *const f3D4A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D4A->then_instructions;

                        body.emit(assign(r3D0D, body.constant(int(0)), 0x01));


                     body.instructions = f3D4A_parent_instructions;
                     body.emit(f3D4A);

                     /* END IF */


                  body.instructions = f3D3F_parent_instructions;
                  body.emit(f3D3F);

                  /* END IF */

                  ir_variable *const r3D4D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3D4D);
                  ir_expression *const r3D4E = lshift(r3B94, body.constant(int(31)));
                  ir_expression *const r3D4F = expr(ir_unop_i2u, r3D0D);
                  ir_expression *const r3D50 = lshift(r3D4F, body.constant(int(20)));
                  ir_expression *const r3D51 = add(r3D4E, r3D50);
                  body.emit(assign(r3D4D, add(r3D51, r3D0E), 0x02));

                  body.emit(assign(r3D4D, r3D0F, 0x01));

                  body.emit(assign(r3D12, r3D4D, 0x03));

                  body.emit(assign(r3D11, body.constant(false), 0x01));


               body.instructions = f3D3E_parent_instructions;
               body.emit(f3D3E);

               /* END IF */

               body.emit(assign(r3B95, r3D12, 0x03));


            body.instructions = f3C80_parent_instructions;
            body.emit(f3C80);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3C7E->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3D53 = equal(r3B9E, body.constant(int(2047)));
            ir_if *f3D52 = new(mem_ctx) ir_if(operand(r3D53).val);
            exec_list *const f3D52_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3D52->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3D55 = bit_or(r3B9B, r3B9C);
               ir_expression *const r3D56 = bit_or(r3B99, r3B9A);
               ir_expression *const r3D57 = bit_or(r3D55, r3D56);
               ir_expression *const r3D58 = nequal(r3D57, body.constant(0u));
               ir_if *f3D54 = new(mem_ctx) ir_if(operand(r3D58).val);
               exec_list *const f3D54_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D54->then_instructions;

                  ir_variable *const r3D59 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r3D59, swizzle_x(r321D), 0x01));

                  ir_variable *const r3D5A = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r3D5A, swizzle_x(r39DD), 0x01));

                  ir_variable *const r3D5B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3D5C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r3D5D = rshift(swizzle_y(r321D), body.constant(int(19)));
                  ir_expression *const r3D5E = bit_and(r3D5D, body.constant(4095u));
                  ir_expression *const r3D5F = equal(r3D5E, body.constant(4094u));
                  ir_expression *const r3D60 = nequal(swizzle_x(r321D), body.constant(0u));
                  ir_expression *const r3D61 = bit_and(swizzle_y(r321D), body.constant(524287u));
                  ir_expression *const r3D62 = nequal(r3D61, body.constant(0u));
                  ir_expression *const r3D63 = logic_or(r3D60, r3D62);
                  body.emit(assign(r3D5C, logic_and(r3D5F, r3D63), 0x01));

                  ir_variable *const r3D64 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r3D65 = lshift(swizzle_y(r39DD), body.constant(int(1)));
                  ir_expression *const r3D66 = lequal(body.constant(4292870144u), r3D65);
                  ir_expression *const r3D67 = nequal(swizzle_x(r39DD), body.constant(0u));
                  ir_expression *const r3D68 = bit_and(swizzle_y(r39DD), body.constant(1048575u));
                  ir_expression *const r3D69 = nequal(r3D68, body.constant(0u));
                  ir_expression *const r3D6A = logic_or(r3D67, r3D69);
                  body.emit(assign(r3D64, logic_and(r3D66, r3D6A), 0x01));

                  body.emit(assign(r3D59, bit_or(swizzle_y(r321D), body.constant(524288u)), 0x02));

                  body.emit(assign(r3D5A, bit_or(swizzle_y(r39DD), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3D6C = lshift(swizzle_y(r321D), body.constant(int(1)));
                  ir_expression *const r3D6D = lequal(body.constant(4292870144u), r3D6C);
                  ir_expression *const r3D6E = nequal(swizzle_x(r321D), body.constant(0u));
                  ir_expression *const r3D6F = bit_and(swizzle_y(r321D), body.constant(1048575u));
                  ir_expression *const r3D70 = nequal(r3D6F, body.constant(0u));
                  ir_expression *const r3D71 = logic_or(r3D6E, r3D70);
                  ir_expression *const r3D72 = logic_and(r3D6D, r3D71);
                  ir_if *f3D6B = new(mem_ctx) ir_if(operand(r3D72).val);
                  exec_list *const f3D6B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D6B->then_instructions;

                     ir_variable *const r3D73 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3D75 = logic_and(r3D5C, r3D64);
                     ir_if *f3D74 = new(mem_ctx) ir_if(operand(r3D75).val);
                     exec_list *const f3D74_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D74->then_instructions;

                        body.emit(assign(r3D73, r3D5A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3D74->else_instructions;

                        body.emit(assign(r3D73, r3D59, 0x03));


                     body.instructions = f3D74_parent_instructions;
                     body.emit(f3D74);

                     /* END IF */

                     body.emit(assign(r3D5B, r3D73, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D6B->else_instructions;

                     body.emit(assign(r3D5B, r3D5A, 0x03));


                  body.instructions = f3D6B_parent_instructions;
                  body.emit(f3D6B);

                  /* END IF */

                  body.emit(assign(r3B95, r3D5B, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3D54->else_instructions;

                  ir_constant_data r3D76_data;
                  memset(&r3D76_data, 0, sizeof(ir_constant_data));
                  r3D76_data.u[0] = 4294967295;
                  r3D76_data.u[1] = 4294967295;
                  ir_constant *const r3D76 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3D76_data);
                  body.emit(assign(r3B95, r3D76, 0x03));


               body.instructions = f3D54_parent_instructions;
               body.emit(f3D54);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3D52->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3D78 = equal(r3B9E, body.constant(int(0)));
               ir_if *f3D77 = new(mem_ctx) ir_if(operand(r3D78).val);
               exec_list *const f3D77_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D77->then_instructions;

                  body.emit(assign(r3B98, body.constant(int(1)), 0x01));

                  body.emit(assign(r3B97, body.constant(int(1)), 0x01));


               body.instructions = f3D77_parent_instructions;
               body.emit(f3D77);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3D7A = less(r3B99, r3B9B);
               ir_if *f3D79 = new(mem_ctx) ir_if(operand(r3D7A).val);
               exec_list *const f3D79_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D79->then_instructions;

                  ir_variable *const r3D7B = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r3D7C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3D7C, sub(r3B9C, r3B9A), 0x01));

                  ir_expression *const r3D7D = sub(r3B9B, r3B99);
                  ir_expression *const r3D7E = less(r3B9C, r3B9A);
                  ir_expression *const r3D7F = expr(ir_unop_b2i, r3D7E);
                  ir_expression *const r3D80 = expr(ir_unop_i2u, r3D7F);
                  body.emit(assign(r3D7B, sub(r3D7D, r3D80), 0x01));

                  body.emit(assign(r3B9D, add(r3B98, body.constant(int(-1))), 0x01));

                  ir_variable *const r3D81 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r3D81, add(r3B9D, body.constant(int(-10))), 0x01));

                  ir_variable *const r3D82 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r3D82, r3D7B, 0x01));

                  ir_variable *const r3D83 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3D83, r3D7C, 0x01));

                  ir_variable *const r3D84 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r3D84);
                  ir_variable *const r3D85 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3D85);
                  /* IF CONDITION */
                  ir_expression *const r3D87 = equal(r3D7B, body.constant(0u));
                  ir_if *f3D86 = new(mem_ctx) ir_if(operand(r3D87).val);
                  exec_list *const f3D86_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D86->then_instructions;

                     body.emit(assign(r3D82, r3D7C, 0x01));

                     body.emit(assign(r3D83, body.constant(0u), 0x01));

                     body.emit(assign(r3D81, add(r3D81, body.constant(int(-32))), 0x01));


                  body.instructions = f3D86_parent_instructions;
                  body.emit(f3D86);

                  /* END IF */

                  ir_variable *const r3D88 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3D88, r3D82, 0x01));

                  ir_variable *const r3D89 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3D8A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3D8A);
                  /* IF CONDITION */
                  ir_expression *const r3D8C = equal(r3D82, body.constant(0u));
                  ir_if *f3D8B = new(mem_ctx) ir_if(operand(r3D8C).val);
                  exec_list *const f3D8B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D8B->then_instructions;

                     body.emit(assign(r3D89, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D8B->else_instructions;

                     body.emit(assign(r3D8A, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3D8E = bit_and(r3D82, body.constant(4294901760u));
                     ir_expression *const r3D8F = equal(r3D8E, body.constant(0u));
                     ir_if *f3D8D = new(mem_ctx) ir_if(operand(r3D8F).val);
                     exec_list *const f3D8D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D8D->then_instructions;

                        body.emit(assign(r3D8A, body.constant(int(16)), 0x01));

                        body.emit(assign(r3D88, lshift(r3D82, body.constant(int(16))), 0x01));


                     body.instructions = f3D8D_parent_instructions;
                     body.emit(f3D8D);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3D91 = bit_and(r3D88, body.constant(4278190080u));
                     ir_expression *const r3D92 = equal(r3D91, body.constant(0u));
                     ir_if *f3D90 = new(mem_ctx) ir_if(operand(r3D92).val);
                     exec_list *const f3D90_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D90->then_instructions;

                        body.emit(assign(r3D8A, add(r3D8A, body.constant(int(8))), 0x01));

                        body.emit(assign(r3D88, lshift(r3D88, body.constant(int(8))), 0x01));


                     body.instructions = f3D90_parent_instructions;
                     body.emit(f3D90);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3D94 = bit_and(r3D88, body.constant(4026531840u));
                     ir_expression *const r3D95 = equal(r3D94, body.constant(0u));
                     ir_if *f3D93 = new(mem_ctx) ir_if(operand(r3D95).val);
                     exec_list *const f3D93_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D93->then_instructions;

                        body.emit(assign(r3D8A, add(r3D8A, body.constant(int(4))), 0x01));

                        body.emit(assign(r3D88, lshift(r3D88, body.constant(int(4))), 0x01));


                     body.instructions = f3D93_parent_instructions;
                     body.emit(f3D93);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3D97 = bit_and(r3D88, body.constant(3221225472u));
                     ir_expression *const r3D98 = equal(r3D97, body.constant(0u));
                     ir_if *f3D96 = new(mem_ctx) ir_if(operand(r3D98).val);
                     exec_list *const f3D96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D96->then_instructions;

                        body.emit(assign(r3D8A, add(r3D8A, body.constant(int(2))), 0x01));

                        body.emit(assign(r3D88, lshift(r3D88, body.constant(int(2))), 0x01));


                     body.instructions = f3D96_parent_instructions;
                     body.emit(f3D96);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3D9A = bit_and(r3D88, body.constant(2147483648u));
                     ir_expression *const r3D9B = equal(r3D9A, body.constant(0u));
                     ir_if *f3D99 = new(mem_ctx) ir_if(operand(r3D9B).val);
                     exec_list *const f3D99_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D99->then_instructions;

                        body.emit(assign(r3D8A, add(r3D8A, body.constant(int(1))), 0x01));


                     body.instructions = f3D99_parent_instructions;
                     body.emit(f3D99);

                     /* END IF */

                     body.emit(assign(r3D89, r3D8A, 0x01));


                  body.instructions = f3D8B_parent_instructions;
                  body.emit(f3D8B);

                  /* END IF */

                  body.emit(assign(r3D85, add(r3D89, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3D9D = lequal(body.constant(int(0)), r3D85);
                  ir_if *f3D9C = new(mem_ctx) ir_if(operand(r3D9D).val);
                  exec_list *const f3D9C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D9C->then_instructions;

                     body.emit(assign(r3D84, body.constant(0u), 0x01));

                     ir_variable *const r3D9E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3D9E, lshift(r3D83, r3D85), 0x01));

                     ir_variable *const r3D9F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3DA1 = equal(r3D85, body.constant(int(0)));
                     ir_if *f3DA0 = new(mem_ctx) ir_if(operand(r3DA1).val);
                     exec_list *const f3DA0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DA0->then_instructions;

                        body.emit(assign(r3D9F, r3D82, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DA0->else_instructions;

                        ir_expression *const r3DA2 = lshift(r3D82, r3D85);
                        ir_expression *const r3DA3 = neg(r3D85);
                        ir_expression *const r3DA4 = bit_and(r3DA3, body.constant(int(31)));
                        ir_expression *const r3DA5 = rshift(r3D83, r3DA4);
                        body.emit(assign(r3D9F, bit_or(r3DA2, r3DA5), 0x01));


                     body.instructions = f3DA0_parent_instructions;
                     body.emit(f3DA0);

                     /* END IF */

                     body.emit(assign(r3D82, r3D9F, 0x01));

                     body.emit(assign(r3D83, r3D9E, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D9C->else_instructions;

                     ir_variable *const r3DA6 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3DA6, body.constant(0u), 0x01));

                     ir_variable *const r3DA7 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3DA7, neg(r3D85), 0x01));

                     ir_variable *const r3DA8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3DA8);
                     ir_variable *const r3DA9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3DA9);
                     ir_variable *const r3DAA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3DAA);
                     ir_variable *const r3DAB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r3DAC = neg(r3DA7);
                     body.emit(assign(r3DAB, bit_and(r3DAC, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3DAE = equal(r3DA7, body.constant(int(0)));
                     ir_if *f3DAD = new(mem_ctx) ir_if(operand(r3DAE).val);
                     exec_list *const f3DAD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DAD->then_instructions;

                        body.emit(assign(r3DA8, r3DA6, 0x01));

                        body.emit(assign(r3DA9, r3D83, 0x01));

                        body.emit(assign(r3DAA, r3D82, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DAD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3DB0 = less(r3DA7, body.constant(int(32)));
                        ir_if *f3DAF = new(mem_ctx) ir_if(operand(r3DB0).val);
                        exec_list *const f3DAF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3DAF->then_instructions;

                           body.emit(assign(r3DA8, lshift(r3D83, r3DAB), 0x01));

                           ir_expression *const r3DB1 = lshift(r3D82, r3DAB);
                           ir_expression *const r3DB2 = rshift(r3D83, r3DA7);
                           body.emit(assign(r3DA9, bit_or(r3DB1, r3DB2), 0x01));

                           body.emit(assign(r3DAA, rshift(r3D82, r3DA7), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3DAF->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3DB4 = equal(r3DA7, body.constant(int(32)));
                           ir_if *f3DB3 = new(mem_ctx) ir_if(operand(r3DB4).val);
                           exec_list *const f3DB3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3DB3->then_instructions;

                              body.emit(assign(r3DA8, r3D83, 0x01));

                              body.emit(assign(r3DA9, r3D82, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3DB3->else_instructions;

                              body.emit(assign(r3DA6, bit_or(body.constant(0u), r3D83), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3DB6 = less(r3DA7, body.constant(int(64)));
                              ir_if *f3DB5 = new(mem_ctx) ir_if(operand(r3DB6).val);
                              exec_list *const f3DB5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3DB5->then_instructions;

                                 body.emit(assign(r3DA8, lshift(r3D82, r3DAB), 0x01));

                                 ir_expression *const r3DB7 = bit_and(r3DA7, body.constant(int(31)));
                                 body.emit(assign(r3DA9, rshift(r3D82, r3DB7), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3DB5->else_instructions;

                                 ir_variable *const r3DB8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3DBA = equal(r3DA7, body.constant(int(64)));
                                 ir_if *f3DB9 = new(mem_ctx) ir_if(operand(r3DBA).val);
                                 exec_list *const f3DB9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3DB9->then_instructions;

                                    body.emit(assign(r3DB8, r3D82, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3DB9->else_instructions;

                                    ir_expression *const r3DBB = nequal(r3D82, body.constant(0u));
                                    ir_expression *const r3DBC = expr(ir_unop_b2i, r3DBB);
                                    body.emit(assign(r3DB8, expr(ir_unop_i2u, r3DBC), 0x01));


                                 body.instructions = f3DB9_parent_instructions;
                                 body.emit(f3DB9);

                                 /* END IF */

                                 body.emit(assign(r3DA8, r3DB8, 0x01));

                                 body.emit(assign(r3DA9, body.constant(0u), 0x01));


                              body.instructions = f3DB5_parent_instructions;
                              body.emit(f3DB5);

                              /* END IF */


                           body.instructions = f3DB3_parent_instructions;
                           body.emit(f3DB3);

                           /* END IF */

                           body.emit(assign(r3DAA, body.constant(0u), 0x01));


                        body.instructions = f3DAF_parent_instructions;
                        body.emit(f3DAF);

                        /* END IF */

                        ir_expression *const r3DBD = nequal(r3DA6, body.constant(0u));
                        ir_expression *const r3DBE = expr(ir_unop_b2i, r3DBD);
                        ir_expression *const r3DBF = expr(ir_unop_i2u, r3DBE);
                        body.emit(assign(r3DA8, bit_or(r3DA8, r3DBF), 0x01));


                     body.instructions = f3DAD_parent_instructions;
                     body.emit(f3DAD);

                     /* END IF */

                     body.emit(assign(r3D82, r3DAA, 0x01));

                     body.emit(assign(r3D83, r3DA9, 0x01));

                     body.emit(assign(r3D84, r3DA8, 0x01));


                  body.instructions = f3D9C_parent_instructions;
                  body.emit(f3D9C);

                  /* END IF */

                  body.emit(assign(r3D81, sub(r3D81, r3D85), 0x01));

                  ir_variable *const r3DC0 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r3DC0, r3D81, 0x01));

                  ir_variable *const r3DC1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r3DC1, r3D82, 0x01));

                  ir_variable *const r3DC2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3DC2, r3D83, 0x01));

                  ir_variable *const r3DC3 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r3DC3, r3D84, 0x01));

                  ir_variable *const r3DC4 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r3DC4, body.constant(true), 0x01));

                  ir_variable *const r3DC5 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3DC6 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r3DC6);
                  ir_expression *const r3DC7 = expr(ir_unop_u2i, r3D84);
                  body.emit(assign(r3DC6, less(r3DC7, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3DC9 = lequal(body.constant(int(2045)), r3D81);
                  ir_if *f3DC8 = new(mem_ctx) ir_if(operand(r3DC9).val);
                  exec_list *const f3DC8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3DC8->then_instructions;

                     ir_variable *const r3DCA = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3DCC = less(body.constant(int(2045)), r3D81);
                     ir_if *f3DCB = new(mem_ctx) ir_if(operand(r3DCC).val);
                     exec_list *const f3DCB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DCB->then_instructions;

                        body.emit(assign(r3DCA, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DCB->else_instructions;

                        ir_variable *const r3DCD = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3DCF = equal(r3D81, body.constant(int(2045)));
                        ir_if *f3DCE = new(mem_ctx) ir_if(operand(r3DCF).val);
                        exec_list *const f3DCE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3DCE->then_instructions;

                           ir_expression *const r3DD0 = equal(body.constant(2097151u), r3D82);
                           ir_expression *const r3DD1 = equal(body.constant(4294967295u), r3D83);
                           body.emit(assign(r3DCD, logic_and(r3DD0, r3DD1), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3DCE->else_instructions;

                           body.emit(assign(r3DCD, body.constant(false), 0x01));


                        body.instructions = f3DCE_parent_instructions;
                        body.emit(f3DCE);

                        /* END IF */

                        body.emit(assign(r3DCA, logic_and(r3DCD, r3DC6), 0x01));


                     body.instructions = f3DCB_parent_instructions;
                     body.emit(f3DCB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3DD2 = new(mem_ctx) ir_if(operand(r3DCA).val);
                     exec_list *const f3DD2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DD2->then_instructions;

                        ir_variable *const r3DD3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3DD3);
                        ir_expression *const r3DD4 = lshift(r3B94, body.constant(int(31)));
                        body.emit(assign(r3DD3, add(r3DD4, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r3DD3, body.constant(0u), 0x01));

                        body.emit(assign(r3DC5, r3DD3, 0x03));

                        body.emit(assign(r3DC4, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DD2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3DD6 = less(r3D81, body.constant(int(0)));
                        ir_if *f3DD5 = new(mem_ctx) ir_if(operand(r3DD6).val);
                        exec_list *const f3DD5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3DD5->then_instructions;

                           ir_variable *const r3DD7 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3DD7, r3D84, 0x01));

                           ir_variable *const r3DD8 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3DD8, neg(r3D81), 0x01));

                           ir_variable *const r3DD9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3DD9);
                           ir_variable *const r3DDA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3DDA);
                           ir_variable *const r3DDB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3DDB);
                           ir_variable *const r3DDC = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3DDD = neg(r3DD8);
                           body.emit(assign(r3DDC, bit_and(r3DDD, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3DDF = equal(r3DD8, body.constant(int(0)));
                           ir_if *f3DDE = new(mem_ctx) ir_if(operand(r3DDF).val);
                           exec_list *const f3DDE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3DDE->then_instructions;

                              body.emit(assign(r3DD9, r3D84, 0x01));

                              body.emit(assign(r3DDA, r3D83, 0x01));

                              body.emit(assign(r3DDB, r3D82, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3DDE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3DE1 = less(r3DD8, body.constant(int(32)));
                              ir_if *f3DE0 = new(mem_ctx) ir_if(operand(r3DE1).val);
                              exec_list *const f3DE0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3DE0->then_instructions;

                                 body.emit(assign(r3DD9, lshift(r3D83, r3DDC), 0x01));

                                 ir_expression *const r3DE2 = lshift(r3D82, r3DDC);
                                 ir_expression *const r3DE3 = rshift(r3D83, r3DD8);
                                 body.emit(assign(r3DDA, bit_or(r3DE2, r3DE3), 0x01));

                                 body.emit(assign(r3DDB, rshift(r3D82, r3DD8), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3DE0->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3DE5 = equal(r3DD8, body.constant(int(32)));
                                 ir_if *f3DE4 = new(mem_ctx) ir_if(operand(r3DE5).val);
                                 exec_list *const f3DE4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3DE4->then_instructions;

                                    body.emit(assign(r3DD9, r3D83, 0x01));

                                    body.emit(assign(r3DDA, r3D82, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3DE4->else_instructions;

                                    body.emit(assign(r3DD7, bit_or(r3D84, r3D83), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3DE7 = less(r3DD8, body.constant(int(64)));
                                    ir_if *f3DE6 = new(mem_ctx) ir_if(operand(r3DE7).val);
                                    exec_list *const f3DE6_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3DE6->then_instructions;

                                       body.emit(assign(r3DD9, lshift(r3D82, r3DDC), 0x01));

                                       ir_expression *const r3DE8 = bit_and(r3DD8, body.constant(int(31)));
                                       body.emit(assign(r3DDA, rshift(r3D82, r3DE8), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3DE6->else_instructions;

                                       ir_variable *const r3DE9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3DEB = equal(r3DD8, body.constant(int(64)));
                                       ir_if *f3DEA = new(mem_ctx) ir_if(operand(r3DEB).val);
                                       exec_list *const f3DEA_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3DEA->then_instructions;

                                          body.emit(assign(r3DE9, r3D82, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3DEA->else_instructions;

                                          ir_expression *const r3DEC = nequal(r3D82, body.constant(0u));
                                          ir_expression *const r3DED = expr(ir_unop_b2i, r3DEC);
                                          body.emit(assign(r3DE9, expr(ir_unop_i2u, r3DED), 0x01));


                                       body.instructions = f3DEA_parent_instructions;
                                       body.emit(f3DEA);

                                       /* END IF */

                                       body.emit(assign(r3DD9, r3DE9, 0x01));

                                       body.emit(assign(r3DDA, body.constant(0u), 0x01));


                                    body.instructions = f3DE6_parent_instructions;
                                    body.emit(f3DE6);

                                    /* END IF */


                                 body.instructions = f3DE4_parent_instructions;
                                 body.emit(f3DE4);

                                 /* END IF */

                                 body.emit(assign(r3DDB, body.constant(0u), 0x01));


                              body.instructions = f3DE0_parent_instructions;
                              body.emit(f3DE0);

                              /* END IF */

                              ir_expression *const r3DEE = nequal(r3DD7, body.constant(0u));
                              ir_expression *const r3DEF = expr(ir_unop_b2i, r3DEE);
                              ir_expression *const r3DF0 = expr(ir_unop_i2u, r3DEF);
                              body.emit(assign(r3DD9, bit_or(r3DD9, r3DF0), 0x01));


                           body.instructions = f3DDE_parent_instructions;
                           body.emit(f3DDE);

                           /* END IF */

                           body.emit(assign(r3DC1, r3DDB, 0x01));

                           body.emit(assign(r3DC2, r3DDA, 0x01));

                           body.emit(assign(r3DC3, r3DD9, 0x01));

                           body.emit(assign(r3DC0, body.constant(int(0)), 0x01));

                           body.emit(assign(r3DC6, less(r3DD9, body.constant(0u)), 0x01));


                        body.instructions = f3DD5_parent_instructions;
                        body.emit(f3DD5);

                        /* END IF */


                     body.instructions = f3DD2_parent_instructions;
                     body.emit(f3DD2);

                     /* END IF */


                  body.instructions = f3DC8_parent_instructions;
                  body.emit(f3DC8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3DF1 = new(mem_ctx) ir_if(operand(r3DC4).val);
                  exec_list *const f3DF1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3DF1->then_instructions;

                     /* IF CONDITION */
                     ir_if *f3DF2 = new(mem_ctx) ir_if(operand(r3DC6).val);
                     exec_list *const f3DF2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DF2->then_instructions;

                        ir_variable *const r3DF3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r3DF3, add(r3DC2, body.constant(1u)), 0x01));

                        ir_expression *const r3DF4 = less(r3DF3, r3DC2);
                        ir_expression *const r3DF5 = expr(ir_unop_b2i, r3DF4);
                        ir_expression *const r3DF6 = expr(ir_unop_i2u, r3DF5);
                        body.emit(assign(r3DC1, add(r3DC1, r3DF6), 0x01));

                        ir_expression *const r3DF7 = equal(r3DC3, body.constant(0u));
                        ir_expression *const r3DF8 = expr(ir_unop_b2i, r3DF7);
                        ir_expression *const r3DF9 = expr(ir_unop_i2u, r3DF8);
                        ir_expression *const r3DFA = add(r3DC3, r3DF9);
                        ir_expression *const r3DFB = bit_and(r3DFA, body.constant(1u));
                        ir_expression *const r3DFC = expr(ir_unop_bit_not, r3DFB);
                        body.emit(assign(r3DC2, bit_and(r3DF3, r3DFC), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DF2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3DFE = bit_or(r3DC1, r3DC2);
                        ir_expression *const r3DFF = equal(r3DFE, body.constant(0u));
                        ir_if *f3DFD = new(mem_ctx) ir_if(operand(r3DFF).val);
                        exec_list *const f3DFD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3DFD->then_instructions;

                           body.emit(assign(r3DC0, body.constant(int(0)), 0x01));


                        body.instructions = f3DFD_parent_instructions;
                        body.emit(f3DFD);

                        /* END IF */


                     body.instructions = f3DF2_parent_instructions;
                     body.emit(f3DF2);

                     /* END IF */

                     ir_variable *const r3E00 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3E00);
                     ir_expression *const r3E01 = lshift(r3B94, body.constant(int(31)));
                     ir_expression *const r3E02 = expr(ir_unop_i2u, r3DC0);
                     ir_expression *const r3E03 = lshift(r3E02, body.constant(int(20)));
                     ir_expression *const r3E04 = add(r3E01, r3E03);
                     body.emit(assign(r3E00, add(r3E04, r3DC1), 0x02));

                     body.emit(assign(r3E00, r3DC2, 0x01));

                     body.emit(assign(r3DC5, r3E00, 0x03));

                     body.emit(assign(r3DC4, body.constant(false), 0x01));


                  body.instructions = f3DF1_parent_instructions;
                  body.emit(f3DF1);

                  /* END IF */

                  body.emit(assign(r3B95, r3DC5, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3D79->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3E06 = less(r3B9B, r3B99);
                  ir_if *f3E05 = new(mem_ctx) ir_if(operand(r3E06).val);
                  exec_list *const f3E05_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3E05->then_instructions;

                     ir_variable *const r3E07 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r3E08 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3E08, sub(r3B9A, r3B9C), 0x01));

                     ir_expression *const r3E09 = sub(r3B99, r3B9B);
                     ir_expression *const r3E0A = less(r3B9A, r3B9C);
                     ir_expression *const r3E0B = expr(ir_unop_b2i, r3E0A);
                     ir_expression *const r3E0C = expr(ir_unop_i2u, r3E0B);
                     body.emit(assign(r3E07, sub(r3E09, r3E0C), 0x01));

                     body.emit(assign(r3B94, bit_xor(r3B94, body.constant(1u)), 0x01));

                     body.emit(assign(r3B9D, add(r3B97, body.constant(int(-1))), 0x01));

                     ir_variable *const r3E0D = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3E0D, add(r3B9D, body.constant(int(-10))), 0x01));

                     ir_variable *const r3E0E = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r3E0E, r3E07, 0x01));

                     ir_variable *const r3E0F = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r3E0F, r3E08, 0x01));

                     ir_variable *const r3E10 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r3E10);
                     ir_variable *const r3E11 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3E11);
                     /* IF CONDITION */
                     ir_expression *const r3E13 = equal(r3E07, body.constant(0u));
                     ir_if *f3E12 = new(mem_ctx) ir_if(operand(r3E13).val);
                     exec_list *const f3E12_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E12->then_instructions;

                        body.emit(assign(r3E0E, r3E08, 0x01));

                        body.emit(assign(r3E0F, body.constant(0u), 0x01));

                        body.emit(assign(r3E0D, add(r3E0D, body.constant(int(-32))), 0x01));


                     body.instructions = f3E12_parent_instructions;
                     body.emit(f3E12);

                     /* END IF */

                     ir_variable *const r3E14 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3E14, r3E0E, 0x01));

                     ir_variable *const r3E15 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3E16 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3E16);
                     /* IF CONDITION */
                     ir_expression *const r3E18 = equal(r3E0E, body.constant(0u));
                     ir_if *f3E17 = new(mem_ctx) ir_if(operand(r3E18).val);
                     exec_list *const f3E17_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E17->then_instructions;

                        body.emit(assign(r3E15, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3E17->else_instructions;

                        body.emit(assign(r3E16, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3E1A = bit_and(r3E0E, body.constant(4294901760u));
                        ir_expression *const r3E1B = equal(r3E1A, body.constant(0u));
                        ir_if *f3E19 = new(mem_ctx) ir_if(operand(r3E1B).val);
                        exec_list *const f3E19_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E19->then_instructions;

                           body.emit(assign(r3E16, body.constant(int(16)), 0x01));

                           body.emit(assign(r3E14, lshift(r3E0E, body.constant(int(16))), 0x01));


                        body.instructions = f3E19_parent_instructions;
                        body.emit(f3E19);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3E1D = bit_and(r3E14, body.constant(4278190080u));
                        ir_expression *const r3E1E = equal(r3E1D, body.constant(0u));
                        ir_if *f3E1C = new(mem_ctx) ir_if(operand(r3E1E).val);
                        exec_list *const f3E1C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E1C->then_instructions;

                           body.emit(assign(r3E16, add(r3E16, body.constant(int(8))), 0x01));

                           body.emit(assign(r3E14, lshift(r3E14, body.constant(int(8))), 0x01));


                        body.instructions = f3E1C_parent_instructions;
                        body.emit(f3E1C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3E20 = bit_and(r3E14, body.constant(4026531840u));
                        ir_expression *const r3E21 = equal(r3E20, body.constant(0u));
                        ir_if *f3E1F = new(mem_ctx) ir_if(operand(r3E21).val);
                        exec_list *const f3E1F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E1F->then_instructions;

                           body.emit(assign(r3E16, add(r3E16, body.constant(int(4))), 0x01));

                           body.emit(assign(r3E14, lshift(r3E14, body.constant(int(4))), 0x01));


                        body.instructions = f3E1F_parent_instructions;
                        body.emit(f3E1F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3E23 = bit_and(r3E14, body.constant(3221225472u));
                        ir_expression *const r3E24 = equal(r3E23, body.constant(0u));
                        ir_if *f3E22 = new(mem_ctx) ir_if(operand(r3E24).val);
                        exec_list *const f3E22_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E22->then_instructions;

                           body.emit(assign(r3E16, add(r3E16, body.constant(int(2))), 0x01));

                           body.emit(assign(r3E14, lshift(r3E14, body.constant(int(2))), 0x01));


                        body.instructions = f3E22_parent_instructions;
                        body.emit(f3E22);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3E26 = bit_and(r3E14, body.constant(2147483648u));
                        ir_expression *const r3E27 = equal(r3E26, body.constant(0u));
                        ir_if *f3E25 = new(mem_ctx) ir_if(operand(r3E27).val);
                        exec_list *const f3E25_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E25->then_instructions;

                           body.emit(assign(r3E16, add(r3E16, body.constant(int(1))), 0x01));


                        body.instructions = f3E25_parent_instructions;
                        body.emit(f3E25);

                        /* END IF */

                        body.emit(assign(r3E15, r3E16, 0x01));


                     body.instructions = f3E17_parent_instructions;
                     body.emit(f3E17);

                     /* END IF */

                     body.emit(assign(r3E11, add(r3E15, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3E29 = lequal(body.constant(int(0)), r3E11);
                     ir_if *f3E28 = new(mem_ctx) ir_if(operand(r3E29).val);
                     exec_list *const f3E28_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E28->then_instructions;

                        body.emit(assign(r3E10, body.constant(0u), 0x01));

                        ir_variable *const r3E2A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r3E2A, lshift(r3E0F, r3E11), 0x01));

                        ir_variable *const r3E2B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3E2D = equal(r3E11, body.constant(int(0)));
                        ir_if *f3E2C = new(mem_ctx) ir_if(operand(r3E2D).val);
                        exec_list *const f3E2C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E2C->then_instructions;

                           body.emit(assign(r3E2B, r3E0E, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E2C->else_instructions;

                           ir_expression *const r3E2E = lshift(r3E0E, r3E11);
                           ir_expression *const r3E2F = neg(r3E11);
                           ir_expression *const r3E30 = bit_and(r3E2F, body.constant(int(31)));
                           ir_expression *const r3E31 = rshift(r3E0F, r3E30);
                           body.emit(assign(r3E2B, bit_or(r3E2E, r3E31), 0x01));


                        body.instructions = f3E2C_parent_instructions;
                        body.emit(f3E2C);

                        /* END IF */

                        body.emit(assign(r3E0E, r3E2B, 0x01));

                        body.emit(assign(r3E0F, r3E2A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3E28->else_instructions;

                        ir_variable *const r3E32 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3E32, body.constant(0u), 0x01));

                        ir_variable *const r3E33 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3E33, neg(r3E11), 0x01));

                        ir_variable *const r3E34 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3E34);
                        ir_variable *const r3E35 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3E35);
                        ir_variable *const r3E36 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3E36);
                        ir_variable *const r3E37 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3E38 = neg(r3E33);
                        body.emit(assign(r3E37, bit_and(r3E38, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3E3A = equal(r3E33, body.constant(int(0)));
                        ir_if *f3E39 = new(mem_ctx) ir_if(operand(r3E3A).val);
                        exec_list *const f3E39_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E39->then_instructions;

                           body.emit(assign(r3E34, r3E32, 0x01));

                           body.emit(assign(r3E35, r3E0F, 0x01));

                           body.emit(assign(r3E36, r3E0E, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E39->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3E3C = less(r3E33, body.constant(int(32)));
                           ir_if *f3E3B = new(mem_ctx) ir_if(operand(r3E3C).val);
                           exec_list *const f3E3B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3E3B->then_instructions;

                              body.emit(assign(r3E34, lshift(r3E0F, r3E37), 0x01));

                              ir_expression *const r3E3D = lshift(r3E0E, r3E37);
                              ir_expression *const r3E3E = rshift(r3E0F, r3E33);
                              body.emit(assign(r3E35, bit_or(r3E3D, r3E3E), 0x01));

                              body.emit(assign(r3E36, rshift(r3E0E, r3E33), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3E3B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3E40 = equal(r3E33, body.constant(int(32)));
                              ir_if *f3E3F = new(mem_ctx) ir_if(operand(r3E40).val);
                              exec_list *const f3E3F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3E3F->then_instructions;

                                 body.emit(assign(r3E34, r3E0F, 0x01));

                                 body.emit(assign(r3E35, r3E0E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3E3F->else_instructions;

                                 body.emit(assign(r3E32, bit_or(body.constant(0u), r3E0F), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3E42 = less(r3E33, body.constant(int(64)));
                                 ir_if *f3E41 = new(mem_ctx) ir_if(operand(r3E42).val);
                                 exec_list *const f3E41_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3E41->then_instructions;

                                    body.emit(assign(r3E34, lshift(r3E0E, r3E37), 0x01));

                                    ir_expression *const r3E43 = bit_and(r3E33, body.constant(int(31)));
                                    body.emit(assign(r3E35, rshift(r3E0E, r3E43), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3E41->else_instructions;

                                    ir_variable *const r3E44 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3E46 = equal(r3E33, body.constant(int(64)));
                                    ir_if *f3E45 = new(mem_ctx) ir_if(operand(r3E46).val);
                                    exec_list *const f3E45_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3E45->then_instructions;

                                       body.emit(assign(r3E44, r3E0E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3E45->else_instructions;

                                       ir_expression *const r3E47 = nequal(r3E0E, body.constant(0u));
                                       ir_expression *const r3E48 = expr(ir_unop_b2i, r3E47);
                                       body.emit(assign(r3E44, expr(ir_unop_i2u, r3E48), 0x01));


                                    body.instructions = f3E45_parent_instructions;
                                    body.emit(f3E45);

                                    /* END IF */

                                    body.emit(assign(r3E34, r3E44, 0x01));

                                    body.emit(assign(r3E35, body.constant(0u), 0x01));


                                 body.instructions = f3E41_parent_instructions;
                                 body.emit(f3E41);

                                 /* END IF */


                              body.instructions = f3E3F_parent_instructions;
                              body.emit(f3E3F);

                              /* END IF */

                              body.emit(assign(r3E36, body.constant(0u), 0x01));


                           body.instructions = f3E3B_parent_instructions;
                           body.emit(f3E3B);

                           /* END IF */

                           ir_expression *const r3E49 = nequal(r3E32, body.constant(0u));
                           ir_expression *const r3E4A = expr(ir_unop_b2i, r3E49);
                           ir_expression *const r3E4B = expr(ir_unop_i2u, r3E4A);
                           body.emit(assign(r3E34, bit_or(r3E34, r3E4B), 0x01));


                        body.instructions = f3E39_parent_instructions;
                        body.emit(f3E39);

                        /* END IF */

                        body.emit(assign(r3E0E, r3E36, 0x01));

                        body.emit(assign(r3E0F, r3E35, 0x01));

                        body.emit(assign(r3E10, r3E34, 0x01));


                     body.instructions = f3E28_parent_instructions;
                     body.emit(f3E28);

                     /* END IF */

                     body.emit(assign(r3E0D, sub(r3E0D, r3E11), 0x01));

                     ir_variable *const r3E4C = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3E4C, r3E0D, 0x01));

                     ir_variable *const r3E4D = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r3E4D, r3E0E, 0x01));

                     ir_variable *const r3E4E = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r3E4E, r3E0F, 0x01));

                     ir_variable *const r3E4F = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r3E4F, r3E10, 0x01));

                     ir_variable *const r3E50 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r3E50, body.constant(true), 0x01));

                     ir_variable *const r3E51 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r3E52 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r3E52);
                     ir_expression *const r3E53 = expr(ir_unop_u2i, r3E10);
                     body.emit(assign(r3E52, less(r3E53, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3E55 = lequal(body.constant(int(2045)), r3E0D);
                     ir_if *f3E54 = new(mem_ctx) ir_if(operand(r3E55).val);
                     exec_list *const f3E54_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E54->then_instructions;

                        ir_variable *const r3E56 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3E58 = less(body.constant(int(2045)), r3E0D);
                        ir_if *f3E57 = new(mem_ctx) ir_if(operand(r3E58).val);
                        exec_list *const f3E57_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E57->then_instructions;

                           body.emit(assign(r3E56, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E57->else_instructions;

                           ir_variable *const r3E59 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3E5B = equal(r3E0D, body.constant(int(2045)));
                           ir_if *f3E5A = new(mem_ctx) ir_if(operand(r3E5B).val);
                           exec_list *const f3E5A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3E5A->then_instructions;

                              ir_expression *const r3E5C = equal(body.constant(2097151u), r3E0E);
                              ir_expression *const r3E5D = equal(body.constant(4294967295u), r3E0F);
                              body.emit(assign(r3E59, logic_and(r3E5C, r3E5D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3E5A->else_instructions;

                              body.emit(assign(r3E59, body.constant(false), 0x01));


                           body.instructions = f3E5A_parent_instructions;
                           body.emit(f3E5A);

                           /* END IF */

                           body.emit(assign(r3E56, logic_and(r3E59, r3E52), 0x01));


                        body.instructions = f3E57_parent_instructions;
                        body.emit(f3E57);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3E5E = new(mem_ctx) ir_if(operand(r3E56).val);
                        exec_list *const f3E5E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E5E->then_instructions;

                           ir_variable *const r3E5F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3E5F);
                           ir_expression *const r3E60 = lshift(r3B94, body.constant(int(31)));
                           body.emit(assign(r3E5F, add(r3E60, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r3E5F, body.constant(0u), 0x01));

                           body.emit(assign(r3E51, r3E5F, 0x03));

                           body.emit(assign(r3E50, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E5E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3E62 = less(r3E0D, body.constant(int(0)));
                           ir_if *f3E61 = new(mem_ctx) ir_if(operand(r3E62).val);
                           exec_list *const f3E61_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3E61->then_instructions;

                              ir_variable *const r3E63 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3E63, r3E10, 0x01));

                              ir_variable *const r3E64 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3E64, neg(r3E0D), 0x01));

                              ir_variable *const r3E65 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3E65);
                              ir_variable *const r3E66 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3E66);
                              ir_variable *const r3E67 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3E67);
                              ir_variable *const r3E68 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3E69 = neg(r3E64);
                              body.emit(assign(r3E68, bit_and(r3E69, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3E6B = equal(r3E64, body.constant(int(0)));
                              ir_if *f3E6A = new(mem_ctx) ir_if(operand(r3E6B).val);
                              exec_list *const f3E6A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3E6A->then_instructions;

                                 body.emit(assign(r3E65, r3E10, 0x01));

                                 body.emit(assign(r3E66, r3E0F, 0x01));

                                 body.emit(assign(r3E67, r3E0E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3E6A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3E6D = less(r3E64, body.constant(int(32)));
                                 ir_if *f3E6C = new(mem_ctx) ir_if(operand(r3E6D).val);
                                 exec_list *const f3E6C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3E6C->then_instructions;

                                    body.emit(assign(r3E65, lshift(r3E0F, r3E68), 0x01));

                                    ir_expression *const r3E6E = lshift(r3E0E, r3E68);
                                    ir_expression *const r3E6F = rshift(r3E0F, r3E64);
                                    body.emit(assign(r3E66, bit_or(r3E6E, r3E6F), 0x01));

                                    body.emit(assign(r3E67, rshift(r3E0E, r3E64), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3E6C->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3E71 = equal(r3E64, body.constant(int(32)));
                                    ir_if *f3E70 = new(mem_ctx) ir_if(operand(r3E71).val);
                                    exec_list *const f3E70_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3E70->then_instructions;

                                       body.emit(assign(r3E65, r3E0F, 0x01));

                                       body.emit(assign(r3E66, r3E0E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3E70->else_instructions;

                                       body.emit(assign(r3E63, bit_or(r3E10, r3E0F), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3E73 = less(r3E64, body.constant(int(64)));
                                       ir_if *f3E72 = new(mem_ctx) ir_if(operand(r3E73).val);
                                       exec_list *const f3E72_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3E72->then_instructions;

                                          body.emit(assign(r3E65, lshift(r3E0E, r3E68), 0x01));

                                          ir_expression *const r3E74 = bit_and(r3E64, body.constant(int(31)));
                                          body.emit(assign(r3E66, rshift(r3E0E, r3E74), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3E72->else_instructions;

                                          ir_variable *const r3E75 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3E77 = equal(r3E64, body.constant(int(64)));
                                          ir_if *f3E76 = new(mem_ctx) ir_if(operand(r3E77).val);
                                          exec_list *const f3E76_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3E76->then_instructions;

                                             body.emit(assign(r3E75, r3E0E, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3E76->else_instructions;

                                             ir_expression *const r3E78 = nequal(r3E0E, body.constant(0u));
                                             ir_expression *const r3E79 = expr(ir_unop_b2i, r3E78);
                                             body.emit(assign(r3E75, expr(ir_unop_i2u, r3E79), 0x01));


                                          body.instructions = f3E76_parent_instructions;
                                          body.emit(f3E76);

                                          /* END IF */

                                          body.emit(assign(r3E65, r3E75, 0x01));

                                          body.emit(assign(r3E66, body.constant(0u), 0x01));


                                       body.instructions = f3E72_parent_instructions;
                                       body.emit(f3E72);

                                       /* END IF */


                                    body.instructions = f3E70_parent_instructions;
                                    body.emit(f3E70);

                                    /* END IF */

                                    body.emit(assign(r3E67, body.constant(0u), 0x01));


                                 body.instructions = f3E6C_parent_instructions;
                                 body.emit(f3E6C);

                                 /* END IF */

                                 ir_expression *const r3E7A = nequal(r3E63, body.constant(0u));
                                 ir_expression *const r3E7B = expr(ir_unop_b2i, r3E7A);
                                 ir_expression *const r3E7C = expr(ir_unop_i2u, r3E7B);
                                 body.emit(assign(r3E65, bit_or(r3E65, r3E7C), 0x01));


                              body.instructions = f3E6A_parent_instructions;
                              body.emit(f3E6A);

                              /* END IF */

                              body.emit(assign(r3E4D, r3E67, 0x01));

                              body.emit(assign(r3E4E, r3E66, 0x01));

                              body.emit(assign(r3E4F, r3E65, 0x01));

                              body.emit(assign(r3E4C, body.constant(int(0)), 0x01));

                              body.emit(assign(r3E52, less(r3E65, body.constant(0u)), 0x01));


                           body.instructions = f3E61_parent_instructions;
                           body.emit(f3E61);

                           /* END IF */


                        body.instructions = f3E5E_parent_instructions;
                        body.emit(f3E5E);

                        /* END IF */


                     body.instructions = f3E54_parent_instructions;
                     body.emit(f3E54);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3E7D = new(mem_ctx) ir_if(operand(r3E50).val);
                     exec_list *const f3E7D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E7D->then_instructions;

                        /* IF CONDITION */
                        ir_if *f3E7E = new(mem_ctx) ir_if(operand(r3E52).val);
                        exec_list *const f3E7E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E7E->then_instructions;

                           ir_variable *const r3E7F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r3E7F, add(r3E4E, body.constant(1u)), 0x01));

                           ir_expression *const r3E80 = less(r3E7F, r3E4E);
                           ir_expression *const r3E81 = expr(ir_unop_b2i, r3E80);
                           ir_expression *const r3E82 = expr(ir_unop_i2u, r3E81);
                           body.emit(assign(r3E4D, add(r3E4D, r3E82), 0x01));

                           ir_expression *const r3E83 = equal(r3E4F, body.constant(0u));
                           ir_expression *const r3E84 = expr(ir_unop_b2i, r3E83);
                           ir_expression *const r3E85 = expr(ir_unop_i2u, r3E84);
                           ir_expression *const r3E86 = add(r3E4F, r3E85);
                           ir_expression *const r3E87 = bit_and(r3E86, body.constant(1u));
                           ir_expression *const r3E88 = expr(ir_unop_bit_not, r3E87);
                           body.emit(assign(r3E4E, bit_and(r3E7F, r3E88), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E7E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3E8A = bit_or(r3E4D, r3E4E);
                           ir_expression *const r3E8B = equal(r3E8A, body.constant(0u));
                           ir_if *f3E89 = new(mem_ctx) ir_if(operand(r3E8B).val);
                           exec_list *const f3E89_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3E89->then_instructions;

                              body.emit(assign(r3E4C, body.constant(int(0)), 0x01));


                           body.instructions = f3E89_parent_instructions;
                           body.emit(f3E89);

                           /* END IF */


                        body.instructions = f3E7E_parent_instructions;
                        body.emit(f3E7E);

                        /* END IF */

                        ir_variable *const r3E8C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3E8C);
                        ir_expression *const r3E8D = lshift(r3B94, body.constant(int(31)));
                        ir_expression *const r3E8E = expr(ir_unop_i2u, r3E4C);
                        ir_expression *const r3E8F = lshift(r3E8E, body.constant(int(20)));
                        ir_expression *const r3E90 = add(r3E8D, r3E8F);
                        body.emit(assign(r3E8C, add(r3E90, r3E4D), 0x02));

                        body.emit(assign(r3E8C, r3E4E, 0x01));

                        body.emit(assign(r3E51, r3E8C, 0x03));

                        body.emit(assign(r3E50, body.constant(false), 0x01));


                     body.instructions = f3E7D_parent_instructions;
                     body.emit(f3E7D);

                     /* END IF */

                     body.emit(assign(r3B95, r3E51, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3E05->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3E92 = less(r3B9A, r3B9C);
                     ir_if *f3E91 = new(mem_ctx) ir_if(operand(r3E92).val);
                     exec_list *const f3E91_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E91->then_instructions;

                        ir_variable *const r3E93 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r3E94 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r3E94, sub(r3B9C, r3B9A), 0x01));

                        ir_expression *const r3E95 = sub(r3B9B, r3B99);
                        ir_expression *const r3E96 = less(r3B9C, r3B9A);
                        ir_expression *const r3E97 = expr(ir_unop_b2i, r3E96);
                        ir_expression *const r3E98 = expr(ir_unop_i2u, r3E97);
                        body.emit(assign(r3E93, sub(r3E95, r3E98), 0x01));

                        body.emit(assign(r3B9D, add(r3B98, body.constant(int(-1))), 0x01));

                        ir_variable *const r3E99 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3E99, add(r3B9D, body.constant(int(-10))), 0x01));

                        ir_variable *const r3E9A = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3E9A, r3E93, 0x01));

                        ir_variable *const r3E9B = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3E9B, r3E94, 0x01));

                        ir_variable *const r3E9C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r3E9C);
                        ir_variable *const r3E9D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r3E9D);
                        /* IF CONDITION */
                        ir_expression *const r3E9F = equal(r3E93, body.constant(0u));
                        ir_if *f3E9E = new(mem_ctx) ir_if(operand(r3E9F).val);
                        exec_list *const f3E9E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E9E->then_instructions;

                           body.emit(assign(r3E9A, r3E94, 0x01));

                           body.emit(assign(r3E9B, body.constant(0u), 0x01));

                           body.emit(assign(r3E99, add(r3E99, body.constant(int(-32))), 0x01));


                        body.instructions = f3E9E_parent_instructions;
                        body.emit(f3E9E);

                        /* END IF */

                        ir_variable *const r3EA0 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r3EA0, r3E9A, 0x01));

                        ir_variable *const r3EA1 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r3EA2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r3EA2);
                        /* IF CONDITION */
                        ir_expression *const r3EA4 = equal(r3E9A, body.constant(0u));
                        ir_if *f3EA3 = new(mem_ctx) ir_if(operand(r3EA4).val);
                        exec_list *const f3EA3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3EA3->then_instructions;

                           body.emit(assign(r3EA1, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3EA3->else_instructions;

                           body.emit(assign(r3EA2, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3EA6 = bit_and(r3E9A, body.constant(4294901760u));
                           ir_expression *const r3EA7 = equal(r3EA6, body.constant(0u));
                           ir_if *f3EA5 = new(mem_ctx) ir_if(operand(r3EA7).val);
                           exec_list *const f3EA5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EA5->then_instructions;

                              body.emit(assign(r3EA2, body.constant(int(16)), 0x01));

                              body.emit(assign(r3EA0, lshift(r3E9A, body.constant(int(16))), 0x01));


                           body.instructions = f3EA5_parent_instructions;
                           body.emit(f3EA5);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3EA9 = bit_and(r3EA0, body.constant(4278190080u));
                           ir_expression *const r3EAA = equal(r3EA9, body.constant(0u));
                           ir_if *f3EA8 = new(mem_ctx) ir_if(operand(r3EAA).val);
                           exec_list *const f3EA8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EA8->then_instructions;

                              body.emit(assign(r3EA2, add(r3EA2, body.constant(int(8))), 0x01));

                              body.emit(assign(r3EA0, lshift(r3EA0, body.constant(int(8))), 0x01));


                           body.instructions = f3EA8_parent_instructions;
                           body.emit(f3EA8);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3EAC = bit_and(r3EA0, body.constant(4026531840u));
                           ir_expression *const r3EAD = equal(r3EAC, body.constant(0u));
                           ir_if *f3EAB = new(mem_ctx) ir_if(operand(r3EAD).val);
                           exec_list *const f3EAB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EAB->then_instructions;

                              body.emit(assign(r3EA2, add(r3EA2, body.constant(int(4))), 0x01));

                              body.emit(assign(r3EA0, lshift(r3EA0, body.constant(int(4))), 0x01));


                           body.instructions = f3EAB_parent_instructions;
                           body.emit(f3EAB);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3EAF = bit_and(r3EA0, body.constant(3221225472u));
                           ir_expression *const r3EB0 = equal(r3EAF, body.constant(0u));
                           ir_if *f3EAE = new(mem_ctx) ir_if(operand(r3EB0).val);
                           exec_list *const f3EAE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EAE->then_instructions;

                              body.emit(assign(r3EA2, add(r3EA2, body.constant(int(2))), 0x01));

                              body.emit(assign(r3EA0, lshift(r3EA0, body.constant(int(2))), 0x01));


                           body.instructions = f3EAE_parent_instructions;
                           body.emit(f3EAE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3EB2 = bit_and(r3EA0, body.constant(2147483648u));
                           ir_expression *const r3EB3 = equal(r3EB2, body.constant(0u));
                           ir_if *f3EB1 = new(mem_ctx) ir_if(operand(r3EB3).val);
                           exec_list *const f3EB1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EB1->then_instructions;

                              body.emit(assign(r3EA2, add(r3EA2, body.constant(int(1))), 0x01));


                           body.instructions = f3EB1_parent_instructions;
                           body.emit(f3EB1);

                           /* END IF */

                           body.emit(assign(r3EA1, r3EA2, 0x01));


                        body.instructions = f3EA3_parent_instructions;
                        body.emit(f3EA3);

                        /* END IF */

                        body.emit(assign(r3E9D, add(r3EA1, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3EB5 = lequal(body.constant(int(0)), r3E9D);
                        ir_if *f3EB4 = new(mem_ctx) ir_if(operand(r3EB5).val);
                        exec_list *const f3EB4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3EB4->then_instructions;

                           body.emit(assign(r3E9C, body.constant(0u), 0x01));

                           ir_variable *const r3EB6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3EB6, lshift(r3E9B, r3E9D), 0x01));

                           ir_variable *const r3EB7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3EB9 = equal(r3E9D, body.constant(int(0)));
                           ir_if *f3EB8 = new(mem_ctx) ir_if(operand(r3EB9).val);
                           exec_list *const f3EB8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EB8->then_instructions;

                              body.emit(assign(r3EB7, r3E9A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3EB8->else_instructions;

                              ir_expression *const r3EBA = lshift(r3E9A, r3E9D);
                              ir_expression *const r3EBB = neg(r3E9D);
                              ir_expression *const r3EBC = bit_and(r3EBB, body.constant(int(31)));
                              ir_expression *const r3EBD = rshift(r3E9B, r3EBC);
                              body.emit(assign(r3EB7, bit_or(r3EBA, r3EBD), 0x01));


                           body.instructions = f3EB8_parent_instructions;
                           body.emit(f3EB8);

                           /* END IF */

                           body.emit(assign(r3E9A, r3EB7, 0x01));

                           body.emit(assign(r3E9B, r3EB6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3EB4->else_instructions;

                           ir_variable *const r3EBE = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3EBE, body.constant(0u), 0x01));

                           ir_variable *const r3EBF = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3EBF, neg(r3E9D), 0x01));

                           ir_variable *const r3EC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3EC0);
                           ir_variable *const r3EC1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3EC1);
                           ir_variable *const r3EC2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3EC2);
                           ir_variable *const r3EC3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3EC4 = neg(r3EBF);
                           body.emit(assign(r3EC3, bit_and(r3EC4, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3EC6 = equal(r3EBF, body.constant(int(0)));
                           ir_if *f3EC5 = new(mem_ctx) ir_if(operand(r3EC6).val);
                           exec_list *const f3EC5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EC5->then_instructions;

                              body.emit(assign(r3EC0, r3EBE, 0x01));

                              body.emit(assign(r3EC1, r3E9B, 0x01));

                              body.emit(assign(r3EC2, r3E9A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3EC5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3EC8 = less(r3EBF, body.constant(int(32)));
                              ir_if *f3EC7 = new(mem_ctx) ir_if(operand(r3EC8).val);
                              exec_list *const f3EC7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3EC7->then_instructions;

                                 body.emit(assign(r3EC0, lshift(r3E9B, r3EC3), 0x01));

                                 ir_expression *const r3EC9 = lshift(r3E9A, r3EC3);
                                 ir_expression *const r3ECA = rshift(r3E9B, r3EBF);
                                 body.emit(assign(r3EC1, bit_or(r3EC9, r3ECA), 0x01));

                                 body.emit(assign(r3EC2, rshift(r3E9A, r3EBF), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3EC7->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3ECC = equal(r3EBF, body.constant(int(32)));
                                 ir_if *f3ECB = new(mem_ctx) ir_if(operand(r3ECC).val);
                                 exec_list *const f3ECB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3ECB->then_instructions;

                                    body.emit(assign(r3EC0, r3E9B, 0x01));

                                    body.emit(assign(r3EC1, r3E9A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3ECB->else_instructions;

                                    body.emit(assign(r3EBE, bit_or(body.constant(0u), r3E9B), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3ECE = less(r3EBF, body.constant(int(64)));
                                    ir_if *f3ECD = new(mem_ctx) ir_if(operand(r3ECE).val);
                                    exec_list *const f3ECD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3ECD->then_instructions;

                                       body.emit(assign(r3EC0, lshift(r3E9A, r3EC3), 0x01));

                                       ir_expression *const r3ECF = bit_and(r3EBF, body.constant(int(31)));
                                       body.emit(assign(r3EC1, rshift(r3E9A, r3ECF), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3ECD->else_instructions;

                                       ir_variable *const r3ED0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3ED2 = equal(r3EBF, body.constant(int(64)));
                                       ir_if *f3ED1 = new(mem_ctx) ir_if(operand(r3ED2).val);
                                       exec_list *const f3ED1_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3ED1->then_instructions;

                                          body.emit(assign(r3ED0, r3E9A, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3ED1->else_instructions;

                                          ir_expression *const r3ED3 = nequal(r3E9A, body.constant(0u));
                                          ir_expression *const r3ED4 = expr(ir_unop_b2i, r3ED3);
                                          body.emit(assign(r3ED0, expr(ir_unop_i2u, r3ED4), 0x01));


                                       body.instructions = f3ED1_parent_instructions;
                                       body.emit(f3ED1);

                                       /* END IF */

                                       body.emit(assign(r3EC0, r3ED0, 0x01));

                                       body.emit(assign(r3EC1, body.constant(0u), 0x01));


                                    body.instructions = f3ECD_parent_instructions;
                                    body.emit(f3ECD);

                                    /* END IF */


                                 body.instructions = f3ECB_parent_instructions;
                                 body.emit(f3ECB);

                                 /* END IF */

                                 body.emit(assign(r3EC2, body.constant(0u), 0x01));


                              body.instructions = f3EC7_parent_instructions;
                              body.emit(f3EC7);

                              /* END IF */

                              ir_expression *const r3ED5 = nequal(r3EBE, body.constant(0u));
                              ir_expression *const r3ED6 = expr(ir_unop_b2i, r3ED5);
                              ir_expression *const r3ED7 = expr(ir_unop_i2u, r3ED6);
                              body.emit(assign(r3EC0, bit_or(r3EC0, r3ED7), 0x01));


                           body.instructions = f3EC5_parent_instructions;
                           body.emit(f3EC5);

                           /* END IF */

                           body.emit(assign(r3E9A, r3EC2, 0x01));

                           body.emit(assign(r3E9B, r3EC1, 0x01));

                           body.emit(assign(r3E9C, r3EC0, 0x01));


                        body.instructions = f3EB4_parent_instructions;
                        body.emit(f3EB4);

                        /* END IF */

                        body.emit(assign(r3E99, sub(r3E99, r3E9D), 0x01));

                        ir_variable *const r3ED8 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3ED8, r3E99, 0x01));

                        ir_variable *const r3ED9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3ED9, r3E9A, 0x01));

                        ir_variable *const r3EDA = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3EDA, r3E9B, 0x01));

                        ir_variable *const r3EDB = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r3EDB, r3E9C, 0x01));

                        ir_variable *const r3EDC = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r3EDC, body.constant(true), 0x01));

                        ir_variable *const r3EDD = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r3EDE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r3EDE);
                        ir_expression *const r3EDF = expr(ir_unop_u2i, r3E9C);
                        body.emit(assign(r3EDE, less(r3EDF, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3EE1 = lequal(body.constant(int(2045)), r3E99);
                        ir_if *f3EE0 = new(mem_ctx) ir_if(operand(r3EE1).val);
                        exec_list *const f3EE0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3EE0->then_instructions;

                           ir_variable *const r3EE2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3EE4 = less(body.constant(int(2045)), r3E99);
                           ir_if *f3EE3 = new(mem_ctx) ir_if(operand(r3EE4).val);
                           exec_list *const f3EE3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EE3->then_instructions;

                              body.emit(assign(r3EE2, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3EE3->else_instructions;

                              ir_variable *const r3EE5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3EE7 = equal(r3E99, body.constant(int(2045)));
                              ir_if *f3EE6 = new(mem_ctx) ir_if(operand(r3EE7).val);
                              exec_list *const f3EE6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3EE6->then_instructions;

                                 ir_expression *const r3EE8 = equal(body.constant(2097151u), r3E9A);
                                 ir_expression *const r3EE9 = equal(body.constant(4294967295u), r3E9B);
                                 body.emit(assign(r3EE5, logic_and(r3EE8, r3EE9), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3EE6->else_instructions;

                                 body.emit(assign(r3EE5, body.constant(false), 0x01));


                              body.instructions = f3EE6_parent_instructions;
                              body.emit(f3EE6);

                              /* END IF */

                              body.emit(assign(r3EE2, logic_and(r3EE5, r3EDE), 0x01));


                           body.instructions = f3EE3_parent_instructions;
                           body.emit(f3EE3);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3EEA = new(mem_ctx) ir_if(operand(r3EE2).val);
                           exec_list *const f3EEA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EEA->then_instructions;

                              ir_variable *const r3EEB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3EEB);
                              ir_expression *const r3EEC = lshift(r3B94, body.constant(int(31)));
                              body.emit(assign(r3EEB, add(r3EEC, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r3EEB, body.constant(0u), 0x01));

                              body.emit(assign(r3EDD, r3EEB, 0x03));

                              body.emit(assign(r3EDC, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3EEA->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3EEE = less(r3E99, body.constant(int(0)));
                              ir_if *f3EED = new(mem_ctx) ir_if(operand(r3EEE).val);
                              exec_list *const f3EED_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3EED->then_instructions;

                                 ir_variable *const r3EEF = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r3EEF, r3E9C, 0x01));

                                 ir_variable *const r3EF0 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r3EF0, neg(r3E99), 0x01));

                                 ir_variable *const r3EF1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r3EF1);
                                 ir_variable *const r3EF2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r3EF2);
                                 ir_variable *const r3EF3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r3EF3);
                                 ir_variable *const r3EF4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r3EF5 = neg(r3EF0);
                                 body.emit(assign(r3EF4, bit_and(r3EF5, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3EF7 = equal(r3EF0, body.constant(int(0)));
                                 ir_if *f3EF6 = new(mem_ctx) ir_if(operand(r3EF7).val);
                                 exec_list *const f3EF6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3EF6->then_instructions;

                                    body.emit(assign(r3EF1, r3E9C, 0x01));

                                    body.emit(assign(r3EF2, r3E9B, 0x01));

                                    body.emit(assign(r3EF3, r3E9A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3EF6->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3EF9 = less(r3EF0, body.constant(int(32)));
                                    ir_if *f3EF8 = new(mem_ctx) ir_if(operand(r3EF9).val);
                                    exec_list *const f3EF8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3EF8->then_instructions;

                                       body.emit(assign(r3EF1, lshift(r3E9B, r3EF4), 0x01));

                                       ir_expression *const r3EFA = lshift(r3E9A, r3EF4);
                                       ir_expression *const r3EFB = rshift(r3E9B, r3EF0);
                                       body.emit(assign(r3EF2, bit_or(r3EFA, r3EFB), 0x01));

                                       body.emit(assign(r3EF3, rshift(r3E9A, r3EF0), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3EF8->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3EFD = equal(r3EF0, body.constant(int(32)));
                                       ir_if *f3EFC = new(mem_ctx) ir_if(operand(r3EFD).val);
                                       exec_list *const f3EFC_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3EFC->then_instructions;

                                          body.emit(assign(r3EF1, r3E9B, 0x01));

                                          body.emit(assign(r3EF2, r3E9A, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3EFC->else_instructions;

                                          body.emit(assign(r3EEF, bit_or(r3E9C, r3E9B), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r3EFF = less(r3EF0, body.constant(int(64)));
                                          ir_if *f3EFE = new(mem_ctx) ir_if(operand(r3EFF).val);
                                          exec_list *const f3EFE_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3EFE->then_instructions;

                                             body.emit(assign(r3EF1, lshift(r3E9A, r3EF4), 0x01));

                                             ir_expression *const r3F00 = bit_and(r3EF0, body.constant(int(31)));
                                             body.emit(assign(r3EF2, rshift(r3E9A, r3F00), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3EFE->else_instructions;

                                             ir_variable *const r3F01 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r3F03 = equal(r3EF0, body.constant(int(64)));
                                             ir_if *f3F02 = new(mem_ctx) ir_if(operand(r3F03).val);
                                             exec_list *const f3F02_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3F02->then_instructions;

                                                body.emit(assign(r3F01, r3E9A, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3F02->else_instructions;

                                                ir_expression *const r3F04 = nequal(r3E9A, body.constant(0u));
                                                ir_expression *const r3F05 = expr(ir_unop_b2i, r3F04);
                                                body.emit(assign(r3F01, expr(ir_unop_i2u, r3F05), 0x01));


                                             body.instructions = f3F02_parent_instructions;
                                             body.emit(f3F02);

                                             /* END IF */

                                             body.emit(assign(r3EF1, r3F01, 0x01));

                                             body.emit(assign(r3EF2, body.constant(0u), 0x01));


                                          body.instructions = f3EFE_parent_instructions;
                                          body.emit(f3EFE);

                                          /* END IF */


                                       body.instructions = f3EFC_parent_instructions;
                                       body.emit(f3EFC);

                                       /* END IF */

                                       body.emit(assign(r3EF3, body.constant(0u), 0x01));


                                    body.instructions = f3EF8_parent_instructions;
                                    body.emit(f3EF8);

                                    /* END IF */

                                    ir_expression *const r3F06 = nequal(r3EEF, body.constant(0u));
                                    ir_expression *const r3F07 = expr(ir_unop_b2i, r3F06);
                                    ir_expression *const r3F08 = expr(ir_unop_i2u, r3F07);
                                    body.emit(assign(r3EF1, bit_or(r3EF1, r3F08), 0x01));


                                 body.instructions = f3EF6_parent_instructions;
                                 body.emit(f3EF6);

                                 /* END IF */

                                 body.emit(assign(r3ED9, r3EF3, 0x01));

                                 body.emit(assign(r3EDA, r3EF2, 0x01));

                                 body.emit(assign(r3EDB, r3EF1, 0x01));

                                 body.emit(assign(r3ED8, body.constant(int(0)), 0x01));

                                 body.emit(assign(r3EDE, less(r3EF1, body.constant(0u)), 0x01));


                              body.instructions = f3EED_parent_instructions;
                              body.emit(f3EED);

                              /* END IF */


                           body.instructions = f3EEA_parent_instructions;
                           body.emit(f3EEA);

                           /* END IF */


                        body.instructions = f3EE0_parent_instructions;
                        body.emit(f3EE0);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3F09 = new(mem_ctx) ir_if(operand(r3EDC).val);
                        exec_list *const f3F09_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3F09->then_instructions;

                           /* IF CONDITION */
                           ir_if *f3F0A = new(mem_ctx) ir_if(operand(r3EDE).val);
                           exec_list *const f3F0A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F0A->then_instructions;

                              ir_variable *const r3F0B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r3F0B, add(r3EDA, body.constant(1u)), 0x01));

                              ir_expression *const r3F0C = less(r3F0B, r3EDA);
                              ir_expression *const r3F0D = expr(ir_unop_b2i, r3F0C);
                              ir_expression *const r3F0E = expr(ir_unop_i2u, r3F0D);
                              body.emit(assign(r3ED9, add(r3ED9, r3F0E), 0x01));

                              ir_expression *const r3F0F = equal(r3EDB, body.constant(0u));
                              ir_expression *const r3F10 = expr(ir_unop_b2i, r3F0F);
                              ir_expression *const r3F11 = expr(ir_unop_i2u, r3F10);
                              ir_expression *const r3F12 = add(r3EDB, r3F11);
                              ir_expression *const r3F13 = bit_and(r3F12, body.constant(1u));
                              ir_expression *const r3F14 = expr(ir_unop_bit_not, r3F13);
                              body.emit(assign(r3EDA, bit_and(r3F0B, r3F14), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3F0A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3F16 = bit_or(r3ED9, r3EDA);
                              ir_expression *const r3F17 = equal(r3F16, body.constant(0u));
                              ir_if *f3F15 = new(mem_ctx) ir_if(operand(r3F17).val);
                              exec_list *const f3F15_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F15->then_instructions;

                                 body.emit(assign(r3ED8, body.constant(int(0)), 0x01));


                              body.instructions = f3F15_parent_instructions;
                              body.emit(f3F15);

                              /* END IF */


                           body.instructions = f3F0A_parent_instructions;
                           body.emit(f3F0A);

                           /* END IF */

                           ir_variable *const r3F18 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3F18);
                           ir_expression *const r3F19 = lshift(r3B94, body.constant(int(31)));
                           ir_expression *const r3F1A = expr(ir_unop_i2u, r3ED8);
                           ir_expression *const r3F1B = lshift(r3F1A, body.constant(int(20)));
                           ir_expression *const r3F1C = add(r3F19, r3F1B);
                           body.emit(assign(r3F18, add(r3F1C, r3ED9), 0x02));

                           body.emit(assign(r3F18, r3EDA, 0x01));

                           body.emit(assign(r3EDD, r3F18, 0x03));

                           body.emit(assign(r3EDC, body.constant(false), 0x01));


                        body.instructions = f3F09_parent_instructions;
                        body.emit(f3F09);

                        /* END IF */

                        body.emit(assign(r3B95, r3EDD, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3E91->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3F1E = less(r3B9C, r3B9A);
                        ir_if *f3F1D = new(mem_ctx) ir_if(operand(r3F1E).val);
                        exec_list *const f3F1D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3F1D->then_instructions;

                           ir_variable *const r3F1F = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r3F20 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3F20, sub(r3B9A, r3B9C), 0x01));

                           ir_expression *const r3F21 = sub(r3B99, r3B9B);
                           ir_expression *const r3F22 = less(r3B9A, r3B9C);
                           ir_expression *const r3F23 = expr(ir_unop_b2i, r3F22);
                           ir_expression *const r3F24 = expr(ir_unop_i2u, r3F23);
                           body.emit(assign(r3F1F, sub(r3F21, r3F24), 0x01));

                           body.emit(assign(r3B94, bit_xor(r3B94, body.constant(1u)), 0x01));

                           body.emit(assign(r3B9D, add(r3B97, body.constant(int(-1))), 0x01));

                           ir_variable *const r3F25 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3F25, add(r3B9D, body.constant(int(-10))), 0x01));

                           ir_variable *const r3F26 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3F26, r3F1F, 0x01));

                           ir_variable *const r3F27 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3F27, r3F20, 0x01));

                           ir_variable *const r3F28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r3F28);
                           ir_variable *const r3F29 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r3F29);
                           /* IF CONDITION */
                           ir_expression *const r3F2B = equal(r3F1F, body.constant(0u));
                           ir_if *f3F2A = new(mem_ctx) ir_if(operand(r3F2B).val);
                           exec_list *const f3F2A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F2A->then_instructions;

                              body.emit(assign(r3F26, r3F20, 0x01));

                              body.emit(assign(r3F27, body.constant(0u), 0x01));

                              body.emit(assign(r3F25, add(r3F25, body.constant(int(-32))), 0x01));


                           body.instructions = f3F2A_parent_instructions;
                           body.emit(f3F2A);

                           /* END IF */

                           ir_variable *const r3F2C = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r3F2C, r3F26, 0x01));

                           ir_variable *const r3F2D = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r3F2E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r3F2E);
                           /* IF CONDITION */
                           ir_expression *const r3F30 = equal(r3F26, body.constant(0u));
                           ir_if *f3F2F = new(mem_ctx) ir_if(operand(r3F30).val);
                           exec_list *const f3F2F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F2F->then_instructions;

                              body.emit(assign(r3F2D, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3F2F->else_instructions;

                              body.emit(assign(r3F2E, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3F32 = bit_and(r3F26, body.constant(4294901760u));
                              ir_expression *const r3F33 = equal(r3F32, body.constant(0u));
                              ir_if *f3F31 = new(mem_ctx) ir_if(operand(r3F33).val);
                              exec_list *const f3F31_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F31->then_instructions;

                                 body.emit(assign(r3F2E, body.constant(int(16)), 0x01));

                                 body.emit(assign(r3F2C, lshift(r3F26, body.constant(int(16))), 0x01));


                              body.instructions = f3F31_parent_instructions;
                              body.emit(f3F31);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3F35 = bit_and(r3F2C, body.constant(4278190080u));
                              ir_expression *const r3F36 = equal(r3F35, body.constant(0u));
                              ir_if *f3F34 = new(mem_ctx) ir_if(operand(r3F36).val);
                              exec_list *const f3F34_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F34->then_instructions;

                                 body.emit(assign(r3F2E, add(r3F2E, body.constant(int(8))), 0x01));

                                 body.emit(assign(r3F2C, lshift(r3F2C, body.constant(int(8))), 0x01));


                              body.instructions = f3F34_parent_instructions;
                              body.emit(f3F34);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3F38 = bit_and(r3F2C, body.constant(4026531840u));
                              ir_expression *const r3F39 = equal(r3F38, body.constant(0u));
                              ir_if *f3F37 = new(mem_ctx) ir_if(operand(r3F39).val);
                              exec_list *const f3F37_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F37->then_instructions;

                                 body.emit(assign(r3F2E, add(r3F2E, body.constant(int(4))), 0x01));

                                 body.emit(assign(r3F2C, lshift(r3F2C, body.constant(int(4))), 0x01));


                              body.instructions = f3F37_parent_instructions;
                              body.emit(f3F37);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3F3B = bit_and(r3F2C, body.constant(3221225472u));
                              ir_expression *const r3F3C = equal(r3F3B, body.constant(0u));
                              ir_if *f3F3A = new(mem_ctx) ir_if(operand(r3F3C).val);
                              exec_list *const f3F3A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F3A->then_instructions;

                                 body.emit(assign(r3F2E, add(r3F2E, body.constant(int(2))), 0x01));

                                 body.emit(assign(r3F2C, lshift(r3F2C, body.constant(int(2))), 0x01));


                              body.instructions = f3F3A_parent_instructions;
                              body.emit(f3F3A);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3F3E = bit_and(r3F2C, body.constant(2147483648u));
                              ir_expression *const r3F3F = equal(r3F3E, body.constant(0u));
                              ir_if *f3F3D = new(mem_ctx) ir_if(operand(r3F3F).val);
                              exec_list *const f3F3D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F3D->then_instructions;

                                 body.emit(assign(r3F2E, add(r3F2E, body.constant(int(1))), 0x01));


                              body.instructions = f3F3D_parent_instructions;
                              body.emit(f3F3D);

                              /* END IF */

                              body.emit(assign(r3F2D, r3F2E, 0x01));


                           body.instructions = f3F2F_parent_instructions;
                           body.emit(f3F2F);

                           /* END IF */

                           body.emit(assign(r3F29, add(r3F2D, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3F41 = lequal(body.constant(int(0)), r3F29);
                           ir_if *f3F40 = new(mem_ctx) ir_if(operand(r3F41).val);
                           exec_list *const f3F40_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F40->then_instructions;

                              body.emit(assign(r3F28, body.constant(0u), 0x01));

                              ir_variable *const r3F42 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r3F42, lshift(r3F27, r3F29), 0x01));

                              ir_variable *const r3F43 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3F45 = equal(r3F29, body.constant(int(0)));
                              ir_if *f3F44 = new(mem_ctx) ir_if(operand(r3F45).val);
                              exec_list *const f3F44_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F44->then_instructions;

                                 body.emit(assign(r3F43, r3F26, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F44->else_instructions;

                                 ir_expression *const r3F46 = lshift(r3F26, r3F29);
                                 ir_expression *const r3F47 = neg(r3F29);
                                 ir_expression *const r3F48 = bit_and(r3F47, body.constant(int(31)));
                                 ir_expression *const r3F49 = rshift(r3F27, r3F48);
                                 body.emit(assign(r3F43, bit_or(r3F46, r3F49), 0x01));


                              body.instructions = f3F44_parent_instructions;
                              body.emit(f3F44);

                              /* END IF */

                              body.emit(assign(r3F26, r3F43, 0x01));

                              body.emit(assign(r3F27, r3F42, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3F40->else_instructions;

                              ir_variable *const r3F4A = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3F4A, body.constant(0u), 0x01));

                              ir_variable *const r3F4B = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3F4B, neg(r3F29), 0x01));

                              ir_variable *const r3F4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3F4C);
                              ir_variable *const r3F4D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3F4D);
                              ir_variable *const r3F4E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3F4E);
                              ir_variable *const r3F4F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3F50 = neg(r3F4B);
                              body.emit(assign(r3F4F, bit_and(r3F50, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3F52 = equal(r3F4B, body.constant(int(0)));
                              ir_if *f3F51 = new(mem_ctx) ir_if(operand(r3F52).val);
                              exec_list *const f3F51_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F51->then_instructions;

                                 body.emit(assign(r3F4C, r3F4A, 0x01));

                                 body.emit(assign(r3F4D, r3F27, 0x01));

                                 body.emit(assign(r3F4E, r3F26, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F51->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3F54 = less(r3F4B, body.constant(int(32)));
                                 ir_if *f3F53 = new(mem_ctx) ir_if(operand(r3F54).val);
                                 exec_list *const f3F53_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3F53->then_instructions;

                                    body.emit(assign(r3F4C, lshift(r3F27, r3F4F), 0x01));

                                    ir_expression *const r3F55 = lshift(r3F26, r3F4F);
                                    ir_expression *const r3F56 = rshift(r3F27, r3F4B);
                                    body.emit(assign(r3F4D, bit_or(r3F55, r3F56), 0x01));

                                    body.emit(assign(r3F4E, rshift(r3F26, r3F4B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3F53->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3F58 = equal(r3F4B, body.constant(int(32)));
                                    ir_if *f3F57 = new(mem_ctx) ir_if(operand(r3F58).val);
                                    exec_list *const f3F57_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3F57->then_instructions;

                                       body.emit(assign(r3F4C, r3F27, 0x01));

                                       body.emit(assign(r3F4D, r3F26, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3F57->else_instructions;

                                       body.emit(assign(r3F4A, bit_or(body.constant(0u), r3F27), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3F5A = less(r3F4B, body.constant(int(64)));
                                       ir_if *f3F59 = new(mem_ctx) ir_if(operand(r3F5A).val);
                                       exec_list *const f3F59_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3F59->then_instructions;

                                          body.emit(assign(r3F4C, lshift(r3F26, r3F4F), 0x01));

                                          ir_expression *const r3F5B = bit_and(r3F4B, body.constant(int(31)));
                                          body.emit(assign(r3F4D, rshift(r3F26, r3F5B), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3F59->else_instructions;

                                          ir_variable *const r3F5C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3F5E = equal(r3F4B, body.constant(int(64)));
                                          ir_if *f3F5D = new(mem_ctx) ir_if(operand(r3F5E).val);
                                          exec_list *const f3F5D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3F5D->then_instructions;

                                             body.emit(assign(r3F5C, r3F26, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3F5D->else_instructions;

                                             ir_expression *const r3F5F = nequal(r3F26, body.constant(0u));
                                             ir_expression *const r3F60 = expr(ir_unop_b2i, r3F5F);
                                             body.emit(assign(r3F5C, expr(ir_unop_i2u, r3F60), 0x01));


                                          body.instructions = f3F5D_parent_instructions;
                                          body.emit(f3F5D);

                                          /* END IF */

                                          body.emit(assign(r3F4C, r3F5C, 0x01));

                                          body.emit(assign(r3F4D, body.constant(0u), 0x01));


                                       body.instructions = f3F59_parent_instructions;
                                       body.emit(f3F59);

                                       /* END IF */


                                    body.instructions = f3F57_parent_instructions;
                                    body.emit(f3F57);

                                    /* END IF */

                                    body.emit(assign(r3F4E, body.constant(0u), 0x01));


                                 body.instructions = f3F53_parent_instructions;
                                 body.emit(f3F53);

                                 /* END IF */

                                 ir_expression *const r3F61 = nequal(r3F4A, body.constant(0u));
                                 ir_expression *const r3F62 = expr(ir_unop_b2i, r3F61);
                                 ir_expression *const r3F63 = expr(ir_unop_i2u, r3F62);
                                 body.emit(assign(r3F4C, bit_or(r3F4C, r3F63), 0x01));


                              body.instructions = f3F51_parent_instructions;
                              body.emit(f3F51);

                              /* END IF */

                              body.emit(assign(r3F26, r3F4E, 0x01));

                              body.emit(assign(r3F27, r3F4D, 0x01));

                              body.emit(assign(r3F28, r3F4C, 0x01));


                           body.instructions = f3F40_parent_instructions;
                           body.emit(f3F40);

                           /* END IF */

                           body.emit(assign(r3F25, sub(r3F25, r3F29), 0x01));

                           ir_variable *const r3F64 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3F64, r3F25, 0x01));

                           ir_variable *const r3F65 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3F65, r3F26, 0x01));

                           ir_variable *const r3F66 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3F66, r3F27, 0x01));

                           ir_variable *const r3F67 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r3F67, r3F28, 0x01));

                           ir_variable *const r3F68 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r3F68, body.constant(true), 0x01));

                           ir_variable *const r3F69 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r3F6A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r3F6A);
                           ir_expression *const r3F6B = expr(ir_unop_u2i, r3F28);
                           body.emit(assign(r3F6A, less(r3F6B, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3F6D = lequal(body.constant(int(2045)), r3F25);
                           ir_if *f3F6C = new(mem_ctx) ir_if(operand(r3F6D).val);
                           exec_list *const f3F6C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F6C->then_instructions;

                              ir_variable *const r3F6E = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3F70 = less(body.constant(int(2045)), r3F25);
                              ir_if *f3F6F = new(mem_ctx) ir_if(operand(r3F70).val);
                              exec_list *const f3F6F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F6F->then_instructions;

                                 body.emit(assign(r3F6E, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F6F->else_instructions;

                                 ir_variable *const r3F71 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3F73 = equal(r3F25, body.constant(int(2045)));
                                 ir_if *f3F72 = new(mem_ctx) ir_if(operand(r3F73).val);
                                 exec_list *const f3F72_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3F72->then_instructions;

                                    ir_expression *const r3F74 = equal(body.constant(2097151u), r3F26);
                                    ir_expression *const r3F75 = equal(body.constant(4294967295u), r3F27);
                                    body.emit(assign(r3F71, logic_and(r3F74, r3F75), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3F72->else_instructions;

                                    body.emit(assign(r3F71, body.constant(false), 0x01));


                                 body.instructions = f3F72_parent_instructions;
                                 body.emit(f3F72);

                                 /* END IF */

                                 body.emit(assign(r3F6E, logic_and(r3F71, r3F6A), 0x01));


                              body.instructions = f3F6F_parent_instructions;
                              body.emit(f3F6F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f3F76 = new(mem_ctx) ir_if(operand(r3F6E).val);
                              exec_list *const f3F76_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F76->then_instructions;

                                 ir_variable *const r3F77 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r3F77);
                                 ir_expression *const r3F78 = lshift(r3B94, body.constant(int(31)));
                                 body.emit(assign(r3F77, add(r3F78, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r3F77, body.constant(0u), 0x01));

                                 body.emit(assign(r3F69, r3F77, 0x03));

                                 body.emit(assign(r3F68, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F76->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3F7A = less(r3F25, body.constant(int(0)));
                                 ir_if *f3F79 = new(mem_ctx) ir_if(operand(r3F7A).val);
                                 exec_list *const f3F79_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3F79->then_instructions;

                                    ir_variable *const r3F7B = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r3F7B, r3F28, 0x01));

                                    ir_variable *const r3F7C = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r3F7C, neg(r3F25), 0x01));

                                    ir_variable *const r3F7D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r3F7D);
                                    ir_variable *const r3F7E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r3F7E);
                                    ir_variable *const r3F7F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r3F7F);
                                    ir_variable *const r3F80 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r3F81 = neg(r3F7C);
                                    body.emit(assign(r3F80, bit_and(r3F81, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3F83 = equal(r3F7C, body.constant(int(0)));
                                    ir_if *f3F82 = new(mem_ctx) ir_if(operand(r3F83).val);
                                    exec_list *const f3F82_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3F82->then_instructions;

                                       body.emit(assign(r3F7D, r3F28, 0x01));

                                       body.emit(assign(r3F7E, r3F27, 0x01));

                                       body.emit(assign(r3F7F, r3F26, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3F82->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3F85 = less(r3F7C, body.constant(int(32)));
                                       ir_if *f3F84 = new(mem_ctx) ir_if(operand(r3F85).val);
                                       exec_list *const f3F84_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3F84->then_instructions;

                                          body.emit(assign(r3F7D, lshift(r3F27, r3F80), 0x01));

                                          ir_expression *const r3F86 = lshift(r3F26, r3F80);
                                          ir_expression *const r3F87 = rshift(r3F27, r3F7C);
                                          body.emit(assign(r3F7E, bit_or(r3F86, r3F87), 0x01));

                                          body.emit(assign(r3F7F, rshift(r3F26, r3F7C), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3F84->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r3F89 = equal(r3F7C, body.constant(int(32)));
                                          ir_if *f3F88 = new(mem_ctx) ir_if(operand(r3F89).val);
                                          exec_list *const f3F88_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3F88->then_instructions;

                                             body.emit(assign(r3F7D, r3F27, 0x01));

                                             body.emit(assign(r3F7E, r3F26, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3F88->else_instructions;

                                             body.emit(assign(r3F7B, bit_or(r3F28, r3F27), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r3F8B = less(r3F7C, body.constant(int(64)));
                                             ir_if *f3F8A = new(mem_ctx) ir_if(operand(r3F8B).val);
                                             exec_list *const f3F8A_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3F8A->then_instructions;

                                                body.emit(assign(r3F7D, lshift(r3F26, r3F80), 0x01));

                                                ir_expression *const r3F8C = bit_and(r3F7C, body.constant(int(31)));
                                                body.emit(assign(r3F7E, rshift(r3F26, r3F8C), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3F8A->else_instructions;

                                                ir_variable *const r3F8D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r3F8F = equal(r3F7C, body.constant(int(64)));
                                                ir_if *f3F8E = new(mem_ctx) ir_if(operand(r3F8F).val);
                                                exec_list *const f3F8E_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3F8E->then_instructions;

                                                   body.emit(assign(r3F8D, r3F26, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3F8E->else_instructions;

                                                   ir_expression *const r3F90 = nequal(r3F26, body.constant(0u));
                                                   ir_expression *const r3F91 = expr(ir_unop_b2i, r3F90);
                                                   body.emit(assign(r3F8D, expr(ir_unop_i2u, r3F91), 0x01));


                                                body.instructions = f3F8E_parent_instructions;
                                                body.emit(f3F8E);

                                                /* END IF */

                                                body.emit(assign(r3F7D, r3F8D, 0x01));

                                                body.emit(assign(r3F7E, body.constant(0u), 0x01));


                                             body.instructions = f3F8A_parent_instructions;
                                             body.emit(f3F8A);

                                             /* END IF */


                                          body.instructions = f3F88_parent_instructions;
                                          body.emit(f3F88);

                                          /* END IF */

                                          body.emit(assign(r3F7F, body.constant(0u), 0x01));


                                       body.instructions = f3F84_parent_instructions;
                                       body.emit(f3F84);

                                       /* END IF */

                                       ir_expression *const r3F92 = nequal(r3F7B, body.constant(0u));
                                       ir_expression *const r3F93 = expr(ir_unop_b2i, r3F92);
                                       ir_expression *const r3F94 = expr(ir_unop_i2u, r3F93);
                                       body.emit(assign(r3F7D, bit_or(r3F7D, r3F94), 0x01));


                                    body.instructions = f3F82_parent_instructions;
                                    body.emit(f3F82);

                                    /* END IF */

                                    body.emit(assign(r3F65, r3F7F, 0x01));

                                    body.emit(assign(r3F66, r3F7E, 0x01));

                                    body.emit(assign(r3F67, r3F7D, 0x01));

                                    body.emit(assign(r3F64, body.constant(int(0)), 0x01));

                                    body.emit(assign(r3F6A, less(r3F7D, body.constant(0u)), 0x01));


                                 body.instructions = f3F79_parent_instructions;
                                 body.emit(f3F79);

                                 /* END IF */


                              body.instructions = f3F76_parent_instructions;
                              body.emit(f3F76);

                              /* END IF */


                           body.instructions = f3F6C_parent_instructions;
                           body.emit(f3F6C);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3F95 = new(mem_ctx) ir_if(operand(r3F68).val);
                           exec_list *const f3F95_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F95->then_instructions;

                              /* IF CONDITION */
                              ir_if *f3F96 = new(mem_ctx) ir_if(operand(r3F6A).val);
                              exec_list *const f3F96_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F96->then_instructions;

                                 ir_variable *const r3F97 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r3F97, add(r3F66, body.constant(1u)), 0x01));

                                 ir_expression *const r3F98 = less(r3F97, r3F66);
                                 ir_expression *const r3F99 = expr(ir_unop_b2i, r3F98);
                                 ir_expression *const r3F9A = expr(ir_unop_i2u, r3F99);
                                 body.emit(assign(r3F65, add(r3F65, r3F9A), 0x01));

                                 ir_expression *const r3F9B = equal(r3F67, body.constant(0u));
                                 ir_expression *const r3F9C = expr(ir_unop_b2i, r3F9B);
                                 ir_expression *const r3F9D = expr(ir_unop_i2u, r3F9C);
                                 ir_expression *const r3F9E = add(r3F67, r3F9D);
                                 ir_expression *const r3F9F = bit_and(r3F9E, body.constant(1u));
                                 ir_expression *const r3FA0 = expr(ir_unop_bit_not, r3F9F);
                                 body.emit(assign(r3F66, bit_and(r3F97, r3FA0), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F96->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3FA2 = bit_or(r3F65, r3F66);
                                 ir_expression *const r3FA3 = equal(r3FA2, body.constant(0u));
                                 ir_if *f3FA1 = new(mem_ctx) ir_if(operand(r3FA3).val);
                                 exec_list *const f3FA1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3FA1->then_instructions;

                                    body.emit(assign(r3F64, body.constant(int(0)), 0x01));


                                 body.instructions = f3FA1_parent_instructions;
                                 body.emit(f3FA1);

                                 /* END IF */


                              body.instructions = f3F96_parent_instructions;
                              body.emit(f3F96);

                              /* END IF */

                              ir_variable *const r3FA4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3FA4);
                              ir_expression *const r3FA5 = lshift(r3B94, body.constant(int(31)));
                              ir_expression *const r3FA6 = expr(ir_unop_i2u, r3F64);
                              ir_expression *const r3FA7 = lshift(r3FA6, body.constant(int(20)));
                              ir_expression *const r3FA8 = add(r3FA5, r3FA7);
                              body.emit(assign(r3FA4, add(r3FA8, r3F65), 0x02));

                              body.emit(assign(r3FA4, r3F66, 0x01));

                              body.emit(assign(r3F69, r3FA4, 0x03));

                              body.emit(assign(r3F68, body.constant(false), 0x01));


                           body.instructions = f3F95_parent_instructions;
                           body.emit(f3F95);

                           /* END IF */

                           body.emit(assign(r3B95, r3F69, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3F1D->else_instructions;

                           ir_variable *const r3FA9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3FA9);
                           body.emit(assign(r3FA9, body.constant(0u), 0x02));

                           body.emit(assign(r3FA9, body.constant(0u), 0x01));

                           body.emit(assign(r3B95, r3FA9, 0x03));


                        body.instructions = f3F1D_parent_instructions;
                        body.emit(f3F1D);

                        /* END IF */


                     body.instructions = f3E91_parent_instructions;
                     body.emit(f3E91);

                     /* END IF */


                  body.instructions = f3E05_parent_instructions;
                  body.emit(f3E05);

                  /* END IF */


               body.instructions = f3D79_parent_instructions;
               body.emit(f3D79);

               /* END IF */


            body.instructions = f3D52_parent_instructions;
            body.emit(f3D52);

            /* END IF */


         body.instructions = f3C7E_parent_instructions;
         body.emit(f3C7E);

         /* END IF */


      body.instructions = f3BAE_parent_instructions;
      body.emit(f3BAE);

      /* END IF */

      body.emit(assign(r3B8F, r3B95, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3B92->else_instructions;

      ir_variable *const r3FAA = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r3FAA, body.constant(true), 0x01));

      ir_variable *const r3FAB = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3FAC = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r3FAC);
      ir_variable *const r3FAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r3FAD);
      ir_variable *const r3FAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r3FAE);
      ir_variable *const r3FAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r3FAF);
      ir_variable *const r3FB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r3FB0);
      ir_variable *const r3FB1 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r3FB1);
      ir_variable *const r3FB2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r3FB2);
      ir_variable *const r3FB3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r3FB3);
      body.emit(assign(r3FB3, body.constant(0u), 0x01));

      body.emit(assign(r3FB2, body.constant(0u), 0x01));

      ir_variable *const r3FB4 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r3FB4, swizzle_x(r321D), 0x01));

      body.emit(assign(r3FB0, r3FB4, 0x01));

      ir_variable *const r3FB5 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r3FB5, bit_and(swizzle_y(r321D), body.constant(1048575u)), 0x01));

      body.emit(assign(r3FAF, r3FB5, 0x01));

      ir_variable *const r3FB6 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r3FB6, swizzle_x(r39DD), 0x01));

      body.emit(assign(r3FAE, r3FB6, 0x01));

      ir_variable *const r3FB7 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r3FB7, bit_and(swizzle_y(r39DD), body.constant(1048575u)), 0x01));

      body.emit(assign(r3FAD, r3FB7, 0x01));

      ir_variable *const r3FB8 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3FB9 = rshift(swizzle_y(r321D), body.constant(int(20)));
      ir_expression *const r3FBA = bit_and(r3FB9, body.constant(2047u));
      body.emit(assign(r3FB8, expr(ir_unop_u2i, r3FBA), 0x01));

      ir_variable *const r3FBB = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3FBC = rshift(swizzle_y(r39DD), body.constant(int(20)));
      ir_expression *const r3FBD = bit_and(r3FBC, body.constant(2047u));
      body.emit(assign(r3FBB, expr(ir_unop_u2i, r3FBD), 0x01));

      ir_variable *const r3FBE = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r3FBE, sub(r3FB8, r3FBB), 0x01));

      body.emit(assign(r3FAC, r3FBE, 0x01));

      /* IF CONDITION */
      ir_expression *const r3FC0 = less(body.constant(int(0)), r3FBE);
      ir_if *f3FBF = new(mem_ctx) ir_if(operand(r3FC0).val);
      exec_list *const f3FBF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3FBF->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3FC2 = equal(r3FB8, body.constant(int(2047)));
         ir_if *f3FC1 = new(mem_ctx) ir_if(operand(r3FC2).val);
         exec_list *const f3FC1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3FC1->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3FC4 = bit_or(r3FB5, swizzle_x(r321D));
            ir_expression *const r3FC5 = nequal(r3FC4, body.constant(0u));
            ir_if *f3FC3 = new(mem_ctx) ir_if(operand(r3FC5).val);
            exec_list *const f3FC3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3FC3->then_instructions;

               ir_variable *const r3FC6 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r3FC6, swizzle_x(r321D), 0x01));

               ir_variable *const r3FC7 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r3FC7, swizzle_x(r39DD), 0x01));

               ir_variable *const r3FC8 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3FC9 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3FCA = rshift(swizzle_y(r321D), body.constant(int(19)));
               ir_expression *const r3FCB = bit_and(r3FCA, body.constant(4095u));
               ir_expression *const r3FCC = equal(r3FCB, body.constant(4094u));
               ir_expression *const r3FCD = nequal(swizzle_x(r321D), body.constant(0u));
               ir_expression *const r3FCE = bit_and(swizzle_y(r321D), body.constant(524287u));
               ir_expression *const r3FCF = nequal(r3FCE, body.constant(0u));
               ir_expression *const r3FD0 = logic_or(r3FCD, r3FCF);
               body.emit(assign(r3FC9, logic_and(r3FCC, r3FD0), 0x01));

               ir_variable *const r3FD1 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r3FD2 = lshift(swizzle_y(r39DD), body.constant(int(1)));
               ir_expression *const r3FD3 = lequal(body.constant(4292870144u), r3FD2);
               ir_expression *const r3FD4 = nequal(swizzle_x(r39DD), body.constant(0u));
               ir_expression *const r3FD5 = bit_and(swizzle_y(r39DD), body.constant(1048575u));
               ir_expression *const r3FD6 = nequal(r3FD5, body.constant(0u));
               ir_expression *const r3FD7 = logic_or(r3FD4, r3FD6);
               body.emit(assign(r3FD1, logic_and(r3FD3, r3FD7), 0x01));

               body.emit(assign(r3FC6, bit_or(swizzle_y(r321D), body.constant(524288u)), 0x02));

               body.emit(assign(r3FC7, bit_or(swizzle_y(r39DD), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r3FD9 = lshift(swizzle_y(r321D), body.constant(int(1)));
               ir_expression *const r3FDA = lequal(body.constant(4292870144u), r3FD9);
               ir_expression *const r3FDB = nequal(swizzle_x(r321D), body.constant(0u));
               ir_expression *const r3FDC = bit_and(swizzle_y(r321D), body.constant(1048575u));
               ir_expression *const r3FDD = nequal(r3FDC, body.constant(0u));
               ir_expression *const r3FDE = logic_or(r3FDB, r3FDD);
               ir_expression *const r3FDF = logic_and(r3FDA, r3FDE);
               ir_if *f3FD8 = new(mem_ctx) ir_if(operand(r3FDF).val);
               exec_list *const f3FD8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3FD8->then_instructions;

                  ir_variable *const r3FE0 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3FE2 = logic_and(r3FC9, r3FD1);
                  ir_if *f3FE1 = new(mem_ctx) ir_if(operand(r3FE2).val);
                  exec_list *const f3FE1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3FE1->then_instructions;

                     body.emit(assign(r3FE0, r3FC7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3FE1->else_instructions;

                     body.emit(assign(r3FE0, r3FC6, 0x03));


                  body.instructions = f3FE1_parent_instructions;
                  body.emit(f3FE1);

                  /* END IF */

                  body.emit(assign(r3FC8, r3FE0, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3FD8->else_instructions;

                  body.emit(assign(r3FC8, r3FC7, 0x03));


               body.instructions = f3FD8_parent_instructions;
               body.emit(f3FD8);

               /* END IF */

               body.emit(assign(r3FAB, r3FC8, 0x03));

               body.emit(assign(r3FAA, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3FC3->else_instructions;

               body.emit(assign(r3FAB, r321D, 0x03));

               body.emit(assign(r3FAA, body.constant(false), 0x01));


            body.instructions = f3FC3_parent_instructions;
            body.emit(f3FC3);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3FC1->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3FE4 = equal(r3FBB, body.constant(int(0)));
            ir_if *f3FE3 = new(mem_ctx) ir_if(operand(r3FE4).val);
            exec_list *const f3FE3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3FE3->then_instructions;

               body.emit(assign(r3FAC, add(r3FBE, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3FE3->else_instructions;

               body.emit(assign(r3FAD, bit_or(r3FB7, body.constant(1048576u)), 0x01));


            body.instructions = f3FE3_parent_instructions;
            body.emit(f3FE3);

            /* END IF */

            ir_variable *const r3FE5 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r3FE5, body.constant(0u), 0x01));

            ir_variable *const r3FE6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r3FE6);
            ir_variable *const r3FE7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r3FE7);
            ir_variable *const r3FE8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r3FE8);
            ir_variable *const r3FE9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r3FEA = neg(r3FAC);
            body.emit(assign(r3FE9, bit_and(r3FEA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3FEC = equal(r3FAC, body.constant(int(0)));
            ir_if *f3FEB = new(mem_ctx) ir_if(operand(r3FEC).val);
            exec_list *const f3FEB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3FEB->then_instructions;

               body.emit(assign(r3FE6, r3FE5, 0x01));

               body.emit(assign(r3FE7, r3FB6, 0x01));

               body.emit(assign(r3FE8, r3FAD, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3FEB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3FEE = less(r3FAC, body.constant(int(32)));
               ir_if *f3FED = new(mem_ctx) ir_if(operand(r3FEE).val);
               exec_list *const f3FED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3FED->then_instructions;

                  body.emit(assign(r3FE6, lshift(swizzle_x(r39DD), r3FE9), 0x01));

                  ir_expression *const r3FEF = lshift(r3FAD, r3FE9);
                  ir_expression *const r3FF0 = rshift(swizzle_x(r39DD), r3FAC);
                  body.emit(assign(r3FE7, bit_or(r3FEF, r3FF0), 0x01));

                  body.emit(assign(r3FE8, rshift(r3FAD, r3FAC), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3FED->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3FF2 = equal(r3FAC, body.constant(int(32)));
                  ir_if *f3FF1 = new(mem_ctx) ir_if(operand(r3FF2).val);
                  exec_list *const f3FF1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3FF1->then_instructions;

                     body.emit(assign(r3FE6, r3FB6, 0x01));

                     body.emit(assign(r3FE7, r3FAD, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3FF1->else_instructions;

                     body.emit(assign(r3FE5, bit_or(body.constant(0u), swizzle_x(r39DD)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3FF4 = less(r3FAC, body.constant(int(64)));
                     ir_if *f3FF3 = new(mem_ctx) ir_if(operand(r3FF4).val);
                     exec_list *const f3FF3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3FF3->then_instructions;

                        body.emit(assign(r3FE6, lshift(r3FAD, r3FE9), 0x01));

                        ir_expression *const r3FF5 = bit_and(r3FAC, body.constant(int(31)));
                        body.emit(assign(r3FE7, rshift(r3FAD, r3FF5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3FF3->else_instructions;

                        ir_variable *const r3FF6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3FF8 = equal(r3FAC, body.constant(int(64)));
                        ir_if *f3FF7 = new(mem_ctx) ir_if(operand(r3FF8).val);
                        exec_list *const f3FF7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3FF7->then_instructions;

                           body.emit(assign(r3FF6, r3FAD, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3FF7->else_instructions;

                           ir_expression *const r3FF9 = nequal(r3FAD, body.constant(0u));
                           ir_expression *const r3FFA = expr(ir_unop_b2i, r3FF9);
                           body.emit(assign(r3FF6, expr(ir_unop_i2u, r3FFA), 0x01));


                        body.instructions = f3FF7_parent_instructions;
                        body.emit(f3FF7);

                        /* END IF */

                        body.emit(assign(r3FE6, r3FF6, 0x01));

                        body.emit(assign(r3FE7, body.constant(0u), 0x01));


                     body.instructions = f3FF3_parent_instructions;
                     body.emit(f3FF3);

                     /* END IF */


                  body.instructions = f3FF1_parent_instructions;
                  body.emit(f3FF1);

                  /* END IF */

                  body.emit(assign(r3FE8, body.constant(0u), 0x01));


               body.instructions = f3FED_parent_instructions;
               body.emit(f3FED);

               /* END IF */

               ir_expression *const r3FFB = nequal(r3FE5, body.constant(0u));
               ir_expression *const r3FFC = expr(ir_unop_b2i, r3FFB);
               ir_expression *const r3FFD = expr(ir_unop_i2u, r3FFC);
               body.emit(assign(r3FE6, bit_or(r3FE6, r3FFD), 0x01));


            body.instructions = f3FEB_parent_instructions;
            body.emit(f3FEB);

            /* END IF */

            body.emit(assign(r3FAD, r3FE8, 0x01));

            body.emit(assign(r3FAE, r3FE7, 0x01));

            body.emit(assign(r3FB2, r3FE6, 0x01));

            body.emit(assign(r3FB1, r3FB8, 0x01));


         body.instructions = f3FC1_parent_instructions;
         body.emit(f3FC1);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3FBF->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3FFF = less(r3FAC, body.constant(int(0)));
         ir_if *f3FFE = new(mem_ctx) ir_if(operand(r3FFF).val);
         exec_list *const f3FFE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3FFE->then_instructions;

            /* IF CONDITION */
            ir_expression *const r4001 = equal(r3FBB, body.constant(int(2047)));
            ir_if *f4000 = new(mem_ctx) ir_if(operand(r4001).val);
            exec_list *const f4000_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f4000->then_instructions;

               /* IF CONDITION */
               ir_expression *const r4003 = bit_or(r3FAD, r3FAE);
               ir_expression *const r4004 = nequal(r4003, body.constant(0u));
               ir_if *f4002 = new(mem_ctx) ir_if(operand(r4004).val);
               exec_list *const f4002_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4002->then_instructions;

                  ir_variable *const r4005 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r4005, swizzle_x(r321D), 0x01));

                  ir_variable *const r4006 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r4006, swizzle_x(r39DD), 0x01));

                  ir_variable *const r4007 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r4008 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r4009 = rshift(swizzle_y(r321D), body.constant(int(19)));
                  ir_expression *const r400A = bit_and(r4009, body.constant(4095u));
                  ir_expression *const r400B = equal(r400A, body.constant(4094u));
                  ir_expression *const r400C = nequal(swizzle_x(r321D), body.constant(0u));
                  ir_expression *const r400D = bit_and(swizzle_y(r321D), body.constant(524287u));
                  ir_expression *const r400E = nequal(r400D, body.constant(0u));
                  ir_expression *const r400F = logic_or(r400C, r400E);
                  body.emit(assign(r4008, logic_and(r400B, r400F), 0x01));

                  ir_variable *const r4010 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r4011 = lshift(swizzle_y(r39DD), body.constant(int(1)));
                  ir_expression *const r4012 = lequal(body.constant(4292870144u), r4011);
                  ir_expression *const r4013 = nequal(swizzle_x(r39DD), body.constant(0u));
                  ir_expression *const r4014 = bit_and(swizzle_y(r39DD), body.constant(1048575u));
                  ir_expression *const r4015 = nequal(r4014, body.constant(0u));
                  ir_expression *const r4016 = logic_or(r4013, r4015);
                  body.emit(assign(r4010, logic_and(r4012, r4016), 0x01));

                  body.emit(assign(r4005, bit_or(swizzle_y(r321D), body.constant(524288u)), 0x02));

                  body.emit(assign(r4006, bit_or(swizzle_y(r39DD), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r4018 = lshift(swizzle_y(r321D), body.constant(int(1)));
                  ir_expression *const r4019 = lequal(body.constant(4292870144u), r4018);
                  ir_expression *const r401A = nequal(swizzle_x(r321D), body.constant(0u));
                  ir_expression *const r401B = bit_and(swizzle_y(r321D), body.constant(1048575u));
                  ir_expression *const r401C = nequal(r401B, body.constant(0u));
                  ir_expression *const r401D = logic_or(r401A, r401C);
                  ir_expression *const r401E = logic_and(r4019, r401D);
                  ir_if *f4017 = new(mem_ctx) ir_if(operand(r401E).val);
                  exec_list *const f4017_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4017->then_instructions;

                     ir_variable *const r401F = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r4021 = logic_and(r4008, r4010);
                     ir_if *f4020 = new(mem_ctx) ir_if(operand(r4021).val);
                     exec_list *const f4020_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4020->then_instructions;

                        body.emit(assign(r401F, r4006, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4020->else_instructions;

                        body.emit(assign(r401F, r4005, 0x03));


                     body.instructions = f4020_parent_instructions;
                     body.emit(f4020);

                     /* END IF */

                     body.emit(assign(r4007, r401F, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f4017->else_instructions;

                     body.emit(assign(r4007, r4006, 0x03));


                  body.instructions = f4017_parent_instructions;
                  body.emit(f4017);

                  /* END IF */

                  body.emit(assign(r3FAB, r4007, 0x03));

                  body.emit(assign(r3FAA, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4002->else_instructions;

                  ir_variable *const r4022 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r4022);
                  ir_expression *const r4023 = lshift(r3B90, body.constant(int(31)));
                  body.emit(assign(r4022, add(r4023, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r4022, body.constant(0u), 0x01));

                  body.emit(assign(r3FAB, r4022, 0x03));

                  body.emit(assign(r3FAA, body.constant(false), 0x01));


               body.instructions = f4002_parent_instructions;
               body.emit(f4002);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f4000->else_instructions;

               /* IF CONDITION */
               ir_expression *const r4025 = equal(r3FB8, body.constant(int(0)));
               ir_if *f4024 = new(mem_ctx) ir_if(operand(r4025).val);
               exec_list *const f4024_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4024->then_instructions;

                  body.emit(assign(r3FAC, add(r3FAC, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4024->else_instructions;

                  body.emit(assign(r3FAF, bit_or(r3FB5, body.constant(1048576u)), 0x01));


               body.instructions = f4024_parent_instructions;
               body.emit(f4024);

               /* END IF */

               ir_variable *const r4026 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r4026, body.constant(0u), 0x01));

               ir_variable *const r4027 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r4027, neg(r3FAC), 0x01));

               ir_variable *const r4028 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r4028);
               ir_variable *const r4029 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r4029);
               ir_variable *const r402A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r402A);
               ir_variable *const r402B = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r402C = neg(r4027);
               body.emit(assign(r402B, bit_and(r402C, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r402E = equal(r4027, body.constant(int(0)));
               ir_if *f402D = new(mem_ctx) ir_if(operand(r402E).val);
               exec_list *const f402D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f402D->then_instructions;

                  body.emit(assign(r4028, r4026, 0x01));

                  body.emit(assign(r4029, r3FB4, 0x01));

                  body.emit(assign(r402A, r3FAF, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f402D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r4030 = less(r4027, body.constant(int(32)));
                  ir_if *f402F = new(mem_ctx) ir_if(operand(r4030).val);
                  exec_list *const f402F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f402F->then_instructions;

                     body.emit(assign(r4028, lshift(swizzle_x(r321D), r402B), 0x01));

                     ir_expression *const r4031 = lshift(r3FAF, r402B);
                     ir_expression *const r4032 = rshift(swizzle_x(r321D), r4027);
                     body.emit(assign(r4029, bit_or(r4031, r4032), 0x01));

                     body.emit(assign(r402A, rshift(r3FAF, r4027), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f402F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r4034 = equal(r4027, body.constant(int(32)));
                     ir_if *f4033 = new(mem_ctx) ir_if(operand(r4034).val);
                     exec_list *const f4033_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4033->then_instructions;

                        body.emit(assign(r4028, r3FB4, 0x01));

                        body.emit(assign(r4029, r3FAF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4033->else_instructions;

                        body.emit(assign(r4026, bit_or(body.constant(0u), swizzle_x(r321D)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r4036 = less(r4027, body.constant(int(64)));
                        ir_if *f4035 = new(mem_ctx) ir_if(operand(r4036).val);
                        exec_list *const f4035_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4035->then_instructions;

                           body.emit(assign(r4028, lshift(r3FAF, r402B), 0x01));

                           ir_expression *const r4037 = bit_and(r4027, body.constant(int(31)));
                           body.emit(assign(r4029, rshift(r3FAF, r4037), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f4035->else_instructions;

                           ir_variable *const r4038 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r403A = equal(r4027, body.constant(int(64)));
                           ir_if *f4039 = new(mem_ctx) ir_if(operand(r403A).val);
                           exec_list *const f4039_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4039->then_instructions;

                              body.emit(assign(r4038, r3FAF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f4039->else_instructions;

                              ir_expression *const r403B = nequal(r3FAF, body.constant(0u));
                              ir_expression *const r403C = expr(ir_unop_b2i, r403B);
                              body.emit(assign(r4038, expr(ir_unop_i2u, r403C), 0x01));


                           body.instructions = f4039_parent_instructions;
                           body.emit(f4039);

                           /* END IF */

                           body.emit(assign(r4028, r4038, 0x01));

                           body.emit(assign(r4029, body.constant(0u), 0x01));


                        body.instructions = f4035_parent_instructions;
                        body.emit(f4035);

                        /* END IF */


                     body.instructions = f4033_parent_instructions;
                     body.emit(f4033);

                     /* END IF */

                     body.emit(assign(r402A, body.constant(0u), 0x01));


                  body.instructions = f402F_parent_instructions;
                  body.emit(f402F);

                  /* END IF */

                  ir_expression *const r403D = nequal(r4026, body.constant(0u));
                  ir_expression *const r403E = expr(ir_unop_b2i, r403D);
                  ir_expression *const r403F = expr(ir_unop_i2u, r403E);
                  body.emit(assign(r4028, bit_or(r4028, r403F), 0x01));


               body.instructions = f402D_parent_instructions;
               body.emit(f402D);

               /* END IF */

               body.emit(assign(r3FAF, r402A, 0x01));

               body.emit(assign(r3FB0, r4029, 0x01));

               body.emit(assign(r3FB2, r4028, 0x01));

               body.emit(assign(r3FB1, r3FBB, 0x01));


            body.instructions = f4000_parent_instructions;
            body.emit(f4000);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3FFE->else_instructions;

            /* IF CONDITION */
            ir_expression *const r4041 = equal(r3FB8, body.constant(int(2047)));
            ir_if *f4040 = new(mem_ctx) ir_if(operand(r4041).val);
            exec_list *const f4040_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f4040->then_instructions;

               /* IF CONDITION */
               ir_expression *const r4043 = bit_or(r3FAF, r3FB0);
               ir_expression *const r4044 = bit_or(r3FAD, r3FAE);
               ir_expression *const r4045 = bit_or(r4043, r4044);
               ir_expression *const r4046 = nequal(r4045, body.constant(0u));
               ir_if *f4042 = new(mem_ctx) ir_if(operand(r4046).val);
               exec_list *const f4042_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4042->then_instructions;

                  ir_variable *const r4047 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r4047, swizzle_x(r321D), 0x01));

                  ir_variable *const r4048 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r4048, swizzle_x(r39DD), 0x01));

                  ir_variable *const r4049 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r404A = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r404B = rshift(swizzle_y(r321D), body.constant(int(19)));
                  ir_expression *const r404C = bit_and(r404B, body.constant(4095u));
                  ir_expression *const r404D = equal(r404C, body.constant(4094u));
                  ir_expression *const r404E = nequal(swizzle_x(r321D), body.constant(0u));
                  ir_expression *const r404F = bit_and(swizzle_y(r321D), body.constant(524287u));
                  ir_expression *const r4050 = nequal(r404F, body.constant(0u));
                  ir_expression *const r4051 = logic_or(r404E, r4050);
                  body.emit(assign(r404A, logic_and(r404D, r4051), 0x01));

                  ir_variable *const r4052 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r4053 = lshift(swizzle_y(r39DD), body.constant(int(1)));
                  ir_expression *const r4054 = lequal(body.constant(4292870144u), r4053);
                  ir_expression *const r4055 = nequal(swizzle_x(r39DD), body.constant(0u));
                  ir_expression *const r4056 = bit_and(swizzle_y(r39DD), body.constant(1048575u));
                  ir_expression *const r4057 = nequal(r4056, body.constant(0u));
                  ir_expression *const r4058 = logic_or(r4055, r4057);
                  body.emit(assign(r4052, logic_and(r4054, r4058), 0x01));

                  body.emit(assign(r4047, bit_or(swizzle_y(r321D), body.constant(524288u)), 0x02));

                  body.emit(assign(r4048, bit_or(swizzle_y(r39DD), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r405A = lshift(swizzle_y(r321D), body.constant(int(1)));
                  ir_expression *const r405B = lequal(body.constant(4292870144u), r405A);
                  ir_expression *const r405C = nequal(swizzle_x(r321D), body.constant(0u));
                  ir_expression *const r405D = bit_and(swizzle_y(r321D), body.constant(1048575u));
                  ir_expression *const r405E = nequal(r405D, body.constant(0u));
                  ir_expression *const r405F = logic_or(r405C, r405E);
                  ir_expression *const r4060 = logic_and(r405B, r405F);
                  ir_if *f4059 = new(mem_ctx) ir_if(operand(r4060).val);
                  exec_list *const f4059_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4059->then_instructions;

                     ir_variable *const r4061 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r4063 = logic_and(r404A, r4052);
                     ir_if *f4062 = new(mem_ctx) ir_if(operand(r4063).val);
                     exec_list *const f4062_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4062->then_instructions;

                        body.emit(assign(r4061, r4048, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4062->else_instructions;

                        body.emit(assign(r4061, r4047, 0x03));


                     body.instructions = f4062_parent_instructions;
                     body.emit(f4062);

                     /* END IF */

                     body.emit(assign(r4049, r4061, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f4059->else_instructions;

                     body.emit(assign(r4049, r4048, 0x03));


                  body.instructions = f4059_parent_instructions;
                  body.emit(f4059);

                  /* END IF */

                  body.emit(assign(r3FAB, r4049, 0x03));

                  body.emit(assign(r3FAA, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4042->else_instructions;

                  body.emit(assign(r3FAB, r321D, 0x03));

                  body.emit(assign(r3FAA, body.constant(false), 0x01));


               body.instructions = f4042_parent_instructions;
               body.emit(f4042);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f4040->else_instructions;

               ir_variable *const r4064 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r4065 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r4065, add(r3FB0, r3FAE), 0x01));

               ir_expression *const r4066 = add(r3FAF, r3FAD);
               ir_expression *const r4067 = less(r4065, r3FB0);
               ir_expression *const r4068 = expr(ir_unop_b2i, r4067);
               ir_expression *const r4069 = expr(ir_unop_i2u, r4068);
               body.emit(assign(r4064, add(r4066, r4069), 0x01));

               body.emit(assign(r3FB3, r4064, 0x01));

               /* IF CONDITION */
               ir_expression *const r406B = equal(r3FB8, body.constant(int(0)));
               ir_if *f406A = new(mem_ctx) ir_if(operand(r406B).val);
               exec_list *const f406A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f406A->then_instructions;

                  ir_variable *const r406C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r406C);
                  ir_expression *const r406D = lshift(r3B90, body.constant(int(31)));
                  body.emit(assign(r406C, add(r406D, r4064), 0x02));

                  body.emit(assign(r406C, r4065, 0x01));

                  body.emit(assign(r3FAB, r406C, 0x03));

                  body.emit(assign(r3FAA, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f406A->else_instructions;

                  body.emit(assign(r3FB3, bit_or(r4064, body.constant(2097152u)), 0x01));

                  body.emit(assign(r3FB1, r3FB8, 0x01));

                  ir_variable *const r406E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r406E);
                  ir_variable *const r406F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r406F);
                  ir_variable *const r4070 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r4070);
                  body.emit(assign(r406E, lshift(r4065, body.constant(int(31))), 0x01));

                  ir_expression *const r4071 = lshift(r3FB3, body.constant(int(31)));
                  ir_expression *const r4072 = rshift(r4065, body.constant(int(1)));
                  body.emit(assign(r406F, bit_or(r4071, r4072), 0x01));

                  body.emit(assign(r4070, rshift(r3FB3, body.constant(int(1))), 0x01));

                  body.emit(assign(r406E, bit_or(r406E, body.constant(0u)), 0x01));

                  body.emit(assign(r3FB3, r4070, 0x01));

                  body.emit(assign(r3FB2, r406E, 0x01));

                  ir_variable *const r4073 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r4073, r3FB8, 0x01));

                  ir_variable *const r4074 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r4074, r4070, 0x01));

                  ir_variable *const r4075 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r4075, r406F, 0x01));

                  ir_variable *const r4076 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r4076, r406E, 0x01));

                  ir_variable *const r4077 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r4077, body.constant(true), 0x01));

                  ir_variable *const r4078 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r4079 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r4079);
                  ir_expression *const r407A = expr(ir_unop_u2i, r406E);
                  body.emit(assign(r4079, less(r407A, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r407C = lequal(body.constant(int(2045)), r3FB8);
                  ir_if *f407B = new(mem_ctx) ir_if(operand(r407C).val);
                  exec_list *const f407B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f407B->then_instructions;

                     ir_variable *const r407D = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r407F = less(body.constant(int(2045)), r3FB8);
                     ir_if *f407E = new(mem_ctx) ir_if(operand(r407F).val);
                     exec_list *const f407E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f407E->then_instructions;

                        body.emit(assign(r407D, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f407E->else_instructions;

                        ir_variable *const r4080 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r4082 = equal(r3FB8, body.constant(int(2045)));
                        ir_if *f4081 = new(mem_ctx) ir_if(operand(r4082).val);
                        exec_list *const f4081_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4081->then_instructions;

                           ir_expression *const r4083 = equal(body.constant(2097151u), r4070);
                           ir_expression *const r4084 = equal(body.constant(4294967295u), r406F);
                           body.emit(assign(r4080, logic_and(r4083, r4084), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f4081->else_instructions;

                           body.emit(assign(r4080, body.constant(false), 0x01));


                        body.instructions = f4081_parent_instructions;
                        body.emit(f4081);

                        /* END IF */

                        body.emit(assign(r407D, logic_and(r4080, r4079), 0x01));


                     body.instructions = f407E_parent_instructions;
                     body.emit(f407E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f4085 = new(mem_ctx) ir_if(operand(r407D).val);
                     exec_list *const f4085_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4085->then_instructions;

                        ir_variable *const r4086 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r4086);
                        ir_expression *const r4087 = lshift(r3B90, body.constant(int(31)));
                        body.emit(assign(r4086, add(r4087, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r4086, body.constant(0u), 0x01));

                        body.emit(assign(r4078, r4086, 0x03));

                        body.emit(assign(r4077, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4085->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r4089 = less(r3FB8, body.constant(int(0)));
                        ir_if *f4088 = new(mem_ctx) ir_if(operand(r4089).val);
                        exec_list *const f4088_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4088->then_instructions;

                           ir_variable *const r408A = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r408A, r406E, 0x01));

                           ir_variable *const r408B = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r408B, neg(r3FB8), 0x01));

                           ir_variable *const r408C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r408C);
                           ir_variable *const r408D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r408D);
                           ir_variable *const r408E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r408E);
                           ir_variable *const r408F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r4090 = neg(r408B);
                           body.emit(assign(r408F, bit_and(r4090, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r4092 = equal(r408B, body.constant(int(0)));
                           ir_if *f4091 = new(mem_ctx) ir_if(operand(r4092).val);
                           exec_list *const f4091_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4091->then_instructions;

                              body.emit(assign(r408C, r406E, 0x01));

                              body.emit(assign(r408D, r406F, 0x01));

                              body.emit(assign(r408E, r4070, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f4091->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r4094 = less(r408B, body.constant(int(32)));
                              ir_if *f4093 = new(mem_ctx) ir_if(operand(r4094).val);
                              exec_list *const f4093_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f4093->then_instructions;

                                 body.emit(assign(r408C, lshift(r406F, r408F), 0x01));

                                 ir_expression *const r4095 = lshift(r4070, r408F);
                                 ir_expression *const r4096 = rshift(r406F, r408B);
                                 body.emit(assign(r408D, bit_or(r4095, r4096), 0x01));

                                 body.emit(assign(r408E, rshift(r4070, r408B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f4093->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r4098 = equal(r408B, body.constant(int(32)));
                                 ir_if *f4097 = new(mem_ctx) ir_if(operand(r4098).val);
                                 exec_list *const f4097_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f4097->then_instructions;

                                    body.emit(assign(r408C, r406F, 0x01));

                                    body.emit(assign(r408D, r4070, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f4097->else_instructions;

                                    body.emit(assign(r408A, bit_or(r406E, r406F), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r409A = less(r408B, body.constant(int(64)));
                                    ir_if *f4099 = new(mem_ctx) ir_if(operand(r409A).val);
                                    exec_list *const f4099_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f4099->then_instructions;

                                       body.emit(assign(r408C, lshift(r4070, r408F), 0x01));

                                       ir_expression *const r409B = bit_and(r408B, body.constant(int(31)));
                                       body.emit(assign(r408D, rshift(r4070, r409B), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f4099->else_instructions;

                                       ir_variable *const r409C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r409E = equal(r408B, body.constant(int(64)));
                                       ir_if *f409D = new(mem_ctx) ir_if(operand(r409E).val);
                                       exec_list *const f409D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f409D->then_instructions;

                                          body.emit(assign(r409C, r4070, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f409D->else_instructions;

                                          ir_expression *const r409F = nequal(r4070, body.constant(0u));
                                          ir_expression *const r40A0 = expr(ir_unop_b2i, r409F);
                                          body.emit(assign(r409C, expr(ir_unop_i2u, r40A0), 0x01));


                                       body.instructions = f409D_parent_instructions;
                                       body.emit(f409D);

                                       /* END IF */

                                       body.emit(assign(r408C, r409C, 0x01));

                                       body.emit(assign(r408D, body.constant(0u), 0x01));


                                    body.instructions = f4099_parent_instructions;
                                    body.emit(f4099);

                                    /* END IF */


                                 body.instructions = f4097_parent_instructions;
                                 body.emit(f4097);

                                 /* END IF */

                                 body.emit(assign(r408E, body.constant(0u), 0x01));


                              body.instructions = f4093_parent_instructions;
                              body.emit(f4093);

                              /* END IF */

                              ir_expression *const r40A1 = nequal(r408A, body.constant(0u));
                              ir_expression *const r40A2 = expr(ir_unop_b2i, r40A1);
                              ir_expression *const r40A3 = expr(ir_unop_i2u, r40A2);
                              body.emit(assign(r408C, bit_or(r408C, r40A3), 0x01));


                           body.instructions = f4091_parent_instructions;
                           body.emit(f4091);

                           /* END IF */

                           body.emit(assign(r4074, r408E, 0x01));

                           body.emit(assign(r4075, r408D, 0x01));

                           body.emit(assign(r4076, r408C, 0x01));

                           body.emit(assign(r4073, body.constant(int(0)), 0x01));

                           body.emit(assign(r4079, less(r408C, body.constant(0u)), 0x01));


                        body.instructions = f4088_parent_instructions;
                        body.emit(f4088);

                        /* END IF */


                     body.instructions = f4085_parent_instructions;
                     body.emit(f4085);

                     /* END IF */


                  body.instructions = f407B_parent_instructions;
                  body.emit(f407B);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f40A4 = new(mem_ctx) ir_if(operand(r4077).val);
                  exec_list *const f40A4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f40A4->then_instructions;

                     /* IF CONDITION */
                     ir_if *f40A5 = new(mem_ctx) ir_if(operand(r4079).val);
                     exec_list *const f40A5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f40A5->then_instructions;

                        ir_variable *const r40A6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r40A6, add(r4075, body.constant(1u)), 0x01));

                        ir_expression *const r40A7 = less(r40A6, r4075);
                        ir_expression *const r40A8 = expr(ir_unop_b2i, r40A7);
                        ir_expression *const r40A9 = expr(ir_unop_i2u, r40A8);
                        body.emit(assign(r4074, add(r4074, r40A9), 0x01));

                        ir_expression *const r40AA = equal(r4076, body.constant(0u));
                        ir_expression *const r40AB = expr(ir_unop_b2i, r40AA);
                        ir_expression *const r40AC = expr(ir_unop_i2u, r40AB);
                        ir_expression *const r40AD = add(r4076, r40AC);
                        ir_expression *const r40AE = bit_and(r40AD, body.constant(1u));
                        ir_expression *const r40AF = expr(ir_unop_bit_not, r40AE);
                        body.emit(assign(r4075, bit_and(r40A6, r40AF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f40A5->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r40B1 = bit_or(r4074, r4075);
                        ir_expression *const r40B2 = equal(r40B1, body.constant(0u));
                        ir_if *f40B0 = new(mem_ctx) ir_if(operand(r40B2).val);
                        exec_list *const f40B0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f40B0->then_instructions;

                           body.emit(assign(r4073, body.constant(int(0)), 0x01));


                        body.instructions = f40B0_parent_instructions;
                        body.emit(f40B0);

                        /* END IF */


                     body.instructions = f40A5_parent_instructions;
                     body.emit(f40A5);

                     /* END IF */

                     ir_variable *const r40B3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r40B3);
                     ir_expression *const r40B4 = lshift(r3B90, body.constant(int(31)));
                     ir_expression *const r40B5 = expr(ir_unop_i2u, r4073);
                     ir_expression *const r40B6 = lshift(r40B5, body.constant(int(20)));
                     ir_expression *const r40B7 = add(r40B4, r40B6);
                     body.emit(assign(r40B3, add(r40B7, r4074), 0x02));

                     body.emit(assign(r40B3, r4075, 0x01));

                     body.emit(assign(r4078, r40B3, 0x03));

                     body.emit(assign(r4077, body.constant(false), 0x01));


                  body.instructions = f40A4_parent_instructions;
                  body.emit(f40A4);

                  /* END IF */

                  body.emit(assign(r3FAB, r4078, 0x03));

                  body.emit(assign(r3FAA, body.constant(false), 0x01));


               body.instructions = f406A_parent_instructions;
               body.emit(f406A);

               /* END IF */


            body.instructions = f4040_parent_instructions;
            body.emit(f4040);

            /* END IF */


         body.instructions = f3FFE_parent_instructions;
         body.emit(f3FFE);

         /* END IF */


      body.instructions = f3FBF_parent_instructions;
      body.emit(f3FBF);

      /* END IF */

      /* IF CONDITION */
      ir_if *f40B8 = new(mem_ctx) ir_if(operand(r3FAA).val);
      exec_list *const f40B8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f40B8->then_instructions;

         body.emit(assign(r3FAF, bit_or(r3FAF, body.constant(1048576u)), 0x01));

         ir_variable *const r40B9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r40BA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r40BA, add(r3FB0, r3FAE), 0x01));

         ir_expression *const r40BB = add(r3FAF, r3FAD);
         ir_expression *const r40BC = less(r40BA, r3FB0);
         ir_expression *const r40BD = expr(ir_unop_b2i, r40BC);
         ir_expression *const r40BE = expr(ir_unop_i2u, r40BD);
         body.emit(assign(r40B9, add(r40BB, r40BE), 0x01));

         body.emit(assign(r3FB3, r40B9, 0x01));

         body.emit(assign(r3FB1, add(r3FB1, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r40C0 = less(r40B9, body.constant(2097152u));
         ir_if *f40BF = new(mem_ctx) ir_if(operand(r40C0).val);
         exec_list *const f40BF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f40BF->then_instructions;

            ir_variable *const r40C1 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r40C1, r3FB1, 0x01));

            ir_variable *const r40C2 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r40C2, r40B9, 0x01));

            ir_variable *const r40C3 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r40C3, r40BA, 0x01));

            ir_variable *const r40C4 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r40C4, r3FB2, 0x01));

            ir_variable *const r40C5 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r40C5, body.constant(true), 0x01));

            ir_variable *const r40C6 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r40C7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r40C7);
            ir_expression *const r40C8 = expr(ir_unop_u2i, r3FB2);
            body.emit(assign(r40C7, less(r40C8, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r40CA = lequal(body.constant(int(2045)), r3FB1);
            ir_if *f40C9 = new(mem_ctx) ir_if(operand(r40CA).val);
            exec_list *const f40C9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f40C9->then_instructions;

               ir_variable *const r40CB = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r40CD = less(body.constant(int(2045)), r3FB1);
               ir_if *f40CC = new(mem_ctx) ir_if(operand(r40CD).val);
               exec_list *const f40CC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f40CC->then_instructions;

                  body.emit(assign(r40CB, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f40CC->else_instructions;

                  ir_variable *const r40CE = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r40D0 = equal(r3FB1, body.constant(int(2045)));
                  ir_if *f40CF = new(mem_ctx) ir_if(operand(r40D0).val);
                  exec_list *const f40CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f40CF->then_instructions;

                     ir_expression *const r40D1 = equal(body.constant(2097151u), r40B9);
                     ir_expression *const r40D2 = equal(body.constant(4294967295u), r40BA);
                     body.emit(assign(r40CE, logic_and(r40D1, r40D2), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f40CF->else_instructions;

                     body.emit(assign(r40CE, body.constant(false), 0x01));


                  body.instructions = f40CF_parent_instructions;
                  body.emit(f40CF);

                  /* END IF */

                  body.emit(assign(r40CB, logic_and(r40CE, r40C7), 0x01));


               body.instructions = f40CC_parent_instructions;
               body.emit(f40CC);

               /* END IF */

               /* IF CONDITION */
               ir_if *f40D3 = new(mem_ctx) ir_if(operand(r40CB).val);
               exec_list *const f40D3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f40D3->then_instructions;

                  ir_variable *const r40D4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r40D4);
                  ir_expression *const r40D5 = lshift(r3B90, body.constant(int(31)));
                  body.emit(assign(r40D4, add(r40D5, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r40D4, body.constant(0u), 0x01));

                  body.emit(assign(r40C6, r40D4, 0x03));

                  body.emit(assign(r40C5, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f40D3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r40D7 = less(r3FB1, body.constant(int(0)));
                  ir_if *f40D6 = new(mem_ctx) ir_if(operand(r40D7).val);
                  exec_list *const f40D6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f40D6->then_instructions;

                     ir_variable *const r40D8 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r40D8, r3FB2, 0x01));

                     ir_variable *const r40D9 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r40D9, neg(r3FB1), 0x01));

                     ir_variable *const r40DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r40DA);
                     ir_variable *const r40DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r40DB);
                     ir_variable *const r40DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r40DC);
                     ir_variable *const r40DD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r40DE = neg(r40D9);
                     body.emit(assign(r40DD, bit_and(r40DE, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r40E0 = equal(r40D9, body.constant(int(0)));
                     ir_if *f40DF = new(mem_ctx) ir_if(operand(r40E0).val);
                     exec_list *const f40DF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f40DF->then_instructions;

                        body.emit(assign(r40DA, r3FB2, 0x01));

                        body.emit(assign(r40DB, r40BA, 0x01));

                        body.emit(assign(r40DC, r40B9, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f40DF->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r40E2 = less(r40D9, body.constant(int(32)));
                        ir_if *f40E1 = new(mem_ctx) ir_if(operand(r40E2).val);
                        exec_list *const f40E1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f40E1->then_instructions;

                           body.emit(assign(r40DA, lshift(r40BA, r40DD), 0x01));

                           ir_expression *const r40E3 = lshift(r40B9, r40DD);
                           ir_expression *const r40E4 = rshift(r40BA, r40D9);
                           body.emit(assign(r40DB, bit_or(r40E3, r40E4), 0x01));

                           body.emit(assign(r40DC, rshift(r40B9, r40D9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f40E1->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r40E6 = equal(r40D9, body.constant(int(32)));
                           ir_if *f40E5 = new(mem_ctx) ir_if(operand(r40E6).val);
                           exec_list *const f40E5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f40E5->then_instructions;

                              body.emit(assign(r40DA, r40BA, 0x01));

                              body.emit(assign(r40DB, r40B9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f40E5->else_instructions;

                              body.emit(assign(r40D8, bit_or(r3FB2, r40BA), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r40E8 = less(r40D9, body.constant(int(64)));
                              ir_if *f40E7 = new(mem_ctx) ir_if(operand(r40E8).val);
                              exec_list *const f40E7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f40E7->then_instructions;

                                 body.emit(assign(r40DA, lshift(r40B9, r40DD), 0x01));

                                 ir_expression *const r40E9 = bit_and(r40D9, body.constant(int(31)));
                                 body.emit(assign(r40DB, rshift(r40B9, r40E9), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f40E7->else_instructions;

                                 ir_variable *const r40EA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r40EC = equal(r40D9, body.constant(int(64)));
                                 ir_if *f40EB = new(mem_ctx) ir_if(operand(r40EC).val);
                                 exec_list *const f40EB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f40EB->then_instructions;

                                    body.emit(assign(r40EA, r40B9, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f40EB->else_instructions;

                                    ir_expression *const r40ED = nequal(r40B9, body.constant(0u));
                                    ir_expression *const r40EE = expr(ir_unop_b2i, r40ED);
                                    body.emit(assign(r40EA, expr(ir_unop_i2u, r40EE), 0x01));


                                 body.instructions = f40EB_parent_instructions;
                                 body.emit(f40EB);

                                 /* END IF */

                                 body.emit(assign(r40DA, r40EA, 0x01));

                                 body.emit(assign(r40DB, body.constant(0u), 0x01));


                              body.instructions = f40E7_parent_instructions;
                              body.emit(f40E7);

                              /* END IF */


                           body.instructions = f40E5_parent_instructions;
                           body.emit(f40E5);

                           /* END IF */

                           body.emit(assign(r40DC, body.constant(0u), 0x01));


                        body.instructions = f40E1_parent_instructions;
                        body.emit(f40E1);

                        /* END IF */

                        ir_expression *const r40EF = nequal(r40D8, body.constant(0u));
                        ir_expression *const r40F0 = expr(ir_unop_b2i, r40EF);
                        ir_expression *const r40F1 = expr(ir_unop_i2u, r40F0);
                        body.emit(assign(r40DA, bit_or(r40DA, r40F1), 0x01));


                     body.instructions = f40DF_parent_instructions;
                     body.emit(f40DF);

                     /* END IF */

                     body.emit(assign(r40C2, r40DC, 0x01));

                     body.emit(assign(r40C3, r40DB, 0x01));

                     body.emit(assign(r40C4, r40DA, 0x01));

                     body.emit(assign(r40C1, body.constant(int(0)), 0x01));

                     body.emit(assign(r40C7, less(r40DA, body.constant(0u)), 0x01));


                  body.instructions = f40D6_parent_instructions;
                  body.emit(f40D6);

                  /* END IF */


               body.instructions = f40D3_parent_instructions;
               body.emit(f40D3);

               /* END IF */


            body.instructions = f40C9_parent_instructions;
            body.emit(f40C9);

            /* END IF */

            /* IF CONDITION */
            ir_if *f40F2 = new(mem_ctx) ir_if(operand(r40C5).val);
            exec_list *const f40F2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f40F2->then_instructions;

               /* IF CONDITION */
               ir_if *f40F3 = new(mem_ctx) ir_if(operand(r40C7).val);
               exec_list *const f40F3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f40F3->then_instructions;

                  ir_variable *const r40F4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r40F4, add(r40C3, body.constant(1u)), 0x01));

                  ir_expression *const r40F5 = less(r40F4, r40C3);
                  ir_expression *const r40F6 = expr(ir_unop_b2i, r40F5);
                  ir_expression *const r40F7 = expr(ir_unop_i2u, r40F6);
                  body.emit(assign(r40C2, add(r40C2, r40F7), 0x01));

                  ir_expression *const r40F8 = equal(r40C4, body.constant(0u));
                  ir_expression *const r40F9 = expr(ir_unop_b2i, r40F8);
                  ir_expression *const r40FA = expr(ir_unop_i2u, r40F9);
                  ir_expression *const r40FB = add(r40C4, r40FA);
                  ir_expression *const r40FC = bit_and(r40FB, body.constant(1u));
                  ir_expression *const r40FD = expr(ir_unop_bit_not, r40FC);
                  body.emit(assign(r40C3, bit_and(r40F4, r40FD), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f40F3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r40FF = bit_or(r40C2, r40C3);
                  ir_expression *const r4100 = equal(r40FF, body.constant(0u));
                  ir_if *f40FE = new(mem_ctx) ir_if(operand(r4100).val);
                  exec_list *const f40FE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f40FE->then_instructions;

                     body.emit(assign(r40C1, body.constant(int(0)), 0x01));


                  body.instructions = f40FE_parent_instructions;
                  body.emit(f40FE);

                  /* END IF */


               body.instructions = f40F3_parent_instructions;
               body.emit(f40F3);

               /* END IF */

               ir_variable *const r4101 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r4101);
               ir_expression *const r4102 = lshift(r3B90, body.constant(int(31)));
               ir_expression *const r4103 = expr(ir_unop_i2u, r40C1);
               ir_expression *const r4104 = lshift(r4103, body.constant(int(20)));
               ir_expression *const r4105 = add(r4102, r4104);
               body.emit(assign(r4101, add(r4105, r40C2), 0x02));

               body.emit(assign(r4101, r40C3, 0x01));

               body.emit(assign(r40C6, r4101, 0x03));

               body.emit(assign(r40C5, body.constant(false), 0x01));


            body.instructions = f40F2_parent_instructions;
            body.emit(f40F2);

            /* END IF */

            body.emit(assign(r3FAB, r40C6, 0x03));

            body.emit(assign(r3FAA, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f40BF->else_instructions;

            body.emit(assign(r3FB1, add(r3FB1, body.constant(int(1))), 0x01));

            ir_variable *const r4106 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r4106);
            ir_variable *const r4107 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r4107);
            ir_variable *const r4108 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r4108);
            body.emit(assign(r4106, lshift(r40BA, body.constant(int(31))), 0x01));

            ir_expression *const r4109 = lshift(r40B9, body.constant(int(31)));
            ir_expression *const r410A = rshift(r40BA, body.constant(int(1)));
            body.emit(assign(r4107, bit_or(r4109, r410A), 0x01));

            body.emit(assign(r4108, rshift(r40B9, body.constant(int(1))), 0x01));

            ir_expression *const r410B = nequal(r3FB2, body.constant(0u));
            ir_expression *const r410C = expr(ir_unop_b2i, r410B);
            ir_expression *const r410D = expr(ir_unop_i2u, r410C);
            body.emit(assign(r4106, bit_or(r4106, r410D), 0x01));

            body.emit(assign(r3FB3, r4108, 0x01));

            body.emit(assign(r3FB2, r4106, 0x01));

            ir_variable *const r410E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r410E, r3FB1, 0x01));

            ir_variable *const r410F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r410F, r4108, 0x01));

            ir_variable *const r4110 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r4110, r4107, 0x01));

            ir_variable *const r4111 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r4111, r4106, 0x01));

            ir_variable *const r4112 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r4112, body.constant(true), 0x01));

            ir_variable *const r4113 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r4114 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r4114);
            ir_expression *const r4115 = expr(ir_unop_u2i, r4106);
            body.emit(assign(r4114, less(r4115, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r4117 = lequal(body.constant(int(2045)), r3FB1);
            ir_if *f4116 = new(mem_ctx) ir_if(operand(r4117).val);
            exec_list *const f4116_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f4116->then_instructions;

               ir_variable *const r4118 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r411A = less(body.constant(int(2045)), r3FB1);
               ir_if *f4119 = new(mem_ctx) ir_if(operand(r411A).val);
               exec_list *const f4119_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4119->then_instructions;

                  body.emit(assign(r4118, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4119->else_instructions;

                  ir_variable *const r411B = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r411D = equal(r3FB1, body.constant(int(2045)));
                  ir_if *f411C = new(mem_ctx) ir_if(operand(r411D).val);
                  exec_list *const f411C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f411C->then_instructions;

                     ir_expression *const r411E = equal(body.constant(2097151u), r4108);
                     ir_expression *const r411F = equal(body.constant(4294967295u), r4107);
                     body.emit(assign(r411B, logic_and(r411E, r411F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f411C->else_instructions;

                     body.emit(assign(r411B, body.constant(false), 0x01));


                  body.instructions = f411C_parent_instructions;
                  body.emit(f411C);

                  /* END IF */

                  body.emit(assign(r4118, logic_and(r411B, r4114), 0x01));


               body.instructions = f4119_parent_instructions;
               body.emit(f4119);

               /* END IF */

               /* IF CONDITION */
               ir_if *f4120 = new(mem_ctx) ir_if(operand(r4118).val);
               exec_list *const f4120_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4120->then_instructions;

                  ir_variable *const r4121 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r4121);
                  ir_expression *const r4122 = lshift(r3B90, body.constant(int(31)));
                  body.emit(assign(r4121, add(r4122, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r4121, body.constant(0u), 0x01));

                  body.emit(assign(r4113, r4121, 0x03));

                  body.emit(assign(r4112, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4120->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r4124 = less(r3FB1, body.constant(int(0)));
                  ir_if *f4123 = new(mem_ctx) ir_if(operand(r4124).val);
                  exec_list *const f4123_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4123->then_instructions;

                     ir_variable *const r4125 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r4125, r4106, 0x01));

                     ir_variable *const r4126 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r4126, neg(r3FB1), 0x01));

                     ir_variable *const r4127 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r4127);
                     ir_variable *const r4128 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r4128);
                     ir_variable *const r4129 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r4129);
                     ir_variable *const r412A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r412B = neg(r4126);
                     body.emit(assign(r412A, bit_and(r412B, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r412D = equal(r4126, body.constant(int(0)));
                     ir_if *f412C = new(mem_ctx) ir_if(operand(r412D).val);
                     exec_list *const f412C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f412C->then_instructions;

                        body.emit(assign(r4127, r4106, 0x01));

                        body.emit(assign(r4128, r4107, 0x01));

                        body.emit(assign(r4129, r4108, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f412C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r412F = less(r4126, body.constant(int(32)));
                        ir_if *f412E = new(mem_ctx) ir_if(operand(r412F).val);
                        exec_list *const f412E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f412E->then_instructions;

                           body.emit(assign(r4127, lshift(r4107, r412A), 0x01));

                           ir_expression *const r4130 = lshift(r4108, r412A);
                           ir_expression *const r4131 = rshift(r4107, r4126);
                           body.emit(assign(r4128, bit_or(r4130, r4131), 0x01));

                           body.emit(assign(r4129, rshift(r4108, r4126), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f412E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r4133 = equal(r4126, body.constant(int(32)));
                           ir_if *f4132 = new(mem_ctx) ir_if(operand(r4133).val);
                           exec_list *const f4132_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4132->then_instructions;

                              body.emit(assign(r4127, r4107, 0x01));

                              body.emit(assign(r4128, r4108, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f4132->else_instructions;

                              body.emit(assign(r4125, bit_or(r4106, r4107), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r4135 = less(r4126, body.constant(int(64)));
                              ir_if *f4134 = new(mem_ctx) ir_if(operand(r4135).val);
                              exec_list *const f4134_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f4134->then_instructions;

                                 body.emit(assign(r4127, lshift(r4108, r412A), 0x01));

                                 ir_expression *const r4136 = bit_and(r4126, body.constant(int(31)));
                                 body.emit(assign(r4128, rshift(r4108, r4136), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f4134->else_instructions;

                                 ir_variable *const r4137 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r4139 = equal(r4126, body.constant(int(64)));
                                 ir_if *f4138 = new(mem_ctx) ir_if(operand(r4139).val);
                                 exec_list *const f4138_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f4138->then_instructions;

                                    body.emit(assign(r4137, r4108, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f4138->else_instructions;

                                    ir_expression *const r413A = nequal(r4108, body.constant(0u));
                                    ir_expression *const r413B = expr(ir_unop_b2i, r413A);
                                    body.emit(assign(r4137, expr(ir_unop_i2u, r413B), 0x01));


                                 body.instructions = f4138_parent_instructions;
                                 body.emit(f4138);

                                 /* END IF */

                                 body.emit(assign(r4127, r4137, 0x01));

                                 body.emit(assign(r4128, body.constant(0u), 0x01));


                              body.instructions = f4134_parent_instructions;
                              body.emit(f4134);

                              /* END IF */


                           body.instructions = f4132_parent_instructions;
                           body.emit(f4132);

                           /* END IF */

                           body.emit(assign(r4129, body.constant(0u), 0x01));


                        body.instructions = f412E_parent_instructions;
                        body.emit(f412E);

                        /* END IF */

                        ir_expression *const r413C = nequal(r4125, body.constant(0u));
                        ir_expression *const r413D = expr(ir_unop_b2i, r413C);
                        ir_expression *const r413E = expr(ir_unop_i2u, r413D);
                        body.emit(assign(r4127, bit_or(r4127, r413E), 0x01));


                     body.instructions = f412C_parent_instructions;
                     body.emit(f412C);

                     /* END IF */

                     body.emit(assign(r410F, r4129, 0x01));

                     body.emit(assign(r4110, r4128, 0x01));

                     body.emit(assign(r4111, r4127, 0x01));

                     body.emit(assign(r410E, body.constant(int(0)), 0x01));

                     body.emit(assign(r4114, less(r4127, body.constant(0u)), 0x01));


                  body.instructions = f4123_parent_instructions;
                  body.emit(f4123);

                  /* END IF */


               body.instructions = f4120_parent_instructions;
               body.emit(f4120);

               /* END IF */


            body.instructions = f4116_parent_instructions;
            body.emit(f4116);

            /* END IF */

            /* IF CONDITION */
            ir_if *f413F = new(mem_ctx) ir_if(operand(r4112).val);
            exec_list *const f413F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f413F->then_instructions;

               /* IF CONDITION */
               ir_if *f4140 = new(mem_ctx) ir_if(operand(r4114).val);
               exec_list *const f4140_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4140->then_instructions;

                  ir_variable *const r4141 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r4141, add(r4110, body.constant(1u)), 0x01));

                  ir_expression *const r4142 = less(r4141, r4110);
                  ir_expression *const r4143 = expr(ir_unop_b2i, r4142);
                  ir_expression *const r4144 = expr(ir_unop_i2u, r4143);
                  body.emit(assign(r410F, add(r410F, r4144), 0x01));

                  ir_expression *const r4145 = equal(r4111, body.constant(0u));
                  ir_expression *const r4146 = expr(ir_unop_b2i, r4145);
                  ir_expression *const r4147 = expr(ir_unop_i2u, r4146);
                  ir_expression *const r4148 = add(r4111, r4147);
                  ir_expression *const r4149 = bit_and(r4148, body.constant(1u));
                  ir_expression *const r414A = expr(ir_unop_bit_not, r4149);
                  body.emit(assign(r4110, bit_and(r4141, r414A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4140->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r414C = bit_or(r410F, r4110);
                  ir_expression *const r414D = equal(r414C, body.constant(0u));
                  ir_if *f414B = new(mem_ctx) ir_if(operand(r414D).val);
                  exec_list *const f414B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f414B->then_instructions;

                     body.emit(assign(r410E, body.constant(int(0)), 0x01));


                  body.instructions = f414B_parent_instructions;
                  body.emit(f414B);

                  /* END IF */


               body.instructions = f4140_parent_instructions;
               body.emit(f4140);

               /* END IF */

               ir_variable *const r414E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r414E);
               ir_expression *const r414F = lshift(r3B90, body.constant(int(31)));
               ir_expression *const r4150 = expr(ir_unop_i2u, r410E);
               ir_expression *const r4151 = lshift(r4150, body.constant(int(20)));
               ir_expression *const r4152 = add(r414F, r4151);
               body.emit(assign(r414E, add(r4152, r410F), 0x02));

               body.emit(assign(r414E, r4110, 0x01));

               body.emit(assign(r4113, r414E, 0x03));

               body.emit(assign(r4112, body.constant(false), 0x01));


            body.instructions = f413F_parent_instructions;
            body.emit(f413F);

            /* END IF */

            body.emit(assign(r3FAB, r4113, 0x03));

            body.emit(assign(r3FAA, body.constant(false), 0x01));


         body.instructions = f40BF_parent_instructions;
         body.emit(f40BF);

         /* END IF */


      body.instructions = f40B8_parent_instructions;
      body.emit(f40B8);

      /* END IF */

      body.emit(assign(r3B8F, r3FAB, 0x03));


   body.instructions = f3B92_parent_instructions;
   body.emit(f3B92);

   /* END IF */

   ir_variable *const r4153 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r4154 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r4154);
   ir_variable *const r4155 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r4155);
   ir_expression *const r4156 = rshift(swizzle_y(r3B8F), body.constant(int(20)));
   ir_expression *const r4157 = bit_and(r4156, body.constant(2047u));
   ir_expression *const r4158 = expr(ir_unop_u2i, r4157);
   ir_expression *const r4159 = equal(r4158, body.constant(int(2047)));
   ir_expression *const r415A = bit_and(swizzle_y(r3B8F), body.constant(1048575u));
   ir_expression *const r415B = bit_or(r415A, swizzle_x(r3B8F));
   ir_expression *const r415C = nequal(r415B, body.constant(0u));
   body.emit(assign(r4155, logic_and(r4159, r415C), 0x01));

   ir_expression *const r415D = rshift(swizzle_y(r321E), body.constant(int(20)));
   ir_expression *const r415E = bit_and(r415D, body.constant(2047u));
   ir_expression *const r415F = expr(ir_unop_u2i, r415E);
   ir_expression *const r4160 = equal(r415F, body.constant(int(2047)));
   ir_expression *const r4161 = bit_and(swizzle_y(r321E), body.constant(1048575u));
   ir_expression *const r4162 = bit_or(r4161, swizzle_x(r321E));
   ir_expression *const r4163 = nequal(r4162, body.constant(0u));
   body.emit(assign(r4154, logic_and(r4160, r4163), 0x01));

   /* IF CONDITION */
   ir_expression *const r4165 = logic_or(r4155, r4154);
   ir_if *f4164 = new(mem_ctx) ir_if(operand(r4165).val);
   exec_list *const f4164_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f4164->then_instructions;

      body.emit(assign(r4153, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f4164->else_instructions;

      ir_expression *const r4166 = equal(swizzle_x(r3B8F), swizzle_x(r321E));
      ir_expression *const r4167 = equal(swizzle_y(r3B8F), swizzle_y(r321E));
      ir_expression *const r4168 = equal(swizzle_x(r3B8F), body.constant(0u));
      ir_expression *const r4169 = bit_or(swizzle_y(r3B8F), swizzle_y(r321E));
      ir_expression *const r416A = lshift(r4169, body.constant(int(1)));
      ir_expression *const r416B = equal(r416A, body.constant(0u));
      ir_expression *const r416C = logic_and(r4168, r416B);
      ir_expression *const r416D = logic_or(r4167, r416C);
      body.emit(assign(r4153, logic_and(r4166, r416D), 0x01));


   body.instructions = f4164_parent_instructions;
   body.emit(f4164);

   /* END IF */

   ir_variable *const r416E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r4170 = expr(ir_unop_logic_not, r4153);
   ir_if *f416F = new(mem_ctx) ir_if(operand(r4170).val);
   exec_list *const f416F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f416F->then_instructions;

      body.emit(assign(r416E, r3B8F, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f416F->else_instructions;

      body.emit(assign(r416E, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


   body.instructions = f416F_parent_instructions;
   body.emit(f416F);

   /* END IF */

   body.emit(ret(r416E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
