ir_function_signature *
fabs64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000B);
   body.emit(assign(r000B, bit_and(swizzle_y(r000B), body.constant(2147483647u)), 0x02));

   body.emit(ret(r000B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
is_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000C);
   ir_expression *const r000D = lshift(swizzle_y(r000C), body.constant(int(1)));
   ir_expression *const r000E = lequal(body.constant(4292870144u), r000D);
   ir_expression *const r000F = nequal(swizzle_x(r000C), body.constant(0u));
   ir_expression *const r0010 = bit_and(swizzle_y(r000C), body.constant(1048575u));
   ir_expression *const r0011 = nequal(r0010, body.constant(0u));
   ir_expression *const r0012 = logic_or(r000F, r0011);
   ir_expression *const r0013 = logic_and(r000E, r0012);
   body.emit(ret(r0013));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fneg64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0014 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0014);
   ir_variable *const r0015 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r0017 = lshift(swizzle_y(r0014), body.constant(int(1)));
   ir_expression *const r0018 = lequal(body.constant(4292870144u), r0017);
   ir_expression *const r0019 = nequal(swizzle_x(r0014), body.constant(0u));
   ir_expression *const r001A = bit_and(swizzle_y(r0014), body.constant(1048575u));
   ir_expression *const r001B = nequal(r001A, body.constant(0u));
   ir_expression *const r001C = logic_or(r0019, r001B);
   ir_expression *const r001D = logic_and(r0018, r001C);
   ir_if *f0016 = new(mem_ctx) ir_if(operand(r001D).val);
   exec_list *const f0016_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0016->then_instructions;

      body.emit(assign(r0015, r0014, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0016->else_instructions;

      body.emit(assign(r0014, bit_xor(swizzle_y(r0014), body.constant(2147483648u)), 0x02));

      body.emit(assign(r0015, r0014, 0x03));


   body.instructions = f0016_parent_instructions;
   body.emit(f0016);

   /* END IF */

   body.emit(ret(r0015));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64FracLo(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r001E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r001E);
   ir_swizzle *const r001F = swizzle_x(r001E);
   body.emit(ret(r001F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64FracHi(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0020 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0020);
   ir_expression *const r0021 = bit_and(swizzle_y(r0020), body.constant(1048575u));
   body.emit(ret(r0021));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0022 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0022);
   ir_expression *const r0023 = rshift(swizzle_y(r0022), body.constant(int(20)));
   ir_expression *const r0024 = bit_and(r0023, body.constant(2047u));
   ir_expression *const r0025 = expr(ir_unop_u2i, r0024);
   body.emit(ret(r0025));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
feq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0026 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0026);
   ir_variable *const r0027 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0027);
   ir_variable *const r0028 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0029 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0029);
   ir_variable *const r002A = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r002A);
   ir_expression *const r002B = rshift(swizzle_y(r0026), body.constant(int(20)));
   ir_expression *const r002C = bit_and(r002B, body.constant(2047u));
   ir_expression *const r002D = expr(ir_unop_u2i, r002C);
   ir_expression *const r002E = equal(r002D, body.constant(int(2047)));
   ir_expression *const r002F = bit_and(swizzle_y(r0026), body.constant(1048575u));
   ir_expression *const r0030 = bit_or(r002F, swizzle_x(r0026));
   ir_expression *const r0031 = nequal(r0030, body.constant(0u));
   body.emit(assign(r002A, logic_and(r002E, r0031), 0x01));

   ir_expression *const r0032 = rshift(swizzle_y(r0027), body.constant(int(20)));
   ir_expression *const r0033 = bit_and(r0032, body.constant(2047u));
   ir_expression *const r0034 = expr(ir_unop_u2i, r0033);
   ir_expression *const r0035 = equal(r0034, body.constant(int(2047)));
   ir_expression *const r0036 = bit_and(swizzle_y(r0027), body.constant(1048575u));
   ir_expression *const r0037 = bit_or(r0036, swizzle_x(r0027));
   ir_expression *const r0038 = nequal(r0037, body.constant(0u));
   body.emit(assign(r0029, logic_and(r0035, r0038), 0x01));

   /* IF CONDITION */
   ir_expression *const r003A = logic_or(r002A, r0029);
   ir_if *f0039 = new(mem_ctx) ir_if(operand(r003A).val);
   exec_list *const f0039_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0039->then_instructions;

      body.emit(assign(r0028, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0039->else_instructions;

      ir_expression *const r003B = equal(swizzle_x(r0026), swizzle_x(r0027));
      ir_expression *const r003C = equal(swizzle_y(r0026), swizzle_y(r0027));
      ir_expression *const r003D = equal(swizzle_x(r0026), body.constant(0u));
      ir_expression *const r003E = bit_or(swizzle_y(r0026), swizzle_y(r0027));
      ir_expression *const r003F = lshift(r003E, body.constant(int(1)));
      ir_expression *const r0040 = equal(r003F, body.constant(0u));
      ir_expression *const r0041 = logic_and(r003D, r0040);
      ir_expression *const r0042 = logic_or(r003C, r0041);
      body.emit(assign(r0028, logic_and(r003B, r0042), 0x01));


   body.instructions = f0039_parent_instructions;
   body.emit(f0039);

   /* END IF */

   body.emit(ret(r0028));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0043 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0043);
   ir_expression *const r0044 = rshift(swizzle_y(r0043), body.constant(int(31)));
   body.emit(ret(r0044));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
le64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0045 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0045);
   ir_variable *const r0046 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0046);
   ir_variable *const r0047 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0047);
   ir_variable *const r0048 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0048);
   ir_expression *const r0049 = less(r0045, r0047);
   ir_expression *const r004A = equal(r0045, r0047);
   ir_expression *const r004B = lequal(r0046, r0048);
   ir_expression *const r004C = logic_and(r004A, r004B);
   ir_expression *const r004D = logic_or(r0049, r004C);
   body.emit(ret(r004D));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fle64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r004E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r004E);
   ir_variable *const r004F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r004F);
   ir_variable *const r0050 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0051 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0051);
   ir_variable *const r0052 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0052);
   ir_expression *const r0053 = rshift(swizzle_y(r004E), body.constant(int(20)));
   ir_expression *const r0054 = bit_and(r0053, body.constant(2047u));
   ir_expression *const r0055 = expr(ir_unop_u2i, r0054);
   ir_expression *const r0056 = equal(r0055, body.constant(int(2047)));
   ir_expression *const r0057 = bit_and(swizzle_y(r004E), body.constant(1048575u));
   ir_expression *const r0058 = bit_or(r0057, swizzle_x(r004E));
   ir_expression *const r0059 = nequal(r0058, body.constant(0u));
   body.emit(assign(r0052, logic_and(r0056, r0059), 0x01));

   ir_expression *const r005A = rshift(swizzle_y(r004F), body.constant(int(20)));
   ir_expression *const r005B = bit_and(r005A, body.constant(2047u));
   ir_expression *const r005C = expr(ir_unop_u2i, r005B);
   ir_expression *const r005D = equal(r005C, body.constant(int(2047)));
   ir_expression *const r005E = bit_and(swizzle_y(r004F), body.constant(1048575u));
   ir_expression *const r005F = bit_or(r005E, swizzle_x(r004F));
   ir_expression *const r0060 = nequal(r005F, body.constant(0u));
   body.emit(assign(r0051, logic_and(r005D, r0060), 0x01));

   /* IF CONDITION */
   ir_expression *const r0062 = logic_or(r0052, r0051);
   ir_if *f0061 = new(mem_ctx) ir_if(operand(r0062).val);
   exec_list *const f0061_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0061->then_instructions;

      body.emit(assign(r0050, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0061->else_instructions;

      ir_variable *const r0063 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0063, rshift(swizzle_y(r004E), body.constant(int(31))), 0x01));

      ir_variable *const r0064 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0064, rshift(swizzle_y(r004F), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0066 = nequal(r0063, r0064);
      ir_if *f0065 = new(mem_ctx) ir_if(operand(r0066).val);
      exec_list *const f0065_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0065->then_instructions;

         ir_expression *const r0067 = nequal(r0063, body.constant(0u));
         ir_expression *const r0068 = bit_or(swizzle_y(r004E), swizzle_y(r004F));
         ir_expression *const r0069 = lshift(r0068, body.constant(int(1)));
         ir_expression *const r006A = bit_or(r0069, swizzle_x(r004E));
         ir_expression *const r006B = bit_or(r006A, swizzle_x(r004F));
         ir_expression *const r006C = equal(r006B, body.constant(0u));
         body.emit(assign(r0050, logic_or(r0067, r006C), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0065->else_instructions;

         ir_variable *const r006D = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r006F = nequal(r0063, body.constant(0u));
         ir_if *f006E = new(mem_ctx) ir_if(operand(r006F).val);
         exec_list *const f006E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f006E->then_instructions;

            ir_expression *const r0070 = less(swizzle_y(r004F), swizzle_y(r004E));
            ir_expression *const r0071 = equal(swizzle_y(r004F), swizzle_y(r004E));
            ir_expression *const r0072 = lequal(swizzle_x(r004F), swizzle_x(r004E));
            ir_expression *const r0073 = logic_and(r0071, r0072);
            body.emit(assign(r006D, logic_or(r0070, r0073), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f006E->else_instructions;

            ir_expression *const r0074 = less(swizzle_y(r004E), swizzle_y(r004F));
            ir_expression *const r0075 = equal(swizzle_y(r004E), swizzle_y(r004F));
            ir_expression *const r0076 = lequal(swizzle_x(r004E), swizzle_x(r004F));
            ir_expression *const r0077 = logic_and(r0075, r0076);
            body.emit(assign(r006D, logic_or(r0074, r0077), 0x01));


         body.instructions = f006E_parent_instructions;
         body.emit(f006E);

         /* END IF */

         body.emit(assign(r0050, r006D, 0x01));


      body.instructions = f0065_parent_instructions;
      body.emit(f0065);

      /* END IF */


   body.instructions = f0061_parent_instructions;
   body.emit(f0061);

   /* END IF */

   body.emit(ret(r0050));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
lt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0078 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0078);
   ir_variable *const r0079 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0079);
   ir_variable *const r007A = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r007A);
   ir_variable *const r007B = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r007B);
   ir_expression *const r007C = less(r0078, r007A);
   ir_expression *const r007D = equal(r0078, r007A);
   ir_expression *const r007E = less(r0079, r007B);
   ir_expression *const r007F = logic_and(r007D, r007E);
   ir_expression *const r0080 = logic_or(r007C, r007F);
   body.emit(ret(r0080));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
flt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0081 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0081);
   ir_variable *const r0082 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0082);
   ir_variable *const r0083 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0084 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0084);
   ir_variable *const r0085 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0085);
   ir_expression *const r0086 = rshift(swizzle_y(r0081), body.constant(int(20)));
   ir_expression *const r0087 = bit_and(r0086, body.constant(2047u));
   ir_expression *const r0088 = expr(ir_unop_u2i, r0087);
   ir_expression *const r0089 = equal(r0088, body.constant(int(2047)));
   ir_expression *const r008A = bit_and(swizzle_y(r0081), body.constant(1048575u));
   ir_expression *const r008B = bit_or(r008A, swizzle_x(r0081));
   ir_expression *const r008C = nequal(r008B, body.constant(0u));
   body.emit(assign(r0085, logic_and(r0089, r008C), 0x01));

   ir_expression *const r008D = rshift(swizzle_y(r0082), body.constant(int(20)));
   ir_expression *const r008E = bit_and(r008D, body.constant(2047u));
   ir_expression *const r008F = expr(ir_unop_u2i, r008E);
   ir_expression *const r0090 = equal(r008F, body.constant(int(2047)));
   ir_expression *const r0091 = bit_and(swizzle_y(r0082), body.constant(1048575u));
   ir_expression *const r0092 = bit_or(r0091, swizzle_x(r0082));
   ir_expression *const r0093 = nequal(r0092, body.constant(0u));
   body.emit(assign(r0084, logic_and(r0090, r0093), 0x01));

   /* IF CONDITION */
   ir_expression *const r0095 = logic_or(r0085, r0084);
   ir_if *f0094 = new(mem_ctx) ir_if(operand(r0095).val);
   exec_list *const f0094_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0094->then_instructions;

      body.emit(assign(r0083, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0094->else_instructions;

      ir_variable *const r0096 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0096, rshift(swizzle_y(r0081), body.constant(int(31))), 0x01));

      ir_variable *const r0097 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0097, rshift(swizzle_y(r0082), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0099 = nequal(r0096, r0097);
      ir_if *f0098 = new(mem_ctx) ir_if(operand(r0099).val);
      exec_list *const f0098_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0098->then_instructions;

         ir_expression *const r009A = nequal(r0096, body.constant(0u));
         ir_expression *const r009B = bit_or(swizzle_y(r0081), swizzle_y(r0082));
         ir_expression *const r009C = lshift(r009B, body.constant(int(1)));
         ir_expression *const r009D = bit_or(r009C, swizzle_x(r0081));
         ir_expression *const r009E = bit_or(r009D, swizzle_x(r0082));
         ir_expression *const r009F = nequal(r009E, body.constant(0u));
         body.emit(assign(r0083, logic_and(r009A, r009F), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0098->else_instructions;

         ir_variable *const r00A0 = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r00A2 = nequal(r0096, body.constant(0u));
         ir_if *f00A1 = new(mem_ctx) ir_if(operand(r00A2).val);
         exec_list *const f00A1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00A1->then_instructions;

            ir_expression *const r00A3 = less(swizzle_y(r0082), swizzle_y(r0081));
            ir_expression *const r00A4 = equal(swizzle_y(r0082), swizzle_y(r0081));
            ir_expression *const r00A5 = less(swizzle_x(r0082), swizzle_x(r0081));
            ir_expression *const r00A6 = logic_and(r00A4, r00A5);
            body.emit(assign(r00A0, logic_or(r00A3, r00A6), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00A1->else_instructions;

            ir_expression *const r00A7 = less(swizzle_y(r0081), swizzle_y(r0082));
            ir_expression *const r00A8 = equal(swizzle_y(r0081), swizzle_y(r0082));
            ir_expression *const r00A9 = less(swizzle_x(r0081), swizzle_x(r0082));
            ir_expression *const r00AA = logic_and(r00A8, r00A9);
            body.emit(assign(r00A0, logic_or(r00A7, r00AA), 0x01));


         body.instructions = f00A1_parent_instructions;
         body.emit(f00A1);

         /* END IF */

         body.emit(assign(r0083, r00A0, 0x01));


      body.instructions = f0098_parent_instructions;
      body.emit(f0098);

      /* END IF */


   body.instructions = f0094_parent_instructions;
   body.emit(f0094);

   /* END IF */

   body.emit(ret(r0083));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00AB);
   ir_variable *const r00AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00AC);
   ir_variable *const r00AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00AD);
   ir_variable *const r00AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00AE);
   ir_variable *const r00AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00AF);
   ir_variable *const r00B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00B0);
   ir_variable *const r00B1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r00B1, add(r00AC, r00AE), 0x01));

   body.emit(assign(r00B0, r00B1, 0x01));

   ir_expression *const r00B2 = add(r00AB, r00AD);
   ir_expression *const r00B3 = less(r00B1, r00AC);
   ir_expression *const r00B4 = expr(ir_unop_b2i, r00B3);
   ir_expression *const r00B5 = expr(ir_unop_i2u, r00B4);
   body.emit(assign(r00AF, add(r00B2, r00B5), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00B6);
   ir_variable *const r00B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00B7);
   ir_variable *const r00B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00B8);
   ir_variable *const r00B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00B9);
   ir_variable *const r00BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00BA);
   ir_variable *const r00BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00BB);
   body.emit(assign(r00BB, sub(r00B7, r00B9), 0x01));

   ir_expression *const r00BC = sub(r00B6, r00B8);
   ir_expression *const r00BD = less(r00B7, r00B9);
   ir_expression *const r00BE = expr(ir_unop_b2i, r00BD);
   ir_expression *const r00BF = expr(ir_unop_i2u, r00BE);
   body.emit(assign(r00BA, sub(r00BC, r00BF), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
eq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00C0);
   ir_variable *const r00C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00C1);
   ir_variable *const r00C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00C2);
   ir_variable *const r00C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00C3);
   ir_expression *const r00C4 = equal(r00C0, r00C2);
   ir_expression *const r00C5 = equal(r00C1, r00C3);
   ir_expression *const r00C6 = logic_and(r00C4, r00C5);
   body.emit(ret(r00C6));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
float64_is_signaling_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r00C7);
   ir_expression *const r00C8 = rshift(swizzle_y(r00C7), body.constant(int(19)));
   ir_expression *const r00C9 = bit_and(r00C8, body.constant(4095u));
   ir_expression *const r00CA = equal(r00C9, body.constant(4094u));
   ir_expression *const r00CB = nequal(swizzle_x(r00C7), body.constant(0u));
   ir_expression *const r00CC = bit_and(swizzle_y(r00C7), body.constant(524287u));
   ir_expression *const r00CD = nequal(r00CC, body.constant(0u));
   ir_expression *const r00CE = logic_or(r00CB, r00CD);
   ir_expression *const r00CF = logic_and(r00CA, r00CE);
   body.emit(ret(r00CF));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00D0);
   ir_variable *const r00D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00D1);
   ir_variable *const r00D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00D2);
   ir_variable *const r00D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D3);
   ir_variable *const r00D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D4);
   ir_variable *const r00D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00D5);
   ir_variable *const r00D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00D6);
   ir_variable *const r00D7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r00D8 = neg(r00D2);
   body.emit(assign(r00D7, bit_and(r00D8, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r00DA = equal(r00D2, body.constant(int(0)));
   ir_if *f00D9 = new(mem_ctx) ir_if(operand(r00DA).val);
   exec_list *const f00D9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f00D9->then_instructions;

      body.emit(assign(r00D5, r00D1, 0x01));

      body.emit(assign(r00D6, r00D0, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f00D9->else_instructions;

      /* IF CONDITION */
      ir_expression *const r00DC = less(r00D2, body.constant(int(32)));
      ir_if *f00DB = new(mem_ctx) ir_if(operand(r00DC).val);
      exec_list *const f00DB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f00DB->then_instructions;

         ir_expression *const r00DD = lshift(r00D0, r00D7);
         ir_expression *const r00DE = rshift(r00D1, r00D2);
         ir_expression *const r00DF = bit_or(r00DD, r00DE);
         ir_expression *const r00E0 = lshift(r00D1, r00D7);
         ir_expression *const r00E1 = nequal(r00E0, body.constant(0u));
         ir_expression *const r00E2 = expr(ir_unop_b2i, r00E1);
         ir_expression *const r00E3 = expr(ir_unop_i2u, r00E2);
         body.emit(assign(r00D5, bit_or(r00DF, r00E3), 0x01));

         body.emit(assign(r00D6, rshift(r00D0, r00D2), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f00DB->else_instructions;

         /* IF CONDITION */
         ir_expression *const r00E5 = equal(r00D2, body.constant(int(32)));
         ir_if *f00E4 = new(mem_ctx) ir_if(operand(r00E5).val);
         exec_list *const f00E4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00E4->then_instructions;

            ir_expression *const r00E6 = nequal(r00D1, body.constant(0u));
            ir_expression *const r00E7 = expr(ir_unop_b2i, r00E6);
            ir_expression *const r00E8 = expr(ir_unop_i2u, r00E7);
            body.emit(assign(r00D5, bit_or(r00D0, r00E8), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00E4->else_instructions;

            /* IF CONDITION */
            ir_expression *const r00EA = less(r00D2, body.constant(int(64)));
            ir_if *f00E9 = new(mem_ctx) ir_if(operand(r00EA).val);
            exec_list *const f00E9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f00E9->then_instructions;

               ir_expression *const r00EB = bit_and(r00D2, body.constant(int(31)));
               ir_expression *const r00EC = rshift(r00D0, r00EB);
               ir_expression *const r00ED = lshift(r00D0, r00D7);
               ir_expression *const r00EE = bit_or(r00ED, r00D1);
               ir_expression *const r00EF = nequal(r00EE, body.constant(0u));
               ir_expression *const r00F0 = expr(ir_unop_b2i, r00EF);
               ir_expression *const r00F1 = expr(ir_unop_i2u, r00F0);
               body.emit(assign(r00D5, bit_or(r00EC, r00F1), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f00E9->else_instructions;

               ir_expression *const r00F2 = bit_or(r00D0, r00D1);
               ir_expression *const r00F3 = nequal(r00F2, body.constant(0u));
               ir_expression *const r00F4 = expr(ir_unop_b2i, r00F3);
               body.emit(assign(r00D5, expr(ir_unop_i2u, r00F4), 0x01));


            body.instructions = f00E9_parent_instructions;
            body.emit(f00E9);

            /* END IF */


         body.instructions = f00E4_parent_instructions;
         body.emit(f00E4);

         /* END IF */

         body.emit(assign(r00D6, body.constant(0u), 0x01));


      body.instructions = f00DB_parent_instructions;
      body.emit(f00DB);

      /* END IF */


   body.instructions = f00D9_parent_instructions;
   body.emit(f00D9);

   /* END IF */

   body.emit(assign(r00D4, r00D5, 0x01));

   body.emit(assign(r00D3, r00D6, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64ExtraRightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00F5);
   ir_variable *const r00F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00F6);
   ir_variable *const r00F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r00F7);
   ir_variable *const r00F8 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00F8);
   ir_variable *const r00F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F9);
   ir_variable *const r00FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00FA);
   ir_variable *const r00FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00FB);
   ir_variable *const r00FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
   body.emit(r00FC);
   ir_variable *const r00FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00FD);
   ir_variable *const r00FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00FE);
   ir_variable *const r00FF = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r0100 = neg(r00F8);
   body.emit(assign(r00FF, bit_and(r0100, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0102 = equal(r00F8, body.constant(int(0)));
   ir_if *f0101 = new(mem_ctx) ir_if(operand(r0102).val);
   exec_list *const f0101_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0101->then_instructions;

      body.emit(assign(r00FC, r00F7, 0x01));

      body.emit(assign(r00FD, r00F6, 0x01));

      body.emit(assign(r00FE, r00F5, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0101->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0104 = less(r00F8, body.constant(int(32)));
      ir_if *f0103 = new(mem_ctx) ir_if(operand(r0104).val);
      exec_list *const f0103_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0103->then_instructions;

         body.emit(assign(r00FC, lshift(r00F6, r00FF), 0x01));

         ir_expression *const r0105 = lshift(r00F5, r00FF);
         ir_expression *const r0106 = rshift(r00F6, r00F8);
         body.emit(assign(r00FD, bit_or(r0105, r0106), 0x01));

         body.emit(assign(r00FE, rshift(r00F5, r00F8), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0103->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0108 = equal(r00F8, body.constant(int(32)));
         ir_if *f0107 = new(mem_ctx) ir_if(operand(r0108).val);
         exec_list *const f0107_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0107->then_instructions;

            body.emit(assign(r00FC, r00F6, 0x01));

            body.emit(assign(r00FD, r00F5, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0107->else_instructions;

            body.emit(assign(r00F7, bit_or(r00F7, r00F6), 0x01));

            /* IF CONDITION */
            ir_expression *const r010A = less(r00F8, body.constant(int(64)));
            ir_if *f0109 = new(mem_ctx) ir_if(operand(r010A).val);
            exec_list *const f0109_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0109->then_instructions;

               body.emit(assign(r00FC, lshift(r00F5, r00FF), 0x01));

               ir_expression *const r010B = bit_and(r00F8, body.constant(int(31)));
               body.emit(assign(r00FD, rshift(r00F5, r010B), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0109->else_instructions;

               ir_variable *const r010C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r010E = equal(r00F8, body.constant(int(64)));
               ir_if *f010D = new(mem_ctx) ir_if(operand(r010E).val);
               exec_list *const f010D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f010D->then_instructions;

                  body.emit(assign(r010C, r00F5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f010D->else_instructions;

                  ir_expression *const r010F = nequal(r00F5, body.constant(0u));
                  ir_expression *const r0110 = expr(ir_unop_b2i, r010F);
                  body.emit(assign(r010C, expr(ir_unop_i2u, r0110), 0x01));


               body.instructions = f010D_parent_instructions;
               body.emit(f010D);

               /* END IF */

               body.emit(assign(r00FC, r010C, 0x01));

               body.emit(assign(r00FD, body.constant(0u), 0x01));


            body.instructions = f0109_parent_instructions;
            body.emit(f0109);

            /* END IF */


         body.instructions = f0107_parent_instructions;
         body.emit(f0107);

         /* END IF */

         body.emit(assign(r00FE, body.constant(0u), 0x01));


      body.instructions = f0103_parent_instructions;
      body.emit(f0103);

      /* END IF */

      ir_expression *const r0111 = nequal(r00F7, body.constant(0u));
      ir_expression *const r0112 = expr(ir_unop_b2i, r0111);
      ir_expression *const r0113 = expr(ir_unop_i2u, r0112);
      body.emit(assign(r00FC, bit_or(r00FC, r0113), 0x01));


   body.instructions = f0101_parent_instructions;
   body.emit(f0101);

   /* END IF */

   body.emit(assign(r00FB, r00FC, 0x01));

   body.emit(assign(r00FA, r00FD, 0x01));

   body.emit(assign(r00F9, r00FE, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shortShift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0114 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0114);
   ir_variable *const r0115 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0115);
   ir_variable *const r0116 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r0116);
   ir_variable *const r0117 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0117);
   ir_variable *const r0118 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0118);
   body.emit(assign(r0118, lshift(r0115, r0116), 0x01));

   ir_variable *const r0119 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r011B = equal(r0116, body.constant(int(0)));
   ir_if *f011A = new(mem_ctx) ir_if(operand(r011B).val);
   exec_list *const f011A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f011A->then_instructions;

      body.emit(assign(r0119, r0114, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f011A->else_instructions;

      ir_expression *const r011C = lshift(r0114, r0116);
      ir_expression *const r011D = neg(r0116);
      ir_expression *const r011E = bit_and(r011D, body.constant(int(31)));
      ir_expression *const r011F = rshift(r0115, r011E);
      body.emit(assign(r0119, bit_or(r011C, r011F), 0x01));


   body.instructions = f011A_parent_instructions;
   body.emit(f011A);

   /* END IF */

   body.emit(assign(r0117, r0119, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0120 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0120);
   ir_variable *const r0121 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0121);
   ir_variable *const r0122 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0122);
   ir_variable *const r0123 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0123);
   ir_variable *const r0124 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
   body.emit(r0124);
   ir_expression *const r0125 = lshift(r0120, body.constant(int(31)));
   ir_expression *const r0126 = expr(ir_unop_i2u, r0121);
   ir_expression *const r0127 = lshift(r0126, body.constant(int(20)));
   ir_expression *const r0128 = add(r0125, r0127);
   body.emit(assign(r0124, add(r0128, r0122), 0x02));

   body.emit(assign(r0124, r0123, 0x01));

   body.emit(ret(r0124));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0129 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0129);
   ir_variable *const r012A = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r012A);
   ir_variable *const r012B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r012B);
   ir_variable *const r012C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r012C);
   ir_variable *const r012D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_function_in);
   sig_parameters.push_tail(r012D);
   ir_variable *const r012E = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r012E, body.constant(true), 0x01));

   ir_variable *const r012F = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0130 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r0130);
   ir_expression *const r0131 = expr(ir_unop_u2i, r012D);
   body.emit(assign(r0130, less(r0131, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0133 = lequal(body.constant(int(2045)), r012A);
   ir_if *f0132 = new(mem_ctx) ir_if(operand(r0133).val);
   exec_list *const f0132_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0132->then_instructions;

      ir_variable *const r0134 = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r0136 = less(body.constant(int(2045)), r012A);
      ir_if *f0135 = new(mem_ctx) ir_if(operand(r0136).val);
      exec_list *const f0135_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0135->then_instructions;

         body.emit(assign(r0134, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0135->else_instructions;

         ir_variable *const r0137 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r0139 = equal(r012A, body.constant(int(2045)));
         ir_if *f0138 = new(mem_ctx) ir_if(operand(r0139).val);
         exec_list *const f0138_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0138->then_instructions;

            ir_expression *const r013A = equal(body.constant(2097151u), r012B);
            ir_expression *const r013B = equal(body.constant(4294967295u), r012C);
            body.emit(assign(r0137, logic_and(r013A, r013B), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0138->else_instructions;

            body.emit(assign(r0137, body.constant(false), 0x01));


         body.instructions = f0138_parent_instructions;
         body.emit(f0138);

         /* END IF */

         body.emit(assign(r0134, logic_and(r0137, r0130), 0x01));


      body.instructions = f0135_parent_instructions;
      body.emit(f0135);

      /* END IF */

      /* IF CONDITION */
      ir_if *f013C = new(mem_ctx) ir_if(operand(r0134).val);
      exec_list *const f013C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f013C->then_instructions;

         ir_variable *const r013D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r013D);
         ir_expression *const r013E = lshift(r0129, body.constant(int(31)));
         body.emit(assign(r013D, add(r013E, body.constant(2146435072u)), 0x02));

         body.emit(assign(r013D, body.constant(0u), 0x01));

         body.emit(assign(r012F, r013D, 0x03));

         body.emit(assign(r012E, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f013C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0140 = less(r012A, body.constant(int(0)));
         ir_if *f013F = new(mem_ctx) ir_if(operand(r0140).val);
         exec_list *const f013F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f013F->then_instructions;

            ir_variable *const r0141 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r0141, r012D, 0x01));

            ir_variable *const r0142 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r0142, neg(r012A), 0x01));

            ir_variable *const r0143 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0143);
            ir_variable *const r0144 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0144);
            ir_variable *const r0145 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0145);
            ir_variable *const r0146 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0147 = neg(r0142);
            body.emit(assign(r0146, bit_and(r0147, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0149 = equal(r0142, body.constant(int(0)));
            ir_if *f0148 = new(mem_ctx) ir_if(operand(r0149).val);
            exec_list *const f0148_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0148->then_instructions;

               body.emit(assign(r0143, r012D, 0x01));

               body.emit(assign(r0144, r012C, 0x01));

               body.emit(assign(r0145, r012B, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0148->else_instructions;

               /* IF CONDITION */
               ir_expression *const r014B = less(r0142, body.constant(int(32)));
               ir_if *f014A = new(mem_ctx) ir_if(operand(r014B).val);
               exec_list *const f014A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f014A->then_instructions;

                  body.emit(assign(r0143, lshift(r012C, r0146), 0x01));

                  ir_expression *const r014C = lshift(r012B, r0146);
                  ir_expression *const r014D = rshift(r012C, r0142);
                  body.emit(assign(r0144, bit_or(r014C, r014D), 0x01));

                  body.emit(assign(r0145, rshift(r012B, r0142), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f014A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r014F = equal(r0142, body.constant(int(32)));
                  ir_if *f014E = new(mem_ctx) ir_if(operand(r014F).val);
                  exec_list *const f014E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f014E->then_instructions;

                     body.emit(assign(r0143, r012C, 0x01));

                     body.emit(assign(r0144, r012B, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f014E->else_instructions;

                     body.emit(assign(r0141, bit_or(r012D, r012C), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0151 = less(r0142, body.constant(int(64)));
                     ir_if *f0150 = new(mem_ctx) ir_if(operand(r0151).val);
                     exec_list *const f0150_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0150->then_instructions;

                        body.emit(assign(r0143, lshift(r012B, r0146), 0x01));

                        ir_expression *const r0152 = bit_and(r0142, body.constant(int(31)));
                        body.emit(assign(r0144, rshift(r012B, r0152), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0150->else_instructions;

                        ir_variable *const r0153 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0155 = equal(r0142, body.constant(int(64)));
                        ir_if *f0154 = new(mem_ctx) ir_if(operand(r0155).val);
                        exec_list *const f0154_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0154->then_instructions;

                           body.emit(assign(r0153, r012B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0154->else_instructions;

                           ir_expression *const r0156 = nequal(r012B, body.constant(0u));
                           ir_expression *const r0157 = expr(ir_unop_b2i, r0156);
                           body.emit(assign(r0153, expr(ir_unop_i2u, r0157), 0x01));


                        body.instructions = f0154_parent_instructions;
                        body.emit(f0154);

                        /* END IF */

                        body.emit(assign(r0143, r0153, 0x01));

                        body.emit(assign(r0144, body.constant(0u), 0x01));


                     body.instructions = f0150_parent_instructions;
                     body.emit(f0150);

                     /* END IF */


                  body.instructions = f014E_parent_instructions;
                  body.emit(f014E);

                  /* END IF */

                  body.emit(assign(r0145, body.constant(0u), 0x01));


               body.instructions = f014A_parent_instructions;
               body.emit(f014A);

               /* END IF */

               ir_expression *const r0158 = nequal(r0141, body.constant(0u));
               ir_expression *const r0159 = expr(ir_unop_b2i, r0158);
               ir_expression *const r015A = expr(ir_unop_i2u, r0159);
               body.emit(assign(r0143, bit_or(r0143, r015A), 0x01));


            body.instructions = f0148_parent_instructions;
            body.emit(f0148);

            /* END IF */

            body.emit(assign(r012B, r0145, 0x01));

            body.emit(assign(r012C, r0144, 0x01));

            body.emit(assign(r012D, r0143, 0x01));

            body.emit(assign(r012A, body.constant(int(0)), 0x01));

            body.emit(assign(r0130, less(r0143, body.constant(0u)), 0x01));


         body.instructions = f013F_parent_instructions;
         body.emit(f013F);

         /* END IF */


      body.instructions = f013C_parent_instructions;
      body.emit(f013C);

      /* END IF */


   body.instructions = f0132_parent_instructions;
   body.emit(f0132);

   /* END IF */

   /* IF CONDITION */
   ir_if *f015B = new(mem_ctx) ir_if(operand(r012E).val);
   exec_list *const f015B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f015B->then_instructions;

      /* IF CONDITION */
      ir_if *f015C = new(mem_ctx) ir_if(operand(r0130).val);
      exec_list *const f015C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f015C->then_instructions;

         ir_variable *const r015D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r015D, add(r012C, body.constant(1u)), 0x01));

         ir_expression *const r015E = less(r015D, r012C);
         ir_expression *const r015F = expr(ir_unop_b2i, r015E);
         ir_expression *const r0160 = expr(ir_unop_i2u, r015F);
         body.emit(assign(r012B, add(r012B, r0160), 0x01));

         ir_expression *const r0161 = equal(r012D, body.constant(0u));
         ir_expression *const r0162 = expr(ir_unop_b2i, r0161);
         ir_expression *const r0163 = expr(ir_unop_i2u, r0162);
         ir_expression *const r0164 = add(r012D, r0163);
         ir_expression *const r0165 = bit_and(r0164, body.constant(1u));
         ir_expression *const r0166 = expr(ir_unop_bit_not, r0165);
         body.emit(assign(r012C, bit_and(r015D, r0166), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f015C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0168 = bit_or(r012B, r012C);
         ir_expression *const r0169 = equal(r0168, body.constant(0u));
         ir_if *f0167 = new(mem_ctx) ir_if(operand(r0169).val);
         exec_list *const f0167_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0167->then_instructions;

            body.emit(assign(r012A, body.constant(int(0)), 0x01));


         body.instructions = f0167_parent_instructions;
         body.emit(f0167);

         /* END IF */


      body.instructions = f015C_parent_instructions;
      body.emit(f015C);

      /* END IF */

      ir_variable *const r016A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r016A);
      ir_expression *const r016B = lshift(r0129, body.constant(int(31)));
      ir_expression *const r016C = expr(ir_unop_i2u, r012A);
      ir_expression *const r016D = lshift(r016C, body.constant(int(20)));
      ir_expression *const r016E = add(r016B, r016D);
      body.emit(assign(r016A, add(r016E, r012B), 0x02));

      body.emit(assign(r016A, r012C, 0x01));

      body.emit(assign(r012F, r016A, 0x03));

      body.emit(assign(r012E, body.constant(false), 0x01));


   body.instructions = f015B_parent_instructions;
   body.emit(f015B);

   /* END IF */

   body.emit(ret(r012F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
countLeadingZeros32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r016F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r016F);
   ir_variable *const r0170 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r0171 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0171);
   /* IF CONDITION */
   ir_expression *const r0173 = equal(r016F, body.constant(0u));
   ir_if *f0172 = new(mem_ctx) ir_if(operand(r0173).val);
   exec_list *const f0172_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0172->then_instructions;

      body.emit(assign(r0170, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0172->else_instructions;

      body.emit(assign(r0171, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0175 = bit_and(r016F, body.constant(4294901760u));
      ir_expression *const r0176 = equal(r0175, body.constant(0u));
      ir_if *f0174 = new(mem_ctx) ir_if(operand(r0176).val);
      exec_list *const f0174_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0174->then_instructions;

         body.emit(assign(r0171, body.constant(int(16)), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(16))), 0x01));


      body.instructions = f0174_parent_instructions;
      body.emit(f0174);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0178 = bit_and(r016F, body.constant(4278190080u));
      ir_expression *const r0179 = equal(r0178, body.constant(0u));
      ir_if *f0177 = new(mem_ctx) ir_if(operand(r0179).val);
      exec_list *const f0177_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0177->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(8))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(8))), 0x01));


      body.instructions = f0177_parent_instructions;
      body.emit(f0177);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017B = bit_and(r016F, body.constant(4026531840u));
      ir_expression *const r017C = equal(r017B, body.constant(0u));
      ir_if *f017A = new(mem_ctx) ir_if(operand(r017C).val);
      exec_list *const f017A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017A->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(4))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(4))), 0x01));


      body.instructions = f017A_parent_instructions;
      body.emit(f017A);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017E = bit_and(r016F, body.constant(3221225472u));
      ir_expression *const r017F = equal(r017E, body.constant(0u));
      ir_if *f017D = new(mem_ctx) ir_if(operand(r017F).val);
      exec_list *const f017D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017D->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(2))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(2))), 0x01));


      body.instructions = f017D_parent_instructions;
      body.emit(f017D);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0181 = bit_and(r016F, body.constant(2147483648u));
      ir_expression *const r0182 = equal(r0181, body.constant(0u));
      ir_if *f0180 = new(mem_ctx) ir_if(operand(r0182).val);
      exec_list *const f0180_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0180->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(1))), 0x01));


      body.instructions = f0180_parent_instructions;
      body.emit(f0180);

      /* END IF */

      body.emit(assign(r0170, r0171, 0x01));


   body.instructions = f0172_parent_instructions;
   body.emit(f0172);

   /* END IF */

   body.emit(ret(r0170));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeRoundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0183 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0183);
   ir_variable *const r0184 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0184);
   ir_variable *const r0185 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0185);
   ir_variable *const r0186 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0186);
   ir_variable *const r0187 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0187);
   ir_variable *const r0188 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0188);
   /* IF CONDITION */
   ir_expression *const r018A = equal(r0185, body.constant(0u));
   ir_if *f0189 = new(mem_ctx) ir_if(operand(r018A).val);
   exec_list *const f0189_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0189->then_instructions;

      body.emit(assign(r0185, r0186, 0x01));

      body.emit(assign(r0186, body.constant(0u), 0x01));

      body.emit(assign(r0184, add(r0184, body.constant(int(-32))), 0x01));


   body.instructions = f0189_parent_instructions;
   body.emit(f0189);

   /* END IF */

   ir_variable *const r018B = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r018B, r0185, 0x01));

   ir_variable *const r018C = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r018D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r018D);
   /* IF CONDITION */
   ir_expression *const r018F = equal(r0185, body.constant(0u));
   ir_if *f018E = new(mem_ctx) ir_if(operand(r018F).val);
   exec_list *const f018E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f018E->then_instructions;

      body.emit(assign(r018C, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f018E->else_instructions;

      body.emit(assign(r018D, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0191 = bit_and(r0185, body.constant(4294901760u));
      ir_expression *const r0192 = equal(r0191, body.constant(0u));
      ir_if *f0190 = new(mem_ctx) ir_if(operand(r0192).val);
      exec_list *const f0190_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0190->then_instructions;

         body.emit(assign(r018D, body.constant(int(16)), 0x01));

         body.emit(assign(r018B, lshift(r0185, body.constant(int(16))), 0x01));


      body.instructions = f0190_parent_instructions;
      body.emit(f0190);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0194 = bit_and(r018B, body.constant(4278190080u));
      ir_expression *const r0195 = equal(r0194, body.constant(0u));
      ir_if *f0193 = new(mem_ctx) ir_if(operand(r0195).val);
      exec_list *const f0193_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0193->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(8))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(8))), 0x01));


      body.instructions = f0193_parent_instructions;
      body.emit(f0193);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0197 = bit_and(r018B, body.constant(4026531840u));
      ir_expression *const r0198 = equal(r0197, body.constant(0u));
      ir_if *f0196 = new(mem_ctx) ir_if(operand(r0198).val);
      exec_list *const f0196_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0196->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(4))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(4))), 0x01));


      body.instructions = f0196_parent_instructions;
      body.emit(f0196);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019A = bit_and(r018B, body.constant(3221225472u));
      ir_expression *const r019B = equal(r019A, body.constant(0u));
      ir_if *f0199 = new(mem_ctx) ir_if(operand(r019B).val);
      exec_list *const f0199_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0199->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(2))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(2))), 0x01));


      body.instructions = f0199_parent_instructions;
      body.emit(f0199);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019D = bit_and(r018B, body.constant(2147483648u));
      ir_expression *const r019E = equal(r019D, body.constant(0u));
      ir_if *f019C = new(mem_ctx) ir_if(operand(r019E).val);
      exec_list *const f019C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f019C->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(1))), 0x01));


      body.instructions = f019C_parent_instructions;
      body.emit(f019C);

      /* END IF */

      body.emit(assign(r018C, r018D, 0x01));


   body.instructions = f018E_parent_instructions;
   body.emit(f018E);

   /* END IF */

   body.emit(assign(r0188, add(r018C, body.constant(int(-11))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01A0 = lequal(body.constant(int(0)), r0188);
   ir_if *f019F = new(mem_ctx) ir_if(operand(r01A0).val);
   exec_list *const f019F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f019F->then_instructions;

      body.emit(assign(r0187, body.constant(0u), 0x01));

      ir_variable *const r01A1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r01A1, lshift(r0186, r0188), 0x01));

      ir_variable *const r01A2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r01A4 = equal(r0188, body.constant(int(0)));
      ir_if *f01A3 = new(mem_ctx) ir_if(operand(r01A4).val);
      exec_list *const f01A3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01A3->then_instructions;

         body.emit(assign(r01A2, r0185, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01A3->else_instructions;

         ir_expression *const r01A5 = lshift(r0185, r0188);
         ir_expression *const r01A6 = neg(r0188);
         ir_expression *const r01A7 = bit_and(r01A6, body.constant(int(31)));
         ir_expression *const r01A8 = rshift(r0186, r01A7);
         body.emit(assign(r01A2, bit_or(r01A5, r01A8), 0x01));


      body.instructions = f01A3_parent_instructions;
      body.emit(f01A3);

      /* END IF */

      body.emit(assign(r0185, r01A2, 0x01));

      body.emit(assign(r0186, r01A1, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f019F->else_instructions;

      ir_variable *const r01A9 = body.make_temp(glsl_type::uint_type, "a2");
      body.emit(assign(r01A9, body.constant(0u), 0x01));

      ir_variable *const r01AA = body.make_temp(glsl_type::int_type, "count");
      body.emit(assign(r01AA, neg(r0188), 0x01));

      ir_variable *const r01AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
      body.emit(r01AB);
      ir_variable *const r01AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r01AC);
      ir_variable *const r01AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r01AD);
      ir_variable *const r01AE = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r01AF = neg(r01AA);
      body.emit(assign(r01AE, bit_and(r01AF, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r01B1 = equal(r01AA, body.constant(int(0)));
      ir_if *f01B0 = new(mem_ctx) ir_if(operand(r01B1).val);
      exec_list *const f01B0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01B0->then_instructions;

         body.emit(assign(r01AB, r01A9, 0x01));

         body.emit(assign(r01AC, r0186, 0x01));

         body.emit(assign(r01AD, r0185, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01B0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01B3 = less(r01AA, body.constant(int(32)));
         ir_if *f01B2 = new(mem_ctx) ir_if(operand(r01B3).val);
         exec_list *const f01B2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01B2->then_instructions;

            body.emit(assign(r01AB, lshift(r0186, r01AE), 0x01));

            ir_expression *const r01B4 = lshift(r0185, r01AE);
            ir_expression *const r01B5 = rshift(r0186, r01AA);
            body.emit(assign(r01AC, bit_or(r01B4, r01B5), 0x01));

            body.emit(assign(r01AD, rshift(r0185, r01AA), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01B2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r01B7 = equal(r01AA, body.constant(int(32)));
            ir_if *f01B6 = new(mem_ctx) ir_if(operand(r01B7).val);
            exec_list *const f01B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01B6->then_instructions;

               body.emit(assign(r01AB, r0186, 0x01));

               body.emit(assign(r01AC, r0185, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01B6->else_instructions;

               body.emit(assign(r01A9, bit_or(body.constant(0u), r0186), 0x01));

               /* IF CONDITION */
               ir_expression *const r01B9 = less(r01AA, body.constant(int(64)));
               ir_if *f01B8 = new(mem_ctx) ir_if(operand(r01B9).val);
               exec_list *const f01B8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01B8->then_instructions;

                  body.emit(assign(r01AB, lshift(r0185, r01AE), 0x01));

                  ir_expression *const r01BA = bit_and(r01AA, body.constant(int(31)));
                  body.emit(assign(r01AC, rshift(r0185, r01BA), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01B8->else_instructions;

                  ir_variable *const r01BB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r01BD = equal(r01AA, body.constant(int(64)));
                  ir_if *f01BC = new(mem_ctx) ir_if(operand(r01BD).val);
                  exec_list *const f01BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01BC->then_instructions;

                     body.emit(assign(r01BB, r0185, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01BC->else_instructions;

                     ir_expression *const r01BE = nequal(r0185, body.constant(0u));
                     ir_expression *const r01BF = expr(ir_unop_b2i, r01BE);
                     body.emit(assign(r01BB, expr(ir_unop_i2u, r01BF), 0x01));


                  body.instructions = f01BC_parent_instructions;
                  body.emit(f01BC);

                  /* END IF */

                  body.emit(assign(r01AB, r01BB, 0x01));

                  body.emit(assign(r01AC, body.constant(0u), 0x01));


               body.instructions = f01B8_parent_instructions;
               body.emit(f01B8);

               /* END IF */


            body.instructions = f01B6_parent_instructions;
            body.emit(f01B6);

            /* END IF */

            body.emit(assign(r01AD, body.constant(0u), 0x01));


         body.instructions = f01B2_parent_instructions;
         body.emit(f01B2);

         /* END IF */

         ir_expression *const r01C0 = nequal(r01A9, body.constant(0u));
         ir_expression *const r01C1 = expr(ir_unop_b2i, r01C0);
         ir_expression *const r01C2 = expr(ir_unop_i2u, r01C1);
         body.emit(assign(r01AB, bit_or(r01AB, r01C2), 0x01));


      body.instructions = f01B0_parent_instructions;
      body.emit(f01B0);

      /* END IF */

      body.emit(assign(r0185, r01AD, 0x01));

      body.emit(assign(r0186, r01AC, 0x01));

      body.emit(assign(r0187, r01AB, 0x01));


   body.instructions = f019F_parent_instructions;
   body.emit(f019F);

   /* END IF */

   body.emit(assign(r0184, sub(r0184, r0188), 0x01));

   ir_variable *const r01C3 = body.make_temp(glsl_type::int_type, "zExp");
   body.emit(assign(r01C3, r0184, 0x01));

   ir_variable *const r01C4 = body.make_temp(glsl_type::uint_type, "zFrac0");
   body.emit(assign(r01C4, r0185, 0x01));

   ir_variable *const r01C5 = body.make_temp(glsl_type::uint_type, "zFrac1");
   body.emit(assign(r01C5, r0186, 0x01));

   ir_variable *const r01C6 = body.make_temp(glsl_type::uint_type, "zFrac2");
   body.emit(assign(r01C6, r0187, 0x01));

   ir_variable *const r01C7 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r01C7, body.constant(true), 0x01));

   ir_variable *const r01C8 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r01C9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r01C9);
   ir_expression *const r01CA = expr(ir_unop_u2i, r0187);
   body.emit(assign(r01C9, less(r01CA, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01CC = lequal(body.constant(int(2045)), r0184);
   ir_if *f01CB = new(mem_ctx) ir_if(operand(r01CC).val);
   exec_list *const f01CB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01CB->then_instructions;

      ir_variable *const r01CD = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r01CF = less(body.constant(int(2045)), r0184);
      ir_if *f01CE = new(mem_ctx) ir_if(operand(r01CF).val);
      exec_list *const f01CE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01CE->then_instructions;

         body.emit(assign(r01CD, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01CE->else_instructions;

         ir_variable *const r01D0 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r01D2 = equal(r0184, body.constant(int(2045)));
         ir_if *f01D1 = new(mem_ctx) ir_if(operand(r01D2).val);
         exec_list *const f01D1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D1->then_instructions;

            ir_expression *const r01D3 = equal(body.constant(2097151u), r0185);
            ir_expression *const r01D4 = equal(body.constant(4294967295u), r0186);
            body.emit(assign(r01D0, logic_and(r01D3, r01D4), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01D1->else_instructions;

            body.emit(assign(r01D0, body.constant(false), 0x01));


         body.instructions = f01D1_parent_instructions;
         body.emit(f01D1);

         /* END IF */

         body.emit(assign(r01CD, logic_and(r01D0, r01C9), 0x01));


      body.instructions = f01CE_parent_instructions;
      body.emit(f01CE);

      /* END IF */

      /* IF CONDITION */
      ir_if *f01D5 = new(mem_ctx) ir_if(operand(r01CD).val);
      exec_list *const f01D5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01D5->then_instructions;

         ir_variable *const r01D6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r01D6);
         ir_expression *const r01D7 = lshift(r0183, body.constant(int(31)));
         body.emit(assign(r01D6, add(r01D7, body.constant(2146435072u)), 0x02));

         body.emit(assign(r01D6, body.constant(0u), 0x01));

         body.emit(assign(r01C8, r01D6, 0x03));

         body.emit(assign(r01C7, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01D5->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01D9 = less(r0184, body.constant(int(0)));
         ir_if *f01D8 = new(mem_ctx) ir_if(operand(r01D9).val);
         exec_list *const f01D8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D8->then_instructions;

            ir_variable *const r01DA = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r01DA, r0187, 0x01));

            ir_variable *const r01DB = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r01DB, neg(r0184), 0x01));

            ir_variable *const r01DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r01DC);
            ir_variable *const r01DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r01DD);
            ir_variable *const r01DE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r01DE);
            ir_variable *const r01DF = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r01E0 = neg(r01DB);
            body.emit(assign(r01DF, bit_and(r01E0, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r01E2 = equal(r01DB, body.constant(int(0)));
            ir_if *f01E1 = new(mem_ctx) ir_if(operand(r01E2).val);
            exec_list *const f01E1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01E1->then_instructions;

               body.emit(assign(r01DC, r0187, 0x01));

               body.emit(assign(r01DD, r0186, 0x01));

               body.emit(assign(r01DE, r0185, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01E1->else_instructions;

               /* IF CONDITION */
               ir_expression *const r01E4 = less(r01DB, body.constant(int(32)));
               ir_if *f01E3 = new(mem_ctx) ir_if(operand(r01E4).val);
               exec_list *const f01E3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01E3->then_instructions;

                  body.emit(assign(r01DC, lshift(r0186, r01DF), 0x01));

                  ir_expression *const r01E5 = lshift(r0185, r01DF);
                  ir_expression *const r01E6 = rshift(r0186, r01DB);
                  body.emit(assign(r01DD, bit_or(r01E5, r01E6), 0x01));

                  body.emit(assign(r01DE, rshift(r0185, r01DB), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01E3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r01E8 = equal(r01DB, body.constant(int(32)));
                  ir_if *f01E7 = new(mem_ctx) ir_if(operand(r01E8).val);
                  exec_list *const f01E7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01E7->then_instructions;

                     body.emit(assign(r01DC, r0186, 0x01));

                     body.emit(assign(r01DD, r0185, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01E7->else_instructions;

                     body.emit(assign(r01DA, bit_or(r0187, r0186), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r01EA = less(r01DB, body.constant(int(64)));
                     ir_if *f01E9 = new(mem_ctx) ir_if(operand(r01EA).val);
                     exec_list *const f01E9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f01E9->then_instructions;

                        body.emit(assign(r01DC, lshift(r0185, r01DF), 0x01));

                        ir_expression *const r01EB = bit_and(r01DB, body.constant(int(31)));
                        body.emit(assign(r01DD, rshift(r0185, r01EB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f01E9->else_instructions;

                        ir_variable *const r01EC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r01EE = equal(r01DB, body.constant(int(64)));
                        ir_if *f01ED = new(mem_ctx) ir_if(operand(r01EE).val);
                        exec_list *const f01ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f01ED->then_instructions;

                           body.emit(assign(r01EC, r0185, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f01ED->else_instructions;

                           ir_expression *const r01EF = nequal(r0185, body.constant(0u));
                           ir_expression *const r01F0 = expr(ir_unop_b2i, r01EF);
                           body.emit(assign(r01EC, expr(ir_unop_i2u, r01F0), 0x01));


                        body.instructions = f01ED_parent_instructions;
                        body.emit(f01ED);

                        /* END IF */

                        body.emit(assign(r01DC, r01EC, 0x01));

                        body.emit(assign(r01DD, body.constant(0u), 0x01));


                     body.instructions = f01E9_parent_instructions;
                     body.emit(f01E9);

                     /* END IF */


                  body.instructions = f01E7_parent_instructions;
                  body.emit(f01E7);

                  /* END IF */

                  body.emit(assign(r01DE, body.constant(0u), 0x01));


               body.instructions = f01E3_parent_instructions;
               body.emit(f01E3);

               /* END IF */

               ir_expression *const r01F1 = nequal(r01DA, body.constant(0u));
               ir_expression *const r01F2 = expr(ir_unop_b2i, r01F1);
               ir_expression *const r01F3 = expr(ir_unop_i2u, r01F2);
               body.emit(assign(r01DC, bit_or(r01DC, r01F3), 0x01));


            body.instructions = f01E1_parent_instructions;
            body.emit(f01E1);

            /* END IF */

            body.emit(assign(r01C4, r01DE, 0x01));

            body.emit(assign(r01C5, r01DD, 0x01));

            body.emit(assign(r01C6, r01DC, 0x01));

            body.emit(assign(r01C3, body.constant(int(0)), 0x01));

            body.emit(assign(r01C9, less(r01DC, body.constant(0u)), 0x01));


         body.instructions = f01D8_parent_instructions;
         body.emit(f01D8);

         /* END IF */


      body.instructions = f01D5_parent_instructions;
      body.emit(f01D5);

      /* END IF */


   body.instructions = f01CB_parent_instructions;
   body.emit(f01CB);

   /* END IF */

   /* IF CONDITION */
   ir_if *f01F4 = new(mem_ctx) ir_if(operand(r01C7).val);
   exec_list *const f01F4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01F4->then_instructions;

      /* IF CONDITION */
      ir_if *f01F5 = new(mem_ctx) ir_if(operand(r01C9).val);
      exec_list *const f01F5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01F5->then_instructions;

         ir_variable *const r01F6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r01F6, add(r01C5, body.constant(1u)), 0x01));

         ir_expression *const r01F7 = less(r01F6, r01C5);
         ir_expression *const r01F8 = expr(ir_unop_b2i, r01F7);
         ir_expression *const r01F9 = expr(ir_unop_i2u, r01F8);
         body.emit(assign(r01C4, add(r01C4, r01F9), 0x01));

         ir_expression *const r01FA = equal(r01C6, body.constant(0u));
         ir_expression *const r01FB = expr(ir_unop_b2i, r01FA);
         ir_expression *const r01FC = expr(ir_unop_i2u, r01FB);
         ir_expression *const r01FD = add(r01C6, r01FC);
         ir_expression *const r01FE = bit_and(r01FD, body.constant(1u));
         ir_expression *const r01FF = expr(ir_unop_bit_not, r01FE);
         body.emit(assign(r01C5, bit_and(r01F6, r01FF), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01F5->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0201 = bit_or(r01C4, r01C5);
         ir_expression *const r0202 = equal(r0201, body.constant(0u));
         ir_if *f0200 = new(mem_ctx) ir_if(operand(r0202).val);
         exec_list *const f0200_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0200->then_instructions;

            body.emit(assign(r01C3, body.constant(int(0)), 0x01));


         body.instructions = f0200_parent_instructions;
         body.emit(f0200);

         /* END IF */


      body.instructions = f01F5_parent_instructions;
      body.emit(f01F5);

      /* END IF */

      ir_variable *const r0203 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r0203);
      ir_expression *const r0204 = lshift(r0183, body.constant(int(31)));
      ir_expression *const r0205 = expr(ir_unop_i2u, r01C3);
      ir_expression *const r0206 = lshift(r0205, body.constant(int(20)));
      ir_expression *const r0207 = add(r0204, r0206);
      body.emit(assign(r0203, add(r0207, r01C4), 0x02));

      body.emit(assign(r0203, r01C5, 0x01));

      body.emit(assign(r01C8, r0203, 0x03));

      body.emit(assign(r01C7, body.constant(false), 0x01));


   body.instructions = f01F4_parent_instructions;
   body.emit(f01F4);

   /* END IF */

   body.emit(ret(r01C8));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
propagateFloat64NaN(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0208 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0208);
   ir_variable *const r0209 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0209);
   ir_variable *const r020A = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r020B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r020C = lshift(swizzle_y(r0208), body.constant(int(1)));
   ir_expression *const r020D = lequal(body.constant(4292870144u), r020C);
   ir_expression *const r020E = nequal(swizzle_x(r0208), body.constant(0u));
   ir_expression *const r020F = bit_and(swizzle_y(r0208), body.constant(1048575u));
   ir_expression *const r0210 = nequal(r020F, body.constant(0u));
   ir_expression *const r0211 = logic_or(r020E, r0210);
   body.emit(assign(r020B, logic_and(r020D, r0211), 0x01));

   ir_variable *const r0212 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
   ir_expression *const r0213 = rshift(swizzle_y(r0208), body.constant(int(19)));
   ir_expression *const r0214 = bit_and(r0213, body.constant(4095u));
   ir_expression *const r0215 = equal(r0214, body.constant(4094u));
   ir_expression *const r0216 = nequal(swizzle_x(r0208), body.constant(0u));
   ir_expression *const r0217 = bit_and(swizzle_y(r0208), body.constant(524287u));
   ir_expression *const r0218 = nequal(r0217, body.constant(0u));
   ir_expression *const r0219 = logic_or(r0216, r0218);
   body.emit(assign(r0212, logic_and(r0215, r0219), 0x01));

   ir_variable *const r021A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r021B = lshift(swizzle_y(r0209), body.constant(int(1)));
   ir_expression *const r021C = lequal(body.constant(4292870144u), r021B);
   ir_expression *const r021D = nequal(swizzle_x(r0209), body.constant(0u));
   ir_expression *const r021E = bit_and(swizzle_y(r0209), body.constant(1048575u));
   ir_expression *const r021F = nequal(r021E, body.constant(0u));
   ir_expression *const r0220 = logic_or(r021D, r021F);
   body.emit(assign(r021A, logic_and(r021C, r0220), 0x01));

   body.emit(assign(r0208, bit_or(swizzle_y(r0208), body.constant(524288u)), 0x02));

   body.emit(assign(r0209, bit_or(swizzle_y(r0209), body.constant(524288u)), 0x02));

   /* IF CONDITION */
   ir_if *f0221 = new(mem_ctx) ir_if(operand(r020B).val);
   exec_list *const f0221_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0221->then_instructions;

      ir_variable *const r0222 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r0224 = logic_and(r0212, r021A);
      ir_if *f0223 = new(mem_ctx) ir_if(operand(r0224).val);
      exec_list *const f0223_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0223->then_instructions;

         body.emit(assign(r0222, r0209, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0223->else_instructions;

         body.emit(assign(r0222, r0208, 0x03));


      body.instructions = f0223_parent_instructions;
      body.emit(f0223);

      /* END IF */

      body.emit(assign(r020A, r0222, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0221->else_instructions;

      body.emit(assign(r020A, r0209, 0x03));


   body.instructions = f0221_parent_instructions;
   body.emit(f0221);

   /* END IF */

   body.emit(ret(r020A));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
addFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0225 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0225);
   ir_variable *const r0226 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0226);
   ir_variable *const r0227 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0227);
   ir_variable *const r0228 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r0228, body.constant(true), 0x01));

   ir_variable *const r0229 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r022A = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r022A);
   ir_variable *const r022B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r022B);
   ir_variable *const r022C = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r022C);
   ir_variable *const r022D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r022D);
   ir_variable *const r022E = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r022E);
   ir_variable *const r022F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r022F);
   ir_variable *const r0230 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0230);
   ir_variable *const r0231 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r0231);
   body.emit(assign(r0231, body.constant(0u), 0x01));

   body.emit(assign(r0230, body.constant(0u), 0x01));

   ir_variable *const r0232 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0232, swizzle_x(r0225), 0x01));

   body.emit(assign(r022E, r0232, 0x01));

   ir_variable *const r0233 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0233, bit_and(swizzle_y(r0225), body.constant(1048575u)), 0x01));

   body.emit(assign(r022D, r0233, 0x01));

   ir_variable *const r0234 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0234, swizzle_x(r0226), 0x01));

   body.emit(assign(r022C, r0234, 0x01));

   ir_variable *const r0235 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0235, bit_and(swizzle_y(r0226), body.constant(1048575u)), 0x01));

   body.emit(assign(r022B, r0235, 0x01));

   ir_variable *const r0236 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0237 = rshift(swizzle_y(r0225), body.constant(int(20)));
   ir_expression *const r0238 = bit_and(r0237, body.constant(2047u));
   body.emit(assign(r0236, expr(ir_unop_u2i, r0238), 0x01));

   ir_variable *const r0239 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r023A = rshift(swizzle_y(r0226), body.constant(int(20)));
   ir_expression *const r023B = bit_and(r023A, body.constant(2047u));
   body.emit(assign(r0239, expr(ir_unop_u2i, r023B), 0x01));

   ir_variable *const r023C = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r023C, sub(r0236, r0239), 0x01));

   body.emit(assign(r022A, r023C, 0x01));

   /* IF CONDITION */
   ir_expression *const r023E = less(body.constant(int(0)), r023C);
   ir_if *f023D = new(mem_ctx) ir_if(operand(r023E).val);
   exec_list *const f023D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f023D->then_instructions;

      /* IF CONDITION */
      ir_expression *const r0240 = equal(r0236, body.constant(int(2047)));
      ir_if *f023F = new(mem_ctx) ir_if(operand(r0240).val);
      exec_list *const f023F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f023F->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0242 = bit_or(r0233, swizzle_x(r0225));
         ir_expression *const r0243 = nequal(r0242, body.constant(0u));
         ir_if *f0241 = new(mem_ctx) ir_if(operand(r0243).val);
         exec_list *const f0241_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0241->then_instructions;

            ir_variable *const r0244 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r0244, swizzle_x(r0225), 0x01));

            ir_variable *const r0245 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r0245, swizzle_x(r0226), 0x01));

            ir_variable *const r0246 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0247 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r0248 = rshift(swizzle_y(r0225), body.constant(int(19)));
            ir_expression *const r0249 = bit_and(r0248, body.constant(4095u));
            ir_expression *const r024A = equal(r0249, body.constant(4094u));
            ir_expression *const r024B = nequal(swizzle_x(r0225), body.constant(0u));
            ir_expression *const r024C = bit_and(swizzle_y(r0225), body.constant(524287u));
            ir_expression *const r024D = nequal(r024C, body.constant(0u));
            ir_expression *const r024E = logic_or(r024B, r024D);
            body.emit(assign(r0247, logic_and(r024A, r024E), 0x01));

            ir_variable *const r024F = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0250 = lshift(swizzle_y(r0226), body.constant(int(1)));
            ir_expression *const r0251 = lequal(body.constant(4292870144u), r0250);
            ir_expression *const r0252 = nequal(swizzle_x(r0226), body.constant(0u));
            ir_expression *const r0253 = bit_and(swizzle_y(r0226), body.constant(1048575u));
            ir_expression *const r0254 = nequal(r0253, body.constant(0u));
            ir_expression *const r0255 = logic_or(r0252, r0254);
            body.emit(assign(r024F, logic_and(r0251, r0255), 0x01));

            body.emit(assign(r0244, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

            body.emit(assign(r0245, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0257 = lshift(swizzle_y(r0225), body.constant(int(1)));
            ir_expression *const r0258 = lequal(body.constant(4292870144u), r0257);
            ir_expression *const r0259 = nequal(swizzle_x(r0225), body.constant(0u));
            ir_expression *const r025A = bit_and(swizzle_y(r0225), body.constant(1048575u));
            ir_expression *const r025B = nequal(r025A, body.constant(0u));
            ir_expression *const r025C = logic_or(r0259, r025B);
            ir_expression *const r025D = logic_and(r0258, r025C);
            ir_if *f0256 = new(mem_ctx) ir_if(operand(r025D).val);
            exec_list *const f0256_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0256->then_instructions;

               ir_variable *const r025E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0260 = logic_and(r0247, r024F);
               ir_if *f025F = new(mem_ctx) ir_if(operand(r0260).val);
               exec_list *const f025F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f025F->then_instructions;

                  body.emit(assign(r025E, r0245, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f025F->else_instructions;

                  body.emit(assign(r025E, r0244, 0x03));


               body.instructions = f025F_parent_instructions;
               body.emit(f025F);

               /* END IF */

               body.emit(assign(r0246, r025E, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0256->else_instructions;

               body.emit(assign(r0246, r0245, 0x03));


            body.instructions = f0256_parent_instructions;
            body.emit(f0256);

            /* END IF */

            body.emit(assign(r0229, r0246, 0x03));

            body.emit(assign(r0228, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0241->else_instructions;

            body.emit(assign(r0229, r0225, 0x03));

            body.emit(assign(r0228, body.constant(false), 0x01));


         body.instructions = f0241_parent_instructions;
         body.emit(f0241);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f023F->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0262 = equal(r0239, body.constant(int(0)));
         ir_if *f0261 = new(mem_ctx) ir_if(operand(r0262).val);
         exec_list *const f0261_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0261->then_instructions;

            body.emit(assign(r022A, add(r023C, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0261->else_instructions;

            body.emit(assign(r022B, bit_or(r0235, body.constant(1048576u)), 0x01));


         body.instructions = f0261_parent_instructions;
         body.emit(f0261);

         /* END IF */

         ir_variable *const r0263 = body.make_temp(glsl_type::uint_type, "a2");
         body.emit(assign(r0263, body.constant(0u), 0x01));

         ir_variable *const r0264 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0264);
         ir_variable *const r0265 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0265);
         ir_variable *const r0266 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0266);
         ir_variable *const r0267 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0268 = neg(r022A);
         body.emit(assign(r0267, bit_and(r0268, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r026A = equal(r022A, body.constant(int(0)));
         ir_if *f0269 = new(mem_ctx) ir_if(operand(r026A).val);
         exec_list *const f0269_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0269->then_instructions;

            body.emit(assign(r0264, r0263, 0x01));

            body.emit(assign(r0265, r0234, 0x01));

            body.emit(assign(r0266, r022B, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0269->else_instructions;

            /* IF CONDITION */
            ir_expression *const r026C = less(r022A, body.constant(int(32)));
            ir_if *f026B = new(mem_ctx) ir_if(operand(r026C).val);
            exec_list *const f026B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f026B->then_instructions;

               body.emit(assign(r0264, lshift(swizzle_x(r0226), r0267), 0x01));

               ir_expression *const r026D = lshift(r022B, r0267);
               ir_expression *const r026E = rshift(swizzle_x(r0226), r022A);
               body.emit(assign(r0265, bit_or(r026D, r026E), 0x01));

               body.emit(assign(r0266, rshift(r022B, r022A), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f026B->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0270 = equal(r022A, body.constant(int(32)));
               ir_if *f026F = new(mem_ctx) ir_if(operand(r0270).val);
               exec_list *const f026F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f026F->then_instructions;

                  body.emit(assign(r0264, r0234, 0x01));

                  body.emit(assign(r0265, r022B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f026F->else_instructions;

                  body.emit(assign(r0263, bit_or(body.constant(0u), swizzle_x(r0226)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0272 = less(r022A, body.constant(int(64)));
                  ir_if *f0271 = new(mem_ctx) ir_if(operand(r0272).val);
                  exec_list *const f0271_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0271->then_instructions;

                     body.emit(assign(r0264, lshift(r022B, r0267), 0x01));

                     ir_expression *const r0273 = bit_and(r022A, body.constant(int(31)));
                     body.emit(assign(r0265, rshift(r022B, r0273), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0271->else_instructions;

                     ir_variable *const r0274 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0276 = equal(r022A, body.constant(int(64)));
                     ir_if *f0275 = new(mem_ctx) ir_if(operand(r0276).val);
                     exec_list *const f0275_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0275->then_instructions;

                        body.emit(assign(r0274, r022B, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0275->else_instructions;

                        ir_expression *const r0277 = nequal(r022B, body.constant(0u));
                        ir_expression *const r0278 = expr(ir_unop_b2i, r0277);
                        body.emit(assign(r0274, expr(ir_unop_i2u, r0278), 0x01));


                     body.instructions = f0275_parent_instructions;
                     body.emit(f0275);

                     /* END IF */

                     body.emit(assign(r0264, r0274, 0x01));

                     body.emit(assign(r0265, body.constant(0u), 0x01));


                  body.instructions = f0271_parent_instructions;
                  body.emit(f0271);

                  /* END IF */


               body.instructions = f026F_parent_instructions;
               body.emit(f026F);

               /* END IF */

               body.emit(assign(r0266, body.constant(0u), 0x01));


            body.instructions = f026B_parent_instructions;
            body.emit(f026B);

            /* END IF */

            ir_expression *const r0279 = nequal(r0263, body.constant(0u));
            ir_expression *const r027A = expr(ir_unop_b2i, r0279);
            ir_expression *const r027B = expr(ir_unop_i2u, r027A);
            body.emit(assign(r0264, bit_or(r0264, r027B), 0x01));


         body.instructions = f0269_parent_instructions;
         body.emit(f0269);

         /* END IF */

         body.emit(assign(r022B, r0266, 0x01));

         body.emit(assign(r022C, r0265, 0x01));

         body.emit(assign(r0230, r0264, 0x01));

         body.emit(assign(r022F, r0236, 0x01));


      body.instructions = f023F_parent_instructions;
      body.emit(f023F);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f023D->else_instructions;

      /* IF CONDITION */
      ir_expression *const r027D = less(r022A, body.constant(int(0)));
      ir_if *f027C = new(mem_ctx) ir_if(operand(r027D).val);
      exec_list *const f027C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f027C->then_instructions;

         /* IF CONDITION */
         ir_expression *const r027F = equal(r0239, body.constant(int(2047)));
         ir_if *f027E = new(mem_ctx) ir_if(operand(r027F).val);
         exec_list *const f027E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f027E->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0281 = bit_or(r022B, r022C);
            ir_expression *const r0282 = nequal(r0281, body.constant(0u));
            ir_if *f0280 = new(mem_ctx) ir_if(operand(r0282).val);
            exec_list *const f0280_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0280->then_instructions;

               ir_variable *const r0283 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0283, swizzle_x(r0225), 0x01));

               ir_variable *const r0284 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0284, swizzle_x(r0226), 0x01));

               ir_variable *const r0285 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0286 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0287 = rshift(swizzle_y(r0225), body.constant(int(19)));
               ir_expression *const r0288 = bit_and(r0287, body.constant(4095u));
               ir_expression *const r0289 = equal(r0288, body.constant(4094u));
               ir_expression *const r028A = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r028B = bit_and(swizzle_y(r0225), body.constant(524287u));
               ir_expression *const r028C = nequal(r028B, body.constant(0u));
               ir_expression *const r028D = logic_or(r028A, r028C);
               body.emit(assign(r0286, logic_and(r0289, r028D), 0x01));

               ir_variable *const r028E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r028F = lshift(swizzle_y(r0226), body.constant(int(1)));
               ir_expression *const r0290 = lequal(body.constant(4292870144u), r028F);
               ir_expression *const r0291 = nequal(swizzle_x(r0226), body.constant(0u));
               ir_expression *const r0292 = bit_and(swizzle_y(r0226), body.constant(1048575u));
               ir_expression *const r0293 = nequal(r0292, body.constant(0u));
               ir_expression *const r0294 = logic_or(r0291, r0293);
               body.emit(assign(r028E, logic_and(r0290, r0294), 0x01));

               body.emit(assign(r0283, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

               body.emit(assign(r0284, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0296 = lshift(swizzle_y(r0225), body.constant(int(1)));
               ir_expression *const r0297 = lequal(body.constant(4292870144u), r0296);
               ir_expression *const r0298 = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r0299 = bit_and(swizzle_y(r0225), body.constant(1048575u));
               ir_expression *const r029A = nequal(r0299, body.constant(0u));
               ir_expression *const r029B = logic_or(r0298, r029A);
               ir_expression *const r029C = logic_and(r0297, r029B);
               ir_if *f0295 = new(mem_ctx) ir_if(operand(r029C).val);
               exec_list *const f0295_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0295->then_instructions;

                  ir_variable *const r029D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r029F = logic_and(r0286, r028E);
                  ir_if *f029E = new(mem_ctx) ir_if(operand(r029F).val);
                  exec_list *const f029E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f029E->then_instructions;

                     body.emit(assign(r029D, r0284, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f029E->else_instructions;

                     body.emit(assign(r029D, r0283, 0x03));


                  body.instructions = f029E_parent_instructions;
                  body.emit(f029E);

                  /* END IF */

                  body.emit(assign(r0285, r029D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0295->else_instructions;

                  body.emit(assign(r0285, r0284, 0x03));


               body.instructions = f0295_parent_instructions;
               body.emit(f0295);

               /* END IF */

               body.emit(assign(r0229, r0285, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0280->else_instructions;

               ir_variable *const r02A0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02A0);
               ir_expression *const r02A1 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r02A0, add(r02A1, body.constant(2146435072u)), 0x02));

               body.emit(assign(r02A0, body.constant(0u), 0x01));

               body.emit(assign(r0229, r02A0, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f0280_parent_instructions;
            body.emit(f0280);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f027E->else_instructions;

            /* IF CONDITION */
            ir_expression *const r02A3 = equal(r0236, body.constant(int(0)));
            ir_if *f02A2 = new(mem_ctx) ir_if(operand(r02A3).val);
            exec_list *const f02A2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02A2->then_instructions;

               body.emit(assign(r022A, add(r022A, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02A2->else_instructions;

               body.emit(assign(r022D, bit_or(r0233, body.constant(1048576u)), 0x01));


            body.instructions = f02A2_parent_instructions;
            body.emit(f02A2);

            /* END IF */

            ir_variable *const r02A4 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r02A4, body.constant(0u), 0x01));

            ir_variable *const r02A5 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r02A5, neg(r022A), 0x01));

            ir_variable *const r02A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r02A6);
            ir_variable *const r02A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r02A7);
            ir_variable *const r02A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r02A8);
            ir_variable *const r02A9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r02AA = neg(r02A5);
            body.emit(assign(r02A9, bit_and(r02AA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r02AC = equal(r02A5, body.constant(int(0)));
            ir_if *f02AB = new(mem_ctx) ir_if(operand(r02AC).val);
            exec_list *const f02AB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02AB->then_instructions;

               body.emit(assign(r02A6, r02A4, 0x01));

               body.emit(assign(r02A7, r0232, 0x01));

               body.emit(assign(r02A8, r022D, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02AB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r02AE = less(r02A5, body.constant(int(32)));
               ir_if *f02AD = new(mem_ctx) ir_if(operand(r02AE).val);
               exec_list *const f02AD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02AD->then_instructions;

                  body.emit(assign(r02A6, lshift(swizzle_x(r0225), r02A9), 0x01));

                  ir_expression *const r02AF = lshift(r022D, r02A9);
                  ir_expression *const r02B0 = rshift(swizzle_x(r0225), r02A5);
                  body.emit(assign(r02A7, bit_or(r02AF, r02B0), 0x01));

                  body.emit(assign(r02A8, rshift(r022D, r02A5), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02AD->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r02B2 = equal(r02A5, body.constant(int(32)));
                  ir_if *f02B1 = new(mem_ctx) ir_if(operand(r02B2).val);
                  exec_list *const f02B1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02B1->then_instructions;

                     body.emit(assign(r02A6, r0232, 0x01));

                     body.emit(assign(r02A7, r022D, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02B1->else_instructions;

                     body.emit(assign(r02A4, bit_or(body.constant(0u), swizzle_x(r0225)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r02B4 = less(r02A5, body.constant(int(64)));
                     ir_if *f02B3 = new(mem_ctx) ir_if(operand(r02B4).val);
                     exec_list *const f02B3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02B3->then_instructions;

                        body.emit(assign(r02A6, lshift(r022D, r02A9), 0x01));

                        ir_expression *const r02B5 = bit_and(r02A5, body.constant(int(31)));
                        body.emit(assign(r02A7, rshift(r022D, r02B5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02B3->else_instructions;

                        ir_variable *const r02B6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r02B8 = equal(r02A5, body.constant(int(64)));
                        ir_if *f02B7 = new(mem_ctx) ir_if(operand(r02B8).val);
                        exec_list *const f02B7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f02B7->then_instructions;

                           body.emit(assign(r02B6, r022D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f02B7->else_instructions;

                           ir_expression *const r02B9 = nequal(r022D, body.constant(0u));
                           ir_expression *const r02BA = expr(ir_unop_b2i, r02B9);
                           body.emit(assign(r02B6, expr(ir_unop_i2u, r02BA), 0x01));


                        body.instructions = f02B7_parent_instructions;
                        body.emit(f02B7);

                        /* END IF */

                        body.emit(assign(r02A6, r02B6, 0x01));

                        body.emit(assign(r02A7, body.constant(0u), 0x01));


                     body.instructions = f02B3_parent_instructions;
                     body.emit(f02B3);

                     /* END IF */


                  body.instructions = f02B1_parent_instructions;
                  body.emit(f02B1);

                  /* END IF */

                  body.emit(assign(r02A8, body.constant(0u), 0x01));


               body.instructions = f02AD_parent_instructions;
               body.emit(f02AD);

               /* END IF */

               ir_expression *const r02BB = nequal(r02A4, body.constant(0u));
               ir_expression *const r02BC = expr(ir_unop_b2i, r02BB);
               ir_expression *const r02BD = expr(ir_unop_i2u, r02BC);
               body.emit(assign(r02A6, bit_or(r02A6, r02BD), 0x01));


            body.instructions = f02AB_parent_instructions;
            body.emit(f02AB);

            /* END IF */

            body.emit(assign(r022D, r02A8, 0x01));

            body.emit(assign(r022E, r02A7, 0x01));

            body.emit(assign(r0230, r02A6, 0x01));

            body.emit(assign(r022F, r0239, 0x01));


         body.instructions = f027E_parent_instructions;
         body.emit(f027E);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f027C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r02BF = equal(r0236, body.constant(int(2047)));
         ir_if *f02BE = new(mem_ctx) ir_if(operand(r02BF).val);
         exec_list *const f02BE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f02BE->then_instructions;

            /* IF CONDITION */
            ir_expression *const r02C1 = bit_or(r022D, r022E);
            ir_expression *const r02C2 = bit_or(r022B, r022C);
            ir_expression *const r02C3 = bit_or(r02C1, r02C2);
            ir_expression *const r02C4 = nequal(r02C3, body.constant(0u));
            ir_if *f02C0 = new(mem_ctx) ir_if(operand(r02C4).val);
            exec_list *const f02C0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02C0->then_instructions;

               ir_variable *const r02C5 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r02C5, swizzle_x(r0225), 0x01));

               ir_variable *const r02C6 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r02C6, swizzle_x(r0226), 0x01));

               ir_variable *const r02C7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02C8 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r02C9 = rshift(swizzle_y(r0225), body.constant(int(19)));
               ir_expression *const r02CA = bit_and(r02C9, body.constant(4095u));
               ir_expression *const r02CB = equal(r02CA, body.constant(4094u));
               ir_expression *const r02CC = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r02CD = bit_and(swizzle_y(r0225), body.constant(524287u));
               ir_expression *const r02CE = nequal(r02CD, body.constant(0u));
               ir_expression *const r02CF = logic_or(r02CC, r02CE);
               body.emit(assign(r02C8, logic_and(r02CB, r02CF), 0x01));

               ir_variable *const r02D0 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r02D1 = lshift(swizzle_y(r0226), body.constant(int(1)));
               ir_expression *const r02D2 = lequal(body.constant(4292870144u), r02D1);
               ir_expression *const r02D3 = nequal(swizzle_x(r0226), body.constant(0u));
               ir_expression *const r02D4 = bit_and(swizzle_y(r0226), body.constant(1048575u));
               ir_expression *const r02D5 = nequal(r02D4, body.constant(0u));
               ir_expression *const r02D6 = logic_or(r02D3, r02D5);
               body.emit(assign(r02D0, logic_and(r02D2, r02D6), 0x01));

               body.emit(assign(r02C5, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

               body.emit(assign(r02C6, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r02D8 = lshift(swizzle_y(r0225), body.constant(int(1)));
               ir_expression *const r02D9 = lequal(body.constant(4292870144u), r02D8);
               ir_expression *const r02DA = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r02DB = bit_and(swizzle_y(r0225), body.constant(1048575u));
               ir_expression *const r02DC = nequal(r02DB, body.constant(0u));
               ir_expression *const r02DD = logic_or(r02DA, r02DC);
               ir_expression *const r02DE = logic_and(r02D9, r02DD);
               ir_if *f02D7 = new(mem_ctx) ir_if(operand(r02DE).val);
               exec_list *const f02D7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02D7->then_instructions;

                  ir_variable *const r02DF = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02E1 = logic_and(r02C8, r02D0);
                  ir_if *f02E0 = new(mem_ctx) ir_if(operand(r02E1).val);
                  exec_list *const f02E0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02E0->then_instructions;

                     body.emit(assign(r02DF, r02C6, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02E0->else_instructions;

                     body.emit(assign(r02DF, r02C5, 0x03));


                  body.instructions = f02E0_parent_instructions;
                  body.emit(f02E0);

                  /* END IF */

                  body.emit(assign(r02C7, r02DF, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02D7->else_instructions;

                  body.emit(assign(r02C7, r02C6, 0x03));


               body.instructions = f02D7_parent_instructions;
               body.emit(f02D7);

               /* END IF */

               body.emit(assign(r0229, r02C7, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02C0->else_instructions;

               body.emit(assign(r0229, r0225, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f02C0_parent_instructions;
            body.emit(f02C0);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f02BE->else_instructions;

            ir_variable *const r02E2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r02E3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r02E3, add(r022E, r022C), 0x01));

            ir_expression *const r02E4 = add(r022D, r022B);
            ir_expression *const r02E5 = less(r02E3, r022E);
            ir_expression *const r02E6 = expr(ir_unop_b2i, r02E5);
            ir_expression *const r02E7 = expr(ir_unop_i2u, r02E6);
            body.emit(assign(r02E2, add(r02E4, r02E7), 0x01));

            body.emit(assign(r0231, r02E2, 0x01));

            /* IF CONDITION */
            ir_expression *const r02E9 = equal(r0236, body.constant(int(0)));
            ir_if *f02E8 = new(mem_ctx) ir_if(operand(r02E9).val);
            exec_list *const f02E8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02E8->then_instructions;

               ir_variable *const r02EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02EA);
               ir_expression *const r02EB = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r02EA, add(r02EB, r02E2), 0x02));

               body.emit(assign(r02EA, r02E3, 0x01));

               body.emit(assign(r0229, r02EA, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02E8->else_instructions;

               body.emit(assign(r0231, bit_or(r02E2, body.constant(2097152u)), 0x01));

               body.emit(assign(r022F, r0236, 0x01));

               ir_variable *const r02EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r02EC);
               ir_variable *const r02ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r02ED);
               ir_variable *const r02EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r02EE);
               body.emit(assign(r02EC, lshift(r02E3, body.constant(int(31))), 0x01));

               ir_expression *const r02EF = lshift(r0231, body.constant(int(31)));
               ir_expression *const r02F0 = rshift(r02E3, body.constant(int(1)));
               body.emit(assign(r02ED, bit_or(r02EF, r02F0), 0x01));

               body.emit(assign(r02EE, rshift(r0231, body.constant(int(1))), 0x01));

               body.emit(assign(r02EC, bit_or(r02EC, body.constant(0u)), 0x01));

               body.emit(assign(r0231, r02EE, 0x01));

               body.emit(assign(r0230, r02EC, 0x01));

               ir_variable *const r02F1 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r02F1, r0236, 0x01));

               ir_variable *const r02F2 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r02F2, r02EE, 0x01));

               ir_variable *const r02F3 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r02F3, r02ED, 0x01));

               ir_variable *const r02F4 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r02F4, r02EC, 0x01));

               ir_variable *const r02F5 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r02F5, body.constant(true), 0x01));

               ir_variable *const r02F6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02F7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r02F7);
               ir_expression *const r02F8 = expr(ir_unop_u2i, r02EC);
               body.emit(assign(r02F7, less(r02F8, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r02FA = lequal(body.constant(int(2045)), r0236);
               ir_if *f02F9 = new(mem_ctx) ir_if(operand(r02FA).val);
               exec_list *const f02F9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02F9->then_instructions;

                  ir_variable *const r02FB = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02FD = less(body.constant(int(2045)), r0236);
                  ir_if *f02FC = new(mem_ctx) ir_if(operand(r02FD).val);
                  exec_list *const f02FC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02FC->then_instructions;

                     body.emit(assign(r02FB, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02FC->else_instructions;

                     ir_variable *const r02FE = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0300 = equal(r0236, body.constant(int(2045)));
                     ir_if *f02FF = new(mem_ctx) ir_if(operand(r0300).val);
                     exec_list *const f02FF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02FF->then_instructions;

                        ir_expression *const r0301 = equal(body.constant(2097151u), r02EE);
                        ir_expression *const r0302 = equal(body.constant(4294967295u), r02ED);
                        body.emit(assign(r02FE, logic_and(r0301, r0302), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02FF->else_instructions;

                        body.emit(assign(r02FE, body.constant(false), 0x01));


                     body.instructions = f02FF_parent_instructions;
                     body.emit(f02FF);

                     /* END IF */

                     body.emit(assign(r02FB, logic_and(r02FE, r02F7), 0x01));


                  body.instructions = f02FC_parent_instructions;
                  body.emit(f02FC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0303 = new(mem_ctx) ir_if(operand(r02FB).val);
                  exec_list *const f0303_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0303->then_instructions;

                     ir_variable *const r0304 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0304);
                     ir_expression *const r0305 = lshift(r0227, body.constant(int(31)));
                     body.emit(assign(r0304, add(r0305, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0304, body.constant(0u), 0x01));

                     body.emit(assign(r02F6, r0304, 0x03));

                     body.emit(assign(r02F5, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0303->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0307 = less(r0236, body.constant(int(0)));
                     ir_if *f0306 = new(mem_ctx) ir_if(operand(r0307).val);
                     exec_list *const f0306_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0306->then_instructions;

                        ir_variable *const r0308 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0308, r02EC, 0x01));

                        ir_variable *const r0309 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0309, neg(r0236), 0x01));

                        ir_variable *const r030A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r030A);
                        ir_variable *const r030B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r030B);
                        ir_variable *const r030C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r030C);
                        ir_variable *const r030D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r030E = neg(r0309);
                        body.emit(assign(r030D, bit_and(r030E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0310 = equal(r0309, body.constant(int(0)));
                        ir_if *f030F = new(mem_ctx) ir_if(operand(r0310).val);
                        exec_list *const f030F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f030F->then_instructions;

                           body.emit(assign(r030A, r02EC, 0x01));

                           body.emit(assign(r030B, r02ED, 0x01));

                           body.emit(assign(r030C, r02EE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f030F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0312 = less(r0309, body.constant(int(32)));
                           ir_if *f0311 = new(mem_ctx) ir_if(operand(r0312).val);
                           exec_list *const f0311_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0311->then_instructions;

                              body.emit(assign(r030A, lshift(r02ED, r030D), 0x01));

                              ir_expression *const r0313 = lshift(r02EE, r030D);
                              ir_expression *const r0314 = rshift(r02ED, r0309);
                              body.emit(assign(r030B, bit_or(r0313, r0314), 0x01));

                              body.emit(assign(r030C, rshift(r02EE, r0309), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0311->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0316 = equal(r0309, body.constant(int(32)));
                              ir_if *f0315 = new(mem_ctx) ir_if(operand(r0316).val);
                              exec_list *const f0315_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0315->then_instructions;

                                 body.emit(assign(r030A, r02ED, 0x01));

                                 body.emit(assign(r030B, r02EE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0315->else_instructions;

                                 body.emit(assign(r0308, bit_or(r02EC, r02ED), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0318 = less(r0309, body.constant(int(64)));
                                 ir_if *f0317 = new(mem_ctx) ir_if(operand(r0318).val);
                                 exec_list *const f0317_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0317->then_instructions;

                                    body.emit(assign(r030A, lshift(r02EE, r030D), 0x01));

                                    ir_expression *const r0319 = bit_and(r0309, body.constant(int(31)));
                                    body.emit(assign(r030B, rshift(r02EE, r0319), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0317->else_instructions;

                                    ir_variable *const r031A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r031C = equal(r0309, body.constant(int(64)));
                                    ir_if *f031B = new(mem_ctx) ir_if(operand(r031C).val);
                                    exec_list *const f031B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f031B->then_instructions;

                                       body.emit(assign(r031A, r02EE, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f031B->else_instructions;

                                       ir_expression *const r031D = nequal(r02EE, body.constant(0u));
                                       ir_expression *const r031E = expr(ir_unop_b2i, r031D);
                                       body.emit(assign(r031A, expr(ir_unop_i2u, r031E), 0x01));


                                    body.instructions = f031B_parent_instructions;
                                    body.emit(f031B);

                                    /* END IF */

                                    body.emit(assign(r030A, r031A, 0x01));

                                    body.emit(assign(r030B, body.constant(0u), 0x01));


                                 body.instructions = f0317_parent_instructions;
                                 body.emit(f0317);

                                 /* END IF */


                              body.instructions = f0315_parent_instructions;
                              body.emit(f0315);

                              /* END IF */

                              body.emit(assign(r030C, body.constant(0u), 0x01));


                           body.instructions = f0311_parent_instructions;
                           body.emit(f0311);

                           /* END IF */

                           ir_expression *const r031F = nequal(r0308, body.constant(0u));
                           ir_expression *const r0320 = expr(ir_unop_b2i, r031F);
                           ir_expression *const r0321 = expr(ir_unop_i2u, r0320);
                           body.emit(assign(r030A, bit_or(r030A, r0321), 0x01));


                        body.instructions = f030F_parent_instructions;
                        body.emit(f030F);

                        /* END IF */

                        body.emit(assign(r02F2, r030C, 0x01));

                        body.emit(assign(r02F3, r030B, 0x01));

                        body.emit(assign(r02F4, r030A, 0x01));

                        body.emit(assign(r02F1, body.constant(int(0)), 0x01));

                        body.emit(assign(r02F7, less(r030A, body.constant(0u)), 0x01));


                     body.instructions = f0306_parent_instructions;
                     body.emit(f0306);

                     /* END IF */


                  body.instructions = f0303_parent_instructions;
                  body.emit(f0303);

                  /* END IF */


               body.instructions = f02F9_parent_instructions;
               body.emit(f02F9);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0322 = new(mem_ctx) ir_if(operand(r02F5).val);
               exec_list *const f0322_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0322->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0323 = new(mem_ctx) ir_if(operand(r02F7).val);
                  exec_list *const f0323_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0323->then_instructions;

                     ir_variable *const r0324 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0324, add(r02F3, body.constant(1u)), 0x01));

                     ir_expression *const r0325 = less(r0324, r02F3);
                     ir_expression *const r0326 = expr(ir_unop_b2i, r0325);
                     ir_expression *const r0327 = expr(ir_unop_i2u, r0326);
                     body.emit(assign(r02F2, add(r02F2, r0327), 0x01));

                     ir_expression *const r0328 = equal(r02F4, body.constant(0u));
                     ir_expression *const r0329 = expr(ir_unop_b2i, r0328);
                     ir_expression *const r032A = expr(ir_unop_i2u, r0329);
                     ir_expression *const r032B = add(r02F4, r032A);
                     ir_expression *const r032C = bit_and(r032B, body.constant(1u));
                     ir_expression *const r032D = expr(ir_unop_bit_not, r032C);
                     body.emit(assign(r02F3, bit_and(r0324, r032D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0323->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r032F = bit_or(r02F2, r02F3);
                     ir_expression *const r0330 = equal(r032F, body.constant(0u));
                     ir_if *f032E = new(mem_ctx) ir_if(operand(r0330).val);
                     exec_list *const f032E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f032E->then_instructions;

                        body.emit(assign(r02F1, body.constant(int(0)), 0x01));


                     body.instructions = f032E_parent_instructions;
                     body.emit(f032E);

                     /* END IF */


                  body.instructions = f0323_parent_instructions;
                  body.emit(f0323);

                  /* END IF */

                  ir_variable *const r0331 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0331);
                  ir_expression *const r0332 = lshift(r0227, body.constant(int(31)));
                  ir_expression *const r0333 = expr(ir_unop_i2u, r02F1);
                  ir_expression *const r0334 = lshift(r0333, body.constant(int(20)));
                  ir_expression *const r0335 = add(r0332, r0334);
                  body.emit(assign(r0331, add(r0335, r02F2), 0x02));

                  body.emit(assign(r0331, r02F3, 0x01));

                  body.emit(assign(r02F6, r0331, 0x03));

                  body.emit(assign(r02F5, body.constant(false), 0x01));


               body.instructions = f0322_parent_instructions;
               body.emit(f0322);

               /* END IF */

               body.emit(assign(r0229, r02F6, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f02E8_parent_instructions;
            body.emit(f02E8);

            /* END IF */


         body.instructions = f02BE_parent_instructions;
         body.emit(f02BE);

         /* END IF */


      body.instructions = f027C_parent_instructions;
      body.emit(f027C);

      /* END IF */


   body.instructions = f023D_parent_instructions;
   body.emit(f023D);

   /* END IF */

   /* IF CONDITION */
   ir_if *f0336 = new(mem_ctx) ir_if(operand(r0228).val);
   exec_list *const f0336_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0336->then_instructions;

      body.emit(assign(r022D, bit_or(r022D, body.constant(1048576u)), 0x01));

      ir_variable *const r0337 = body.make_temp(glsl_type::uint_type, "z0Ptr");
      ir_variable *const r0338 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r0338, add(r022E, r022C), 0x01));

      ir_expression *const r0339 = add(r022D, r022B);
      ir_expression *const r033A = less(r0338, r022E);
      ir_expression *const r033B = expr(ir_unop_b2i, r033A);
      ir_expression *const r033C = expr(ir_unop_i2u, r033B);
      body.emit(assign(r0337, add(r0339, r033C), 0x01));

      body.emit(assign(r0231, r0337, 0x01));

      body.emit(assign(r022F, add(r022F, body.constant(int(-1))), 0x01));

      /* IF CONDITION */
      ir_expression *const r033E = less(r0337, body.constant(2097152u));
      ir_if *f033D = new(mem_ctx) ir_if(operand(r033E).val);
      exec_list *const f033D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f033D->then_instructions;

         ir_variable *const r033F = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r033F, r022F, 0x01));

         ir_variable *const r0340 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0340, r0337, 0x01));

         ir_variable *const r0341 = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r0341, r0338, 0x01));

         ir_variable *const r0342 = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r0342, r0230, 0x01));

         ir_variable *const r0343 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0343, body.constant(true), 0x01));

         ir_variable *const r0344 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0345 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0345);
         ir_expression *const r0346 = expr(ir_unop_u2i, r0230);
         body.emit(assign(r0345, less(r0346, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0348 = lequal(body.constant(int(2045)), r022F);
         ir_if *f0347 = new(mem_ctx) ir_if(operand(r0348).val);
         exec_list *const f0347_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0347->then_instructions;

            ir_variable *const r0349 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r034B = less(body.constant(int(2045)), r022F);
            ir_if *f034A = new(mem_ctx) ir_if(operand(r034B).val);
            exec_list *const f034A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f034A->then_instructions;

               body.emit(assign(r0349, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f034A->else_instructions;

               ir_variable *const r034C = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r034E = equal(r022F, body.constant(int(2045)));
               ir_if *f034D = new(mem_ctx) ir_if(operand(r034E).val);
               exec_list *const f034D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f034D->then_instructions;

                  ir_expression *const r034F = equal(body.constant(2097151u), r0337);
                  ir_expression *const r0350 = equal(body.constant(4294967295u), r0338);
                  body.emit(assign(r034C, logic_and(r034F, r0350), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f034D->else_instructions;

                  body.emit(assign(r034C, body.constant(false), 0x01));


               body.instructions = f034D_parent_instructions;
               body.emit(f034D);

               /* END IF */

               body.emit(assign(r0349, logic_and(r034C, r0345), 0x01));


            body.instructions = f034A_parent_instructions;
            body.emit(f034A);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0351 = new(mem_ctx) ir_if(operand(r0349).val);
            exec_list *const f0351_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0351->then_instructions;

               ir_variable *const r0352 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0352);
               ir_expression *const r0353 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r0352, add(r0353, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0352, body.constant(0u), 0x01));

               body.emit(assign(r0344, r0352, 0x03));

               body.emit(assign(r0343, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0351->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0355 = less(r022F, body.constant(int(0)));
               ir_if *f0354 = new(mem_ctx) ir_if(operand(r0355).val);
               exec_list *const f0354_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0354->then_instructions;

                  ir_variable *const r0356 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0356, r0230, 0x01));

                  ir_variable *const r0357 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0357, neg(r022F), 0x01));

                  ir_variable *const r0358 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0358);
                  ir_variable *const r0359 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0359);
                  ir_variable *const r035A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r035A);
                  ir_variable *const r035B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r035C = neg(r0357);
                  body.emit(assign(r035B, bit_and(r035C, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r035E = equal(r0357, body.constant(int(0)));
                  ir_if *f035D = new(mem_ctx) ir_if(operand(r035E).val);
                  exec_list *const f035D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f035D->then_instructions;

                     body.emit(assign(r0358, r0230, 0x01));

                     body.emit(assign(r0359, r0338, 0x01));

                     body.emit(assign(r035A, r0337, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f035D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0360 = less(r0357, body.constant(int(32)));
                     ir_if *f035F = new(mem_ctx) ir_if(operand(r0360).val);
                     exec_list *const f035F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f035F->then_instructions;

                        body.emit(assign(r0358, lshift(r0338, r035B), 0x01));

                        ir_expression *const r0361 = lshift(r0337, r035B);
                        ir_expression *const r0362 = rshift(r0338, r0357);
                        body.emit(assign(r0359, bit_or(r0361, r0362), 0x01));

                        body.emit(assign(r035A, rshift(r0337, r0357), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f035F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0364 = equal(r0357, body.constant(int(32)));
                        ir_if *f0363 = new(mem_ctx) ir_if(operand(r0364).val);
                        exec_list *const f0363_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0363->then_instructions;

                           body.emit(assign(r0358, r0338, 0x01));

                           body.emit(assign(r0359, r0337, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0363->else_instructions;

                           body.emit(assign(r0356, bit_or(r0230, r0338), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0366 = less(r0357, body.constant(int(64)));
                           ir_if *f0365 = new(mem_ctx) ir_if(operand(r0366).val);
                           exec_list *const f0365_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0365->then_instructions;

                              body.emit(assign(r0358, lshift(r0337, r035B), 0x01));

                              ir_expression *const r0367 = bit_and(r0357, body.constant(int(31)));
                              body.emit(assign(r0359, rshift(r0337, r0367), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0365->else_instructions;

                              ir_variable *const r0368 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r036A = equal(r0357, body.constant(int(64)));
                              ir_if *f0369 = new(mem_ctx) ir_if(operand(r036A).val);
                              exec_list *const f0369_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0369->then_instructions;

                                 body.emit(assign(r0368, r0337, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0369->else_instructions;

                                 ir_expression *const r036B = nequal(r0337, body.constant(0u));
                                 ir_expression *const r036C = expr(ir_unop_b2i, r036B);
                                 body.emit(assign(r0368, expr(ir_unop_i2u, r036C), 0x01));


                              body.instructions = f0369_parent_instructions;
                              body.emit(f0369);

                              /* END IF */

                              body.emit(assign(r0358, r0368, 0x01));

                              body.emit(assign(r0359, body.constant(0u), 0x01));


                           body.instructions = f0365_parent_instructions;
                           body.emit(f0365);

                           /* END IF */


                        body.instructions = f0363_parent_instructions;
                        body.emit(f0363);

                        /* END IF */

                        body.emit(assign(r035A, body.constant(0u), 0x01));


                     body.instructions = f035F_parent_instructions;
                     body.emit(f035F);

                     /* END IF */

                     ir_expression *const r036D = nequal(r0356, body.constant(0u));
                     ir_expression *const r036E = expr(ir_unop_b2i, r036D);
                     ir_expression *const r036F = expr(ir_unop_i2u, r036E);
                     body.emit(assign(r0358, bit_or(r0358, r036F), 0x01));


                  body.instructions = f035D_parent_instructions;
                  body.emit(f035D);

                  /* END IF */

                  body.emit(assign(r0340, r035A, 0x01));

                  body.emit(assign(r0341, r0359, 0x01));

                  body.emit(assign(r0342, r0358, 0x01));

                  body.emit(assign(r033F, body.constant(int(0)), 0x01));

                  body.emit(assign(r0345, less(r0358, body.constant(0u)), 0x01));


               body.instructions = f0354_parent_instructions;
               body.emit(f0354);

               /* END IF */


            body.instructions = f0351_parent_instructions;
            body.emit(f0351);

            /* END IF */


         body.instructions = f0347_parent_instructions;
         body.emit(f0347);

         /* END IF */

         /* IF CONDITION */
         ir_if *f0370 = new(mem_ctx) ir_if(operand(r0343).val);
         exec_list *const f0370_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0370->then_instructions;

            /* IF CONDITION */
            ir_if *f0371 = new(mem_ctx) ir_if(operand(r0345).val);
            exec_list *const f0371_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0371->then_instructions;

               ir_variable *const r0372 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0372, add(r0341, body.constant(1u)), 0x01));

               ir_expression *const r0373 = less(r0372, r0341);
               ir_expression *const r0374 = expr(ir_unop_b2i, r0373);
               ir_expression *const r0375 = expr(ir_unop_i2u, r0374);
               body.emit(assign(r0340, add(r0340, r0375), 0x01));

               ir_expression *const r0376 = equal(r0342, body.constant(0u));
               ir_expression *const r0377 = expr(ir_unop_b2i, r0376);
               ir_expression *const r0378 = expr(ir_unop_i2u, r0377);
               ir_expression *const r0379 = add(r0342, r0378);
               ir_expression *const r037A = bit_and(r0379, body.constant(1u));
               ir_expression *const r037B = expr(ir_unop_bit_not, r037A);
               body.emit(assign(r0341, bit_and(r0372, r037B), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0371->else_instructions;

               /* IF CONDITION */
               ir_expression *const r037D = bit_or(r0340, r0341);
               ir_expression *const r037E = equal(r037D, body.constant(0u));
               ir_if *f037C = new(mem_ctx) ir_if(operand(r037E).val);
               exec_list *const f037C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f037C->then_instructions;

                  body.emit(assign(r033F, body.constant(int(0)), 0x01));


               body.instructions = f037C_parent_instructions;
               body.emit(f037C);

               /* END IF */


            body.instructions = f0371_parent_instructions;
            body.emit(f0371);

            /* END IF */

            ir_variable *const r037F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r037F);
            ir_expression *const r0380 = lshift(r0227, body.constant(int(31)));
            ir_expression *const r0381 = expr(ir_unop_i2u, r033F);
            ir_expression *const r0382 = lshift(r0381, body.constant(int(20)));
            ir_expression *const r0383 = add(r0380, r0382);
            body.emit(assign(r037F, add(r0383, r0340), 0x02));

            body.emit(assign(r037F, r0341, 0x01));

            body.emit(assign(r0344, r037F, 0x03));

            body.emit(assign(r0343, body.constant(false), 0x01));


         body.instructions = f0370_parent_instructions;
         body.emit(f0370);

         /* END IF */

         body.emit(assign(r0229, r0344, 0x03));

         body.emit(assign(r0228, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f033D->else_instructions;

         body.emit(assign(r022F, add(r022F, body.constant(int(1))), 0x01));

         ir_variable *const r0384 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0384);
         ir_variable *const r0385 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0385);
         ir_variable *const r0386 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0386);
         body.emit(assign(r0384, lshift(r0338, body.constant(int(31))), 0x01));

         ir_expression *const r0387 = lshift(r0337, body.constant(int(31)));
         ir_expression *const r0388 = rshift(r0338, body.constant(int(1)));
         body.emit(assign(r0385, bit_or(r0387, r0388), 0x01));

         body.emit(assign(r0386, rshift(r0337, body.constant(int(1))), 0x01));

         ir_expression *const r0389 = nequal(r0230, body.constant(0u));
         ir_expression *const r038A = expr(ir_unop_b2i, r0389);
         ir_expression *const r038B = expr(ir_unop_i2u, r038A);
         body.emit(assign(r0384, bit_or(r0384, r038B), 0x01));

         body.emit(assign(r0231, r0386, 0x01));

         body.emit(assign(r0230, r0384, 0x01));

         ir_variable *const r038C = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r038C, r022F, 0x01));

         ir_variable *const r038D = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r038D, r0386, 0x01));

         ir_variable *const r038E = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r038E, r0385, 0x01));

         ir_variable *const r038F = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r038F, r0384, 0x01));

         ir_variable *const r0390 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0390, body.constant(true), 0x01));

         ir_variable *const r0391 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0392 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0392);
         ir_expression *const r0393 = expr(ir_unop_u2i, r0384);
         body.emit(assign(r0392, less(r0393, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0395 = lequal(body.constant(int(2045)), r022F);
         ir_if *f0394 = new(mem_ctx) ir_if(operand(r0395).val);
         exec_list *const f0394_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0394->then_instructions;

            ir_variable *const r0396 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0398 = less(body.constant(int(2045)), r022F);
            ir_if *f0397 = new(mem_ctx) ir_if(operand(r0398).val);
            exec_list *const f0397_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0397->then_instructions;

               body.emit(assign(r0396, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0397->else_instructions;

               ir_variable *const r0399 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r039B = equal(r022F, body.constant(int(2045)));
               ir_if *f039A = new(mem_ctx) ir_if(operand(r039B).val);
               exec_list *const f039A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f039A->then_instructions;

                  ir_expression *const r039C = equal(body.constant(2097151u), r0386);
                  ir_expression *const r039D = equal(body.constant(4294967295u), r0385);
                  body.emit(assign(r0399, logic_and(r039C, r039D), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f039A->else_instructions;

                  body.emit(assign(r0399, body.constant(false), 0x01));


               body.instructions = f039A_parent_instructions;
               body.emit(f039A);

               /* END IF */

               body.emit(assign(r0396, logic_and(r0399, r0392), 0x01));


            body.instructions = f0397_parent_instructions;
            body.emit(f0397);

            /* END IF */

            /* IF CONDITION */
            ir_if *f039E = new(mem_ctx) ir_if(operand(r0396).val);
            exec_list *const f039E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f039E->then_instructions;

               ir_variable *const r039F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r039F);
               ir_expression *const r03A0 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r039F, add(r03A0, body.constant(2146435072u)), 0x02));

               body.emit(assign(r039F, body.constant(0u), 0x01));

               body.emit(assign(r0391, r039F, 0x03));

               body.emit(assign(r0390, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f039E->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03A2 = less(r022F, body.constant(int(0)));
               ir_if *f03A1 = new(mem_ctx) ir_if(operand(r03A2).val);
               exec_list *const f03A1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03A1->then_instructions;

                  ir_variable *const r03A3 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r03A3, r0384, 0x01));

                  ir_variable *const r03A4 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r03A4, neg(r022F), 0x01));

                  ir_variable *const r03A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r03A5);
                  ir_variable *const r03A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r03A6);
                  ir_variable *const r03A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r03A7);
                  ir_variable *const r03A8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r03A9 = neg(r03A4);
                  body.emit(assign(r03A8, bit_and(r03A9, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r03AB = equal(r03A4, body.constant(int(0)));
                  ir_if *f03AA = new(mem_ctx) ir_if(operand(r03AB).val);
                  exec_list *const f03AA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f03AA->then_instructions;

                     body.emit(assign(r03A5, r0384, 0x01));

                     body.emit(assign(r03A6, r0385, 0x01));

                     body.emit(assign(r03A7, r0386, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f03AA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r03AD = less(r03A4, body.constant(int(32)));
                     ir_if *f03AC = new(mem_ctx) ir_if(operand(r03AD).val);
                     exec_list *const f03AC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f03AC->then_instructions;

                        body.emit(assign(r03A5, lshift(r0385, r03A8), 0x01));

                        ir_expression *const r03AE = lshift(r0386, r03A8);
                        ir_expression *const r03AF = rshift(r0385, r03A4);
                        body.emit(assign(r03A6, bit_or(r03AE, r03AF), 0x01));

                        body.emit(assign(r03A7, rshift(r0386, r03A4), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f03AC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r03B1 = equal(r03A4, body.constant(int(32)));
                        ir_if *f03B0 = new(mem_ctx) ir_if(operand(r03B1).val);
                        exec_list *const f03B0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f03B0->then_instructions;

                           body.emit(assign(r03A5, r0385, 0x01));

                           body.emit(assign(r03A6, r0386, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f03B0->else_instructions;

                           body.emit(assign(r03A3, bit_or(r0384, r0385), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r03B3 = less(r03A4, body.constant(int(64)));
                           ir_if *f03B2 = new(mem_ctx) ir_if(operand(r03B3).val);
                           exec_list *const f03B2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f03B2->then_instructions;

                              body.emit(assign(r03A5, lshift(r0386, r03A8), 0x01));

                              ir_expression *const r03B4 = bit_and(r03A4, body.constant(int(31)));
                              body.emit(assign(r03A6, rshift(r0386, r03B4), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f03B2->else_instructions;

                              ir_variable *const r03B5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r03B7 = equal(r03A4, body.constant(int(64)));
                              ir_if *f03B6 = new(mem_ctx) ir_if(operand(r03B7).val);
                              exec_list *const f03B6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f03B6->then_instructions;

                                 body.emit(assign(r03B5, r0386, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f03B6->else_instructions;

                                 ir_expression *const r03B8 = nequal(r0386, body.constant(0u));
                                 ir_expression *const r03B9 = expr(ir_unop_b2i, r03B8);
                                 body.emit(assign(r03B5, expr(ir_unop_i2u, r03B9), 0x01));


                              body.instructions = f03B6_parent_instructions;
                              body.emit(f03B6);

                              /* END IF */

                              body.emit(assign(r03A5, r03B5, 0x01));

                              body.emit(assign(r03A6, body.constant(0u), 0x01));


                           body.instructions = f03B2_parent_instructions;
                           body.emit(f03B2);

                           /* END IF */


                        body.instructions = f03B0_parent_instructions;
                        body.emit(f03B0);

                        /* END IF */

                        body.emit(assign(r03A7, body.constant(0u), 0x01));


                     body.instructions = f03AC_parent_instructions;
                     body.emit(f03AC);

                     /* END IF */

                     ir_expression *const r03BA = nequal(r03A3, body.constant(0u));
                     ir_expression *const r03BB = expr(ir_unop_b2i, r03BA);
                     ir_expression *const r03BC = expr(ir_unop_i2u, r03BB);
                     body.emit(assign(r03A5, bit_or(r03A5, r03BC), 0x01));


                  body.instructions = f03AA_parent_instructions;
                  body.emit(f03AA);

                  /* END IF */

                  body.emit(assign(r038D, r03A7, 0x01));

                  body.emit(assign(r038E, r03A6, 0x01));

                  body.emit(assign(r038F, r03A5, 0x01));

                  body.emit(assign(r038C, body.constant(int(0)), 0x01));

                  body.emit(assign(r0392, less(r03A5, body.constant(0u)), 0x01));


               body.instructions = f03A1_parent_instructions;
               body.emit(f03A1);

               /* END IF */


            body.instructions = f039E_parent_instructions;
            body.emit(f039E);

            /* END IF */


         body.instructions = f0394_parent_instructions;
         body.emit(f0394);

         /* END IF */

         /* IF CONDITION */
         ir_if *f03BD = new(mem_ctx) ir_if(operand(r0390).val);
         exec_list *const f03BD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03BD->then_instructions;

            /* IF CONDITION */
            ir_if *f03BE = new(mem_ctx) ir_if(operand(r0392).val);
            exec_list *const f03BE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f03BE->then_instructions;

               ir_variable *const r03BF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r03BF, add(r038E, body.constant(1u)), 0x01));

               ir_expression *const r03C0 = less(r03BF, r038E);
               ir_expression *const r03C1 = expr(ir_unop_b2i, r03C0);
               ir_expression *const r03C2 = expr(ir_unop_i2u, r03C1);
               body.emit(assign(r038D, add(r038D, r03C2), 0x01));

               ir_expression *const r03C3 = equal(r038F, body.constant(0u));
               ir_expression *const r03C4 = expr(ir_unop_b2i, r03C3);
               ir_expression *const r03C5 = expr(ir_unop_i2u, r03C4);
               ir_expression *const r03C6 = add(r038F, r03C5);
               ir_expression *const r03C7 = bit_and(r03C6, body.constant(1u));
               ir_expression *const r03C8 = expr(ir_unop_bit_not, r03C7);
               body.emit(assign(r038E, bit_and(r03BF, r03C8), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f03BE->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03CA = bit_or(r038D, r038E);
               ir_expression *const r03CB = equal(r03CA, body.constant(0u));
               ir_if *f03C9 = new(mem_ctx) ir_if(operand(r03CB).val);
               exec_list *const f03C9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03C9->then_instructions;

                  body.emit(assign(r038C, body.constant(int(0)), 0x01));


               body.instructions = f03C9_parent_instructions;
               body.emit(f03C9);

               /* END IF */


            body.instructions = f03BE_parent_instructions;
            body.emit(f03BE);

            /* END IF */

            ir_variable *const r03CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r03CC);
            ir_expression *const r03CD = lshift(r0227, body.constant(int(31)));
            ir_expression *const r03CE = expr(ir_unop_i2u, r038C);
            ir_expression *const r03CF = lshift(r03CE, body.constant(int(20)));
            ir_expression *const r03D0 = add(r03CD, r03CF);
            body.emit(assign(r03CC, add(r03D0, r038D), 0x02));

            body.emit(assign(r03CC, r038E, 0x01));

            body.emit(assign(r0391, r03CC, 0x03));

            body.emit(assign(r0390, body.constant(false), 0x01));


         body.instructions = f03BD_parent_instructions;
         body.emit(f03BD);

         /* END IF */

         body.emit(assign(r0229, r0391, 0x03));

         body.emit(assign(r0228, body.constant(false), 0x01));


      body.instructions = f033D_parent_instructions;
      body.emit(f033D);

      /* END IF */


   body.instructions = f0336_parent_instructions;
   body.emit(f0336);

   /* END IF */

   body.emit(ret(r0229));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
subFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r03D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r03D1);
   ir_variable *const r03D2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r03D2);
   ir_variable *const r03D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r03D3);
   ir_variable *const r03D4 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r03D5 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r03D5);
   ir_variable *const r03D6 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r03D6);
   ir_variable *const r03D7 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r03D7);
   ir_variable *const r03D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r03D8);
   ir_variable *const r03D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r03D9);
   ir_variable *const r03DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r03DA);
   ir_variable *const r03DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r03DB);
   ir_variable *const r03DC = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r03DC);
   ir_variable *const r03DD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03DE = rshift(swizzle_y(r03D1), body.constant(int(20)));
   ir_expression *const r03DF = bit_and(r03DE, body.constant(2047u));
   body.emit(assign(r03DD, expr(ir_unop_u2i, r03DF), 0x01));

   body.emit(assign(r03D7, r03DD, 0x01));

   ir_variable *const r03E0 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03E1 = rshift(swizzle_y(r03D2), body.constant(int(20)));
   ir_expression *const r03E2 = bit_and(r03E1, body.constant(2047u));
   body.emit(assign(r03E0, expr(ir_unop_u2i, r03E2), 0x01));

   body.emit(assign(r03D6, r03E0, 0x01));

   body.emit(assign(r03D5, sub(r03DD, r03E0), 0x01));

   ir_variable *const r03E3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E3, lshift(swizzle_x(r03D1), body.constant(int(10))), 0x01));

   ir_variable *const r03E4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03E5 = bit_and(swizzle_y(r03D1), body.constant(1048575u));
   ir_expression *const r03E6 = lshift(r03E5, body.constant(int(10)));
   ir_expression *const r03E7 = rshift(swizzle_x(r03D1), body.constant(int(22)));
   body.emit(assign(r03E4, bit_or(r03E6, r03E7), 0x01));

   body.emit(assign(r03DA, r03E4, 0x01));

   body.emit(assign(r03DB, r03E3, 0x01));

   ir_variable *const r03E8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E8, lshift(swizzle_x(r03D2), body.constant(int(10))), 0x01));

   ir_variable *const r03E9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03EA = bit_and(swizzle_y(r03D2), body.constant(1048575u));
   ir_expression *const r03EB = lshift(r03EA, body.constant(int(10)));
   ir_expression *const r03EC = rshift(swizzle_x(r03D2), body.constant(int(22)));
   body.emit(assign(r03E9, bit_or(r03EB, r03EC), 0x01));

   body.emit(assign(r03D8, r03E9, 0x01));

   body.emit(assign(r03D9, r03E8, 0x01));

   /* IF CONDITION */
   ir_expression *const r03EE = less(body.constant(int(0)), r03D5);
   ir_if *f03ED = new(mem_ctx) ir_if(operand(r03EE).val);
   exec_list *const f03ED_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f03ED->then_instructions;

      /* IF CONDITION */
      ir_expression *const r03F0 = equal(r03DD, body.constant(int(2047)));
      ir_if *f03EF = new(mem_ctx) ir_if(operand(r03F0).val);
      exec_list *const f03EF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f03EF->then_instructions;

         /* IF CONDITION */
         ir_expression *const r03F2 = bit_or(r03E4, r03E3);
         ir_expression *const r03F3 = nequal(r03F2, body.constant(0u));
         ir_if *f03F1 = new(mem_ctx) ir_if(operand(r03F3).val);
         exec_list *const f03F1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03F1->then_instructions;

            ir_variable *const r03F4 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r03F4, swizzle_x(r03D1), 0x01));

            ir_variable *const r03F5 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r03F5, swizzle_x(r03D2), 0x01));

            ir_variable *const r03F6 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r03F7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r03F8 = rshift(swizzle_y(r03D1), body.constant(int(19)));
            ir_expression *const r03F9 = bit_and(r03F8, body.constant(4095u));
            ir_expression *const r03FA = equal(r03F9, body.constant(4094u));
            ir_expression *const r03FB = nequal(swizzle_x(r03D1), body.constant(0u));
            ir_expression *const r03FC = bit_and(swizzle_y(r03D1), body.constant(524287u));
            ir_expression *const r03FD = nequal(r03FC, body.constant(0u));
            ir_expression *const r03FE = logic_or(r03FB, r03FD);
            body.emit(assign(r03F7, logic_and(r03FA, r03FE), 0x01));

            ir_variable *const r03FF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0400 = lshift(swizzle_y(r03D2), body.constant(int(1)));
            ir_expression *const r0401 = lequal(body.constant(4292870144u), r0400);
            ir_expression *const r0402 = nequal(swizzle_x(r03D2), body.constant(0u));
            ir_expression *const r0403 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
            ir_expression *const r0404 = nequal(r0403, body.constant(0u));
            ir_expression *const r0405 = logic_or(r0402, r0404);
            body.emit(assign(r03FF, logic_and(r0401, r0405), 0x01));

            body.emit(assign(r03F4, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

            body.emit(assign(r03F5, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0407 = lshift(swizzle_y(r03D1), body.constant(int(1)));
            ir_expression *const r0408 = lequal(body.constant(4292870144u), r0407);
            ir_expression *const r0409 = nequal(swizzle_x(r03D1), body.constant(0u));
            ir_expression *const r040A = bit_and(swizzle_y(r03D1), body.constant(1048575u));
            ir_expression *const r040B = nequal(r040A, body.constant(0u));
            ir_expression *const r040C = logic_or(r0409, r040B);
            ir_expression *const r040D = logic_and(r0408, r040C);
            ir_if *f0406 = new(mem_ctx) ir_if(operand(r040D).val);
            exec_list *const f0406_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0406->then_instructions;

               ir_variable *const r040E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0410 = logic_and(r03F7, r03FF);
               ir_if *f040F = new(mem_ctx) ir_if(operand(r0410).val);
               exec_list *const f040F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f040F->then_instructions;

                  body.emit(assign(r040E, r03F5, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f040F->else_instructions;

                  body.emit(assign(r040E, r03F4, 0x03));


               body.instructions = f040F_parent_instructions;
               body.emit(f040F);

               /* END IF */

               body.emit(assign(r03F6, r040E, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0406->else_instructions;

               body.emit(assign(r03F6, r03F5, 0x03));


            body.instructions = f0406_parent_instructions;
            body.emit(f0406);

            /* END IF */

            body.emit(assign(r03D4, r03F6, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f03F1->else_instructions;

            body.emit(assign(r03D4, r03D1, 0x03));


         body.instructions = f03F1_parent_instructions;
         body.emit(f03F1);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f03EF->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0412 = equal(r03E0, body.constant(int(0)));
         ir_if *f0411 = new(mem_ctx) ir_if(operand(r0412).val);
         exec_list *const f0411_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0411->then_instructions;

            body.emit(assign(r03D5, add(r03D5, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0411->else_instructions;

            body.emit(assign(r03D8, bit_or(r03E9, body.constant(1073741824u)), 0x01));


         body.instructions = f0411_parent_instructions;
         body.emit(f0411);

         /* END IF */

         ir_variable *const r0413 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0413);
         ir_variable *const r0414 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0414);
         ir_variable *const r0415 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0416 = neg(r03D5);
         body.emit(assign(r0415, bit_and(r0416, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0418 = equal(r03D5, body.constant(int(0)));
         ir_if *f0417 = new(mem_ctx) ir_if(operand(r0418).val);
         exec_list *const f0417_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0417->then_instructions;

            body.emit(assign(r0413, r03E8, 0x01));

            body.emit(assign(r0414, r03D8, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0417->else_instructions;

            /* IF CONDITION */
            ir_expression *const r041A = less(r03D5, body.constant(int(32)));
            ir_if *f0419 = new(mem_ctx) ir_if(operand(r041A).val);
            exec_list *const f0419_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0419->then_instructions;

               ir_expression *const r041B = lshift(r03D8, r0415);
               ir_expression *const r041C = rshift(r03E8, r03D5);
               ir_expression *const r041D = bit_or(r041B, r041C);
               ir_expression *const r041E = lshift(r03E8, r0415);
               ir_expression *const r041F = nequal(r041E, body.constant(0u));
               ir_expression *const r0420 = expr(ir_unop_b2i, r041F);
               ir_expression *const r0421 = expr(ir_unop_i2u, r0420);
               body.emit(assign(r0413, bit_or(r041D, r0421), 0x01));

               body.emit(assign(r0414, rshift(r03D8, r03D5), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0419->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0423 = equal(r03D5, body.constant(int(32)));
               ir_if *f0422 = new(mem_ctx) ir_if(operand(r0423).val);
               exec_list *const f0422_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0422->then_instructions;

                  ir_expression *const r0424 = nequal(r03E8, body.constant(0u));
                  ir_expression *const r0425 = expr(ir_unop_b2i, r0424);
                  ir_expression *const r0426 = expr(ir_unop_i2u, r0425);
                  body.emit(assign(r0413, bit_or(r03D8, r0426), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0422->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0428 = less(r03D5, body.constant(int(64)));
                  ir_if *f0427 = new(mem_ctx) ir_if(operand(r0428).val);
                  exec_list *const f0427_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0427->then_instructions;

                     ir_expression *const r0429 = bit_and(r03D5, body.constant(int(31)));
                     ir_expression *const r042A = rshift(r03D8, r0429);
                     ir_expression *const r042B = lshift(r03D8, r0415);
                     ir_expression *const r042C = bit_or(r042B, r03E8);
                     ir_expression *const r042D = nequal(r042C, body.constant(0u));
                     ir_expression *const r042E = expr(ir_unop_b2i, r042D);
                     ir_expression *const r042F = expr(ir_unop_i2u, r042E);
                     body.emit(assign(r0413, bit_or(r042A, r042F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0427->else_instructions;

                     ir_expression *const r0430 = bit_or(r03D8, r03E8);
                     ir_expression *const r0431 = nequal(r0430, body.constant(0u));
                     ir_expression *const r0432 = expr(ir_unop_b2i, r0431);
                     body.emit(assign(r0413, expr(ir_unop_i2u, r0432), 0x01));


                  body.instructions = f0427_parent_instructions;
                  body.emit(f0427);

                  /* END IF */


               body.instructions = f0422_parent_instructions;
               body.emit(f0422);

               /* END IF */

               body.emit(assign(r0414, body.constant(0u), 0x01));


            body.instructions = f0419_parent_instructions;
            body.emit(f0419);

            /* END IF */


         body.instructions = f0417_parent_instructions;
         body.emit(f0417);

         /* END IF */

         body.emit(assign(r03D8, r0414, 0x01));

         body.emit(assign(r03D9, r0413, 0x01));

         body.emit(assign(r03DA, bit_or(r03E4, body.constant(1073741824u)), 0x01));

         ir_variable *const r0433 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0434 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r0434, sub(r03E3, r0413), 0x01));

         ir_expression *const r0435 = sub(r03DA, r0414);
         ir_expression *const r0436 = less(r03E3, r0413);
         ir_expression *const r0437 = expr(ir_unop_b2i, r0436);
         ir_expression *const r0438 = expr(ir_unop_i2u, r0437);
         body.emit(assign(r0433, sub(r0435, r0438), 0x01));

         body.emit(assign(r03DC, add(r03DD, body.constant(int(-1))), 0x01));

         ir_variable *const r0439 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0439, add(r03DC, body.constant(int(-10))), 0x01));

         ir_variable *const r043A = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r043A, r0433, 0x01));

         ir_variable *const r043B = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r043B, r0434, 0x01));

         ir_variable *const r043C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r043C);
         ir_variable *const r043D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r043D);
         /* IF CONDITION */
         ir_expression *const r043F = equal(r0433, body.constant(0u));
         ir_if *f043E = new(mem_ctx) ir_if(operand(r043F).val);
         exec_list *const f043E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f043E->then_instructions;

            body.emit(assign(r043A, r0434, 0x01));

            body.emit(assign(r043B, body.constant(0u), 0x01));

            body.emit(assign(r0439, add(r0439, body.constant(int(-32))), 0x01));


         body.instructions = f043E_parent_instructions;
         body.emit(f043E);

         /* END IF */

         ir_variable *const r0440 = body.make_temp(glsl_type::uint_type, "a");
         body.emit(assign(r0440, r043A, 0x01));

         ir_variable *const r0441 = body.make_temp(glsl_type::int_type, "return_value");
         ir_variable *const r0442 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r0442);
         /* IF CONDITION */
         ir_expression *const r0444 = equal(r043A, body.constant(0u));
         ir_if *f0443 = new(mem_ctx) ir_if(operand(r0444).val);
         exec_list *const f0443_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0443->then_instructions;

            body.emit(assign(r0441, body.constant(int(32)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0443->else_instructions;

            body.emit(assign(r0442, body.constant(int(0)), 0x01));

            /* IF CONDITION */
            ir_expression *const r0446 = bit_and(r043A, body.constant(4294901760u));
            ir_expression *const r0447 = equal(r0446, body.constant(0u));
            ir_if *f0445 = new(mem_ctx) ir_if(operand(r0447).val);
            exec_list *const f0445_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0445->then_instructions;

               body.emit(assign(r0442, body.constant(int(16)), 0x01));

               body.emit(assign(r0440, lshift(r043A, body.constant(int(16))), 0x01));


            body.instructions = f0445_parent_instructions;
            body.emit(f0445);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0449 = bit_and(r0440, body.constant(4278190080u));
            ir_expression *const r044A = equal(r0449, body.constant(0u));
            ir_if *f0448 = new(mem_ctx) ir_if(operand(r044A).val);
            exec_list *const f0448_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0448->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(8))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(8))), 0x01));


            body.instructions = f0448_parent_instructions;
            body.emit(f0448);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044C = bit_and(r0440, body.constant(4026531840u));
            ir_expression *const r044D = equal(r044C, body.constant(0u));
            ir_if *f044B = new(mem_ctx) ir_if(operand(r044D).val);
            exec_list *const f044B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044B->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(4))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(4))), 0x01));


            body.instructions = f044B_parent_instructions;
            body.emit(f044B);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044F = bit_and(r0440, body.constant(3221225472u));
            ir_expression *const r0450 = equal(r044F, body.constant(0u));
            ir_if *f044E = new(mem_ctx) ir_if(operand(r0450).val);
            exec_list *const f044E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044E->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(2))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(2))), 0x01));


            body.instructions = f044E_parent_instructions;
            body.emit(f044E);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0452 = bit_and(r0440, body.constant(2147483648u));
            ir_expression *const r0453 = equal(r0452, body.constant(0u));
            ir_if *f0451 = new(mem_ctx) ir_if(operand(r0453).val);
            exec_list *const f0451_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0451->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(1))), 0x01));


            body.instructions = f0451_parent_instructions;
            body.emit(f0451);

            /* END IF */

            body.emit(assign(r0441, r0442, 0x01));


         body.instructions = f0443_parent_instructions;
         body.emit(f0443);

         /* END IF */

         body.emit(assign(r043D, add(r0441, body.constant(int(-11))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0455 = lequal(body.constant(int(0)), r043D);
         ir_if *f0454 = new(mem_ctx) ir_if(operand(r0455).val);
         exec_list *const f0454_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0454->then_instructions;

            body.emit(assign(r043C, body.constant(0u), 0x01));

            ir_variable *const r0456 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0456, lshift(r043B, r043D), 0x01));

            ir_variable *const r0457 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r0459 = equal(r043D, body.constant(int(0)));
            ir_if *f0458 = new(mem_ctx) ir_if(operand(r0459).val);
            exec_list *const f0458_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0458->then_instructions;

               body.emit(assign(r0457, r043A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0458->else_instructions;

               ir_expression *const r045A = lshift(r043A, r043D);
               ir_expression *const r045B = neg(r043D);
               ir_expression *const r045C = bit_and(r045B, body.constant(int(31)));
               ir_expression *const r045D = rshift(r043B, r045C);
               body.emit(assign(r0457, bit_or(r045A, r045D), 0x01));


            body.instructions = f0458_parent_instructions;
            body.emit(f0458);

            /* END IF */

            body.emit(assign(r043A, r0457, 0x01));

            body.emit(assign(r043B, r0456, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0454->else_instructions;

            ir_variable *const r045E = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r045E, body.constant(0u), 0x01));

            ir_variable *const r045F = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r045F, neg(r043D), 0x01));

            ir_variable *const r0460 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0460);
            ir_variable *const r0461 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0461);
            ir_variable *const r0462 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0462);
            ir_variable *const r0463 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0464 = neg(r045F);
            body.emit(assign(r0463, bit_and(r0464, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0466 = equal(r045F, body.constant(int(0)));
            ir_if *f0465 = new(mem_ctx) ir_if(operand(r0466).val);
            exec_list *const f0465_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0465->then_instructions;

               body.emit(assign(r0460, r045E, 0x01));

               body.emit(assign(r0461, r043B, 0x01));

               body.emit(assign(r0462, r043A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0465->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0468 = less(r045F, body.constant(int(32)));
               ir_if *f0467 = new(mem_ctx) ir_if(operand(r0468).val);
               exec_list *const f0467_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0467->then_instructions;

                  body.emit(assign(r0460, lshift(r043B, r0463), 0x01));

                  ir_expression *const r0469 = lshift(r043A, r0463);
                  ir_expression *const r046A = rshift(r043B, r045F);
                  body.emit(assign(r0461, bit_or(r0469, r046A), 0x01));

                  body.emit(assign(r0462, rshift(r043A, r045F), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0467->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r046C = equal(r045F, body.constant(int(32)));
                  ir_if *f046B = new(mem_ctx) ir_if(operand(r046C).val);
                  exec_list *const f046B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f046B->then_instructions;

                     body.emit(assign(r0460, r043B, 0x01));

                     body.emit(assign(r0461, r043A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f046B->else_instructions;

                     body.emit(assign(r045E, bit_or(body.constant(0u), r043B), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r046E = less(r045F, body.constant(int(64)));
                     ir_if *f046D = new(mem_ctx) ir_if(operand(r046E).val);
                     exec_list *const f046D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f046D->then_instructions;

                        body.emit(assign(r0460, lshift(r043A, r0463), 0x01));

                        ir_expression *const r046F = bit_and(r045F, body.constant(int(31)));
                        body.emit(assign(r0461, rshift(r043A, r046F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f046D->else_instructions;

                        ir_variable *const r0470 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0472 = equal(r045F, body.constant(int(64)));
                        ir_if *f0471 = new(mem_ctx) ir_if(operand(r0472).val);
                        exec_list *const f0471_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0471->then_instructions;

                           body.emit(assign(r0470, r043A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0471->else_instructions;

                           ir_expression *const r0473 = nequal(r043A, body.constant(0u));
                           ir_expression *const r0474 = expr(ir_unop_b2i, r0473);
                           body.emit(assign(r0470, expr(ir_unop_i2u, r0474), 0x01));


                        body.instructions = f0471_parent_instructions;
                        body.emit(f0471);

                        /* END IF */

                        body.emit(assign(r0460, r0470, 0x01));

                        body.emit(assign(r0461, body.constant(0u), 0x01));


                     body.instructions = f046D_parent_instructions;
                     body.emit(f046D);

                     /* END IF */


                  body.instructions = f046B_parent_instructions;
                  body.emit(f046B);

                  /* END IF */

                  body.emit(assign(r0462, body.constant(0u), 0x01));


               body.instructions = f0467_parent_instructions;
               body.emit(f0467);

               /* END IF */

               ir_expression *const r0475 = nequal(r045E, body.constant(0u));
               ir_expression *const r0476 = expr(ir_unop_b2i, r0475);
               ir_expression *const r0477 = expr(ir_unop_i2u, r0476);
               body.emit(assign(r0460, bit_or(r0460, r0477), 0x01));


            body.instructions = f0465_parent_instructions;
            body.emit(f0465);

            /* END IF */

            body.emit(assign(r043A, r0462, 0x01));

            body.emit(assign(r043B, r0461, 0x01));

            body.emit(assign(r043C, r0460, 0x01));


         body.instructions = f0454_parent_instructions;
         body.emit(f0454);

         /* END IF */

         body.emit(assign(r0439, sub(r0439, r043D), 0x01));

         ir_variable *const r0478 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0478, r0439, 0x01));

         ir_variable *const r0479 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0479, r043A, 0x01));

         ir_variable *const r047A = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r047A, r043B, 0x01));

         ir_variable *const r047B = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r047B, r043C, 0x01));

         ir_variable *const r047C = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r047C, body.constant(true), 0x01));

         ir_variable *const r047D = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r047E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r047E);
         ir_expression *const r047F = expr(ir_unop_u2i, r043C);
         body.emit(assign(r047E, less(r047F, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0481 = lequal(body.constant(int(2045)), r0439);
         ir_if *f0480 = new(mem_ctx) ir_if(operand(r0481).val);
         exec_list *const f0480_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0480->then_instructions;

            ir_variable *const r0482 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0484 = less(body.constant(int(2045)), r0439);
            ir_if *f0483 = new(mem_ctx) ir_if(operand(r0484).val);
            exec_list *const f0483_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0483->then_instructions;

               body.emit(assign(r0482, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0483->else_instructions;

               ir_variable *const r0485 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r0487 = equal(r0439, body.constant(int(2045)));
               ir_if *f0486 = new(mem_ctx) ir_if(operand(r0487).val);
               exec_list *const f0486_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0486->then_instructions;

                  ir_expression *const r0488 = equal(body.constant(2097151u), r043A);
                  ir_expression *const r0489 = equal(body.constant(4294967295u), r043B);
                  body.emit(assign(r0485, logic_and(r0488, r0489), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0486->else_instructions;

                  body.emit(assign(r0485, body.constant(false), 0x01));


               body.instructions = f0486_parent_instructions;
               body.emit(f0486);

               /* END IF */

               body.emit(assign(r0482, logic_and(r0485, r047E), 0x01));


            body.instructions = f0483_parent_instructions;
            body.emit(f0483);

            /* END IF */

            /* IF CONDITION */
            ir_if *f048A = new(mem_ctx) ir_if(operand(r0482).val);
            exec_list *const f048A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f048A->then_instructions;

               ir_variable *const r048B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r048B);
               ir_expression *const r048C = lshift(r03D3, body.constant(int(31)));
               body.emit(assign(r048B, add(r048C, body.constant(2146435072u)), 0x02));

               body.emit(assign(r048B, body.constant(0u), 0x01));

               body.emit(assign(r047D, r048B, 0x03));

               body.emit(assign(r047C, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f048A->else_instructions;

               /* IF CONDITION */
               ir_expression *const r048E = less(r0439, body.constant(int(0)));
               ir_if *f048D = new(mem_ctx) ir_if(operand(r048E).val);
               exec_list *const f048D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f048D->then_instructions;

                  ir_variable *const r048F = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r048F, r043C, 0x01));

                  ir_variable *const r0490 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0490, neg(r0439), 0x01));

                  ir_variable *const r0491 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0491);
                  ir_variable *const r0492 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0492);
                  ir_variable *const r0493 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0493);
                  ir_variable *const r0494 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0495 = neg(r0490);
                  body.emit(assign(r0494, bit_and(r0495, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0497 = equal(r0490, body.constant(int(0)));
                  ir_if *f0496 = new(mem_ctx) ir_if(operand(r0497).val);
                  exec_list *const f0496_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0496->then_instructions;

                     body.emit(assign(r0491, r043C, 0x01));

                     body.emit(assign(r0492, r043B, 0x01));

                     body.emit(assign(r0493, r043A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0496->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0499 = less(r0490, body.constant(int(32)));
                     ir_if *f0498 = new(mem_ctx) ir_if(operand(r0499).val);
                     exec_list *const f0498_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0498->then_instructions;

                        body.emit(assign(r0491, lshift(r043B, r0494), 0x01));

                        ir_expression *const r049A = lshift(r043A, r0494);
                        ir_expression *const r049B = rshift(r043B, r0490);
                        body.emit(assign(r0492, bit_or(r049A, r049B), 0x01));

                        body.emit(assign(r0493, rshift(r043A, r0490), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0498->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r049D = equal(r0490, body.constant(int(32)));
                        ir_if *f049C = new(mem_ctx) ir_if(operand(r049D).val);
                        exec_list *const f049C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f049C->then_instructions;

                           body.emit(assign(r0491, r043B, 0x01));

                           body.emit(assign(r0492, r043A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f049C->else_instructions;

                           body.emit(assign(r048F, bit_or(r043C, r043B), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r049F = less(r0490, body.constant(int(64)));
                           ir_if *f049E = new(mem_ctx) ir_if(operand(r049F).val);
                           exec_list *const f049E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f049E->then_instructions;

                              body.emit(assign(r0491, lshift(r043A, r0494), 0x01));

                              ir_expression *const r04A0 = bit_and(r0490, body.constant(int(31)));
                              body.emit(assign(r0492, rshift(r043A, r04A0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f049E->else_instructions;

                              ir_variable *const r04A1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r04A3 = equal(r0490, body.constant(int(64)));
                              ir_if *f04A2 = new(mem_ctx) ir_if(operand(r04A3).val);
                              exec_list *const f04A2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f04A2->then_instructions;

                                 body.emit(assign(r04A1, r043A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f04A2->else_instructions;

                                 ir_expression *const r04A4 = nequal(r043A, body.constant(0u));
                                 ir_expression *const r04A5 = expr(ir_unop_b2i, r04A4);
                                 body.emit(assign(r04A1, expr(ir_unop_i2u, r04A5), 0x01));


                              body.instructions = f04A2_parent_instructions;
                              body.emit(f04A2);

                              /* END IF */

                              body.emit(assign(r0491, r04A1, 0x01));

                              body.emit(assign(r0492, body.constant(0u), 0x01));


                           body.instructions = f049E_parent_instructions;
                           body.emit(f049E);

                           /* END IF */


                        body.instructions = f049C_parent_instructions;
                        body.emit(f049C);

                        /* END IF */

                        body.emit(assign(r0493, body.constant(0u), 0x01));


                     body.instructions = f0498_parent_instructions;
                     body.emit(f0498);

                     /* END IF */

                     ir_expression *const r04A6 = nequal(r048F, body.constant(0u));
                     ir_expression *const r04A7 = expr(ir_unop_b2i, r04A6);
                     ir_expression *const r04A8 = expr(ir_unop_i2u, r04A7);
                     body.emit(assign(r0491, bit_or(r0491, r04A8), 0x01));


                  body.instructions = f0496_parent_instructions;
                  body.emit(f0496);

                  /* END IF */

                  body.emit(assign(r0479, r0493, 0x01));

                  body.emit(assign(r047A, r0492, 0x01));

                  body.emit(assign(r047B, r0491, 0x01));

                  body.emit(assign(r0478, body.constant(int(0)), 0x01));

                  body.emit(assign(r047E, less(r0491, body.constant(0u)), 0x01));


               body.instructions = f048D_parent_instructions;
               body.emit(f048D);

               /* END IF */


            body.instructions = f048A_parent_instructions;
            body.emit(f048A);

            /* END IF */


         body.instructions = f0480_parent_instructions;
         body.emit(f0480);

         /* END IF */

         /* IF CONDITION */
         ir_if *f04A9 = new(mem_ctx) ir_if(operand(r047C).val);
         exec_list *const f04A9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04A9->then_instructions;

            /* IF CONDITION */
            ir_if *f04AA = new(mem_ctx) ir_if(operand(r047E).val);
            exec_list *const f04AA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04AA->then_instructions;

               ir_variable *const r04AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r04AB, add(r047A, body.constant(1u)), 0x01));

               ir_expression *const r04AC = less(r04AB, r047A);
               ir_expression *const r04AD = expr(ir_unop_b2i, r04AC);
               ir_expression *const r04AE = expr(ir_unop_i2u, r04AD);
               body.emit(assign(r0479, add(r0479, r04AE), 0x01));

               ir_expression *const r04AF = equal(r047B, body.constant(0u));
               ir_expression *const r04B0 = expr(ir_unop_b2i, r04AF);
               ir_expression *const r04B1 = expr(ir_unop_i2u, r04B0);
               ir_expression *const r04B2 = add(r047B, r04B1);
               ir_expression *const r04B3 = bit_and(r04B2, body.constant(1u));
               ir_expression *const r04B4 = expr(ir_unop_bit_not, r04B3);
               body.emit(assign(r047A, bit_and(r04AB, r04B4), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04AA->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04B6 = bit_or(r0479, r047A);
               ir_expression *const r04B7 = equal(r04B6, body.constant(0u));
               ir_if *f04B5 = new(mem_ctx) ir_if(operand(r04B7).val);
               exec_list *const f04B5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04B5->then_instructions;

                  body.emit(assign(r0478, body.constant(int(0)), 0x01));


               body.instructions = f04B5_parent_instructions;
               body.emit(f04B5);

               /* END IF */


            body.instructions = f04AA_parent_instructions;
            body.emit(f04AA);

            /* END IF */

            ir_variable *const r04B8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r04B8);
            ir_expression *const r04B9 = lshift(r03D3, body.constant(int(31)));
            ir_expression *const r04BA = expr(ir_unop_i2u, r0478);
            ir_expression *const r04BB = lshift(r04BA, body.constant(int(20)));
            ir_expression *const r04BC = add(r04B9, r04BB);
            body.emit(assign(r04B8, add(r04BC, r0479), 0x02));

            body.emit(assign(r04B8, r047A, 0x01));

            body.emit(assign(r047D, r04B8, 0x03));

            body.emit(assign(r047C, body.constant(false), 0x01));


         body.instructions = f04A9_parent_instructions;
         body.emit(f04A9);

         /* END IF */

         body.emit(assign(r03D4, r047D, 0x03));


      body.instructions = f03EF_parent_instructions;
      body.emit(f03EF);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f03ED->else_instructions;

      /* IF CONDITION */
      ir_expression *const r04BE = less(r03D5, body.constant(int(0)));
      ir_if *f04BD = new(mem_ctx) ir_if(operand(r04BE).val);
      exec_list *const f04BD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f04BD->then_instructions;

         /* IF CONDITION */
         ir_expression *const r04C0 = equal(r03E0, body.constant(int(2047)));
         ir_if *f04BF = new(mem_ctx) ir_if(operand(r04C0).val);
         exec_list *const f04BF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04BF->then_instructions;

            /* IF CONDITION */
            ir_expression *const r04C2 = bit_or(r03D8, r03D9);
            ir_expression *const r04C3 = nequal(r04C2, body.constant(0u));
            ir_if *f04C1 = new(mem_ctx) ir_if(operand(r04C3).val);
            exec_list *const f04C1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04C1->then_instructions;

               ir_variable *const r04C4 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r04C4, swizzle_x(r03D1), 0x01));

               ir_variable *const r04C5 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r04C5, swizzle_x(r03D2), 0x01));

               ir_variable *const r04C6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r04C7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r04C8 = rshift(swizzle_y(r03D1), body.constant(int(19)));
               ir_expression *const r04C9 = bit_and(r04C8, body.constant(4095u));
               ir_expression *const r04CA = equal(r04C9, body.constant(4094u));
               ir_expression *const r04CB = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r04CC = bit_and(swizzle_y(r03D1), body.constant(524287u));
               ir_expression *const r04CD = nequal(r04CC, body.constant(0u));
               ir_expression *const r04CE = logic_or(r04CB, r04CD);
               body.emit(assign(r04C7, logic_and(r04CA, r04CE), 0x01));

               ir_variable *const r04CF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r04D0 = lshift(swizzle_y(r03D2), body.constant(int(1)));
               ir_expression *const r04D1 = lequal(body.constant(4292870144u), r04D0);
               ir_expression *const r04D2 = nequal(swizzle_x(r03D2), body.constant(0u));
               ir_expression *const r04D3 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
               ir_expression *const r04D4 = nequal(r04D3, body.constant(0u));
               ir_expression *const r04D5 = logic_or(r04D2, r04D4);
               body.emit(assign(r04CF, logic_and(r04D1, r04D5), 0x01));

               body.emit(assign(r04C4, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

               body.emit(assign(r04C5, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r04D7 = lshift(swizzle_y(r03D1), body.constant(int(1)));
               ir_expression *const r04D8 = lequal(body.constant(4292870144u), r04D7);
               ir_expression *const r04D9 = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r04DA = bit_and(swizzle_y(r03D1), body.constant(1048575u));
               ir_expression *const r04DB = nequal(r04DA, body.constant(0u));
               ir_expression *const r04DC = logic_or(r04D9, r04DB);
               ir_expression *const r04DD = logic_and(r04D8, r04DC);
               ir_if *f04D6 = new(mem_ctx) ir_if(operand(r04DD).val);
               exec_list *const f04D6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04D6->then_instructions;

                  ir_variable *const r04DE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r04E0 = logic_and(r04C7, r04CF);
                  ir_if *f04DF = new(mem_ctx) ir_if(operand(r04E0).val);
                  exec_list *const f04DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04DF->then_instructions;

                     body.emit(assign(r04DE, r04C5, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04DF->else_instructions;

                     body.emit(assign(r04DE, r04C4, 0x03));


                  body.instructions = f04DF_parent_instructions;
                  body.emit(f04DF);

                  /* END IF */

                  body.emit(assign(r04C6, r04DE, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04D6->else_instructions;

                  body.emit(assign(r04C6, r04C5, 0x03));


               body.instructions = f04D6_parent_instructions;
               body.emit(f04D6);

               /* END IF */

               body.emit(assign(r03D4, r04C6, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04C1->else_instructions;

               ir_variable *const r04E1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r04E1);
               ir_expression *const r04E2 = bit_xor(r03D3, body.constant(1u));
               ir_expression *const r04E3 = lshift(r04E2, body.constant(int(31)));
               body.emit(assign(r04E1, add(r04E3, body.constant(2146435072u)), 0x02));

               body.emit(assign(r04E1, body.constant(0u), 0x01));

               body.emit(assign(r03D4, r04E1, 0x03));


            body.instructions = f04C1_parent_instructions;
            body.emit(f04C1);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f04BF->else_instructions;

            /* IF CONDITION */
            ir_expression *const r04E5 = equal(r03DD, body.constant(int(0)));
            ir_if *f04E4 = new(mem_ctx) ir_if(operand(r04E5).val);
            exec_list *const f04E4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04E4->then_instructions;

               body.emit(assign(r03D5, add(r03D5, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04E4->else_instructions;

               body.emit(assign(r03DA, bit_or(r03DA, body.constant(1073741824u)), 0x01));


            body.instructions = f04E4_parent_instructions;
            body.emit(f04E4);

            /* END IF */

            ir_variable *const r04E6 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r04E6, neg(r03D5), 0x01));

            ir_variable *const r04E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r04E7);
            ir_variable *const r04E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r04E8);
            ir_variable *const r04E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r04EA = neg(r04E6);
            body.emit(assign(r04E9, bit_and(r04EA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r04EC = equal(r04E6, body.constant(int(0)));
            ir_if *f04EB = new(mem_ctx) ir_if(operand(r04EC).val);
            exec_list *const f04EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04EB->then_instructions;

               body.emit(assign(r04E7, r03E3, 0x01));

               body.emit(assign(r04E8, r03DA, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04EB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04EE = less(r04E6, body.constant(int(32)));
               ir_if *f04ED = new(mem_ctx) ir_if(operand(r04EE).val);
               exec_list *const f04ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04ED->then_instructions;

                  ir_expression *const r04EF = lshift(r03DA, r04E9);
                  ir_expression *const r04F0 = rshift(r03E3, r04E6);
                  ir_expression *const r04F1 = bit_or(r04EF, r04F0);
                  ir_expression *const r04F2 = lshift(r03E3, r04E9);
                  ir_expression *const r04F3 = nequal(r04F2, body.constant(0u));
                  ir_expression *const r04F4 = expr(ir_unop_b2i, r04F3);
                  ir_expression *const r04F5 = expr(ir_unop_i2u, r04F4);
                  body.emit(assign(r04E7, bit_or(r04F1, r04F5), 0x01));

                  body.emit(assign(r04E8, rshift(r03DA, r04E6), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04ED->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r04F7 = equal(r04E6, body.constant(int(32)));
                  ir_if *f04F6 = new(mem_ctx) ir_if(operand(r04F7).val);
                  exec_list *const f04F6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04F6->then_instructions;

                     ir_expression *const r04F8 = nequal(r03E3, body.constant(0u));
                     ir_expression *const r04F9 = expr(ir_unop_b2i, r04F8);
                     ir_expression *const r04FA = expr(ir_unop_i2u, r04F9);
                     body.emit(assign(r04E7, bit_or(r03DA, r04FA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04F6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r04FC = less(r04E6, body.constant(int(64)));
                     ir_if *f04FB = new(mem_ctx) ir_if(operand(r04FC).val);
                     exec_list *const f04FB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f04FB->then_instructions;

                        ir_expression *const r04FD = bit_and(r04E6, body.constant(int(31)));
                        ir_expression *const r04FE = rshift(r03DA, r04FD);
                        ir_expression *const r04FF = lshift(r03DA, r04E9);
                        ir_expression *const r0500 = bit_or(r04FF, r03E3);
                        ir_expression *const r0501 = nequal(r0500, body.constant(0u));
                        ir_expression *const r0502 = expr(ir_unop_b2i, r0501);
                        ir_expression *const r0503 = expr(ir_unop_i2u, r0502);
                        body.emit(assign(r04E7, bit_or(r04FE, r0503), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f04FB->else_instructions;

                        ir_expression *const r0504 = bit_or(r03DA, r03E3);
                        ir_expression *const r0505 = nequal(r0504, body.constant(0u));
                        ir_expression *const r0506 = expr(ir_unop_b2i, r0505);
                        body.emit(assign(r04E7, expr(ir_unop_i2u, r0506), 0x01));


                     body.instructions = f04FB_parent_instructions;
                     body.emit(f04FB);

                     /* END IF */


                  body.instructions = f04F6_parent_instructions;
                  body.emit(f04F6);

                  /* END IF */

                  body.emit(assign(r04E8, body.constant(0u), 0x01));


               body.instructions = f04ED_parent_instructions;
               body.emit(f04ED);

               /* END IF */


            body.instructions = f04EB_parent_instructions;
            body.emit(f04EB);

            /* END IF */

            body.emit(assign(r03DA, r04E8, 0x01));

            body.emit(assign(r03DB, r04E7, 0x01));

            body.emit(assign(r03D8, bit_or(r03D8, body.constant(1073741824u)), 0x01));

            ir_variable *const r0507 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0508 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0508, sub(r03D9, r04E7), 0x01));

            ir_expression *const r0509 = sub(r03D8, r04E8);
            ir_expression *const r050A = less(r03D9, r04E7);
            ir_expression *const r050B = expr(ir_unop_b2i, r050A);
            ir_expression *const r050C = expr(ir_unop_i2u, r050B);
            body.emit(assign(r0507, sub(r0509, r050C), 0x01));

            body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

            body.emit(assign(r03DC, add(r03E0, body.constant(int(-1))), 0x01));

            ir_variable *const r050D = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r050D, add(r03DC, body.constant(int(-10))), 0x01));

            ir_variable *const r050E = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r050E, r0507, 0x01));

            ir_variable *const r050F = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r050F, r0508, 0x01));

            ir_variable *const r0510 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0510);
            ir_variable *const r0511 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0511);
            /* IF CONDITION */
            ir_expression *const r0513 = equal(r0507, body.constant(0u));
            ir_if *f0512 = new(mem_ctx) ir_if(operand(r0513).val);
            exec_list *const f0512_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0512->then_instructions;

               body.emit(assign(r050E, r0508, 0x01));

               body.emit(assign(r050F, body.constant(0u), 0x01));

               body.emit(assign(r050D, add(r050D, body.constant(int(-32))), 0x01));


            body.instructions = f0512_parent_instructions;
            body.emit(f0512);

            /* END IF */

            ir_variable *const r0514 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0514, r050E, 0x01));

            ir_variable *const r0515 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0516 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0516);
            /* IF CONDITION */
            ir_expression *const r0518 = equal(r050E, body.constant(0u));
            ir_if *f0517 = new(mem_ctx) ir_if(operand(r0518).val);
            exec_list *const f0517_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0517->then_instructions;

               body.emit(assign(r0515, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0517->else_instructions;

               body.emit(assign(r0516, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r051A = bit_and(r050E, body.constant(4294901760u));
               ir_expression *const r051B = equal(r051A, body.constant(0u));
               ir_if *f0519 = new(mem_ctx) ir_if(operand(r051B).val);
               exec_list *const f0519_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0519->then_instructions;

                  body.emit(assign(r0516, body.constant(int(16)), 0x01));

                  body.emit(assign(r0514, lshift(r050E, body.constant(int(16))), 0x01));


               body.instructions = f0519_parent_instructions;
               body.emit(f0519);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r051D = bit_and(r0514, body.constant(4278190080u));
               ir_expression *const r051E = equal(r051D, body.constant(0u));
               ir_if *f051C = new(mem_ctx) ir_if(operand(r051E).val);
               exec_list *const f051C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051C->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(8))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(8))), 0x01));


               body.instructions = f051C_parent_instructions;
               body.emit(f051C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0520 = bit_and(r0514, body.constant(4026531840u));
               ir_expression *const r0521 = equal(r0520, body.constant(0u));
               ir_if *f051F = new(mem_ctx) ir_if(operand(r0521).val);
               exec_list *const f051F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051F->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(4))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(4))), 0x01));


               body.instructions = f051F_parent_instructions;
               body.emit(f051F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0523 = bit_and(r0514, body.constant(3221225472u));
               ir_expression *const r0524 = equal(r0523, body.constant(0u));
               ir_if *f0522 = new(mem_ctx) ir_if(operand(r0524).val);
               exec_list *const f0522_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0522->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(2))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(2))), 0x01));


               body.instructions = f0522_parent_instructions;
               body.emit(f0522);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0526 = bit_and(r0514, body.constant(2147483648u));
               ir_expression *const r0527 = equal(r0526, body.constant(0u));
               ir_if *f0525 = new(mem_ctx) ir_if(operand(r0527).val);
               exec_list *const f0525_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0525->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(1))), 0x01));


               body.instructions = f0525_parent_instructions;
               body.emit(f0525);

               /* END IF */

               body.emit(assign(r0515, r0516, 0x01));


            body.instructions = f0517_parent_instructions;
            body.emit(f0517);

            /* END IF */

            body.emit(assign(r0511, add(r0515, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0529 = lequal(body.constant(int(0)), r0511);
            ir_if *f0528 = new(mem_ctx) ir_if(operand(r0529).val);
            exec_list *const f0528_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0528->then_instructions;

               body.emit(assign(r0510, body.constant(0u), 0x01));

               ir_variable *const r052A = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r052A, lshift(r050F, r0511), 0x01));

               ir_variable *const r052B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r052D = equal(r0511, body.constant(int(0)));
               ir_if *f052C = new(mem_ctx) ir_if(operand(r052D).val);
               exec_list *const f052C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f052C->then_instructions;

                  body.emit(assign(r052B, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f052C->else_instructions;

                  ir_expression *const r052E = lshift(r050E, r0511);
                  ir_expression *const r052F = neg(r0511);
                  ir_expression *const r0530 = bit_and(r052F, body.constant(int(31)));
                  ir_expression *const r0531 = rshift(r050F, r0530);
                  body.emit(assign(r052B, bit_or(r052E, r0531), 0x01));


               body.instructions = f052C_parent_instructions;
               body.emit(f052C);

               /* END IF */

               body.emit(assign(r050E, r052B, 0x01));

               body.emit(assign(r050F, r052A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0528->else_instructions;

               ir_variable *const r0532 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0532, body.constant(0u), 0x01));

               ir_variable *const r0533 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0533, neg(r0511), 0x01));

               ir_variable *const r0534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0534);
               ir_variable *const r0535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0535);
               ir_variable *const r0536 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0536);
               ir_variable *const r0537 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0538 = neg(r0533);
               body.emit(assign(r0537, bit_and(r0538, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r053A = equal(r0533, body.constant(int(0)));
               ir_if *f0539 = new(mem_ctx) ir_if(operand(r053A).val);
               exec_list *const f0539_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0539->then_instructions;

                  body.emit(assign(r0534, r0532, 0x01));

                  body.emit(assign(r0535, r050F, 0x01));

                  body.emit(assign(r0536, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0539->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r053C = less(r0533, body.constant(int(32)));
                  ir_if *f053B = new(mem_ctx) ir_if(operand(r053C).val);
                  exec_list *const f053B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f053B->then_instructions;

                     body.emit(assign(r0534, lshift(r050F, r0537), 0x01));

                     ir_expression *const r053D = lshift(r050E, r0537);
                     ir_expression *const r053E = rshift(r050F, r0533);
                     body.emit(assign(r0535, bit_or(r053D, r053E), 0x01));

                     body.emit(assign(r0536, rshift(r050E, r0533), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f053B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0540 = equal(r0533, body.constant(int(32)));
                     ir_if *f053F = new(mem_ctx) ir_if(operand(r0540).val);
                     exec_list *const f053F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f053F->then_instructions;

                        body.emit(assign(r0534, r050F, 0x01));

                        body.emit(assign(r0535, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f053F->else_instructions;

                        body.emit(assign(r0532, bit_or(body.constant(0u), r050F), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0542 = less(r0533, body.constant(int(64)));
                        ir_if *f0541 = new(mem_ctx) ir_if(operand(r0542).val);
                        exec_list *const f0541_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0541->then_instructions;

                           body.emit(assign(r0534, lshift(r050E, r0537), 0x01));

                           ir_expression *const r0543 = bit_and(r0533, body.constant(int(31)));
                           body.emit(assign(r0535, rshift(r050E, r0543), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0541->else_instructions;

                           ir_variable *const r0544 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0546 = equal(r0533, body.constant(int(64)));
                           ir_if *f0545 = new(mem_ctx) ir_if(operand(r0546).val);
                           exec_list *const f0545_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0545->then_instructions;

                              body.emit(assign(r0544, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0545->else_instructions;

                              ir_expression *const r0547 = nequal(r050E, body.constant(0u));
                              ir_expression *const r0548 = expr(ir_unop_b2i, r0547);
                              body.emit(assign(r0544, expr(ir_unop_i2u, r0548), 0x01));


                           body.instructions = f0545_parent_instructions;
                           body.emit(f0545);

                           /* END IF */

                           body.emit(assign(r0534, r0544, 0x01));

                           body.emit(assign(r0535, body.constant(0u), 0x01));


                        body.instructions = f0541_parent_instructions;
                        body.emit(f0541);

                        /* END IF */


                     body.instructions = f053F_parent_instructions;
                     body.emit(f053F);

                     /* END IF */

                     body.emit(assign(r0536, body.constant(0u), 0x01));


                  body.instructions = f053B_parent_instructions;
                  body.emit(f053B);

                  /* END IF */

                  ir_expression *const r0549 = nequal(r0532, body.constant(0u));
                  ir_expression *const r054A = expr(ir_unop_b2i, r0549);
                  ir_expression *const r054B = expr(ir_unop_i2u, r054A);
                  body.emit(assign(r0534, bit_or(r0534, r054B), 0x01));


               body.instructions = f0539_parent_instructions;
               body.emit(f0539);

               /* END IF */

               body.emit(assign(r050E, r0536, 0x01));

               body.emit(assign(r050F, r0535, 0x01));

               body.emit(assign(r0510, r0534, 0x01));


            body.instructions = f0528_parent_instructions;
            body.emit(f0528);

            /* END IF */

            body.emit(assign(r050D, sub(r050D, r0511), 0x01));

            ir_variable *const r054C = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r054C, r050D, 0x01));

            ir_variable *const r054D = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r054D, r050E, 0x01));

            ir_variable *const r054E = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r054E, r050F, 0x01));

            ir_variable *const r054F = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r054F, r0510, 0x01));

            ir_variable *const r0550 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0550, body.constant(true), 0x01));

            ir_variable *const r0551 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0552 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0552);
            ir_expression *const r0553 = expr(ir_unop_u2i, r0510);
            body.emit(assign(r0552, less(r0553, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0555 = lequal(body.constant(int(2045)), r050D);
            ir_if *f0554 = new(mem_ctx) ir_if(operand(r0555).val);
            exec_list *const f0554_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0554->then_instructions;

               ir_variable *const r0556 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0558 = less(body.constant(int(2045)), r050D);
               ir_if *f0557 = new(mem_ctx) ir_if(operand(r0558).val);
               exec_list *const f0557_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0557->then_instructions;

                  body.emit(assign(r0556, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0557->else_instructions;

                  ir_variable *const r0559 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r055B = equal(r050D, body.constant(int(2045)));
                  ir_if *f055A = new(mem_ctx) ir_if(operand(r055B).val);
                  exec_list *const f055A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f055A->then_instructions;

                     ir_expression *const r055C = equal(body.constant(2097151u), r050E);
                     ir_expression *const r055D = equal(body.constant(4294967295u), r050F);
                     body.emit(assign(r0559, logic_and(r055C, r055D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f055A->else_instructions;

                     body.emit(assign(r0559, body.constant(false), 0x01));


                  body.instructions = f055A_parent_instructions;
                  body.emit(f055A);

                  /* END IF */

                  body.emit(assign(r0556, logic_and(r0559, r0552), 0x01));


               body.instructions = f0557_parent_instructions;
               body.emit(f0557);

               /* END IF */

               /* IF CONDITION */
               ir_if *f055E = new(mem_ctx) ir_if(operand(r0556).val);
               exec_list *const f055E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f055E->then_instructions;

                  ir_variable *const r055F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r055F);
                  ir_expression *const r0560 = lshift(r03D3, body.constant(int(31)));
                  body.emit(assign(r055F, add(r0560, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r055F, body.constant(0u), 0x01));

                  body.emit(assign(r0551, r055F, 0x03));

                  body.emit(assign(r0550, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f055E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0562 = less(r050D, body.constant(int(0)));
                  ir_if *f0561 = new(mem_ctx) ir_if(operand(r0562).val);
                  exec_list *const f0561_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0561->then_instructions;

                     ir_variable *const r0563 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0563, r0510, 0x01));

                     ir_variable *const r0564 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0564, neg(r050D), 0x01));

                     ir_variable *const r0565 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0565);
                     ir_variable *const r0566 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0566);
                     ir_variable *const r0567 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0567);
                     ir_variable *const r0568 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0569 = neg(r0564);
                     body.emit(assign(r0568, bit_and(r0569, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r056B = equal(r0564, body.constant(int(0)));
                     ir_if *f056A = new(mem_ctx) ir_if(operand(r056B).val);
                     exec_list *const f056A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f056A->then_instructions;

                        body.emit(assign(r0565, r0510, 0x01));

                        body.emit(assign(r0566, r050F, 0x01));

                        body.emit(assign(r0567, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f056A->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r056D = less(r0564, body.constant(int(32)));
                        ir_if *f056C = new(mem_ctx) ir_if(operand(r056D).val);
                        exec_list *const f056C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f056C->then_instructions;

                           body.emit(assign(r0565, lshift(r050F, r0568), 0x01));

                           ir_expression *const r056E = lshift(r050E, r0568);
                           ir_expression *const r056F = rshift(r050F, r0564);
                           body.emit(assign(r0566, bit_or(r056E, r056F), 0x01));

                           body.emit(assign(r0567, rshift(r050E, r0564), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f056C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0571 = equal(r0564, body.constant(int(32)));
                           ir_if *f0570 = new(mem_ctx) ir_if(operand(r0571).val);
                           exec_list *const f0570_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0570->then_instructions;

                              body.emit(assign(r0565, r050F, 0x01));

                              body.emit(assign(r0566, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0570->else_instructions;

                              body.emit(assign(r0563, bit_or(r0510, r050F), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0573 = less(r0564, body.constant(int(64)));
                              ir_if *f0572 = new(mem_ctx) ir_if(operand(r0573).val);
                              exec_list *const f0572_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0572->then_instructions;

                                 body.emit(assign(r0565, lshift(r050E, r0568), 0x01));

                                 ir_expression *const r0574 = bit_and(r0564, body.constant(int(31)));
                                 body.emit(assign(r0566, rshift(r050E, r0574), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0572->else_instructions;

                                 ir_variable *const r0575 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0577 = equal(r0564, body.constant(int(64)));
                                 ir_if *f0576 = new(mem_ctx) ir_if(operand(r0577).val);
                                 exec_list *const f0576_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0576->then_instructions;

                                    body.emit(assign(r0575, r050E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0576->else_instructions;

                                    ir_expression *const r0578 = nequal(r050E, body.constant(0u));
                                    ir_expression *const r0579 = expr(ir_unop_b2i, r0578);
                                    body.emit(assign(r0575, expr(ir_unop_i2u, r0579), 0x01));


                                 body.instructions = f0576_parent_instructions;
                                 body.emit(f0576);

                                 /* END IF */

                                 body.emit(assign(r0565, r0575, 0x01));

                                 body.emit(assign(r0566, body.constant(0u), 0x01));


                              body.instructions = f0572_parent_instructions;
                              body.emit(f0572);

                              /* END IF */


                           body.instructions = f0570_parent_instructions;
                           body.emit(f0570);

                           /* END IF */

                           body.emit(assign(r0567, body.constant(0u), 0x01));


                        body.instructions = f056C_parent_instructions;
                        body.emit(f056C);

                        /* END IF */

                        ir_expression *const r057A = nequal(r0563, body.constant(0u));
                        ir_expression *const r057B = expr(ir_unop_b2i, r057A);
                        ir_expression *const r057C = expr(ir_unop_i2u, r057B);
                        body.emit(assign(r0565, bit_or(r0565, r057C), 0x01));


                     body.instructions = f056A_parent_instructions;
                     body.emit(f056A);

                     /* END IF */

                     body.emit(assign(r054D, r0567, 0x01));

                     body.emit(assign(r054E, r0566, 0x01));

                     body.emit(assign(r054F, r0565, 0x01));

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));

                     body.emit(assign(r0552, less(r0565, body.constant(0u)), 0x01));


                  body.instructions = f0561_parent_instructions;
                  body.emit(f0561);

                  /* END IF */


               body.instructions = f055E_parent_instructions;
               body.emit(f055E);

               /* END IF */


            body.instructions = f0554_parent_instructions;
            body.emit(f0554);

            /* END IF */

            /* IF CONDITION */
            ir_if *f057D = new(mem_ctx) ir_if(operand(r0550).val);
            exec_list *const f057D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f057D->then_instructions;

               /* IF CONDITION */
               ir_if *f057E = new(mem_ctx) ir_if(operand(r0552).val);
               exec_list *const f057E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f057E->then_instructions;

                  ir_variable *const r057F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r057F, add(r054E, body.constant(1u)), 0x01));

                  ir_expression *const r0580 = less(r057F, r054E);
                  ir_expression *const r0581 = expr(ir_unop_b2i, r0580);
                  ir_expression *const r0582 = expr(ir_unop_i2u, r0581);
                  body.emit(assign(r054D, add(r054D, r0582), 0x01));

                  ir_expression *const r0583 = equal(r054F, body.constant(0u));
                  ir_expression *const r0584 = expr(ir_unop_b2i, r0583);
                  ir_expression *const r0585 = expr(ir_unop_i2u, r0584);
                  ir_expression *const r0586 = add(r054F, r0585);
                  ir_expression *const r0587 = bit_and(r0586, body.constant(1u));
                  ir_expression *const r0588 = expr(ir_unop_bit_not, r0587);
                  body.emit(assign(r054E, bit_and(r057F, r0588), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f057E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r058A = bit_or(r054D, r054E);
                  ir_expression *const r058B = equal(r058A, body.constant(0u));
                  ir_if *f0589 = new(mem_ctx) ir_if(operand(r058B).val);
                  exec_list *const f0589_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0589->then_instructions;

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));


                  body.instructions = f0589_parent_instructions;
                  body.emit(f0589);

                  /* END IF */


               body.instructions = f057E_parent_instructions;
               body.emit(f057E);

               /* END IF */

               ir_variable *const r058C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r058C);
               ir_expression *const r058D = lshift(r03D3, body.constant(int(31)));
               ir_expression *const r058E = expr(ir_unop_i2u, r054C);
               ir_expression *const r058F = lshift(r058E, body.constant(int(20)));
               ir_expression *const r0590 = add(r058D, r058F);
               body.emit(assign(r058C, add(r0590, r054D), 0x02));

               body.emit(assign(r058C, r054E, 0x01));

               body.emit(assign(r0551, r058C, 0x03));

               body.emit(assign(r0550, body.constant(false), 0x01));


            body.instructions = f057D_parent_instructions;
            body.emit(f057D);

            /* END IF */

            body.emit(assign(r03D4, r0551, 0x03));


         body.instructions = f04BF_parent_instructions;
         body.emit(f04BF);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f04BD->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0592 = equal(r03DD, body.constant(int(2047)));
         ir_if *f0591 = new(mem_ctx) ir_if(operand(r0592).val);
         exec_list *const f0591_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0591->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0594 = bit_or(r03DA, r03DB);
            ir_expression *const r0595 = bit_or(r03D8, r03D9);
            ir_expression *const r0596 = bit_or(r0594, r0595);
            ir_expression *const r0597 = nequal(r0596, body.constant(0u));
            ir_if *f0593 = new(mem_ctx) ir_if(operand(r0597).val);
            exec_list *const f0593_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0593->then_instructions;

               ir_variable *const r0598 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0598, swizzle_x(r03D1), 0x01));

               ir_variable *const r0599 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0599, swizzle_x(r03D2), 0x01));

               ir_variable *const r059A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r059B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r059C = rshift(swizzle_y(r03D1), body.constant(int(19)));
               ir_expression *const r059D = bit_and(r059C, body.constant(4095u));
               ir_expression *const r059E = equal(r059D, body.constant(4094u));
               ir_expression *const r059F = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r05A0 = bit_and(swizzle_y(r03D1), body.constant(524287u));
               ir_expression *const r05A1 = nequal(r05A0, body.constant(0u));
               ir_expression *const r05A2 = logic_or(r059F, r05A1);
               body.emit(assign(r059B, logic_and(r059E, r05A2), 0x01));

               ir_variable *const r05A3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r05A4 = lshift(swizzle_y(r03D2), body.constant(int(1)));
               ir_expression *const r05A5 = lequal(body.constant(4292870144u), r05A4);
               ir_expression *const r05A6 = nequal(swizzle_x(r03D2), body.constant(0u));
               ir_expression *const r05A7 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
               ir_expression *const r05A8 = nequal(r05A7, body.constant(0u));
               ir_expression *const r05A9 = logic_or(r05A6, r05A8);
               body.emit(assign(r05A3, logic_and(r05A5, r05A9), 0x01));

               body.emit(assign(r0598, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

               body.emit(assign(r0599, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r05AB = lshift(swizzle_y(r03D1), body.constant(int(1)));
               ir_expression *const r05AC = lequal(body.constant(4292870144u), r05AB);
               ir_expression *const r05AD = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r05AE = bit_and(swizzle_y(r03D1), body.constant(1048575u));
               ir_expression *const r05AF = nequal(r05AE, body.constant(0u));
               ir_expression *const r05B0 = logic_or(r05AD, r05AF);
               ir_expression *const r05B1 = logic_and(r05AC, r05B0);
               ir_if *f05AA = new(mem_ctx) ir_if(operand(r05B1).val);
               exec_list *const f05AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05AA->then_instructions;

                  ir_variable *const r05B2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05B4 = logic_and(r059B, r05A3);
                  ir_if *f05B3 = new(mem_ctx) ir_if(operand(r05B4).val);
                  exec_list *const f05B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05B3->then_instructions;

                     body.emit(assign(r05B2, r0599, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05B3->else_instructions;

                     body.emit(assign(r05B2, r0598, 0x03));


                  body.instructions = f05B3_parent_instructions;
                  body.emit(f05B3);

                  /* END IF */

                  body.emit(assign(r059A, r05B2, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05AA->else_instructions;

                  body.emit(assign(r059A, r0599, 0x03));


               body.instructions = f05AA_parent_instructions;
               body.emit(f05AA);

               /* END IF */

               body.emit(assign(r03D4, r059A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0593->else_instructions;

               ir_constant_data r05B5_data;
               memset(&r05B5_data, 0, sizeof(ir_constant_data));
               r05B5_data.u[0] = 4294967295;
               r05B5_data.u[1] = 4294967295;
               ir_constant *const r05B5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r05B5_data);
               body.emit(assign(r03D4, r05B5, 0x03));


            body.instructions = f0593_parent_instructions;
            body.emit(f0593);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0591->else_instructions;

            /* IF CONDITION */
            ir_expression *const r05B7 = equal(r03DD, body.constant(int(0)));
            ir_if *f05B6 = new(mem_ctx) ir_if(operand(r05B7).val);
            exec_list *const f05B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B6->then_instructions;

               body.emit(assign(r03D7, body.constant(int(1)), 0x01));

               body.emit(assign(r03D6, body.constant(int(1)), 0x01));


            body.instructions = f05B6_parent_instructions;
            body.emit(f05B6);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r05B9 = less(r03D8, r03DA);
            ir_if *f05B8 = new(mem_ctx) ir_if(operand(r05B9).val);
            exec_list *const f05B8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B8->then_instructions;

               ir_variable *const r05BA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r05BB = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r05BB, sub(r03DB, r03D9), 0x01));

               ir_expression *const r05BC = sub(r03DA, r03D8);
               ir_expression *const r05BD = less(r03DB, r03D9);
               ir_expression *const r05BE = expr(ir_unop_b2i, r05BD);
               ir_expression *const r05BF = expr(ir_unop_i2u, r05BE);
               body.emit(assign(r05BA, sub(r05BC, r05BF), 0x01));

               body.emit(assign(r03DC, add(r03D7, body.constant(int(-1))), 0x01));

               ir_variable *const r05C0 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05C0, add(r03DC, body.constant(int(-10))), 0x01));

               ir_variable *const r05C1 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r05C1, r05BA, 0x01));

               ir_variable *const r05C2 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r05C2, r05BB, 0x01));

               ir_variable *const r05C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r05C3);
               ir_variable *const r05C4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C4);
               /* IF CONDITION */
               ir_expression *const r05C6 = equal(r05BA, body.constant(0u));
               ir_if *f05C5 = new(mem_ctx) ir_if(operand(r05C6).val);
               exec_list *const f05C5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05C5->then_instructions;

                  body.emit(assign(r05C1, r05BB, 0x01));

                  body.emit(assign(r05C2, body.constant(0u), 0x01));

                  body.emit(assign(r05C0, add(r05C0, body.constant(int(-32))), 0x01));


               body.instructions = f05C5_parent_instructions;
               body.emit(f05C5);

               /* END IF */

               ir_variable *const r05C7 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r05C7, r05C1, 0x01));

               ir_variable *const r05C8 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r05C9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C9);
               /* IF CONDITION */
               ir_expression *const r05CB = equal(r05C1, body.constant(0u));
               ir_if *f05CA = new(mem_ctx) ir_if(operand(r05CB).val);
               exec_list *const f05CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05CA->then_instructions;

                  body.emit(assign(r05C8, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05CA->else_instructions;

                  body.emit(assign(r05C9, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05CD = bit_and(r05C1, body.constant(4294901760u));
                  ir_expression *const r05CE = equal(r05CD, body.constant(0u));
                  ir_if *f05CC = new(mem_ctx) ir_if(operand(r05CE).val);
                  exec_list *const f05CC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CC->then_instructions;

                     body.emit(assign(r05C9, body.constant(int(16)), 0x01));

                     body.emit(assign(r05C7, lshift(r05C1, body.constant(int(16))), 0x01));


                  body.instructions = f05CC_parent_instructions;
                  body.emit(f05CC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D0 = bit_and(r05C7, body.constant(4278190080u));
                  ir_expression *const r05D1 = equal(r05D0, body.constant(0u));
                  ir_if *f05CF = new(mem_ctx) ir_if(operand(r05D1).val);
                  exec_list *const f05CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CF->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(8))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(8))), 0x01));


                  body.instructions = f05CF_parent_instructions;
                  body.emit(f05CF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D3 = bit_and(r05C7, body.constant(4026531840u));
                  ir_expression *const r05D4 = equal(r05D3, body.constant(0u));
                  ir_if *f05D2 = new(mem_ctx) ir_if(operand(r05D4).val);
                  exec_list *const f05D2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D2->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(4))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(4))), 0x01));


                  body.instructions = f05D2_parent_instructions;
                  body.emit(f05D2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D6 = bit_and(r05C7, body.constant(3221225472u));
                  ir_expression *const r05D7 = equal(r05D6, body.constant(0u));
                  ir_if *f05D5 = new(mem_ctx) ir_if(operand(r05D7).val);
                  exec_list *const f05D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D5->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(2))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(2))), 0x01));


                  body.instructions = f05D5_parent_instructions;
                  body.emit(f05D5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D9 = bit_and(r05C7, body.constant(2147483648u));
                  ir_expression *const r05DA = equal(r05D9, body.constant(0u));
                  ir_if *f05D8 = new(mem_ctx) ir_if(operand(r05DA).val);
                  exec_list *const f05D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D8->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(1))), 0x01));


                  body.instructions = f05D8_parent_instructions;
                  body.emit(f05D8);

                  /* END IF */

                  body.emit(assign(r05C8, r05C9, 0x01));


               body.instructions = f05CA_parent_instructions;
               body.emit(f05CA);

               /* END IF */

               body.emit(assign(r05C4, add(r05C8, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r05DC = lequal(body.constant(int(0)), r05C4);
               ir_if *f05DB = new(mem_ctx) ir_if(operand(r05DC).val);
               exec_list *const f05DB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05DB->then_instructions;

                  body.emit(assign(r05C3, body.constant(0u), 0x01));

                  ir_variable *const r05DD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r05DD, lshift(r05C2, r05C4), 0x01));

                  ir_variable *const r05DE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05E0 = equal(r05C4, body.constant(int(0)));
                  ir_if *f05DF = new(mem_ctx) ir_if(operand(r05E0).val);
                  exec_list *const f05DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05DF->then_instructions;

                     body.emit(assign(r05DE, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05DF->else_instructions;

                     ir_expression *const r05E1 = lshift(r05C1, r05C4);
                     ir_expression *const r05E2 = neg(r05C4);
                     ir_expression *const r05E3 = bit_and(r05E2, body.constant(int(31)));
                     ir_expression *const r05E4 = rshift(r05C2, r05E3);
                     body.emit(assign(r05DE, bit_or(r05E1, r05E4), 0x01));


                  body.instructions = f05DF_parent_instructions;
                  body.emit(f05DF);

                  /* END IF */

                  body.emit(assign(r05C1, r05DE, 0x01));

                  body.emit(assign(r05C2, r05DD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05DB->else_instructions;

                  ir_variable *const r05E5 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r05E5, body.constant(0u), 0x01));

                  ir_variable *const r05E6 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r05E6, neg(r05C4), 0x01));

                  ir_variable *const r05E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r05E7);
                  ir_variable *const r05E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r05E8);
                  ir_variable *const r05E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r05E9);
                  ir_variable *const r05EA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r05EB = neg(r05E6);
                  body.emit(assign(r05EA, bit_and(r05EB, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05ED = equal(r05E6, body.constant(int(0)));
                  ir_if *f05EC = new(mem_ctx) ir_if(operand(r05ED).val);
                  exec_list *const f05EC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05EC->then_instructions;

                     body.emit(assign(r05E7, r05E5, 0x01));

                     body.emit(assign(r05E8, r05C2, 0x01));

                     body.emit(assign(r05E9, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05EC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r05EF = less(r05E6, body.constant(int(32)));
                     ir_if *f05EE = new(mem_ctx) ir_if(operand(r05EF).val);
                     exec_list *const f05EE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f05EE->then_instructions;

                        body.emit(assign(r05E7, lshift(r05C2, r05EA), 0x01));

                        ir_expression *const r05F0 = lshift(r05C1, r05EA);
                        ir_expression *const r05F1 = rshift(r05C2, r05E6);
                        body.emit(assign(r05E8, bit_or(r05F0, r05F1), 0x01));

                        body.emit(assign(r05E9, rshift(r05C1, r05E6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f05EE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r05F3 = equal(r05E6, body.constant(int(32)));
                        ir_if *f05F2 = new(mem_ctx) ir_if(operand(r05F3).val);
                        exec_list *const f05F2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f05F2->then_instructions;

                           body.emit(assign(r05E7, r05C2, 0x01));

                           body.emit(assign(r05E8, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f05F2->else_instructions;

                           body.emit(assign(r05E5, bit_or(body.constant(0u), r05C2), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r05F5 = less(r05E6, body.constant(int(64)));
                           ir_if *f05F4 = new(mem_ctx) ir_if(operand(r05F5).val);
                           exec_list *const f05F4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f05F4->then_instructions;

                              body.emit(assign(r05E7, lshift(r05C1, r05EA), 0x01));

                              ir_expression *const r05F6 = bit_and(r05E6, body.constant(int(31)));
                              body.emit(assign(r05E8, rshift(r05C1, r05F6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f05F4->else_instructions;

                              ir_variable *const r05F7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r05F9 = equal(r05E6, body.constant(int(64)));
                              ir_if *f05F8 = new(mem_ctx) ir_if(operand(r05F9).val);
                              exec_list *const f05F8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f05F8->then_instructions;

                                 body.emit(assign(r05F7, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f05F8->else_instructions;

                                 ir_expression *const r05FA = nequal(r05C1, body.constant(0u));
                                 ir_expression *const r05FB = expr(ir_unop_b2i, r05FA);
                                 body.emit(assign(r05F7, expr(ir_unop_i2u, r05FB), 0x01));


                              body.instructions = f05F8_parent_instructions;
                              body.emit(f05F8);

                              /* END IF */

                              body.emit(assign(r05E7, r05F7, 0x01));

                              body.emit(assign(r05E8, body.constant(0u), 0x01));


                           body.instructions = f05F4_parent_instructions;
                           body.emit(f05F4);

                           /* END IF */


                        body.instructions = f05F2_parent_instructions;
                        body.emit(f05F2);

                        /* END IF */

                        body.emit(assign(r05E9, body.constant(0u), 0x01));


                     body.instructions = f05EE_parent_instructions;
                     body.emit(f05EE);

                     /* END IF */

                     ir_expression *const r05FC = nequal(r05E5, body.constant(0u));
                     ir_expression *const r05FD = expr(ir_unop_b2i, r05FC);
                     ir_expression *const r05FE = expr(ir_unop_i2u, r05FD);
                     body.emit(assign(r05E7, bit_or(r05E7, r05FE), 0x01));


                  body.instructions = f05EC_parent_instructions;
                  body.emit(f05EC);

                  /* END IF */

                  body.emit(assign(r05C1, r05E9, 0x01));

                  body.emit(assign(r05C2, r05E8, 0x01));

                  body.emit(assign(r05C3, r05E7, 0x01));


               body.instructions = f05DB_parent_instructions;
               body.emit(f05DB);

               /* END IF */

               body.emit(assign(r05C0, sub(r05C0, r05C4), 0x01));

               ir_variable *const r05FF = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05FF, r05C0, 0x01));

               ir_variable *const r0600 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0600, r05C1, 0x01));

               ir_variable *const r0601 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0601, r05C2, 0x01));

               ir_variable *const r0602 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0602, r05C3, 0x01));

               ir_variable *const r0603 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0603, body.constant(true), 0x01));

               ir_variable *const r0604 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0605 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0605);
               ir_expression *const r0606 = expr(ir_unop_u2i, r05C3);
               body.emit(assign(r0605, less(r0606, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0608 = lequal(body.constant(int(2045)), r05C0);
               ir_if *f0607 = new(mem_ctx) ir_if(operand(r0608).val);
               exec_list *const f0607_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0607->then_instructions;

                  ir_variable *const r0609 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r060B = less(body.constant(int(2045)), r05C0);
                  ir_if *f060A = new(mem_ctx) ir_if(operand(r060B).val);
                  exec_list *const f060A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f060A->then_instructions;

                     body.emit(assign(r0609, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f060A->else_instructions;

                     ir_variable *const r060C = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r060E = equal(r05C0, body.constant(int(2045)));
                     ir_if *f060D = new(mem_ctx) ir_if(operand(r060E).val);
                     exec_list *const f060D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f060D->then_instructions;

                        ir_expression *const r060F = equal(body.constant(2097151u), r05C1);
                        ir_expression *const r0610 = equal(body.constant(4294967295u), r05C2);
                        body.emit(assign(r060C, logic_and(r060F, r0610), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f060D->else_instructions;

                        body.emit(assign(r060C, body.constant(false), 0x01));


                     body.instructions = f060D_parent_instructions;
                     body.emit(f060D);

                     /* END IF */

                     body.emit(assign(r0609, logic_and(r060C, r0605), 0x01));


                  body.instructions = f060A_parent_instructions;
                  body.emit(f060A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0611 = new(mem_ctx) ir_if(operand(r0609).val);
                  exec_list *const f0611_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0611->then_instructions;

                     ir_variable *const r0612 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0612);
                     ir_expression *const r0613 = lshift(r03D3, body.constant(int(31)));
                     body.emit(assign(r0612, add(r0613, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0612, body.constant(0u), 0x01));

                     body.emit(assign(r0604, r0612, 0x03));

                     body.emit(assign(r0603, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0611->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0615 = less(r05C0, body.constant(int(0)));
                     ir_if *f0614 = new(mem_ctx) ir_if(operand(r0615).val);
                     exec_list *const f0614_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0614->then_instructions;

                        ir_variable *const r0616 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0616, r05C3, 0x01));

                        ir_variable *const r0617 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0617, neg(r05C0), 0x01));

                        ir_variable *const r0618 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0618);
                        ir_variable *const r0619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0619);
                        ir_variable *const r061A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r061A);
                        ir_variable *const r061B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r061C = neg(r0617);
                        body.emit(assign(r061B, bit_and(r061C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r061E = equal(r0617, body.constant(int(0)));
                        ir_if *f061D = new(mem_ctx) ir_if(operand(r061E).val);
                        exec_list *const f061D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f061D->then_instructions;

                           body.emit(assign(r0618, r05C3, 0x01));

                           body.emit(assign(r0619, r05C2, 0x01));

                           body.emit(assign(r061A, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f061D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0620 = less(r0617, body.constant(int(32)));
                           ir_if *f061F = new(mem_ctx) ir_if(operand(r0620).val);
                           exec_list *const f061F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f061F->then_instructions;

                              body.emit(assign(r0618, lshift(r05C2, r061B), 0x01));

                              ir_expression *const r0621 = lshift(r05C1, r061B);
                              ir_expression *const r0622 = rshift(r05C2, r0617);
                              body.emit(assign(r0619, bit_or(r0621, r0622), 0x01));

                              body.emit(assign(r061A, rshift(r05C1, r0617), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f061F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0624 = equal(r0617, body.constant(int(32)));
                              ir_if *f0623 = new(mem_ctx) ir_if(operand(r0624).val);
                              exec_list *const f0623_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0623->then_instructions;

                                 body.emit(assign(r0618, r05C2, 0x01));

                                 body.emit(assign(r0619, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0623->else_instructions;

                                 body.emit(assign(r0616, bit_or(r05C3, r05C2), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0626 = less(r0617, body.constant(int(64)));
                                 ir_if *f0625 = new(mem_ctx) ir_if(operand(r0626).val);
                                 exec_list *const f0625_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0625->then_instructions;

                                    body.emit(assign(r0618, lshift(r05C1, r061B), 0x01));

                                    ir_expression *const r0627 = bit_and(r0617, body.constant(int(31)));
                                    body.emit(assign(r0619, rshift(r05C1, r0627), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0625->else_instructions;

                                    ir_variable *const r0628 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r062A = equal(r0617, body.constant(int(64)));
                                    ir_if *f0629 = new(mem_ctx) ir_if(operand(r062A).val);
                                    exec_list *const f0629_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0629->then_instructions;

                                       body.emit(assign(r0628, r05C1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0629->else_instructions;

                                       ir_expression *const r062B = nequal(r05C1, body.constant(0u));
                                       ir_expression *const r062C = expr(ir_unop_b2i, r062B);
                                       body.emit(assign(r0628, expr(ir_unop_i2u, r062C), 0x01));


                                    body.instructions = f0629_parent_instructions;
                                    body.emit(f0629);

                                    /* END IF */

                                    body.emit(assign(r0618, r0628, 0x01));

                                    body.emit(assign(r0619, body.constant(0u), 0x01));


                                 body.instructions = f0625_parent_instructions;
                                 body.emit(f0625);

                                 /* END IF */


                              body.instructions = f0623_parent_instructions;
                              body.emit(f0623);

                              /* END IF */

                              body.emit(assign(r061A, body.constant(0u), 0x01));


                           body.instructions = f061F_parent_instructions;
                           body.emit(f061F);

                           /* END IF */

                           ir_expression *const r062D = nequal(r0616, body.constant(0u));
                           ir_expression *const r062E = expr(ir_unop_b2i, r062D);
                           ir_expression *const r062F = expr(ir_unop_i2u, r062E);
                           body.emit(assign(r0618, bit_or(r0618, r062F), 0x01));


                        body.instructions = f061D_parent_instructions;
                        body.emit(f061D);

                        /* END IF */

                        body.emit(assign(r0600, r061A, 0x01));

                        body.emit(assign(r0601, r0619, 0x01));

                        body.emit(assign(r0602, r0618, 0x01));

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));

                        body.emit(assign(r0605, less(r0618, body.constant(0u)), 0x01));


                     body.instructions = f0614_parent_instructions;
                     body.emit(f0614);

                     /* END IF */


                  body.instructions = f0611_parent_instructions;
                  body.emit(f0611);

                  /* END IF */


               body.instructions = f0607_parent_instructions;
               body.emit(f0607);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0630 = new(mem_ctx) ir_if(operand(r0603).val);
               exec_list *const f0630_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0630->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0631 = new(mem_ctx) ir_if(operand(r0605).val);
                  exec_list *const f0631_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0631->then_instructions;

                     ir_variable *const r0632 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0632, add(r0601, body.constant(1u)), 0x01));

                     ir_expression *const r0633 = less(r0632, r0601);
                     ir_expression *const r0634 = expr(ir_unop_b2i, r0633);
                     ir_expression *const r0635 = expr(ir_unop_i2u, r0634);
                     body.emit(assign(r0600, add(r0600, r0635), 0x01));

                     ir_expression *const r0636 = equal(r0602, body.constant(0u));
                     ir_expression *const r0637 = expr(ir_unop_b2i, r0636);
                     ir_expression *const r0638 = expr(ir_unop_i2u, r0637);
                     ir_expression *const r0639 = add(r0602, r0638);
                     ir_expression *const r063A = bit_and(r0639, body.constant(1u));
                     ir_expression *const r063B = expr(ir_unop_bit_not, r063A);
                     body.emit(assign(r0601, bit_and(r0632, r063B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0631->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r063D = bit_or(r0600, r0601);
                     ir_expression *const r063E = equal(r063D, body.constant(0u));
                     ir_if *f063C = new(mem_ctx) ir_if(operand(r063E).val);
                     exec_list *const f063C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f063C->then_instructions;

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));


                     body.instructions = f063C_parent_instructions;
                     body.emit(f063C);

                     /* END IF */


                  body.instructions = f0631_parent_instructions;
                  body.emit(f0631);

                  /* END IF */

                  ir_variable *const r063F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r063F);
                  ir_expression *const r0640 = lshift(r03D3, body.constant(int(31)));
                  ir_expression *const r0641 = expr(ir_unop_i2u, r05FF);
                  ir_expression *const r0642 = lshift(r0641, body.constant(int(20)));
                  ir_expression *const r0643 = add(r0640, r0642);
                  body.emit(assign(r063F, add(r0643, r0600), 0x02));

                  body.emit(assign(r063F, r0601, 0x01));

                  body.emit(assign(r0604, r063F, 0x03));

                  body.emit(assign(r0603, body.constant(false), 0x01));


               body.instructions = f0630_parent_instructions;
               body.emit(f0630);

               /* END IF */

               body.emit(assign(r03D4, r0604, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f05B8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0645 = less(r03DA, r03D8);
               ir_if *f0644 = new(mem_ctx) ir_if(operand(r0645).val);
               exec_list *const f0644_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0644->then_instructions;

                  ir_variable *const r0646 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0647 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0647, sub(r03D9, r03DB), 0x01));

                  ir_expression *const r0648 = sub(r03D8, r03DA);
                  ir_expression *const r0649 = less(r03D9, r03DB);
                  ir_expression *const r064A = expr(ir_unop_b2i, r0649);
                  ir_expression *const r064B = expr(ir_unop_i2u, r064A);
                  body.emit(assign(r0646, sub(r0648, r064B), 0x01));

                  body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

                  body.emit(assign(r03DC, add(r03D6, body.constant(int(-1))), 0x01));

                  ir_variable *const r064C = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r064C, add(r03DC, body.constant(int(-10))), 0x01));

                  ir_variable *const r064D = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r064D, r0646, 0x01));

                  ir_variable *const r064E = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r064E, r0647, 0x01));

                  ir_variable *const r064F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r064F);
                  ir_variable *const r0650 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0650);
                  /* IF CONDITION */
                  ir_expression *const r0652 = equal(r0646, body.constant(0u));
                  ir_if *f0651 = new(mem_ctx) ir_if(operand(r0652).val);
                  exec_list *const f0651_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0651->then_instructions;

                     body.emit(assign(r064D, r0647, 0x01));

                     body.emit(assign(r064E, body.constant(0u), 0x01));

                     body.emit(assign(r064C, add(r064C, body.constant(int(-32))), 0x01));


                  body.instructions = f0651_parent_instructions;
                  body.emit(f0651);

                  /* END IF */

                  ir_variable *const r0653 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0653, r064D, 0x01));

                  ir_variable *const r0654 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0655 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0655);
                  /* IF CONDITION */
                  ir_expression *const r0657 = equal(r064D, body.constant(0u));
                  ir_if *f0656 = new(mem_ctx) ir_if(operand(r0657).val);
                  exec_list *const f0656_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0656->then_instructions;

                     body.emit(assign(r0654, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0656->else_instructions;

                     body.emit(assign(r0655, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0659 = bit_and(r064D, body.constant(4294901760u));
                     ir_expression *const r065A = equal(r0659, body.constant(0u));
                     ir_if *f0658 = new(mem_ctx) ir_if(operand(r065A).val);
                     exec_list *const f0658_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0658->then_instructions;

                        body.emit(assign(r0655, body.constant(int(16)), 0x01));

                        body.emit(assign(r0653, lshift(r064D, body.constant(int(16))), 0x01));


                     body.instructions = f0658_parent_instructions;
                     body.emit(f0658);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065C = bit_and(r0653, body.constant(4278190080u));
                     ir_expression *const r065D = equal(r065C, body.constant(0u));
                     ir_if *f065B = new(mem_ctx) ir_if(operand(r065D).val);
                     exec_list *const f065B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065B->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(8))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(8))), 0x01));


                     body.instructions = f065B_parent_instructions;
                     body.emit(f065B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065F = bit_and(r0653, body.constant(4026531840u));
                     ir_expression *const r0660 = equal(r065F, body.constant(0u));
                     ir_if *f065E = new(mem_ctx) ir_if(operand(r0660).val);
                     exec_list *const f065E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065E->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(4))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(4))), 0x01));


                     body.instructions = f065E_parent_instructions;
                     body.emit(f065E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0662 = bit_and(r0653, body.constant(3221225472u));
                     ir_expression *const r0663 = equal(r0662, body.constant(0u));
                     ir_if *f0661 = new(mem_ctx) ir_if(operand(r0663).val);
                     exec_list *const f0661_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0661->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(2))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(2))), 0x01));


                     body.instructions = f0661_parent_instructions;
                     body.emit(f0661);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0665 = bit_and(r0653, body.constant(2147483648u));
                     ir_expression *const r0666 = equal(r0665, body.constant(0u));
                     ir_if *f0664 = new(mem_ctx) ir_if(operand(r0666).val);
                     exec_list *const f0664_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0664->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(1))), 0x01));


                     body.instructions = f0664_parent_instructions;
                     body.emit(f0664);

                     /* END IF */

                     body.emit(assign(r0654, r0655, 0x01));


                  body.instructions = f0656_parent_instructions;
                  body.emit(f0656);

                  /* END IF */

                  body.emit(assign(r0650, add(r0654, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0668 = lequal(body.constant(int(0)), r0650);
                  ir_if *f0667 = new(mem_ctx) ir_if(operand(r0668).val);
                  exec_list *const f0667_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0667->then_instructions;

                     body.emit(assign(r064F, body.constant(0u), 0x01));

                     ir_variable *const r0669 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0669, lshift(r064E, r0650), 0x01));

                     ir_variable *const r066A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r066C = equal(r0650, body.constant(int(0)));
                     ir_if *f066B = new(mem_ctx) ir_if(operand(r066C).val);
                     exec_list *const f066B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f066B->then_instructions;

                        body.emit(assign(r066A, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f066B->else_instructions;

                        ir_expression *const r066D = lshift(r064D, r0650);
                        ir_expression *const r066E = neg(r0650);
                        ir_expression *const r066F = bit_and(r066E, body.constant(int(31)));
                        ir_expression *const r0670 = rshift(r064E, r066F);
                        body.emit(assign(r066A, bit_or(r066D, r0670), 0x01));


                     body.instructions = f066B_parent_instructions;
                     body.emit(f066B);

                     /* END IF */

                     body.emit(assign(r064D, r066A, 0x01));

                     body.emit(assign(r064E, r0669, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0667->else_instructions;

                     ir_variable *const r0671 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0671, body.constant(0u), 0x01));

                     ir_variable *const r0672 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0672, neg(r0650), 0x01));

                     ir_variable *const r0673 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0673);
                     ir_variable *const r0674 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0674);
                     ir_variable *const r0675 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0675);
                     ir_variable *const r0676 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0677 = neg(r0672);
                     body.emit(assign(r0676, bit_and(r0677, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0679 = equal(r0672, body.constant(int(0)));
                     ir_if *f0678 = new(mem_ctx) ir_if(operand(r0679).val);
                     exec_list *const f0678_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0678->then_instructions;

                        body.emit(assign(r0673, r0671, 0x01));

                        body.emit(assign(r0674, r064E, 0x01));

                        body.emit(assign(r0675, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0678->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r067B = less(r0672, body.constant(int(32)));
                        ir_if *f067A = new(mem_ctx) ir_if(operand(r067B).val);
                        exec_list *const f067A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f067A->then_instructions;

                           body.emit(assign(r0673, lshift(r064E, r0676), 0x01));

                           ir_expression *const r067C = lshift(r064D, r0676);
                           ir_expression *const r067D = rshift(r064E, r0672);
                           body.emit(assign(r0674, bit_or(r067C, r067D), 0x01));

                           body.emit(assign(r0675, rshift(r064D, r0672), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f067A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r067F = equal(r0672, body.constant(int(32)));
                           ir_if *f067E = new(mem_ctx) ir_if(operand(r067F).val);
                           exec_list *const f067E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f067E->then_instructions;

                              body.emit(assign(r0673, r064E, 0x01));

                              body.emit(assign(r0674, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f067E->else_instructions;

                              body.emit(assign(r0671, bit_or(body.constant(0u), r064E), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0681 = less(r0672, body.constant(int(64)));
                              ir_if *f0680 = new(mem_ctx) ir_if(operand(r0681).val);
                              exec_list *const f0680_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0680->then_instructions;

                                 body.emit(assign(r0673, lshift(r064D, r0676), 0x01));

                                 ir_expression *const r0682 = bit_and(r0672, body.constant(int(31)));
                                 body.emit(assign(r0674, rshift(r064D, r0682), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0680->else_instructions;

                                 ir_variable *const r0683 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0685 = equal(r0672, body.constant(int(64)));
                                 ir_if *f0684 = new(mem_ctx) ir_if(operand(r0685).val);
                                 exec_list *const f0684_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0684->then_instructions;

                                    body.emit(assign(r0683, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0684->else_instructions;

                                    ir_expression *const r0686 = nequal(r064D, body.constant(0u));
                                    ir_expression *const r0687 = expr(ir_unop_b2i, r0686);
                                    body.emit(assign(r0683, expr(ir_unop_i2u, r0687), 0x01));


                                 body.instructions = f0684_parent_instructions;
                                 body.emit(f0684);

                                 /* END IF */

                                 body.emit(assign(r0673, r0683, 0x01));

                                 body.emit(assign(r0674, body.constant(0u), 0x01));


                              body.instructions = f0680_parent_instructions;
                              body.emit(f0680);

                              /* END IF */


                           body.instructions = f067E_parent_instructions;
                           body.emit(f067E);

                           /* END IF */

                           body.emit(assign(r0675, body.constant(0u), 0x01));


                        body.instructions = f067A_parent_instructions;
                        body.emit(f067A);

                        /* END IF */

                        ir_expression *const r0688 = nequal(r0671, body.constant(0u));
                        ir_expression *const r0689 = expr(ir_unop_b2i, r0688);
                        ir_expression *const r068A = expr(ir_unop_i2u, r0689);
                        body.emit(assign(r0673, bit_or(r0673, r068A), 0x01));


                     body.instructions = f0678_parent_instructions;
                     body.emit(f0678);

                     /* END IF */

                     body.emit(assign(r064D, r0675, 0x01));

                     body.emit(assign(r064E, r0674, 0x01));

                     body.emit(assign(r064F, r0673, 0x01));


                  body.instructions = f0667_parent_instructions;
                  body.emit(f0667);

                  /* END IF */

                  body.emit(assign(r064C, sub(r064C, r0650), 0x01));

                  ir_variable *const r068B = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r068B, r064C, 0x01));

                  ir_variable *const r068C = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r068C, r064D, 0x01));

                  ir_variable *const r068D = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r068D, r064E, 0x01));

                  ir_variable *const r068E = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r068E, r064F, 0x01));

                  ir_variable *const r068F = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r068F, body.constant(true), 0x01));

                  ir_variable *const r0690 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0691 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0691);
                  ir_expression *const r0692 = expr(ir_unop_u2i, r064F);
                  body.emit(assign(r0691, less(r0692, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0694 = lequal(body.constant(int(2045)), r064C);
                  ir_if *f0693 = new(mem_ctx) ir_if(operand(r0694).val);
                  exec_list *const f0693_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0693->then_instructions;

                     ir_variable *const r0695 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0697 = less(body.constant(int(2045)), r064C);
                     ir_if *f0696 = new(mem_ctx) ir_if(operand(r0697).val);
                     exec_list *const f0696_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0696->then_instructions;

                        body.emit(assign(r0695, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0696->else_instructions;

                        ir_variable *const r0698 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r069A = equal(r064C, body.constant(int(2045)));
                        ir_if *f0699 = new(mem_ctx) ir_if(operand(r069A).val);
                        exec_list *const f0699_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0699->then_instructions;

                           ir_expression *const r069B = equal(body.constant(2097151u), r064D);
                           ir_expression *const r069C = equal(body.constant(4294967295u), r064E);
                           body.emit(assign(r0698, logic_and(r069B, r069C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0699->else_instructions;

                           body.emit(assign(r0698, body.constant(false), 0x01));


                        body.instructions = f0699_parent_instructions;
                        body.emit(f0699);

                        /* END IF */

                        body.emit(assign(r0695, logic_and(r0698, r0691), 0x01));


                     body.instructions = f0696_parent_instructions;
                     body.emit(f0696);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f069D = new(mem_ctx) ir_if(operand(r0695).val);
                     exec_list *const f069D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f069D->then_instructions;

                        ir_variable *const r069E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r069E);
                        ir_expression *const r069F = lshift(r03D3, body.constant(int(31)));
                        body.emit(assign(r069E, add(r069F, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r069E, body.constant(0u), 0x01));

                        body.emit(assign(r0690, r069E, 0x03));

                        body.emit(assign(r068F, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f069D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06A1 = less(r064C, body.constant(int(0)));
                        ir_if *f06A0 = new(mem_ctx) ir_if(operand(r06A1).val);
                        exec_list *const f06A0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06A0->then_instructions;

                           ir_variable *const r06A2 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r06A2, r064F, 0x01));

                           ir_variable *const r06A3 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r06A3, neg(r064C), 0x01));

                           ir_variable *const r06A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r06A4);
                           ir_variable *const r06A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r06A5);
                           ir_variable *const r06A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r06A6);
                           ir_variable *const r06A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r06A8 = neg(r06A3);
                           body.emit(assign(r06A7, bit_and(r06A8, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r06AA = equal(r06A3, body.constant(int(0)));
                           ir_if *f06A9 = new(mem_ctx) ir_if(operand(r06AA).val);
                           exec_list *const f06A9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f06A9->then_instructions;

                              body.emit(assign(r06A4, r064F, 0x01));

                              body.emit(assign(r06A5, r064E, 0x01));

                              body.emit(assign(r06A6, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f06A9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r06AC = less(r06A3, body.constant(int(32)));
                              ir_if *f06AB = new(mem_ctx) ir_if(operand(r06AC).val);
                              exec_list *const f06AB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f06AB->then_instructions;

                                 body.emit(assign(r06A4, lshift(r064E, r06A7), 0x01));

                                 ir_expression *const r06AD = lshift(r064D, r06A7);
                                 ir_expression *const r06AE = rshift(r064E, r06A3);
                                 body.emit(assign(r06A5, bit_or(r06AD, r06AE), 0x01));

                                 body.emit(assign(r06A6, rshift(r064D, r06A3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f06AB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r06B0 = equal(r06A3, body.constant(int(32)));
                                 ir_if *f06AF = new(mem_ctx) ir_if(operand(r06B0).val);
                                 exec_list *const f06AF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f06AF->then_instructions;

                                    body.emit(assign(r06A4, r064E, 0x01));

                                    body.emit(assign(r06A5, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f06AF->else_instructions;

                                    body.emit(assign(r06A2, bit_or(r064F, r064E), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r06B2 = less(r06A3, body.constant(int(64)));
                                    ir_if *f06B1 = new(mem_ctx) ir_if(operand(r06B2).val);
                                    exec_list *const f06B1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f06B1->then_instructions;

                                       body.emit(assign(r06A4, lshift(r064D, r06A7), 0x01));

                                       ir_expression *const r06B3 = bit_and(r06A3, body.constant(int(31)));
                                       body.emit(assign(r06A5, rshift(r064D, r06B3), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f06B1->else_instructions;

                                       ir_variable *const r06B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r06B6 = equal(r06A3, body.constant(int(64)));
                                       ir_if *f06B5 = new(mem_ctx) ir_if(operand(r06B6).val);
                                       exec_list *const f06B5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f06B5->then_instructions;

                                          body.emit(assign(r06B4, r064D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f06B5->else_instructions;

                                          ir_expression *const r06B7 = nequal(r064D, body.constant(0u));
                                          ir_expression *const r06B8 = expr(ir_unop_b2i, r06B7);
                                          body.emit(assign(r06B4, expr(ir_unop_i2u, r06B8), 0x01));


                                       body.instructions = f06B5_parent_instructions;
                                       body.emit(f06B5);

                                       /* END IF */

                                       body.emit(assign(r06A4, r06B4, 0x01));

                                       body.emit(assign(r06A5, body.constant(0u), 0x01));


                                    body.instructions = f06B1_parent_instructions;
                                    body.emit(f06B1);

                                    /* END IF */


                                 body.instructions = f06AF_parent_instructions;
                                 body.emit(f06AF);

                                 /* END IF */

                                 body.emit(assign(r06A6, body.constant(0u), 0x01));


                              body.instructions = f06AB_parent_instructions;
                              body.emit(f06AB);

                              /* END IF */

                              ir_expression *const r06B9 = nequal(r06A2, body.constant(0u));
                              ir_expression *const r06BA = expr(ir_unop_b2i, r06B9);
                              ir_expression *const r06BB = expr(ir_unop_i2u, r06BA);
                              body.emit(assign(r06A4, bit_or(r06A4, r06BB), 0x01));


                           body.instructions = f06A9_parent_instructions;
                           body.emit(f06A9);

                           /* END IF */

                           body.emit(assign(r068C, r06A6, 0x01));

                           body.emit(assign(r068D, r06A5, 0x01));

                           body.emit(assign(r068E, r06A4, 0x01));

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));

                           body.emit(assign(r0691, less(r06A4, body.constant(0u)), 0x01));


                        body.instructions = f06A0_parent_instructions;
                        body.emit(f06A0);

                        /* END IF */


                     body.instructions = f069D_parent_instructions;
                     body.emit(f069D);

                     /* END IF */


                  body.instructions = f0693_parent_instructions;
                  body.emit(f0693);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f06BC = new(mem_ctx) ir_if(operand(r068F).val);
                  exec_list *const f06BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06BC->then_instructions;

                     /* IF CONDITION */
                     ir_if *f06BD = new(mem_ctx) ir_if(operand(r0691).val);
                     exec_list *const f06BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06BD->then_instructions;

                        ir_variable *const r06BE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r06BE, add(r068D, body.constant(1u)), 0x01));

                        ir_expression *const r06BF = less(r06BE, r068D);
                        ir_expression *const r06C0 = expr(ir_unop_b2i, r06BF);
                        ir_expression *const r06C1 = expr(ir_unop_i2u, r06C0);
                        body.emit(assign(r068C, add(r068C, r06C1), 0x01));

                        ir_expression *const r06C2 = equal(r068E, body.constant(0u));
                        ir_expression *const r06C3 = expr(ir_unop_b2i, r06C2);
                        ir_expression *const r06C4 = expr(ir_unop_i2u, r06C3);
                        ir_expression *const r06C5 = add(r068E, r06C4);
                        ir_expression *const r06C6 = bit_and(r06C5, body.constant(1u));
                        ir_expression *const r06C7 = expr(ir_unop_bit_not, r06C6);
                        body.emit(assign(r068D, bit_and(r06BE, r06C7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06BD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06C9 = bit_or(r068C, r068D);
                        ir_expression *const r06CA = equal(r06C9, body.constant(0u));
                        ir_if *f06C8 = new(mem_ctx) ir_if(operand(r06CA).val);
                        exec_list *const f06C8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06C8->then_instructions;

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));


                        body.instructions = f06C8_parent_instructions;
                        body.emit(f06C8);

                        /* END IF */


                     body.instructions = f06BD_parent_instructions;
                     body.emit(f06BD);

                     /* END IF */

                     ir_variable *const r06CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r06CB);
                     ir_expression *const r06CC = lshift(r03D3, body.constant(int(31)));
                     ir_expression *const r06CD = expr(ir_unop_i2u, r068B);
                     ir_expression *const r06CE = lshift(r06CD, body.constant(int(20)));
                     ir_expression *const r06CF = add(r06CC, r06CE);
                     body.emit(assign(r06CB, add(r06CF, r068C), 0x02));

                     body.emit(assign(r06CB, r068D, 0x01));

                     body.emit(assign(r0690, r06CB, 0x03));

                     body.emit(assign(r068F, body.constant(false), 0x01));


                  body.instructions = f06BC_parent_instructions;
                  body.emit(f06BC);

                  /* END IF */

                  body.emit(assign(r03D4, r0690, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0644->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r06D1 = less(r03D9, r03DB);
                  ir_if *f06D0 = new(mem_ctx) ir_if(operand(r06D1).val);
                  exec_list *const f06D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06D0->then_instructions;

                     ir_variable *const r06D2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r06D3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r06D3, sub(r03DB, r03D9), 0x01));

                     ir_expression *const r06D4 = sub(r03DA, r03D8);
                     ir_expression *const r06D5 = less(r03DB, r03D9);
                     ir_expression *const r06D6 = expr(ir_unop_b2i, r06D5);
                     ir_expression *const r06D7 = expr(ir_unop_i2u, r06D6);
                     body.emit(assign(r06D2, sub(r06D4, r06D7), 0x01));

                     body.emit(assign(r03DC, add(r03D7, body.constant(int(-1))), 0x01));

                     ir_variable *const r06D8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r06D8, add(r03DC, body.constant(int(-10))), 0x01));

                     ir_variable *const r06D9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r06D9, r06D2, 0x01));

                     ir_variable *const r06DA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r06DA, r06D3, 0x01));

                     ir_variable *const r06DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r06DB);
                     ir_variable *const r06DC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06DC);
                     /* IF CONDITION */
                     ir_expression *const r06DE = equal(r06D2, body.constant(0u));
                     ir_if *f06DD = new(mem_ctx) ir_if(operand(r06DE).val);
                     exec_list *const f06DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06DD->then_instructions;

                        body.emit(assign(r06D9, r06D3, 0x01));

                        body.emit(assign(r06DA, body.constant(0u), 0x01));

                        body.emit(assign(r06D8, add(r06D8, body.constant(int(-32))), 0x01));


                     body.instructions = f06DD_parent_instructions;
                     body.emit(f06DD);

                     /* END IF */

                     ir_variable *const r06DF = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r06DF, r06D9, 0x01));

                     ir_variable *const r06E0 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r06E1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06E1);
                     /* IF CONDITION */
                     ir_expression *const r06E3 = equal(r06D9, body.constant(0u));
                     ir_if *f06E2 = new(mem_ctx) ir_if(operand(r06E3).val);
                     exec_list *const f06E2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06E2->then_instructions;

                        body.emit(assign(r06E0, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06E2->else_instructions;

                        body.emit(assign(r06E1, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r06E5 = bit_and(r06D9, body.constant(4294901760u));
                        ir_expression *const r06E6 = equal(r06E5, body.constant(0u));
                        ir_if *f06E4 = new(mem_ctx) ir_if(operand(r06E6).val);
                        exec_list *const f06E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E4->then_instructions;

                           body.emit(assign(r06E1, body.constant(int(16)), 0x01));

                           body.emit(assign(r06DF, lshift(r06D9, body.constant(int(16))), 0x01));


                        body.instructions = f06E4_parent_instructions;
                        body.emit(f06E4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06E8 = bit_and(r06DF, body.constant(4278190080u));
                        ir_expression *const r06E9 = equal(r06E8, body.constant(0u));
                        ir_if *f06E7 = new(mem_ctx) ir_if(operand(r06E9).val);
                        exec_list *const f06E7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E7->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(8))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(8))), 0x01));


                        body.instructions = f06E7_parent_instructions;
                        body.emit(f06E7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EB = bit_and(r06DF, body.constant(4026531840u));
                        ir_expression *const r06EC = equal(r06EB, body.constant(0u));
                        ir_if *f06EA = new(mem_ctx) ir_if(operand(r06EC).val);
                        exec_list *const f06EA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06EA->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(4))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(4))), 0x01));


                        body.instructions = f06EA_parent_instructions;
                        body.emit(f06EA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EE = bit_and(r06DF, body.constant(3221225472u));
                        ir_expression *const r06EF = equal(r06EE, body.constant(0u));
                        ir_if *f06ED = new(mem_ctx) ir_if(operand(r06EF).val);
                        exec_list *const f06ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06ED->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(2))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(2))), 0x01));


                        body.instructions = f06ED_parent_instructions;
                        body.emit(f06ED);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06F1 = bit_and(r06DF, body.constant(2147483648u));
                        ir_expression *const r06F2 = equal(r06F1, body.constant(0u));
                        ir_if *f06F0 = new(mem_ctx) ir_if(operand(r06F2).val);
                        exec_list *const f06F0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F0->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(1))), 0x01));


                        body.instructions = f06F0_parent_instructions;
                        body.emit(f06F0);

                        /* END IF */

                        body.emit(assign(r06E0, r06E1, 0x01));


                     body.instructions = f06E2_parent_instructions;
                     body.emit(f06E2);

                     /* END IF */

                     body.emit(assign(r06DC, add(r06E0, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r06F4 = lequal(body.constant(int(0)), r06DC);
                     ir_if *f06F3 = new(mem_ctx) ir_if(operand(r06F4).val);
                     exec_list *const f06F3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06F3->then_instructions;

                        body.emit(assign(r06DB, body.constant(0u), 0x01));

                        ir_variable *const r06F5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r06F5, lshift(r06DA, r06DC), 0x01));

                        ir_variable *const r06F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r06F8 = equal(r06DC, body.constant(int(0)));
                        ir_if *f06F7 = new(mem_ctx) ir_if(operand(r06F8).val);
                        exec_list *const f06F7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F7->then_instructions;

                           body.emit(assign(r06F6, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f06F7->else_instructions;

                           ir_expression *const r06F9 = lshift(r06D9, r06DC);
                           ir_expression *const r06FA = neg(r06DC);
                           ir_expression *const r06FB = bit_and(r06FA, body.constant(int(31)));
                           ir_expression *const r06FC = rshift(r06DA, r06FB);
                           body.emit(assign(r06F6, bit_or(r06F9, r06FC), 0x01));


                        body.instructions = f06F7_parent_instructions;
                        body.emit(f06F7);

                        /* END IF */

                        body.emit(assign(r06D9, r06F6, 0x01));

                        body.emit(assign(r06DA, r06F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06F3->else_instructions;

                        ir_variable *const r06FD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r06FD, body.constant(0u), 0x01));

                        ir_variable *const r06FE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r06FE, neg(r06DC), 0x01));

                        ir_variable *const r06FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r06FF);
                        ir_variable *const r0700 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0700);
                        ir_variable *const r0701 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0701);
                        ir_variable *const r0702 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0703 = neg(r06FE);
                        body.emit(assign(r0702, bit_and(r0703, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0705 = equal(r06FE, body.constant(int(0)));
                        ir_if *f0704 = new(mem_ctx) ir_if(operand(r0705).val);
                        exec_list *const f0704_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0704->then_instructions;

                           body.emit(assign(r06FF, r06FD, 0x01));

                           body.emit(assign(r0700, r06DA, 0x01));

                           body.emit(assign(r0701, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0704->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0707 = less(r06FE, body.constant(int(32)));
                           ir_if *f0706 = new(mem_ctx) ir_if(operand(r0707).val);
                           exec_list *const f0706_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0706->then_instructions;

                              body.emit(assign(r06FF, lshift(r06DA, r0702), 0x01));

                              ir_expression *const r0708 = lshift(r06D9, r0702);
                              ir_expression *const r0709 = rshift(r06DA, r06FE);
                              body.emit(assign(r0700, bit_or(r0708, r0709), 0x01));

                              body.emit(assign(r0701, rshift(r06D9, r06FE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0706->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r070B = equal(r06FE, body.constant(int(32)));
                              ir_if *f070A = new(mem_ctx) ir_if(operand(r070B).val);
                              exec_list *const f070A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f070A->then_instructions;

                                 body.emit(assign(r06FF, r06DA, 0x01));

                                 body.emit(assign(r0700, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f070A->else_instructions;

                                 body.emit(assign(r06FD, bit_or(body.constant(0u), r06DA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r070D = less(r06FE, body.constant(int(64)));
                                 ir_if *f070C = new(mem_ctx) ir_if(operand(r070D).val);
                                 exec_list *const f070C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f070C->then_instructions;

                                    body.emit(assign(r06FF, lshift(r06D9, r0702), 0x01));

                                    ir_expression *const r070E = bit_and(r06FE, body.constant(int(31)));
                                    body.emit(assign(r0700, rshift(r06D9, r070E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f070C->else_instructions;

                                    ir_variable *const r070F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0711 = equal(r06FE, body.constant(int(64)));
                                    ir_if *f0710 = new(mem_ctx) ir_if(operand(r0711).val);
                                    exec_list *const f0710_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0710->then_instructions;

                                       body.emit(assign(r070F, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0710->else_instructions;

                                       ir_expression *const r0712 = nequal(r06D9, body.constant(0u));
                                       ir_expression *const r0713 = expr(ir_unop_b2i, r0712);
                                       body.emit(assign(r070F, expr(ir_unop_i2u, r0713), 0x01));


                                    body.instructions = f0710_parent_instructions;
                                    body.emit(f0710);

                                    /* END IF */

                                    body.emit(assign(r06FF, r070F, 0x01));

                                    body.emit(assign(r0700, body.constant(0u), 0x01));


                                 body.instructions = f070C_parent_instructions;
                                 body.emit(f070C);

                                 /* END IF */


                              body.instructions = f070A_parent_instructions;
                              body.emit(f070A);

                              /* END IF */

                              body.emit(assign(r0701, body.constant(0u), 0x01));


                           body.instructions = f0706_parent_instructions;
                           body.emit(f0706);

                           /* END IF */

                           ir_expression *const r0714 = nequal(r06FD, body.constant(0u));
                           ir_expression *const r0715 = expr(ir_unop_b2i, r0714);
                           ir_expression *const r0716 = expr(ir_unop_i2u, r0715);
                           body.emit(assign(r06FF, bit_or(r06FF, r0716), 0x01));


                        body.instructions = f0704_parent_instructions;
                        body.emit(f0704);

                        /* END IF */

                        body.emit(assign(r06D9, r0701, 0x01));

                        body.emit(assign(r06DA, r0700, 0x01));

                        body.emit(assign(r06DB, r06FF, 0x01));


                     body.instructions = f06F3_parent_instructions;
                     body.emit(f06F3);

                     /* END IF */

                     body.emit(assign(r06D8, sub(r06D8, r06DC), 0x01));

                     ir_variable *const r0717 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0717, r06D8, 0x01));

                     ir_variable *const r0718 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0718, r06D9, 0x01));

                     ir_variable *const r0719 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0719, r06DA, 0x01));

                     ir_variable *const r071A = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r071A, r06DB, 0x01));

                     ir_variable *const r071B = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r071B, body.constant(true), 0x01));

                     ir_variable *const r071C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r071D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r071D);
                     ir_expression *const r071E = expr(ir_unop_u2i, r06DB);
                     body.emit(assign(r071D, less(r071E, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0720 = lequal(body.constant(int(2045)), r06D8);
                     ir_if *f071F = new(mem_ctx) ir_if(operand(r0720).val);
                     exec_list *const f071F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f071F->then_instructions;

                        ir_variable *const r0721 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0723 = less(body.constant(int(2045)), r06D8);
                        ir_if *f0722 = new(mem_ctx) ir_if(operand(r0723).val);
                        exec_list *const f0722_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0722->then_instructions;

                           body.emit(assign(r0721, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0722->else_instructions;

                           ir_variable *const r0724 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0726 = equal(r06D8, body.constant(int(2045)));
                           ir_if *f0725 = new(mem_ctx) ir_if(operand(r0726).val);
                           exec_list *const f0725_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0725->then_instructions;

                              ir_expression *const r0727 = equal(body.constant(2097151u), r06D9);
                              ir_expression *const r0728 = equal(body.constant(4294967295u), r06DA);
                              body.emit(assign(r0724, logic_and(r0727, r0728), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0725->else_instructions;

                              body.emit(assign(r0724, body.constant(false), 0x01));


                           body.instructions = f0725_parent_instructions;
                           body.emit(f0725);

                           /* END IF */

                           body.emit(assign(r0721, logic_and(r0724, r071D), 0x01));


                        body.instructions = f0722_parent_instructions;
                        body.emit(f0722);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0729 = new(mem_ctx) ir_if(operand(r0721).val);
                        exec_list *const f0729_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0729->then_instructions;

                           ir_variable *const r072A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r072A);
                           ir_expression *const r072B = lshift(r03D3, body.constant(int(31)));
                           body.emit(assign(r072A, add(r072B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r072A, body.constant(0u), 0x01));

                           body.emit(assign(r071C, r072A, 0x03));

                           body.emit(assign(r071B, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0729->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r072D = less(r06D8, body.constant(int(0)));
                           ir_if *f072C = new(mem_ctx) ir_if(operand(r072D).val);
                           exec_list *const f072C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f072C->then_instructions;

                              ir_variable *const r072E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r072E, r06DB, 0x01));

                              ir_variable *const r072F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r072F, neg(r06D8), 0x01));

                              ir_variable *const r0730 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0730);
                              ir_variable *const r0731 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0731);
                              ir_variable *const r0732 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0732);
                              ir_variable *const r0733 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0734 = neg(r072F);
                              body.emit(assign(r0733, bit_and(r0734, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0736 = equal(r072F, body.constant(int(0)));
                              ir_if *f0735 = new(mem_ctx) ir_if(operand(r0736).val);
                              exec_list *const f0735_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0735->then_instructions;

                                 body.emit(assign(r0730, r06DB, 0x01));

                                 body.emit(assign(r0731, r06DA, 0x01));

                                 body.emit(assign(r0732, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0735->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0738 = less(r072F, body.constant(int(32)));
                                 ir_if *f0737 = new(mem_ctx) ir_if(operand(r0738).val);
                                 exec_list *const f0737_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0737->then_instructions;

                                    body.emit(assign(r0730, lshift(r06DA, r0733), 0x01));

                                    ir_expression *const r0739 = lshift(r06D9, r0733);
                                    ir_expression *const r073A = rshift(r06DA, r072F);
                                    body.emit(assign(r0731, bit_or(r0739, r073A), 0x01));

                                    body.emit(assign(r0732, rshift(r06D9, r072F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0737->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r073C = equal(r072F, body.constant(int(32)));
                                    ir_if *f073B = new(mem_ctx) ir_if(operand(r073C).val);
                                    exec_list *const f073B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f073B->then_instructions;

                                       body.emit(assign(r0730, r06DA, 0x01));

                                       body.emit(assign(r0731, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f073B->else_instructions;

                                       body.emit(assign(r072E, bit_or(r06DB, r06DA), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r073E = less(r072F, body.constant(int(64)));
                                       ir_if *f073D = new(mem_ctx) ir_if(operand(r073E).val);
                                       exec_list *const f073D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f073D->then_instructions;

                                          body.emit(assign(r0730, lshift(r06D9, r0733), 0x01));

                                          ir_expression *const r073F = bit_and(r072F, body.constant(int(31)));
                                          body.emit(assign(r0731, rshift(r06D9, r073F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f073D->else_instructions;

                                          ir_variable *const r0740 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0742 = equal(r072F, body.constant(int(64)));
                                          ir_if *f0741 = new(mem_ctx) ir_if(operand(r0742).val);
                                          exec_list *const f0741_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0741->then_instructions;

                                             body.emit(assign(r0740, r06D9, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0741->else_instructions;

                                             ir_expression *const r0743 = nequal(r06D9, body.constant(0u));
                                             ir_expression *const r0744 = expr(ir_unop_b2i, r0743);
                                             body.emit(assign(r0740, expr(ir_unop_i2u, r0744), 0x01));


                                          body.instructions = f0741_parent_instructions;
                                          body.emit(f0741);

                                          /* END IF */

                                          body.emit(assign(r0730, r0740, 0x01));

                                          body.emit(assign(r0731, body.constant(0u), 0x01));


                                       body.instructions = f073D_parent_instructions;
                                       body.emit(f073D);

                                       /* END IF */


                                    body.instructions = f073B_parent_instructions;
                                    body.emit(f073B);

                                    /* END IF */

                                    body.emit(assign(r0732, body.constant(0u), 0x01));


                                 body.instructions = f0737_parent_instructions;
                                 body.emit(f0737);

                                 /* END IF */

                                 ir_expression *const r0745 = nequal(r072E, body.constant(0u));
                                 ir_expression *const r0746 = expr(ir_unop_b2i, r0745);
                                 ir_expression *const r0747 = expr(ir_unop_i2u, r0746);
                                 body.emit(assign(r0730, bit_or(r0730, r0747), 0x01));


                              body.instructions = f0735_parent_instructions;
                              body.emit(f0735);

                              /* END IF */

                              body.emit(assign(r0718, r0732, 0x01));

                              body.emit(assign(r0719, r0731, 0x01));

                              body.emit(assign(r071A, r0730, 0x01));

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));

                              body.emit(assign(r071D, less(r0730, body.constant(0u)), 0x01));


                           body.instructions = f072C_parent_instructions;
                           body.emit(f072C);

                           /* END IF */


                        body.instructions = f0729_parent_instructions;
                        body.emit(f0729);

                        /* END IF */


                     body.instructions = f071F_parent_instructions;
                     body.emit(f071F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0748 = new(mem_ctx) ir_if(operand(r071B).val);
                     exec_list *const f0748_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0748->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0749 = new(mem_ctx) ir_if(operand(r071D).val);
                        exec_list *const f0749_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0749->then_instructions;

                           ir_variable *const r074A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r074A, add(r0719, body.constant(1u)), 0x01));

                           ir_expression *const r074B = less(r074A, r0719);
                           ir_expression *const r074C = expr(ir_unop_b2i, r074B);
                           ir_expression *const r074D = expr(ir_unop_i2u, r074C);
                           body.emit(assign(r0718, add(r0718, r074D), 0x01));

                           ir_expression *const r074E = equal(r071A, body.constant(0u));
                           ir_expression *const r074F = expr(ir_unop_b2i, r074E);
                           ir_expression *const r0750 = expr(ir_unop_i2u, r074F);
                           ir_expression *const r0751 = add(r071A, r0750);
                           ir_expression *const r0752 = bit_and(r0751, body.constant(1u));
                           ir_expression *const r0753 = expr(ir_unop_bit_not, r0752);
                           body.emit(assign(r0719, bit_and(r074A, r0753), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0749->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0755 = bit_or(r0718, r0719);
                           ir_expression *const r0756 = equal(r0755, body.constant(0u));
                           ir_if *f0754 = new(mem_ctx) ir_if(operand(r0756).val);
                           exec_list *const f0754_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0754->then_instructions;

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));


                           body.instructions = f0754_parent_instructions;
                           body.emit(f0754);

                           /* END IF */


                        body.instructions = f0749_parent_instructions;
                        body.emit(f0749);

                        /* END IF */

                        ir_variable *const r0757 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0757);
                        ir_expression *const r0758 = lshift(r03D3, body.constant(int(31)));
                        ir_expression *const r0759 = expr(ir_unop_i2u, r0717);
                        ir_expression *const r075A = lshift(r0759, body.constant(int(20)));
                        ir_expression *const r075B = add(r0758, r075A);
                        body.emit(assign(r0757, add(r075B, r0718), 0x02));

                        body.emit(assign(r0757, r0719, 0x01));

                        body.emit(assign(r071C, r0757, 0x03));

                        body.emit(assign(r071B, body.constant(false), 0x01));


                     body.instructions = f0748_parent_instructions;
                     body.emit(f0748);

                     /* END IF */

                     body.emit(assign(r03D4, r071C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f06D0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r075D = less(r03DB, r03D9);
                     ir_if *f075C = new(mem_ctx) ir_if(operand(r075D).val);
                     exec_list *const f075C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f075C->then_instructions;

                        ir_variable *const r075E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r075F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r075F, sub(r03D9, r03DB), 0x01));

                        ir_expression *const r0760 = sub(r03D8, r03DA);
                        ir_expression *const r0761 = less(r03D9, r03DB);
                        ir_expression *const r0762 = expr(ir_unop_b2i, r0761);
                        ir_expression *const r0763 = expr(ir_unop_i2u, r0762);
                        body.emit(assign(r075E, sub(r0760, r0763), 0x01));

                        body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

                        body.emit(assign(r03DC, add(r03D6, body.constant(int(-1))), 0x01));

                        ir_variable *const r0764 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0764, add(r03DC, body.constant(int(-10))), 0x01));

                        ir_variable *const r0765 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0765, r075E, 0x01));

                        ir_variable *const r0766 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0766, r075F, 0x01));

                        ir_variable *const r0767 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0767);
                        ir_variable *const r0768 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0768);
                        /* IF CONDITION */
                        ir_expression *const r076A = equal(r075E, body.constant(0u));
                        ir_if *f0769 = new(mem_ctx) ir_if(operand(r076A).val);
                        exec_list *const f0769_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0769->then_instructions;

                           body.emit(assign(r0765, r075F, 0x01));

                           body.emit(assign(r0766, body.constant(0u), 0x01));

                           body.emit(assign(r0764, add(r0764, body.constant(int(-32))), 0x01));


                        body.instructions = f0769_parent_instructions;
                        body.emit(f0769);

                        /* END IF */

                        ir_variable *const r076B = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r076B, r0765, 0x01));

                        ir_variable *const r076C = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r076D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r076D);
                        /* IF CONDITION */
                        ir_expression *const r076F = equal(r0765, body.constant(0u));
                        ir_if *f076E = new(mem_ctx) ir_if(operand(r076F).val);
                        exec_list *const f076E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f076E->then_instructions;

                           body.emit(assign(r076C, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f076E->else_instructions;

                           body.emit(assign(r076D, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0771 = bit_and(r0765, body.constant(4294901760u));
                           ir_expression *const r0772 = equal(r0771, body.constant(0u));
                           ir_if *f0770 = new(mem_ctx) ir_if(operand(r0772).val);
                           exec_list *const f0770_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0770->then_instructions;

                              body.emit(assign(r076D, body.constant(int(16)), 0x01));

                              body.emit(assign(r076B, lshift(r0765, body.constant(int(16))), 0x01));


                           body.instructions = f0770_parent_instructions;
                           body.emit(f0770);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0774 = bit_and(r076B, body.constant(4278190080u));
                           ir_expression *const r0775 = equal(r0774, body.constant(0u));
                           ir_if *f0773 = new(mem_ctx) ir_if(operand(r0775).val);
                           exec_list *const f0773_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0773->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(8))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(8))), 0x01));


                           body.instructions = f0773_parent_instructions;
                           body.emit(f0773);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0777 = bit_and(r076B, body.constant(4026531840u));
                           ir_expression *const r0778 = equal(r0777, body.constant(0u));
                           ir_if *f0776 = new(mem_ctx) ir_if(operand(r0778).val);
                           exec_list *const f0776_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0776->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(4))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(4))), 0x01));


                           body.instructions = f0776_parent_instructions;
                           body.emit(f0776);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077A = bit_and(r076B, body.constant(3221225472u));
                           ir_expression *const r077B = equal(r077A, body.constant(0u));
                           ir_if *f0779 = new(mem_ctx) ir_if(operand(r077B).val);
                           exec_list *const f0779_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0779->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(2))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(2))), 0x01));


                           body.instructions = f0779_parent_instructions;
                           body.emit(f0779);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077D = bit_and(r076B, body.constant(2147483648u));
                           ir_expression *const r077E = equal(r077D, body.constant(0u));
                           ir_if *f077C = new(mem_ctx) ir_if(operand(r077E).val);
                           exec_list *const f077C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f077C->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(1))), 0x01));


                           body.instructions = f077C_parent_instructions;
                           body.emit(f077C);

                           /* END IF */

                           body.emit(assign(r076C, r076D, 0x01));


                        body.instructions = f076E_parent_instructions;
                        body.emit(f076E);

                        /* END IF */

                        body.emit(assign(r0768, add(r076C, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0780 = lequal(body.constant(int(0)), r0768);
                        ir_if *f077F = new(mem_ctx) ir_if(operand(r0780).val);
                        exec_list *const f077F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f077F->then_instructions;

                           body.emit(assign(r0767, body.constant(0u), 0x01));

                           ir_variable *const r0781 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0781, lshift(r0766, r0768), 0x01));

                           ir_variable *const r0782 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0784 = equal(r0768, body.constant(int(0)));
                           ir_if *f0783 = new(mem_ctx) ir_if(operand(r0784).val);
                           exec_list *const f0783_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0783->then_instructions;

                              body.emit(assign(r0782, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0783->else_instructions;

                              ir_expression *const r0785 = lshift(r0765, r0768);
                              ir_expression *const r0786 = neg(r0768);
                              ir_expression *const r0787 = bit_and(r0786, body.constant(int(31)));
                              ir_expression *const r0788 = rshift(r0766, r0787);
                              body.emit(assign(r0782, bit_or(r0785, r0788), 0x01));


                           body.instructions = f0783_parent_instructions;
                           body.emit(f0783);

                           /* END IF */

                           body.emit(assign(r0765, r0782, 0x01));

                           body.emit(assign(r0766, r0781, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f077F->else_instructions;

                           ir_variable *const r0789 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0789, body.constant(0u), 0x01));

                           ir_variable *const r078A = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r078A, neg(r0768), 0x01));

                           ir_variable *const r078B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r078B);
                           ir_variable *const r078C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r078C);
                           ir_variable *const r078D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r078D);
                           ir_variable *const r078E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r078F = neg(r078A);
                           body.emit(assign(r078E, bit_and(r078F, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0791 = equal(r078A, body.constant(int(0)));
                           ir_if *f0790 = new(mem_ctx) ir_if(operand(r0791).val);
                           exec_list *const f0790_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0790->then_instructions;

                              body.emit(assign(r078B, r0789, 0x01));

                              body.emit(assign(r078C, r0766, 0x01));

                              body.emit(assign(r078D, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0790->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0793 = less(r078A, body.constant(int(32)));
                              ir_if *f0792 = new(mem_ctx) ir_if(operand(r0793).val);
                              exec_list *const f0792_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0792->then_instructions;

                                 body.emit(assign(r078B, lshift(r0766, r078E), 0x01));

                                 ir_expression *const r0794 = lshift(r0765, r078E);
                                 ir_expression *const r0795 = rshift(r0766, r078A);
                                 body.emit(assign(r078C, bit_or(r0794, r0795), 0x01));

                                 body.emit(assign(r078D, rshift(r0765, r078A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0792->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0797 = equal(r078A, body.constant(int(32)));
                                 ir_if *f0796 = new(mem_ctx) ir_if(operand(r0797).val);
                                 exec_list *const f0796_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0796->then_instructions;

                                    body.emit(assign(r078B, r0766, 0x01));

                                    body.emit(assign(r078C, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0796->else_instructions;

                                    body.emit(assign(r0789, bit_or(body.constant(0u), r0766), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0799 = less(r078A, body.constant(int(64)));
                                    ir_if *f0798 = new(mem_ctx) ir_if(operand(r0799).val);
                                    exec_list *const f0798_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0798->then_instructions;

                                       body.emit(assign(r078B, lshift(r0765, r078E), 0x01));

                                       ir_expression *const r079A = bit_and(r078A, body.constant(int(31)));
                                       body.emit(assign(r078C, rshift(r0765, r079A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0798->else_instructions;

                                       ir_variable *const r079B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r079D = equal(r078A, body.constant(int(64)));
                                       ir_if *f079C = new(mem_ctx) ir_if(operand(r079D).val);
                                       exec_list *const f079C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f079C->then_instructions;

                                          body.emit(assign(r079B, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f079C->else_instructions;

                                          ir_expression *const r079E = nequal(r0765, body.constant(0u));
                                          ir_expression *const r079F = expr(ir_unop_b2i, r079E);
                                          body.emit(assign(r079B, expr(ir_unop_i2u, r079F), 0x01));


                                       body.instructions = f079C_parent_instructions;
                                       body.emit(f079C);

                                       /* END IF */

                                       body.emit(assign(r078B, r079B, 0x01));

                                       body.emit(assign(r078C, body.constant(0u), 0x01));


                                    body.instructions = f0798_parent_instructions;
                                    body.emit(f0798);

                                    /* END IF */


                                 body.instructions = f0796_parent_instructions;
                                 body.emit(f0796);

                                 /* END IF */

                                 body.emit(assign(r078D, body.constant(0u), 0x01));


                              body.instructions = f0792_parent_instructions;
                              body.emit(f0792);

                              /* END IF */

                              ir_expression *const r07A0 = nequal(r0789, body.constant(0u));
                              ir_expression *const r07A1 = expr(ir_unop_b2i, r07A0);
                              ir_expression *const r07A2 = expr(ir_unop_i2u, r07A1);
                              body.emit(assign(r078B, bit_or(r078B, r07A2), 0x01));


                           body.instructions = f0790_parent_instructions;
                           body.emit(f0790);

                           /* END IF */

                           body.emit(assign(r0765, r078D, 0x01));

                           body.emit(assign(r0766, r078C, 0x01));

                           body.emit(assign(r0767, r078B, 0x01));


                        body.instructions = f077F_parent_instructions;
                        body.emit(f077F);

                        /* END IF */

                        body.emit(assign(r0764, sub(r0764, r0768), 0x01));

                        ir_variable *const r07A3 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r07A3, r0764, 0x01));

                        ir_variable *const r07A4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r07A4, r0765, 0x01));

                        ir_variable *const r07A5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r07A5, r0766, 0x01));

                        ir_variable *const r07A6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r07A6, r0767, 0x01));

                        ir_variable *const r07A7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r07A7, body.constant(true), 0x01));

                        ir_variable *const r07A8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r07A9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r07A9);
                        ir_expression *const r07AA = expr(ir_unop_u2i, r0767);
                        body.emit(assign(r07A9, less(r07AA, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r07AC = lequal(body.constant(int(2045)), r0764);
                        ir_if *f07AB = new(mem_ctx) ir_if(operand(r07AC).val);
                        exec_list *const f07AB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07AB->then_instructions;

                           ir_variable *const r07AD = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r07AF = less(body.constant(int(2045)), r0764);
                           ir_if *f07AE = new(mem_ctx) ir_if(operand(r07AF).val);
                           exec_list *const f07AE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07AE->then_instructions;

                              body.emit(assign(r07AD, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07AE->else_instructions;

                              ir_variable *const r07B0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r07B2 = equal(r0764, body.constant(int(2045)));
                              ir_if *f07B1 = new(mem_ctx) ir_if(operand(r07B2).val);
                              exec_list *const f07B1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B1->then_instructions;

                                 ir_expression *const r07B3 = equal(body.constant(2097151u), r0765);
                                 ir_expression *const r07B4 = equal(body.constant(4294967295u), r0766);
                                 body.emit(assign(r07B0, logic_and(r07B3, r07B4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f07B1->else_instructions;

                                 body.emit(assign(r07B0, body.constant(false), 0x01));


                              body.instructions = f07B1_parent_instructions;
                              body.emit(f07B1);

                              /* END IF */

                              body.emit(assign(r07AD, logic_and(r07B0, r07A9), 0x01));


                           body.instructions = f07AE_parent_instructions;
                           body.emit(f07AE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f07B5 = new(mem_ctx) ir_if(operand(r07AD).val);
                           exec_list *const f07B5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07B5->then_instructions;

                              ir_variable *const r07B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r07B6);
                              ir_expression *const r07B7 = lshift(r03D3, body.constant(int(31)));
                              body.emit(assign(r07B6, add(r07B7, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r07B6, body.constant(0u), 0x01));

                              body.emit(assign(r07A8, r07B6, 0x03));

                              body.emit(assign(r07A7, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07B5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07B9 = less(r0764, body.constant(int(0)));
                              ir_if *f07B8 = new(mem_ctx) ir_if(operand(r07B9).val);
                              exec_list *const f07B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B8->then_instructions;

                                 ir_variable *const r07BA = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r07BA, r0767, 0x01));

                                 ir_variable *const r07BB = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r07BB, neg(r0764), 0x01));

                                 ir_variable *const r07BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r07BC);
                                 ir_variable *const r07BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r07BD);
                                 ir_variable *const r07BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r07BE);
                                 ir_variable *const r07BF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r07C0 = neg(r07BB);
                                 body.emit(assign(r07BF, bit_and(r07C0, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r07C2 = equal(r07BB, body.constant(int(0)));
                                 ir_if *f07C1 = new(mem_ctx) ir_if(operand(r07C2).val);
                                 exec_list *const f07C1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f07C1->then_instructions;

                                    body.emit(assign(r07BC, r0767, 0x01));

                                    body.emit(assign(r07BD, r0766, 0x01));

                                    body.emit(assign(r07BE, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f07C1->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r07C4 = less(r07BB, body.constant(int(32)));
                                    ir_if *f07C3 = new(mem_ctx) ir_if(operand(r07C4).val);
                                    exec_list *const f07C3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f07C3->then_instructions;

                                       body.emit(assign(r07BC, lshift(r0766, r07BF), 0x01));

                                       ir_expression *const r07C5 = lshift(r0765, r07BF);
                                       ir_expression *const r07C6 = rshift(r0766, r07BB);
                                       body.emit(assign(r07BD, bit_or(r07C5, r07C6), 0x01));

                                       body.emit(assign(r07BE, rshift(r0765, r07BB), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f07C3->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r07C8 = equal(r07BB, body.constant(int(32)));
                                       ir_if *f07C7 = new(mem_ctx) ir_if(operand(r07C8).val);
                                       exec_list *const f07C7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f07C7->then_instructions;

                                          body.emit(assign(r07BC, r0766, 0x01));

                                          body.emit(assign(r07BD, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f07C7->else_instructions;

                                          body.emit(assign(r07BA, bit_or(r0767, r0766), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r07CA = less(r07BB, body.constant(int(64)));
                                          ir_if *f07C9 = new(mem_ctx) ir_if(operand(r07CA).val);
                                          exec_list *const f07C9_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f07C9->then_instructions;

                                             body.emit(assign(r07BC, lshift(r0765, r07BF), 0x01));

                                             ir_expression *const r07CB = bit_and(r07BB, body.constant(int(31)));
                                             body.emit(assign(r07BD, rshift(r0765, r07CB), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f07C9->else_instructions;

                                             ir_variable *const r07CC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r07CE = equal(r07BB, body.constant(int(64)));
                                             ir_if *f07CD = new(mem_ctx) ir_if(operand(r07CE).val);
                                             exec_list *const f07CD_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f07CD->then_instructions;

                                                body.emit(assign(r07CC, r0765, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f07CD->else_instructions;

                                                ir_expression *const r07CF = nequal(r0765, body.constant(0u));
                                                ir_expression *const r07D0 = expr(ir_unop_b2i, r07CF);
                                                body.emit(assign(r07CC, expr(ir_unop_i2u, r07D0), 0x01));


                                             body.instructions = f07CD_parent_instructions;
                                             body.emit(f07CD);

                                             /* END IF */

                                             body.emit(assign(r07BC, r07CC, 0x01));

                                             body.emit(assign(r07BD, body.constant(0u), 0x01));


                                          body.instructions = f07C9_parent_instructions;
                                          body.emit(f07C9);

                                          /* END IF */


                                       body.instructions = f07C7_parent_instructions;
                                       body.emit(f07C7);

                                       /* END IF */

                                       body.emit(assign(r07BE, body.constant(0u), 0x01));


                                    body.instructions = f07C3_parent_instructions;
                                    body.emit(f07C3);

                                    /* END IF */

                                    ir_expression *const r07D1 = nequal(r07BA, body.constant(0u));
                                    ir_expression *const r07D2 = expr(ir_unop_b2i, r07D1);
                                    ir_expression *const r07D3 = expr(ir_unop_i2u, r07D2);
                                    body.emit(assign(r07BC, bit_or(r07BC, r07D3), 0x01));


                                 body.instructions = f07C1_parent_instructions;
                                 body.emit(f07C1);

                                 /* END IF */

                                 body.emit(assign(r07A4, r07BE, 0x01));

                                 body.emit(assign(r07A5, r07BD, 0x01));

                                 body.emit(assign(r07A6, r07BC, 0x01));

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));

                                 body.emit(assign(r07A9, less(r07BC, body.constant(0u)), 0x01));


                              body.instructions = f07B8_parent_instructions;
                              body.emit(f07B8);

                              /* END IF */


                           body.instructions = f07B5_parent_instructions;
                           body.emit(f07B5);

                           /* END IF */


                        body.instructions = f07AB_parent_instructions;
                        body.emit(f07AB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f07D4 = new(mem_ctx) ir_if(operand(r07A7).val);
                        exec_list *const f07D4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07D4->then_instructions;

                           /* IF CONDITION */
                           ir_if *f07D5 = new(mem_ctx) ir_if(operand(r07A9).val);
                           exec_list *const f07D5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07D5->then_instructions;

                              ir_variable *const r07D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r07D6, add(r07A5, body.constant(1u)), 0x01));

                              ir_expression *const r07D7 = less(r07D6, r07A5);
                              ir_expression *const r07D8 = expr(ir_unop_b2i, r07D7);
                              ir_expression *const r07D9 = expr(ir_unop_i2u, r07D8);
                              body.emit(assign(r07A4, add(r07A4, r07D9), 0x01));

                              ir_expression *const r07DA = equal(r07A6, body.constant(0u));
                              ir_expression *const r07DB = expr(ir_unop_b2i, r07DA);
                              ir_expression *const r07DC = expr(ir_unop_i2u, r07DB);
                              ir_expression *const r07DD = add(r07A6, r07DC);
                              ir_expression *const r07DE = bit_and(r07DD, body.constant(1u));
                              ir_expression *const r07DF = expr(ir_unop_bit_not, r07DE);
                              body.emit(assign(r07A5, bit_and(r07D6, r07DF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07D5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07E1 = bit_or(r07A4, r07A5);
                              ir_expression *const r07E2 = equal(r07E1, body.constant(0u));
                              ir_if *f07E0 = new(mem_ctx) ir_if(operand(r07E2).val);
                              exec_list *const f07E0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07E0->then_instructions;

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));


                              body.instructions = f07E0_parent_instructions;
                              body.emit(f07E0);

                              /* END IF */


                           body.instructions = f07D5_parent_instructions;
                           body.emit(f07D5);

                           /* END IF */

                           ir_variable *const r07E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r07E3);
                           ir_expression *const r07E4 = lshift(r03D3, body.constant(int(31)));
                           ir_expression *const r07E5 = expr(ir_unop_i2u, r07A3);
                           ir_expression *const r07E6 = lshift(r07E5, body.constant(int(20)));
                           ir_expression *const r07E7 = add(r07E4, r07E6);
                           body.emit(assign(r07E3, add(r07E7, r07A4), 0x02));

                           body.emit(assign(r07E3, r07A5, 0x01));

                           body.emit(assign(r07A8, r07E3, 0x03));

                           body.emit(assign(r07A7, body.constant(false), 0x01));


                        body.instructions = f07D4_parent_instructions;
                        body.emit(f07D4);

                        /* END IF */

                        body.emit(assign(r03D4, r07A8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f075C->else_instructions;

                        ir_variable *const r07E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r07E8);
                        body.emit(assign(r07E8, body.constant(0u), 0x02));

                        body.emit(assign(r07E8, body.constant(0u), 0x01));

                        body.emit(assign(r03D4, r07E8, 0x03));


                     body.instructions = f075C_parent_instructions;
                     body.emit(f075C);

                     /* END IF */


                  body.instructions = f06D0_parent_instructions;
                  body.emit(f06D0);

                  /* END IF */


               body.instructions = f0644_parent_instructions;
               body.emit(f0644);

               /* END IF */


            body.instructions = f05B8_parent_instructions;
            body.emit(f05B8);

            /* END IF */


         body.instructions = f0591_parent_instructions;
         body.emit(f0591);

         /* END IF */


      body.instructions = f04BD_parent_instructions;
      body.emit(f04BD);

      /* END IF */


   body.instructions = f03ED_parent_instructions;
   body.emit(f03ED);

   /* END IF */

   body.emit(ret(r03D4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fadd64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r07E9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r07E9);
   ir_variable *const r07EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r07EA);
   ir_variable *const r07EB = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r07EC = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07EC, rshift(swizzle_y(r07E9), body.constant(int(31))), 0x01));

   ir_variable *const r07ED = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07ED, rshift(swizzle_y(r07EA), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r07EF = equal(r07EC, r07ED);
   ir_if *f07EE = new(mem_ctx) ir_if(operand(r07EF).val);
   exec_list *const f07EE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f07EE->then_instructions;

      ir_variable *const r07F0 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r07F0, body.constant(true), 0x01));

      ir_variable *const r07F1 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r07F2 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r07F2);
      ir_variable *const r07F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r07F3);
      ir_variable *const r07F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r07F4);
      ir_variable *const r07F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r07F5);
      ir_variable *const r07F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r07F6);
      ir_variable *const r07F7 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r07F7);
      ir_variable *const r07F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r07F8);
      ir_variable *const r07F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r07F9);
      body.emit(assign(r07F9, body.constant(0u), 0x01));

      body.emit(assign(r07F8, body.constant(0u), 0x01));

      ir_variable *const r07FA = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r07FA, swizzle_x(r07E9), 0x01));

      body.emit(assign(r07F6, r07FA, 0x01));

      ir_variable *const r07FB = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r07FB, bit_and(swizzle_y(r07E9), body.constant(1048575u)), 0x01));

      body.emit(assign(r07F5, r07FB, 0x01));

      ir_variable *const r07FC = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r07FC, swizzle_x(r07EA), 0x01));

      body.emit(assign(r07F4, r07FC, 0x01));

      ir_variable *const r07FD = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r07FD, bit_and(swizzle_y(r07EA), body.constant(1048575u)), 0x01));

      body.emit(assign(r07F3, r07FD, 0x01));

      ir_variable *const r07FE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r07FF = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r0800 = bit_and(r07FF, body.constant(2047u));
      body.emit(assign(r07FE, expr(ir_unop_u2i, r0800), 0x01));

      ir_variable *const r0801 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0802 = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r0803 = bit_and(r0802, body.constant(2047u));
      body.emit(assign(r0801, expr(ir_unop_u2i, r0803), 0x01));

      ir_variable *const r0804 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r0804, sub(r07FE, r0801), 0x01));

      body.emit(assign(r07F2, r0804, 0x01));

      /* IF CONDITION */
      ir_expression *const r0806 = less(body.constant(int(0)), r0804);
      ir_if *f0805 = new(mem_ctx) ir_if(operand(r0806).val);
      exec_list *const f0805_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0805->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0808 = equal(r07FE, body.constant(int(2047)));
         ir_if *f0807 = new(mem_ctx) ir_if(operand(r0808).val);
         exec_list *const f0807_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0807->then_instructions;

            /* IF CONDITION */
            ir_expression *const r080A = bit_or(r07FB, swizzle_x(r07E9));
            ir_expression *const r080B = nequal(r080A, body.constant(0u));
            ir_if *f0809 = new(mem_ctx) ir_if(operand(r080B).val);
            exec_list *const f0809_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0809->then_instructions;

               ir_variable *const r080C = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r080C, swizzle_x(r07E9), 0x01));

               ir_variable *const r080D = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r080D, swizzle_x(r07EA), 0x01));

               ir_variable *const r080E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r080F = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0810 = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r0811 = bit_and(r0810, body.constant(4095u));
               ir_expression *const r0812 = equal(r0811, body.constant(4094u));
               ir_expression *const r0813 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r0814 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r0815 = nequal(r0814, body.constant(0u));
               ir_expression *const r0816 = logic_or(r0813, r0815);
               body.emit(assign(r080F, logic_and(r0812, r0816), 0x01));

               ir_variable *const r0817 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0818 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r0819 = lequal(body.constant(4292870144u), r0818);
               ir_expression *const r081A = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r081B = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r081C = nequal(r081B, body.constant(0u));
               ir_expression *const r081D = logic_or(r081A, r081C);
               body.emit(assign(r0817, logic_and(r0819, r081D), 0x01));

               body.emit(assign(r080C, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r080D, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r081F = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r0820 = lequal(body.constant(4292870144u), r081F);
               ir_expression *const r0821 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r0822 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r0823 = nequal(r0822, body.constant(0u));
               ir_expression *const r0824 = logic_or(r0821, r0823);
               ir_expression *const r0825 = logic_and(r0820, r0824);
               ir_if *f081E = new(mem_ctx) ir_if(operand(r0825).val);
               exec_list *const f081E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f081E->then_instructions;

                  ir_variable *const r0826 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0828 = logic_and(r080F, r0817);
                  ir_if *f0827 = new(mem_ctx) ir_if(operand(r0828).val);
                  exec_list *const f0827_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0827->then_instructions;

                     body.emit(assign(r0826, r080D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0827->else_instructions;

                     body.emit(assign(r0826, r080C, 0x03));


                  body.instructions = f0827_parent_instructions;
                  body.emit(f0827);

                  /* END IF */

                  body.emit(assign(r080E, r0826, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f081E->else_instructions;

                  body.emit(assign(r080E, r080D, 0x03));


               body.instructions = f081E_parent_instructions;
               body.emit(f081E);

               /* END IF */

               body.emit(assign(r07F1, r080E, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0809->else_instructions;

               body.emit(assign(r07F1, r07E9, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


            body.instructions = f0809_parent_instructions;
            body.emit(f0809);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0807->else_instructions;

            /* IF CONDITION */
            ir_expression *const r082A = equal(r0801, body.constant(int(0)));
            ir_if *f0829 = new(mem_ctx) ir_if(operand(r082A).val);
            exec_list *const f0829_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0829->then_instructions;

               body.emit(assign(r07F2, add(r0804, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0829->else_instructions;

               body.emit(assign(r07F3, bit_or(r07FD, body.constant(1048576u)), 0x01));


            body.instructions = f0829_parent_instructions;
            body.emit(f0829);

            /* END IF */

            ir_variable *const r082B = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r082B, body.constant(0u), 0x01));

            ir_variable *const r082C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r082C);
            ir_variable *const r082D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r082D);
            ir_variable *const r082E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r082E);
            ir_variable *const r082F = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0830 = neg(r07F2);
            body.emit(assign(r082F, bit_and(r0830, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0832 = equal(r07F2, body.constant(int(0)));
            ir_if *f0831 = new(mem_ctx) ir_if(operand(r0832).val);
            exec_list *const f0831_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0831->then_instructions;

               body.emit(assign(r082C, r082B, 0x01));

               body.emit(assign(r082D, r07FC, 0x01));

               body.emit(assign(r082E, r07F3, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0831->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0834 = less(r07F2, body.constant(int(32)));
               ir_if *f0833 = new(mem_ctx) ir_if(operand(r0834).val);
               exec_list *const f0833_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0833->then_instructions;

                  body.emit(assign(r082C, lshift(swizzle_x(r07EA), r082F), 0x01));

                  ir_expression *const r0835 = lshift(r07F3, r082F);
                  ir_expression *const r0836 = rshift(swizzle_x(r07EA), r07F2);
                  body.emit(assign(r082D, bit_or(r0835, r0836), 0x01));

                  body.emit(assign(r082E, rshift(r07F3, r07F2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0833->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0838 = equal(r07F2, body.constant(int(32)));
                  ir_if *f0837 = new(mem_ctx) ir_if(operand(r0838).val);
                  exec_list *const f0837_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0837->then_instructions;

                     body.emit(assign(r082C, r07FC, 0x01));

                     body.emit(assign(r082D, r07F3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0837->else_instructions;

                     body.emit(assign(r082B, bit_or(body.constant(0u), swizzle_x(r07EA)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r083A = less(r07F2, body.constant(int(64)));
                     ir_if *f0839 = new(mem_ctx) ir_if(operand(r083A).val);
                     exec_list *const f0839_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0839->then_instructions;

                        body.emit(assign(r082C, lshift(r07F3, r082F), 0x01));

                        ir_expression *const r083B = bit_and(r07F2, body.constant(int(31)));
                        body.emit(assign(r082D, rshift(r07F3, r083B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0839->else_instructions;

                        ir_variable *const r083C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r083E = equal(r07F2, body.constant(int(64)));
                        ir_if *f083D = new(mem_ctx) ir_if(operand(r083E).val);
                        exec_list *const f083D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f083D->then_instructions;

                           body.emit(assign(r083C, r07F3, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f083D->else_instructions;

                           ir_expression *const r083F = nequal(r07F3, body.constant(0u));
                           ir_expression *const r0840 = expr(ir_unop_b2i, r083F);
                           body.emit(assign(r083C, expr(ir_unop_i2u, r0840), 0x01));


                        body.instructions = f083D_parent_instructions;
                        body.emit(f083D);

                        /* END IF */

                        body.emit(assign(r082C, r083C, 0x01));

                        body.emit(assign(r082D, body.constant(0u), 0x01));


                     body.instructions = f0839_parent_instructions;
                     body.emit(f0839);

                     /* END IF */


                  body.instructions = f0837_parent_instructions;
                  body.emit(f0837);

                  /* END IF */

                  body.emit(assign(r082E, body.constant(0u), 0x01));


               body.instructions = f0833_parent_instructions;
               body.emit(f0833);

               /* END IF */

               ir_expression *const r0841 = nequal(r082B, body.constant(0u));
               ir_expression *const r0842 = expr(ir_unop_b2i, r0841);
               ir_expression *const r0843 = expr(ir_unop_i2u, r0842);
               body.emit(assign(r082C, bit_or(r082C, r0843), 0x01));


            body.instructions = f0831_parent_instructions;
            body.emit(f0831);

            /* END IF */

            body.emit(assign(r07F3, r082E, 0x01));

            body.emit(assign(r07F4, r082D, 0x01));

            body.emit(assign(r07F8, r082C, 0x01));

            body.emit(assign(r07F7, r07FE, 0x01));


         body.instructions = f0807_parent_instructions;
         body.emit(f0807);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0805->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0845 = less(r07F2, body.constant(int(0)));
         ir_if *f0844 = new(mem_ctx) ir_if(operand(r0845).val);
         exec_list *const f0844_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0844->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0847 = equal(r0801, body.constant(int(2047)));
            ir_if *f0846 = new(mem_ctx) ir_if(operand(r0847).val);
            exec_list *const f0846_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0846->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0849 = bit_or(r07F3, r07F4);
               ir_expression *const r084A = nequal(r0849, body.constant(0u));
               ir_if *f0848 = new(mem_ctx) ir_if(operand(r084A).val);
               exec_list *const f0848_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0848->then_instructions;

                  ir_variable *const r084B = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r084B, swizzle_x(r07E9), 0x01));

                  ir_variable *const r084C = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r084C, swizzle_x(r07EA), 0x01));

                  ir_variable *const r084D = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r084E = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r084F = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0850 = bit_and(r084F, body.constant(4095u));
                  ir_expression *const r0851 = equal(r0850, body.constant(4094u));
                  ir_expression *const r0852 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0853 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0854 = nequal(r0853, body.constant(0u));
                  ir_expression *const r0855 = logic_or(r0852, r0854);
                  body.emit(assign(r084E, logic_and(r0851, r0855), 0x01));

                  ir_variable *const r0856 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0857 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0858 = lequal(body.constant(4292870144u), r0857);
                  ir_expression *const r0859 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r085A = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r085B = nequal(r085A, body.constant(0u));
                  ir_expression *const r085C = logic_or(r0859, r085B);
                  body.emit(assign(r0856, logic_and(r0858, r085C), 0x01));

                  body.emit(assign(r084B, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r084C, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r085E = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r085F = lequal(body.constant(4292870144u), r085E);
                  ir_expression *const r0860 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0861 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0862 = nequal(r0861, body.constant(0u));
                  ir_expression *const r0863 = logic_or(r0860, r0862);
                  ir_expression *const r0864 = logic_and(r085F, r0863);
                  ir_if *f085D = new(mem_ctx) ir_if(operand(r0864).val);
                  exec_list *const f085D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f085D->then_instructions;

                     ir_variable *const r0865 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0867 = logic_and(r084E, r0856);
                     ir_if *f0866 = new(mem_ctx) ir_if(operand(r0867).val);
                     exec_list *const f0866_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0866->then_instructions;

                        body.emit(assign(r0865, r084C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0866->else_instructions;

                        body.emit(assign(r0865, r084B, 0x03));


                     body.instructions = f0866_parent_instructions;
                     body.emit(f0866);

                     /* END IF */

                     body.emit(assign(r084D, r0865, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f085D->else_instructions;

                     body.emit(assign(r084D, r084C, 0x03));


                  body.instructions = f085D_parent_instructions;
                  body.emit(f085D);

                  /* END IF */

                  body.emit(assign(r07F1, r084D, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0848->else_instructions;

                  ir_variable *const r0868 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0868);
                  ir_expression *const r0869 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0868, add(r0869, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0868, body.constant(0u), 0x01));

                  body.emit(assign(r07F1, r0868, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0848_parent_instructions;
               body.emit(f0848);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0846->else_instructions;

               /* IF CONDITION */
               ir_expression *const r086B = equal(r07FE, body.constant(int(0)));
               ir_if *f086A = new(mem_ctx) ir_if(operand(r086B).val);
               exec_list *const f086A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f086A->then_instructions;

                  body.emit(assign(r07F2, add(r07F2, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f086A->else_instructions;

                  body.emit(assign(r07F5, bit_or(r07FB, body.constant(1048576u)), 0x01));


               body.instructions = f086A_parent_instructions;
               body.emit(f086A);

               /* END IF */

               ir_variable *const r086C = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r086C, body.constant(0u), 0x01));

               ir_variable *const r086D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r086D, neg(r07F2), 0x01));

               ir_variable *const r086E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r086E);
               ir_variable *const r086F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r086F);
               ir_variable *const r0870 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0870);
               ir_variable *const r0871 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0872 = neg(r086D);
               body.emit(assign(r0871, bit_and(r0872, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0874 = equal(r086D, body.constant(int(0)));
               ir_if *f0873 = new(mem_ctx) ir_if(operand(r0874).val);
               exec_list *const f0873_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0873->then_instructions;

                  body.emit(assign(r086E, r086C, 0x01));

                  body.emit(assign(r086F, r07FA, 0x01));

                  body.emit(assign(r0870, r07F5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0873->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0876 = less(r086D, body.constant(int(32)));
                  ir_if *f0875 = new(mem_ctx) ir_if(operand(r0876).val);
                  exec_list *const f0875_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0875->then_instructions;

                     body.emit(assign(r086E, lshift(swizzle_x(r07E9), r0871), 0x01));

                     ir_expression *const r0877 = lshift(r07F5, r0871);
                     ir_expression *const r0878 = rshift(swizzle_x(r07E9), r086D);
                     body.emit(assign(r086F, bit_or(r0877, r0878), 0x01));

                     body.emit(assign(r0870, rshift(r07F5, r086D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0875->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r087A = equal(r086D, body.constant(int(32)));
                     ir_if *f0879 = new(mem_ctx) ir_if(operand(r087A).val);
                     exec_list *const f0879_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0879->then_instructions;

                        body.emit(assign(r086E, r07FA, 0x01));

                        body.emit(assign(r086F, r07F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0879->else_instructions;

                        body.emit(assign(r086C, bit_or(body.constant(0u), swizzle_x(r07E9)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r087C = less(r086D, body.constant(int(64)));
                        ir_if *f087B = new(mem_ctx) ir_if(operand(r087C).val);
                        exec_list *const f087B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f087B->then_instructions;

                           body.emit(assign(r086E, lshift(r07F5, r0871), 0x01));

                           ir_expression *const r087D = bit_and(r086D, body.constant(int(31)));
                           body.emit(assign(r086F, rshift(r07F5, r087D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f087B->else_instructions;

                           ir_variable *const r087E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0880 = equal(r086D, body.constant(int(64)));
                           ir_if *f087F = new(mem_ctx) ir_if(operand(r0880).val);
                           exec_list *const f087F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f087F->then_instructions;

                              body.emit(assign(r087E, r07F5, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f087F->else_instructions;

                              ir_expression *const r0881 = nequal(r07F5, body.constant(0u));
                              ir_expression *const r0882 = expr(ir_unop_b2i, r0881);
                              body.emit(assign(r087E, expr(ir_unop_i2u, r0882), 0x01));


                           body.instructions = f087F_parent_instructions;
                           body.emit(f087F);

                           /* END IF */

                           body.emit(assign(r086E, r087E, 0x01));

                           body.emit(assign(r086F, body.constant(0u), 0x01));


                        body.instructions = f087B_parent_instructions;
                        body.emit(f087B);

                        /* END IF */


                     body.instructions = f0879_parent_instructions;
                     body.emit(f0879);

                     /* END IF */

                     body.emit(assign(r0870, body.constant(0u), 0x01));


                  body.instructions = f0875_parent_instructions;
                  body.emit(f0875);

                  /* END IF */

                  ir_expression *const r0883 = nequal(r086C, body.constant(0u));
                  ir_expression *const r0884 = expr(ir_unop_b2i, r0883);
                  ir_expression *const r0885 = expr(ir_unop_i2u, r0884);
                  body.emit(assign(r086E, bit_or(r086E, r0885), 0x01));


               body.instructions = f0873_parent_instructions;
               body.emit(f0873);

               /* END IF */

               body.emit(assign(r07F5, r0870, 0x01));

               body.emit(assign(r07F6, r086F, 0x01));

               body.emit(assign(r07F8, r086E, 0x01));

               body.emit(assign(r07F7, r0801, 0x01));


            body.instructions = f0846_parent_instructions;
            body.emit(f0846);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0844->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0887 = equal(r07FE, body.constant(int(2047)));
            ir_if *f0886 = new(mem_ctx) ir_if(operand(r0887).val);
            exec_list *const f0886_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0886->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0889 = bit_or(r07F5, r07F6);
               ir_expression *const r088A = bit_or(r07F3, r07F4);
               ir_expression *const r088B = bit_or(r0889, r088A);
               ir_expression *const r088C = nequal(r088B, body.constant(0u));
               ir_if *f0888 = new(mem_ctx) ir_if(operand(r088C).val);
               exec_list *const f0888_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0888->then_instructions;

                  ir_variable *const r088D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r088D, swizzle_x(r07E9), 0x01));

                  ir_variable *const r088E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r088E, swizzle_x(r07EA), 0x01));

                  ir_variable *const r088F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0890 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0891 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0892 = bit_and(r0891, body.constant(4095u));
                  ir_expression *const r0893 = equal(r0892, body.constant(4094u));
                  ir_expression *const r0894 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0895 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0896 = nequal(r0895, body.constant(0u));
                  ir_expression *const r0897 = logic_or(r0894, r0896);
                  body.emit(assign(r0890, logic_and(r0893, r0897), 0x01));

                  ir_variable *const r0898 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0899 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r089A = lequal(body.constant(4292870144u), r0899);
                  ir_expression *const r089B = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r089C = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r089D = nequal(r089C, body.constant(0u));
                  ir_expression *const r089E = logic_or(r089B, r089D);
                  body.emit(assign(r0898, logic_and(r089A, r089E), 0x01));

                  body.emit(assign(r088D, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r088E, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r08A0 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r08A1 = lequal(body.constant(4292870144u), r08A0);
                  ir_expression *const r08A2 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r08A3 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r08A4 = nequal(r08A3, body.constant(0u));
                  ir_expression *const r08A5 = logic_or(r08A2, r08A4);
                  ir_expression *const r08A6 = logic_and(r08A1, r08A5);
                  ir_if *f089F = new(mem_ctx) ir_if(operand(r08A6).val);
                  exec_list *const f089F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f089F->then_instructions;

                     ir_variable *const r08A7 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08A9 = logic_and(r0890, r0898);
                     ir_if *f08A8 = new(mem_ctx) ir_if(operand(r08A9).val);
                     exec_list *const f08A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08A8->then_instructions;

                        body.emit(assign(r08A7, r088E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08A8->else_instructions;

                        body.emit(assign(r08A7, r088D, 0x03));


                     body.instructions = f08A8_parent_instructions;
                     body.emit(f08A8);

                     /* END IF */

                     body.emit(assign(r088F, r08A7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f089F->else_instructions;

                     body.emit(assign(r088F, r088E, 0x03));


                  body.instructions = f089F_parent_instructions;
                  body.emit(f089F);

                  /* END IF */

                  body.emit(assign(r07F1, r088F, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0888->else_instructions;

                  body.emit(assign(r07F1, r07E9, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0888_parent_instructions;
               body.emit(f0888);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0886->else_instructions;

               ir_variable *const r08AA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r08AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r08AB, add(r07F6, r07F4), 0x01));

               ir_expression *const r08AC = add(r07F5, r07F3);
               ir_expression *const r08AD = less(r08AB, r07F6);
               ir_expression *const r08AE = expr(ir_unop_b2i, r08AD);
               ir_expression *const r08AF = expr(ir_unop_i2u, r08AE);
               body.emit(assign(r08AA, add(r08AC, r08AF), 0x01));

               body.emit(assign(r07F9, r08AA, 0x01));

               /* IF CONDITION */
               ir_expression *const r08B1 = equal(r07FE, body.constant(int(0)));
               ir_if *f08B0 = new(mem_ctx) ir_if(operand(r08B1).val);
               exec_list *const f08B0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f08B0->then_instructions;

                  ir_variable *const r08B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r08B2);
                  ir_expression *const r08B3 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r08B2, add(r08B3, r08AA), 0x02));

                  body.emit(assign(r08B2, r08AB, 0x01));

                  body.emit(assign(r07F1, r08B2, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f08B0->else_instructions;

                  body.emit(assign(r07F9, bit_or(r08AA, body.constant(2097152u)), 0x01));

                  body.emit(assign(r07F7, r07FE, 0x01));

                  ir_variable *const r08B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r08B4);
                  ir_variable *const r08B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r08B5);
                  ir_variable *const r08B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r08B6);
                  body.emit(assign(r08B4, lshift(r08AB, body.constant(int(31))), 0x01));

                  ir_expression *const r08B7 = lshift(r07F9, body.constant(int(31)));
                  ir_expression *const r08B8 = rshift(r08AB, body.constant(int(1)));
                  body.emit(assign(r08B5, bit_or(r08B7, r08B8), 0x01));

                  body.emit(assign(r08B6, rshift(r07F9, body.constant(int(1))), 0x01));

                  body.emit(assign(r08B4, bit_or(r08B4, body.constant(0u)), 0x01));

                  body.emit(assign(r07F9, r08B6, 0x01));

                  body.emit(assign(r07F8, r08B4, 0x01));

                  ir_variable *const r08B9 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r08B9, r07FE, 0x01));

                  ir_variable *const r08BA = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r08BA, r08B6, 0x01));

                  ir_variable *const r08BB = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r08BB, r08B5, 0x01));

                  ir_variable *const r08BC = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r08BC, r08B4, 0x01));

                  ir_variable *const r08BD = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r08BD, body.constant(true), 0x01));

                  ir_variable *const r08BE = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r08BF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r08BF);
                  ir_expression *const r08C0 = expr(ir_unop_u2i, r08B4);
                  body.emit(assign(r08BF, less(r08C0, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r08C2 = lequal(body.constant(int(2045)), r07FE);
                  ir_if *f08C1 = new(mem_ctx) ir_if(operand(r08C2).val);
                  exec_list *const f08C1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08C1->then_instructions;

                     ir_variable *const r08C3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08C5 = less(body.constant(int(2045)), r07FE);
                     ir_if *f08C4 = new(mem_ctx) ir_if(operand(r08C5).val);
                     exec_list *const f08C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08C4->then_instructions;

                        body.emit(assign(r08C3, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08C4->else_instructions;

                        ir_variable *const r08C6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r08C8 = equal(r07FE, body.constant(int(2045)));
                        ir_if *f08C7 = new(mem_ctx) ir_if(operand(r08C8).val);
                        exec_list *const f08C7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08C7->then_instructions;

                           ir_expression *const r08C9 = equal(body.constant(2097151u), r08B6);
                           ir_expression *const r08CA = equal(body.constant(4294967295u), r08B5);
                           body.emit(assign(r08C6, logic_and(r08C9, r08CA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f08C7->else_instructions;

                           body.emit(assign(r08C6, body.constant(false), 0x01));


                        body.instructions = f08C7_parent_instructions;
                        body.emit(f08C7);

                        /* END IF */

                        body.emit(assign(r08C3, logic_and(r08C6, r08BF), 0x01));


                     body.instructions = f08C4_parent_instructions;
                     body.emit(f08C4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f08CB = new(mem_ctx) ir_if(operand(r08C3).val);
                     exec_list *const f08CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08CB->then_instructions;

                        ir_variable *const r08CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r08CC);
                        ir_expression *const r08CD = lshift(r07EC, body.constant(int(31)));
                        body.emit(assign(r08CC, add(r08CD, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r08CC, body.constant(0u), 0x01));

                        body.emit(assign(r08BE, r08CC, 0x03));

                        body.emit(assign(r08BD, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08CB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08CF = less(r07FE, body.constant(int(0)));
                        ir_if *f08CE = new(mem_ctx) ir_if(operand(r08CF).val);
                        exec_list *const f08CE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08CE->then_instructions;

                           ir_variable *const r08D0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r08D0, r08B4, 0x01));

                           ir_variable *const r08D1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r08D1, neg(r07FE), 0x01));

                           ir_variable *const r08D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r08D2);
                           ir_variable *const r08D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r08D3);
                           ir_variable *const r08D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r08D4);
                           ir_variable *const r08D5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r08D6 = neg(r08D1);
                           body.emit(assign(r08D5, bit_and(r08D6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r08D8 = equal(r08D1, body.constant(int(0)));
                           ir_if *f08D7 = new(mem_ctx) ir_if(operand(r08D8).val);
                           exec_list *const f08D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f08D7->then_instructions;

                              body.emit(assign(r08D2, r08B4, 0x01));

                              body.emit(assign(r08D3, r08B5, 0x01));

                              body.emit(assign(r08D4, r08B6, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f08D7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r08DA = less(r08D1, body.constant(int(32)));
                              ir_if *f08D9 = new(mem_ctx) ir_if(operand(r08DA).val);
                              exec_list *const f08D9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f08D9->then_instructions;

                                 body.emit(assign(r08D2, lshift(r08B5, r08D5), 0x01));

                                 ir_expression *const r08DB = lshift(r08B6, r08D5);
                                 ir_expression *const r08DC = rshift(r08B5, r08D1);
                                 body.emit(assign(r08D3, bit_or(r08DB, r08DC), 0x01));

                                 body.emit(assign(r08D4, rshift(r08B6, r08D1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f08D9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r08DE = equal(r08D1, body.constant(int(32)));
                                 ir_if *f08DD = new(mem_ctx) ir_if(operand(r08DE).val);
                                 exec_list *const f08DD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f08DD->then_instructions;

                                    body.emit(assign(r08D2, r08B5, 0x01));

                                    body.emit(assign(r08D3, r08B6, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f08DD->else_instructions;

                                    body.emit(assign(r08D0, bit_or(r08B4, r08B5), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r08E0 = less(r08D1, body.constant(int(64)));
                                    ir_if *f08DF = new(mem_ctx) ir_if(operand(r08E0).val);
                                    exec_list *const f08DF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f08DF->then_instructions;

                                       body.emit(assign(r08D2, lshift(r08B6, r08D5), 0x01));

                                       ir_expression *const r08E1 = bit_and(r08D1, body.constant(int(31)));
                                       body.emit(assign(r08D3, rshift(r08B6, r08E1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f08DF->else_instructions;

                                       ir_variable *const r08E2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r08E4 = equal(r08D1, body.constant(int(64)));
                                       ir_if *f08E3 = new(mem_ctx) ir_if(operand(r08E4).val);
                                       exec_list *const f08E3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f08E3->then_instructions;

                                          body.emit(assign(r08E2, r08B6, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f08E3->else_instructions;

                                          ir_expression *const r08E5 = nequal(r08B6, body.constant(0u));
                                          ir_expression *const r08E6 = expr(ir_unop_b2i, r08E5);
                                          body.emit(assign(r08E2, expr(ir_unop_i2u, r08E6), 0x01));


                                       body.instructions = f08E3_parent_instructions;
                                       body.emit(f08E3);

                                       /* END IF */

                                       body.emit(assign(r08D2, r08E2, 0x01));

                                       body.emit(assign(r08D3, body.constant(0u), 0x01));


                                    body.instructions = f08DF_parent_instructions;
                                    body.emit(f08DF);

                                    /* END IF */


                                 body.instructions = f08DD_parent_instructions;
                                 body.emit(f08DD);

                                 /* END IF */

                                 body.emit(assign(r08D4, body.constant(0u), 0x01));


                              body.instructions = f08D9_parent_instructions;
                              body.emit(f08D9);

                              /* END IF */

                              ir_expression *const r08E7 = nequal(r08D0, body.constant(0u));
                              ir_expression *const r08E8 = expr(ir_unop_b2i, r08E7);
                              ir_expression *const r08E9 = expr(ir_unop_i2u, r08E8);
                              body.emit(assign(r08D2, bit_or(r08D2, r08E9), 0x01));


                           body.instructions = f08D7_parent_instructions;
                           body.emit(f08D7);

                           /* END IF */

                           body.emit(assign(r08BA, r08D4, 0x01));

                           body.emit(assign(r08BB, r08D3, 0x01));

                           body.emit(assign(r08BC, r08D2, 0x01));

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));

                           body.emit(assign(r08BF, less(r08D2, body.constant(0u)), 0x01));


                        body.instructions = f08CE_parent_instructions;
                        body.emit(f08CE);

                        /* END IF */


                     body.instructions = f08CB_parent_instructions;
                     body.emit(f08CB);

                     /* END IF */


                  body.instructions = f08C1_parent_instructions;
                  body.emit(f08C1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f08EA = new(mem_ctx) ir_if(operand(r08BD).val);
                  exec_list *const f08EA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08EA->then_instructions;

                     /* IF CONDITION */
                     ir_if *f08EB = new(mem_ctx) ir_if(operand(r08BF).val);
                     exec_list *const f08EB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08EB->then_instructions;

                        ir_variable *const r08EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r08EC, add(r08BB, body.constant(1u)), 0x01));

                        ir_expression *const r08ED = less(r08EC, r08BB);
                        ir_expression *const r08EE = expr(ir_unop_b2i, r08ED);
                        ir_expression *const r08EF = expr(ir_unop_i2u, r08EE);
                        body.emit(assign(r08BA, add(r08BA, r08EF), 0x01));

                        ir_expression *const r08F0 = equal(r08BC, body.constant(0u));
                        ir_expression *const r08F1 = expr(ir_unop_b2i, r08F0);
                        ir_expression *const r08F2 = expr(ir_unop_i2u, r08F1);
                        ir_expression *const r08F3 = add(r08BC, r08F2);
                        ir_expression *const r08F4 = bit_and(r08F3, body.constant(1u));
                        ir_expression *const r08F5 = expr(ir_unop_bit_not, r08F4);
                        body.emit(assign(r08BB, bit_and(r08EC, r08F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08EB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08F7 = bit_or(r08BA, r08BB);
                        ir_expression *const r08F8 = equal(r08F7, body.constant(0u));
                        ir_if *f08F6 = new(mem_ctx) ir_if(operand(r08F8).val);
                        exec_list *const f08F6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08F6->then_instructions;

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));


                        body.instructions = f08F6_parent_instructions;
                        body.emit(f08F6);

                        /* END IF */


                     body.instructions = f08EB_parent_instructions;
                     body.emit(f08EB);

                     /* END IF */

                     ir_variable *const r08F9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r08F9);
                     ir_expression *const r08FA = lshift(r07EC, body.constant(int(31)));
                     ir_expression *const r08FB = expr(ir_unop_i2u, r08B9);
                     ir_expression *const r08FC = lshift(r08FB, body.constant(int(20)));
                     ir_expression *const r08FD = add(r08FA, r08FC);
                     body.emit(assign(r08F9, add(r08FD, r08BA), 0x02));

                     body.emit(assign(r08F9, r08BB, 0x01));

                     body.emit(assign(r08BE, r08F9, 0x03));

                     body.emit(assign(r08BD, body.constant(false), 0x01));


                  body.instructions = f08EA_parent_instructions;
                  body.emit(f08EA);

                  /* END IF */

                  body.emit(assign(r07F1, r08BE, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f08B0_parent_instructions;
               body.emit(f08B0);

               /* END IF */


            body.instructions = f0886_parent_instructions;
            body.emit(f0886);

            /* END IF */


         body.instructions = f0844_parent_instructions;
         body.emit(f0844);

         /* END IF */


      body.instructions = f0805_parent_instructions;
      body.emit(f0805);

      /* END IF */

      /* IF CONDITION */
      ir_if *f08FE = new(mem_ctx) ir_if(operand(r07F0).val);
      exec_list *const f08FE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f08FE->then_instructions;

         body.emit(assign(r07F5, bit_or(r07F5, body.constant(1048576u)), 0x01));

         ir_variable *const r08FF = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0900 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r0900, add(r07F6, r07F4), 0x01));

         ir_expression *const r0901 = add(r07F5, r07F3);
         ir_expression *const r0902 = less(r0900, r07F6);
         ir_expression *const r0903 = expr(ir_unop_b2i, r0902);
         ir_expression *const r0904 = expr(ir_unop_i2u, r0903);
         body.emit(assign(r08FF, add(r0901, r0904), 0x01));

         body.emit(assign(r07F9, r08FF, 0x01));

         body.emit(assign(r07F7, add(r07F7, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0906 = less(r08FF, body.constant(2097152u));
         ir_if *f0905 = new(mem_ctx) ir_if(operand(r0906).val);
         exec_list *const f0905_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0905->then_instructions;

            ir_variable *const r0907 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0907, r07F7, 0x01));

            ir_variable *const r0908 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0908, r08FF, 0x01));

            ir_variable *const r0909 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0909, r0900, 0x01));

            ir_variable *const r090A = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r090A, r07F8, 0x01));

            ir_variable *const r090B = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r090B, body.constant(true), 0x01));

            ir_variable *const r090C = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r090D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r090D);
            ir_expression *const r090E = expr(ir_unop_u2i, r07F8);
            body.emit(assign(r090D, less(r090E, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0910 = lequal(body.constant(int(2045)), r07F7);
            ir_if *f090F = new(mem_ctx) ir_if(operand(r0910).val);
            exec_list *const f090F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f090F->then_instructions;

               ir_variable *const r0911 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0913 = less(body.constant(int(2045)), r07F7);
               ir_if *f0912 = new(mem_ctx) ir_if(operand(r0913).val);
               exec_list *const f0912_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0912->then_instructions;

                  body.emit(assign(r0911, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0912->else_instructions;

                  ir_variable *const r0914 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0916 = equal(r07F7, body.constant(int(2045)));
                  ir_if *f0915 = new(mem_ctx) ir_if(operand(r0916).val);
                  exec_list *const f0915_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0915->then_instructions;

                     ir_expression *const r0917 = equal(body.constant(2097151u), r08FF);
                     ir_expression *const r0918 = equal(body.constant(4294967295u), r0900);
                     body.emit(assign(r0914, logic_and(r0917, r0918), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0915->else_instructions;

                     body.emit(assign(r0914, body.constant(false), 0x01));


                  body.instructions = f0915_parent_instructions;
                  body.emit(f0915);

                  /* END IF */

                  body.emit(assign(r0911, logic_and(r0914, r090D), 0x01));


               body.instructions = f0912_parent_instructions;
               body.emit(f0912);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0919 = new(mem_ctx) ir_if(operand(r0911).val);
               exec_list *const f0919_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0919->then_instructions;

                  ir_variable *const r091A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r091A);
                  ir_expression *const r091B = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r091A, add(r091B, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r091A, body.constant(0u), 0x01));

                  body.emit(assign(r090C, r091A, 0x03));

                  body.emit(assign(r090B, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0919->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r091D = less(r07F7, body.constant(int(0)));
                  ir_if *f091C = new(mem_ctx) ir_if(operand(r091D).val);
                  exec_list *const f091C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f091C->then_instructions;

                     ir_variable *const r091E = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r091E, r07F8, 0x01));

                     ir_variable *const r091F = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r091F, neg(r07F7), 0x01));

                     ir_variable *const r0920 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0920);
                     ir_variable *const r0921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0921);
                     ir_variable *const r0922 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0922);
                     ir_variable *const r0923 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0924 = neg(r091F);
                     body.emit(assign(r0923, bit_and(r0924, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0926 = equal(r091F, body.constant(int(0)));
                     ir_if *f0925 = new(mem_ctx) ir_if(operand(r0926).val);
                     exec_list *const f0925_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0925->then_instructions;

                        body.emit(assign(r0920, r07F8, 0x01));

                        body.emit(assign(r0921, r0900, 0x01));

                        body.emit(assign(r0922, r08FF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0925->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0928 = less(r091F, body.constant(int(32)));
                        ir_if *f0927 = new(mem_ctx) ir_if(operand(r0928).val);
                        exec_list *const f0927_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0927->then_instructions;

                           body.emit(assign(r0920, lshift(r0900, r0923), 0x01));

                           ir_expression *const r0929 = lshift(r08FF, r0923);
                           ir_expression *const r092A = rshift(r0900, r091F);
                           body.emit(assign(r0921, bit_or(r0929, r092A), 0x01));

                           body.emit(assign(r0922, rshift(r08FF, r091F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0927->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r092C = equal(r091F, body.constant(int(32)));
                           ir_if *f092B = new(mem_ctx) ir_if(operand(r092C).val);
                           exec_list *const f092B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f092B->then_instructions;

                              body.emit(assign(r0920, r0900, 0x01));

                              body.emit(assign(r0921, r08FF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f092B->else_instructions;

                              body.emit(assign(r091E, bit_or(r07F8, r0900), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r092E = less(r091F, body.constant(int(64)));
                              ir_if *f092D = new(mem_ctx) ir_if(operand(r092E).val);
                              exec_list *const f092D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f092D->then_instructions;

                                 body.emit(assign(r0920, lshift(r08FF, r0923), 0x01));

                                 ir_expression *const r092F = bit_and(r091F, body.constant(int(31)));
                                 body.emit(assign(r0921, rshift(r08FF, r092F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f092D->else_instructions;

                                 ir_variable *const r0930 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0932 = equal(r091F, body.constant(int(64)));
                                 ir_if *f0931 = new(mem_ctx) ir_if(operand(r0932).val);
                                 exec_list *const f0931_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0931->then_instructions;

                                    body.emit(assign(r0930, r08FF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0931->else_instructions;

                                    ir_expression *const r0933 = nequal(r08FF, body.constant(0u));
                                    ir_expression *const r0934 = expr(ir_unop_b2i, r0933);
                                    body.emit(assign(r0930, expr(ir_unop_i2u, r0934), 0x01));


                                 body.instructions = f0931_parent_instructions;
                                 body.emit(f0931);

                                 /* END IF */

                                 body.emit(assign(r0920, r0930, 0x01));

                                 body.emit(assign(r0921, body.constant(0u), 0x01));


                              body.instructions = f092D_parent_instructions;
                              body.emit(f092D);

                              /* END IF */


                           body.instructions = f092B_parent_instructions;
                           body.emit(f092B);

                           /* END IF */

                           body.emit(assign(r0922, body.constant(0u), 0x01));


                        body.instructions = f0927_parent_instructions;
                        body.emit(f0927);

                        /* END IF */

                        ir_expression *const r0935 = nequal(r091E, body.constant(0u));
                        ir_expression *const r0936 = expr(ir_unop_b2i, r0935);
                        ir_expression *const r0937 = expr(ir_unop_i2u, r0936);
                        body.emit(assign(r0920, bit_or(r0920, r0937), 0x01));


                     body.instructions = f0925_parent_instructions;
                     body.emit(f0925);

                     /* END IF */

                     body.emit(assign(r0908, r0922, 0x01));

                     body.emit(assign(r0909, r0921, 0x01));

                     body.emit(assign(r090A, r0920, 0x01));

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));

                     body.emit(assign(r090D, less(r0920, body.constant(0u)), 0x01));


                  body.instructions = f091C_parent_instructions;
                  body.emit(f091C);

                  /* END IF */


               body.instructions = f0919_parent_instructions;
               body.emit(f0919);

               /* END IF */


            body.instructions = f090F_parent_instructions;
            body.emit(f090F);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0938 = new(mem_ctx) ir_if(operand(r090B).val);
            exec_list *const f0938_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0938->then_instructions;

               /* IF CONDITION */
               ir_if *f0939 = new(mem_ctx) ir_if(operand(r090D).val);
               exec_list *const f0939_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0939->then_instructions;

                  ir_variable *const r093A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r093A, add(r0909, body.constant(1u)), 0x01));

                  ir_expression *const r093B = less(r093A, r0909);
                  ir_expression *const r093C = expr(ir_unop_b2i, r093B);
                  ir_expression *const r093D = expr(ir_unop_i2u, r093C);
                  body.emit(assign(r0908, add(r0908, r093D), 0x01));

                  ir_expression *const r093E = equal(r090A, body.constant(0u));
                  ir_expression *const r093F = expr(ir_unop_b2i, r093E);
                  ir_expression *const r0940 = expr(ir_unop_i2u, r093F);
                  ir_expression *const r0941 = add(r090A, r0940);
                  ir_expression *const r0942 = bit_and(r0941, body.constant(1u));
                  ir_expression *const r0943 = expr(ir_unop_bit_not, r0942);
                  body.emit(assign(r0909, bit_and(r093A, r0943), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0939->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0945 = bit_or(r0908, r0909);
                  ir_expression *const r0946 = equal(r0945, body.constant(0u));
                  ir_if *f0944 = new(mem_ctx) ir_if(operand(r0946).val);
                  exec_list *const f0944_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0944->then_instructions;

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));


                  body.instructions = f0944_parent_instructions;
                  body.emit(f0944);

                  /* END IF */


               body.instructions = f0939_parent_instructions;
               body.emit(f0939);

               /* END IF */

               ir_variable *const r0947 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0947);
               ir_expression *const r0948 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0949 = expr(ir_unop_i2u, r0907);
               ir_expression *const r094A = lshift(r0949, body.constant(int(20)));
               ir_expression *const r094B = add(r0948, r094A);
               body.emit(assign(r0947, add(r094B, r0908), 0x02));

               body.emit(assign(r0947, r0909, 0x01));

               body.emit(assign(r090C, r0947, 0x03));

               body.emit(assign(r090B, body.constant(false), 0x01));


            body.instructions = f0938_parent_instructions;
            body.emit(f0938);

            /* END IF */

            body.emit(assign(r07F1, r090C, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0905->else_instructions;

            body.emit(assign(r07F7, add(r07F7, body.constant(int(1))), 0x01));

            ir_variable *const r094C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r094C);
            ir_variable *const r094D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r094D);
            ir_variable *const r094E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r094E);
            body.emit(assign(r094C, lshift(r0900, body.constant(int(31))), 0x01));

            ir_expression *const r094F = lshift(r08FF, body.constant(int(31)));
            ir_expression *const r0950 = rshift(r0900, body.constant(int(1)));
            body.emit(assign(r094D, bit_or(r094F, r0950), 0x01));

            body.emit(assign(r094E, rshift(r08FF, body.constant(int(1))), 0x01));

            ir_expression *const r0951 = nequal(r07F8, body.constant(0u));
            ir_expression *const r0952 = expr(ir_unop_b2i, r0951);
            ir_expression *const r0953 = expr(ir_unop_i2u, r0952);
            body.emit(assign(r094C, bit_or(r094C, r0953), 0x01));

            body.emit(assign(r07F9, r094E, 0x01));

            body.emit(assign(r07F8, r094C, 0x01));

            ir_variable *const r0954 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0954, r07F7, 0x01));

            ir_variable *const r0955 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0955, r094E, 0x01));

            ir_variable *const r0956 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0956, r094D, 0x01));

            ir_variable *const r0957 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0957, r094C, 0x01));

            ir_variable *const r0958 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0958, body.constant(true), 0x01));

            ir_variable *const r0959 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r095A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r095A);
            ir_expression *const r095B = expr(ir_unop_u2i, r094C);
            body.emit(assign(r095A, less(r095B, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r095D = lequal(body.constant(int(2045)), r07F7);
            ir_if *f095C = new(mem_ctx) ir_if(operand(r095D).val);
            exec_list *const f095C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f095C->then_instructions;

               ir_variable *const r095E = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0960 = less(body.constant(int(2045)), r07F7);
               ir_if *f095F = new(mem_ctx) ir_if(operand(r0960).val);
               exec_list *const f095F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f095F->then_instructions;

                  body.emit(assign(r095E, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f095F->else_instructions;

                  ir_variable *const r0961 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0963 = equal(r07F7, body.constant(int(2045)));
                  ir_if *f0962 = new(mem_ctx) ir_if(operand(r0963).val);
                  exec_list *const f0962_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0962->then_instructions;

                     ir_expression *const r0964 = equal(body.constant(2097151u), r094E);
                     ir_expression *const r0965 = equal(body.constant(4294967295u), r094D);
                     body.emit(assign(r0961, logic_and(r0964, r0965), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0962->else_instructions;

                     body.emit(assign(r0961, body.constant(false), 0x01));


                  body.instructions = f0962_parent_instructions;
                  body.emit(f0962);

                  /* END IF */

                  body.emit(assign(r095E, logic_and(r0961, r095A), 0x01));


               body.instructions = f095F_parent_instructions;
               body.emit(f095F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0966 = new(mem_ctx) ir_if(operand(r095E).val);
               exec_list *const f0966_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0966->then_instructions;

                  ir_variable *const r0967 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0967);
                  ir_expression *const r0968 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0967, add(r0968, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0967, body.constant(0u), 0x01));

                  body.emit(assign(r0959, r0967, 0x03));

                  body.emit(assign(r0958, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0966->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r096A = less(r07F7, body.constant(int(0)));
                  ir_if *f0969 = new(mem_ctx) ir_if(operand(r096A).val);
                  exec_list *const f0969_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0969->then_instructions;

                     ir_variable *const r096B = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r096B, r094C, 0x01));

                     ir_variable *const r096C = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r096C, neg(r07F7), 0x01));

                     ir_variable *const r096D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r096D);
                     ir_variable *const r096E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r096E);
                     ir_variable *const r096F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r096F);
                     ir_variable *const r0970 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0971 = neg(r096C);
                     body.emit(assign(r0970, bit_and(r0971, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0973 = equal(r096C, body.constant(int(0)));
                     ir_if *f0972 = new(mem_ctx) ir_if(operand(r0973).val);
                     exec_list *const f0972_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0972->then_instructions;

                        body.emit(assign(r096D, r094C, 0x01));

                        body.emit(assign(r096E, r094D, 0x01));

                        body.emit(assign(r096F, r094E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0972->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0975 = less(r096C, body.constant(int(32)));
                        ir_if *f0974 = new(mem_ctx) ir_if(operand(r0975).val);
                        exec_list *const f0974_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0974->then_instructions;

                           body.emit(assign(r096D, lshift(r094D, r0970), 0x01));

                           ir_expression *const r0976 = lshift(r094E, r0970);
                           ir_expression *const r0977 = rshift(r094D, r096C);
                           body.emit(assign(r096E, bit_or(r0976, r0977), 0x01));

                           body.emit(assign(r096F, rshift(r094E, r096C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0974->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0979 = equal(r096C, body.constant(int(32)));
                           ir_if *f0978 = new(mem_ctx) ir_if(operand(r0979).val);
                           exec_list *const f0978_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0978->then_instructions;

                              body.emit(assign(r096D, r094D, 0x01));

                              body.emit(assign(r096E, r094E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0978->else_instructions;

                              body.emit(assign(r096B, bit_or(r094C, r094D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r097B = less(r096C, body.constant(int(64)));
                              ir_if *f097A = new(mem_ctx) ir_if(operand(r097B).val);
                              exec_list *const f097A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f097A->then_instructions;

                                 body.emit(assign(r096D, lshift(r094E, r0970), 0x01));

                                 ir_expression *const r097C = bit_and(r096C, body.constant(int(31)));
                                 body.emit(assign(r096E, rshift(r094E, r097C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f097A->else_instructions;

                                 ir_variable *const r097D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r097F = equal(r096C, body.constant(int(64)));
                                 ir_if *f097E = new(mem_ctx) ir_if(operand(r097F).val);
                                 exec_list *const f097E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f097E->then_instructions;

                                    body.emit(assign(r097D, r094E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f097E->else_instructions;

                                    ir_expression *const r0980 = nequal(r094E, body.constant(0u));
                                    ir_expression *const r0981 = expr(ir_unop_b2i, r0980);
                                    body.emit(assign(r097D, expr(ir_unop_i2u, r0981), 0x01));


                                 body.instructions = f097E_parent_instructions;
                                 body.emit(f097E);

                                 /* END IF */

                                 body.emit(assign(r096D, r097D, 0x01));

                                 body.emit(assign(r096E, body.constant(0u), 0x01));


                              body.instructions = f097A_parent_instructions;
                              body.emit(f097A);

                              /* END IF */


                           body.instructions = f0978_parent_instructions;
                           body.emit(f0978);

                           /* END IF */

                           body.emit(assign(r096F, body.constant(0u), 0x01));


                        body.instructions = f0974_parent_instructions;
                        body.emit(f0974);

                        /* END IF */

                        ir_expression *const r0982 = nequal(r096B, body.constant(0u));
                        ir_expression *const r0983 = expr(ir_unop_b2i, r0982);
                        ir_expression *const r0984 = expr(ir_unop_i2u, r0983);
                        body.emit(assign(r096D, bit_or(r096D, r0984), 0x01));


                     body.instructions = f0972_parent_instructions;
                     body.emit(f0972);

                     /* END IF */

                     body.emit(assign(r0955, r096F, 0x01));

                     body.emit(assign(r0956, r096E, 0x01));

                     body.emit(assign(r0957, r096D, 0x01));

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));

                     body.emit(assign(r095A, less(r096D, body.constant(0u)), 0x01));


                  body.instructions = f0969_parent_instructions;
                  body.emit(f0969);

                  /* END IF */


               body.instructions = f0966_parent_instructions;
               body.emit(f0966);

               /* END IF */


            body.instructions = f095C_parent_instructions;
            body.emit(f095C);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0985 = new(mem_ctx) ir_if(operand(r0958).val);
            exec_list *const f0985_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0985->then_instructions;

               /* IF CONDITION */
               ir_if *f0986 = new(mem_ctx) ir_if(operand(r095A).val);
               exec_list *const f0986_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0986->then_instructions;

                  ir_variable *const r0987 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0987, add(r0956, body.constant(1u)), 0x01));

                  ir_expression *const r0988 = less(r0987, r0956);
                  ir_expression *const r0989 = expr(ir_unop_b2i, r0988);
                  ir_expression *const r098A = expr(ir_unop_i2u, r0989);
                  body.emit(assign(r0955, add(r0955, r098A), 0x01));

                  ir_expression *const r098B = equal(r0957, body.constant(0u));
                  ir_expression *const r098C = expr(ir_unop_b2i, r098B);
                  ir_expression *const r098D = expr(ir_unop_i2u, r098C);
                  ir_expression *const r098E = add(r0957, r098D);
                  ir_expression *const r098F = bit_and(r098E, body.constant(1u));
                  ir_expression *const r0990 = expr(ir_unop_bit_not, r098F);
                  body.emit(assign(r0956, bit_and(r0987, r0990), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0986->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0992 = bit_or(r0955, r0956);
                  ir_expression *const r0993 = equal(r0992, body.constant(0u));
                  ir_if *f0991 = new(mem_ctx) ir_if(operand(r0993).val);
                  exec_list *const f0991_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0991->then_instructions;

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));


                  body.instructions = f0991_parent_instructions;
                  body.emit(f0991);

                  /* END IF */


               body.instructions = f0986_parent_instructions;
               body.emit(f0986);

               /* END IF */

               ir_variable *const r0994 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0994);
               ir_expression *const r0995 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0996 = expr(ir_unop_i2u, r0954);
               ir_expression *const r0997 = lshift(r0996, body.constant(int(20)));
               ir_expression *const r0998 = add(r0995, r0997);
               body.emit(assign(r0994, add(r0998, r0955), 0x02));

               body.emit(assign(r0994, r0956, 0x01));

               body.emit(assign(r0959, r0994, 0x03));

               body.emit(assign(r0958, body.constant(false), 0x01));


            body.instructions = f0985_parent_instructions;
            body.emit(f0985);

            /* END IF */

            body.emit(assign(r07F1, r0959, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


         body.instructions = f0905_parent_instructions;
         body.emit(f0905);

         /* END IF */


      body.instructions = f08FE_parent_instructions;
      body.emit(f08FE);

      /* END IF */

      body.emit(assign(r07EB, r07F1, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f07EE->else_instructions;

      ir_variable *const r0999 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0999, r07EC, 0x01));

      ir_variable *const r099A = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r099B = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r099B);
      ir_variable *const r099C = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r099C);
      ir_variable *const r099D = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r099D);
      ir_variable *const r099E = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r099E);
      ir_variable *const r099F = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r099F);
      ir_variable *const r09A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r09A0);
      ir_variable *const r09A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r09A1);
      ir_variable *const r09A2 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r09A2);
      ir_variable *const r09A3 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A4 = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r09A5 = bit_and(r09A4, body.constant(2047u));
      body.emit(assign(r09A3, expr(ir_unop_u2i, r09A5), 0x01));

      body.emit(assign(r099D, r09A3, 0x01));

      ir_variable *const r09A6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A7 = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r09A8 = bit_and(r09A7, body.constant(2047u));
      body.emit(assign(r09A6, expr(ir_unop_u2i, r09A8), 0x01));

      body.emit(assign(r099C, r09A6, 0x01));

      body.emit(assign(r099B, sub(r09A3, r09A6), 0x01));

      ir_variable *const r09A9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09A9, lshift(swizzle_x(r07E9), body.constant(int(10))), 0x01));

      ir_variable *const r09AA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09AB = bit_and(swizzle_y(r07E9), body.constant(1048575u));
      ir_expression *const r09AC = lshift(r09AB, body.constant(int(10)));
      ir_expression *const r09AD = rshift(swizzle_x(r07E9), body.constant(int(22)));
      body.emit(assign(r09AA, bit_or(r09AC, r09AD), 0x01));

      body.emit(assign(r09A0, r09AA, 0x01));

      body.emit(assign(r09A1, r09A9, 0x01));

      ir_variable *const r09AE = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09AE, lshift(swizzle_x(r07EA), body.constant(int(10))), 0x01));

      ir_variable *const r09AF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09B0 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
      ir_expression *const r09B1 = lshift(r09B0, body.constant(int(10)));
      ir_expression *const r09B2 = rshift(swizzle_x(r07EA), body.constant(int(22)));
      body.emit(assign(r09AF, bit_or(r09B1, r09B2), 0x01));

      body.emit(assign(r099E, r09AF, 0x01));

      body.emit(assign(r099F, r09AE, 0x01));

      /* IF CONDITION */
      ir_expression *const r09B4 = less(body.constant(int(0)), r099B);
      ir_if *f09B3 = new(mem_ctx) ir_if(operand(r09B4).val);
      exec_list *const f09B3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f09B3->then_instructions;

         /* IF CONDITION */
         ir_expression *const r09B6 = equal(r09A3, body.constant(int(2047)));
         ir_if *f09B5 = new(mem_ctx) ir_if(operand(r09B6).val);
         exec_list *const f09B5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f09B5->then_instructions;

            /* IF CONDITION */
            ir_expression *const r09B8 = bit_or(r09AA, r09A9);
            ir_expression *const r09B9 = nequal(r09B8, body.constant(0u));
            ir_if *f09B7 = new(mem_ctx) ir_if(operand(r09B9).val);
            exec_list *const f09B7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09B7->then_instructions;

               ir_variable *const r09BA = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r09BA, swizzle_x(r07E9), 0x01));

               ir_variable *const r09BB = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r09BB, swizzle_x(r07EA), 0x01));

               ir_variable *const r09BC = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r09BD = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r09BE = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r09BF = bit_and(r09BE, body.constant(4095u));
               ir_expression *const r09C0 = equal(r09BF, body.constant(4094u));
               ir_expression *const r09C1 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09C2 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r09C3 = nequal(r09C2, body.constant(0u));
               ir_expression *const r09C4 = logic_or(r09C1, r09C3);
               body.emit(assign(r09BD, logic_and(r09C0, r09C4), 0x01));

               ir_variable *const r09C5 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r09C6 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r09C7 = lequal(body.constant(4292870144u), r09C6);
               ir_expression *const r09C8 = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r09C9 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r09CA = nequal(r09C9, body.constant(0u));
               ir_expression *const r09CB = logic_or(r09C8, r09CA);
               body.emit(assign(r09C5, logic_and(r09C7, r09CB), 0x01));

               body.emit(assign(r09BA, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r09BB, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r09CD = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r09CE = lequal(body.constant(4292870144u), r09CD);
               ir_expression *const r09CF = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09D0 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r09D1 = nequal(r09D0, body.constant(0u));
               ir_expression *const r09D2 = logic_or(r09CF, r09D1);
               ir_expression *const r09D3 = logic_and(r09CE, r09D2);
               ir_if *f09CC = new(mem_ctx) ir_if(operand(r09D3).val);
               exec_list *const f09CC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09CC->then_instructions;

                  ir_variable *const r09D4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r09D6 = logic_and(r09BD, r09C5);
                  ir_if *f09D5 = new(mem_ctx) ir_if(operand(r09D6).val);
                  exec_list *const f09D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09D5->then_instructions;

                     body.emit(assign(r09D4, r09BB, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09D5->else_instructions;

                     body.emit(assign(r09D4, r09BA, 0x03));


                  body.instructions = f09D5_parent_instructions;
                  body.emit(f09D5);

                  /* END IF */

                  body.emit(assign(r09BC, r09D4, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09CC->else_instructions;

                  body.emit(assign(r09BC, r09BB, 0x03));


               body.instructions = f09CC_parent_instructions;
               body.emit(f09CC);

               /* END IF */

               body.emit(assign(r099A, r09BC, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09B7->else_instructions;

               body.emit(assign(r099A, r07E9, 0x03));


            body.instructions = f09B7_parent_instructions;
            body.emit(f09B7);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f09B5->else_instructions;

            /* IF CONDITION */
            ir_expression *const r09D8 = equal(r09A6, body.constant(int(0)));
            ir_if *f09D7 = new(mem_ctx) ir_if(operand(r09D8).val);
            exec_list *const f09D7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09D7->then_instructions;

               body.emit(assign(r099B, add(r099B, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09D7->else_instructions;

               body.emit(assign(r099E, bit_or(r09AF, body.constant(1073741824u)), 0x01));


            body.instructions = f09D7_parent_instructions;
            body.emit(f09D7);

            /* END IF */

            ir_variable *const r09D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r09D9);
            ir_variable *const r09DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r09DA);
            ir_variable *const r09DB = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r09DC = neg(r099B);
            body.emit(assign(r09DB, bit_and(r09DC, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r09DE = equal(r099B, body.constant(int(0)));
            ir_if *f09DD = new(mem_ctx) ir_if(operand(r09DE).val);
            exec_list *const f09DD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09DD->then_instructions;

               body.emit(assign(r09D9, r09AE, 0x01));

               body.emit(assign(r09DA, r099E, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09DD->else_instructions;

               /* IF CONDITION */
               ir_expression *const r09E0 = less(r099B, body.constant(int(32)));
               ir_if *f09DF = new(mem_ctx) ir_if(operand(r09E0).val);
               exec_list *const f09DF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09DF->then_instructions;

                  ir_expression *const r09E1 = lshift(r099E, r09DB);
                  ir_expression *const r09E2 = rshift(r09AE, r099B);
                  ir_expression *const r09E3 = bit_or(r09E1, r09E2);
                  ir_expression *const r09E4 = lshift(r09AE, r09DB);
                  ir_expression *const r09E5 = nequal(r09E4, body.constant(0u));
                  ir_expression *const r09E6 = expr(ir_unop_b2i, r09E5);
                  ir_expression *const r09E7 = expr(ir_unop_i2u, r09E6);
                  body.emit(assign(r09D9, bit_or(r09E3, r09E7), 0x01));

                  body.emit(assign(r09DA, rshift(r099E, r099B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09DF->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r09E9 = equal(r099B, body.constant(int(32)));
                  ir_if *f09E8 = new(mem_ctx) ir_if(operand(r09E9).val);
                  exec_list *const f09E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09E8->then_instructions;

                     ir_expression *const r09EA = nequal(r09AE, body.constant(0u));
                     ir_expression *const r09EB = expr(ir_unop_b2i, r09EA);
                     ir_expression *const r09EC = expr(ir_unop_i2u, r09EB);
                     body.emit(assign(r09D9, bit_or(r099E, r09EC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09E8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r09EE = less(r099B, body.constant(int(64)));
                     ir_if *f09ED = new(mem_ctx) ir_if(operand(r09EE).val);
                     exec_list *const f09ED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f09ED->then_instructions;

                        ir_expression *const r09EF = bit_and(r099B, body.constant(int(31)));
                        ir_expression *const r09F0 = rshift(r099E, r09EF);
                        ir_expression *const r09F1 = lshift(r099E, r09DB);
                        ir_expression *const r09F2 = bit_or(r09F1, r09AE);
                        ir_expression *const r09F3 = nequal(r09F2, body.constant(0u));
                        ir_expression *const r09F4 = expr(ir_unop_b2i, r09F3);
                        ir_expression *const r09F5 = expr(ir_unop_i2u, r09F4);
                        body.emit(assign(r09D9, bit_or(r09F0, r09F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f09ED->else_instructions;

                        ir_expression *const r09F6 = bit_or(r099E, r09AE);
                        ir_expression *const r09F7 = nequal(r09F6, body.constant(0u));
                        ir_expression *const r09F8 = expr(ir_unop_b2i, r09F7);
                        body.emit(assign(r09D9, expr(ir_unop_i2u, r09F8), 0x01));


                     body.instructions = f09ED_parent_instructions;
                     body.emit(f09ED);

                     /* END IF */


                  body.instructions = f09E8_parent_instructions;
                  body.emit(f09E8);

                  /* END IF */

                  body.emit(assign(r09DA, body.constant(0u), 0x01));


               body.instructions = f09DF_parent_instructions;
               body.emit(f09DF);

               /* END IF */


            body.instructions = f09DD_parent_instructions;
            body.emit(f09DD);

            /* END IF */

            body.emit(assign(r099E, r09DA, 0x01));

            body.emit(assign(r099F, r09D9, 0x01));

            body.emit(assign(r09A0, bit_or(r09AA, body.constant(1073741824u)), 0x01));

            ir_variable *const r09F9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r09FA = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r09FA, sub(r09A9, r09D9), 0x01));

            ir_expression *const r09FB = sub(r09A0, r09DA);
            ir_expression *const r09FC = less(r09A9, r09D9);
            ir_expression *const r09FD = expr(ir_unop_b2i, r09FC);
            ir_expression *const r09FE = expr(ir_unop_i2u, r09FD);
            body.emit(assign(r09F9, sub(r09FB, r09FE), 0x01));

            body.emit(assign(r09A2, add(r09A3, body.constant(int(-1))), 0x01));

            ir_variable *const r09FF = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r09FF, add(r09A2, body.constant(int(-10))), 0x01));

            ir_variable *const r0A00 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A00, r09F9, 0x01));

            ir_variable *const r0A01 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A01, r09FA, 0x01));

            ir_variable *const r0A02 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0A02);
            ir_variable *const r0A03 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A03);
            /* IF CONDITION */
            ir_expression *const r0A05 = equal(r09F9, body.constant(0u));
            ir_if *f0A04 = new(mem_ctx) ir_if(operand(r0A05).val);
            exec_list *const f0A04_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A04->then_instructions;

               body.emit(assign(r0A00, r09FA, 0x01));

               body.emit(assign(r0A01, body.constant(0u), 0x01));

               body.emit(assign(r09FF, add(r09FF, body.constant(int(-32))), 0x01));


            body.instructions = f0A04_parent_instructions;
            body.emit(f0A04);

            /* END IF */

            ir_variable *const r0A06 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0A06, r0A00, 0x01));

            ir_variable *const r0A07 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0A08 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A08);
            /* IF CONDITION */
            ir_expression *const r0A0A = equal(r0A00, body.constant(0u));
            ir_if *f0A09 = new(mem_ctx) ir_if(operand(r0A0A).val);
            exec_list *const f0A09_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A09->then_instructions;

               body.emit(assign(r0A07, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A09->else_instructions;

               body.emit(assign(r0A08, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A0C = bit_and(r0A00, body.constant(4294901760u));
               ir_expression *const r0A0D = equal(r0A0C, body.constant(0u));
               ir_if *f0A0B = new(mem_ctx) ir_if(operand(r0A0D).val);
               exec_list *const f0A0B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0B->then_instructions;

                  body.emit(assign(r0A08, body.constant(int(16)), 0x01));

                  body.emit(assign(r0A06, lshift(r0A00, body.constant(int(16))), 0x01));


               body.instructions = f0A0B_parent_instructions;
               body.emit(f0A0B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A0F = bit_and(r0A06, body.constant(4278190080u));
               ir_expression *const r0A10 = equal(r0A0F, body.constant(0u));
               ir_if *f0A0E = new(mem_ctx) ir_if(operand(r0A10).val);
               exec_list *const f0A0E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0E->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(8))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(8))), 0x01));


               body.instructions = f0A0E_parent_instructions;
               body.emit(f0A0E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A12 = bit_and(r0A06, body.constant(4026531840u));
               ir_expression *const r0A13 = equal(r0A12, body.constant(0u));
               ir_if *f0A11 = new(mem_ctx) ir_if(operand(r0A13).val);
               exec_list *const f0A11_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A11->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(4))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(4))), 0x01));


               body.instructions = f0A11_parent_instructions;
               body.emit(f0A11);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A15 = bit_and(r0A06, body.constant(3221225472u));
               ir_expression *const r0A16 = equal(r0A15, body.constant(0u));
               ir_if *f0A14 = new(mem_ctx) ir_if(operand(r0A16).val);
               exec_list *const f0A14_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A14->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(2))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(2))), 0x01));


               body.instructions = f0A14_parent_instructions;
               body.emit(f0A14);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A18 = bit_and(r0A06, body.constant(2147483648u));
               ir_expression *const r0A19 = equal(r0A18, body.constant(0u));
               ir_if *f0A17 = new(mem_ctx) ir_if(operand(r0A19).val);
               exec_list *const f0A17_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A17->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(1))), 0x01));


               body.instructions = f0A17_parent_instructions;
               body.emit(f0A17);

               /* END IF */

               body.emit(assign(r0A07, r0A08, 0x01));


            body.instructions = f0A09_parent_instructions;
            body.emit(f0A09);

            /* END IF */

            body.emit(assign(r0A03, add(r0A07, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A1B = lequal(body.constant(int(0)), r0A03);
            ir_if *f0A1A = new(mem_ctx) ir_if(operand(r0A1B).val);
            exec_list *const f0A1A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A1A->then_instructions;

               body.emit(assign(r0A02, body.constant(0u), 0x01));

               ir_variable *const r0A1C = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0A1C, lshift(r0A01, r0A03), 0x01));

               ir_variable *const r0A1D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0A1F = equal(r0A03, body.constant(int(0)));
               ir_if *f0A1E = new(mem_ctx) ir_if(operand(r0A1F).val);
               exec_list *const f0A1E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A1E->then_instructions;

                  body.emit(assign(r0A1D, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A1E->else_instructions;

                  ir_expression *const r0A20 = lshift(r0A00, r0A03);
                  ir_expression *const r0A21 = neg(r0A03);
                  ir_expression *const r0A22 = bit_and(r0A21, body.constant(int(31)));
                  ir_expression *const r0A23 = rshift(r0A01, r0A22);
                  body.emit(assign(r0A1D, bit_or(r0A20, r0A23), 0x01));


               body.instructions = f0A1E_parent_instructions;
               body.emit(f0A1E);

               /* END IF */

               body.emit(assign(r0A00, r0A1D, 0x01));

               body.emit(assign(r0A01, r0A1C, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A1A->else_instructions;

               ir_variable *const r0A24 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0A24, body.constant(0u), 0x01));

               ir_variable *const r0A25 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0A25, neg(r0A03), 0x01));

               ir_variable *const r0A26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0A26);
               ir_variable *const r0A27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0A27);
               ir_variable *const r0A28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0A28);
               ir_variable *const r0A29 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0A2A = neg(r0A25);
               body.emit(assign(r0A29, bit_and(r0A2A, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A2C = equal(r0A25, body.constant(int(0)));
               ir_if *f0A2B = new(mem_ctx) ir_if(operand(r0A2C).val);
               exec_list *const f0A2B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A2B->then_instructions;

                  body.emit(assign(r0A26, r0A24, 0x01));

                  body.emit(assign(r0A27, r0A01, 0x01));

                  body.emit(assign(r0A28, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A2B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A2E = less(r0A25, body.constant(int(32)));
                  ir_if *f0A2D = new(mem_ctx) ir_if(operand(r0A2E).val);
                  exec_list *const f0A2D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A2D->then_instructions;

                     body.emit(assign(r0A26, lshift(r0A01, r0A29), 0x01));

                     ir_expression *const r0A2F = lshift(r0A00, r0A29);
                     ir_expression *const r0A30 = rshift(r0A01, r0A25);
                     body.emit(assign(r0A27, bit_or(r0A2F, r0A30), 0x01));

                     body.emit(assign(r0A28, rshift(r0A00, r0A25), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A2D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0A32 = equal(r0A25, body.constant(int(32)));
                     ir_if *f0A31 = new(mem_ctx) ir_if(operand(r0A32).val);
                     exec_list *const f0A31_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A31->then_instructions;

                        body.emit(assign(r0A26, r0A01, 0x01));

                        body.emit(assign(r0A27, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A31->else_instructions;

                        body.emit(assign(r0A24, bit_or(body.constant(0u), r0A01), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0A34 = less(r0A25, body.constant(int(64)));
                        ir_if *f0A33 = new(mem_ctx) ir_if(operand(r0A34).val);
                        exec_list *const f0A33_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A33->then_instructions;

                           body.emit(assign(r0A26, lshift(r0A00, r0A29), 0x01));

                           ir_expression *const r0A35 = bit_and(r0A25, body.constant(int(31)));
                           body.emit(assign(r0A27, rshift(r0A00, r0A35), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A33->else_instructions;

                           ir_variable *const r0A36 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0A38 = equal(r0A25, body.constant(int(64)));
                           ir_if *f0A37 = new(mem_ctx) ir_if(operand(r0A38).val);
                           exec_list *const f0A37_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A37->then_instructions;

                              body.emit(assign(r0A36, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A37->else_instructions;

                              ir_expression *const r0A39 = nequal(r0A00, body.constant(0u));
                              ir_expression *const r0A3A = expr(ir_unop_b2i, r0A39);
                              body.emit(assign(r0A36, expr(ir_unop_i2u, r0A3A), 0x01));


                           body.instructions = f0A37_parent_instructions;
                           body.emit(f0A37);

                           /* END IF */

                           body.emit(assign(r0A26, r0A36, 0x01));

                           body.emit(assign(r0A27, body.constant(0u), 0x01));


                        body.instructions = f0A33_parent_instructions;
                        body.emit(f0A33);

                        /* END IF */


                     body.instructions = f0A31_parent_instructions;
                     body.emit(f0A31);

                     /* END IF */

                     body.emit(assign(r0A28, body.constant(0u), 0x01));


                  body.instructions = f0A2D_parent_instructions;
                  body.emit(f0A2D);

                  /* END IF */

                  ir_expression *const r0A3B = nequal(r0A24, body.constant(0u));
                  ir_expression *const r0A3C = expr(ir_unop_b2i, r0A3B);
                  ir_expression *const r0A3D = expr(ir_unop_i2u, r0A3C);
                  body.emit(assign(r0A26, bit_or(r0A26, r0A3D), 0x01));


               body.instructions = f0A2B_parent_instructions;
               body.emit(f0A2B);

               /* END IF */

               body.emit(assign(r0A00, r0A28, 0x01));

               body.emit(assign(r0A01, r0A27, 0x01));

               body.emit(assign(r0A02, r0A26, 0x01));


            body.instructions = f0A1A_parent_instructions;
            body.emit(f0A1A);

            /* END IF */

            body.emit(assign(r09FF, sub(r09FF, r0A03), 0x01));

            ir_variable *const r0A3E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0A3E, r09FF, 0x01));

            ir_variable *const r0A3F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A3F, r0A00, 0x01));

            ir_variable *const r0A40 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A40, r0A01, 0x01));

            ir_variable *const r0A41 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0A41, r0A02, 0x01));

            ir_variable *const r0A42 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0A42, body.constant(true), 0x01));

            ir_variable *const r0A43 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0A44 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0A44);
            ir_expression *const r0A45 = expr(ir_unop_u2i, r0A02);
            body.emit(assign(r0A44, less(r0A45, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A47 = lequal(body.constant(int(2045)), r09FF);
            ir_if *f0A46 = new(mem_ctx) ir_if(operand(r0A47).val);
            exec_list *const f0A46_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A46->then_instructions;

               ir_variable *const r0A48 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0A4A = less(body.constant(int(2045)), r09FF);
               ir_if *f0A49 = new(mem_ctx) ir_if(operand(r0A4A).val);
               exec_list *const f0A49_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A49->then_instructions;

                  body.emit(assign(r0A48, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A49->else_instructions;

                  ir_variable *const r0A4B = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0A4D = equal(r09FF, body.constant(int(2045)));
                  ir_if *f0A4C = new(mem_ctx) ir_if(operand(r0A4D).val);
                  exec_list *const f0A4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A4C->then_instructions;

                     ir_expression *const r0A4E = equal(body.constant(2097151u), r0A00);
                     ir_expression *const r0A4F = equal(body.constant(4294967295u), r0A01);
                     body.emit(assign(r0A4B, logic_and(r0A4E, r0A4F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A4C->else_instructions;

                     body.emit(assign(r0A4B, body.constant(false), 0x01));


                  body.instructions = f0A4C_parent_instructions;
                  body.emit(f0A4C);

                  /* END IF */

                  body.emit(assign(r0A48, logic_and(r0A4B, r0A44), 0x01));


               body.instructions = f0A49_parent_instructions;
               body.emit(f0A49);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0A50 = new(mem_ctx) ir_if(operand(r0A48).val);
               exec_list *const f0A50_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A50->then_instructions;

                  ir_variable *const r0A51 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0A51);
                  ir_expression *const r0A52 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0A51, add(r0A52, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0A51, body.constant(0u), 0x01));

                  body.emit(assign(r0A43, r0A51, 0x03));

                  body.emit(assign(r0A42, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A50->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A54 = less(r09FF, body.constant(int(0)));
                  ir_if *f0A53 = new(mem_ctx) ir_if(operand(r0A54).val);
                  exec_list *const f0A53_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A53->then_instructions;

                     ir_variable *const r0A55 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0A55, r0A02, 0x01));

                     ir_variable *const r0A56 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0A56, neg(r09FF), 0x01));

                     ir_variable *const r0A57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0A57);
                     ir_variable *const r0A58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0A58);
                     ir_variable *const r0A59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0A59);
                     ir_variable *const r0A5A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0A5B = neg(r0A56);
                     body.emit(assign(r0A5A, bit_and(r0A5B, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0A5D = equal(r0A56, body.constant(int(0)));
                     ir_if *f0A5C = new(mem_ctx) ir_if(operand(r0A5D).val);
                     exec_list *const f0A5C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A5C->then_instructions;

                        body.emit(assign(r0A57, r0A02, 0x01));

                        body.emit(assign(r0A58, r0A01, 0x01));

                        body.emit(assign(r0A59, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A5C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0A5F = less(r0A56, body.constant(int(32)));
                        ir_if *f0A5E = new(mem_ctx) ir_if(operand(r0A5F).val);
                        exec_list *const f0A5E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A5E->then_instructions;

                           body.emit(assign(r0A57, lshift(r0A01, r0A5A), 0x01));

                           ir_expression *const r0A60 = lshift(r0A00, r0A5A);
                           ir_expression *const r0A61 = rshift(r0A01, r0A56);
                           body.emit(assign(r0A58, bit_or(r0A60, r0A61), 0x01));

                           body.emit(assign(r0A59, rshift(r0A00, r0A56), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A5E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0A63 = equal(r0A56, body.constant(int(32)));
                           ir_if *f0A62 = new(mem_ctx) ir_if(operand(r0A63).val);
                           exec_list *const f0A62_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A62->then_instructions;

                              body.emit(assign(r0A57, r0A01, 0x01));

                              body.emit(assign(r0A58, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A62->else_instructions;

                              body.emit(assign(r0A55, bit_or(r0A02, r0A01), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0A65 = less(r0A56, body.constant(int(64)));
                              ir_if *f0A64 = new(mem_ctx) ir_if(operand(r0A65).val);
                              exec_list *const f0A64_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0A64->then_instructions;

                                 body.emit(assign(r0A57, lshift(r0A00, r0A5A), 0x01));

                                 ir_expression *const r0A66 = bit_and(r0A56, body.constant(int(31)));
                                 body.emit(assign(r0A58, rshift(r0A00, r0A66), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0A64->else_instructions;

                                 ir_variable *const r0A67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0A69 = equal(r0A56, body.constant(int(64)));
                                 ir_if *f0A68 = new(mem_ctx) ir_if(operand(r0A69).val);
                                 exec_list *const f0A68_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0A68->then_instructions;

                                    body.emit(assign(r0A67, r0A00, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0A68->else_instructions;

                                    ir_expression *const r0A6A = nequal(r0A00, body.constant(0u));
                                    ir_expression *const r0A6B = expr(ir_unop_b2i, r0A6A);
                                    body.emit(assign(r0A67, expr(ir_unop_i2u, r0A6B), 0x01));


                                 body.instructions = f0A68_parent_instructions;
                                 body.emit(f0A68);

                                 /* END IF */

                                 body.emit(assign(r0A57, r0A67, 0x01));

                                 body.emit(assign(r0A58, body.constant(0u), 0x01));


                              body.instructions = f0A64_parent_instructions;
                              body.emit(f0A64);

                              /* END IF */


                           body.instructions = f0A62_parent_instructions;
                           body.emit(f0A62);

                           /* END IF */

                           body.emit(assign(r0A59, body.constant(0u), 0x01));


                        body.instructions = f0A5E_parent_instructions;
                        body.emit(f0A5E);

                        /* END IF */

                        ir_expression *const r0A6C = nequal(r0A55, body.constant(0u));
                        ir_expression *const r0A6D = expr(ir_unop_b2i, r0A6C);
                        ir_expression *const r0A6E = expr(ir_unop_i2u, r0A6D);
                        body.emit(assign(r0A57, bit_or(r0A57, r0A6E), 0x01));


                     body.instructions = f0A5C_parent_instructions;
                     body.emit(f0A5C);

                     /* END IF */

                     body.emit(assign(r0A3F, r0A59, 0x01));

                     body.emit(assign(r0A40, r0A58, 0x01));

                     body.emit(assign(r0A41, r0A57, 0x01));

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));

                     body.emit(assign(r0A44, less(r0A57, body.constant(0u)), 0x01));


                  body.instructions = f0A53_parent_instructions;
                  body.emit(f0A53);

                  /* END IF */


               body.instructions = f0A50_parent_instructions;
               body.emit(f0A50);

               /* END IF */


            body.instructions = f0A46_parent_instructions;
            body.emit(f0A46);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0A6F = new(mem_ctx) ir_if(operand(r0A42).val);
            exec_list *const f0A6F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A6F->then_instructions;

               /* IF CONDITION */
               ir_if *f0A70 = new(mem_ctx) ir_if(operand(r0A44).val);
               exec_list *const f0A70_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A70->then_instructions;

                  ir_variable *const r0A71 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0A71, add(r0A40, body.constant(1u)), 0x01));

                  ir_expression *const r0A72 = less(r0A71, r0A40);
                  ir_expression *const r0A73 = expr(ir_unop_b2i, r0A72);
                  ir_expression *const r0A74 = expr(ir_unop_i2u, r0A73);
                  body.emit(assign(r0A3F, add(r0A3F, r0A74), 0x01));

                  ir_expression *const r0A75 = equal(r0A41, body.constant(0u));
                  ir_expression *const r0A76 = expr(ir_unop_b2i, r0A75);
                  ir_expression *const r0A77 = expr(ir_unop_i2u, r0A76);
                  ir_expression *const r0A78 = add(r0A41, r0A77);
                  ir_expression *const r0A79 = bit_and(r0A78, body.constant(1u));
                  ir_expression *const r0A7A = expr(ir_unop_bit_not, r0A79);
                  body.emit(assign(r0A40, bit_and(r0A71, r0A7A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A70->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A7C = bit_or(r0A3F, r0A40);
                  ir_expression *const r0A7D = equal(r0A7C, body.constant(0u));
                  ir_if *f0A7B = new(mem_ctx) ir_if(operand(r0A7D).val);
                  exec_list *const f0A7B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A7B->then_instructions;

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));


                  body.instructions = f0A7B_parent_instructions;
                  body.emit(f0A7B);

                  /* END IF */


               body.instructions = f0A70_parent_instructions;
               body.emit(f0A70);

               /* END IF */

               ir_variable *const r0A7E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0A7E);
               ir_expression *const r0A7F = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0A80 = expr(ir_unop_i2u, r0A3E);
               ir_expression *const r0A81 = lshift(r0A80, body.constant(int(20)));
               ir_expression *const r0A82 = add(r0A7F, r0A81);
               body.emit(assign(r0A7E, add(r0A82, r0A3F), 0x02));

               body.emit(assign(r0A7E, r0A40, 0x01));

               body.emit(assign(r0A43, r0A7E, 0x03));

               body.emit(assign(r0A42, body.constant(false), 0x01));


            body.instructions = f0A6F_parent_instructions;
            body.emit(f0A6F);

            /* END IF */

            body.emit(assign(r099A, r0A43, 0x03));


         body.instructions = f09B5_parent_instructions;
         body.emit(f09B5);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f09B3->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0A84 = less(r099B, body.constant(int(0)));
         ir_if *f0A83 = new(mem_ctx) ir_if(operand(r0A84).val);
         exec_list *const f0A83_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0A83->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0A86 = equal(r09A6, body.constant(int(2047)));
            ir_if *f0A85 = new(mem_ctx) ir_if(operand(r0A86).val);
            exec_list *const f0A85_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A85->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0A88 = bit_or(r099E, r099F);
               ir_expression *const r0A89 = nequal(r0A88, body.constant(0u));
               ir_if *f0A87 = new(mem_ctx) ir_if(operand(r0A89).val);
               exec_list *const f0A87_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A87->then_instructions;

                  ir_variable *const r0A8A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0A8A, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0A8B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0A8B, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0A8C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0A8D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0A8E = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0A8F = bit_and(r0A8E, body.constant(4095u));
                  ir_expression *const r0A90 = equal(r0A8F, body.constant(4094u));
                  ir_expression *const r0A91 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0A92 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0A93 = nequal(r0A92, body.constant(0u));
                  ir_expression *const r0A94 = logic_or(r0A91, r0A93);
                  body.emit(assign(r0A8D, logic_and(r0A90, r0A94), 0x01));

                  ir_variable *const r0A95 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0A96 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0A97 = lequal(body.constant(4292870144u), r0A96);
                  ir_expression *const r0A98 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0A99 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0A9A = nequal(r0A99, body.constant(0u));
                  ir_expression *const r0A9B = logic_or(r0A98, r0A9A);
                  body.emit(assign(r0A95, logic_and(r0A97, r0A9B), 0x01));

                  body.emit(assign(r0A8A, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0A8B, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0A9D = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0A9E = lequal(body.constant(4292870144u), r0A9D);
                  ir_expression *const r0A9F = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0AA0 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0AA1 = nequal(r0AA0, body.constant(0u));
                  ir_expression *const r0AA2 = logic_or(r0A9F, r0AA1);
                  ir_expression *const r0AA3 = logic_and(r0A9E, r0AA2);
                  ir_if *f0A9C = new(mem_ctx) ir_if(operand(r0AA3).val);
                  exec_list *const f0A9C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A9C->then_instructions;

                     ir_variable *const r0AA4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0AA6 = logic_and(r0A8D, r0A95);
                     ir_if *f0AA5 = new(mem_ctx) ir_if(operand(r0AA6).val);
                     exec_list *const f0AA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0AA5->then_instructions;

                        body.emit(assign(r0AA4, r0A8B, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0AA5->else_instructions;

                        body.emit(assign(r0AA4, r0A8A, 0x03));


                     body.instructions = f0AA5_parent_instructions;
                     body.emit(f0AA5);

                     /* END IF */

                     body.emit(assign(r0A8C, r0AA4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A9C->else_instructions;

                     body.emit(assign(r0A8C, r0A8B, 0x03));


                  body.instructions = f0A9C_parent_instructions;
                  body.emit(f0A9C);

                  /* END IF */

                  body.emit(assign(r099A, r0A8C, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A87->else_instructions;

                  ir_variable *const r0AA7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0AA7);
                  ir_expression *const r0AA8 = bit_xor(r07EC, body.constant(1u));
                  ir_expression *const r0AA9 = lshift(r0AA8, body.constant(int(31)));
                  body.emit(assign(r0AA7, add(r0AA9, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0AA7, body.constant(0u), 0x01));

                  body.emit(assign(r099A, r0AA7, 0x03));


               body.instructions = f0A87_parent_instructions;
               body.emit(f0A87);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A85->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0AAB = equal(r09A3, body.constant(int(0)));
               ir_if *f0AAA = new(mem_ctx) ir_if(operand(r0AAB).val);
               exec_list *const f0AAA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AAA->then_instructions;

                  body.emit(assign(r099B, add(r099B, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AAA->else_instructions;

                  body.emit(assign(r09A0, bit_or(r09A0, body.constant(1073741824u)), 0x01));


               body.instructions = f0AAA_parent_instructions;
               body.emit(f0AAA);

               /* END IF */

               ir_variable *const r0AAC = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0AAC, neg(r099B), 0x01));

               ir_variable *const r0AAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0AAD);
               ir_variable *const r0AAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0AAE);
               ir_variable *const r0AAF = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0AB0 = neg(r0AAC);
               body.emit(assign(r0AAF, bit_and(r0AB0, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AB2 = equal(r0AAC, body.constant(int(0)));
               ir_if *f0AB1 = new(mem_ctx) ir_if(operand(r0AB2).val);
               exec_list *const f0AB1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AB1->then_instructions;

                  body.emit(assign(r0AAD, r09A9, 0x01));

                  body.emit(assign(r0AAE, r09A0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AB1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0AB4 = less(r0AAC, body.constant(int(32)));
                  ir_if *f0AB3 = new(mem_ctx) ir_if(operand(r0AB4).val);
                  exec_list *const f0AB3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AB3->then_instructions;

                     ir_expression *const r0AB5 = lshift(r09A0, r0AAF);
                     ir_expression *const r0AB6 = rshift(r09A9, r0AAC);
                     ir_expression *const r0AB7 = bit_or(r0AB5, r0AB6);
                     ir_expression *const r0AB8 = lshift(r09A9, r0AAF);
                     ir_expression *const r0AB9 = nequal(r0AB8, body.constant(0u));
                     ir_expression *const r0ABA = expr(ir_unop_b2i, r0AB9);
                     ir_expression *const r0ABB = expr(ir_unop_i2u, r0ABA);
                     body.emit(assign(r0AAD, bit_or(r0AB7, r0ABB), 0x01));

                     body.emit(assign(r0AAE, rshift(r09A0, r0AAC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AB3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0ABD = equal(r0AAC, body.constant(int(32)));
                     ir_if *f0ABC = new(mem_ctx) ir_if(operand(r0ABD).val);
                     exec_list *const f0ABC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0ABC->then_instructions;

                        ir_expression *const r0ABE = nequal(r09A9, body.constant(0u));
                        ir_expression *const r0ABF = expr(ir_unop_b2i, r0ABE);
                        ir_expression *const r0AC0 = expr(ir_unop_i2u, r0ABF);
                        body.emit(assign(r0AAD, bit_or(r09A0, r0AC0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0ABC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0AC2 = less(r0AAC, body.constant(int(64)));
                        ir_if *f0AC1 = new(mem_ctx) ir_if(operand(r0AC2).val);
                        exec_list *const f0AC1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0AC1->then_instructions;

                           ir_expression *const r0AC3 = bit_and(r0AAC, body.constant(int(31)));
                           ir_expression *const r0AC4 = rshift(r09A0, r0AC3);
                           ir_expression *const r0AC5 = lshift(r09A0, r0AAF);
                           ir_expression *const r0AC6 = bit_or(r0AC5, r09A9);
                           ir_expression *const r0AC7 = nequal(r0AC6, body.constant(0u));
                           ir_expression *const r0AC8 = expr(ir_unop_b2i, r0AC7);
                           ir_expression *const r0AC9 = expr(ir_unop_i2u, r0AC8);
                           body.emit(assign(r0AAD, bit_or(r0AC4, r0AC9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0AC1->else_instructions;

                           ir_expression *const r0ACA = bit_or(r09A0, r09A9);
                           ir_expression *const r0ACB = nequal(r0ACA, body.constant(0u));
                           ir_expression *const r0ACC = expr(ir_unop_b2i, r0ACB);
                           body.emit(assign(r0AAD, expr(ir_unop_i2u, r0ACC), 0x01));


                        body.instructions = f0AC1_parent_instructions;
                        body.emit(f0AC1);

                        /* END IF */


                     body.instructions = f0ABC_parent_instructions;
                     body.emit(f0ABC);

                     /* END IF */

                     body.emit(assign(r0AAE, body.constant(0u), 0x01));


                  body.instructions = f0AB3_parent_instructions;
                  body.emit(f0AB3);

                  /* END IF */


               body.instructions = f0AB1_parent_instructions;
               body.emit(f0AB1);

               /* END IF */

               body.emit(assign(r09A0, r0AAE, 0x01));

               body.emit(assign(r09A1, r0AAD, 0x01));

               body.emit(assign(r099E, bit_or(r099E, body.constant(1073741824u)), 0x01));

               ir_variable *const r0ACD = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0ACE = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0ACE, sub(r099F, r0AAD), 0x01));

               ir_expression *const r0ACF = sub(r099E, r0AAE);
               ir_expression *const r0AD0 = less(r099F, r0AAD);
               ir_expression *const r0AD1 = expr(ir_unop_b2i, r0AD0);
               ir_expression *const r0AD2 = expr(ir_unop_i2u, r0AD1);
               body.emit(assign(r0ACD, sub(r0ACF, r0AD2), 0x01));

               body.emit(assign(r0999, bit_xor(r07EC, body.constant(1u)), 0x01));

               body.emit(assign(r09A2, add(r09A6, body.constant(int(-1))), 0x01));

               ir_variable *const r0AD3 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0AD3, add(r09A2, body.constant(int(-10))), 0x01));

               ir_variable *const r0AD4 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0AD4, r0ACD, 0x01));

               ir_variable *const r0AD5 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0AD5, r0ACE, 0x01));

               ir_variable *const r0AD6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0AD6);
               ir_variable *const r0AD7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0AD7);
               /* IF CONDITION */
               ir_expression *const r0AD9 = equal(r0ACD, body.constant(0u));
               ir_if *f0AD8 = new(mem_ctx) ir_if(operand(r0AD9).val);
               exec_list *const f0AD8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AD8->then_instructions;

                  body.emit(assign(r0AD4, r0ACE, 0x01));

                  body.emit(assign(r0AD5, body.constant(0u), 0x01));

                  body.emit(assign(r0AD3, add(r0AD3, body.constant(int(-32))), 0x01));


               body.instructions = f0AD8_parent_instructions;
               body.emit(f0AD8);

               /* END IF */

               ir_variable *const r0ADA = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0ADA, r0AD4, 0x01));

               ir_variable *const r0ADB = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0ADC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0ADC);
               /* IF CONDITION */
               ir_expression *const r0ADE = equal(r0AD4, body.constant(0u));
               ir_if *f0ADD = new(mem_ctx) ir_if(operand(r0ADE).val);
               exec_list *const f0ADD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ADD->then_instructions;

                  body.emit(assign(r0ADB, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ADD->else_instructions;

                  body.emit(assign(r0ADC, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0AE0 = bit_and(r0AD4, body.constant(4294901760u));
                  ir_expression *const r0AE1 = equal(r0AE0, body.constant(0u));
                  ir_if *f0ADF = new(mem_ctx) ir_if(operand(r0AE1).val);
                  exec_list *const f0ADF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0ADF->then_instructions;

                     body.emit(assign(r0ADC, body.constant(int(16)), 0x01));

                     body.emit(assign(r0ADA, lshift(r0AD4, body.constant(int(16))), 0x01));


                  body.instructions = f0ADF_parent_instructions;
                  body.emit(f0ADF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE3 = bit_and(r0ADA, body.constant(4278190080u));
                  ir_expression *const r0AE4 = equal(r0AE3, body.constant(0u));
                  ir_if *f0AE2 = new(mem_ctx) ir_if(operand(r0AE4).val);
                  exec_list *const f0AE2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE2->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(8))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(8))), 0x01));


                  body.instructions = f0AE2_parent_instructions;
                  body.emit(f0AE2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE6 = bit_and(r0ADA, body.constant(4026531840u));
                  ir_expression *const r0AE7 = equal(r0AE6, body.constant(0u));
                  ir_if *f0AE5 = new(mem_ctx) ir_if(operand(r0AE7).val);
                  exec_list *const f0AE5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE5->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(4))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(4))), 0x01));


                  body.instructions = f0AE5_parent_instructions;
                  body.emit(f0AE5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE9 = bit_and(r0ADA, body.constant(3221225472u));
                  ir_expression *const r0AEA = equal(r0AE9, body.constant(0u));
                  ir_if *f0AE8 = new(mem_ctx) ir_if(operand(r0AEA).val);
                  exec_list *const f0AE8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE8->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(2))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(2))), 0x01));


                  body.instructions = f0AE8_parent_instructions;
                  body.emit(f0AE8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AEC = bit_and(r0ADA, body.constant(2147483648u));
                  ir_expression *const r0AED = equal(r0AEC, body.constant(0u));
                  ir_if *f0AEB = new(mem_ctx) ir_if(operand(r0AED).val);
                  exec_list *const f0AEB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AEB->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(1))), 0x01));


                  body.instructions = f0AEB_parent_instructions;
                  body.emit(f0AEB);

                  /* END IF */

                  body.emit(assign(r0ADB, r0ADC, 0x01));


               body.instructions = f0ADD_parent_instructions;
               body.emit(f0ADD);

               /* END IF */

               body.emit(assign(r0AD7, add(r0ADB, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AEF = lequal(body.constant(int(0)), r0AD7);
               ir_if *f0AEE = new(mem_ctx) ir_if(operand(r0AEF).val);
               exec_list *const f0AEE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AEE->then_instructions;

                  body.emit(assign(r0AD6, body.constant(0u), 0x01));

                  ir_variable *const r0AF0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0AF0, lshift(r0AD5, r0AD7), 0x01));

                  ir_variable *const r0AF1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0AF3 = equal(r0AD7, body.constant(int(0)));
                  ir_if *f0AF2 = new(mem_ctx) ir_if(operand(r0AF3).val);
                  exec_list *const f0AF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AF2->then_instructions;

                     body.emit(assign(r0AF1, r0AD4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AF2->else_instructions;

                     ir_expression *const r0AF4 = lshift(r0AD4, r0AD7);
                     ir_expression *const r0AF5 = neg(r0AD7);
                     ir_expression *const r0AF6 = bit_and(r0AF5, body.constant(int(31)));
                     ir_expression *const r0AF7 = rshift(r0AD5, r0AF6);
                     body.emit(assign(r0AF1, bit_or(r0AF4, r0AF7), 0x01));


                  body.instructions = f0AF2_parent_instructions;
                  body.emit(f0AF2);

                  /* END IF */

                  body.emit(assign(r0AD4, r0AF1, 0x01));

                  body.emit(assign(r0AD5, r0AF0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AEE->else_instructions;

                  ir_variable *const r0AF8 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0AF8, body.constant(0u), 0x01));

                  ir_variable *const r0AF9 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0AF9, neg(r0AD7), 0x01));

                  ir_variable *const r0AFA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0AFA);
                  ir_variable *const r0AFB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0AFB);
                  ir_variable *const r0AFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0AFC);
                  ir_variable *const r0AFD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0AFE = neg(r0AF9);
                  body.emit(assign(r0AFD, bit_and(r0AFE, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0B00 = equal(r0AF9, body.constant(int(0)));
                  ir_if *f0AFF = new(mem_ctx) ir_if(operand(r0B00).val);
                  exec_list *const f0AFF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AFF->then_instructions;

                     body.emit(assign(r0AFA, r0AF8, 0x01));

                     body.emit(assign(r0AFB, r0AD5, 0x01));

                     body.emit(assign(r0AFC, r0AD4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AFF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B02 = less(r0AF9, body.constant(int(32)));
                     ir_if *f0B01 = new(mem_ctx) ir_if(operand(r0B02).val);
                     exec_list *const f0B01_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B01->then_instructions;

                        body.emit(assign(r0AFA, lshift(r0AD5, r0AFD), 0x01));

                        ir_expression *const r0B03 = lshift(r0AD4, r0AFD);
                        ir_expression *const r0B04 = rshift(r0AD5, r0AF9);
                        body.emit(assign(r0AFB, bit_or(r0B03, r0B04), 0x01));

                        body.emit(assign(r0AFC, rshift(r0AD4, r0AF9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B01->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0B06 = equal(r0AF9, body.constant(int(32)));
                        ir_if *f0B05 = new(mem_ctx) ir_if(operand(r0B06).val);
                        exec_list *const f0B05_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B05->then_instructions;

                           body.emit(assign(r0AFA, r0AD5, 0x01));

                           body.emit(assign(r0AFB, r0AD4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B05->else_instructions;

                           body.emit(assign(r0AF8, bit_or(body.constant(0u), r0AD5), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0B08 = less(r0AF9, body.constant(int(64)));
                           ir_if *f0B07 = new(mem_ctx) ir_if(operand(r0B08).val);
                           exec_list *const f0B07_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B07->then_instructions;

                              body.emit(assign(r0AFA, lshift(r0AD4, r0AFD), 0x01));

                              ir_expression *const r0B09 = bit_and(r0AF9, body.constant(int(31)));
                              body.emit(assign(r0AFB, rshift(r0AD4, r0B09), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B07->else_instructions;

                              ir_variable *const r0B0A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0B0C = equal(r0AF9, body.constant(int(64)));
                              ir_if *f0B0B = new(mem_ctx) ir_if(operand(r0B0C).val);
                              exec_list *const f0B0B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B0B->then_instructions;

                                 body.emit(assign(r0B0A, r0AD4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B0B->else_instructions;

                                 ir_expression *const r0B0D = nequal(r0AD4, body.constant(0u));
                                 ir_expression *const r0B0E = expr(ir_unop_b2i, r0B0D);
                                 body.emit(assign(r0B0A, expr(ir_unop_i2u, r0B0E), 0x01));


                              body.instructions = f0B0B_parent_instructions;
                              body.emit(f0B0B);

                              /* END IF */

                              body.emit(assign(r0AFA, r0B0A, 0x01));

                              body.emit(assign(r0AFB, body.constant(0u), 0x01));


                           body.instructions = f0B07_parent_instructions;
                           body.emit(f0B07);

                           /* END IF */


                        body.instructions = f0B05_parent_instructions;
                        body.emit(f0B05);

                        /* END IF */

                        body.emit(assign(r0AFC, body.constant(0u), 0x01));


                     body.instructions = f0B01_parent_instructions;
                     body.emit(f0B01);

                     /* END IF */

                     ir_expression *const r0B0F = nequal(r0AF8, body.constant(0u));
                     ir_expression *const r0B10 = expr(ir_unop_b2i, r0B0F);
                     ir_expression *const r0B11 = expr(ir_unop_i2u, r0B10);
                     body.emit(assign(r0AFA, bit_or(r0AFA, r0B11), 0x01));


                  body.instructions = f0AFF_parent_instructions;
                  body.emit(f0AFF);

                  /* END IF */

                  body.emit(assign(r0AD4, r0AFC, 0x01));

                  body.emit(assign(r0AD5, r0AFB, 0x01));

                  body.emit(assign(r0AD6, r0AFA, 0x01));


               body.instructions = f0AEE_parent_instructions;
               body.emit(f0AEE);

               /* END IF */

               body.emit(assign(r0AD3, sub(r0AD3, r0AD7), 0x01));

               ir_variable *const r0B12 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0B12, r0AD3, 0x01));

               ir_variable *const r0B13 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0B13, r0AD4, 0x01));

               ir_variable *const r0B14 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0B14, r0AD5, 0x01));

               ir_variable *const r0B15 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0B15, r0AD6, 0x01));

               ir_variable *const r0B16 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0B16, body.constant(true), 0x01));

               ir_variable *const r0B17 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0B18 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0B18);
               ir_expression *const r0B19 = expr(ir_unop_u2i, r0AD6);
               body.emit(assign(r0B18, less(r0B19, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0B1B = lequal(body.constant(int(2045)), r0AD3);
               ir_if *f0B1A = new(mem_ctx) ir_if(operand(r0B1B).val);
               exec_list *const f0B1A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B1A->then_instructions;

                  ir_variable *const r0B1C = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0B1E = less(body.constant(int(2045)), r0AD3);
                  ir_if *f0B1D = new(mem_ctx) ir_if(operand(r0B1E).val);
                  exec_list *const f0B1D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B1D->then_instructions;

                     body.emit(assign(r0B1C, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B1D->else_instructions;

                     ir_variable *const r0B1F = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B21 = equal(r0AD3, body.constant(int(2045)));
                     ir_if *f0B20 = new(mem_ctx) ir_if(operand(r0B21).val);
                     exec_list *const f0B20_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B20->then_instructions;

                        ir_expression *const r0B22 = equal(body.constant(2097151u), r0AD4);
                        ir_expression *const r0B23 = equal(body.constant(4294967295u), r0AD5);
                        body.emit(assign(r0B1F, logic_and(r0B22, r0B23), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B20->else_instructions;

                        body.emit(assign(r0B1F, body.constant(false), 0x01));


                     body.instructions = f0B20_parent_instructions;
                     body.emit(f0B20);

                     /* END IF */

                     body.emit(assign(r0B1C, logic_and(r0B1F, r0B18), 0x01));


                  body.instructions = f0B1D_parent_instructions;
                  body.emit(f0B1D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0B24 = new(mem_ctx) ir_if(operand(r0B1C).val);
                  exec_list *const f0B24_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B24->then_instructions;

                     ir_variable *const r0B25 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0B25);
                     ir_expression *const r0B26 = lshift(r0999, body.constant(int(31)));
                     body.emit(assign(r0B25, add(r0B26, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0B25, body.constant(0u), 0x01));

                     body.emit(assign(r0B17, r0B25, 0x03));

                     body.emit(assign(r0B16, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B24->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B28 = less(r0AD3, body.constant(int(0)));
                     ir_if *f0B27 = new(mem_ctx) ir_if(operand(r0B28).val);
                     exec_list *const f0B27_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B27->then_instructions;

                        ir_variable *const r0B29 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0B29, r0AD6, 0x01));

                        ir_variable *const r0B2A = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0B2A, neg(r0AD3), 0x01));

                        ir_variable *const r0B2B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0B2B);
                        ir_variable *const r0B2C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0B2C);
                        ir_variable *const r0B2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0B2D);
                        ir_variable *const r0B2E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0B2F = neg(r0B2A);
                        body.emit(assign(r0B2E, bit_and(r0B2F, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0B31 = equal(r0B2A, body.constant(int(0)));
                        ir_if *f0B30 = new(mem_ctx) ir_if(operand(r0B31).val);
                        exec_list *const f0B30_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B30->then_instructions;

                           body.emit(assign(r0B2B, r0AD6, 0x01));

                           body.emit(assign(r0B2C, r0AD5, 0x01));

                           body.emit(assign(r0B2D, r0AD4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B30->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0B33 = less(r0B2A, body.constant(int(32)));
                           ir_if *f0B32 = new(mem_ctx) ir_if(operand(r0B33).val);
                           exec_list *const f0B32_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B32->then_instructions;

                              body.emit(assign(r0B2B, lshift(r0AD5, r0B2E), 0x01));

                              ir_expression *const r0B34 = lshift(r0AD4, r0B2E);
                              ir_expression *const r0B35 = rshift(r0AD5, r0B2A);
                              body.emit(assign(r0B2C, bit_or(r0B34, r0B35), 0x01));

                              body.emit(assign(r0B2D, rshift(r0AD4, r0B2A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B32->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0B37 = equal(r0B2A, body.constant(int(32)));
                              ir_if *f0B36 = new(mem_ctx) ir_if(operand(r0B37).val);
                              exec_list *const f0B36_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B36->then_instructions;

                                 body.emit(assign(r0B2B, r0AD5, 0x01));

                                 body.emit(assign(r0B2C, r0AD4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B36->else_instructions;

                                 body.emit(assign(r0B29, bit_or(r0AD6, r0AD5), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0B39 = less(r0B2A, body.constant(int(64)));
                                 ir_if *f0B38 = new(mem_ctx) ir_if(operand(r0B39).val);
                                 exec_list *const f0B38_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0B38->then_instructions;

                                    body.emit(assign(r0B2B, lshift(r0AD4, r0B2E), 0x01));

                                    ir_expression *const r0B3A = bit_and(r0B2A, body.constant(int(31)));
                                    body.emit(assign(r0B2C, rshift(r0AD4, r0B3A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0B38->else_instructions;

                                    ir_variable *const r0B3B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0B3D = equal(r0B2A, body.constant(int(64)));
                                    ir_if *f0B3C = new(mem_ctx) ir_if(operand(r0B3D).val);
                                    exec_list *const f0B3C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0B3C->then_instructions;

                                       body.emit(assign(r0B3B, r0AD4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0B3C->else_instructions;

                                       ir_expression *const r0B3E = nequal(r0AD4, body.constant(0u));
                                       ir_expression *const r0B3F = expr(ir_unop_b2i, r0B3E);
                                       body.emit(assign(r0B3B, expr(ir_unop_i2u, r0B3F), 0x01));


                                    body.instructions = f0B3C_parent_instructions;
                                    body.emit(f0B3C);

                                    /* END IF */

                                    body.emit(assign(r0B2B, r0B3B, 0x01));

                                    body.emit(assign(r0B2C, body.constant(0u), 0x01));


                                 body.instructions = f0B38_parent_instructions;
                                 body.emit(f0B38);

                                 /* END IF */


                              body.instructions = f0B36_parent_instructions;
                              body.emit(f0B36);

                              /* END IF */

                              body.emit(assign(r0B2D, body.constant(0u), 0x01));


                           body.instructions = f0B32_parent_instructions;
                           body.emit(f0B32);

                           /* END IF */

                           ir_expression *const r0B40 = nequal(r0B29, body.constant(0u));
                           ir_expression *const r0B41 = expr(ir_unop_b2i, r0B40);
                           ir_expression *const r0B42 = expr(ir_unop_i2u, r0B41);
                           body.emit(assign(r0B2B, bit_or(r0B2B, r0B42), 0x01));


                        body.instructions = f0B30_parent_instructions;
                        body.emit(f0B30);

                        /* END IF */

                        body.emit(assign(r0B13, r0B2D, 0x01));

                        body.emit(assign(r0B14, r0B2C, 0x01));

                        body.emit(assign(r0B15, r0B2B, 0x01));

                        body.emit(assign(r0B12, body.constant(int(0)), 0x01));

                        body.emit(assign(r0B18, less(r0B2B, body.constant(0u)), 0x01));


                     body.instructions = f0B27_parent_instructions;
                     body.emit(f0B27);

                     /* END IF */


                  body.instructions = f0B24_parent_instructions;
                  body.emit(f0B24);

                  /* END IF */


               body.instructions = f0B1A_parent_instructions;
               body.emit(f0B1A);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0B43 = new(mem_ctx) ir_if(operand(r0B16).val);
               exec_list *const f0B43_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B43->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0B44 = new(mem_ctx) ir_if(operand(r0B18).val);
                  exec_list *const f0B44_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B44->then_instructions;

                     ir_variable *const r0B45 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0B45, add(r0B14, body.constant(1u)), 0x01));

                     ir_expression *const r0B46 = less(r0B45, r0B14);
                     ir_expression *const r0B47 = expr(ir_unop_b2i, r0B46);
                     ir_expression *const r0B48 = expr(ir_unop_i2u, r0B47);
                     body.emit(assign(r0B13, add(r0B13, r0B48), 0x01));

                     ir_expression *const r0B49 = equal(r0B15, body.constant(0u));
                     ir_expression *const r0B4A = expr(ir_unop_b2i, r0B49);
                     ir_expression *const r0B4B = expr(ir_unop_i2u, r0B4A);
                     ir_expression *const r0B4C = add(r0B15, r0B4B);
                     ir_expression *const r0B4D = bit_and(r0B4C, body.constant(1u));
                     ir_expression *const r0B4E = expr(ir_unop_bit_not, r0B4D);
                     body.emit(assign(r0B14, bit_and(r0B45, r0B4E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B44->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B50 = bit_or(r0B13, r0B14);
                     ir_expression *const r0B51 = equal(r0B50, body.constant(0u));
                     ir_if *f0B4F = new(mem_ctx) ir_if(operand(r0B51).val);
                     exec_list *const f0B4F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B4F->then_instructions;

                        body.emit(assign(r0B12, body.constant(int(0)), 0x01));


                     body.instructions = f0B4F_parent_instructions;
                     body.emit(f0B4F);

                     /* END IF */


                  body.instructions = f0B44_parent_instructions;
                  body.emit(f0B44);

                  /* END IF */

                  ir_variable *const r0B52 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0B52);
                  ir_expression *const r0B53 = lshift(r0999, body.constant(int(31)));
                  ir_expression *const r0B54 = expr(ir_unop_i2u, r0B12);
                  ir_expression *const r0B55 = lshift(r0B54, body.constant(int(20)));
                  ir_expression *const r0B56 = add(r0B53, r0B55);
                  body.emit(assign(r0B52, add(r0B56, r0B13), 0x02));

                  body.emit(assign(r0B52, r0B14, 0x01));

                  body.emit(assign(r0B17, r0B52, 0x03));

                  body.emit(assign(r0B16, body.constant(false), 0x01));


               body.instructions = f0B43_parent_instructions;
               body.emit(f0B43);

               /* END IF */

               body.emit(assign(r099A, r0B17, 0x03));


            body.instructions = f0A85_parent_instructions;
            body.emit(f0A85);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0A83->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0B58 = equal(r09A3, body.constant(int(2047)));
            ir_if *f0B57 = new(mem_ctx) ir_if(operand(r0B58).val);
            exec_list *const f0B57_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0B57->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0B5A = bit_or(r09A0, r09A1);
               ir_expression *const r0B5B = bit_or(r099E, r099F);
               ir_expression *const r0B5C = bit_or(r0B5A, r0B5B);
               ir_expression *const r0B5D = nequal(r0B5C, body.constant(0u));
               ir_if *f0B59 = new(mem_ctx) ir_if(operand(r0B5D).val);
               exec_list *const f0B59_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B59->then_instructions;

                  ir_variable *const r0B5E = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0B5E, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0B5F = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0B5F, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0B60 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0B61 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0B62 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0B63 = bit_and(r0B62, body.constant(4095u));
                  ir_expression *const r0B64 = equal(r0B63, body.constant(4094u));
                  ir_expression *const r0B65 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B66 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0B67 = nequal(r0B66, body.constant(0u));
                  ir_expression *const r0B68 = logic_or(r0B65, r0B67);
                  body.emit(assign(r0B61, logic_and(r0B64, r0B68), 0x01));

                  ir_variable *const r0B69 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0B6A = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0B6B = lequal(body.constant(4292870144u), r0B6A);
                  ir_expression *const r0B6C = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0B6D = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0B6E = nequal(r0B6D, body.constant(0u));
                  ir_expression *const r0B6F = logic_or(r0B6C, r0B6E);
                  body.emit(assign(r0B69, logic_and(r0B6B, r0B6F), 0x01));

                  body.emit(assign(r0B5E, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0B5F, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0B71 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0B72 = lequal(body.constant(4292870144u), r0B71);
                  ir_expression *const r0B73 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B74 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0B75 = nequal(r0B74, body.constant(0u));
                  ir_expression *const r0B76 = logic_or(r0B73, r0B75);
                  ir_expression *const r0B77 = logic_and(r0B72, r0B76);
                  ir_if *f0B70 = new(mem_ctx) ir_if(operand(r0B77).val);
                  exec_list *const f0B70_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B70->then_instructions;

                     ir_variable *const r0B78 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B7A = logic_and(r0B61, r0B69);
                     ir_if *f0B79 = new(mem_ctx) ir_if(operand(r0B7A).val);
                     exec_list *const f0B79_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B79->then_instructions;

                        body.emit(assign(r0B78, r0B5F, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B79->else_instructions;

                        body.emit(assign(r0B78, r0B5E, 0x03));


                     body.instructions = f0B79_parent_instructions;
                     body.emit(f0B79);

                     /* END IF */

                     body.emit(assign(r0B60, r0B78, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B70->else_instructions;

                     body.emit(assign(r0B60, r0B5F, 0x03));


                  body.instructions = f0B70_parent_instructions;
                  body.emit(f0B70);

                  /* END IF */

                  body.emit(assign(r099A, r0B60, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B59->else_instructions;

                  ir_constant_data r0B7B_data;
                  memset(&r0B7B_data, 0, sizeof(ir_constant_data));
                  r0B7B_data.u[0] = 4294967295;
                  r0B7B_data.u[1] = 4294967295;
                  ir_constant *const r0B7B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0B7B_data);
                  body.emit(assign(r099A, r0B7B, 0x03));


               body.instructions = f0B59_parent_instructions;
               body.emit(f0B59);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0B57->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0B7D = equal(r09A3, body.constant(int(0)));
               ir_if *f0B7C = new(mem_ctx) ir_if(operand(r0B7D).val);
               exec_list *const f0B7C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B7C->then_instructions;

                  body.emit(assign(r099D, body.constant(int(1)), 0x01));

                  body.emit(assign(r099C, body.constant(int(1)), 0x01));


               body.instructions = f0B7C_parent_instructions;
               body.emit(f0B7C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0B7F = less(r099E, r09A0);
               ir_if *f0B7E = new(mem_ctx) ir_if(operand(r0B7F).val);
               exec_list *const f0B7E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B7E->then_instructions;

                  ir_variable *const r0B80 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0B81 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0B81, sub(r09A1, r099F), 0x01));

                  ir_expression *const r0B82 = sub(r09A0, r099E);
                  ir_expression *const r0B83 = less(r09A1, r099F);
                  ir_expression *const r0B84 = expr(ir_unop_b2i, r0B83);
                  ir_expression *const r0B85 = expr(ir_unop_i2u, r0B84);
                  body.emit(assign(r0B80, sub(r0B82, r0B85), 0x01));

                  body.emit(assign(r09A2, add(r099D, body.constant(int(-1))), 0x01));

                  ir_variable *const r0B86 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0B86, add(r09A2, body.constant(int(-10))), 0x01));

                  ir_variable *const r0B87 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0B87, r0B80, 0x01));

                  ir_variable *const r0B88 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0B88, r0B81, 0x01));

                  ir_variable *const r0B89 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0B89);
                  ir_variable *const r0B8A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B8A);
                  /* IF CONDITION */
                  ir_expression *const r0B8C = equal(r0B80, body.constant(0u));
                  ir_if *f0B8B = new(mem_ctx) ir_if(operand(r0B8C).val);
                  exec_list *const f0B8B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B8B->then_instructions;

                     body.emit(assign(r0B87, r0B81, 0x01));

                     body.emit(assign(r0B88, body.constant(0u), 0x01));

                     body.emit(assign(r0B86, add(r0B86, body.constant(int(-32))), 0x01));


                  body.instructions = f0B8B_parent_instructions;
                  body.emit(f0B8B);

                  /* END IF */

                  ir_variable *const r0B8D = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0B8D, r0B87, 0x01));

                  ir_variable *const r0B8E = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0B8F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B8F);
                  /* IF CONDITION */
                  ir_expression *const r0B91 = equal(r0B87, body.constant(0u));
                  ir_if *f0B90 = new(mem_ctx) ir_if(operand(r0B91).val);
                  exec_list *const f0B90_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B90->then_instructions;

                     body.emit(assign(r0B8E, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B90->else_instructions;

                     body.emit(assign(r0B8F, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0B93 = bit_and(r0B87, body.constant(4294901760u));
                     ir_expression *const r0B94 = equal(r0B93, body.constant(0u));
                     ir_if *f0B92 = new(mem_ctx) ir_if(operand(r0B94).val);
                     exec_list *const f0B92_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B92->then_instructions;

                        body.emit(assign(r0B8F, body.constant(int(16)), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B87, body.constant(int(16))), 0x01));


                     body.instructions = f0B92_parent_instructions;
                     body.emit(f0B92);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B96 = bit_and(r0B8D, body.constant(4278190080u));
                     ir_expression *const r0B97 = equal(r0B96, body.constant(0u));
                     ir_if *f0B95 = new(mem_ctx) ir_if(operand(r0B97).val);
                     exec_list *const f0B95_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B95->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(8))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(8))), 0x01));


                     body.instructions = f0B95_parent_instructions;
                     body.emit(f0B95);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B99 = bit_and(r0B8D, body.constant(4026531840u));
                     ir_expression *const r0B9A = equal(r0B99, body.constant(0u));
                     ir_if *f0B98 = new(mem_ctx) ir_if(operand(r0B9A).val);
                     exec_list *const f0B98_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B98->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(4))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(4))), 0x01));


                     body.instructions = f0B98_parent_instructions;
                     body.emit(f0B98);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9C = bit_and(r0B8D, body.constant(3221225472u));
                     ir_expression *const r0B9D = equal(r0B9C, body.constant(0u));
                     ir_if *f0B9B = new(mem_ctx) ir_if(operand(r0B9D).val);
                     exec_list *const f0B9B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9B->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(2))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(2))), 0x01));


                     body.instructions = f0B9B_parent_instructions;
                     body.emit(f0B9B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9F = bit_and(r0B8D, body.constant(2147483648u));
                     ir_expression *const r0BA0 = equal(r0B9F, body.constant(0u));
                     ir_if *f0B9E = new(mem_ctx) ir_if(operand(r0BA0).val);
                     exec_list *const f0B9E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9E->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(1))), 0x01));


                     body.instructions = f0B9E_parent_instructions;
                     body.emit(f0B9E);

                     /* END IF */

                     body.emit(assign(r0B8E, r0B8F, 0x01));


                  body.instructions = f0B90_parent_instructions;
                  body.emit(f0B90);

                  /* END IF */

                  body.emit(assign(r0B8A, add(r0B8E, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BA2 = lequal(body.constant(int(0)), r0B8A);
                  ir_if *f0BA1 = new(mem_ctx) ir_if(operand(r0BA2).val);
                  exec_list *const f0BA1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BA1->then_instructions;

                     body.emit(assign(r0B89, body.constant(0u), 0x01));

                     ir_variable *const r0BA3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0BA3, lshift(r0B88, r0B8A), 0x01));

                     ir_variable *const r0BA4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BA6 = equal(r0B8A, body.constant(int(0)));
                     ir_if *f0BA5 = new(mem_ctx) ir_if(operand(r0BA6).val);
                     exec_list *const f0BA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BA5->then_instructions;

                        body.emit(assign(r0BA4, r0B87, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BA5->else_instructions;

                        ir_expression *const r0BA7 = lshift(r0B87, r0B8A);
                        ir_expression *const r0BA8 = neg(r0B8A);
                        ir_expression *const r0BA9 = bit_and(r0BA8, body.constant(int(31)));
                        ir_expression *const r0BAA = rshift(r0B88, r0BA9);
                        body.emit(assign(r0BA4, bit_or(r0BA7, r0BAA), 0x01));


                     body.instructions = f0BA5_parent_instructions;
                     body.emit(f0BA5);

                     /* END IF */

                     body.emit(assign(r0B87, r0BA4, 0x01));

                     body.emit(assign(r0B88, r0BA3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0BA1->else_instructions;

                     ir_variable *const r0BAB = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0BAB, body.constant(0u), 0x01));

                     ir_variable *const r0BAC = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0BAC, neg(r0B8A), 0x01));

                     ir_variable *const r0BAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0BAD);
                     ir_variable *const r0BAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0BAE);
                     ir_variable *const r0BAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0BAF);
                     ir_variable *const r0BB0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0BB1 = neg(r0BAC);
                     body.emit(assign(r0BB0, bit_and(r0BB1, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0BB3 = equal(r0BAC, body.constant(int(0)));
                     ir_if *f0BB2 = new(mem_ctx) ir_if(operand(r0BB3).val);
                     exec_list *const f0BB2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BB2->then_instructions;

                        body.emit(assign(r0BAD, r0BAB, 0x01));

                        body.emit(assign(r0BAE, r0B88, 0x01));

                        body.emit(assign(r0BAF, r0B87, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BB2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BB5 = less(r0BAC, body.constant(int(32)));
                        ir_if *f0BB4 = new(mem_ctx) ir_if(operand(r0BB5).val);
                        exec_list *const f0BB4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BB4->then_instructions;

                           body.emit(assign(r0BAD, lshift(r0B88, r0BB0), 0x01));

                           ir_expression *const r0BB6 = lshift(r0B87, r0BB0);
                           ir_expression *const r0BB7 = rshift(r0B88, r0BAC);
                           body.emit(assign(r0BAE, bit_or(r0BB6, r0BB7), 0x01));

                           body.emit(assign(r0BAF, rshift(r0B87, r0BAC), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BB4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0BB9 = equal(r0BAC, body.constant(int(32)));
                           ir_if *f0BB8 = new(mem_ctx) ir_if(operand(r0BB9).val);
                           exec_list *const f0BB8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BB8->then_instructions;

                              body.emit(assign(r0BAD, r0B88, 0x01));

                              body.emit(assign(r0BAE, r0B87, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BB8->else_instructions;

                              body.emit(assign(r0BAB, bit_or(body.constant(0u), r0B88), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0BBB = less(r0BAC, body.constant(int(64)));
                              ir_if *f0BBA = new(mem_ctx) ir_if(operand(r0BBB).val);
                              exec_list *const f0BBA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BBA->then_instructions;

                                 body.emit(assign(r0BAD, lshift(r0B87, r0BB0), 0x01));

                                 ir_expression *const r0BBC = bit_and(r0BAC, body.constant(int(31)));
                                 body.emit(assign(r0BAE, rshift(r0B87, r0BBC), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BBA->else_instructions;

                                 ir_variable *const r0BBD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0BBF = equal(r0BAC, body.constant(int(64)));
                                 ir_if *f0BBE = new(mem_ctx) ir_if(operand(r0BBF).val);
                                 exec_list *const f0BBE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BBE->then_instructions;

                                    body.emit(assign(r0BBD, r0B87, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BBE->else_instructions;

                                    ir_expression *const r0BC0 = nequal(r0B87, body.constant(0u));
                                    ir_expression *const r0BC1 = expr(ir_unop_b2i, r0BC0);
                                    body.emit(assign(r0BBD, expr(ir_unop_i2u, r0BC1), 0x01));


                                 body.instructions = f0BBE_parent_instructions;
                                 body.emit(f0BBE);

                                 /* END IF */

                                 body.emit(assign(r0BAD, r0BBD, 0x01));

                                 body.emit(assign(r0BAE, body.constant(0u), 0x01));


                              body.instructions = f0BBA_parent_instructions;
                              body.emit(f0BBA);

                              /* END IF */


                           body.instructions = f0BB8_parent_instructions;
                           body.emit(f0BB8);

                           /* END IF */

                           body.emit(assign(r0BAF, body.constant(0u), 0x01));


                        body.instructions = f0BB4_parent_instructions;
                        body.emit(f0BB4);

                        /* END IF */

                        ir_expression *const r0BC2 = nequal(r0BAB, body.constant(0u));
                        ir_expression *const r0BC3 = expr(ir_unop_b2i, r0BC2);
                        ir_expression *const r0BC4 = expr(ir_unop_i2u, r0BC3);
                        body.emit(assign(r0BAD, bit_or(r0BAD, r0BC4), 0x01));


                     body.instructions = f0BB2_parent_instructions;
                     body.emit(f0BB2);

                     /* END IF */

                     body.emit(assign(r0B87, r0BAF, 0x01));

                     body.emit(assign(r0B88, r0BAE, 0x01));

                     body.emit(assign(r0B89, r0BAD, 0x01));


                  body.instructions = f0BA1_parent_instructions;
                  body.emit(f0BA1);

                  /* END IF */

                  body.emit(assign(r0B86, sub(r0B86, r0B8A), 0x01));

                  ir_variable *const r0BC5 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0BC5, r0B86, 0x01));

                  ir_variable *const r0BC6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0BC6, r0B87, 0x01));

                  ir_variable *const r0BC7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0BC7, r0B88, 0x01));

                  ir_variable *const r0BC8 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0BC8, r0B89, 0x01));

                  ir_variable *const r0BC9 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0BC9, body.constant(true), 0x01));

                  ir_variable *const r0BCA = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0BCB = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0BCB);
                  ir_expression *const r0BCC = expr(ir_unop_u2i, r0B89);
                  body.emit(assign(r0BCB, less(r0BCC, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BCE = lequal(body.constant(int(2045)), r0B86);
                  ir_if *f0BCD = new(mem_ctx) ir_if(operand(r0BCE).val);
                  exec_list *const f0BCD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BCD->then_instructions;

                     ir_variable *const r0BCF = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BD1 = less(body.constant(int(2045)), r0B86);
                     ir_if *f0BD0 = new(mem_ctx) ir_if(operand(r0BD1).val);
                     exec_list *const f0BD0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD0->then_instructions;

                        body.emit(assign(r0BCF, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD0->else_instructions;

                        ir_variable *const r0BD2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0BD4 = equal(r0B86, body.constant(int(2045)));
                        ir_if *f0BD3 = new(mem_ctx) ir_if(operand(r0BD4).val);
                        exec_list *const f0BD3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BD3->then_instructions;

                           ir_expression *const r0BD5 = equal(body.constant(2097151u), r0B87);
                           ir_expression *const r0BD6 = equal(body.constant(4294967295u), r0B88);
                           body.emit(assign(r0BD2, logic_and(r0BD5, r0BD6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BD3->else_instructions;

                           body.emit(assign(r0BD2, body.constant(false), 0x01));


                        body.instructions = f0BD3_parent_instructions;
                        body.emit(f0BD3);

                        /* END IF */

                        body.emit(assign(r0BCF, logic_and(r0BD2, r0BCB), 0x01));


                     body.instructions = f0BD0_parent_instructions;
                     body.emit(f0BD0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0BD7 = new(mem_ctx) ir_if(operand(r0BCF).val);
                     exec_list *const f0BD7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD7->then_instructions;

                        ir_variable *const r0BD8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0BD8);
                        ir_expression *const r0BD9 = lshift(r0999, body.constant(int(31)));
                        body.emit(assign(r0BD8, add(r0BD9, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0BD8, body.constant(0u), 0x01));

                        body.emit(assign(r0BCA, r0BD8, 0x03));

                        body.emit(assign(r0BC9, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BDB = less(r0B86, body.constant(int(0)));
                        ir_if *f0BDA = new(mem_ctx) ir_if(operand(r0BDB).val);
                        exec_list *const f0BDA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BDA->then_instructions;

                           ir_variable *const r0BDC = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0BDC, r0B89, 0x01));

                           ir_variable *const r0BDD = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0BDD, neg(r0B86), 0x01));

                           ir_variable *const r0BDE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0BDE);
                           ir_variable *const r0BDF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0BDF);
                           ir_variable *const r0BE0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0BE0);
                           ir_variable *const r0BE1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0BE2 = neg(r0BDD);
                           body.emit(assign(r0BE1, bit_and(r0BE2, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0BE4 = equal(r0BDD, body.constant(int(0)));
                           ir_if *f0BE3 = new(mem_ctx) ir_if(operand(r0BE4).val);
                           exec_list *const f0BE3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BE3->then_instructions;

                              body.emit(assign(r0BDE, r0B89, 0x01));

                              body.emit(assign(r0BDF, r0B88, 0x01));

                              body.emit(assign(r0BE0, r0B87, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BE3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0BE6 = less(r0BDD, body.constant(int(32)));
                              ir_if *f0BE5 = new(mem_ctx) ir_if(operand(r0BE6).val);
                              exec_list *const f0BE5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BE5->then_instructions;

                                 body.emit(assign(r0BDE, lshift(r0B88, r0BE1), 0x01));

                                 ir_expression *const r0BE7 = lshift(r0B87, r0BE1);
                                 ir_expression *const r0BE8 = rshift(r0B88, r0BDD);
                                 body.emit(assign(r0BDF, bit_or(r0BE7, r0BE8), 0x01));

                                 body.emit(assign(r0BE0, rshift(r0B87, r0BDD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BE5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0BEA = equal(r0BDD, body.constant(int(32)));
                                 ir_if *f0BE9 = new(mem_ctx) ir_if(operand(r0BEA).val);
                                 exec_list *const f0BE9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BE9->then_instructions;

                                    body.emit(assign(r0BDE, r0B88, 0x01));

                                    body.emit(assign(r0BDF, r0B87, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BE9->else_instructions;

                                    body.emit(assign(r0BDC, bit_or(r0B89, r0B88), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0BEC = less(r0BDD, body.constant(int(64)));
                                    ir_if *f0BEB = new(mem_ctx) ir_if(operand(r0BEC).val);
                                    exec_list *const f0BEB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0BEB->then_instructions;

                                       body.emit(assign(r0BDE, lshift(r0B87, r0BE1), 0x01));

                                       ir_expression *const r0BED = bit_and(r0BDD, body.constant(int(31)));
                                       body.emit(assign(r0BDF, rshift(r0B87, r0BED), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0BEB->else_instructions;

                                       ir_variable *const r0BEE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0BF0 = equal(r0BDD, body.constant(int(64)));
                                       ir_if *f0BEF = new(mem_ctx) ir_if(operand(r0BF0).val);
                                       exec_list *const f0BEF_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0BEF->then_instructions;

                                          body.emit(assign(r0BEE, r0B87, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0BEF->else_instructions;

                                          ir_expression *const r0BF1 = nequal(r0B87, body.constant(0u));
                                          ir_expression *const r0BF2 = expr(ir_unop_b2i, r0BF1);
                                          body.emit(assign(r0BEE, expr(ir_unop_i2u, r0BF2), 0x01));


                                       body.instructions = f0BEF_parent_instructions;
                                       body.emit(f0BEF);

                                       /* END IF */

                                       body.emit(assign(r0BDE, r0BEE, 0x01));

                                       body.emit(assign(r0BDF, body.constant(0u), 0x01));


                                    body.instructions = f0BEB_parent_instructions;
                                    body.emit(f0BEB);

                                    /* END IF */


                                 body.instructions = f0BE9_parent_instructions;
                                 body.emit(f0BE9);

                                 /* END IF */

                                 body.emit(assign(r0BE0, body.constant(0u), 0x01));


                              body.instructions = f0BE5_parent_instructions;
                              body.emit(f0BE5);

                              /* END IF */

                              ir_expression *const r0BF3 = nequal(r0BDC, body.constant(0u));
                              ir_expression *const r0BF4 = expr(ir_unop_b2i, r0BF3);
                              ir_expression *const r0BF5 = expr(ir_unop_i2u, r0BF4);
                              body.emit(assign(r0BDE, bit_or(r0BDE, r0BF5), 0x01));


                           body.instructions = f0BE3_parent_instructions;
                           body.emit(f0BE3);

                           /* END IF */

                           body.emit(assign(r0BC6, r0BE0, 0x01));

                           body.emit(assign(r0BC7, r0BDF, 0x01));

                           body.emit(assign(r0BC8, r0BDE, 0x01));

                           body.emit(assign(r0BC5, body.constant(int(0)), 0x01));

                           body.emit(assign(r0BCB, less(r0BDE, body.constant(0u)), 0x01));


                        body.instructions = f0BDA_parent_instructions;
                        body.emit(f0BDA);

                        /* END IF */


                     body.instructions = f0BD7_parent_instructions;
                     body.emit(f0BD7);

                     /* END IF */


                  body.instructions = f0BCD_parent_instructions;
                  body.emit(f0BCD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0BF6 = new(mem_ctx) ir_if(operand(r0BC9).val);
                  exec_list *const f0BF6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BF6->then_instructions;

                     /* IF CONDITION */
                     ir_if *f0BF7 = new(mem_ctx) ir_if(operand(r0BCB).val);
                     exec_list *const f0BF7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BF7->then_instructions;

                        ir_variable *const r0BF8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r0BF8, add(r0BC7, body.constant(1u)), 0x01));

                        ir_expression *const r0BF9 = less(r0BF8, r0BC7);
                        ir_expression *const r0BFA = expr(ir_unop_b2i, r0BF9);
                        ir_expression *const r0BFB = expr(ir_unop_i2u, r0BFA);
                        body.emit(assign(r0BC6, add(r0BC6, r0BFB), 0x01));

                        ir_expression *const r0BFC = equal(r0BC8, body.constant(0u));
                        ir_expression *const r0BFD = expr(ir_unop_b2i, r0BFC);
                        ir_expression *const r0BFE = expr(ir_unop_i2u, r0BFD);
                        ir_expression *const r0BFF = add(r0BC8, r0BFE);
                        ir_expression *const r0C00 = bit_and(r0BFF, body.constant(1u));
                        ir_expression *const r0C01 = expr(ir_unop_bit_not, r0C00);
                        body.emit(assign(r0BC7, bit_and(r0BF8, r0C01), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BF7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0C03 = bit_or(r0BC6, r0BC7);
                        ir_expression *const r0C04 = equal(r0C03, body.constant(0u));
                        ir_if *f0C02 = new(mem_ctx) ir_if(operand(r0C04).val);
                        exec_list *const f0C02_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C02->then_instructions;

                           body.emit(assign(r0BC5, body.constant(int(0)), 0x01));


                        body.instructions = f0C02_parent_instructions;
                        body.emit(f0C02);

                        /* END IF */


                     body.instructions = f0BF7_parent_instructions;
                     body.emit(f0BF7);

                     /* END IF */

                     ir_variable *const r0C05 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0C05);
                     ir_expression *const r0C06 = lshift(r0999, body.constant(int(31)));
                     ir_expression *const r0C07 = expr(ir_unop_i2u, r0BC5);
                     ir_expression *const r0C08 = lshift(r0C07, body.constant(int(20)));
                     ir_expression *const r0C09 = add(r0C06, r0C08);
                     body.emit(assign(r0C05, add(r0C09, r0BC6), 0x02));

                     body.emit(assign(r0C05, r0BC7, 0x01));

                     body.emit(assign(r0BCA, r0C05, 0x03));

                     body.emit(assign(r0BC9, body.constant(false), 0x01));


                  body.instructions = f0BF6_parent_instructions;
                  body.emit(f0BF6);

                  /* END IF */

                  body.emit(assign(r099A, r0BCA, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B7E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0C0B = less(r09A0, r099E);
                  ir_if *f0C0A = new(mem_ctx) ir_if(operand(r0C0B).val);
                  exec_list *const f0C0A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0C0A->then_instructions;

                     ir_variable *const r0C0C = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r0C0D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0C0D, sub(r099F, r09A1), 0x01));

                     ir_expression *const r0C0E = sub(r099E, r09A0);
                     ir_expression *const r0C0F = less(r099F, r09A1);
                     ir_expression *const r0C10 = expr(ir_unop_b2i, r0C0F);
                     ir_expression *const r0C11 = expr(ir_unop_i2u, r0C10);
                     body.emit(assign(r0C0C, sub(r0C0E, r0C11), 0x01));

                     body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                     body.emit(assign(r09A2, add(r099C, body.constant(int(-1))), 0x01));

                     ir_variable *const r0C12 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C12, add(r09A2, body.constant(int(-10))), 0x01));

                     ir_variable *const r0C13 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C13, r0C0C, 0x01));

                     ir_variable *const r0C14 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C14, r0C0D, 0x01));

                     ir_variable *const r0C15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r0C15);
                     ir_variable *const r0C16 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C16);
                     /* IF CONDITION */
                     ir_expression *const r0C18 = equal(r0C0C, body.constant(0u));
                     ir_if *f0C17 = new(mem_ctx) ir_if(operand(r0C18).val);
                     exec_list *const f0C17_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C17->then_instructions;

                        body.emit(assign(r0C13, r0C0D, 0x01));

                        body.emit(assign(r0C14, body.constant(0u), 0x01));

                        body.emit(assign(r0C12, add(r0C12, body.constant(int(-32))), 0x01));


                     body.instructions = f0C17_parent_instructions;
                     body.emit(f0C17);

                     /* END IF */

                     ir_variable *const r0C19 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0C19, r0C13, 0x01));

                     ir_variable *const r0C1A = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0C1B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C1B);
                     /* IF CONDITION */
                     ir_expression *const r0C1D = equal(r0C13, body.constant(0u));
                     ir_if *f0C1C = new(mem_ctx) ir_if(operand(r0C1D).val);
                     exec_list *const f0C1C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C1C->then_instructions;

                        body.emit(assign(r0C1A, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C1C->else_instructions;

                        body.emit(assign(r0C1B, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C1F = bit_and(r0C13, body.constant(4294901760u));
                        ir_expression *const r0C20 = equal(r0C1F, body.constant(0u));
                        ir_if *f0C1E = new(mem_ctx) ir_if(operand(r0C20).val);
                        exec_list *const f0C1E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C1E->then_instructions;

                           body.emit(assign(r0C1B, body.constant(int(16)), 0x01));

                           body.emit(assign(r0C19, lshift(r0C13, body.constant(int(16))), 0x01));


                        body.instructions = f0C1E_parent_instructions;
                        body.emit(f0C1E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C22 = bit_and(r0C19, body.constant(4278190080u));
                        ir_expression *const r0C23 = equal(r0C22, body.constant(0u));
                        ir_if *f0C21 = new(mem_ctx) ir_if(operand(r0C23).val);
                        exec_list *const f0C21_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C21->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(8))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(8))), 0x01));


                        body.instructions = f0C21_parent_instructions;
                        body.emit(f0C21);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C25 = bit_and(r0C19, body.constant(4026531840u));
                        ir_expression *const r0C26 = equal(r0C25, body.constant(0u));
                        ir_if *f0C24 = new(mem_ctx) ir_if(operand(r0C26).val);
                        exec_list *const f0C24_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C24->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(4))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(4))), 0x01));


                        body.instructions = f0C24_parent_instructions;
                        body.emit(f0C24);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C28 = bit_and(r0C19, body.constant(3221225472u));
                        ir_expression *const r0C29 = equal(r0C28, body.constant(0u));
                        ir_if *f0C27 = new(mem_ctx) ir_if(operand(r0C29).val);
                        exec_list *const f0C27_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C27->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(2))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(2))), 0x01));


                        body.instructions = f0C27_parent_instructions;
                        body.emit(f0C27);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C2B = bit_and(r0C19, body.constant(2147483648u));
                        ir_expression *const r0C2C = equal(r0C2B, body.constant(0u));
                        ir_if *f0C2A = new(mem_ctx) ir_if(operand(r0C2C).val);
                        exec_list *const f0C2A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C2A->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(1))), 0x01));


                        body.instructions = f0C2A_parent_instructions;
                        body.emit(f0C2A);

                        /* END IF */

                        body.emit(assign(r0C1A, r0C1B, 0x01));


                     body.instructions = f0C1C_parent_instructions;
                     body.emit(f0C1C);

                     /* END IF */

                     body.emit(assign(r0C16, add(r0C1A, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C2E = lequal(body.constant(int(0)), r0C16);
                     ir_if *f0C2D = new(mem_ctx) ir_if(operand(r0C2E).val);
                     exec_list *const f0C2D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C2D->then_instructions;

                        body.emit(assign(r0C15, body.constant(0u), 0x01));

                        ir_variable *const r0C2F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C2F, lshift(r0C14, r0C16), 0x01));

                        ir_variable *const r0C30 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C32 = equal(r0C16, body.constant(int(0)));
                        ir_if *f0C31 = new(mem_ctx) ir_if(operand(r0C32).val);
                        exec_list *const f0C31_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C31->then_instructions;

                           body.emit(assign(r0C30, r0C13, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C31->else_instructions;

                           ir_expression *const r0C33 = lshift(r0C13, r0C16);
                           ir_expression *const r0C34 = neg(r0C16);
                           ir_expression *const r0C35 = bit_and(r0C34, body.constant(int(31)));
                           ir_expression *const r0C36 = rshift(r0C14, r0C35);
                           body.emit(assign(r0C30, bit_or(r0C33, r0C36), 0x01));


                        body.instructions = f0C31_parent_instructions;
                        body.emit(f0C31);

                        /* END IF */

                        body.emit(assign(r0C13, r0C30, 0x01));

                        body.emit(assign(r0C14, r0C2F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C2D->else_instructions;

                        ir_variable *const r0C37 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0C37, body.constant(0u), 0x01));

                        ir_variable *const r0C38 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0C38, neg(r0C16), 0x01));

                        ir_variable *const r0C39 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0C39);
                        ir_variable *const r0C3A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0C3A);
                        ir_variable *const r0C3B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0C3B);
                        ir_variable *const r0C3C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0C3D = neg(r0C38);
                        body.emit(assign(r0C3C, bit_and(r0C3D, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C3F = equal(r0C38, body.constant(int(0)));
                        ir_if *f0C3E = new(mem_ctx) ir_if(operand(r0C3F).val);
                        exec_list *const f0C3E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C3E->then_instructions;

                           body.emit(assign(r0C39, r0C37, 0x01));

                           body.emit(assign(r0C3A, r0C14, 0x01));

                           body.emit(assign(r0C3B, r0C13, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C3E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C41 = less(r0C38, body.constant(int(32)));
                           ir_if *f0C40 = new(mem_ctx) ir_if(operand(r0C41).val);
                           exec_list *const f0C40_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C40->then_instructions;

                              body.emit(assign(r0C39, lshift(r0C14, r0C3C), 0x01));

                              ir_expression *const r0C42 = lshift(r0C13, r0C3C);
                              ir_expression *const r0C43 = rshift(r0C14, r0C38);
                              body.emit(assign(r0C3A, bit_or(r0C42, r0C43), 0x01));

                              body.emit(assign(r0C3B, rshift(r0C13, r0C38), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C40->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0C45 = equal(r0C38, body.constant(int(32)));
                              ir_if *f0C44 = new(mem_ctx) ir_if(operand(r0C45).val);
                              exec_list *const f0C44_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C44->then_instructions;

                                 body.emit(assign(r0C39, r0C14, 0x01));

                                 body.emit(assign(r0C3A, r0C13, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C44->else_instructions;

                                 body.emit(assign(r0C37, bit_or(body.constant(0u), r0C14), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0C47 = less(r0C38, body.constant(int(64)));
                                 ir_if *f0C46 = new(mem_ctx) ir_if(operand(r0C47).val);
                                 exec_list *const f0C46_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C46->then_instructions;

                                    body.emit(assign(r0C39, lshift(r0C13, r0C3C), 0x01));

                                    ir_expression *const r0C48 = bit_and(r0C38, body.constant(int(31)));
                                    body.emit(assign(r0C3A, rshift(r0C13, r0C48), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C46->else_instructions;

                                    ir_variable *const r0C49 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0C4B = equal(r0C38, body.constant(int(64)));
                                    ir_if *f0C4A = new(mem_ctx) ir_if(operand(r0C4B).val);
                                    exec_list *const f0C4A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C4A->then_instructions;

                                       body.emit(assign(r0C49, r0C13, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C4A->else_instructions;

                                       ir_expression *const r0C4C = nequal(r0C13, body.constant(0u));
                                       ir_expression *const r0C4D = expr(ir_unop_b2i, r0C4C);
                                       body.emit(assign(r0C49, expr(ir_unop_i2u, r0C4D), 0x01));


                                    body.instructions = f0C4A_parent_instructions;
                                    body.emit(f0C4A);

                                    /* END IF */

                                    body.emit(assign(r0C39, r0C49, 0x01));

                                    body.emit(assign(r0C3A, body.constant(0u), 0x01));


                                 body.instructions = f0C46_parent_instructions;
                                 body.emit(f0C46);

                                 /* END IF */


                              body.instructions = f0C44_parent_instructions;
                              body.emit(f0C44);

                              /* END IF */

                              body.emit(assign(r0C3B, body.constant(0u), 0x01));


                           body.instructions = f0C40_parent_instructions;
                           body.emit(f0C40);

                           /* END IF */

                           ir_expression *const r0C4E = nequal(r0C37, body.constant(0u));
                           ir_expression *const r0C4F = expr(ir_unop_b2i, r0C4E);
                           ir_expression *const r0C50 = expr(ir_unop_i2u, r0C4F);
                           body.emit(assign(r0C39, bit_or(r0C39, r0C50), 0x01));


                        body.instructions = f0C3E_parent_instructions;
                        body.emit(f0C3E);

                        /* END IF */

                        body.emit(assign(r0C13, r0C3B, 0x01));

                        body.emit(assign(r0C14, r0C3A, 0x01));

                        body.emit(assign(r0C15, r0C39, 0x01));


                     body.instructions = f0C2D_parent_instructions;
                     body.emit(f0C2D);

                     /* END IF */

                     body.emit(assign(r0C12, sub(r0C12, r0C16), 0x01));

                     ir_variable *const r0C51 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C51, r0C12, 0x01));

                     ir_variable *const r0C52 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C52, r0C13, 0x01));

                     ir_variable *const r0C53 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C53, r0C14, 0x01));

                     ir_variable *const r0C54 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r0C54, r0C15, 0x01));

                     ir_variable *const r0C55 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r0C55, body.constant(true), 0x01));

                     ir_variable *const r0C56 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r0C57 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r0C57);
                     ir_expression *const r0C58 = expr(ir_unop_u2i, r0C15);
                     body.emit(assign(r0C57, less(r0C58, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C5A = lequal(body.constant(int(2045)), r0C12);
                     ir_if *f0C59 = new(mem_ctx) ir_if(operand(r0C5A).val);
                     exec_list *const f0C59_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C59->then_instructions;

                        ir_variable *const r0C5B = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C5D = less(body.constant(int(2045)), r0C12);
                        ir_if *f0C5C = new(mem_ctx) ir_if(operand(r0C5D).val);
                        exec_list *const f0C5C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C5C->then_instructions;

                           body.emit(assign(r0C5B, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C5C->else_instructions;

                           ir_variable *const r0C5E = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0C60 = equal(r0C12, body.constant(int(2045)));
                           ir_if *f0C5F = new(mem_ctx) ir_if(operand(r0C60).val);
                           exec_list *const f0C5F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C5F->then_instructions;

                              ir_expression *const r0C61 = equal(body.constant(2097151u), r0C13);
                              ir_expression *const r0C62 = equal(body.constant(4294967295u), r0C14);
                              body.emit(assign(r0C5E, logic_and(r0C61, r0C62), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C5F->else_instructions;

                              body.emit(assign(r0C5E, body.constant(false), 0x01));


                           body.instructions = f0C5F_parent_instructions;
                           body.emit(f0C5F);

                           /* END IF */

                           body.emit(assign(r0C5B, logic_and(r0C5E, r0C57), 0x01));


                        body.instructions = f0C5C_parent_instructions;
                        body.emit(f0C5C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0C63 = new(mem_ctx) ir_if(operand(r0C5B).val);
                        exec_list *const f0C63_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C63->then_instructions;

                           ir_variable *const r0C64 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0C64);
                           ir_expression *const r0C65 = lshift(r0999, body.constant(int(31)));
                           body.emit(assign(r0C64, add(r0C65, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r0C64, body.constant(0u), 0x01));

                           body.emit(assign(r0C56, r0C64, 0x03));

                           body.emit(assign(r0C55, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C63->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C67 = less(r0C12, body.constant(int(0)));
                           ir_if *f0C66 = new(mem_ctx) ir_if(operand(r0C67).val);
                           exec_list *const f0C66_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C66->then_instructions;

                              ir_variable *const r0C68 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0C68, r0C15, 0x01));

                              ir_variable *const r0C69 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0C69, neg(r0C12), 0x01));

                              ir_variable *const r0C6A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0C6A);
                              ir_variable *const r0C6B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0C6B);
                              ir_variable *const r0C6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0C6C);
                              ir_variable *const r0C6D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0C6E = neg(r0C69);
                              body.emit(assign(r0C6D, bit_and(r0C6E, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0C70 = equal(r0C69, body.constant(int(0)));
                              ir_if *f0C6F = new(mem_ctx) ir_if(operand(r0C70).val);
                              exec_list *const f0C6F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C6F->then_instructions;

                                 body.emit(assign(r0C6A, r0C15, 0x01));

                                 body.emit(assign(r0C6B, r0C14, 0x01));

                                 body.emit(assign(r0C6C, r0C13, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C6F->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0C72 = less(r0C69, body.constant(int(32)));
                                 ir_if *f0C71 = new(mem_ctx) ir_if(operand(r0C72).val);
                                 exec_list *const f0C71_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C71->then_instructions;

                                    body.emit(assign(r0C6A, lshift(r0C14, r0C6D), 0x01));

                                    ir_expression *const r0C73 = lshift(r0C13, r0C6D);
                                    ir_expression *const r0C74 = rshift(r0C14, r0C69);
                                    body.emit(assign(r0C6B, bit_or(r0C73, r0C74), 0x01));

                                    body.emit(assign(r0C6C, rshift(r0C13, r0C69), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C71->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0C76 = equal(r0C69, body.constant(int(32)));
                                    ir_if *f0C75 = new(mem_ctx) ir_if(operand(r0C76).val);
                                    exec_list *const f0C75_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C75->then_instructions;

                                       body.emit(assign(r0C6A, r0C14, 0x01));

                                       body.emit(assign(r0C6B, r0C13, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C75->else_instructions;

                                       body.emit(assign(r0C68, bit_or(r0C15, r0C14), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0C78 = less(r0C69, body.constant(int(64)));
                                       ir_if *f0C77 = new(mem_ctx) ir_if(operand(r0C78).val);
                                       exec_list *const f0C77_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0C77->then_instructions;

                                          body.emit(assign(r0C6A, lshift(r0C13, r0C6D), 0x01));

                                          ir_expression *const r0C79 = bit_and(r0C69, body.constant(int(31)));
                                          body.emit(assign(r0C6B, rshift(r0C13, r0C79), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0C77->else_instructions;

                                          ir_variable *const r0C7A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0C7C = equal(r0C69, body.constant(int(64)));
                                          ir_if *f0C7B = new(mem_ctx) ir_if(operand(r0C7C).val);
                                          exec_list *const f0C7B_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0C7B->then_instructions;

                                             body.emit(assign(r0C7A, r0C13, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0C7B->else_instructions;

                                             ir_expression *const r0C7D = nequal(r0C13, body.constant(0u));
                                             ir_expression *const r0C7E = expr(ir_unop_b2i, r0C7D);
                                             body.emit(assign(r0C7A, expr(ir_unop_i2u, r0C7E), 0x01));


                                          body.instructions = f0C7B_parent_instructions;
                                          body.emit(f0C7B);

                                          /* END IF */

                                          body.emit(assign(r0C6A, r0C7A, 0x01));

                                          body.emit(assign(r0C6B, body.constant(0u), 0x01));


                                       body.instructions = f0C77_parent_instructions;
                                       body.emit(f0C77);

                                       /* END IF */


                                    body.instructions = f0C75_parent_instructions;
                                    body.emit(f0C75);

                                    /* END IF */

                                    body.emit(assign(r0C6C, body.constant(0u), 0x01));


                                 body.instructions = f0C71_parent_instructions;
                                 body.emit(f0C71);

                                 /* END IF */

                                 ir_expression *const r0C7F = nequal(r0C68, body.constant(0u));
                                 ir_expression *const r0C80 = expr(ir_unop_b2i, r0C7F);
                                 ir_expression *const r0C81 = expr(ir_unop_i2u, r0C80);
                                 body.emit(assign(r0C6A, bit_or(r0C6A, r0C81), 0x01));


                              body.instructions = f0C6F_parent_instructions;
                              body.emit(f0C6F);

                              /* END IF */

                              body.emit(assign(r0C52, r0C6C, 0x01));

                              body.emit(assign(r0C53, r0C6B, 0x01));

                              body.emit(assign(r0C54, r0C6A, 0x01));

                              body.emit(assign(r0C51, body.constant(int(0)), 0x01));

                              body.emit(assign(r0C57, less(r0C6A, body.constant(0u)), 0x01));


                           body.instructions = f0C66_parent_instructions;
                           body.emit(f0C66);

                           /* END IF */


                        body.instructions = f0C63_parent_instructions;
                        body.emit(f0C63);

                        /* END IF */


                     body.instructions = f0C59_parent_instructions;
                     body.emit(f0C59);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0C82 = new(mem_ctx) ir_if(operand(r0C55).val);
                     exec_list *const f0C82_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C82->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0C83 = new(mem_ctx) ir_if(operand(r0C57).val);
                        exec_list *const f0C83_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C83->then_instructions;

                           ir_variable *const r0C84 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r0C84, add(r0C53, body.constant(1u)), 0x01));

                           ir_expression *const r0C85 = less(r0C84, r0C53);
                           ir_expression *const r0C86 = expr(ir_unop_b2i, r0C85);
                           ir_expression *const r0C87 = expr(ir_unop_i2u, r0C86);
                           body.emit(assign(r0C52, add(r0C52, r0C87), 0x01));

                           ir_expression *const r0C88 = equal(r0C54, body.constant(0u));
                           ir_expression *const r0C89 = expr(ir_unop_b2i, r0C88);
                           ir_expression *const r0C8A = expr(ir_unop_i2u, r0C89);
                           ir_expression *const r0C8B = add(r0C54, r0C8A);
                           ir_expression *const r0C8C = bit_and(r0C8B, body.constant(1u));
                           ir_expression *const r0C8D = expr(ir_unop_bit_not, r0C8C);
                           body.emit(assign(r0C53, bit_and(r0C84, r0C8D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C83->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C8F = bit_or(r0C52, r0C53);
                           ir_expression *const r0C90 = equal(r0C8F, body.constant(0u));
                           ir_if *f0C8E = new(mem_ctx) ir_if(operand(r0C90).val);
                           exec_list *const f0C8E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C8E->then_instructions;

                              body.emit(assign(r0C51, body.constant(int(0)), 0x01));


                           body.instructions = f0C8E_parent_instructions;
                           body.emit(f0C8E);

                           /* END IF */


                        body.instructions = f0C83_parent_instructions;
                        body.emit(f0C83);

                        /* END IF */

                        ir_variable *const r0C91 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0C91);
                        ir_expression *const r0C92 = lshift(r0999, body.constant(int(31)));
                        ir_expression *const r0C93 = expr(ir_unop_i2u, r0C51);
                        ir_expression *const r0C94 = lshift(r0C93, body.constant(int(20)));
                        ir_expression *const r0C95 = add(r0C92, r0C94);
                        body.emit(assign(r0C91, add(r0C95, r0C52), 0x02));

                        body.emit(assign(r0C91, r0C53, 0x01));

                        body.emit(assign(r0C56, r0C91, 0x03));

                        body.emit(assign(r0C55, body.constant(false), 0x01));


                     body.instructions = f0C82_parent_instructions;
                     body.emit(f0C82);

                     /* END IF */

                     body.emit(assign(r099A, r0C56, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0C0A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0C97 = less(r099F, r09A1);
                     ir_if *f0C96 = new(mem_ctx) ir_if(operand(r0C97).val);
                     exec_list *const f0C96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C96->then_instructions;

                        ir_variable *const r0C98 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r0C99 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C99, sub(r09A1, r099F), 0x01));

                        ir_expression *const r0C9A = sub(r09A0, r099E);
                        ir_expression *const r0C9B = less(r09A1, r099F);
                        ir_expression *const r0C9C = expr(ir_unop_b2i, r0C9B);
                        ir_expression *const r0C9D = expr(ir_unop_i2u, r0C9C);
                        body.emit(assign(r0C98, sub(r0C9A, r0C9D), 0x01));

                        body.emit(assign(r09A2, add(r099D, body.constant(int(-1))), 0x01));

                        ir_variable *const r0C9E = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0C9E, add(r09A2, body.constant(int(-10))), 0x01));

                        ir_variable *const r0C9F = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0C9F, r0C98, 0x01));

                        ir_variable *const r0CA0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CA0, r0C99, 0x01));

                        ir_variable *const r0CA1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0CA1);
                        ir_variable *const r0CA2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA2);
                        /* IF CONDITION */
                        ir_expression *const r0CA4 = equal(r0C98, body.constant(0u));
                        ir_if *f0CA3 = new(mem_ctx) ir_if(operand(r0CA4).val);
                        exec_list *const f0CA3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA3->then_instructions;

                           body.emit(assign(r0C9F, r0C99, 0x01));

                           body.emit(assign(r0CA0, body.constant(0u), 0x01));

                           body.emit(assign(r0C9E, add(r0C9E, body.constant(int(-32))), 0x01));


                        body.instructions = f0CA3_parent_instructions;
                        body.emit(f0CA3);

                        /* END IF */

                        ir_variable *const r0CA5 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r0CA5, r0C9F, 0x01));

                        ir_variable *const r0CA6 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r0CA7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA7);
                        /* IF CONDITION */
                        ir_expression *const r0CA9 = equal(r0C9F, body.constant(0u));
                        ir_if *f0CA8 = new(mem_ctx) ir_if(operand(r0CA9).val);
                        exec_list *const f0CA8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA8->then_instructions;

                           body.emit(assign(r0CA6, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CA8->else_instructions;

                           body.emit(assign(r0CA7, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CAB = bit_and(r0C9F, body.constant(4294901760u));
                           ir_expression *const r0CAC = equal(r0CAB, body.constant(0u));
                           ir_if *f0CAA = new(mem_ctx) ir_if(operand(r0CAC).val);
                           exec_list *const f0CAA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAA->then_instructions;

                              body.emit(assign(r0CA7, body.constant(int(16)), 0x01));

                              body.emit(assign(r0CA5, lshift(r0C9F, body.constant(int(16))), 0x01));


                           body.instructions = f0CAA_parent_instructions;
                           body.emit(f0CAA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CAE = bit_and(r0CA5, body.constant(4278190080u));
                           ir_expression *const r0CAF = equal(r0CAE, body.constant(0u));
                           ir_if *f0CAD = new(mem_ctx) ir_if(operand(r0CAF).val);
                           exec_list *const f0CAD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAD->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(8))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(8))), 0x01));


                           body.instructions = f0CAD_parent_instructions;
                           body.emit(f0CAD);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB1 = bit_and(r0CA5, body.constant(4026531840u));
                           ir_expression *const r0CB2 = equal(r0CB1, body.constant(0u));
                           ir_if *f0CB0 = new(mem_ctx) ir_if(operand(r0CB2).val);
                           exec_list *const f0CB0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB0->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(4))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(4))), 0x01));


                           body.instructions = f0CB0_parent_instructions;
                           body.emit(f0CB0);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB4 = bit_and(r0CA5, body.constant(3221225472u));
                           ir_expression *const r0CB5 = equal(r0CB4, body.constant(0u));
                           ir_if *f0CB3 = new(mem_ctx) ir_if(operand(r0CB5).val);
                           exec_list *const f0CB3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB3->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(2))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(2))), 0x01));


                           body.instructions = f0CB3_parent_instructions;
                           body.emit(f0CB3);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB7 = bit_and(r0CA5, body.constant(2147483648u));
                           ir_expression *const r0CB8 = equal(r0CB7, body.constant(0u));
                           ir_if *f0CB6 = new(mem_ctx) ir_if(operand(r0CB8).val);
                           exec_list *const f0CB6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB6->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(1))), 0x01));


                           body.instructions = f0CB6_parent_instructions;
                           body.emit(f0CB6);

                           /* END IF */

                           body.emit(assign(r0CA6, r0CA7, 0x01));


                        body.instructions = f0CA8_parent_instructions;
                        body.emit(f0CA8);

                        /* END IF */

                        body.emit(assign(r0CA2, add(r0CA6, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CBA = lequal(body.constant(int(0)), r0CA2);
                        ir_if *f0CB9 = new(mem_ctx) ir_if(operand(r0CBA).val);
                        exec_list *const f0CB9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CB9->then_instructions;

                           body.emit(assign(r0CA1, body.constant(0u), 0x01));

                           ir_variable *const r0CBB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0CBB, lshift(r0CA0, r0CA2), 0x01));

                           ir_variable *const r0CBC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CBE = equal(r0CA2, body.constant(int(0)));
                           ir_if *f0CBD = new(mem_ctx) ir_if(operand(r0CBE).val);
                           exec_list *const f0CBD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CBD->then_instructions;

                              body.emit(assign(r0CBC, r0C9F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CBD->else_instructions;

                              ir_expression *const r0CBF = lshift(r0C9F, r0CA2);
                              ir_expression *const r0CC0 = neg(r0CA2);
                              ir_expression *const r0CC1 = bit_and(r0CC0, body.constant(int(31)));
                              ir_expression *const r0CC2 = rshift(r0CA0, r0CC1);
                              body.emit(assign(r0CBC, bit_or(r0CBF, r0CC2), 0x01));


                           body.instructions = f0CBD_parent_instructions;
                           body.emit(f0CBD);

                           /* END IF */

                           body.emit(assign(r0C9F, r0CBC, 0x01));

                           body.emit(assign(r0CA0, r0CBB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CB9->else_instructions;

                           ir_variable *const r0CC3 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0CC3, body.constant(0u), 0x01));

                           ir_variable *const r0CC4 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0CC4, neg(r0CA2), 0x01));

                           ir_variable *const r0CC5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0CC5);
                           ir_variable *const r0CC6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0CC6);
                           ir_variable *const r0CC7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0CC7);
                           ir_variable *const r0CC8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0CC9 = neg(r0CC4);
                           body.emit(assign(r0CC8, bit_and(r0CC9, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CCB = equal(r0CC4, body.constant(int(0)));
                           ir_if *f0CCA = new(mem_ctx) ir_if(operand(r0CCB).val);
                           exec_list *const f0CCA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CCA->then_instructions;

                              body.emit(assign(r0CC5, r0CC3, 0x01));

                              body.emit(assign(r0CC6, r0CA0, 0x01));

                              body.emit(assign(r0CC7, r0C9F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CCA->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CCD = less(r0CC4, body.constant(int(32)));
                              ir_if *f0CCC = new(mem_ctx) ir_if(operand(r0CCD).val);
                              exec_list *const f0CCC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CCC->then_instructions;

                                 body.emit(assign(r0CC5, lshift(r0CA0, r0CC8), 0x01));

                                 ir_expression *const r0CCE = lshift(r0C9F, r0CC8);
                                 ir_expression *const r0CCF = rshift(r0CA0, r0CC4);
                                 body.emit(assign(r0CC6, bit_or(r0CCE, r0CCF), 0x01));

                                 body.emit(assign(r0CC7, rshift(r0C9F, r0CC4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CCC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0CD1 = equal(r0CC4, body.constant(int(32)));
                                 ir_if *f0CD0 = new(mem_ctx) ir_if(operand(r0CD1).val);
                                 exec_list *const f0CD0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CD0->then_instructions;

                                    body.emit(assign(r0CC5, r0CA0, 0x01));

                                    body.emit(assign(r0CC6, r0C9F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CD0->else_instructions;

                                    body.emit(assign(r0CC3, bit_or(body.constant(0u), r0CA0), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0CD3 = less(r0CC4, body.constant(int(64)));
                                    ir_if *f0CD2 = new(mem_ctx) ir_if(operand(r0CD3).val);
                                    exec_list *const f0CD2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CD2->then_instructions;

                                       body.emit(assign(r0CC5, lshift(r0C9F, r0CC8), 0x01));

                                       ir_expression *const r0CD4 = bit_and(r0CC4, body.constant(int(31)));
                                       body.emit(assign(r0CC6, rshift(r0C9F, r0CD4), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CD2->else_instructions;

                                       ir_variable *const r0CD5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0CD7 = equal(r0CC4, body.constant(int(64)));
                                       ir_if *f0CD6 = new(mem_ctx) ir_if(operand(r0CD7).val);
                                       exec_list *const f0CD6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0CD6->then_instructions;

                                          body.emit(assign(r0CD5, r0C9F, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0CD6->else_instructions;

                                          ir_expression *const r0CD8 = nequal(r0C9F, body.constant(0u));
                                          ir_expression *const r0CD9 = expr(ir_unop_b2i, r0CD8);
                                          body.emit(assign(r0CD5, expr(ir_unop_i2u, r0CD9), 0x01));


                                       body.instructions = f0CD6_parent_instructions;
                                       body.emit(f0CD6);

                                       /* END IF */

                                       body.emit(assign(r0CC5, r0CD5, 0x01));

                                       body.emit(assign(r0CC6, body.constant(0u), 0x01));


                                    body.instructions = f0CD2_parent_instructions;
                                    body.emit(f0CD2);

                                    /* END IF */


                                 body.instructions = f0CD0_parent_instructions;
                                 body.emit(f0CD0);

                                 /* END IF */

                                 body.emit(assign(r0CC7, body.constant(0u), 0x01));


                              body.instructions = f0CCC_parent_instructions;
                              body.emit(f0CCC);

                              /* END IF */

                              ir_expression *const r0CDA = nequal(r0CC3, body.constant(0u));
                              ir_expression *const r0CDB = expr(ir_unop_b2i, r0CDA);
                              ir_expression *const r0CDC = expr(ir_unop_i2u, r0CDB);
                              body.emit(assign(r0CC5, bit_or(r0CC5, r0CDC), 0x01));


                           body.instructions = f0CCA_parent_instructions;
                           body.emit(f0CCA);

                           /* END IF */

                           body.emit(assign(r0C9F, r0CC7, 0x01));

                           body.emit(assign(r0CA0, r0CC6, 0x01));

                           body.emit(assign(r0CA1, r0CC5, 0x01));


                        body.instructions = f0CB9_parent_instructions;
                        body.emit(f0CB9);

                        /* END IF */

                        body.emit(assign(r0C9E, sub(r0C9E, r0CA2), 0x01));

                        ir_variable *const r0CDD = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0CDD, r0C9E, 0x01));

                        ir_variable *const r0CDE = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0CDE, r0C9F, 0x01));

                        ir_variable *const r0CDF = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CDF, r0CA0, 0x01));

                        ir_variable *const r0CE0 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r0CE0, r0CA1, 0x01));

                        ir_variable *const r0CE1 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r0CE1, body.constant(true), 0x01));

                        ir_variable *const r0CE2 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r0CE3 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r0CE3);
                        ir_expression *const r0CE4 = expr(ir_unop_u2i, r0CA1);
                        body.emit(assign(r0CE3, less(r0CE4, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CE6 = lequal(body.constant(int(2045)), r0C9E);
                        ir_if *f0CE5 = new(mem_ctx) ir_if(operand(r0CE6).val);
                        exec_list *const f0CE5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CE5->then_instructions;

                           ir_variable *const r0CE7 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CE9 = less(body.constant(int(2045)), r0C9E);
                           ir_if *f0CE8 = new(mem_ctx) ir_if(operand(r0CE9).val);
                           exec_list *const f0CE8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CE8->then_instructions;

                              body.emit(assign(r0CE7, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CE8->else_instructions;

                              ir_variable *const r0CEA = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0CEC = equal(r0C9E, body.constant(int(2045)));
                              ir_if *f0CEB = new(mem_ctx) ir_if(operand(r0CEC).val);
                              exec_list *const f0CEB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CEB->then_instructions;

                                 ir_expression *const r0CED = equal(body.constant(2097151u), r0C9F);
                                 ir_expression *const r0CEE = equal(body.constant(4294967295u), r0CA0);
                                 body.emit(assign(r0CEA, logic_and(r0CED, r0CEE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CEB->else_instructions;

                                 body.emit(assign(r0CEA, body.constant(false), 0x01));


                              body.instructions = f0CEB_parent_instructions;
                              body.emit(f0CEB);

                              /* END IF */

                              body.emit(assign(r0CE7, logic_and(r0CEA, r0CE3), 0x01));


                           body.instructions = f0CE8_parent_instructions;
                           body.emit(f0CE8);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0CEF = new(mem_ctx) ir_if(operand(r0CE7).val);
                           exec_list *const f0CEF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CEF->then_instructions;

                              ir_variable *const r0CF0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0CF0);
                              ir_expression *const r0CF1 = lshift(r0999, body.constant(int(31)));
                              body.emit(assign(r0CF0, add(r0CF1, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r0CF0, body.constant(0u), 0x01));

                              body.emit(assign(r0CE2, r0CF0, 0x03));

                              body.emit(assign(r0CE1, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CEF->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CF3 = less(r0C9E, body.constant(int(0)));
                              ir_if *f0CF2 = new(mem_ctx) ir_if(operand(r0CF3).val);
                              exec_list *const f0CF2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CF2->then_instructions;

                                 ir_variable *const r0CF4 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r0CF4, r0CA1, 0x01));

                                 ir_variable *const r0CF5 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r0CF5, neg(r0C9E), 0x01));

                                 ir_variable *const r0CF6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r0CF6);
                                 ir_variable *const r0CF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r0CF7);
                                 ir_variable *const r0CF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r0CF8);
                                 ir_variable *const r0CF9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r0CFA = neg(r0CF5);
                                 body.emit(assign(r0CF9, bit_and(r0CFA, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0CFC = equal(r0CF5, body.constant(int(0)));
                                 ir_if *f0CFB = new(mem_ctx) ir_if(operand(r0CFC).val);
                                 exec_list *const f0CFB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CFB->then_instructions;

                                    body.emit(assign(r0CF6, r0CA1, 0x01));

                                    body.emit(assign(r0CF7, r0CA0, 0x01));

                                    body.emit(assign(r0CF8, r0C9F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CFB->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0CFE = less(r0CF5, body.constant(int(32)));
                                    ir_if *f0CFD = new(mem_ctx) ir_if(operand(r0CFE).val);
                                    exec_list *const f0CFD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CFD->then_instructions;

                                       body.emit(assign(r0CF6, lshift(r0CA0, r0CF9), 0x01));

                                       ir_expression *const r0CFF = lshift(r0C9F, r0CF9);
                                       ir_expression *const r0D00 = rshift(r0CA0, r0CF5);
                                       body.emit(assign(r0CF7, bit_or(r0CFF, r0D00), 0x01));

                                       body.emit(assign(r0CF8, rshift(r0C9F, r0CF5), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CFD->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D02 = equal(r0CF5, body.constant(int(32)));
                                       ir_if *f0D01 = new(mem_ctx) ir_if(operand(r0D02).val);
                                       exec_list *const f0D01_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D01->then_instructions;

                                          body.emit(assign(r0CF6, r0CA0, 0x01));

                                          body.emit(assign(r0CF7, r0C9F, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D01->else_instructions;

                                          body.emit(assign(r0CF4, bit_or(r0CA1, r0CA0), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r0D04 = less(r0CF5, body.constant(int(64)));
                                          ir_if *f0D03 = new(mem_ctx) ir_if(operand(r0D04).val);
                                          exec_list *const f0D03_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D03->then_instructions;

                                             body.emit(assign(r0CF6, lshift(r0C9F, r0CF9), 0x01));

                                             ir_expression *const r0D05 = bit_and(r0CF5, body.constant(int(31)));
                                             body.emit(assign(r0CF7, rshift(r0C9F, r0D05), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D03->else_instructions;

                                             ir_variable *const r0D06 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r0D08 = equal(r0CF5, body.constant(int(64)));
                                             ir_if *f0D07 = new(mem_ctx) ir_if(operand(r0D08).val);
                                             exec_list *const f0D07_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D07->then_instructions;

                                                body.emit(assign(r0D06, r0C9F, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D07->else_instructions;

                                                ir_expression *const r0D09 = nequal(r0C9F, body.constant(0u));
                                                ir_expression *const r0D0A = expr(ir_unop_b2i, r0D09);
                                                body.emit(assign(r0D06, expr(ir_unop_i2u, r0D0A), 0x01));


                                             body.instructions = f0D07_parent_instructions;
                                             body.emit(f0D07);

                                             /* END IF */

                                             body.emit(assign(r0CF6, r0D06, 0x01));

                                             body.emit(assign(r0CF7, body.constant(0u), 0x01));


                                          body.instructions = f0D03_parent_instructions;
                                          body.emit(f0D03);

                                          /* END IF */


                                       body.instructions = f0D01_parent_instructions;
                                       body.emit(f0D01);

                                       /* END IF */

                                       body.emit(assign(r0CF8, body.constant(0u), 0x01));


                                    body.instructions = f0CFD_parent_instructions;
                                    body.emit(f0CFD);

                                    /* END IF */

                                    ir_expression *const r0D0B = nequal(r0CF4, body.constant(0u));
                                    ir_expression *const r0D0C = expr(ir_unop_b2i, r0D0B);
                                    ir_expression *const r0D0D = expr(ir_unop_i2u, r0D0C);
                                    body.emit(assign(r0CF6, bit_or(r0CF6, r0D0D), 0x01));


                                 body.instructions = f0CFB_parent_instructions;
                                 body.emit(f0CFB);

                                 /* END IF */

                                 body.emit(assign(r0CDE, r0CF8, 0x01));

                                 body.emit(assign(r0CDF, r0CF7, 0x01));

                                 body.emit(assign(r0CE0, r0CF6, 0x01));

                                 body.emit(assign(r0CDD, body.constant(int(0)), 0x01));

                                 body.emit(assign(r0CE3, less(r0CF6, body.constant(0u)), 0x01));


                              body.instructions = f0CF2_parent_instructions;
                              body.emit(f0CF2);

                              /* END IF */


                           body.instructions = f0CEF_parent_instructions;
                           body.emit(f0CEF);

                           /* END IF */


                        body.instructions = f0CE5_parent_instructions;
                        body.emit(f0CE5);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0D0E = new(mem_ctx) ir_if(operand(r0CE1).val);
                        exec_list *const f0D0E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D0E->then_instructions;

                           /* IF CONDITION */
                           ir_if *f0D0F = new(mem_ctx) ir_if(operand(r0CE3).val);
                           exec_list *const f0D0F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D0F->then_instructions;

                              ir_variable *const r0D10 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r0D10, add(r0CDF, body.constant(1u)), 0x01));

                              ir_expression *const r0D11 = less(r0D10, r0CDF);
                              ir_expression *const r0D12 = expr(ir_unop_b2i, r0D11);
                              ir_expression *const r0D13 = expr(ir_unop_i2u, r0D12);
                              body.emit(assign(r0CDE, add(r0CDE, r0D13), 0x01));

                              ir_expression *const r0D14 = equal(r0CE0, body.constant(0u));
                              ir_expression *const r0D15 = expr(ir_unop_b2i, r0D14);
                              ir_expression *const r0D16 = expr(ir_unop_i2u, r0D15);
                              ir_expression *const r0D17 = add(r0CE0, r0D16);
                              ir_expression *const r0D18 = bit_and(r0D17, body.constant(1u));
                              ir_expression *const r0D19 = expr(ir_unop_bit_not, r0D18);
                              body.emit(assign(r0CDF, bit_and(r0D10, r0D19), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D0F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0D1B = bit_or(r0CDE, r0CDF);
                              ir_expression *const r0D1C = equal(r0D1B, body.constant(0u));
                              ir_if *f0D1A = new(mem_ctx) ir_if(operand(r0D1C).val);
                              exec_list *const f0D1A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D1A->then_instructions;

                                 body.emit(assign(r0CDD, body.constant(int(0)), 0x01));


                              body.instructions = f0D1A_parent_instructions;
                              body.emit(f0D1A);

                              /* END IF */


                           body.instructions = f0D0F_parent_instructions;
                           body.emit(f0D0F);

                           /* END IF */

                           ir_variable *const r0D1D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0D1D);
                           ir_expression *const r0D1E = lshift(r0999, body.constant(int(31)));
                           ir_expression *const r0D1F = expr(ir_unop_i2u, r0CDD);
                           ir_expression *const r0D20 = lshift(r0D1F, body.constant(int(20)));
                           ir_expression *const r0D21 = add(r0D1E, r0D20);
                           body.emit(assign(r0D1D, add(r0D21, r0CDE), 0x02));

                           body.emit(assign(r0D1D, r0CDF, 0x01));

                           body.emit(assign(r0CE2, r0D1D, 0x03));

                           body.emit(assign(r0CE1, body.constant(false), 0x01));


                        body.instructions = f0D0E_parent_instructions;
                        body.emit(f0D0E);

                        /* END IF */

                        body.emit(assign(r099A, r0CE2, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C96->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0D23 = less(r09A1, r099F);
                        ir_if *f0D22 = new(mem_ctx) ir_if(operand(r0D23).val);
                        exec_list *const f0D22_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D22->then_instructions;

                           ir_variable *const r0D24 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r0D25 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0D25, sub(r099F, r09A1), 0x01));

                           ir_expression *const r0D26 = sub(r099E, r09A0);
                           ir_expression *const r0D27 = less(r099F, r09A1);
                           ir_expression *const r0D28 = expr(ir_unop_b2i, r0D27);
                           ir_expression *const r0D29 = expr(ir_unop_i2u, r0D28);
                           body.emit(assign(r0D24, sub(r0D26, r0D29), 0x01));

                           body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                           body.emit(assign(r09A2, add(r099C, body.constant(int(-1))), 0x01));

                           ir_variable *const r0D2A = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D2A, add(r09A2, body.constant(int(-10))), 0x01));

                           ir_variable *const r0D2B = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D2B, r0D24, 0x01));

                           ir_variable *const r0D2C = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D2C, r0D25, 0x01));

                           ir_variable *const r0D2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r0D2D);
                           ir_variable *const r0D2E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D2E);
                           /* IF CONDITION */
                           ir_expression *const r0D30 = equal(r0D24, body.constant(0u));
                           ir_if *f0D2F = new(mem_ctx) ir_if(operand(r0D30).val);
                           exec_list *const f0D2F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D2F->then_instructions;

                              body.emit(assign(r0D2B, r0D25, 0x01));

                              body.emit(assign(r0D2C, body.constant(0u), 0x01));

                              body.emit(assign(r0D2A, add(r0D2A, body.constant(int(-32))), 0x01));


                           body.instructions = f0D2F_parent_instructions;
                           body.emit(f0D2F);

                           /* END IF */

                           ir_variable *const r0D31 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r0D31, r0D2B, 0x01));

                           ir_variable *const r0D32 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r0D33 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D33);
                           /* IF CONDITION */
                           ir_expression *const r0D35 = equal(r0D2B, body.constant(0u));
                           ir_if *f0D34 = new(mem_ctx) ir_if(operand(r0D35).val);
                           exec_list *const f0D34_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D34->then_instructions;

                              body.emit(assign(r0D32, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D34->else_instructions;

                              body.emit(assign(r0D33, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D37 = bit_and(r0D2B, body.constant(4294901760u));
                              ir_expression *const r0D38 = equal(r0D37, body.constant(0u));
                              ir_if *f0D36 = new(mem_ctx) ir_if(operand(r0D38).val);
                              exec_list *const f0D36_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D36->then_instructions;

                                 body.emit(assign(r0D33, body.constant(int(16)), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D2B, body.constant(int(16))), 0x01));


                              body.instructions = f0D36_parent_instructions;
                              body.emit(f0D36);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3A = bit_and(r0D31, body.constant(4278190080u));
                              ir_expression *const r0D3B = equal(r0D3A, body.constant(0u));
                              ir_if *f0D39 = new(mem_ctx) ir_if(operand(r0D3B).val);
                              exec_list *const f0D39_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D39->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(8))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(8))), 0x01));


                              body.instructions = f0D39_parent_instructions;
                              body.emit(f0D39);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3D = bit_and(r0D31, body.constant(4026531840u));
                              ir_expression *const r0D3E = equal(r0D3D, body.constant(0u));
                              ir_if *f0D3C = new(mem_ctx) ir_if(operand(r0D3E).val);
                              exec_list *const f0D3C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3C->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(4))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(4))), 0x01));


                              body.instructions = f0D3C_parent_instructions;
                              body.emit(f0D3C);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D40 = bit_and(r0D31, body.constant(3221225472u));
                              ir_expression *const r0D41 = equal(r0D40, body.constant(0u));
                              ir_if *f0D3F = new(mem_ctx) ir_if(operand(r0D41).val);
                              exec_list *const f0D3F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3F->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(2))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(2))), 0x01));


                              body.instructions = f0D3F_parent_instructions;
                              body.emit(f0D3F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D43 = bit_and(r0D31, body.constant(2147483648u));
                              ir_expression *const r0D44 = equal(r0D43, body.constant(0u));
                              ir_if *f0D42 = new(mem_ctx) ir_if(operand(r0D44).val);
                              exec_list *const f0D42_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D42->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(1))), 0x01));


                              body.instructions = f0D42_parent_instructions;
                              body.emit(f0D42);

                              /* END IF */

                              body.emit(assign(r0D32, r0D33, 0x01));


                           body.instructions = f0D34_parent_instructions;
                           body.emit(f0D34);

                           /* END IF */

                           body.emit(assign(r0D2E, add(r0D32, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D46 = lequal(body.constant(int(0)), r0D2E);
                           ir_if *f0D45 = new(mem_ctx) ir_if(operand(r0D46).val);
                           exec_list *const f0D45_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D45->then_instructions;

                              body.emit(assign(r0D2D, body.constant(0u), 0x01));

                              ir_variable *const r0D47 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r0D47, lshift(r0D2C, r0D2E), 0x01));

                              ir_variable *const r0D48 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D4A = equal(r0D2E, body.constant(int(0)));
                              ir_if *f0D49 = new(mem_ctx) ir_if(operand(r0D4A).val);
                              exec_list *const f0D49_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D49->then_instructions;

                                 body.emit(assign(r0D48, r0D2B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D49->else_instructions;

                                 ir_expression *const r0D4B = lshift(r0D2B, r0D2E);
                                 ir_expression *const r0D4C = neg(r0D2E);
                                 ir_expression *const r0D4D = bit_and(r0D4C, body.constant(int(31)));
                                 ir_expression *const r0D4E = rshift(r0D2C, r0D4D);
                                 body.emit(assign(r0D48, bit_or(r0D4B, r0D4E), 0x01));


                              body.instructions = f0D49_parent_instructions;
                              body.emit(f0D49);

                              /* END IF */

                              body.emit(assign(r0D2B, r0D48, 0x01));

                              body.emit(assign(r0D2C, r0D47, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D45->else_instructions;

                              ir_variable *const r0D4F = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0D4F, body.constant(0u), 0x01));

                              ir_variable *const r0D50 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0D50, neg(r0D2E), 0x01));

                              ir_variable *const r0D51 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0D51);
                              ir_variable *const r0D52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0D52);
                              ir_variable *const r0D53 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0D53);
                              ir_variable *const r0D54 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0D55 = neg(r0D50);
                              body.emit(assign(r0D54, bit_and(r0D55, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D57 = equal(r0D50, body.constant(int(0)));
                              ir_if *f0D56 = new(mem_ctx) ir_if(operand(r0D57).val);
                              exec_list *const f0D56_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D56->then_instructions;

                                 body.emit(assign(r0D51, r0D4F, 0x01));

                                 body.emit(assign(r0D52, r0D2C, 0x01));

                                 body.emit(assign(r0D53, r0D2B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D56->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D59 = less(r0D50, body.constant(int(32)));
                                 ir_if *f0D58 = new(mem_ctx) ir_if(operand(r0D59).val);
                                 exec_list *const f0D58_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D58->then_instructions;

                                    body.emit(assign(r0D51, lshift(r0D2C, r0D54), 0x01));

                                    ir_expression *const r0D5A = lshift(r0D2B, r0D54);
                                    ir_expression *const r0D5B = rshift(r0D2C, r0D50);
                                    body.emit(assign(r0D52, bit_or(r0D5A, r0D5B), 0x01));

                                    body.emit(assign(r0D53, rshift(r0D2B, r0D50), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D58->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0D5D = equal(r0D50, body.constant(int(32)));
                                    ir_if *f0D5C = new(mem_ctx) ir_if(operand(r0D5D).val);
                                    exec_list *const f0D5C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D5C->then_instructions;

                                       body.emit(assign(r0D51, r0D2C, 0x01));

                                       body.emit(assign(r0D52, r0D2B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D5C->else_instructions;

                                       body.emit(assign(r0D4F, bit_or(body.constant(0u), r0D2C), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0D5F = less(r0D50, body.constant(int(64)));
                                       ir_if *f0D5E = new(mem_ctx) ir_if(operand(r0D5F).val);
                                       exec_list *const f0D5E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D5E->then_instructions;

                                          body.emit(assign(r0D51, lshift(r0D2B, r0D54), 0x01));

                                          ir_expression *const r0D60 = bit_and(r0D50, body.constant(int(31)));
                                          body.emit(assign(r0D52, rshift(r0D2B, r0D60), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D5E->else_instructions;

                                          ir_variable *const r0D61 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0D63 = equal(r0D50, body.constant(int(64)));
                                          ir_if *f0D62 = new(mem_ctx) ir_if(operand(r0D63).val);
                                          exec_list *const f0D62_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D62->then_instructions;

                                             body.emit(assign(r0D61, r0D2B, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D62->else_instructions;

                                             ir_expression *const r0D64 = nequal(r0D2B, body.constant(0u));
                                             ir_expression *const r0D65 = expr(ir_unop_b2i, r0D64);
                                             body.emit(assign(r0D61, expr(ir_unop_i2u, r0D65), 0x01));


                                          body.instructions = f0D62_parent_instructions;
                                          body.emit(f0D62);

                                          /* END IF */

                                          body.emit(assign(r0D51, r0D61, 0x01));

                                          body.emit(assign(r0D52, body.constant(0u), 0x01));


                                       body.instructions = f0D5E_parent_instructions;
                                       body.emit(f0D5E);

                                       /* END IF */


                                    body.instructions = f0D5C_parent_instructions;
                                    body.emit(f0D5C);

                                    /* END IF */

                                    body.emit(assign(r0D53, body.constant(0u), 0x01));


                                 body.instructions = f0D58_parent_instructions;
                                 body.emit(f0D58);

                                 /* END IF */

                                 ir_expression *const r0D66 = nequal(r0D4F, body.constant(0u));
                                 ir_expression *const r0D67 = expr(ir_unop_b2i, r0D66);
                                 ir_expression *const r0D68 = expr(ir_unop_i2u, r0D67);
                                 body.emit(assign(r0D51, bit_or(r0D51, r0D68), 0x01));


                              body.instructions = f0D56_parent_instructions;
                              body.emit(f0D56);

                              /* END IF */

                              body.emit(assign(r0D2B, r0D53, 0x01));

                              body.emit(assign(r0D2C, r0D52, 0x01));

                              body.emit(assign(r0D2D, r0D51, 0x01));


                           body.instructions = f0D45_parent_instructions;
                           body.emit(f0D45);

                           /* END IF */

                           body.emit(assign(r0D2A, sub(r0D2A, r0D2E), 0x01));

                           ir_variable *const r0D69 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D69, r0D2A, 0x01));

                           ir_variable *const r0D6A = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D6A, r0D2B, 0x01));

                           ir_variable *const r0D6B = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D6B, r0D2C, 0x01));

                           ir_variable *const r0D6C = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r0D6C, r0D2D, 0x01));

                           ir_variable *const r0D6D = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r0D6D, body.constant(true), 0x01));

                           ir_variable *const r0D6E = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r0D6F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r0D6F);
                           ir_expression *const r0D70 = expr(ir_unop_u2i, r0D2D);
                           body.emit(assign(r0D6F, less(r0D70, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D72 = lequal(body.constant(int(2045)), r0D2A);
                           ir_if *f0D71 = new(mem_ctx) ir_if(operand(r0D72).val);
                           exec_list *const f0D71_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D71->then_instructions;

                              ir_variable *const r0D73 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D75 = less(body.constant(int(2045)), r0D2A);
                              ir_if *f0D74 = new(mem_ctx) ir_if(operand(r0D75).val);
                              exec_list *const f0D74_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D74->then_instructions;

                                 body.emit(assign(r0D73, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D74->else_instructions;

                                 ir_variable *const r0D76 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0D78 = equal(r0D2A, body.constant(int(2045)));
                                 ir_if *f0D77 = new(mem_ctx) ir_if(operand(r0D78).val);
                                 exec_list *const f0D77_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D77->then_instructions;

                                    ir_expression *const r0D79 = equal(body.constant(2097151u), r0D2B);
                                    ir_expression *const r0D7A = equal(body.constant(4294967295u), r0D2C);
                                    body.emit(assign(r0D76, logic_and(r0D79, r0D7A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D77->else_instructions;

                                    body.emit(assign(r0D76, body.constant(false), 0x01));


                                 body.instructions = f0D77_parent_instructions;
                                 body.emit(f0D77);

                                 /* END IF */

                                 body.emit(assign(r0D73, logic_and(r0D76, r0D6F), 0x01));


                              body.instructions = f0D74_parent_instructions;
                              body.emit(f0D74);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f0D7B = new(mem_ctx) ir_if(operand(r0D73).val);
                              exec_list *const f0D7B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D7B->then_instructions;

                                 ir_variable *const r0D7C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r0D7C);
                                 ir_expression *const r0D7D = lshift(r0999, body.constant(int(31)));
                                 body.emit(assign(r0D7C, add(r0D7D, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r0D7C, body.constant(0u), 0x01));

                                 body.emit(assign(r0D6E, r0D7C, 0x03));

                                 body.emit(assign(r0D6D, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D7B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D7F = less(r0D2A, body.constant(int(0)));
                                 ir_if *f0D7E = new(mem_ctx) ir_if(operand(r0D7F).val);
                                 exec_list *const f0D7E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D7E->then_instructions;

                                    ir_variable *const r0D80 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r0D80, r0D2D, 0x01));

                                    ir_variable *const r0D81 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r0D81, neg(r0D2A), 0x01));

                                    ir_variable *const r0D82 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r0D82);
                                    ir_variable *const r0D83 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r0D83);
                                    ir_variable *const r0D84 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r0D84);
                                    ir_variable *const r0D85 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r0D86 = neg(r0D81);
                                    body.emit(assign(r0D85, bit_and(r0D86, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0D88 = equal(r0D81, body.constant(int(0)));
                                    ir_if *f0D87 = new(mem_ctx) ir_if(operand(r0D88).val);
                                    exec_list *const f0D87_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D87->then_instructions;

                                       body.emit(assign(r0D82, r0D2D, 0x01));

                                       body.emit(assign(r0D83, r0D2C, 0x01));

                                       body.emit(assign(r0D84, r0D2B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D87->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D8A = less(r0D81, body.constant(int(32)));
                                       ir_if *f0D89 = new(mem_ctx) ir_if(operand(r0D8A).val);
                                       exec_list *const f0D89_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D89->then_instructions;

                                          body.emit(assign(r0D82, lshift(r0D2C, r0D85), 0x01));

                                          ir_expression *const r0D8B = lshift(r0D2B, r0D85);
                                          ir_expression *const r0D8C = rshift(r0D2C, r0D81);
                                          body.emit(assign(r0D83, bit_or(r0D8B, r0D8C), 0x01));

                                          body.emit(assign(r0D84, rshift(r0D2B, r0D81), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D89->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r0D8E = equal(r0D81, body.constant(int(32)));
                                          ir_if *f0D8D = new(mem_ctx) ir_if(operand(r0D8E).val);
                                          exec_list *const f0D8D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D8D->then_instructions;

                                             body.emit(assign(r0D82, r0D2C, 0x01));

                                             body.emit(assign(r0D83, r0D2B, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D8D->else_instructions;

                                             body.emit(assign(r0D80, bit_or(r0D2D, r0D2C), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r0D90 = less(r0D81, body.constant(int(64)));
                                             ir_if *f0D8F = new(mem_ctx) ir_if(operand(r0D90).val);
                                             exec_list *const f0D8F_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D8F->then_instructions;

                                                body.emit(assign(r0D82, lshift(r0D2B, r0D85), 0x01));

                                                ir_expression *const r0D91 = bit_and(r0D81, body.constant(int(31)));
                                                body.emit(assign(r0D83, rshift(r0D2B, r0D91), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D8F->else_instructions;

                                                ir_variable *const r0D92 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r0D94 = equal(r0D81, body.constant(int(64)));
                                                ir_if *f0D93 = new(mem_ctx) ir_if(operand(r0D94).val);
                                                exec_list *const f0D93_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f0D93->then_instructions;

                                                   body.emit(assign(r0D92, r0D2B, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f0D93->else_instructions;

                                                   ir_expression *const r0D95 = nequal(r0D2B, body.constant(0u));
                                                   ir_expression *const r0D96 = expr(ir_unop_b2i, r0D95);
                                                   body.emit(assign(r0D92, expr(ir_unop_i2u, r0D96), 0x01));


                                                body.instructions = f0D93_parent_instructions;
                                                body.emit(f0D93);

                                                /* END IF */

                                                body.emit(assign(r0D82, r0D92, 0x01));

                                                body.emit(assign(r0D83, body.constant(0u), 0x01));


                                             body.instructions = f0D8F_parent_instructions;
                                             body.emit(f0D8F);

                                             /* END IF */


                                          body.instructions = f0D8D_parent_instructions;
                                          body.emit(f0D8D);

                                          /* END IF */

                                          body.emit(assign(r0D84, body.constant(0u), 0x01));


                                       body.instructions = f0D89_parent_instructions;
                                       body.emit(f0D89);

                                       /* END IF */

                                       ir_expression *const r0D97 = nequal(r0D80, body.constant(0u));
                                       ir_expression *const r0D98 = expr(ir_unop_b2i, r0D97);
                                       ir_expression *const r0D99 = expr(ir_unop_i2u, r0D98);
                                       body.emit(assign(r0D82, bit_or(r0D82, r0D99), 0x01));


                                    body.instructions = f0D87_parent_instructions;
                                    body.emit(f0D87);

                                    /* END IF */

                                    body.emit(assign(r0D6A, r0D84, 0x01));

                                    body.emit(assign(r0D6B, r0D83, 0x01));

                                    body.emit(assign(r0D6C, r0D82, 0x01));

                                    body.emit(assign(r0D69, body.constant(int(0)), 0x01));

                                    body.emit(assign(r0D6F, less(r0D82, body.constant(0u)), 0x01));


                                 body.instructions = f0D7E_parent_instructions;
                                 body.emit(f0D7E);

                                 /* END IF */


                              body.instructions = f0D7B_parent_instructions;
                              body.emit(f0D7B);

                              /* END IF */


                           body.instructions = f0D71_parent_instructions;
                           body.emit(f0D71);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0D9A = new(mem_ctx) ir_if(operand(r0D6D).val);
                           exec_list *const f0D9A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D9A->then_instructions;

                              /* IF CONDITION */
                              ir_if *f0D9B = new(mem_ctx) ir_if(operand(r0D6F).val);
                              exec_list *const f0D9B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D9B->then_instructions;

                                 ir_variable *const r0D9C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r0D9C, add(r0D6B, body.constant(1u)), 0x01));

                                 ir_expression *const r0D9D = less(r0D9C, r0D6B);
                                 ir_expression *const r0D9E = expr(ir_unop_b2i, r0D9D);
                                 ir_expression *const r0D9F = expr(ir_unop_i2u, r0D9E);
                                 body.emit(assign(r0D6A, add(r0D6A, r0D9F), 0x01));

                                 ir_expression *const r0DA0 = equal(r0D6C, body.constant(0u));
                                 ir_expression *const r0DA1 = expr(ir_unop_b2i, r0DA0);
                                 ir_expression *const r0DA2 = expr(ir_unop_i2u, r0DA1);
                                 ir_expression *const r0DA3 = add(r0D6C, r0DA2);
                                 ir_expression *const r0DA4 = bit_and(r0DA3, body.constant(1u));
                                 ir_expression *const r0DA5 = expr(ir_unop_bit_not, r0DA4);
                                 body.emit(assign(r0D6B, bit_and(r0D9C, r0DA5), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D9B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0DA7 = bit_or(r0D6A, r0D6B);
                                 ir_expression *const r0DA8 = equal(r0DA7, body.constant(0u));
                                 ir_if *f0DA6 = new(mem_ctx) ir_if(operand(r0DA8).val);
                                 exec_list *const f0DA6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0DA6->then_instructions;

                                    body.emit(assign(r0D69, body.constant(int(0)), 0x01));


                                 body.instructions = f0DA6_parent_instructions;
                                 body.emit(f0DA6);

                                 /* END IF */


                              body.instructions = f0D9B_parent_instructions;
                              body.emit(f0D9B);

                              /* END IF */

                              ir_variable *const r0DA9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0DA9);
                              ir_expression *const r0DAA = lshift(r0999, body.constant(int(31)));
                              ir_expression *const r0DAB = expr(ir_unop_i2u, r0D69);
                              ir_expression *const r0DAC = lshift(r0DAB, body.constant(int(20)));
                              ir_expression *const r0DAD = add(r0DAA, r0DAC);
                              body.emit(assign(r0DA9, add(r0DAD, r0D6A), 0x02));

                              body.emit(assign(r0DA9, r0D6B, 0x01));

                              body.emit(assign(r0D6E, r0DA9, 0x03));

                              body.emit(assign(r0D6D, body.constant(false), 0x01));


                           body.instructions = f0D9A_parent_instructions;
                           body.emit(f0D9A);

                           /* END IF */

                           body.emit(assign(r099A, r0D6E, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0D22->else_instructions;

                           ir_variable *const r0DAE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0DAE);
                           body.emit(assign(r0DAE, body.constant(0u), 0x02));

                           body.emit(assign(r0DAE, body.constant(0u), 0x01));

                           body.emit(assign(r099A, r0DAE, 0x03));


                        body.instructions = f0D22_parent_instructions;
                        body.emit(f0D22);

                        /* END IF */


                     body.instructions = f0C96_parent_instructions;
                     body.emit(f0C96);

                     /* END IF */


                  body.instructions = f0C0A_parent_instructions;
                  body.emit(f0C0A);

                  /* END IF */


               body.instructions = f0B7E_parent_instructions;
               body.emit(f0B7E);

               /* END IF */


            body.instructions = f0B57_parent_instructions;
            body.emit(f0B57);

            /* END IF */


         body.instructions = f0A83_parent_instructions;
         body.emit(f0A83);

         /* END IF */


      body.instructions = f09B3_parent_instructions;
      body.emit(f09B3);

      /* END IF */

      body.emit(assign(r07EB, r099A, 0x03));


   body.instructions = f07EE_parent_instructions;
   body.emit(f07EE);

   /* END IF */

   body.emit(ret(r07EB));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul32To64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0DAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0DAF);
   ir_variable *const r0DB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0DB0);
   ir_variable *const r0DB1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DB1);
   ir_variable *const r0DB2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DB2);
   ir_variable *const r0DB3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0DB3);
   ir_variable *const r0DB4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0DB4);
   ir_variable *const r0DB5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0DB5);
   ir_variable *const r0DB6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DB6, bit_and(r0DAF, body.constant(65535u)), 0x01));

   ir_variable *const r0DB7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DB7, rshift(r0DAF, body.constant(int(16))), 0x01));

   ir_variable *const r0DB8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DB8, bit_and(r0DB0, body.constant(65535u)), 0x01));

   ir_variable *const r0DB9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DB9, rshift(r0DB0, body.constant(int(16))), 0x01));

   ir_variable *const r0DBA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DBA, mul(r0DB7, r0DB8), 0x01));

   ir_expression *const r0DBB = mul(r0DB6, r0DB9);
   body.emit(assign(r0DB4, add(r0DBB, r0DBA), 0x01));

   ir_expression *const r0DBC = mul(r0DB7, r0DB9);
   ir_expression *const r0DBD = less(r0DB4, r0DBA);
   ir_expression *const r0DBE = expr(ir_unop_b2i, r0DBD);
   ir_expression *const r0DBF = expr(ir_unop_i2u, r0DBE);
   ir_expression *const r0DC0 = lshift(r0DBF, body.constant(int(16)));
   ir_expression *const r0DC1 = rshift(r0DB4, body.constant(int(16)));
   ir_expression *const r0DC2 = add(r0DC0, r0DC1);
   body.emit(assign(r0DB3, add(r0DBC, r0DC2), 0x01));

   body.emit(assign(r0DB4, lshift(r0DB4, body.constant(int(16))), 0x01));

   ir_expression *const r0DC3 = mul(r0DB6, r0DB8);
   body.emit(assign(r0DB5, add(r0DC3, r0DB4), 0x01));

   ir_expression *const r0DC4 = less(r0DB5, r0DB4);
   ir_expression *const r0DC5 = expr(ir_unop_b2i, r0DC4);
   ir_expression *const r0DC6 = expr(ir_unop_i2u, r0DC5);
   body.emit(assign(r0DB3, add(r0DB3, r0DC6), 0x01));

   body.emit(assign(r0DB2, r0DB5, 0x01));

   body.emit(assign(r0DB1, r0DB3, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64To128(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0DC7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0DC7);
   ir_variable *const r0DC8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0DC8);
   ir_variable *const r0DC9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0DC9);
   ir_variable *const r0DCA = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0DCA);
   ir_variable *const r0DCB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DCB);
   ir_variable *const r0DCC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DCC);
   ir_variable *const r0DCD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DCD);
   ir_variable *const r0DCE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z3Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DCE);
   ir_variable *const r0DCF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0DCF);
   ir_variable *const r0DD0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0DD0);
   ir_variable *const r0DD1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0DD1);
   ir_variable *const r0DD2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DD2, bit_and(r0DC8, body.constant(65535u)), 0x01));

   ir_variable *const r0DD3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DD3, rshift(r0DC8, body.constant(int(16))), 0x01));

   ir_variable *const r0DD4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DD4, bit_and(r0DCA, body.constant(65535u)), 0x01));

   ir_variable *const r0DD5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DD5, rshift(r0DCA, body.constant(int(16))), 0x01));

   ir_variable *const r0DD6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DD6, mul(r0DD3, r0DD4), 0x01));

   ir_expression *const r0DD7 = mul(r0DD2, r0DD5);
   body.emit(assign(r0DD0, add(r0DD7, r0DD6), 0x01));

   ir_expression *const r0DD8 = mul(r0DD3, r0DD5);
   ir_expression *const r0DD9 = less(r0DD0, r0DD6);
   ir_expression *const r0DDA = expr(ir_unop_b2i, r0DD9);
   ir_expression *const r0DDB = expr(ir_unop_i2u, r0DDA);
   ir_expression *const r0DDC = lshift(r0DDB, body.constant(int(16)));
   ir_expression *const r0DDD = rshift(r0DD0, body.constant(int(16)));
   ir_expression *const r0DDE = add(r0DDC, r0DDD);
   body.emit(assign(r0DCF, add(r0DD8, r0DDE), 0x01));

   body.emit(assign(r0DD0, lshift(r0DD0, body.constant(int(16))), 0x01));

   ir_expression *const r0DDF = mul(r0DD2, r0DD4);
   body.emit(assign(r0DD1, add(r0DDF, r0DD0), 0x01));

   ir_expression *const r0DE0 = less(r0DD1, r0DD0);
   ir_expression *const r0DE1 = expr(ir_unop_b2i, r0DE0);
   ir_expression *const r0DE2 = expr(ir_unop_i2u, r0DE1);
   body.emit(assign(r0DCF, add(r0DCF, r0DE2), 0x01));

   ir_variable *const r0DE3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0DE3);
   ir_variable *const r0DE4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0DE4);
   ir_variable *const r0DE5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0DE5);
   ir_variable *const r0DE6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DE6, bit_and(r0DC8, body.constant(65535u)), 0x01));

   ir_variable *const r0DE7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DE7, rshift(r0DC8, body.constant(int(16))), 0x01));

   ir_variable *const r0DE8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DE8, bit_and(r0DC9, body.constant(65535u)), 0x01));

   ir_variable *const r0DE9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DE9, rshift(r0DC9, body.constant(int(16))), 0x01));

   ir_variable *const r0DEA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DEA, mul(r0DE7, r0DE8), 0x01));

   ir_expression *const r0DEB = mul(r0DE6, r0DE9);
   body.emit(assign(r0DE4, add(r0DEB, r0DEA), 0x01));

   ir_expression *const r0DEC = mul(r0DE7, r0DE9);
   ir_expression *const r0DED = less(r0DE4, r0DEA);
   ir_expression *const r0DEE = expr(ir_unop_b2i, r0DED);
   ir_expression *const r0DEF = expr(ir_unop_i2u, r0DEE);
   ir_expression *const r0DF0 = lshift(r0DEF, body.constant(int(16)));
   ir_expression *const r0DF1 = rshift(r0DE4, body.constant(int(16)));
   ir_expression *const r0DF2 = add(r0DF0, r0DF1);
   body.emit(assign(r0DE3, add(r0DEC, r0DF2), 0x01));

   body.emit(assign(r0DE4, lshift(r0DE4, body.constant(int(16))), 0x01));

   ir_expression *const r0DF3 = mul(r0DE6, r0DE8);
   body.emit(assign(r0DE5, add(r0DF3, r0DE4), 0x01));

   ir_expression *const r0DF4 = less(r0DE5, r0DE4);
   ir_expression *const r0DF5 = expr(ir_unop_b2i, r0DF4);
   ir_expression *const r0DF6 = expr(ir_unop_i2u, r0DF5);
   body.emit(assign(r0DE3, add(r0DE3, r0DF6), 0x01));

   ir_variable *const r0DF7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DF7, add(r0DE5, r0DCF), 0x01));

   ir_variable *const r0DF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0DF8);
   ir_variable *const r0DF9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0DF9);
   ir_variable *const r0DFA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0DFA);
   ir_variable *const r0DFB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DFB, bit_and(r0DC7, body.constant(65535u)), 0x01));

   ir_variable *const r0DFC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DFC, rshift(r0DC7, body.constant(int(16))), 0x01));

   ir_variable *const r0DFD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DFD, bit_and(r0DC9, body.constant(65535u)), 0x01));

   ir_variable *const r0DFE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DFE, rshift(r0DC9, body.constant(int(16))), 0x01));

   ir_variable *const r0DFF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DFF, mul(r0DFC, r0DFD), 0x01));

   ir_expression *const r0E00 = mul(r0DFB, r0DFE);
   body.emit(assign(r0DF9, add(r0E00, r0DFF), 0x01));

   ir_expression *const r0E01 = mul(r0DFC, r0DFE);
   ir_expression *const r0E02 = less(r0DF9, r0DFF);
   ir_expression *const r0E03 = expr(ir_unop_b2i, r0E02);
   ir_expression *const r0E04 = expr(ir_unop_i2u, r0E03);
   ir_expression *const r0E05 = lshift(r0E04, body.constant(int(16)));
   ir_expression *const r0E06 = rshift(r0DF9, body.constant(int(16)));
   ir_expression *const r0E07 = add(r0E05, r0E06);
   body.emit(assign(r0DF8, add(r0E01, r0E07), 0x01));

   body.emit(assign(r0DF9, lshift(r0DF9, body.constant(int(16))), 0x01));

   ir_expression *const r0E08 = mul(r0DFB, r0DFD);
   body.emit(assign(r0DFA, add(r0E08, r0DF9), 0x01));

   ir_expression *const r0E09 = less(r0DFA, r0DF9);
   ir_expression *const r0E0A = expr(ir_unop_b2i, r0E09);
   ir_expression *const r0E0B = expr(ir_unop_i2u, r0E0A);
   body.emit(assign(r0DF8, add(r0DF8, r0E0B), 0x01));

   ir_variable *const r0E0C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r0E0D = less(r0DF7, r0DE5);
   ir_expression *const r0E0E = expr(ir_unop_b2i, r0E0D);
   ir_expression *const r0E0F = expr(ir_unop_i2u, r0E0E);
   ir_expression *const r0E10 = add(r0DE3, r0E0F);
   body.emit(assign(r0E0C, add(r0DFA, r0E10), 0x01));

   ir_variable *const r0E11 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0E11);
   ir_variable *const r0E12 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0E12);
   ir_variable *const r0E13 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0E13);
   ir_variable *const r0E14 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E14, bit_and(r0DC7, body.constant(65535u)), 0x01));

   ir_variable *const r0E15 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E15, rshift(r0DC7, body.constant(int(16))), 0x01));

   ir_variable *const r0E16 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E16, bit_and(r0DCA, body.constant(65535u)), 0x01));

   ir_variable *const r0E17 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E17, rshift(r0DCA, body.constant(int(16))), 0x01));

   ir_variable *const r0E18 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E18, mul(r0E15, r0E16), 0x01));

   ir_expression *const r0E19 = mul(r0E14, r0E17);
   body.emit(assign(r0E12, add(r0E19, r0E18), 0x01));

   ir_expression *const r0E1A = mul(r0E15, r0E17);
   ir_expression *const r0E1B = less(r0E12, r0E18);
   ir_expression *const r0E1C = expr(ir_unop_b2i, r0E1B);
   ir_expression *const r0E1D = expr(ir_unop_i2u, r0E1C);
   ir_expression *const r0E1E = lshift(r0E1D, body.constant(int(16)));
   ir_expression *const r0E1F = rshift(r0E12, body.constant(int(16)));
   ir_expression *const r0E20 = add(r0E1E, r0E1F);
   body.emit(assign(r0E11, add(r0E1A, r0E20), 0x01));

   body.emit(assign(r0E12, lshift(r0E12, body.constant(int(16))), 0x01));

   ir_expression *const r0E21 = mul(r0E14, r0E16);
   body.emit(assign(r0E13, add(r0E21, r0E12), 0x01));

   ir_expression *const r0E22 = less(r0E13, r0E12);
   ir_expression *const r0E23 = expr(ir_unop_b2i, r0E22);
   ir_expression *const r0E24 = expr(ir_unop_i2u, r0E23);
   body.emit(assign(r0E11, add(r0E11, r0E24), 0x01));

   ir_variable *const r0E25 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E25, add(r0E13, r0DF7), 0x01));

   ir_variable *const r0E26 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r0E27 = less(r0E25, r0E13);
   ir_expression *const r0E28 = expr(ir_unop_b2i, r0E27);
   ir_expression *const r0E29 = expr(ir_unop_i2u, r0E28);
   ir_expression *const r0E2A = add(r0E11, r0E29);
   body.emit(assign(r0E26, add(r0E0C, r0E2A), 0x01));

   body.emit(assign(r0DCE, r0DD1, 0x01));

   body.emit(assign(r0DCD, r0E25, 0x01));

   body.emit(assign(r0DCC, r0E26, 0x01));

   ir_expression *const r0E2B = less(r0E0C, r0DFA);
   ir_expression *const r0E2C = expr(ir_unop_b2i, r0E2B);
   ir_expression *const r0E2D = expr(ir_unop_i2u, r0E2C);
   ir_expression *const r0E2E = add(r0DF8, r0E2D);
   ir_expression *const r0E2F = less(r0E26, r0E0C);
   ir_expression *const r0E30 = expr(ir_unop_b2i, r0E2F);
   ir_expression *const r0E31 = expr(ir_unop_i2u, r0E30);
   body.emit(assign(r0DCB, add(r0E2E, r0E31), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat64Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0E32 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0E32);
   ir_variable *const r0E33 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0E33);
   ir_variable *const r0E34 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r0E34);
   ir_variable *const r0E35 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0E35);
   ir_variable *const r0E36 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0E36);
   ir_variable *const r0E37 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0E37);
   /* IF CONDITION */
   ir_expression *const r0E39 = equal(r0E32, body.constant(0u));
   ir_if *f0E38 = new(mem_ctx) ir_if(operand(r0E39).val);
   exec_list *const f0E38_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0E38->then_instructions;

      ir_variable *const r0E3A = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r0E3A, r0E33, 0x01));

      ir_variable *const r0E3B = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r0E3C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r0E3C);
      /* IF CONDITION */
      ir_expression *const r0E3E = equal(r0E33, body.constant(0u));
      ir_if *f0E3D = new(mem_ctx) ir_if(operand(r0E3E).val);
      exec_list *const f0E3D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E3D->then_instructions;

         body.emit(assign(r0E3B, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E3D->else_instructions;

         body.emit(assign(r0E3C, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r0E40 = bit_and(r0E33, body.constant(4294901760u));
         ir_expression *const r0E41 = equal(r0E40, body.constant(0u));
         ir_if *f0E3F = new(mem_ctx) ir_if(operand(r0E41).val);
         exec_list *const f0E3F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E3F->then_instructions;

            body.emit(assign(r0E3C, body.constant(int(16)), 0x01));

            body.emit(assign(r0E3A, lshift(r0E33, body.constant(int(16))), 0x01));


         body.instructions = f0E3F_parent_instructions;
         body.emit(f0E3F);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E43 = bit_and(r0E3A, body.constant(4278190080u));
         ir_expression *const r0E44 = equal(r0E43, body.constant(0u));
         ir_if *f0E42 = new(mem_ctx) ir_if(operand(r0E44).val);
         exec_list *const f0E42_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E42->then_instructions;

            body.emit(assign(r0E3C, add(r0E3C, body.constant(int(8))), 0x01));

            body.emit(assign(r0E3A, lshift(r0E3A, body.constant(int(8))), 0x01));


         body.instructions = f0E42_parent_instructions;
         body.emit(f0E42);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E46 = bit_and(r0E3A, body.constant(4026531840u));
         ir_expression *const r0E47 = equal(r0E46, body.constant(0u));
         ir_if *f0E45 = new(mem_ctx) ir_if(operand(r0E47).val);
         exec_list *const f0E45_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E45->then_instructions;

            body.emit(assign(r0E3C, add(r0E3C, body.constant(int(4))), 0x01));

            body.emit(assign(r0E3A, lshift(r0E3A, body.constant(int(4))), 0x01));


         body.instructions = f0E45_parent_instructions;
         body.emit(f0E45);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E49 = bit_and(r0E3A, body.constant(3221225472u));
         ir_expression *const r0E4A = equal(r0E49, body.constant(0u));
         ir_if *f0E48 = new(mem_ctx) ir_if(operand(r0E4A).val);
         exec_list *const f0E48_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E48->then_instructions;

            body.emit(assign(r0E3C, add(r0E3C, body.constant(int(2))), 0x01));

            body.emit(assign(r0E3A, lshift(r0E3A, body.constant(int(2))), 0x01));


         body.instructions = f0E48_parent_instructions;
         body.emit(f0E48);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E4C = bit_and(r0E3A, body.constant(2147483648u));
         ir_expression *const r0E4D = equal(r0E4C, body.constant(0u));
         ir_if *f0E4B = new(mem_ctx) ir_if(operand(r0E4D).val);
         exec_list *const f0E4B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E4B->then_instructions;

            body.emit(assign(r0E3C, add(r0E3C, body.constant(int(1))), 0x01));


         body.instructions = f0E4B_parent_instructions;
         body.emit(f0E4B);

         /* END IF */

         body.emit(assign(r0E3B, r0E3C, 0x01));


      body.instructions = f0E3D_parent_instructions;
      body.emit(f0E3D);

      /* END IF */

      body.emit(assign(r0E37, add(r0E3B, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0E4F = less(r0E37, body.constant(int(0)));
      ir_if *f0E4E = new(mem_ctx) ir_if(operand(r0E4F).val);
      exec_list *const f0E4E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E4E->then_instructions;

         ir_expression *const r0E50 = neg(r0E37);
         body.emit(assign(r0E35, rshift(r0E33, r0E50), 0x01));

         ir_expression *const r0E51 = bit_and(r0E37, body.constant(int(31)));
         body.emit(assign(r0E36, lshift(r0E33, r0E51), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E4E->else_instructions;

         body.emit(assign(r0E35, lshift(r0E33, r0E37), 0x01));

         body.emit(assign(r0E36, body.constant(0u), 0x01));


      body.instructions = f0E4E_parent_instructions;
      body.emit(f0E4E);

      /* END IF */

      body.emit(assign(r0E34, sub(body.constant(int(-31)), r0E37), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0E38->else_instructions;

      ir_variable *const r0E52 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r0E52, r0E32, 0x01));

      ir_variable *const r0E53 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r0E54 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r0E54);
      /* IF CONDITION */
      ir_expression *const r0E56 = equal(r0E32, body.constant(0u));
      ir_if *f0E55 = new(mem_ctx) ir_if(operand(r0E56).val);
      exec_list *const f0E55_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E55->then_instructions;

         body.emit(assign(r0E53, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E55->else_instructions;

         body.emit(assign(r0E54, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r0E58 = bit_and(r0E32, body.constant(4294901760u));
         ir_expression *const r0E59 = equal(r0E58, body.constant(0u));
         ir_if *f0E57 = new(mem_ctx) ir_if(operand(r0E59).val);
         exec_list *const f0E57_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E57->then_instructions;

            body.emit(assign(r0E54, body.constant(int(16)), 0x01));

            body.emit(assign(r0E52, lshift(r0E32, body.constant(int(16))), 0x01));


         body.instructions = f0E57_parent_instructions;
         body.emit(f0E57);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E5B = bit_and(r0E52, body.constant(4278190080u));
         ir_expression *const r0E5C = equal(r0E5B, body.constant(0u));
         ir_if *f0E5A = new(mem_ctx) ir_if(operand(r0E5C).val);
         exec_list *const f0E5A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E5A->then_instructions;

            body.emit(assign(r0E54, add(r0E54, body.constant(int(8))), 0x01));

            body.emit(assign(r0E52, lshift(r0E52, body.constant(int(8))), 0x01));


         body.instructions = f0E5A_parent_instructions;
         body.emit(f0E5A);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E5E = bit_and(r0E52, body.constant(4026531840u));
         ir_expression *const r0E5F = equal(r0E5E, body.constant(0u));
         ir_if *f0E5D = new(mem_ctx) ir_if(operand(r0E5F).val);
         exec_list *const f0E5D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E5D->then_instructions;

            body.emit(assign(r0E54, add(r0E54, body.constant(int(4))), 0x01));

            body.emit(assign(r0E52, lshift(r0E52, body.constant(int(4))), 0x01));


         body.instructions = f0E5D_parent_instructions;
         body.emit(f0E5D);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E61 = bit_and(r0E52, body.constant(3221225472u));
         ir_expression *const r0E62 = equal(r0E61, body.constant(0u));
         ir_if *f0E60 = new(mem_ctx) ir_if(operand(r0E62).val);
         exec_list *const f0E60_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E60->then_instructions;

            body.emit(assign(r0E54, add(r0E54, body.constant(int(2))), 0x01));

            body.emit(assign(r0E52, lshift(r0E52, body.constant(int(2))), 0x01));


         body.instructions = f0E60_parent_instructions;
         body.emit(f0E60);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E64 = bit_and(r0E52, body.constant(2147483648u));
         ir_expression *const r0E65 = equal(r0E64, body.constant(0u));
         ir_if *f0E63 = new(mem_ctx) ir_if(operand(r0E65).val);
         exec_list *const f0E63_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E63->then_instructions;

            body.emit(assign(r0E54, add(r0E54, body.constant(int(1))), 0x01));


         body.instructions = f0E63_parent_instructions;
         body.emit(f0E63);

         /* END IF */

         body.emit(assign(r0E53, r0E54, 0x01));


      body.instructions = f0E55_parent_instructions;
      body.emit(f0E55);

      /* END IF */

      body.emit(assign(r0E37, add(r0E53, body.constant(int(-11))), 0x01));

      ir_variable *const r0E66 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0E66, lshift(r0E33, r0E37), 0x01));

      ir_variable *const r0E67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r0E69 = equal(r0E37, body.constant(int(0)));
      ir_if *f0E68 = new(mem_ctx) ir_if(operand(r0E69).val);
      exec_list *const f0E68_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E68->then_instructions;

         body.emit(assign(r0E67, r0E32, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E68->else_instructions;

         ir_expression *const r0E6A = lshift(r0E32, r0E37);
         ir_expression *const r0E6B = neg(r0E37);
         ir_expression *const r0E6C = bit_and(r0E6B, body.constant(int(31)));
         ir_expression *const r0E6D = rshift(r0E33, r0E6C);
         body.emit(assign(r0E67, bit_or(r0E6A, r0E6D), 0x01));


      body.instructions = f0E68_parent_instructions;
      body.emit(f0E68);

      /* END IF */

      body.emit(assign(r0E35, r0E67, 0x01));

      body.emit(assign(r0E36, r0E66, 0x01));

      body.emit(assign(r0E34, sub(body.constant(int(1)), r0E37), 0x01));


   body.instructions = f0E38_parent_instructions;
   body.emit(f0E38);

   /* END IF */

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmul64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0E6E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0E6E);
   ir_variable *const r0E6F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0E6F);
   ir_variable *const r0E70 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r0E70, body.constant(true), 0x01));

   ir_variable *const r0E71 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0E72 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r0E72);
   ir_variable *const r0E73 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r0E73);
   ir_variable *const r0E74 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r0E74);
   ir_variable *const r0E75 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r0E75);
   ir_variable *const r0E76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r0E76);
   ir_variable *const r0E77 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r0E77);
   ir_variable *const r0E78 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r0E78);
   ir_variable *const r0E79 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r0E79);
   ir_variable *const r0E7A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0E7A);
   ir_variable *const r0E7B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r0E7B);
   ir_variable *const r0E7C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r0E7C);
   body.emit(assign(r0E7C, body.constant(0u), 0x01));

   body.emit(assign(r0E7B, body.constant(0u), 0x01));

   body.emit(assign(r0E7A, body.constant(0u), 0x01));

   ir_variable *const r0E7D = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0E7D, swizzle_x(r0E6E), 0x01));

   body.emit(assign(r0E78, r0E7D, 0x01));

   ir_variable *const r0E7E = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0E7E, bit_and(swizzle_y(r0E6E), body.constant(1048575u)), 0x01));

   body.emit(assign(r0E77, r0E7E, 0x01));

   ir_variable *const r0E7F = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0E7F, swizzle_x(r0E6F), 0x01));

   body.emit(assign(r0E76, r0E7F, 0x01));

   ir_variable *const r0E80 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0E80, bit_and(swizzle_y(r0E6F), body.constant(1048575u)), 0x01));

   body.emit(assign(r0E75, r0E80, 0x01));

   ir_variable *const r0E81 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0E82 = rshift(swizzle_y(r0E6E), body.constant(int(20)));
   ir_expression *const r0E83 = bit_and(r0E82, body.constant(2047u));
   body.emit(assign(r0E81, expr(ir_unop_u2i, r0E83), 0x01));

   body.emit(assign(r0E74, r0E81, 0x01));

   ir_variable *const r0E84 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0E85 = rshift(swizzle_y(r0E6F), body.constant(int(20)));
   ir_expression *const r0E86 = bit_and(r0E85, body.constant(2047u));
   body.emit(assign(r0E84, expr(ir_unop_u2i, r0E86), 0x01));

   body.emit(assign(r0E73, r0E84, 0x01));

   ir_expression *const r0E87 = rshift(swizzle_y(r0E6E), body.constant(int(31)));
   ir_expression *const r0E88 = rshift(swizzle_y(r0E6F), body.constant(int(31)));
   body.emit(assign(r0E72, bit_xor(r0E87, r0E88), 0x01));

   /* IF CONDITION */
   ir_expression *const r0E8A = equal(r0E81, body.constant(int(2047)));
   ir_if *f0E89 = new(mem_ctx) ir_if(operand(r0E8A).val);
   exec_list *const f0E89_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0E89->then_instructions;

      /* IF CONDITION */
      ir_expression *const r0E8C = bit_or(r0E7E, swizzle_x(r0E6E));
      ir_expression *const r0E8D = nequal(r0E8C, body.constant(0u));
      ir_expression *const r0E8E = equal(r0E84, body.constant(int(2047)));
      ir_expression *const r0E8F = bit_or(r0E80, swizzle_x(r0E6F));
      ir_expression *const r0E90 = nequal(r0E8F, body.constant(0u));
      ir_expression *const r0E91 = logic_and(r0E8E, r0E90);
      ir_expression *const r0E92 = logic_or(r0E8D, r0E91);
      ir_if *f0E8B = new(mem_ctx) ir_if(operand(r0E92).val);
      exec_list *const f0E8B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E8B->then_instructions;

         ir_variable *const r0E93 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r0E93, swizzle_x(r0E6E), 0x01));

         ir_variable *const r0E94 = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r0E94, swizzle_x(r0E6F), 0x01));

         ir_variable *const r0E95 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0E96 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r0E97 = rshift(swizzle_y(r0E6E), body.constant(int(19)));
         ir_expression *const r0E98 = bit_and(r0E97, body.constant(4095u));
         ir_expression *const r0E99 = equal(r0E98, body.constant(4094u));
         ir_expression *const r0E9A = nequal(swizzle_x(r0E6E), body.constant(0u));
         ir_expression *const r0E9B = bit_and(swizzle_y(r0E6E), body.constant(524287u));
         ir_expression *const r0E9C = nequal(r0E9B, body.constant(0u));
         ir_expression *const r0E9D = logic_or(r0E9A, r0E9C);
         body.emit(assign(r0E96, logic_and(r0E99, r0E9D), 0x01));

         ir_variable *const r0E9E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r0E9F = lshift(swizzle_y(r0E6F), body.constant(int(1)));
         ir_expression *const r0EA0 = lequal(body.constant(4292870144u), r0E9F);
         ir_expression *const r0EA1 = nequal(swizzle_x(r0E6F), body.constant(0u));
         ir_expression *const r0EA2 = bit_and(swizzle_y(r0E6F), body.constant(1048575u));
         ir_expression *const r0EA3 = nequal(r0EA2, body.constant(0u));
         ir_expression *const r0EA4 = logic_or(r0EA1, r0EA3);
         body.emit(assign(r0E9E, logic_and(r0EA0, r0EA4), 0x01));

         body.emit(assign(r0E93, bit_or(swizzle_y(r0E6E), body.constant(524288u)), 0x02));

         body.emit(assign(r0E94, bit_or(swizzle_y(r0E6F), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r0EA6 = lshift(swizzle_y(r0E6E), body.constant(int(1)));
         ir_expression *const r0EA7 = lequal(body.constant(4292870144u), r0EA6);
         ir_expression *const r0EA8 = nequal(swizzle_x(r0E6E), body.constant(0u));
         ir_expression *const r0EA9 = bit_and(swizzle_y(r0E6E), body.constant(1048575u));
         ir_expression *const r0EAA = nequal(r0EA9, body.constant(0u));
         ir_expression *const r0EAB = logic_or(r0EA8, r0EAA);
         ir_expression *const r0EAC = logic_and(r0EA7, r0EAB);
         ir_if *f0EA5 = new(mem_ctx) ir_if(operand(r0EAC).val);
         exec_list *const f0EA5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EA5->then_instructions;

            ir_variable *const r0EAD = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r0EAF = logic_and(r0E96, r0E9E);
            ir_if *f0EAE = new(mem_ctx) ir_if(operand(r0EAF).val);
            exec_list *const f0EAE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EAE->then_instructions;

               body.emit(assign(r0EAD, r0E94, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EAE->else_instructions;

               body.emit(assign(r0EAD, r0E93, 0x03));


            body.instructions = f0EAE_parent_instructions;
            body.emit(f0EAE);

            /* END IF */

            body.emit(assign(r0E95, r0EAD, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0EA5->else_instructions;

            body.emit(assign(r0E95, r0E94, 0x03));


         body.instructions = f0EA5_parent_instructions;
         body.emit(f0EA5);

         /* END IF */

         body.emit(assign(r0E71, r0E95, 0x03));

         body.emit(assign(r0E70, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E8B->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0EB1 = expr(ir_unop_i2u, r0E84);
         ir_expression *const r0EB2 = bit_or(r0EB1, r0E80);
         ir_expression *const r0EB3 = bit_or(r0EB2, swizzle_x(r0E6F));
         ir_expression *const r0EB4 = equal(r0EB3, body.constant(0u));
         ir_if *f0EB0 = new(mem_ctx) ir_if(operand(r0EB4).val);
         exec_list *const f0EB0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EB0->then_instructions;

            ir_constant_data r0EB5_data;
            memset(&r0EB5_data, 0, sizeof(ir_constant_data));
            r0EB5_data.u[0] = 4294967295;
            r0EB5_data.u[1] = 4294967295;
            ir_constant *const r0EB5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0EB5_data);
            body.emit(assign(r0E71, r0EB5, 0x03));

            body.emit(assign(r0E70, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0EB0->else_instructions;

            ir_variable *const r0EB6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r0EB6);
            ir_expression *const r0EB7 = lshift(r0E72, body.constant(int(31)));
            body.emit(assign(r0EB6, add(r0EB7, body.constant(2146435072u)), 0x02));

            body.emit(assign(r0EB6, body.constant(0u), 0x01));

            body.emit(assign(r0E71, r0EB6, 0x03));

            body.emit(assign(r0E70, body.constant(false), 0x01));


         body.instructions = f0EB0_parent_instructions;
         body.emit(f0EB0);

         /* END IF */


      body.instructions = f0E8B_parent_instructions;
      body.emit(f0E8B);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0E89->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0EB9 = equal(r0E84, body.constant(int(2047)));
      ir_if *f0EB8 = new(mem_ctx) ir_if(operand(r0EB9).val);
      exec_list *const f0EB8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0EB8->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0EBB = bit_or(r0E80, swizzle_x(r0E6F));
         ir_expression *const r0EBC = nequal(r0EBB, body.constant(0u));
         ir_if *f0EBA = new(mem_ctx) ir_if(operand(r0EBC).val);
         exec_list *const f0EBA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EBA->then_instructions;

            ir_variable *const r0EBD = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r0EBD, swizzle_x(r0E6E), 0x01));

            ir_variable *const r0EBE = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r0EBE, swizzle_x(r0E6F), 0x01));

            ir_variable *const r0EBF = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0EC0 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r0EC1 = rshift(swizzle_y(r0E6E), body.constant(int(19)));
            ir_expression *const r0EC2 = bit_and(r0EC1, body.constant(4095u));
            ir_expression *const r0EC3 = equal(r0EC2, body.constant(4094u));
            ir_expression *const r0EC4 = nequal(swizzle_x(r0E6E), body.constant(0u));
            ir_expression *const r0EC5 = bit_and(swizzle_y(r0E6E), body.constant(524287u));
            ir_expression *const r0EC6 = nequal(r0EC5, body.constant(0u));
            ir_expression *const r0EC7 = logic_or(r0EC4, r0EC6);
            body.emit(assign(r0EC0, logic_and(r0EC3, r0EC7), 0x01));

            ir_variable *const r0EC8 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0EC9 = lshift(swizzle_y(r0E6F), body.constant(int(1)));
            ir_expression *const r0ECA = lequal(body.constant(4292870144u), r0EC9);
            ir_expression *const r0ECB = nequal(swizzle_x(r0E6F), body.constant(0u));
            ir_expression *const r0ECC = bit_and(swizzle_y(r0E6F), body.constant(1048575u));
            ir_expression *const r0ECD = nequal(r0ECC, body.constant(0u));
            ir_expression *const r0ECE = logic_or(r0ECB, r0ECD);
            body.emit(assign(r0EC8, logic_and(r0ECA, r0ECE), 0x01));

            body.emit(assign(r0EBD, bit_or(swizzle_y(r0E6E), body.constant(524288u)), 0x02));

            body.emit(assign(r0EBE, bit_or(swizzle_y(r0E6F), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0ED0 = lshift(swizzle_y(r0E6E), body.constant(int(1)));
            ir_expression *const r0ED1 = lequal(body.constant(4292870144u), r0ED0);
            ir_expression *const r0ED2 = nequal(swizzle_x(r0E6E), body.constant(0u));
            ir_expression *const r0ED3 = bit_and(swizzle_y(r0E6E), body.constant(1048575u));
            ir_expression *const r0ED4 = nequal(r0ED3, body.constant(0u));
            ir_expression *const r0ED5 = logic_or(r0ED2, r0ED4);
            ir_expression *const r0ED6 = logic_and(r0ED1, r0ED5);
            ir_if *f0ECF = new(mem_ctx) ir_if(operand(r0ED6).val);
            exec_list *const f0ECF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0ECF->then_instructions;

               ir_variable *const r0ED7 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0ED9 = logic_and(r0EC0, r0EC8);
               ir_if *f0ED8 = new(mem_ctx) ir_if(operand(r0ED9).val);
               exec_list *const f0ED8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ED8->then_instructions;

                  body.emit(assign(r0ED7, r0EBE, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ED8->else_instructions;

                  body.emit(assign(r0ED7, r0EBD, 0x03));


               body.instructions = f0ED8_parent_instructions;
               body.emit(f0ED8);

               /* END IF */

               body.emit(assign(r0EBF, r0ED7, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0ECF->else_instructions;

               body.emit(assign(r0EBF, r0EBE, 0x03));


            body.instructions = f0ECF_parent_instructions;
            body.emit(f0ECF);

            /* END IF */

            body.emit(assign(r0E71, r0EBF, 0x03));

            body.emit(assign(r0E70, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0EBA->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0EDB = expr(ir_unop_i2u, r0E81);
            ir_expression *const r0EDC = bit_or(r0EDB, r0E7E);
            ir_expression *const r0EDD = bit_or(r0EDC, swizzle_x(r0E6E));
            ir_expression *const r0EDE = equal(r0EDD, body.constant(0u));
            ir_if *f0EDA = new(mem_ctx) ir_if(operand(r0EDE).val);
            exec_list *const f0EDA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EDA->then_instructions;

               ir_constant_data r0EDF_data;
               memset(&r0EDF_data, 0, sizeof(ir_constant_data));
               r0EDF_data.u[0] = 4294967295;
               r0EDF_data.u[1] = 4294967295;
               ir_constant *const r0EDF = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0EDF_data);
               body.emit(assign(r0E71, r0EDF, 0x03));

               body.emit(assign(r0E70, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EDA->else_instructions;

               ir_variable *const r0EE0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0EE0);
               ir_expression *const r0EE1 = lshift(r0E72, body.constant(int(31)));
               body.emit(assign(r0EE0, add(r0EE1, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0EE0, body.constant(0u), 0x01));

               body.emit(assign(r0E71, r0EE0, 0x03));

               body.emit(assign(r0E70, body.constant(false), 0x01));


            body.instructions = f0EDA_parent_instructions;
            body.emit(f0EDA);

            /* END IF */


         body.instructions = f0EBA_parent_instructions;
         body.emit(f0EBA);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0EB8->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0EE3 = equal(r0E81, body.constant(int(0)));
         ir_if *f0EE2 = new(mem_ctx) ir_if(operand(r0EE3).val);
         exec_list *const f0EE2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EE2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0EE5 = bit_or(r0E7E, swizzle_x(r0E6E));
            ir_expression *const r0EE6 = equal(r0EE5, body.constant(0u));
            ir_if *f0EE4 = new(mem_ctx) ir_if(operand(r0EE6).val);
            exec_list *const f0EE4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EE4->then_instructions;

               ir_variable *const r0EE7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0EE7);
               body.emit(assign(r0EE7, lshift(r0E72, body.constant(int(31))), 0x02));

               body.emit(assign(r0EE7, body.constant(0u), 0x01));

               body.emit(assign(r0E71, r0EE7, 0x03));

               body.emit(assign(r0E70, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EE4->else_instructions;

               ir_variable *const r0EE8 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r0EE8, r0E81, 0x01));

               ir_variable *const r0EE9 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r0EE9, r0E7E, 0x01));

               ir_variable *const r0EEA = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r0EEA, r0E7D, 0x01));

               ir_variable *const r0EEB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EEB);
               /* IF CONDITION */
               ir_expression *const r0EED = equal(r0E7E, body.constant(0u));
               ir_if *f0EEC = new(mem_ctx) ir_if(operand(r0EED).val);
               exec_list *const f0EEC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EEC->then_instructions;

                  ir_variable *const r0EEE = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0EEE, r0E7D, 0x01));

                  ir_variable *const r0EEF = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0EF0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0EF0);
                  /* IF CONDITION */
                  ir_expression *const r0EF2 = equal(swizzle_x(r0E6E), body.constant(0u));
                  ir_if *f0EF1 = new(mem_ctx) ir_if(operand(r0EF2).val);
                  exec_list *const f0EF1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EF1->then_instructions;

                     body.emit(assign(r0EEF, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0EF1->else_instructions;

                     body.emit(assign(r0EF0, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0EF4 = bit_and(swizzle_x(r0E6E), body.constant(4294901760u));
                     ir_expression *const r0EF5 = equal(r0EF4, body.constant(0u));
                     ir_if *f0EF3 = new(mem_ctx) ir_if(operand(r0EF5).val);
                     exec_list *const f0EF3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EF3->then_instructions;

                        body.emit(assign(r0EF0, body.constant(int(16)), 0x01));

                        body.emit(assign(r0EEE, lshift(swizzle_x(r0E6E), body.constant(int(16))), 0x01));


                     body.instructions = f0EF3_parent_instructions;
                     body.emit(f0EF3);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0EF7 = bit_and(r0EEE, body.constant(4278190080u));
                     ir_expression *const r0EF8 = equal(r0EF7, body.constant(0u));
                     ir_if *f0EF6 = new(mem_ctx) ir_if(operand(r0EF8).val);
                     exec_list *const f0EF6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EF6->then_instructions;

                        body.emit(assign(r0EF0, add(r0EF0, body.constant(int(8))), 0x01));

                        body.emit(assign(r0EEE, lshift(r0EEE, body.constant(int(8))), 0x01));


                     body.instructions = f0EF6_parent_instructions;
                     body.emit(f0EF6);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0EFA = bit_and(r0EEE, body.constant(4026531840u));
                     ir_expression *const r0EFB = equal(r0EFA, body.constant(0u));
                     ir_if *f0EF9 = new(mem_ctx) ir_if(operand(r0EFB).val);
                     exec_list *const f0EF9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EF9->then_instructions;

                        body.emit(assign(r0EF0, add(r0EF0, body.constant(int(4))), 0x01));

                        body.emit(assign(r0EEE, lshift(r0EEE, body.constant(int(4))), 0x01));


                     body.instructions = f0EF9_parent_instructions;
                     body.emit(f0EF9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0EFD = bit_and(r0EEE, body.constant(3221225472u));
                     ir_expression *const r0EFE = equal(r0EFD, body.constant(0u));
                     ir_if *f0EFC = new(mem_ctx) ir_if(operand(r0EFE).val);
                     exec_list *const f0EFC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EFC->then_instructions;

                        body.emit(assign(r0EF0, add(r0EF0, body.constant(int(2))), 0x01));

                        body.emit(assign(r0EEE, lshift(r0EEE, body.constant(int(2))), 0x01));


                     body.instructions = f0EFC_parent_instructions;
                     body.emit(f0EFC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0F00 = bit_and(r0EEE, body.constant(2147483648u));
                     ir_expression *const r0F01 = equal(r0F00, body.constant(0u));
                     ir_if *f0EFF = new(mem_ctx) ir_if(operand(r0F01).val);
                     exec_list *const f0EFF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EFF->then_instructions;

                        body.emit(assign(r0EF0, add(r0EF0, body.constant(int(1))), 0x01));


                     body.instructions = f0EFF_parent_instructions;
                     body.emit(f0EFF);

                     /* END IF */

                     body.emit(assign(r0EEF, r0EF0, 0x01));


                  body.instructions = f0EF1_parent_instructions;
                  body.emit(f0EF1);

                  /* END IF */

                  body.emit(assign(r0EEB, add(r0EEF, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0F03 = less(r0EEB, body.constant(int(0)));
                  ir_if *f0F02 = new(mem_ctx) ir_if(operand(r0F03).val);
                  exec_list *const f0F02_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F02->then_instructions;

                     ir_expression *const r0F04 = neg(r0EEB);
                     body.emit(assign(r0EE9, rshift(swizzle_x(r0E6E), r0F04), 0x01));

                     ir_expression *const r0F05 = bit_and(r0EEB, body.constant(int(31)));
                     body.emit(assign(r0EEA, lshift(swizzle_x(r0E6E), r0F05), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F02->else_instructions;

                     body.emit(assign(r0EE9, lshift(swizzle_x(r0E6E), r0EEB), 0x01));

                     body.emit(assign(r0EEA, body.constant(0u), 0x01));


                  body.instructions = f0F02_parent_instructions;
                  body.emit(f0F02);

                  /* END IF */

                  body.emit(assign(r0EE8, sub(body.constant(int(-31)), r0EEB), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EEC->else_instructions;

                  ir_variable *const r0F06 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0F06, r0E7E, 0x01));

                  ir_variable *const r0F07 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0F08 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0F08);
                  /* IF CONDITION */
                  ir_expression *const r0F0A = equal(r0E7E, body.constant(0u));
                  ir_if *f0F09 = new(mem_ctx) ir_if(operand(r0F0A).val);
                  exec_list *const f0F09_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F09->then_instructions;

                     body.emit(assign(r0F07, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F09->else_instructions;

                     body.emit(assign(r0F08, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0F0C = bit_and(r0E7E, body.constant(4294901760u));
                     ir_expression *const r0F0D = equal(r0F0C, body.constant(0u));
                     ir_if *f0F0B = new(mem_ctx) ir_if(operand(r0F0D).val);
                     exec_list *const f0F0B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F0B->then_instructions;

                        body.emit(assign(r0F08, body.constant(int(16)), 0x01));

                        body.emit(assign(r0F06, lshift(r0E7E, body.constant(int(16))), 0x01));


                     body.instructions = f0F0B_parent_instructions;
                     body.emit(f0F0B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0F0F = bit_and(r0F06, body.constant(4278190080u));
                     ir_expression *const r0F10 = equal(r0F0F, body.constant(0u));
                     ir_if *f0F0E = new(mem_ctx) ir_if(operand(r0F10).val);
                     exec_list *const f0F0E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F0E->then_instructions;

                        body.emit(assign(r0F08, add(r0F08, body.constant(int(8))), 0x01));

                        body.emit(assign(r0F06, lshift(r0F06, body.constant(int(8))), 0x01));


                     body.instructions = f0F0E_parent_instructions;
                     body.emit(f0F0E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0F12 = bit_and(r0F06, body.constant(4026531840u));
                     ir_expression *const r0F13 = equal(r0F12, body.constant(0u));
                     ir_if *f0F11 = new(mem_ctx) ir_if(operand(r0F13).val);
                     exec_list *const f0F11_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F11->then_instructions;

                        body.emit(assign(r0F08, add(r0F08, body.constant(int(4))), 0x01));

                        body.emit(assign(r0F06, lshift(r0F06, body.constant(int(4))), 0x01));


                     body.instructions = f0F11_parent_instructions;
                     body.emit(f0F11);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0F15 = bit_and(r0F06, body.constant(3221225472u));
                     ir_expression *const r0F16 = equal(r0F15, body.constant(0u));
                     ir_if *f0F14 = new(mem_ctx) ir_if(operand(r0F16).val);
                     exec_list *const f0F14_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F14->then_instructions;

                        body.emit(assign(r0F08, add(r0F08, body.constant(int(2))), 0x01));

                        body.emit(assign(r0F06, lshift(r0F06, body.constant(int(2))), 0x01));


                     body.instructions = f0F14_parent_instructions;
                     body.emit(f0F14);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0F18 = bit_and(r0F06, body.constant(2147483648u));
                     ir_expression *const r0F19 = equal(r0F18, body.constant(0u));
                     ir_if *f0F17 = new(mem_ctx) ir_if(operand(r0F19).val);
                     exec_list *const f0F17_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F17->then_instructions;

                        body.emit(assign(r0F08, add(r0F08, body.constant(int(1))), 0x01));


                     body.instructions = f0F17_parent_instructions;
                     body.emit(f0F17);

                     /* END IF */

                     body.emit(assign(r0F07, r0F08, 0x01));


                  body.instructions = f0F09_parent_instructions;
                  body.emit(f0F09);

                  /* END IF */

                  body.emit(assign(r0EEB, add(r0F07, body.constant(int(-11))), 0x01));

                  ir_variable *const r0F1A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0F1A, lshift(swizzle_x(r0E6E), r0EEB), 0x01));

                  ir_variable *const r0F1B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F1D = equal(r0EEB, body.constant(int(0)));
                  ir_if *f0F1C = new(mem_ctx) ir_if(operand(r0F1D).val);
                  exec_list *const f0F1C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F1C->then_instructions;

                     body.emit(assign(r0F1B, r0E7E, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F1C->else_instructions;

                     ir_expression *const r0F1E = lshift(r0E7E, r0EEB);
                     ir_expression *const r0F1F = neg(r0EEB);
                     ir_expression *const r0F20 = bit_and(r0F1F, body.constant(int(31)));
                     ir_expression *const r0F21 = rshift(swizzle_x(r0E6E), r0F20);
                     body.emit(assign(r0F1B, bit_or(r0F1E, r0F21), 0x01));


                  body.instructions = f0F1C_parent_instructions;
                  body.emit(f0F1C);

                  /* END IF */

                  body.emit(assign(r0EE9, r0F1B, 0x01));

                  body.emit(assign(r0EEA, r0F1A, 0x01));

                  body.emit(assign(r0EE8, sub(body.constant(int(1)), r0EEB), 0x01));


               body.instructions = f0EEC_parent_instructions;
               body.emit(f0EEC);

               /* END IF */

               body.emit(assign(r0E74, r0EE8, 0x01));

               body.emit(assign(r0E77, r0EE9, 0x01));

               body.emit(assign(r0E78, r0EEA, 0x01));


            body.instructions = f0EE4_parent_instructions;
            body.emit(f0EE4);

            /* END IF */


         body.instructions = f0EE2_parent_instructions;
         body.emit(f0EE2);

         /* END IF */

         /* IF CONDITION */
         ir_if *f0F22 = new(mem_ctx) ir_if(operand(r0E70).val);
         exec_list *const f0F22_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0F22->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0F24 = equal(r0E84, body.constant(int(0)));
            ir_if *f0F23 = new(mem_ctx) ir_if(operand(r0F24).val);
            exec_list *const f0F23_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0F23->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0F26 = bit_or(r0E80, swizzle_x(r0E6F));
               ir_expression *const r0F27 = equal(r0F26, body.constant(0u));
               ir_if *f0F25 = new(mem_ctx) ir_if(operand(r0F27).val);
               exec_list *const f0F25_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F25->then_instructions;

                  ir_variable *const r0F28 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0F28);
                  body.emit(assign(r0F28, lshift(r0E72, body.constant(int(31))), 0x02));

                  body.emit(assign(r0F28, body.constant(0u), 0x01));

                  body.emit(assign(r0E71, r0F28, 0x03));

                  body.emit(assign(r0E70, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F25->else_instructions;

                  ir_variable *const r0F29 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r0F29, r0E84, 0x01));

                  ir_variable *const r0F2A = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r0F2A, r0E80, 0x01));

                  ir_variable *const r0F2B = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r0F2B, r0E7F, 0x01));

                  ir_variable *const r0F2C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0F2C);
                  /* IF CONDITION */
                  ir_expression *const r0F2E = equal(r0E80, body.constant(0u));
                  ir_if *f0F2D = new(mem_ctx) ir_if(operand(r0F2E).val);
                  exec_list *const f0F2D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F2D->then_instructions;

                     ir_variable *const r0F2F = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0F2F, r0E7F, 0x01));

                     ir_variable *const r0F30 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0F31 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0F31);
                     /* IF CONDITION */
                     ir_expression *const r0F33 = equal(swizzle_x(r0E6F), body.constant(0u));
                     ir_if *f0F32 = new(mem_ctx) ir_if(operand(r0F33).val);
                     exec_list *const f0F32_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F32->then_instructions;

                        body.emit(assign(r0F30, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F32->else_instructions;

                        body.emit(assign(r0F31, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0F35 = bit_and(swizzle_x(r0E6F), body.constant(4294901760u));
                        ir_expression *const r0F36 = equal(r0F35, body.constant(0u));
                        ir_if *f0F34 = new(mem_ctx) ir_if(operand(r0F36).val);
                        exec_list *const f0F34_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F34->then_instructions;

                           body.emit(assign(r0F31, body.constant(int(16)), 0x01));

                           body.emit(assign(r0F2F, lshift(swizzle_x(r0E6F), body.constant(int(16))), 0x01));


                        body.instructions = f0F34_parent_instructions;
                        body.emit(f0F34);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F38 = bit_and(r0F2F, body.constant(4278190080u));
                        ir_expression *const r0F39 = equal(r0F38, body.constant(0u));
                        ir_if *f0F37 = new(mem_ctx) ir_if(operand(r0F39).val);
                        exec_list *const f0F37_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F37->then_instructions;

                           body.emit(assign(r0F31, add(r0F31, body.constant(int(8))), 0x01));

                           body.emit(assign(r0F2F, lshift(r0F2F, body.constant(int(8))), 0x01));


                        body.instructions = f0F37_parent_instructions;
                        body.emit(f0F37);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F3B = bit_and(r0F2F, body.constant(4026531840u));
                        ir_expression *const r0F3C = equal(r0F3B, body.constant(0u));
                        ir_if *f0F3A = new(mem_ctx) ir_if(operand(r0F3C).val);
                        exec_list *const f0F3A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F3A->then_instructions;

                           body.emit(assign(r0F31, add(r0F31, body.constant(int(4))), 0x01));

                           body.emit(assign(r0F2F, lshift(r0F2F, body.constant(int(4))), 0x01));


                        body.instructions = f0F3A_parent_instructions;
                        body.emit(f0F3A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F3E = bit_and(r0F2F, body.constant(3221225472u));
                        ir_expression *const r0F3F = equal(r0F3E, body.constant(0u));
                        ir_if *f0F3D = new(mem_ctx) ir_if(operand(r0F3F).val);
                        exec_list *const f0F3D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F3D->then_instructions;

                           body.emit(assign(r0F31, add(r0F31, body.constant(int(2))), 0x01));

                           body.emit(assign(r0F2F, lshift(r0F2F, body.constant(int(2))), 0x01));


                        body.instructions = f0F3D_parent_instructions;
                        body.emit(f0F3D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F41 = bit_and(r0F2F, body.constant(2147483648u));
                        ir_expression *const r0F42 = equal(r0F41, body.constant(0u));
                        ir_if *f0F40 = new(mem_ctx) ir_if(operand(r0F42).val);
                        exec_list *const f0F40_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F40->then_instructions;

                           body.emit(assign(r0F31, add(r0F31, body.constant(int(1))), 0x01));


                        body.instructions = f0F40_parent_instructions;
                        body.emit(f0F40);

                        /* END IF */

                        body.emit(assign(r0F30, r0F31, 0x01));


                     body.instructions = f0F32_parent_instructions;
                     body.emit(f0F32);

                     /* END IF */

                     body.emit(assign(r0F2C, add(r0F30, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0F44 = less(r0F2C, body.constant(int(0)));
                     ir_if *f0F43 = new(mem_ctx) ir_if(operand(r0F44).val);
                     exec_list *const f0F43_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F43->then_instructions;

                        ir_expression *const r0F45 = neg(r0F2C);
                        body.emit(assign(r0F2A, rshift(swizzle_x(r0E6F), r0F45), 0x01));

                        ir_expression *const r0F46 = bit_and(r0F2C, body.constant(int(31)));
                        body.emit(assign(r0F2B, lshift(swizzle_x(r0E6F), r0F46), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F43->else_instructions;

                        body.emit(assign(r0F2A, lshift(swizzle_x(r0E6F), r0F2C), 0x01));

                        body.emit(assign(r0F2B, body.constant(0u), 0x01));


                     body.instructions = f0F43_parent_instructions;
                     body.emit(f0F43);

                     /* END IF */

                     body.emit(assign(r0F29, sub(body.constant(int(-31)), r0F2C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F2D->else_instructions;

                     ir_variable *const r0F47 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0F47, r0E80, 0x01));

                     ir_variable *const r0F48 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0F49 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0F49);
                     /* IF CONDITION */
                     ir_expression *const r0F4B = equal(r0E80, body.constant(0u));
                     ir_if *f0F4A = new(mem_ctx) ir_if(operand(r0F4B).val);
                     exec_list *const f0F4A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F4A->then_instructions;

                        body.emit(assign(r0F48, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F4A->else_instructions;

                        body.emit(assign(r0F49, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0F4D = bit_and(r0E80, body.constant(4294901760u));
                        ir_expression *const r0F4E = equal(r0F4D, body.constant(0u));
                        ir_if *f0F4C = new(mem_ctx) ir_if(operand(r0F4E).val);
                        exec_list *const f0F4C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F4C->then_instructions;

                           body.emit(assign(r0F49, body.constant(int(16)), 0x01));

                           body.emit(assign(r0F47, lshift(r0E80, body.constant(int(16))), 0x01));


                        body.instructions = f0F4C_parent_instructions;
                        body.emit(f0F4C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F50 = bit_and(r0F47, body.constant(4278190080u));
                        ir_expression *const r0F51 = equal(r0F50, body.constant(0u));
                        ir_if *f0F4F = new(mem_ctx) ir_if(operand(r0F51).val);
                        exec_list *const f0F4F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F4F->then_instructions;

                           body.emit(assign(r0F49, add(r0F49, body.constant(int(8))), 0x01));

                           body.emit(assign(r0F47, lshift(r0F47, body.constant(int(8))), 0x01));


                        body.instructions = f0F4F_parent_instructions;
                        body.emit(f0F4F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F53 = bit_and(r0F47, body.constant(4026531840u));
                        ir_expression *const r0F54 = equal(r0F53, body.constant(0u));
                        ir_if *f0F52 = new(mem_ctx) ir_if(operand(r0F54).val);
                        exec_list *const f0F52_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F52->then_instructions;

                           body.emit(assign(r0F49, add(r0F49, body.constant(int(4))), 0x01));

                           body.emit(assign(r0F47, lshift(r0F47, body.constant(int(4))), 0x01));


                        body.instructions = f0F52_parent_instructions;
                        body.emit(f0F52);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F56 = bit_and(r0F47, body.constant(3221225472u));
                        ir_expression *const r0F57 = equal(r0F56, body.constant(0u));
                        ir_if *f0F55 = new(mem_ctx) ir_if(operand(r0F57).val);
                        exec_list *const f0F55_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F55->then_instructions;

                           body.emit(assign(r0F49, add(r0F49, body.constant(int(2))), 0x01));

                           body.emit(assign(r0F47, lshift(r0F47, body.constant(int(2))), 0x01));


                        body.instructions = f0F55_parent_instructions;
                        body.emit(f0F55);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F59 = bit_and(r0F47, body.constant(2147483648u));
                        ir_expression *const r0F5A = equal(r0F59, body.constant(0u));
                        ir_if *f0F58 = new(mem_ctx) ir_if(operand(r0F5A).val);
                        exec_list *const f0F58_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F58->then_instructions;

                           body.emit(assign(r0F49, add(r0F49, body.constant(int(1))), 0x01));


                        body.instructions = f0F58_parent_instructions;
                        body.emit(f0F58);

                        /* END IF */

                        body.emit(assign(r0F48, r0F49, 0x01));


                     body.instructions = f0F4A_parent_instructions;
                     body.emit(f0F4A);

                     /* END IF */

                     body.emit(assign(r0F2C, add(r0F48, body.constant(int(-11))), 0x01));

                     ir_variable *const r0F5B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0F5B, lshift(swizzle_x(r0E6F), r0F2C), 0x01));

                     ir_variable *const r0F5C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F5E = equal(r0F2C, body.constant(int(0)));
                     ir_if *f0F5D = new(mem_ctx) ir_if(operand(r0F5E).val);
                     exec_list *const f0F5D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F5D->then_instructions;

                        body.emit(assign(r0F5C, r0E80, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F5D->else_instructions;

                        ir_expression *const r0F5F = lshift(r0E80, r0F2C);
                        ir_expression *const r0F60 = neg(r0F2C);
                        ir_expression *const r0F61 = bit_and(r0F60, body.constant(int(31)));
                        ir_expression *const r0F62 = rshift(swizzle_x(r0E6F), r0F61);
                        body.emit(assign(r0F5C, bit_or(r0F5F, r0F62), 0x01));


                     body.instructions = f0F5D_parent_instructions;
                     body.emit(f0F5D);

                     /* END IF */

                     body.emit(assign(r0F2A, r0F5C, 0x01));

                     body.emit(assign(r0F2B, r0F5B, 0x01));

                     body.emit(assign(r0F29, sub(body.constant(int(1)), r0F2C), 0x01));


                  body.instructions = f0F2D_parent_instructions;
                  body.emit(f0F2D);

                  /* END IF */

                  body.emit(assign(r0E73, r0F29, 0x01));

                  body.emit(assign(r0E75, r0F2A, 0x01));

                  body.emit(assign(r0E76, r0F2B, 0x01));


               body.instructions = f0F25_parent_instructions;
               body.emit(f0F25);

               /* END IF */


            body.instructions = f0F23_parent_instructions;
            body.emit(f0F23);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0F63 = new(mem_ctx) ir_if(operand(r0E70).val);
            exec_list *const f0F63_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0F63->then_instructions;

               ir_expression *const r0F64 = add(r0E74, r0E73);
               body.emit(assign(r0E79, add(r0F64, body.constant(int(-1024))), 0x01));

               body.emit(assign(r0E77, bit_or(r0E77, body.constant(1048576u)), 0x01));

               ir_variable *const r0F65 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0F65, lshift(r0E76, body.constant(int(12))), 0x01));

               ir_variable *const r0F66 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r0F67 = lshift(r0E75, body.constant(int(12)));
               ir_expression *const r0F68 = rshift(r0E76, body.constant(int(20)));
               body.emit(assign(r0F66, bit_or(r0F67, r0F68), 0x01));

               body.emit(assign(r0E75, r0F66, 0x01));

               body.emit(assign(r0E76, r0F65, 0x01));

               ir_variable *const r0F69 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0F69);
               ir_variable *const r0F6A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r0F6A);
               ir_variable *const r0F6B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0F6B);
               ir_variable *const r0F6C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F6C, bit_and(r0E78, body.constant(65535u)), 0x01));

               ir_variable *const r0F6D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F6D, rshift(r0E78, body.constant(int(16))), 0x01));

               ir_variable *const r0F6E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F6E, bit_and(r0F65, body.constant(65535u)), 0x01));

               ir_variable *const r0F6F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F6F, rshift(r0F65, body.constant(int(16))), 0x01));

               ir_variable *const r0F70 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F70, mul(r0F6D, r0F6E), 0x01));

               ir_expression *const r0F71 = mul(r0F6C, r0F6F);
               body.emit(assign(r0F6A, add(r0F71, r0F70), 0x01));

               ir_expression *const r0F72 = mul(r0F6D, r0F6F);
               ir_expression *const r0F73 = less(r0F6A, r0F70);
               ir_expression *const r0F74 = expr(ir_unop_b2i, r0F73);
               ir_expression *const r0F75 = expr(ir_unop_i2u, r0F74);
               ir_expression *const r0F76 = lshift(r0F75, body.constant(int(16)));
               ir_expression *const r0F77 = rshift(r0F6A, body.constant(int(16)));
               ir_expression *const r0F78 = add(r0F76, r0F77);
               body.emit(assign(r0F69, add(r0F72, r0F78), 0x01));

               body.emit(assign(r0F6A, lshift(r0F6A, body.constant(int(16))), 0x01));

               ir_expression *const r0F79 = mul(r0F6C, r0F6E);
               body.emit(assign(r0F6B, add(r0F79, r0F6A), 0x01));

               ir_expression *const r0F7A = less(r0F6B, r0F6A);
               ir_expression *const r0F7B = expr(ir_unop_b2i, r0F7A);
               ir_expression *const r0F7C = expr(ir_unop_i2u, r0F7B);
               body.emit(assign(r0F69, add(r0F69, r0F7C), 0x01));

               ir_variable *const r0F7D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0F7D);
               ir_variable *const r0F7E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r0F7E);
               ir_variable *const r0F7F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0F7F);
               ir_variable *const r0F80 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F80, bit_and(r0E78, body.constant(65535u)), 0x01));

               ir_variable *const r0F81 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F81, rshift(r0E78, body.constant(int(16))), 0x01));

               ir_variable *const r0F82 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F82, bit_and(r0F66, body.constant(65535u)), 0x01));

               ir_variable *const r0F83 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F83, rshift(r0F66, body.constant(int(16))), 0x01));

               ir_variable *const r0F84 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F84, mul(r0F81, r0F82), 0x01));

               ir_expression *const r0F85 = mul(r0F80, r0F83);
               body.emit(assign(r0F7E, add(r0F85, r0F84), 0x01));

               ir_expression *const r0F86 = mul(r0F81, r0F83);
               ir_expression *const r0F87 = less(r0F7E, r0F84);
               ir_expression *const r0F88 = expr(ir_unop_b2i, r0F87);
               ir_expression *const r0F89 = expr(ir_unop_i2u, r0F88);
               ir_expression *const r0F8A = lshift(r0F89, body.constant(int(16)));
               ir_expression *const r0F8B = rshift(r0F7E, body.constant(int(16)));
               ir_expression *const r0F8C = add(r0F8A, r0F8B);
               body.emit(assign(r0F7D, add(r0F86, r0F8C), 0x01));

               body.emit(assign(r0F7E, lshift(r0F7E, body.constant(int(16))), 0x01));

               ir_expression *const r0F8D = mul(r0F80, r0F82);
               body.emit(assign(r0F7F, add(r0F8D, r0F7E), 0x01));

               ir_expression *const r0F8E = less(r0F7F, r0F7E);
               ir_expression *const r0F8F = expr(ir_unop_b2i, r0F8E);
               ir_expression *const r0F90 = expr(ir_unop_i2u, r0F8F);
               body.emit(assign(r0F7D, add(r0F7D, r0F90), 0x01));

               ir_variable *const r0F91 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F91, add(r0F7F, r0F69), 0x01));

               ir_variable *const r0F92 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0F92);
               ir_variable *const r0F93 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r0F93);
               ir_variable *const r0F94 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0F94);
               ir_variable *const r0F95 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F95, bit_and(r0E77, body.constant(65535u)), 0x01));

               ir_variable *const r0F96 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F96, rshift(r0E77, body.constant(int(16))), 0x01));

               ir_variable *const r0F97 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F97, bit_and(r0F66, body.constant(65535u)), 0x01));

               ir_variable *const r0F98 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F98, rshift(r0F66, body.constant(int(16))), 0x01));

               ir_variable *const r0F99 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F99, mul(r0F96, r0F97), 0x01));

               ir_expression *const r0F9A = mul(r0F95, r0F98);
               body.emit(assign(r0F93, add(r0F9A, r0F99), 0x01));

               ir_expression *const r0F9B = mul(r0F96, r0F98);
               ir_expression *const r0F9C = less(r0F93, r0F99);
               ir_expression *const r0F9D = expr(ir_unop_b2i, r0F9C);
               ir_expression *const r0F9E = expr(ir_unop_i2u, r0F9D);
               ir_expression *const r0F9F = lshift(r0F9E, body.constant(int(16)));
               ir_expression *const r0FA0 = rshift(r0F93, body.constant(int(16)));
               ir_expression *const r0FA1 = add(r0F9F, r0FA0);
               body.emit(assign(r0F92, add(r0F9B, r0FA1), 0x01));

               body.emit(assign(r0F93, lshift(r0F93, body.constant(int(16))), 0x01));

               ir_expression *const r0FA2 = mul(r0F95, r0F97);
               body.emit(assign(r0F94, add(r0FA2, r0F93), 0x01));

               ir_expression *const r0FA3 = less(r0F94, r0F93);
               ir_expression *const r0FA4 = expr(ir_unop_b2i, r0FA3);
               ir_expression *const r0FA5 = expr(ir_unop_i2u, r0FA4);
               body.emit(assign(r0F92, add(r0F92, r0FA5), 0x01));

               ir_variable *const r0FA6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r0FA7 = less(r0F91, r0F7F);
               ir_expression *const r0FA8 = expr(ir_unop_b2i, r0FA7);
               ir_expression *const r0FA9 = expr(ir_unop_i2u, r0FA8);
               ir_expression *const r0FAA = add(r0F7D, r0FA9);
               body.emit(assign(r0FA6, add(r0F94, r0FAA), 0x01));

               ir_variable *const r0FAB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0FAB);
               ir_variable *const r0FAC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r0FAC);
               ir_variable *const r0FAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0FAD);
               ir_variable *const r0FAE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FAE, bit_and(r0E77, body.constant(65535u)), 0x01));

               ir_variable *const r0FAF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FAF, rshift(r0E77, body.constant(int(16))), 0x01));

               ir_variable *const r0FB0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FB0, bit_and(r0F65, body.constant(65535u)), 0x01));

               ir_variable *const r0FB1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FB1, rshift(r0F65, body.constant(int(16))), 0x01));

               ir_variable *const r0FB2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FB2, mul(r0FAF, r0FB0), 0x01));

               ir_expression *const r0FB3 = mul(r0FAE, r0FB1);
               body.emit(assign(r0FAC, add(r0FB3, r0FB2), 0x01));

               ir_expression *const r0FB4 = mul(r0FAF, r0FB1);
               ir_expression *const r0FB5 = less(r0FAC, r0FB2);
               ir_expression *const r0FB6 = expr(ir_unop_b2i, r0FB5);
               ir_expression *const r0FB7 = expr(ir_unop_i2u, r0FB6);
               ir_expression *const r0FB8 = lshift(r0FB7, body.constant(int(16)));
               ir_expression *const r0FB9 = rshift(r0FAC, body.constant(int(16)));
               ir_expression *const r0FBA = add(r0FB8, r0FB9);
               body.emit(assign(r0FAB, add(r0FB4, r0FBA), 0x01));

               body.emit(assign(r0FAC, lshift(r0FAC, body.constant(int(16))), 0x01));

               ir_expression *const r0FBB = mul(r0FAE, r0FB0);
               body.emit(assign(r0FAD, add(r0FBB, r0FAC), 0x01));

               ir_expression *const r0FBC = less(r0FAD, r0FAC);
               ir_expression *const r0FBD = expr(ir_unop_b2i, r0FBC);
               ir_expression *const r0FBE = expr(ir_unop_i2u, r0FBD);
               body.emit(assign(r0FAB, add(r0FAB, r0FBE), 0x01));

               ir_variable *const r0FBF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FBF, add(r0FAD, r0F91), 0x01));

               ir_variable *const r0FC0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r0FC1 = less(r0FBF, r0FAD);
               ir_expression *const r0FC2 = expr(ir_unop_b2i, r0FC1);
               ir_expression *const r0FC3 = expr(ir_unop_i2u, r0FC2);
               ir_expression *const r0FC4 = add(r0FAB, r0FC3);
               body.emit(assign(r0FC0, add(r0FA6, r0FC4), 0x01));

               ir_variable *const r0FC5 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0FC6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FC6, add(r0FC0, r0E78), 0x01));

               ir_expression *const r0FC7 = less(r0FA6, r0F94);
               ir_expression *const r0FC8 = expr(ir_unop_b2i, r0FC7);
               ir_expression *const r0FC9 = expr(ir_unop_i2u, r0FC8);
               ir_expression *const r0FCA = add(r0F92, r0FC9);
               ir_expression *const r0FCB = less(r0FC0, r0FA6);
               ir_expression *const r0FCC = expr(ir_unop_b2i, r0FCB);
               ir_expression *const r0FCD = expr(ir_unop_i2u, r0FCC);
               ir_expression *const r0FCE = add(r0FCA, r0FCD);
               ir_expression *const r0FCF = add(r0FCE, r0E77);
               ir_expression *const r0FD0 = less(r0FC6, r0FC0);
               ir_expression *const r0FD1 = expr(ir_unop_b2i, r0FD0);
               ir_expression *const r0FD2 = expr(ir_unop_i2u, r0FD1);
               body.emit(assign(r0FC5, add(r0FCF, r0FD2), 0x01));

               body.emit(assign(r0E7C, r0FC5, 0x01));

               body.emit(assign(r0E7B, r0FC6, 0x01));

               ir_expression *const r0FD3 = nequal(r0F6B, body.constant(0u));
               ir_expression *const r0FD4 = expr(ir_unop_b2i, r0FD3);
               ir_expression *const r0FD5 = expr(ir_unop_i2u, r0FD4);
               body.emit(assign(r0E7A, bit_or(r0FBF, r0FD5), 0x01));

               /* IF CONDITION */
               ir_expression *const r0FD7 = lequal(body.constant(2097152u), r0FC5);
               ir_if *f0FD6 = new(mem_ctx) ir_if(operand(r0FD7).val);
               exec_list *const f0FD6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0FD6->then_instructions;

                  ir_variable *const r0FD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0FD8);
                  body.emit(assign(r0FD8, lshift(r0FC6, body.constant(int(31))), 0x01));

                  ir_expression *const r0FD9 = nequal(r0E7A, body.constant(0u));
                  ir_expression *const r0FDA = expr(ir_unop_b2i, r0FD9);
                  ir_expression *const r0FDB = expr(ir_unop_i2u, r0FDA);
                  body.emit(assign(r0FD8, bit_or(r0FD8, r0FDB), 0x01));

                  body.emit(assign(r0E7C, rshift(r0FC5, body.constant(int(1))), 0x01));

                  ir_expression *const r0FDC = lshift(r0FC5, body.constant(int(31)));
                  ir_expression *const r0FDD = rshift(r0FC6, body.constant(int(1)));
                  body.emit(assign(r0E7B, bit_or(r0FDC, r0FDD), 0x01));

                  body.emit(assign(r0E7A, r0FD8, 0x01));

                  body.emit(assign(r0E79, add(r0E79, body.constant(int(1))), 0x01));


               body.instructions = f0FD6_parent_instructions;
               body.emit(f0FD6);

               /* END IF */

               ir_variable *const r0FDE = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0FDE, r0E79, 0x01));

               ir_variable *const r0FDF = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0FDF, r0E7C, 0x01));

               ir_variable *const r0FE0 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0FE0, r0E7B, 0x01));

               ir_variable *const r0FE1 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0FE1, r0E7A, 0x01));

               ir_variable *const r0FE2 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0FE2, body.constant(true), 0x01));

               ir_variable *const r0FE3 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0FE4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0FE4);
               ir_expression *const r0FE5 = expr(ir_unop_u2i, r0E7A);
               body.emit(assign(r0FE4, less(r0FE5, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0FE7 = lequal(body.constant(int(2045)), r0E79);
               ir_if *f0FE6 = new(mem_ctx) ir_if(operand(r0FE7).val);
               exec_list *const f0FE6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0FE6->then_instructions;

                  ir_variable *const r0FE8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0FEA = less(body.constant(int(2045)), r0E79);
                  ir_if *f0FE9 = new(mem_ctx) ir_if(operand(r0FEA).val);
                  exec_list *const f0FE9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FE9->then_instructions;

                     body.emit(assign(r0FE8, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FE9->else_instructions;

                     ir_variable *const r0FEB = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FED = equal(r0E79, body.constant(int(2045)));
                     ir_if *f0FEC = new(mem_ctx) ir_if(operand(r0FED).val);
                     exec_list *const f0FEC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FEC->then_instructions;

                        ir_expression *const r0FEE = equal(body.constant(2097151u), r0E7C);
                        ir_expression *const r0FEF = equal(body.constant(4294967295u), r0E7B);
                        body.emit(assign(r0FEB, logic_and(r0FEE, r0FEF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FEC->else_instructions;

                        body.emit(assign(r0FEB, body.constant(false), 0x01));


                     body.instructions = f0FEC_parent_instructions;
                     body.emit(f0FEC);

                     /* END IF */

                     body.emit(assign(r0FE8, logic_and(r0FEB, r0FE4), 0x01));


                  body.instructions = f0FE9_parent_instructions;
                  body.emit(f0FE9);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0FF0 = new(mem_ctx) ir_if(operand(r0FE8).val);
                  exec_list *const f0FF0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FF0->then_instructions;

                     ir_variable *const r0FF1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0FF1);
                     ir_expression *const r0FF2 = lshift(r0E72, body.constant(int(31)));
                     body.emit(assign(r0FF1, add(r0FF2, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0FF1, body.constant(0u), 0x01));

                     body.emit(assign(r0FE3, r0FF1, 0x03));

                     body.emit(assign(r0FE2, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FF0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0FF4 = less(r0E79, body.constant(int(0)));
                     ir_if *f0FF3 = new(mem_ctx) ir_if(operand(r0FF4).val);
                     exec_list *const f0FF3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FF3->then_instructions;

                        ir_variable *const r0FF5 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0FF5, r0E7A, 0x01));

                        ir_variable *const r0FF6 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0FF6, neg(r0E79), 0x01));

                        ir_variable *const r0FF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0FF7);
                        ir_variable *const r0FF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0FF8);
                        ir_variable *const r0FF9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0FF9);
                        ir_variable *const r0FFA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0FFB = neg(r0FF6);
                        body.emit(assign(r0FFA, bit_and(r0FFB, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0FFD = equal(r0FF6, body.constant(int(0)));
                        ir_if *f0FFC = new(mem_ctx) ir_if(operand(r0FFD).val);
                        exec_list *const f0FFC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FFC->then_instructions;

                           body.emit(assign(r0FF7, r0E7A, 0x01));

                           body.emit(assign(r0FF8, r0E7B, 0x01));

                           body.emit(assign(r0FF9, r0E7C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FFC->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0FFF = less(r0FF6, body.constant(int(32)));
                           ir_if *f0FFE = new(mem_ctx) ir_if(operand(r0FFF).val);
                           exec_list *const f0FFE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0FFE->then_instructions;

                              body.emit(assign(r0FF7, lshift(r0E7B, r0FFA), 0x01));

                              ir_expression *const r1000 = lshift(r0E7C, r0FFA);
                              ir_expression *const r1001 = rshift(r0E7B, r0FF6);
                              body.emit(assign(r0FF8, bit_or(r1000, r1001), 0x01));

                              body.emit(assign(r0FF9, rshift(r0E7C, r0FF6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0FFE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1003 = equal(r0FF6, body.constant(int(32)));
                              ir_if *f1002 = new(mem_ctx) ir_if(operand(r1003).val);
                              exec_list *const f1002_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1002->then_instructions;

                                 body.emit(assign(r0FF7, r0E7B, 0x01));

                                 body.emit(assign(r0FF8, r0E7C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1002->else_instructions;

                                 body.emit(assign(r0FF5, bit_or(r0E7A, r0E7B), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1005 = less(r0FF6, body.constant(int(64)));
                                 ir_if *f1004 = new(mem_ctx) ir_if(operand(r1005).val);
                                 exec_list *const f1004_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1004->then_instructions;

                                    body.emit(assign(r0FF7, lshift(r0E7C, r0FFA), 0x01));

                                    ir_expression *const r1006 = bit_and(r0FF6, body.constant(int(31)));
                                    body.emit(assign(r0FF8, rshift(r0E7C, r1006), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1004->else_instructions;

                                    ir_variable *const r1007 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1009 = equal(r0FF6, body.constant(int(64)));
                                    ir_if *f1008 = new(mem_ctx) ir_if(operand(r1009).val);
                                    exec_list *const f1008_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1008->then_instructions;

                                       body.emit(assign(r1007, r0E7C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1008->else_instructions;

                                       ir_expression *const r100A = nequal(r0E7C, body.constant(0u));
                                       ir_expression *const r100B = expr(ir_unop_b2i, r100A);
                                       body.emit(assign(r1007, expr(ir_unop_i2u, r100B), 0x01));


                                    body.instructions = f1008_parent_instructions;
                                    body.emit(f1008);

                                    /* END IF */

                                    body.emit(assign(r0FF7, r1007, 0x01));

                                    body.emit(assign(r0FF8, body.constant(0u), 0x01));


                                 body.instructions = f1004_parent_instructions;
                                 body.emit(f1004);

                                 /* END IF */


                              body.instructions = f1002_parent_instructions;
                              body.emit(f1002);

                              /* END IF */

                              body.emit(assign(r0FF9, body.constant(0u), 0x01));


                           body.instructions = f0FFE_parent_instructions;
                           body.emit(f0FFE);

                           /* END IF */

                           ir_expression *const r100C = nequal(r0FF5, body.constant(0u));
                           ir_expression *const r100D = expr(ir_unop_b2i, r100C);
                           ir_expression *const r100E = expr(ir_unop_i2u, r100D);
                           body.emit(assign(r0FF7, bit_or(r0FF7, r100E), 0x01));


                        body.instructions = f0FFC_parent_instructions;
                        body.emit(f0FFC);

                        /* END IF */

                        body.emit(assign(r0FDF, r0FF9, 0x01));

                        body.emit(assign(r0FE0, r0FF8, 0x01));

                        body.emit(assign(r0FE1, r0FF7, 0x01));

                        body.emit(assign(r0FDE, body.constant(int(0)), 0x01));

                        body.emit(assign(r0FE4, less(r0FF7, body.constant(0u)), 0x01));


                     body.instructions = f0FF3_parent_instructions;
                     body.emit(f0FF3);

                     /* END IF */


                  body.instructions = f0FF0_parent_instructions;
                  body.emit(f0FF0);

                  /* END IF */


               body.instructions = f0FE6_parent_instructions;
               body.emit(f0FE6);

               /* END IF */

               /* IF CONDITION */
               ir_if *f100F = new(mem_ctx) ir_if(operand(r0FE2).val);
               exec_list *const f100F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f100F->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1010 = new(mem_ctx) ir_if(operand(r0FE4).val);
                  exec_list *const f1010_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1010->then_instructions;

                     ir_variable *const r1011 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1011, add(r0FE0, body.constant(1u)), 0x01));

                     ir_expression *const r1012 = less(r1011, r0FE0);
                     ir_expression *const r1013 = expr(ir_unop_b2i, r1012);
                     ir_expression *const r1014 = expr(ir_unop_i2u, r1013);
                     body.emit(assign(r0FDF, add(r0FDF, r1014), 0x01));

                     ir_expression *const r1015 = equal(r0FE1, body.constant(0u));
                     ir_expression *const r1016 = expr(ir_unop_b2i, r1015);
                     ir_expression *const r1017 = expr(ir_unop_i2u, r1016);
                     ir_expression *const r1018 = add(r0FE1, r1017);
                     ir_expression *const r1019 = bit_and(r1018, body.constant(1u));
                     ir_expression *const r101A = expr(ir_unop_bit_not, r1019);
                     body.emit(assign(r0FE0, bit_and(r1011, r101A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1010->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r101C = bit_or(r0FDF, r0FE0);
                     ir_expression *const r101D = equal(r101C, body.constant(0u));
                     ir_if *f101B = new(mem_ctx) ir_if(operand(r101D).val);
                     exec_list *const f101B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f101B->then_instructions;

                        body.emit(assign(r0FDE, body.constant(int(0)), 0x01));


                     body.instructions = f101B_parent_instructions;
                     body.emit(f101B);

                     /* END IF */


                  body.instructions = f1010_parent_instructions;
                  body.emit(f1010);

                  /* END IF */

                  ir_variable *const r101E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r101E);
                  ir_expression *const r101F = lshift(r0E72, body.constant(int(31)));
                  ir_expression *const r1020 = expr(ir_unop_i2u, r0FDE);
                  ir_expression *const r1021 = lshift(r1020, body.constant(int(20)));
                  ir_expression *const r1022 = add(r101F, r1021);
                  body.emit(assign(r101E, add(r1022, r0FDF), 0x02));

                  body.emit(assign(r101E, r0FE0, 0x01));

                  body.emit(assign(r0FE3, r101E, 0x03));

                  body.emit(assign(r0FE2, body.constant(false), 0x01));


               body.instructions = f100F_parent_instructions;
               body.emit(f100F);

               /* END IF */

               body.emit(assign(r0E71, r0FE3, 0x03));

               body.emit(assign(r0E70, body.constant(false), 0x01));


            body.instructions = f0F63_parent_instructions;
            body.emit(f0F63);

            /* END IF */


         body.instructions = f0F22_parent_instructions;
         body.emit(f0F22);

         /* END IF */


      body.instructions = f0EB8_parent_instructions;
      body.emit(f0EB8);

      /* END IF */


   body.instructions = f0E89_parent_instructions;
   body.emit(f0E89);

   /* END IF */

   body.emit(ret(r0E71));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1023 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1023);
   ir_variable *const r1024 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1024);
   ir_variable *const r1025 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r1025);
   ir_variable *const r1026 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r1026);
   ir_variable *const r1027 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1027);
   ir_variable *const r1028 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r1028);
   ir_variable *const r1029 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1029);
   ir_variable *const r102A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r102A);
   ir_variable *const r102B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r102B);
   ir_variable *const r102C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r102C);
   ir_variable *const r102D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r102D);
   ir_variable *const r102E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r102E, add(r1025, r1028), 0x01));

   ir_variable *const r102F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r1030 = less(r102E, r1025);
   ir_expression *const r1031 = expr(ir_unop_b2i, r1030);
   body.emit(assign(r102F, expr(ir_unop_i2u, r1031), 0x01));

   ir_variable *const r1032 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1032, add(r1024, r1027), 0x01));

   body.emit(assign(r102D, add(r1032, r102F), 0x01));

   ir_expression *const r1033 = add(r1023, r1026);
   ir_expression *const r1034 = less(r102D, r102F);
   ir_expression *const r1035 = expr(ir_unop_b2i, r1034);
   ir_expression *const r1036 = expr(ir_unop_i2u, r1035);
   body.emit(assign(r102C, add(r1033, r1036), 0x01));

   ir_expression *const r1037 = less(r1032, r1024);
   ir_expression *const r1038 = expr(ir_unop_b2i, r1037);
   ir_expression *const r1039 = expr(ir_unop_i2u, r1038);
   body.emit(assign(r102C, add(r102C, r1039), 0x01));

   body.emit(assign(r102B, r102E, 0x01));

   body.emit(assign(r102A, r102D, 0x01));

   body.emit(assign(r1029, r102C, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r103A = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r103A);
   ir_variable *const r103B = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r103B);
   ir_variable *const r103C = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r103C);
   ir_variable *const r103D = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r103D);
   ir_variable *const r103E = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r103E);
   ir_variable *const r103F = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r103F);
   ir_variable *const r1040 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1040);
   ir_variable *const r1041 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1041);
   ir_variable *const r1042 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1042);
   ir_variable *const r1043 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1043);
   ir_variable *const r1044 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r1045 = less(r103C, r103F);
   ir_expression *const r1046 = expr(ir_unop_b2i, r1045);
   body.emit(assign(r1044, expr(ir_unop_i2u, r1046), 0x01));

   ir_variable *const r1047 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1047, sub(r103B, r103E), 0x01));

   ir_expression *const r1048 = sub(r103A, r103D);
   ir_expression *const r1049 = less(r1047, r1044);
   ir_expression *const r104A = expr(ir_unop_b2i, r1049);
   ir_expression *const r104B = expr(ir_unop_i2u, r104A);
   body.emit(assign(r1043, sub(r1048, r104B), 0x01));

   ir_expression *const r104C = less(r103B, r103E);
   ir_expression *const r104D = expr(ir_unop_b2i, r104C);
   ir_expression *const r104E = expr(ir_unop_i2u, r104D);
   body.emit(assign(r1043, sub(r1043, r104E), 0x01));

   body.emit(assign(r1042, sub(r103C, r103F), 0x01));

   body.emit(assign(r1041, sub(r1047, r1044), 0x01));

   body.emit(assign(r1040, r1043, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Right(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r104F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r104F);
   ir_variable *const r1050 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1050);
   ir_variable *const r1051 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1051);
   ir_variable *const r1052 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1052);
   ir_variable *const r1053 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1053);
   ir_variable *const r1054 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1054);
   ir_variable *const r1055 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1055);
   ir_variable *const r1056 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1057 = neg(r1051);
   body.emit(assign(r1056, bit_and(r1057, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1059 = equal(r1051, body.constant(int(0)));
   ir_if *f1058 = new(mem_ctx) ir_if(operand(r1059).val);
   exec_list *const f1058_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1058->then_instructions;

      body.emit(assign(r1054, r1050, 0x01));

      body.emit(assign(r1055, r104F, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1058->else_instructions;

      /* IF CONDITION */
      ir_expression *const r105B = less(r1051, body.constant(int(32)));
      ir_if *f105A = new(mem_ctx) ir_if(operand(r105B).val);
      exec_list *const f105A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f105A->then_instructions;

         ir_expression *const r105C = lshift(r104F, r1056);
         ir_expression *const r105D = rshift(r1050, r1051);
         body.emit(assign(r1054, bit_or(r105C, r105D), 0x01));

         body.emit(assign(r1055, rshift(r104F, r1051), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f105A->else_instructions;

         ir_variable *const r105E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1060 = less(r1051, body.constant(int(64)));
         ir_if *f105F = new(mem_ctx) ir_if(operand(r1060).val);
         exec_list *const f105F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f105F->then_instructions;

            ir_expression *const r1061 = bit_and(r1051, body.constant(int(31)));
            body.emit(assign(r105E, rshift(r104F, r1061), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f105F->else_instructions;

            body.emit(assign(r105E, body.constant(0u), 0x01));


         body.instructions = f105F_parent_instructions;
         body.emit(f105F);

         /* END IF */

         body.emit(assign(r1054, r105E, 0x01));

         body.emit(assign(r1055, body.constant(0u), 0x01));


      body.instructions = f105A_parent_instructions;
      body.emit(f105A);

      /* END IF */


   body.instructions = f1058_parent_instructions;
   body.emit(f1058);

   /* END IF */

   body.emit(assign(r1053, r1054, 0x01));

   body.emit(assign(r1052, r1055, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateDiv64To32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1062 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1062);
   ir_variable *const r1063 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1063);
   ir_variable *const r1064 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1064);
   ir_variable *const r1065 = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1066 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r1066);
   ir_variable *const r1067 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r1067);
   ir_variable *const r1068 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r1068);
   ir_variable *const r1069 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
   body.emit(r1069);
   body.emit(assign(r1068, body.constant(0u), 0x01));

   body.emit(assign(r1067, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r106B = lequal(r1064, r1062);
   ir_if *f106A = new(mem_ctx) ir_if(operand(r106B).val);
   exec_list *const f106A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f106A->then_instructions;

      body.emit(assign(r1065, body.constant(4294967295u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f106A->else_instructions;

      body.emit(assign(r1069, rshift(r1064, body.constant(int(16))), 0x01));

      ir_variable *const r106C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r106E = lshift(r1069, body.constant(int(16)));
      ir_expression *const r106F = lequal(r106E, r1062);
      ir_if *f106D = new(mem_ctx) ir_if(operand(r106F).val);
      exec_list *const f106D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f106D->then_instructions;

         body.emit(assign(r106C, body.constant(4294901760u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f106D->else_instructions;

         ir_expression *const r1070 = expr(ir_binop_div, r1062, r1069);
         body.emit(assign(r106C, lshift(r1070, body.constant(int(16))), 0x01));


      body.instructions = f106D_parent_instructions;
      body.emit(f106D);

      /* END IF */

      body.emit(assign(r1066, r106C, 0x01));

      ir_variable *const r1071 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1071);
      ir_variable *const r1072 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
      body.emit(r1072);
      ir_variable *const r1073 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1073);
      ir_variable *const r1074 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1074, bit_and(r1064, body.constant(65535u)), 0x01));

      ir_variable *const r1075 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1075, rshift(r1064, body.constant(int(16))), 0x01));

      ir_variable *const r1076 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1076, bit_and(r106C, body.constant(65535u)), 0x01));

      ir_variable *const r1077 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1077, rshift(r106C, body.constant(int(16))), 0x01));

      ir_variable *const r1078 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1078, mul(r1075, r1076), 0x01));

      ir_expression *const r1079 = mul(r1074, r1077);
      body.emit(assign(r1072, add(r1079, r1078), 0x01));

      ir_expression *const r107A = mul(r1075, r1077);
      ir_expression *const r107B = less(r1072, r1078);
      ir_expression *const r107C = expr(ir_unop_b2i, r107B);
      ir_expression *const r107D = expr(ir_unop_i2u, r107C);
      ir_expression *const r107E = lshift(r107D, body.constant(int(16)));
      ir_expression *const r107F = rshift(r1072, body.constant(int(16)));
      ir_expression *const r1080 = add(r107E, r107F);
      body.emit(assign(r1071, add(r107A, r1080), 0x01));

      body.emit(assign(r1072, lshift(r1072, body.constant(int(16))), 0x01));

      ir_expression *const r1081 = mul(r1074, r1076);
      body.emit(assign(r1073, add(r1081, r1072), 0x01));

      ir_expression *const r1082 = less(r1073, r1072);
      ir_expression *const r1083 = expr(ir_unop_b2i, r1082);
      ir_expression *const r1084 = expr(ir_unop_i2u, r1083);
      body.emit(assign(r1071, add(r1071, r1084), 0x01));

      ir_expression *const r1085 = sub(r1062, r1071);
      ir_expression *const r1086 = less(r1063, r1073);
      ir_expression *const r1087 = expr(ir_unop_b2i, r1086);
      ir_expression *const r1088 = expr(ir_unop_i2u, r1087);
      body.emit(assign(r1068, sub(r1085, r1088), 0x01));

      body.emit(assign(r1067, sub(r1063, r1073), 0x01));

      /* LOOP BEGIN */
      ir_loop *f1089 = new(mem_ctx) ir_loop();
      exec_list *const f1089_parent_instructions = body.instructions;

         body.instructions = &f1089->body_instructions;

         /* IF CONDITION */
         ir_expression *const r108B = expr(ir_unop_u2i, r1068);
         ir_expression *const r108C = gequal(r108B, body.constant(int(0)));
         ir_if *f108A = new(mem_ctx) ir_if(operand(r108C).val);
         exec_list *const f108A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f108A->then_instructions;

            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


         body.instructions = f108A_parent_instructions;
         body.emit(f108A);

         /* END IF */

         body.emit(assign(r1066, add(r1066, body.constant(4294901760u)), 0x01));

         ir_variable *const r108D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         ir_expression *const r108E = lshift(r1064, body.constant(int(16)));
         body.emit(assign(r108D, add(r1067, r108E), 0x01));

         ir_expression *const r108F = add(r1068, r1069);
         ir_expression *const r1090 = less(r108D, r1067);
         ir_expression *const r1091 = expr(ir_unop_b2i, r1090);
         ir_expression *const r1092 = expr(ir_unop_i2u, r1091);
         body.emit(assign(r1068, add(r108F, r1092), 0x01));

         body.emit(assign(r1067, r108D, 0x01));

      /* LOOP END */

      body.instructions = f1089_parent_instructions;
      body.emit(f1089);

      ir_expression *const r1093 = lshift(r1068, body.constant(int(16)));
      ir_expression *const r1094 = rshift(r1067, body.constant(int(16)));
      body.emit(assign(r1068, bit_or(r1093, r1094), 0x01));

      ir_variable *const r1095 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1097 = lshift(r1069, body.constant(int(16)));
      ir_expression *const r1098 = lequal(r1097, r1068);
      ir_if *f1096 = new(mem_ctx) ir_if(operand(r1098).val);
      exec_list *const f1096_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1096->then_instructions;

         body.emit(assign(r1095, body.constant(65535u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1096->else_instructions;

         body.emit(assign(r1095, expr(ir_binop_div, r1068, r1069), 0x01));


      body.instructions = f1096_parent_instructions;
      body.emit(f1096);

      /* END IF */

      body.emit(assign(r1066, bit_or(r1066, r1095), 0x01));

      body.emit(assign(r1065, r1066, 0x01));


   body.instructions = f106A_parent_instructions;
   body.emit(f106A);

   /* END IF */

   body.emit(ret(r1065));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat32Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1099 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_function_in);
   sig_parameters.push_tail(r1099);
   ir_variable *const r109A = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r109A);
   ir_variable *const r109B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFracPtr", ir_var_function_inout);
   sig_parameters.push_tail(r109B);
   ir_variable *const r109C = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r109C, r1099, 0x01));

   ir_variable *const r109D = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r109E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r109E);
   /* IF CONDITION */
   ir_expression *const r10A0 = equal(r1099, body.constant(0u));
   ir_if *f109F = new(mem_ctx) ir_if(operand(r10A0).val);
   exec_list *const f109F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f109F->then_instructions;

      body.emit(assign(r109D, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f109F->else_instructions;

      body.emit(assign(r109E, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r10A2 = bit_and(r1099, body.constant(4294901760u));
      ir_expression *const r10A3 = equal(r10A2, body.constant(0u));
      ir_if *f10A1 = new(mem_ctx) ir_if(operand(r10A3).val);
      exec_list *const f10A1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f10A1->then_instructions;

         body.emit(assign(r109E, body.constant(int(16)), 0x01));

         body.emit(assign(r109C, lshift(r1099, body.constant(int(16))), 0x01));


      body.instructions = f10A1_parent_instructions;
      body.emit(f10A1);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r10A5 = bit_and(r109C, body.constant(4278190080u));
      ir_expression *const r10A6 = equal(r10A5, body.constant(0u));
      ir_if *f10A4 = new(mem_ctx) ir_if(operand(r10A6).val);
      exec_list *const f10A4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f10A4->then_instructions;

         body.emit(assign(r109E, add(r109E, body.constant(int(8))), 0x01));

         body.emit(assign(r109C, lshift(r109C, body.constant(int(8))), 0x01));


      body.instructions = f10A4_parent_instructions;
      body.emit(f10A4);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r10A8 = bit_and(r109C, body.constant(4026531840u));
      ir_expression *const r10A9 = equal(r10A8, body.constant(0u));
      ir_if *f10A7 = new(mem_ctx) ir_if(operand(r10A9).val);
      exec_list *const f10A7_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f10A7->then_instructions;

         body.emit(assign(r109E, add(r109E, body.constant(int(4))), 0x01));

         body.emit(assign(r109C, lshift(r109C, body.constant(int(4))), 0x01));


      body.instructions = f10A7_parent_instructions;
      body.emit(f10A7);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r10AB = bit_and(r109C, body.constant(3221225472u));
      ir_expression *const r10AC = equal(r10AB, body.constant(0u));
      ir_if *f10AA = new(mem_ctx) ir_if(operand(r10AC).val);
      exec_list *const f10AA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f10AA->then_instructions;

         body.emit(assign(r109E, add(r109E, body.constant(int(2))), 0x01));

         body.emit(assign(r109C, lshift(r109C, body.constant(int(2))), 0x01));


      body.instructions = f10AA_parent_instructions;
      body.emit(f10AA);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r10AE = bit_and(r109C, body.constant(2147483648u));
      ir_expression *const r10AF = equal(r10AE, body.constant(0u));
      ir_if *f10AD = new(mem_ctx) ir_if(operand(r10AF).val);
      exec_list *const f10AD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f10AD->then_instructions;

         body.emit(assign(r109E, add(r109E, body.constant(int(1))), 0x01));


      body.instructions = f10AD_parent_instructions;
      body.emit(f10AD);

      /* END IF */

      body.emit(assign(r109D, r109E, 0x01));


   body.instructions = f109F_parent_instructions;
   body.emit(f109F);

   /* END IF */

   ir_variable *const r10B0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r10B0, add(r109D, body.constant(int(-8))), 0x01));

   body.emit(assign(r109B, lshift(r1099, r10B0), 0x01));

   body.emit(assign(r109A, sub(body.constant(int(1)), r10B0), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Frac(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r10B1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r10B1);
   ir_expression *const r10B2 = bit_and(r10B1, body.constant(8388607u));
   body.emit(ret(r10B2));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r10B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r10B3);
   ir_expression *const r10B4 = rshift(r10B3, body.constant(int(23)));
   ir_expression *const r10B5 = bit_and(r10B4, body.constant(255u));
   ir_expression *const r10B6 = expr(ir_unop_u2i, r10B5);
   body.emit(ret(r10B6));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r10B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r10B7);
   ir_expression *const r10B8 = rshift(r10B7, body.constant(int(31)));
   body.emit(ret(r10B8));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp32_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r10B9 = new(mem_ctx) ir_variable(glsl_type::float_type, "f", ir_var_function_in);
   sig_parameters.push_tail(r10B9);
   ir_variable *const r10BA = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r10BA, body.constant(true), 0x01));

   ir_variable *const r10BB = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r10BC = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r10BC);
   ir_variable *const r10BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r10BD);
   ir_variable *const r10BE = body.make_temp(glsl_type::uint_type, "floatBitsToUint_retval");
   body.emit(assign(r10BE, expr(ir_unop_bitcast_f2u, r10B9), 0x01));

   ir_variable *const r10BF = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r10BF, bit_and(r10BE, body.constant(8388607u)), 0x01));

   body.emit(assign(r10BD, r10BF, 0x01));

   ir_variable *const r10C0 = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r10C1 = rshift(r10BE, body.constant(int(23)));
   ir_expression *const r10C2 = bit_and(r10C1, body.constant(255u));
   body.emit(assign(r10C0, expr(ir_unop_u2i, r10C2), 0x01));

   body.emit(assign(r10BC, r10C0, 0x01));

   ir_variable *const r10C3 = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r10C3, rshift(r10BE, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r10C5 = equal(r10C0, body.constant(int(255)));
   ir_if *f10C4 = new(mem_ctx) ir_if(operand(r10C5).val);
   exec_list *const f10C4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f10C4->then_instructions;

      /* IF CONDITION */
      ir_expression *const r10C7 = nequal(r10BF, body.constant(0u));
      ir_if *f10C6 = new(mem_ctx) ir_if(operand(r10C7).val);
      exec_list *const f10C6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f10C6->then_instructions;

         ir_variable *const r10C8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r10C8, lshift(r10BE, body.constant(int(9))), 0x01));

         ir_variable *const r10C9 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         ir_expression *const r10CA = lshift(r10C8, body.constant(int(20)));
         body.emit(assign(r10C9, bit_or(r10CA, body.constant(0u)), 0x01));

         ir_expression *const r10CB = rshift(r10C8, body.constant(int(12)));
         ir_expression *const r10CC = lshift(r10C3, body.constant(int(31)));
         ir_expression *const r10CD = bit_or(r10CC, body.constant(2146959360u));
         body.emit(assign(r10C9, bit_or(r10CB, r10CD), 0x02));

         body.emit(assign(r10BB, r10C9, 0x03));

         body.emit(assign(r10BA, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f10C6->else_instructions;

         ir_variable *const r10CE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r10CE);
         ir_expression *const r10CF = lshift(r10C3, body.constant(int(31)));
         body.emit(assign(r10CE, add(r10CF, body.constant(2146435072u)), 0x02));

         body.emit(assign(r10CE, body.constant(0u), 0x01));

         body.emit(assign(r10BB, r10CE, 0x03));

         body.emit(assign(r10BA, body.constant(false), 0x01));


      body.instructions = f10C6_parent_instructions;
      body.emit(f10C6);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f10C4->else_instructions;

      /* IF CONDITION */
      ir_expression *const r10D1 = equal(r10C0, body.constant(int(0)));
      ir_if *f10D0 = new(mem_ctx) ir_if(operand(r10D1).val);
      exec_list *const f10D0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f10D0->then_instructions;

         /* IF CONDITION */
         ir_expression *const r10D3 = equal(r10BF, body.constant(0u));
         ir_if *f10D2 = new(mem_ctx) ir_if(operand(r10D3).val);
         exec_list *const f10D2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f10D2->then_instructions;

            ir_variable *const r10D4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r10D4);
            body.emit(assign(r10D4, lshift(r10C3, body.constant(int(31))), 0x02));

            body.emit(assign(r10D4, body.constant(0u), 0x01));

            body.emit(assign(r10BB, r10D4, 0x03));

            body.emit(assign(r10BA, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f10D2->else_instructions;

            ir_variable *const r10D5 = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r10D5, r10C0, 0x01));

            ir_variable *const r10D6 = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r10D6, r10BF, 0x01));

            ir_variable *const r10D7 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r10D7, r10BF, 0x01));

            ir_variable *const r10D8 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r10D9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r10D9);
            /* IF CONDITION */
            ir_expression *const r10DB = equal(r10BF, body.constant(0u));
            ir_if *f10DA = new(mem_ctx) ir_if(operand(r10DB).val);
            exec_list *const f10DA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f10DA->then_instructions;

               body.emit(assign(r10D8, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f10DA->else_instructions;

               body.emit(assign(r10D9, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r10DD = bit_and(r10BF, body.constant(4294901760u));
               ir_expression *const r10DE = equal(r10DD, body.constant(0u));
               ir_if *f10DC = new(mem_ctx) ir_if(operand(r10DE).val);
               exec_list *const f10DC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f10DC->then_instructions;

                  body.emit(assign(r10D9, body.constant(int(16)), 0x01));

                  body.emit(assign(r10D7, lshift(r10BF, body.constant(int(16))), 0x01));


               body.instructions = f10DC_parent_instructions;
               body.emit(f10DC);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r10E0 = bit_and(r10D7, body.constant(4278190080u));
               ir_expression *const r10E1 = equal(r10E0, body.constant(0u));
               ir_if *f10DF = new(mem_ctx) ir_if(operand(r10E1).val);
               exec_list *const f10DF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f10DF->then_instructions;

                  body.emit(assign(r10D9, add(r10D9, body.constant(int(8))), 0x01));

                  body.emit(assign(r10D7, lshift(r10D7, body.constant(int(8))), 0x01));


               body.instructions = f10DF_parent_instructions;
               body.emit(f10DF);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r10E3 = bit_and(r10D7, body.constant(4026531840u));
               ir_expression *const r10E4 = equal(r10E3, body.constant(0u));
               ir_if *f10E2 = new(mem_ctx) ir_if(operand(r10E4).val);
               exec_list *const f10E2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f10E2->then_instructions;

                  body.emit(assign(r10D9, add(r10D9, body.constant(int(4))), 0x01));

                  body.emit(assign(r10D7, lshift(r10D7, body.constant(int(4))), 0x01));


               body.instructions = f10E2_parent_instructions;
               body.emit(f10E2);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r10E6 = bit_and(r10D7, body.constant(3221225472u));
               ir_expression *const r10E7 = equal(r10E6, body.constant(0u));
               ir_if *f10E5 = new(mem_ctx) ir_if(operand(r10E7).val);
               exec_list *const f10E5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f10E5->then_instructions;

                  body.emit(assign(r10D9, add(r10D9, body.constant(int(2))), 0x01));

                  body.emit(assign(r10D7, lshift(r10D7, body.constant(int(2))), 0x01));


               body.instructions = f10E5_parent_instructions;
               body.emit(f10E5);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r10E9 = bit_and(r10D7, body.constant(2147483648u));
               ir_expression *const r10EA = equal(r10E9, body.constant(0u));
               ir_if *f10E8 = new(mem_ctx) ir_if(operand(r10EA).val);
               exec_list *const f10E8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f10E8->then_instructions;

                  body.emit(assign(r10D9, add(r10D9, body.constant(int(1))), 0x01));


               body.instructions = f10E8_parent_instructions;
               body.emit(f10E8);

               /* END IF */

               body.emit(assign(r10D8, r10D9, 0x01));


            body.instructions = f10DA_parent_instructions;
            body.emit(f10DA);

            /* END IF */

            ir_variable *const r10EB = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r10EB, add(r10D8, body.constant(int(-8))), 0x01));

            body.emit(assign(r10D6, lshift(r10BF, r10EB), 0x01));

            body.emit(assign(r10D5, sub(body.constant(int(1)), r10EB), 0x01));

            body.emit(assign(r10BD, r10D6, 0x01));

            body.emit(assign(r10BC, add(r10D5, body.constant(int(-1))), 0x01));


         body.instructions = f10D2_parent_instructions;
         body.emit(f10D2);

         /* END IF */


      body.instructions = f10D0_parent_instructions;
      body.emit(f10D0);

      /* END IF */

      /* IF CONDITION */
      ir_if *f10EC = new(mem_ctx) ir_if(operand(r10BA).val);
      exec_list *const f10EC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f10EC->then_instructions;

         ir_variable *const r10ED = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r10ED);
         ir_expression *const r10EE = lshift(r10C3, body.constant(int(31)));
         ir_expression *const r10EF = add(r10BC, body.constant(int(896)));
         ir_expression *const r10F0 = expr(ir_unop_i2u, r10EF);
         ir_expression *const r10F1 = lshift(r10F0, body.constant(int(20)));
         ir_expression *const r10F2 = add(r10EE, r10F1);
         ir_expression *const r10F3 = rshift(r10BD, body.constant(int(3)));
         body.emit(assign(r10ED, add(r10F2, r10F3), 0x02));

         ir_expression *const r10F4 = lshift(r10BD, body.constant(int(29)));
         body.emit(assign(r10ED, bit_or(r10F4, body.constant(0u)), 0x01));

         body.emit(assign(r10BB, r10ED, 0x03));

         body.emit(assign(r10BA, body.constant(false), 0x01));


      body.instructions = f10EC_parent_instructions;
      body.emit(f10EC);

      /* END IF */


   body.instructions = f10C4_parent_instructions;
   body.emit(f10C4);

   /* END IF */

   body.emit(ret(r10BB));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r10F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r10F5);
   ir_variable *const r10F6 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r10F6);
   ir_variable *const r10F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r10F7);
   ir_variable *const r10F8 = body.make_temp(glsl_type::float_type, "uintBitsToFloat_retval");
   ir_expression *const r10F9 = lshift(r10F5, body.constant(int(31)));
   ir_expression *const r10FA = expr(ir_unop_i2u, r10F6);
   ir_expression *const r10FB = lshift(r10FA, body.constant(int(23)));
   ir_expression *const r10FC = add(r10F9, r10FB);
   ir_expression *const r10FD = add(r10FC, r10F7);
   body.emit(assign(r10F8, expr(ir_unop_bitcast_u2f, r10FD), 0x01));

   body.emit(ret(r10F8));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift32RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r10FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r10FE);
   ir_variable *const r10FF = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r10FF);
   ir_variable *const r1100 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1100);
   ir_variable *const r1101 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r1101);
   /* IF CONDITION */
   ir_expression *const r1103 = equal(r10FF, body.constant(int(0)));
   ir_if *f1102 = new(mem_ctx) ir_if(operand(r1103).val);
   exec_list *const f1102_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1102->then_instructions;

      body.emit(assign(r1101, r10FE, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1102->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1105 = less(r10FF, body.constant(int(32)));
      ir_if *f1104 = new(mem_ctx) ir_if(operand(r1105).val);
      exec_list *const f1104_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1104->then_instructions;

         ir_expression *const r1106 = rshift(r10FE, r10FF);
         ir_expression *const r1107 = neg(r10FF);
         ir_expression *const r1108 = bit_and(r1107, body.constant(int(31)));
         ir_expression *const r1109 = lshift(r10FE, r1108);
         ir_expression *const r110A = nequal(r1109, body.constant(0u));
         ir_expression *const r110B = expr(ir_unop_b2i, r110A);
         ir_expression *const r110C = expr(ir_unop_i2u, r110B);
         body.emit(assign(r1101, bit_or(r1106, r110C), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1104->else_instructions;

         ir_expression *const r110D = nequal(r10FE, body.constant(0u));
         ir_expression *const r110E = expr(ir_unop_b2i, r110D);
         body.emit(assign(r1101, expr(ir_unop_i2u, r110E), 0x01));


      body.instructions = f1104_parent_instructions;
      body.emit(f1104);

      /* END IF */


   body.instructions = f1102_parent_instructions;
   body.emit(f1102);

   /* END IF */

   body.emit(assign(r1100, r1101, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r110F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r110F);
   ir_variable *const r1110 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r1110);
   ir_variable *const r1111 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r1111);
   ir_variable *const r1112 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1112, body.constant(true), 0x01));

   ir_variable *const r1113 = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r1114 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
   body.emit(r1114);
   ir_expression *const r1115 = bit_and(r1111, body.constant(127u));
   body.emit(assign(r1114, expr(ir_unop_u2i, r1115), 0x01));

   /* IF CONDITION */
   ir_expression *const r1117 = expr(ir_unop_i2u, r1110);
   ir_expression *const r1118 = lequal(body.constant(253u), r1117);
   ir_if *f1116 = new(mem_ctx) ir_if(operand(r1118).val);
   exec_list *const f1116_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1116->then_instructions;

      /* IF CONDITION */
      ir_expression *const r111A = less(body.constant(int(253)), r1110);
      ir_expression *const r111B = equal(r1110, body.constant(int(253)));
      ir_expression *const r111C = expr(ir_unop_u2i, r1111);
      ir_expression *const r111D = less(r111C, body.constant(int(-64)));
      ir_expression *const r111E = logic_and(r111B, r111D);
      ir_expression *const r111F = logic_or(r111A, r111E);
      ir_if *f1119 = new(mem_ctx) ir_if(operand(r111F).val);
      exec_list *const f1119_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1119->then_instructions;

         ir_expression *const r1120 = lshift(r110F, body.constant(int(31)));
         ir_expression *const r1121 = add(r1120, body.constant(2139095040u));
         body.emit(assign(r1113, expr(ir_unop_bitcast_u2f, r1121), 0x01));

         body.emit(assign(r1112, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1119->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1123 = less(r1110, body.constant(int(0)));
         ir_if *f1122 = new(mem_ctx) ir_if(operand(r1123).val);
         exec_list *const f1122_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1122->then_instructions;

            ir_variable *const r1124 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r1124, neg(r1110), 0x01));

            ir_variable *const r1125 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
            body.emit(r1125);
            /* IF CONDITION */
            ir_expression *const r1127 = equal(r1124, body.constant(int(0)));
            ir_if *f1126 = new(mem_ctx) ir_if(operand(r1127).val);
            exec_list *const f1126_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1126->then_instructions;

               body.emit(assign(r1125, r1111, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1126->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1129 = less(r1124, body.constant(int(32)));
               ir_if *f1128 = new(mem_ctx) ir_if(operand(r1129).val);
               exec_list *const f1128_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1128->then_instructions;

                  ir_expression *const r112A = rshift(r1111, r1124);
                  ir_expression *const r112B = neg(r1124);
                  ir_expression *const r112C = bit_and(r112B, body.constant(int(31)));
                  ir_expression *const r112D = lshift(r1111, r112C);
                  ir_expression *const r112E = nequal(r112D, body.constant(0u));
                  ir_expression *const r112F = expr(ir_unop_b2i, r112E);
                  ir_expression *const r1130 = expr(ir_unop_i2u, r112F);
                  body.emit(assign(r1125, bit_or(r112A, r1130), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1128->else_instructions;

                  ir_expression *const r1131 = nequal(r1111, body.constant(0u));
                  ir_expression *const r1132 = expr(ir_unop_b2i, r1131);
                  body.emit(assign(r1125, expr(ir_unop_i2u, r1132), 0x01));


               body.instructions = f1128_parent_instructions;
               body.emit(f1128);

               /* END IF */


            body.instructions = f1126_parent_instructions;
            body.emit(f1126);

            /* END IF */

            body.emit(assign(r1111, r1125, 0x01));

            body.emit(assign(r1110, body.constant(int(0)), 0x01));

            ir_expression *const r1133 = expr(ir_unop_u2i, r1125);
            body.emit(assign(r1114, bit_and(r1133, body.constant(int(127))), 0x01));


         body.instructions = f1122_parent_instructions;
         body.emit(f1122);

         /* END IF */


      body.instructions = f1119_parent_instructions;
      body.emit(f1119);

      /* END IF */


   body.instructions = f1116_parent_instructions;
   body.emit(f1116);

   /* END IF */

   /* IF CONDITION */
   ir_if *f1134 = new(mem_ctx) ir_if(operand(r1112).val);
   exec_list *const f1134_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1134->then_instructions;

      ir_expression *const r1135 = add(r1111, body.constant(64u));
      body.emit(assign(r1111, rshift(r1135, body.constant(int(7))), 0x01));

      ir_expression *const r1136 = bit_xor(r1114, body.constant(int(64)));
      ir_expression *const r1137 = equal(r1136, body.constant(int(0)));
      ir_expression *const r1138 = expr(ir_unop_b2i, r1137);
      ir_expression *const r1139 = expr(ir_unop_i2u, r1138);
      ir_expression *const r113A = expr(ir_unop_bit_not, r1139);
      body.emit(assign(r1111, bit_and(r1111, r113A), 0x01));

      /* IF CONDITION */
      ir_expression *const r113C = equal(r1111, body.constant(0u));
      ir_if *f113B = new(mem_ctx) ir_if(operand(r113C).val);
      exec_list *const f113B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f113B->then_instructions;

         body.emit(assign(r1110, body.constant(int(0)), 0x01));


      body.instructions = f113B_parent_instructions;
      body.emit(f113B);

      /* END IF */

      ir_expression *const r113D = lshift(r110F, body.constant(int(31)));
      ir_expression *const r113E = expr(ir_unop_i2u, r1110);
      ir_expression *const r113F = lshift(r113E, body.constant(int(23)));
      ir_expression *const r1140 = add(r113D, r113F);
      ir_expression *const r1141 = add(r1140, r1111);
      body.emit(assign(r1113, expr(ir_unop_bitcast_u2f, r1141), 0x01));

      body.emit(assign(r1112, body.constant(false), 0x01));


   body.instructions = f1134_parent_instructions;
   body.emit(f1134);

   /* END IF */

   body.emit(ret(r1113));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_fp32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1142 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1142);
   ir_variable *const r1143 = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r1144 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r1144);
   body.emit(assign(r1144, body.constant(0u), 0x01));

   ir_variable *const r1145 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r1145, swizzle_x(r1142), 0x01));

   ir_variable *const r1146 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1146, bit_and(swizzle_y(r1142), body.constant(1048575u)), 0x01));

   ir_variable *const r1147 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1148 = rshift(swizzle_y(r1142), body.constant(int(20)));
   ir_expression *const r1149 = bit_and(r1148, body.constant(2047u));
   body.emit(assign(r1147, expr(ir_unop_u2i, r1149), 0x01));

   ir_variable *const r114A = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r114A, rshift(swizzle_y(r1142), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r114C = equal(r1147, body.constant(int(2047)));
   ir_if *f114B = new(mem_ctx) ir_if(operand(r114C).val);
   exec_list *const f114B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f114B->then_instructions;

      /* IF CONDITION */
      ir_expression *const r114E = bit_or(r1146, swizzle_x(r1142));
      ir_expression *const r114F = nequal(r114E, body.constant(0u));
      ir_if *f114D = new(mem_ctx) ir_if(operand(r114F).val);
      exec_list *const f114D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f114D->then_instructions;

         ir_variable *const r1150 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1150, lshift(swizzle_x(r1142), body.constant(int(12))), 0x01));

         ir_variable *const r1151 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r1152 = lshift(swizzle_y(r1142), body.constant(int(12)));
         ir_expression *const r1153 = rshift(swizzle_x(r1142), body.constant(int(20)));
         body.emit(assign(r1151, bit_or(r1152, r1153), 0x01));

         body.emit(assign(r1142, r1151, 0x02));

         body.emit(assign(r1142, r1150, 0x01));

         ir_expression *const r1154 = lshift(r114A, body.constant(int(31)));
         ir_expression *const r1155 = bit_or(r1154, body.constant(2143289344u));
         ir_expression *const r1156 = rshift(r1151, body.constant(int(9)));
         ir_expression *const r1157 = bit_or(r1155, r1156);
         body.emit(assign(r1143, expr(ir_unop_bitcast_u2f, r1157), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f114D->else_instructions;

         ir_expression *const r1158 = lshift(r114A, body.constant(int(31)));
         ir_expression *const r1159 = add(r1158, body.constant(2139095040u));
         body.emit(assign(r1143, expr(ir_unop_bitcast_u2f, r1159), 0x01));


      body.instructions = f114D_parent_instructions;
      body.emit(f114D);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f114B->else_instructions;

      ir_variable *const r115A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r115A);
      ir_variable *const r115B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r115B);
      ir_expression *const r115C = lshift(r1146, body.constant(int(10)));
      ir_expression *const r115D = rshift(r1145, body.constant(int(22)));
      ir_expression *const r115E = bit_or(r115C, r115D);
      ir_expression *const r115F = lshift(r1145, body.constant(int(10)));
      ir_expression *const r1160 = nequal(r115F, body.constant(0u));
      ir_expression *const r1161 = expr(ir_unop_b2i, r1160);
      ir_expression *const r1162 = expr(ir_unop_i2u, r1161);
      body.emit(assign(r115A, bit_or(r115E, r1162), 0x01));

      body.emit(assign(r115B, rshift(r1146, body.constant(int(22))), 0x01));

      body.emit(assign(r1144, r115A, 0x01));

      /* IF CONDITION */
      ir_expression *const r1164 = nequal(r1147, body.constant(int(0)));
      ir_if *f1163 = new(mem_ctx) ir_if(operand(r1164).val);
      exec_list *const f1163_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1163->then_instructions;

         body.emit(assign(r1144, bit_or(r115A, body.constant(1073741824u)), 0x01));


      body.instructions = f1163_parent_instructions;
      body.emit(f1163);

      /* END IF */

      ir_variable *const r1165 = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r1165, add(r1147, body.constant(int(-897))), 0x01));

      ir_variable *const r1166 = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r1166, r1144, 0x01));

      ir_variable *const r1167 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r1167, body.constant(true), 0x01));

      ir_variable *const r1168 = body.make_temp(glsl_type::float_type, "return_value");
      ir_variable *const r1169 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
      body.emit(r1169);
      ir_expression *const r116A = bit_and(r1144, body.constant(127u));
      body.emit(assign(r1169, expr(ir_unop_u2i, r116A), 0x01));

      /* IF CONDITION */
      ir_expression *const r116C = expr(ir_unop_i2u, r1165);
      ir_expression *const r116D = lequal(body.constant(253u), r116C);
      ir_if *f116B = new(mem_ctx) ir_if(operand(r116D).val);
      exec_list *const f116B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f116B->then_instructions;

         /* IF CONDITION */
         ir_expression *const r116F = less(body.constant(int(253)), r1165);
         ir_expression *const r1170 = equal(r1165, body.constant(int(253)));
         ir_expression *const r1171 = expr(ir_unop_u2i, r1144);
         ir_expression *const r1172 = less(r1171, body.constant(int(-64)));
         ir_expression *const r1173 = logic_and(r1170, r1172);
         ir_expression *const r1174 = logic_or(r116F, r1173);
         ir_if *f116E = new(mem_ctx) ir_if(operand(r1174).val);
         exec_list *const f116E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f116E->then_instructions;

            ir_expression *const r1175 = lshift(r114A, body.constant(int(31)));
            ir_expression *const r1176 = add(r1175, body.constant(2139095040u));
            body.emit(assign(r1168, expr(ir_unop_bitcast_u2f, r1176), 0x01));

            body.emit(assign(r1167, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f116E->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1178 = less(r1165, body.constant(int(0)));
            ir_if *f1177 = new(mem_ctx) ir_if(operand(r1178).val);
            exec_list *const f1177_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1177->then_instructions;

               ir_variable *const r1179 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1179, neg(r1165), 0x01));

               ir_variable *const r117A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r117A);
               /* IF CONDITION */
               ir_expression *const r117C = equal(r1179, body.constant(int(0)));
               ir_if *f117B = new(mem_ctx) ir_if(operand(r117C).val);
               exec_list *const f117B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f117B->then_instructions;

                  body.emit(assign(r117A, r1144, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f117B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r117E = less(r1179, body.constant(int(32)));
                  ir_if *f117D = new(mem_ctx) ir_if(operand(r117E).val);
                  exec_list *const f117D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f117D->then_instructions;

                     ir_expression *const r117F = rshift(r1144, r1179);
                     ir_expression *const r1180 = neg(r1179);
                     ir_expression *const r1181 = bit_and(r1180, body.constant(int(31)));
                     ir_expression *const r1182 = lshift(r1144, r1181);
                     ir_expression *const r1183 = nequal(r1182, body.constant(0u));
                     ir_expression *const r1184 = expr(ir_unop_b2i, r1183);
                     ir_expression *const r1185 = expr(ir_unop_i2u, r1184);
                     body.emit(assign(r117A, bit_or(r117F, r1185), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f117D->else_instructions;

                     ir_expression *const r1186 = nequal(r1144, body.constant(0u));
                     ir_expression *const r1187 = expr(ir_unop_b2i, r1186);
                     body.emit(assign(r117A, expr(ir_unop_i2u, r1187), 0x01));


                  body.instructions = f117D_parent_instructions;
                  body.emit(f117D);

                  /* END IF */


               body.instructions = f117B_parent_instructions;
               body.emit(f117B);

               /* END IF */

               body.emit(assign(r1166, r117A, 0x01));

               body.emit(assign(r1165, body.constant(int(0)), 0x01));

               ir_expression *const r1188 = expr(ir_unop_u2i, r117A);
               body.emit(assign(r1169, bit_and(r1188, body.constant(int(127))), 0x01));


            body.instructions = f1177_parent_instructions;
            body.emit(f1177);

            /* END IF */


         body.instructions = f116E_parent_instructions;
         body.emit(f116E);

         /* END IF */


      body.instructions = f116B_parent_instructions;
      body.emit(f116B);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1189 = new(mem_ctx) ir_if(operand(r1167).val);
      exec_list *const f1189_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1189->then_instructions;

         ir_expression *const r118A = add(r1166, body.constant(64u));
         body.emit(assign(r1166, rshift(r118A, body.constant(int(7))), 0x01));

         ir_expression *const r118B = bit_xor(r1169, body.constant(int(64)));
         ir_expression *const r118C = equal(r118B, body.constant(int(0)));
         ir_expression *const r118D = expr(ir_unop_b2i, r118C);
         ir_expression *const r118E = expr(ir_unop_i2u, r118D);
         ir_expression *const r118F = expr(ir_unop_bit_not, r118E);
         body.emit(assign(r1166, bit_and(r1166, r118F), 0x01));

         /* IF CONDITION */
         ir_expression *const r1191 = equal(r1166, body.constant(0u));
         ir_if *f1190 = new(mem_ctx) ir_if(operand(r1191).val);
         exec_list *const f1190_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1190->then_instructions;

            body.emit(assign(r1165, body.constant(int(0)), 0x01));


         body.instructions = f1190_parent_instructions;
         body.emit(f1190);

         /* END IF */

         ir_expression *const r1192 = lshift(r114A, body.constant(int(31)));
         ir_expression *const r1193 = expr(ir_unop_i2u, r1165);
         ir_expression *const r1194 = lshift(r1193, body.constant(int(23)));
         ir_expression *const r1195 = add(r1192, r1194);
         ir_expression *const r1196 = add(r1195, r1166);
         body.emit(assign(r1168, expr(ir_unop_bitcast_u2f, r1196), 0x01));

         body.emit(assign(r1167, body.constant(false), 0x01));


      body.instructions = f1189_parent_instructions;
      body.emit(f1189);

      /* END IF */

      body.emit(assign(r1143, r1168, 0x01));


   body.instructions = f114B_parent_instructions;
   body.emit(f114B);

   /* END IF */

   body.emit(ret(r1143));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_int(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1197 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1197);
   ir_variable *const r1198 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1198, body.constant(true), 0x01));

   ir_variable *const r1199 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r119A = new(mem_ctx) ir_variable(glsl_type::uint_type, "absZ", ir_var_auto);
   body.emit(r119A);
   ir_variable *const r119B = new(mem_ctx) ir_variable(glsl_type::uint_type, "aSign", ir_var_auto);
   body.emit(r119B);
   ir_variable *const r119C = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r119C);
   ir_variable *const r119D = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r119D, bit_and(swizzle_y(r1197), body.constant(1048575u)), 0x01));

   body.emit(assign(r119C, r119D, 0x01));

   ir_variable *const r119E = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r119F = rshift(swizzle_y(r1197), body.constant(int(20)));
   ir_expression *const r11A0 = bit_and(r119F, body.constant(2047u));
   body.emit(assign(r119E, expr(ir_unop_u2i, r11A0), 0x01));

   body.emit(assign(r119B, rshift(swizzle_y(r1197), body.constant(int(31))), 0x01));

   body.emit(assign(r119A, body.constant(0u), 0x01));

   ir_variable *const r11A1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r11A1, add(r119E, body.constant(int(-1043))), 0x01));

   /* IF CONDITION */
   ir_expression *const r11A3 = lequal(body.constant(int(0)), r11A1);
   ir_if *f11A2 = new(mem_ctx) ir_if(operand(r11A3).val);
   exec_list *const f11A2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f11A2->then_instructions;

      /* IF CONDITION */
      ir_expression *const r11A5 = less(body.constant(int(1054)), r119E);
      ir_if *f11A4 = new(mem_ctx) ir_if(operand(r11A5).val);
      exec_list *const f11A4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f11A4->then_instructions;

         /* IF CONDITION */
         ir_expression *const r11A7 = equal(r119E, body.constant(int(2047)));
         ir_expression *const r11A8 = bit_or(r119D, swizzle_x(r1197));
         ir_expression *const r11A9 = expr(ir_unop_u2i, r11A8);
         ir_expression *const r11AA = expr(ir_unop_i2b, r11A9);
         ir_expression *const r11AB = logic_and(r11A7, r11AA);
         ir_if *f11A6 = new(mem_ctx) ir_if(operand(r11AB).val);
         exec_list *const f11A6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11A6->then_instructions;

            body.emit(assign(r119B, body.constant(0u), 0x01));


         body.instructions = f11A6_parent_instructions;
         body.emit(f11A6);

         /* END IF */

         ir_variable *const r11AC = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r11AE = expr(ir_unop_u2i, r119B);
         ir_expression *const r11AF = expr(ir_unop_i2b, r11AE);
         ir_if *f11AD = new(mem_ctx) ir_if(operand(r11AF).val);
         exec_list *const f11AD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11AD->then_instructions;

            body.emit(assign(r11AC, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f11AD->else_instructions;

            body.emit(assign(r11AC, body.constant(int(2147483647)), 0x01));


         body.instructions = f11AD_parent_instructions;
         body.emit(f11AD);

         /* END IF */

         body.emit(assign(r1199, r11AC, 0x01));

         body.emit(assign(r1198, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f11A4->else_instructions;

         ir_variable *const r11B0 = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r11B0, bit_or(r119D, body.constant(1048576u)), 0x01));

         ir_variable *const r11B1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r11B1, lshift(swizzle_x(r1197), r11A1), 0x01));

         ir_variable *const r11B2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r11B4 = equal(r11A1, body.constant(int(0)));
         ir_if *f11B3 = new(mem_ctx) ir_if(operand(r11B4).val);
         exec_list *const f11B3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11B3->then_instructions;

            body.emit(assign(r11B2, r11B0, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f11B3->else_instructions;

            ir_expression *const r11B5 = lshift(r11B0, r11A1);
            ir_expression *const r11B6 = neg(r11A1);
            ir_expression *const r11B7 = bit_and(r11B6, body.constant(int(31)));
            ir_expression *const r11B8 = rshift(swizzle_x(r1197), r11B7);
            body.emit(assign(r11B2, bit_or(r11B5, r11B8), 0x01));


         body.instructions = f11B3_parent_instructions;
         body.emit(f11B3);

         /* END IF */

         body.emit(assign(r119A, r11B2, 0x01));


      body.instructions = f11A4_parent_instructions;
      body.emit(f11A4);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f11A2->else_instructions;

      /* IF CONDITION */
      ir_expression *const r11BA = less(r119E, body.constant(int(1023)));
      ir_if *f11B9 = new(mem_ctx) ir_if(operand(r11BA).val);
      exec_list *const f11B9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f11B9->then_instructions;

         body.emit(assign(r1199, body.constant(int(0)), 0x01));

         body.emit(assign(r1198, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f11B9->else_instructions;

         body.emit(assign(r119C, bit_or(r119D, body.constant(1048576u)), 0x01));

         ir_expression *const r11BB = neg(r11A1);
         body.emit(assign(r119A, rshift(r119C, r11BB), 0x01));


      body.instructions = f11B9_parent_instructions;
      body.emit(f11B9);

      /* END IF */


   body.instructions = f11A2_parent_instructions;
   body.emit(f11A2);

   /* END IF */

   /* IF CONDITION */
   ir_if *f11BC = new(mem_ctx) ir_if(operand(r1198).val);
   exec_list *const f11BC_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f11BC->then_instructions;

      ir_variable *const r11BD = body.make_temp(glsl_type::int_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r11BF = nequal(r119B, body.constant(0u));
      ir_if *f11BE = new(mem_ctx) ir_if(operand(r11BF).val);
      exec_list *const f11BE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f11BE->then_instructions;

         ir_expression *const r11C0 = expr(ir_unop_u2i, r119A);
         body.emit(assign(r11BD, neg(r11C0), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f11BE->else_instructions;

         body.emit(assign(r11BD, expr(ir_unop_u2i, r119A), 0x01));


      body.instructions = f11BE_parent_instructions;
      body.emit(f11BE);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r11C2 = less(r11BD, body.constant(int(0)));
      ir_expression *const r11C3 = expr(ir_unop_b2i, r11C2);
      ir_expression *const r11C4 = expr(ir_unop_i2u, r11C3);
      ir_expression *const r11C5 = bit_xor(r119B, r11C4);
      ir_expression *const r11C6 = expr(ir_unop_u2i, r11C5);
      ir_expression *const r11C7 = expr(ir_unop_i2b, r11C6);
      ir_expression *const r11C8 = expr(ir_unop_i2b, r11BD);
      ir_expression *const r11C9 = logic_and(r11C7, r11C8);
      ir_if *f11C1 = new(mem_ctx) ir_if(operand(r11C9).val);
      exec_list *const f11C1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f11C1->then_instructions;

         ir_variable *const r11CA = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r11CC = expr(ir_unop_u2i, r119B);
         ir_expression *const r11CD = expr(ir_unop_i2b, r11CC);
         ir_if *f11CB = new(mem_ctx) ir_if(operand(r11CD).val);
         exec_list *const f11CB_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11CB->then_instructions;

            body.emit(assign(r11CA, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f11CB->else_instructions;

            body.emit(assign(r11CA, body.constant(int(2147483647)), 0x01));


         body.instructions = f11CB_parent_instructions;
         body.emit(f11CB);

         /* END IF */

         body.emit(assign(r1199, r11CA, 0x01));

         body.emit(assign(r1198, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f11C1->else_instructions;

         body.emit(assign(r1199, r11BD, 0x01));

         body.emit(assign(r1198, body.constant(false), 0x01));


      body.instructions = f11C1_parent_instructions;
      body.emit(f11C1);

      /* END IF */


   body.instructions = f11BC_parent_instructions;
   body.emit(f11BC);

   /* END IF */

   body.emit(ret(r1199));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
int_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r11CE = new(mem_ctx) ir_variable(glsl_type::int_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r11CE);
   ir_variable *const r11CF = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r11D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r11D0);
   ir_variable *const r11D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r11D1);
   ir_variable *const r11D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r11D2);
   body.emit(assign(r11D2, body.constant(0u), 0x01));

   body.emit(assign(r11D1, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r11D4 = equal(r11CE, body.constant(int(0)));
   ir_if *f11D3 = new(mem_ctx) ir_if(operand(r11D4).val);
   exec_list *const f11D3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f11D3->then_instructions;

      ir_variable *const r11D5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r11D5);
      body.emit(assign(r11D5, body.constant(0u), 0x02));

      body.emit(assign(r11D5, body.constant(0u), 0x01));

      body.emit(assign(r11CF, r11D5, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f11D3->else_instructions;

      ir_expression *const r11D6 = less(r11CE, body.constant(int(0)));
      ir_expression *const r11D7 = expr(ir_unop_b2i, r11D6);
      body.emit(assign(r11D0, expr(ir_unop_i2u, r11D7), 0x01));

      ir_variable *const r11D8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r11DA = less(r11CE, body.constant(int(0)));
      ir_if *f11D9 = new(mem_ctx) ir_if(operand(r11DA).val);
      exec_list *const f11D9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f11D9->then_instructions;

         ir_expression *const r11DB = neg(r11CE);
         body.emit(assign(r11D8, expr(ir_unop_i2u, r11DB), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f11D9->else_instructions;

         body.emit(assign(r11D8, expr(ir_unop_i2u, r11CE), 0x01));


      body.instructions = f11D9_parent_instructions;
      body.emit(f11D9);

      /* END IF */

      ir_variable *const r11DC = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r11DC, r11D8, 0x01));

      ir_variable *const r11DD = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r11DE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r11DE);
      /* IF CONDITION */
      ir_expression *const r11E0 = equal(r11D8, body.constant(0u));
      ir_if *f11DF = new(mem_ctx) ir_if(operand(r11E0).val);
      exec_list *const f11DF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f11DF->then_instructions;

         body.emit(assign(r11DD, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f11DF->else_instructions;

         body.emit(assign(r11DE, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r11E2 = bit_and(r11D8, body.constant(4294901760u));
         ir_expression *const r11E3 = equal(r11E2, body.constant(0u));
         ir_if *f11E1 = new(mem_ctx) ir_if(operand(r11E3).val);
         exec_list *const f11E1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11E1->then_instructions;

            body.emit(assign(r11DE, body.constant(int(16)), 0x01));

            body.emit(assign(r11DC, lshift(r11D8, body.constant(int(16))), 0x01));


         body.instructions = f11E1_parent_instructions;
         body.emit(f11E1);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r11E5 = bit_and(r11DC, body.constant(4278190080u));
         ir_expression *const r11E6 = equal(r11E5, body.constant(0u));
         ir_if *f11E4 = new(mem_ctx) ir_if(operand(r11E6).val);
         exec_list *const f11E4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11E4->then_instructions;

            body.emit(assign(r11DE, add(r11DE, body.constant(int(8))), 0x01));

            body.emit(assign(r11DC, lshift(r11DC, body.constant(int(8))), 0x01));


         body.instructions = f11E4_parent_instructions;
         body.emit(f11E4);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r11E8 = bit_and(r11DC, body.constant(4026531840u));
         ir_expression *const r11E9 = equal(r11E8, body.constant(0u));
         ir_if *f11E7 = new(mem_ctx) ir_if(operand(r11E9).val);
         exec_list *const f11E7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11E7->then_instructions;

            body.emit(assign(r11DE, add(r11DE, body.constant(int(4))), 0x01));

            body.emit(assign(r11DC, lshift(r11DC, body.constant(int(4))), 0x01));


         body.instructions = f11E7_parent_instructions;
         body.emit(f11E7);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r11EB = bit_and(r11DC, body.constant(3221225472u));
         ir_expression *const r11EC = equal(r11EB, body.constant(0u));
         ir_if *f11EA = new(mem_ctx) ir_if(operand(r11EC).val);
         exec_list *const f11EA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11EA->then_instructions;

            body.emit(assign(r11DE, add(r11DE, body.constant(int(2))), 0x01));

            body.emit(assign(r11DC, lshift(r11DC, body.constant(int(2))), 0x01));


         body.instructions = f11EA_parent_instructions;
         body.emit(f11EA);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r11EE = bit_and(r11DC, body.constant(2147483648u));
         ir_expression *const r11EF = equal(r11EE, body.constant(0u));
         ir_if *f11ED = new(mem_ctx) ir_if(operand(r11EF).val);
         exec_list *const f11ED_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11ED->then_instructions;

            body.emit(assign(r11DE, add(r11DE, body.constant(int(1))), 0x01));


         body.instructions = f11ED_parent_instructions;
         body.emit(f11ED);

         /* END IF */

         body.emit(assign(r11DD, r11DE, 0x01));


      body.instructions = f11DF_parent_instructions;
      body.emit(f11DF);

      /* END IF */

      ir_variable *const r11F0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r11F0, add(r11DD, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r11F2 = lequal(body.constant(int(0)), r11F0);
      ir_if *f11F1 = new(mem_ctx) ir_if(operand(r11F2).val);
      exec_list *const f11F1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f11F1->then_instructions;

         body.emit(assign(r11D2, lshift(r11D8, r11F0), 0x01));

         body.emit(assign(r11D1, body.constant(0u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f11F1->else_instructions;

         ir_variable *const r11F3 = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r11F3, body.constant(0u), 0x01));

         ir_variable *const r11F4 = body.make_temp(glsl_type::int_type, "count");
         body.emit(assign(r11F4, neg(r11F0), 0x01));

         ir_variable *const r11F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r11F5);
         ir_variable *const r11F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r11F6);
         ir_variable *const r11F7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r11F8 = neg(r11F4);
         body.emit(assign(r11F7, bit_and(r11F8, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r11FA = equal(r11F4, body.constant(int(0)));
         ir_if *f11F9 = new(mem_ctx) ir_if(operand(r11FA).val);
         exec_list *const f11F9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11F9->then_instructions;

            body.emit(assign(r11F5, body.constant(0u), 0x01));

            body.emit(assign(r11F6, r11D8, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f11F9->else_instructions;

            /* IF CONDITION */
            ir_expression *const r11FC = less(r11F4, body.constant(int(32)));
            ir_if *f11FB = new(mem_ctx) ir_if(operand(r11FC).val);
            exec_list *const f11FB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f11FB->then_instructions;

               ir_expression *const r11FD = lshift(r11D8, r11F7);
               body.emit(assign(r11F5, bit_or(r11FD, body.constant(0u)), 0x01));

               body.emit(assign(r11F6, rshift(r11D8, r11F4), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f11FB->else_instructions;

               ir_variable *const r11FE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1200 = less(r11F4, body.constant(int(64)));
               ir_if *f11FF = new(mem_ctx) ir_if(operand(r1200).val);
               exec_list *const f11FF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f11FF->then_instructions;

                  ir_expression *const r1201 = bit_and(r11F4, body.constant(int(31)));
                  body.emit(assign(r11FE, rshift(r11D8, r1201), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f11FF->else_instructions;

                  body.emit(assign(r11FE, body.constant(0u), 0x01));


               body.instructions = f11FF_parent_instructions;
               body.emit(f11FF);

               /* END IF */

               body.emit(assign(r11F5, r11FE, 0x01));

               body.emit(assign(r11F6, body.constant(0u), 0x01));


            body.instructions = f11FB_parent_instructions;
            body.emit(f11FB);

            /* END IF */


         body.instructions = f11F9_parent_instructions;
         body.emit(f11F9);

         /* END IF */

         body.emit(assign(r11D2, r11F6, 0x01));

         body.emit(assign(r11D1, r11F5, 0x01));


      body.instructions = f11F1_parent_instructions;
      body.emit(f11F1);

      /* END IF */

      ir_variable *const r1202 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1202);
      ir_expression *const r1203 = lshift(r11D0, body.constant(int(31)));
      ir_expression *const r1204 = sub(body.constant(int(1042)), r11F0);
      ir_expression *const r1205 = expr(ir_unop_i2u, r1204);
      ir_expression *const r1206 = lshift(r1205, body.constant(int(20)));
      ir_expression *const r1207 = add(r1203, r1206);
      body.emit(assign(r1202, add(r1207, r11D2), 0x02));

      body.emit(assign(r1202, r11D1, 0x01));

      body.emit(assign(r11CF, r1202, 0x03));


   body.instructions = f11D3_parent_instructions;
   body.emit(f11D3);

   /* END IF */

   body.emit(ret(r11CF));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtOddAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1208 = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r1208);
   ir_variable *const r1209 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r1209);
   body.emit(assign(r1209, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r120B = equal(r1208, body.constant(int(0)));
   ir_if *f120A = new(mem_ctx) ir_if(operand(r120B).val);
   exec_list *const f120A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f120A->then_instructions;

      body.emit(assign(r1209, body.constant(4u), 0x01));


   body.instructions = f120A_parent_instructions;
   body.emit(f120A);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r120D = equal(r1208, body.constant(int(1)));
   ir_if *f120C = new(mem_ctx) ir_if(operand(r120D).val);
   exec_list *const f120C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f120C->then_instructions;

      body.emit(assign(r1209, body.constant(34u), 0x01));


   body.instructions = f120C_parent_instructions;
   body.emit(f120C);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r120F = equal(r1208, body.constant(int(2)));
   ir_if *f120E = new(mem_ctx) ir_if(operand(r120F).val);
   exec_list *const f120E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f120E->then_instructions;

      body.emit(assign(r1209, body.constant(93u), 0x01));


   body.instructions = f120E_parent_instructions;
   body.emit(f120E);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1211 = equal(r1208, body.constant(int(3)));
   ir_if *f1210 = new(mem_ctx) ir_if(operand(r1211).val);
   exec_list *const f1210_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1210->then_instructions;

      body.emit(assign(r1209, body.constant(177u), 0x01));


   body.instructions = f1210_parent_instructions;
   body.emit(f1210);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1213 = equal(r1208, body.constant(int(4)));
   ir_if *f1212 = new(mem_ctx) ir_if(operand(r1213).val);
   exec_list *const f1212_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1212->then_instructions;

      body.emit(assign(r1209, body.constant(285u), 0x01));


   body.instructions = f1212_parent_instructions;
   body.emit(f1212);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1215 = equal(r1208, body.constant(int(5)));
   ir_if *f1214 = new(mem_ctx) ir_if(operand(r1215).val);
   exec_list *const f1214_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1214->then_instructions;

      body.emit(assign(r1209, body.constant(415u), 0x01));


   body.instructions = f1214_parent_instructions;
   body.emit(f1214);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1217 = equal(r1208, body.constant(int(6)));
   ir_if *f1216 = new(mem_ctx) ir_if(operand(r1217).val);
   exec_list *const f1216_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1216->then_instructions;

      body.emit(assign(r1209, body.constant(566u), 0x01));


   body.instructions = f1216_parent_instructions;
   body.emit(f1216);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1219 = equal(r1208, body.constant(int(7)));
   ir_if *f1218 = new(mem_ctx) ir_if(operand(r1219).val);
   exec_list *const f1218_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1218->then_instructions;

      body.emit(assign(r1209, body.constant(736u), 0x01));


   body.instructions = f1218_parent_instructions;
   body.emit(f1218);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r121B = equal(r1208, body.constant(int(8)));
   ir_if *f121A = new(mem_ctx) ir_if(operand(r121B).val);
   exec_list *const f121A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f121A->then_instructions;

      body.emit(assign(r1209, body.constant(924u), 0x01));


   body.instructions = f121A_parent_instructions;
   body.emit(f121A);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r121D = equal(r1208, body.constant(int(9)));
   ir_if *f121C = new(mem_ctx) ir_if(operand(r121D).val);
   exec_list *const f121C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f121C->then_instructions;

      body.emit(assign(r1209, body.constant(1128u), 0x01));


   body.instructions = f121C_parent_instructions;
   body.emit(f121C);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r121F = equal(r1208, body.constant(int(10)));
   ir_if *f121E = new(mem_ctx) ir_if(operand(r121F).val);
   exec_list *const f121E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f121E->then_instructions;

      body.emit(assign(r1209, body.constant(1349u), 0x01));


   body.instructions = f121E_parent_instructions;
   body.emit(f121E);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1221 = equal(r1208, body.constant(int(11)));
   ir_if *f1220 = new(mem_ctx) ir_if(operand(r1221).val);
   exec_list *const f1220_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1220->then_instructions;

      body.emit(assign(r1209, body.constant(1585u), 0x01));


   body.instructions = f1220_parent_instructions;
   body.emit(f1220);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1223 = equal(r1208, body.constant(int(12)));
   ir_if *f1222 = new(mem_ctx) ir_if(operand(r1223).val);
   exec_list *const f1222_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1222->then_instructions;

      body.emit(assign(r1209, body.constant(1835u), 0x01));


   body.instructions = f1222_parent_instructions;
   body.emit(f1222);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1225 = equal(r1208, body.constant(int(13)));
   ir_if *f1224 = new(mem_ctx) ir_if(operand(r1225).val);
   exec_list *const f1224_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1224->then_instructions;

      body.emit(assign(r1209, body.constant(2098u), 0x01));


   body.instructions = f1224_parent_instructions;
   body.emit(f1224);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1227 = equal(r1208, body.constant(int(14)));
   ir_if *f1226 = new(mem_ctx) ir_if(operand(r1227).val);
   exec_list *const f1226_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1226->then_instructions;

      body.emit(assign(r1209, body.constant(2374u), 0x01));


   body.instructions = f1226_parent_instructions;
   body.emit(f1226);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1229 = equal(r1208, body.constant(int(15)));
   ir_if *f1228 = new(mem_ctx) ir_if(operand(r1229).val);
   exec_list *const f1228_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1228->then_instructions;

      body.emit(assign(r1209, body.constant(2663u), 0x01));


   body.instructions = f1228_parent_instructions;
   body.emit(f1228);

   /* END IF */

   body.emit(ret(r1209));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtEvenAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r122A = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r122A);
   ir_variable *const r122B = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r122B);
   body.emit(assign(r122B, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r122D = equal(r122A, body.constant(int(0)));
   ir_if *f122C = new(mem_ctx) ir_if(operand(r122D).val);
   exec_list *const f122C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f122C->then_instructions;

      body.emit(assign(r122B, body.constant(2605u), 0x01));


   body.instructions = f122C_parent_instructions;
   body.emit(f122C);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r122F = equal(r122A, body.constant(int(1)));
   ir_if *f122E = new(mem_ctx) ir_if(operand(r122F).val);
   exec_list *const f122E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f122E->then_instructions;

      body.emit(assign(r122B, body.constant(2223u), 0x01));


   body.instructions = f122E_parent_instructions;
   body.emit(f122E);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1231 = equal(r122A, body.constant(int(2)));
   ir_if *f1230 = new(mem_ctx) ir_if(operand(r1231).val);
   exec_list *const f1230_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1230->then_instructions;

      body.emit(assign(r122B, body.constant(1882u), 0x01));


   body.instructions = f1230_parent_instructions;
   body.emit(f1230);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1233 = equal(r122A, body.constant(int(3)));
   ir_if *f1232 = new(mem_ctx) ir_if(operand(r1233).val);
   exec_list *const f1232_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1232->then_instructions;

      body.emit(assign(r122B, body.constant(1577u), 0x01));


   body.instructions = f1232_parent_instructions;
   body.emit(f1232);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1235 = equal(r122A, body.constant(int(4)));
   ir_if *f1234 = new(mem_ctx) ir_if(operand(r1235).val);
   exec_list *const f1234_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1234->then_instructions;

      body.emit(assign(r122B, body.constant(1306u), 0x01));


   body.instructions = f1234_parent_instructions;
   body.emit(f1234);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1237 = equal(r122A, body.constant(int(5)));
   ir_if *f1236 = new(mem_ctx) ir_if(operand(r1237).val);
   exec_list *const f1236_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1236->then_instructions;

      body.emit(assign(r122B, body.constant(1065u), 0x01));


   body.instructions = f1236_parent_instructions;
   body.emit(f1236);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1239 = equal(r122A, body.constant(int(6)));
   ir_if *f1238 = new(mem_ctx) ir_if(operand(r1239).val);
   exec_list *const f1238_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1238->then_instructions;

      body.emit(assign(r122B, body.constant(854u), 0x01));


   body.instructions = f1238_parent_instructions;
   body.emit(f1238);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r123B = equal(r122A, body.constant(int(7)));
   ir_if *f123A = new(mem_ctx) ir_if(operand(r123B).val);
   exec_list *const f123A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f123A->then_instructions;

      body.emit(assign(r122B, body.constant(670u), 0x01));


   body.instructions = f123A_parent_instructions;
   body.emit(f123A);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r123D = equal(r122A, body.constant(int(8)));
   ir_if *f123C = new(mem_ctx) ir_if(operand(r123D).val);
   exec_list *const f123C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f123C->then_instructions;

      body.emit(assign(r122B, body.constant(512u), 0x01));


   body.instructions = f123C_parent_instructions;
   body.emit(f123C);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r123F = equal(r122A, body.constant(int(9)));
   ir_if *f123E = new(mem_ctx) ir_if(operand(r123F).val);
   exec_list *const f123E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f123E->then_instructions;

      body.emit(assign(r122B, body.constant(377u), 0x01));


   body.instructions = f123E_parent_instructions;
   body.emit(f123E);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1241 = equal(r122A, body.constant(int(10)));
   ir_if *f1240 = new(mem_ctx) ir_if(operand(r1241).val);
   exec_list *const f1240_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1240->then_instructions;

      body.emit(assign(r122B, body.constant(265u), 0x01));


   body.instructions = f1240_parent_instructions;
   body.emit(f1240);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1243 = equal(r122A, body.constant(int(11)));
   ir_if *f1242 = new(mem_ctx) ir_if(operand(r1243).val);
   exec_list *const f1242_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1242->then_instructions;

      body.emit(assign(r122B, body.constant(175u), 0x01));


   body.instructions = f1242_parent_instructions;
   body.emit(f1242);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1245 = equal(r122A, body.constant(int(12)));
   ir_if *f1244 = new(mem_ctx) ir_if(operand(r1245).val);
   exec_list *const f1244_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1244->then_instructions;

      body.emit(assign(r122B, body.constant(104u), 0x01));


   body.instructions = f1244_parent_instructions;
   body.emit(f1244);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1247 = equal(r122A, body.constant(int(13)));
   ir_if *f1246 = new(mem_ctx) ir_if(operand(r1247).val);
   exec_list *const f1246_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1246->then_instructions;

      body.emit(assign(r122B, body.constant(52u), 0x01));


   body.instructions = f1246_parent_instructions;
   body.emit(f1246);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1249 = equal(r122A, body.constant(int(14)));
   ir_if *f1248 = new(mem_ctx) ir_if(operand(r1249).val);
   exec_list *const f1248_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1248->then_instructions;

      body.emit(assign(r122B, body.constant(18u), 0x01));


   body.instructions = f1248_parent_instructions;
   body.emit(f1248);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r124B = equal(r122A, body.constant(int(15)));
   ir_if *f124A = new(mem_ctx) ir_if(operand(r124B).val);
   exec_list *const f124A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f124A->then_instructions;

      body.emit(assign(r122B, body.constant(2u), 0x01));


   body.instructions = f124A_parent_instructions;
   body.emit(f124A);

   /* END IF */

   body.emit(ret(r122B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateSqrt32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r124C = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_function_in);
   sig_parameters.push_tail(r124C);
   ir_variable *const r124D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r124D);
   ir_variable *const r124E = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r124E, body.constant(true), 0x01));

   ir_variable *const r124F = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1250 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r1250);
   ir_variable *const r1251 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1252 = rshift(r124D, body.constant(int(27)));
   ir_expression *const r1253 = bit_and(r1252, body.constant(15u));
   body.emit(assign(r1251, expr(ir_unop_u2i, r1253), 0x01));

   /* IF CONDITION */
   ir_expression *const r1255 = bit_and(r124C, body.constant(int(1)));
   ir_expression *const r1256 = nequal(r1255, body.constant(int(0)));
   ir_if *f1254 = new(mem_ctx) ir_if(operand(r1256).val);
   exec_list *const f1254_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1254->then_instructions;

      ir_variable *const r1257 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r1257);
      body.emit(assign(r1257, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1259 = equal(r1251, body.constant(int(0)));
      ir_if *f1258 = new(mem_ctx) ir_if(operand(r1259).val);
      exec_list *const f1258_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1258->then_instructions;

         body.emit(assign(r1257, body.constant(4u), 0x01));


      body.instructions = f1258_parent_instructions;
      body.emit(f1258);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r125B = equal(r1251, body.constant(int(1)));
      ir_if *f125A = new(mem_ctx) ir_if(operand(r125B).val);
      exec_list *const f125A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f125A->then_instructions;

         body.emit(assign(r1257, body.constant(34u), 0x01));


      body.instructions = f125A_parent_instructions;
      body.emit(f125A);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r125D = equal(r1251, body.constant(int(2)));
      ir_if *f125C = new(mem_ctx) ir_if(operand(r125D).val);
      exec_list *const f125C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f125C->then_instructions;

         body.emit(assign(r1257, body.constant(93u), 0x01));


      body.instructions = f125C_parent_instructions;
      body.emit(f125C);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r125F = equal(r1251, body.constant(int(3)));
      ir_if *f125E = new(mem_ctx) ir_if(operand(r125F).val);
      exec_list *const f125E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f125E->then_instructions;

         body.emit(assign(r1257, body.constant(177u), 0x01));


      body.instructions = f125E_parent_instructions;
      body.emit(f125E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1261 = equal(r1251, body.constant(int(4)));
      ir_if *f1260 = new(mem_ctx) ir_if(operand(r1261).val);
      exec_list *const f1260_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1260->then_instructions;

         body.emit(assign(r1257, body.constant(285u), 0x01));


      body.instructions = f1260_parent_instructions;
      body.emit(f1260);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1263 = equal(r1251, body.constant(int(5)));
      ir_if *f1262 = new(mem_ctx) ir_if(operand(r1263).val);
      exec_list *const f1262_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1262->then_instructions;

         body.emit(assign(r1257, body.constant(415u), 0x01));


      body.instructions = f1262_parent_instructions;
      body.emit(f1262);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1265 = equal(r1251, body.constant(int(6)));
      ir_if *f1264 = new(mem_ctx) ir_if(operand(r1265).val);
      exec_list *const f1264_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1264->then_instructions;

         body.emit(assign(r1257, body.constant(566u), 0x01));


      body.instructions = f1264_parent_instructions;
      body.emit(f1264);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1267 = equal(r1251, body.constant(int(7)));
      ir_if *f1266 = new(mem_ctx) ir_if(operand(r1267).val);
      exec_list *const f1266_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1266->then_instructions;

         body.emit(assign(r1257, body.constant(736u), 0x01));


      body.instructions = f1266_parent_instructions;
      body.emit(f1266);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1269 = equal(r1251, body.constant(int(8)));
      ir_if *f1268 = new(mem_ctx) ir_if(operand(r1269).val);
      exec_list *const f1268_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1268->then_instructions;

         body.emit(assign(r1257, body.constant(924u), 0x01));


      body.instructions = f1268_parent_instructions;
      body.emit(f1268);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r126B = equal(r1251, body.constant(int(9)));
      ir_if *f126A = new(mem_ctx) ir_if(operand(r126B).val);
      exec_list *const f126A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f126A->then_instructions;

         body.emit(assign(r1257, body.constant(1128u), 0x01));


      body.instructions = f126A_parent_instructions;
      body.emit(f126A);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r126D = equal(r1251, body.constant(int(10)));
      ir_if *f126C = new(mem_ctx) ir_if(operand(r126D).val);
      exec_list *const f126C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f126C->then_instructions;

         body.emit(assign(r1257, body.constant(1349u), 0x01));


      body.instructions = f126C_parent_instructions;
      body.emit(f126C);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r126F = equal(r1251, body.constant(int(11)));
      ir_if *f126E = new(mem_ctx) ir_if(operand(r126F).val);
      exec_list *const f126E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f126E->then_instructions;

         body.emit(assign(r1257, body.constant(1585u), 0x01));


      body.instructions = f126E_parent_instructions;
      body.emit(f126E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1271 = equal(r1251, body.constant(int(12)));
      ir_if *f1270 = new(mem_ctx) ir_if(operand(r1271).val);
      exec_list *const f1270_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1270->then_instructions;

         body.emit(assign(r1257, body.constant(1835u), 0x01));


      body.instructions = f1270_parent_instructions;
      body.emit(f1270);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1273 = equal(r1251, body.constant(int(13)));
      ir_if *f1272 = new(mem_ctx) ir_if(operand(r1273).val);
      exec_list *const f1272_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1272->then_instructions;

         body.emit(assign(r1257, body.constant(2098u), 0x01));


      body.instructions = f1272_parent_instructions;
      body.emit(f1272);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1275 = equal(r1251, body.constant(int(14)));
      ir_if *f1274 = new(mem_ctx) ir_if(operand(r1275).val);
      exec_list *const f1274_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1274->then_instructions;

         body.emit(assign(r1257, body.constant(2374u), 0x01));


      body.instructions = f1274_parent_instructions;
      body.emit(f1274);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1277 = equal(r1251, body.constant(int(15)));
      ir_if *f1276 = new(mem_ctx) ir_if(operand(r1277).val);
      exec_list *const f1276_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1276->then_instructions;

         body.emit(assign(r1257, body.constant(2663u), 0x01));


      body.instructions = f1276_parent_instructions;
      body.emit(f1276);

      /* END IF */

      ir_expression *const r1278 = rshift(r124D, body.constant(int(17)));
      ir_expression *const r1279 = add(body.constant(16384u), r1278);
      body.emit(assign(r1250, sub(r1279, r1257), 0x01));

      ir_expression *const r127A = expr(ir_binop_div, r124D, r1250);
      ir_expression *const r127B = lshift(r127A, body.constant(int(14)));
      ir_expression *const r127C = lshift(r1250, body.constant(int(15)));
      body.emit(assign(r1250, add(r127B, r127C), 0x01));

      body.emit(assign(r124D, rshift(r124D, body.constant(int(1))), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1254->else_instructions;

      ir_variable *const r127D = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r127D);
      body.emit(assign(r127D, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r127F = equal(r1251, body.constant(int(0)));
      ir_if *f127E = new(mem_ctx) ir_if(operand(r127F).val);
      exec_list *const f127E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f127E->then_instructions;

         body.emit(assign(r127D, body.constant(2605u), 0x01));


      body.instructions = f127E_parent_instructions;
      body.emit(f127E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1281 = equal(r1251, body.constant(int(1)));
      ir_if *f1280 = new(mem_ctx) ir_if(operand(r1281).val);
      exec_list *const f1280_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1280->then_instructions;

         body.emit(assign(r127D, body.constant(2223u), 0x01));


      body.instructions = f1280_parent_instructions;
      body.emit(f1280);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1283 = equal(r1251, body.constant(int(2)));
      ir_if *f1282 = new(mem_ctx) ir_if(operand(r1283).val);
      exec_list *const f1282_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1282->then_instructions;

         body.emit(assign(r127D, body.constant(1882u), 0x01));


      body.instructions = f1282_parent_instructions;
      body.emit(f1282);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1285 = equal(r1251, body.constant(int(3)));
      ir_if *f1284 = new(mem_ctx) ir_if(operand(r1285).val);
      exec_list *const f1284_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1284->then_instructions;

         body.emit(assign(r127D, body.constant(1577u), 0x01));


      body.instructions = f1284_parent_instructions;
      body.emit(f1284);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1287 = equal(r1251, body.constant(int(4)));
      ir_if *f1286 = new(mem_ctx) ir_if(operand(r1287).val);
      exec_list *const f1286_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1286->then_instructions;

         body.emit(assign(r127D, body.constant(1306u), 0x01));


      body.instructions = f1286_parent_instructions;
      body.emit(f1286);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1289 = equal(r1251, body.constant(int(5)));
      ir_if *f1288 = new(mem_ctx) ir_if(operand(r1289).val);
      exec_list *const f1288_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1288->then_instructions;

         body.emit(assign(r127D, body.constant(1065u), 0x01));


      body.instructions = f1288_parent_instructions;
      body.emit(f1288);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r128B = equal(r1251, body.constant(int(6)));
      ir_if *f128A = new(mem_ctx) ir_if(operand(r128B).val);
      exec_list *const f128A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f128A->then_instructions;

         body.emit(assign(r127D, body.constant(854u), 0x01));


      body.instructions = f128A_parent_instructions;
      body.emit(f128A);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r128D = equal(r1251, body.constant(int(7)));
      ir_if *f128C = new(mem_ctx) ir_if(operand(r128D).val);
      exec_list *const f128C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f128C->then_instructions;

         body.emit(assign(r127D, body.constant(670u), 0x01));


      body.instructions = f128C_parent_instructions;
      body.emit(f128C);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r128F = equal(r1251, body.constant(int(8)));
      ir_if *f128E = new(mem_ctx) ir_if(operand(r128F).val);
      exec_list *const f128E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f128E->then_instructions;

         body.emit(assign(r127D, body.constant(512u), 0x01));


      body.instructions = f128E_parent_instructions;
      body.emit(f128E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1291 = equal(r1251, body.constant(int(9)));
      ir_if *f1290 = new(mem_ctx) ir_if(operand(r1291).val);
      exec_list *const f1290_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1290->then_instructions;

         body.emit(assign(r127D, body.constant(377u), 0x01));


      body.instructions = f1290_parent_instructions;
      body.emit(f1290);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1293 = equal(r1251, body.constant(int(10)));
      ir_if *f1292 = new(mem_ctx) ir_if(operand(r1293).val);
      exec_list *const f1292_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1292->then_instructions;

         body.emit(assign(r127D, body.constant(265u), 0x01));


      body.instructions = f1292_parent_instructions;
      body.emit(f1292);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1295 = equal(r1251, body.constant(int(11)));
      ir_if *f1294 = new(mem_ctx) ir_if(operand(r1295).val);
      exec_list *const f1294_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1294->then_instructions;

         body.emit(assign(r127D, body.constant(175u), 0x01));


      body.instructions = f1294_parent_instructions;
      body.emit(f1294);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1297 = equal(r1251, body.constant(int(12)));
      ir_if *f1296 = new(mem_ctx) ir_if(operand(r1297).val);
      exec_list *const f1296_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1296->then_instructions;

         body.emit(assign(r127D, body.constant(104u), 0x01));


      body.instructions = f1296_parent_instructions;
      body.emit(f1296);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1299 = equal(r1251, body.constant(int(13)));
      ir_if *f1298 = new(mem_ctx) ir_if(operand(r1299).val);
      exec_list *const f1298_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1298->then_instructions;

         body.emit(assign(r127D, body.constant(52u), 0x01));


      body.instructions = f1298_parent_instructions;
      body.emit(f1298);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r129B = equal(r1251, body.constant(int(14)));
      ir_if *f129A = new(mem_ctx) ir_if(operand(r129B).val);
      exec_list *const f129A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f129A->then_instructions;

         body.emit(assign(r127D, body.constant(18u), 0x01));


      body.instructions = f129A_parent_instructions;
      body.emit(f129A);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r129D = equal(r1251, body.constant(int(15)));
      ir_if *f129C = new(mem_ctx) ir_if(operand(r129D).val);
      exec_list *const f129C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f129C->then_instructions;

         body.emit(assign(r127D, body.constant(2u), 0x01));


      body.instructions = f129C_parent_instructions;
      body.emit(f129C);

      /* END IF */

      ir_expression *const r129E = rshift(r124D, body.constant(int(17)));
      ir_expression *const r129F = add(body.constant(32768u), r129E);
      body.emit(assign(r1250, sub(r129F, r127D), 0x01));

      ir_expression *const r12A0 = expr(ir_binop_div, r124D, r1250);
      body.emit(assign(r1250, add(r12A0, r1250), 0x01));

      ir_variable *const r12A1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r12A3 = lequal(body.constant(131072u), r1250);
      ir_if *f12A2 = new(mem_ctx) ir_if(operand(r12A3).val);
      exec_list *const f12A2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f12A2->then_instructions;

         body.emit(assign(r12A1, body.constant(4294934528u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f12A2->else_instructions;

         body.emit(assign(r12A1, lshift(r1250, body.constant(int(15))), 0x01));


      body.instructions = f12A2_parent_instructions;
      body.emit(f12A2);

      /* END IF */

      body.emit(assign(r1250, r12A1, 0x01));

      /* IF CONDITION */
      ir_expression *const r12A5 = lequal(r12A1, r124D);
      ir_if *f12A4 = new(mem_ctx) ir_if(operand(r12A5).val);
      exec_list *const f12A4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f12A4->then_instructions;

         ir_expression *const r12A6 = expr(ir_unop_u2i, r124D);
         ir_expression *const r12A7 = rshift(r12A6, body.constant(int(1)));
         body.emit(assign(r124F, expr(ir_unop_i2u, r12A7), 0x01));

         body.emit(assign(r124E, body.constant(false), 0x01));


      body.instructions = f12A4_parent_instructions;
      body.emit(f12A4);

      /* END IF */


   body.instructions = f1254_parent_instructions;
   body.emit(f1254);

   /* END IF */

   /* IF CONDITION */
   ir_if *f12A8 = new(mem_ctx) ir_if(operand(r124E).val);
   exec_list *const f12A8_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f12A8->then_instructions;

      ir_variable *const r12A9 = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r12AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
      body.emit(r12AA);
      ir_variable *const r12AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
      body.emit(r12AB);
      ir_variable *const r12AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
      body.emit(r12AC);
      ir_variable *const r12AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
      body.emit(r12AD);
      body.emit(assign(r12AC, body.constant(0u), 0x01));

      body.emit(assign(r12AB, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r12AF = lequal(r1250, r124D);
      ir_if *f12AE = new(mem_ctx) ir_if(operand(r12AF).val);
      exec_list *const f12AE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f12AE->then_instructions;

         body.emit(assign(r12A9, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f12AE->else_instructions;

         body.emit(assign(r12AD, rshift(r1250, body.constant(int(16))), 0x01));

         ir_variable *const r12B0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r12B2 = lshift(r12AD, body.constant(int(16)));
         ir_expression *const r12B3 = lequal(r12B2, r124D);
         ir_if *f12B1 = new(mem_ctx) ir_if(operand(r12B3).val);
         exec_list *const f12B1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f12B1->then_instructions;

            body.emit(assign(r12B0, body.constant(4294901760u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f12B1->else_instructions;

            ir_expression *const r12B4 = expr(ir_binop_div, r124D, r12AD);
            body.emit(assign(r12B0, lshift(r12B4, body.constant(int(16))), 0x01));


         body.instructions = f12B1_parent_instructions;
         body.emit(f12B1);

         /* END IF */

         body.emit(assign(r12AA, r12B0, 0x01));

         ir_variable *const r12B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r12B5);
         ir_variable *const r12B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
         body.emit(r12B6);
         ir_variable *const r12B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r12B7);
         ir_variable *const r12B8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r12B8, bit_and(r1250, body.constant(65535u)), 0x01));

         ir_variable *const r12B9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r12B9, rshift(r1250, body.constant(int(16))), 0x01));

         ir_variable *const r12BA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r12BA, bit_and(r12B0, body.constant(65535u)), 0x01));

         ir_variable *const r12BB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r12BB, rshift(r12B0, body.constant(int(16))), 0x01));

         ir_variable *const r12BC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r12BC, mul(r12B9, r12BA), 0x01));

         ir_expression *const r12BD = mul(r12B8, r12BB);
         body.emit(assign(r12B6, add(r12BD, r12BC), 0x01));

         ir_expression *const r12BE = mul(r12B9, r12BB);
         ir_expression *const r12BF = less(r12B6, r12BC);
         ir_expression *const r12C0 = expr(ir_unop_b2i, r12BF);
         ir_expression *const r12C1 = expr(ir_unop_i2u, r12C0);
         ir_expression *const r12C2 = lshift(r12C1, body.constant(int(16)));
         ir_expression *const r12C3 = rshift(r12B6, body.constant(int(16)));
         ir_expression *const r12C4 = add(r12C2, r12C3);
         body.emit(assign(r12B5, add(r12BE, r12C4), 0x01));

         body.emit(assign(r12B6, lshift(r12B6, body.constant(int(16))), 0x01));

         ir_expression *const r12C5 = mul(r12B8, r12BA);
         body.emit(assign(r12B7, add(r12C5, r12B6), 0x01));

         ir_expression *const r12C6 = less(r12B7, r12B6);
         ir_expression *const r12C7 = expr(ir_unop_b2i, r12C6);
         ir_expression *const r12C8 = expr(ir_unop_i2u, r12C7);
         body.emit(assign(r12B5, add(r12B5, r12C8), 0x01));

         ir_expression *const r12C9 = sub(r124D, r12B5);
         ir_expression *const r12CA = less(body.constant(0u), r12B7);
         ir_expression *const r12CB = expr(ir_unop_b2i, r12CA);
         ir_expression *const r12CC = expr(ir_unop_i2u, r12CB);
         body.emit(assign(r12AC, sub(r12C9, r12CC), 0x01));

         body.emit(assign(r12AB, neg(r12B7), 0x01));

         /* LOOP BEGIN */
         ir_loop *f12CD = new(mem_ctx) ir_loop();
         exec_list *const f12CD_parent_instructions = body.instructions;

            body.instructions = &f12CD->body_instructions;

            /* IF CONDITION */
            ir_expression *const r12CF = expr(ir_unop_u2i, r12AC);
            ir_expression *const r12D0 = gequal(r12CF, body.constant(int(0)));
            ir_if *f12CE = new(mem_ctx) ir_if(operand(r12D0).val);
            exec_list *const f12CE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f12CE->then_instructions;

               body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


            body.instructions = f12CE_parent_instructions;
            body.emit(f12CE);

            /* END IF */

            body.emit(assign(r12AA, add(r12AA, body.constant(4294901760u)), 0x01));

            ir_variable *const r12D1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            ir_expression *const r12D2 = lshift(r1250, body.constant(int(16)));
            body.emit(assign(r12D1, add(r12AB, r12D2), 0x01));

            ir_expression *const r12D3 = add(r12AC, r12AD);
            ir_expression *const r12D4 = less(r12D1, r12AB);
            ir_expression *const r12D5 = expr(ir_unop_b2i, r12D4);
            ir_expression *const r12D6 = expr(ir_unop_i2u, r12D5);
            body.emit(assign(r12AC, add(r12D3, r12D6), 0x01));

            body.emit(assign(r12AB, r12D1, 0x01));

         /* LOOP END */

         body.instructions = f12CD_parent_instructions;
         body.emit(f12CD);

         ir_expression *const r12D7 = lshift(r12AC, body.constant(int(16)));
         ir_expression *const r12D8 = rshift(r12AB, body.constant(int(16)));
         body.emit(assign(r12AC, bit_or(r12D7, r12D8), 0x01));

         ir_variable *const r12D9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r12DB = lshift(r12AD, body.constant(int(16)));
         ir_expression *const r12DC = lequal(r12DB, r12AC);
         ir_if *f12DA = new(mem_ctx) ir_if(operand(r12DC).val);
         exec_list *const f12DA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f12DA->then_instructions;

            body.emit(assign(r12D9, body.constant(65535u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f12DA->else_instructions;

            body.emit(assign(r12D9, expr(ir_binop_div, r12AC, r12AD), 0x01));


         body.instructions = f12DA_parent_instructions;
         body.emit(f12DA);

         /* END IF */

         body.emit(assign(r12AA, bit_or(r12AA, r12D9), 0x01));

         body.emit(assign(r12A9, r12AA, 0x01));


      body.instructions = f12AE_parent_instructions;
      body.emit(f12AE);

      /* END IF */

      ir_expression *const r12DD = rshift(r12A9, body.constant(int(1)));
      ir_expression *const r12DE = rshift(r1250, body.constant(int(1)));
      body.emit(assign(r124F, add(r12DD, r12DE), 0x01));

      body.emit(assign(r124E, body.constant(false), 0x01));


   body.instructions = f12A8_parent_instructions;
   body.emit(f12A8);

   /* END IF */

   body.emit(ret(r124F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsqrt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r12DF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r12DF);
   ir_variable *const r12E0 = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r12E1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r12E1);
   body.emit(assign(r12E1, body.constant(0u), 0x01));

   ir_variable *const r12E2 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r12E2, bit_and(swizzle_y(r12DF), body.constant(1048575u)), 0x01));

   ir_variable *const r12E3 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r12E4 = rshift(swizzle_y(r12DF), body.constant(int(20)));
   ir_expression *const r12E5 = bit_and(r12E4, body.constant(2047u));
   body.emit(assign(r12E3, expr(ir_unop_u2i, r12E5), 0x01));

   ir_variable *const r12E6 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r12E6, rshift(swizzle_y(r12DF), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r12E8 = equal(r12E3, body.constant(int(2047)));
   ir_if *f12E7 = new(mem_ctx) ir_if(operand(r12E8).val);
   exec_list *const f12E7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f12E7->then_instructions;

      /* IF CONDITION */
      ir_expression *const r12EA = bit_or(r12E2, swizzle_x(r12DF));
      ir_expression *const r12EB = nequal(r12EA, body.constant(0u));
      ir_if *f12E9 = new(mem_ctx) ir_if(operand(r12EB).val);
      exec_list *const f12E9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f12E9->then_instructions;

         ir_variable *const r12EC = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r12EC, lshift(swizzle_x(r12DF), body.constant(int(12))), 0x01));

         ir_expression *const r12ED = lshift(r12E6, body.constant(int(31)));
         ir_expression *const r12EE = bit_or(r12ED, body.constant(2143289344u));
         ir_expression *const r12EF = lshift(swizzle_y(r12DF), body.constant(int(12)));
         ir_expression *const r12F0 = rshift(swizzle_x(r12DF), body.constant(int(20)));
         ir_expression *const r12F1 = bit_or(r12EF, r12F0);
         ir_expression *const r12F2 = rshift(r12F1, body.constant(int(9)));
         ir_expression *const r12F3 = bit_or(r12EE, r12F2);
         body.emit(assign(r12E0, expr(ir_unop_bitcast_u2f, r12F3), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f12E9->else_instructions;

         ir_expression *const r12F4 = lshift(r12E6, body.constant(int(31)));
         ir_expression *const r12F5 = add(r12F4, body.constant(2139095040u));
         body.emit(assign(r12E0, expr(ir_unop_bitcast_u2f, r12F5), 0x01));


      body.instructions = f12E9_parent_instructions;
      body.emit(f12E9);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f12E7->else_instructions;

      ir_variable *const r12F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r12F6);
      ir_variable *const r12F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r12F7);
      ir_expression *const r12F8 = lshift(r12E2, body.constant(int(10)));
      ir_expression *const r12F9 = rshift(swizzle_x(r12DF), body.constant(int(22)));
      ir_expression *const r12FA = bit_or(r12F8, r12F9);
      ir_expression *const r12FB = lshift(swizzle_x(r12DF), body.constant(int(10)));
      ir_expression *const r12FC = nequal(r12FB, body.constant(0u));
      ir_expression *const r12FD = expr(ir_unop_b2i, r12FC);
      ir_expression *const r12FE = expr(ir_unop_i2u, r12FD);
      body.emit(assign(r12F6, bit_or(r12FA, r12FE), 0x01));

      body.emit(assign(r12F7, rshift(r12E2, body.constant(int(22))), 0x01));

      body.emit(assign(r12E1, r12F6, 0x01));

      /* IF CONDITION */
      ir_expression *const r1300 = nequal(r12E3, body.constant(int(0)));
      ir_if *f12FF = new(mem_ctx) ir_if(operand(r1300).val);
      exec_list *const f12FF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f12FF->then_instructions;

         body.emit(assign(r12E1, bit_or(r12F6, body.constant(1073741824u)), 0x01));


      body.instructions = f12FF_parent_instructions;
      body.emit(f12FF);

      /* END IF */

      ir_variable *const r1301 = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r1301, add(r12E3, body.constant(int(-897))), 0x01));

      ir_variable *const r1302 = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r1302, r12E1, 0x01));

      ir_variable *const r1303 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r1303, body.constant(true), 0x01));

      ir_variable *const r1304 = body.make_temp(glsl_type::float_type, "return_value");
      ir_variable *const r1305 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
      body.emit(r1305);
      ir_expression *const r1306 = bit_and(r12E1, body.constant(127u));
      body.emit(assign(r1305, expr(ir_unop_u2i, r1306), 0x01));

      /* IF CONDITION */
      ir_expression *const r1308 = expr(ir_unop_i2u, r1301);
      ir_expression *const r1309 = lequal(body.constant(253u), r1308);
      ir_if *f1307 = new(mem_ctx) ir_if(operand(r1309).val);
      exec_list *const f1307_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1307->then_instructions;

         /* IF CONDITION */
         ir_expression *const r130B = less(body.constant(int(253)), r1301);
         ir_expression *const r130C = equal(r1301, body.constant(int(253)));
         ir_expression *const r130D = expr(ir_unop_u2i, r12E1);
         ir_expression *const r130E = less(r130D, body.constant(int(-64)));
         ir_expression *const r130F = logic_and(r130C, r130E);
         ir_expression *const r1310 = logic_or(r130B, r130F);
         ir_if *f130A = new(mem_ctx) ir_if(operand(r1310).val);
         exec_list *const f130A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f130A->then_instructions;

            ir_expression *const r1311 = lshift(r12E6, body.constant(int(31)));
            ir_expression *const r1312 = add(r1311, body.constant(2139095040u));
            body.emit(assign(r1304, expr(ir_unop_bitcast_u2f, r1312), 0x01));

            body.emit(assign(r1303, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f130A->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1314 = less(r1301, body.constant(int(0)));
            ir_if *f1313 = new(mem_ctx) ir_if(operand(r1314).val);
            exec_list *const f1313_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1313->then_instructions;

               ir_variable *const r1315 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1315, neg(r1301), 0x01));

               ir_variable *const r1316 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r1316);
               /* IF CONDITION */
               ir_expression *const r1318 = equal(r1315, body.constant(int(0)));
               ir_if *f1317 = new(mem_ctx) ir_if(operand(r1318).val);
               exec_list *const f1317_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1317->then_instructions;

                  body.emit(assign(r1316, r12E1, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1317->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r131A = less(r1315, body.constant(int(32)));
                  ir_if *f1319 = new(mem_ctx) ir_if(operand(r131A).val);
                  exec_list *const f1319_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1319->then_instructions;

                     ir_expression *const r131B = rshift(r12E1, r1315);
                     ir_expression *const r131C = neg(r1315);
                     ir_expression *const r131D = bit_and(r131C, body.constant(int(31)));
                     ir_expression *const r131E = lshift(r12E1, r131D);
                     ir_expression *const r131F = nequal(r131E, body.constant(0u));
                     ir_expression *const r1320 = expr(ir_unop_b2i, r131F);
                     ir_expression *const r1321 = expr(ir_unop_i2u, r1320);
                     body.emit(assign(r1316, bit_or(r131B, r1321), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1319->else_instructions;

                     ir_expression *const r1322 = nequal(r12E1, body.constant(0u));
                     ir_expression *const r1323 = expr(ir_unop_b2i, r1322);
                     body.emit(assign(r1316, expr(ir_unop_i2u, r1323), 0x01));


                  body.instructions = f1319_parent_instructions;
                  body.emit(f1319);

                  /* END IF */


               body.instructions = f1317_parent_instructions;
               body.emit(f1317);

               /* END IF */

               body.emit(assign(r1302, r1316, 0x01));

               body.emit(assign(r1301, body.constant(int(0)), 0x01));

               ir_expression *const r1324 = expr(ir_unop_u2i, r1316);
               body.emit(assign(r1305, bit_and(r1324, body.constant(int(127))), 0x01));


            body.instructions = f1313_parent_instructions;
            body.emit(f1313);

            /* END IF */


         body.instructions = f130A_parent_instructions;
         body.emit(f130A);

         /* END IF */


      body.instructions = f1307_parent_instructions;
      body.emit(f1307);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1325 = new(mem_ctx) ir_if(operand(r1303).val);
      exec_list *const f1325_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1325->then_instructions;

         ir_expression *const r1326 = add(r1302, body.constant(64u));
         body.emit(assign(r1302, rshift(r1326, body.constant(int(7))), 0x01));

         ir_expression *const r1327 = bit_xor(r1305, body.constant(int(64)));
         ir_expression *const r1328 = equal(r1327, body.constant(int(0)));
         ir_expression *const r1329 = expr(ir_unop_b2i, r1328);
         ir_expression *const r132A = expr(ir_unop_i2u, r1329);
         ir_expression *const r132B = expr(ir_unop_bit_not, r132A);
         body.emit(assign(r1302, bit_and(r1302, r132B), 0x01));

         /* IF CONDITION */
         ir_expression *const r132D = equal(r1302, body.constant(0u));
         ir_if *f132C = new(mem_ctx) ir_if(operand(r132D).val);
         exec_list *const f132C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f132C->then_instructions;

            body.emit(assign(r1301, body.constant(int(0)), 0x01));


         body.instructions = f132C_parent_instructions;
         body.emit(f132C);

         /* END IF */

         ir_expression *const r132E = lshift(r12E6, body.constant(int(31)));
         ir_expression *const r132F = expr(ir_unop_i2u, r1301);
         ir_expression *const r1330 = lshift(r132F, body.constant(int(23)));
         ir_expression *const r1331 = add(r132E, r1330);
         ir_expression *const r1332 = add(r1331, r1302);
         body.emit(assign(r1304, expr(ir_unop_bitcast_u2f, r1332), 0x01));

         body.emit(assign(r1303, body.constant(false), 0x01));


      body.instructions = f1325_parent_instructions;
      body.emit(f1325);

      /* END IF */

      body.emit(assign(r12E0, r1304, 0x01));


   body.instructions = f12E7_parent_instructions;
   body.emit(f12E7);

   /* END IF */

   ir_variable *const r1333 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1333, body.constant(true), 0x01));

   ir_variable *const r1334 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1335 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r1335);
   ir_variable *const r1336 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r1336);
   ir_variable *const r1337 = body.make_temp(glsl_type::uint_type, "floatBitsToUint_retval");
   ir_expression *const r1338 = expr(ir_unop_sqrt, r12E0);
   body.emit(assign(r1337, expr(ir_unop_bitcast_f2u, r1338), 0x01));

   ir_variable *const r1339 = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r1339, bit_and(r1337, body.constant(8388607u)), 0x01));

   body.emit(assign(r1336, r1339, 0x01));

   ir_variable *const r133A = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r133B = rshift(r1337, body.constant(int(23)));
   ir_expression *const r133C = bit_and(r133B, body.constant(255u));
   body.emit(assign(r133A, expr(ir_unop_u2i, r133C), 0x01));

   body.emit(assign(r1335, r133A, 0x01));

   ir_variable *const r133D = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r133D, rshift(r1337, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r133F = equal(r133A, body.constant(int(255)));
   ir_if *f133E = new(mem_ctx) ir_if(operand(r133F).val);
   exec_list *const f133E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f133E->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1341 = nequal(r1339, body.constant(0u));
      ir_if *f1340 = new(mem_ctx) ir_if(operand(r1341).val);
      exec_list *const f1340_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1340->then_instructions;

         ir_variable *const r1342 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1342, lshift(r1337, body.constant(int(9))), 0x01));

         ir_variable *const r1343 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         ir_expression *const r1344 = lshift(r1342, body.constant(int(20)));
         body.emit(assign(r1343, bit_or(r1344, body.constant(0u)), 0x01));

         ir_expression *const r1345 = rshift(r1342, body.constant(int(12)));
         ir_expression *const r1346 = lshift(r133D, body.constant(int(31)));
         ir_expression *const r1347 = bit_or(r1346, body.constant(2146959360u));
         body.emit(assign(r1343, bit_or(r1345, r1347), 0x02));

         body.emit(assign(r1334, r1343, 0x03));

         body.emit(assign(r1333, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1340->else_instructions;

         ir_variable *const r1348 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1348);
         ir_expression *const r1349 = lshift(r133D, body.constant(int(31)));
         body.emit(assign(r1348, add(r1349, body.constant(2146435072u)), 0x02));

         body.emit(assign(r1348, body.constant(0u), 0x01));

         body.emit(assign(r1334, r1348, 0x03));

         body.emit(assign(r1333, body.constant(false), 0x01));


      body.instructions = f1340_parent_instructions;
      body.emit(f1340);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f133E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r134B = equal(r133A, body.constant(int(0)));
      ir_if *f134A = new(mem_ctx) ir_if(operand(r134B).val);
      exec_list *const f134A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f134A->then_instructions;

         /* IF CONDITION */
         ir_expression *const r134D = equal(r1339, body.constant(0u));
         ir_if *f134C = new(mem_ctx) ir_if(operand(r134D).val);
         exec_list *const f134C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f134C->then_instructions;

            ir_variable *const r134E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r134E);
            body.emit(assign(r134E, lshift(r133D, body.constant(int(31))), 0x02));

            body.emit(assign(r134E, body.constant(0u), 0x01));

            body.emit(assign(r1334, r134E, 0x03));

            body.emit(assign(r1333, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f134C->else_instructions;

            ir_variable *const r134F = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r134F, r133A, 0x01));

            ir_variable *const r1350 = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r1350, r1339, 0x01));

            ir_variable *const r1351 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r1351, r1339, 0x01));

            ir_variable *const r1352 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r1353 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r1353);
            /* IF CONDITION */
            ir_expression *const r1355 = equal(r1339, body.constant(0u));
            ir_if *f1354 = new(mem_ctx) ir_if(operand(r1355).val);
            exec_list *const f1354_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1354->then_instructions;

               body.emit(assign(r1352, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1354->else_instructions;

               body.emit(assign(r1353, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r1357 = bit_and(r1339, body.constant(4294901760u));
               ir_expression *const r1358 = equal(r1357, body.constant(0u));
               ir_if *f1356 = new(mem_ctx) ir_if(operand(r1358).val);
               exec_list *const f1356_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1356->then_instructions;

                  body.emit(assign(r1353, body.constant(int(16)), 0x01));

                  body.emit(assign(r1351, lshift(r1339, body.constant(int(16))), 0x01));


               body.instructions = f1356_parent_instructions;
               body.emit(f1356);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r135A = bit_and(r1351, body.constant(4278190080u));
               ir_expression *const r135B = equal(r135A, body.constant(0u));
               ir_if *f1359 = new(mem_ctx) ir_if(operand(r135B).val);
               exec_list *const f1359_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1359->then_instructions;

                  body.emit(assign(r1353, add(r1353, body.constant(int(8))), 0x01));

                  body.emit(assign(r1351, lshift(r1351, body.constant(int(8))), 0x01));


               body.instructions = f1359_parent_instructions;
               body.emit(f1359);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r135D = bit_and(r1351, body.constant(4026531840u));
               ir_expression *const r135E = equal(r135D, body.constant(0u));
               ir_if *f135C = new(mem_ctx) ir_if(operand(r135E).val);
               exec_list *const f135C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f135C->then_instructions;

                  body.emit(assign(r1353, add(r1353, body.constant(int(4))), 0x01));

                  body.emit(assign(r1351, lshift(r1351, body.constant(int(4))), 0x01));


               body.instructions = f135C_parent_instructions;
               body.emit(f135C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1360 = bit_and(r1351, body.constant(3221225472u));
               ir_expression *const r1361 = equal(r1360, body.constant(0u));
               ir_if *f135F = new(mem_ctx) ir_if(operand(r1361).val);
               exec_list *const f135F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f135F->then_instructions;

                  body.emit(assign(r1353, add(r1353, body.constant(int(2))), 0x01));

                  body.emit(assign(r1351, lshift(r1351, body.constant(int(2))), 0x01));


               body.instructions = f135F_parent_instructions;
               body.emit(f135F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1363 = bit_and(r1351, body.constant(2147483648u));
               ir_expression *const r1364 = equal(r1363, body.constant(0u));
               ir_if *f1362 = new(mem_ctx) ir_if(operand(r1364).val);
               exec_list *const f1362_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1362->then_instructions;

                  body.emit(assign(r1353, add(r1353, body.constant(int(1))), 0x01));


               body.instructions = f1362_parent_instructions;
               body.emit(f1362);

               /* END IF */

               body.emit(assign(r1352, r1353, 0x01));


            body.instructions = f1354_parent_instructions;
            body.emit(f1354);

            /* END IF */

            ir_variable *const r1365 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r1365, add(r1352, body.constant(int(-8))), 0x01));

            body.emit(assign(r1350, lshift(r1339, r1365), 0x01));

            body.emit(assign(r134F, sub(body.constant(int(1)), r1365), 0x01));

            body.emit(assign(r1336, r1350, 0x01));

            body.emit(assign(r1335, add(r134F, body.constant(int(-1))), 0x01));


         body.instructions = f134C_parent_instructions;
         body.emit(f134C);

         /* END IF */


      body.instructions = f134A_parent_instructions;
      body.emit(f134A);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1366 = new(mem_ctx) ir_if(operand(r1333).val);
      exec_list *const f1366_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1366->then_instructions;

         ir_variable *const r1367 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1367);
         ir_expression *const r1368 = lshift(r133D, body.constant(int(31)));
         ir_expression *const r1369 = add(r1335, body.constant(int(896)));
         ir_expression *const r136A = expr(ir_unop_i2u, r1369);
         ir_expression *const r136B = lshift(r136A, body.constant(int(20)));
         ir_expression *const r136C = add(r1368, r136B);
         ir_expression *const r136D = rshift(r1336, body.constant(int(3)));
         body.emit(assign(r1367, add(r136C, r136D), 0x02));

         ir_expression *const r136E = lshift(r1336, body.constant(int(29)));
         body.emit(assign(r1367, bit_or(r136E, body.constant(0u)), 0x01));

         body.emit(assign(r1334, r1367, 0x03));

         body.emit(assign(r1333, body.constant(false), 0x01));


      body.instructions = f1366_parent_instructions;
      body.emit(f1366);

      /* END IF */


   body.instructions = f133E_parent_instructions;
   body.emit(f133E);

   /* END IF */

   body.emit(ret(r1334));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r136F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r136F);
   ir_variable *const r1370 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1370);
   ir_variable *const r1371 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1371);
   ir_variable *const r1372 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1372);
   ir_variable *const r1373 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1373);
   ir_variable *const r1374 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1374);
   ir_variable *const r1375 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1375);
   ir_variable *const r1376 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1377 = neg(r1371);
   body.emit(assign(r1376, bit_and(r1377, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1379 = equal(r1371, body.constant(int(0)));
   ir_if *f1378 = new(mem_ctx) ir_if(operand(r1379).val);
   exec_list *const f1378_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1378->then_instructions;

      body.emit(assign(r1375, r136F, 0x01));

      body.emit(assign(r1374, r1370, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1378->else_instructions;

      /* IF CONDITION */
      ir_expression *const r137B = less(r1371, body.constant(int(32)));
      ir_if *f137A = new(mem_ctx) ir_if(operand(r137B).val);
      exec_list *const f137A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f137A->then_instructions;

         ir_expression *const r137C = lshift(r136F, r1371);
         ir_expression *const r137D = rshift(r1370, r1376);
         body.emit(assign(r1375, bit_or(r137C, r137D), 0x01));

         body.emit(assign(r1374, lshift(r1370, r1371), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f137A->else_instructions;

         ir_variable *const r137E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1380 = less(r1371, body.constant(int(64)));
         ir_if *f137F = new(mem_ctx) ir_if(operand(r1380).val);
         exec_list *const f137F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f137F->then_instructions;

            ir_expression *const r1381 = add(r1371, body.constant(int(-32)));
            body.emit(assign(r137E, lshift(r1370, r1381), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f137F->else_instructions;

            body.emit(assign(r137E, body.constant(0u), 0x01));


         body.instructions = f137F_parent_instructions;
         body.emit(f137F);

         /* END IF */

         body.emit(assign(r1375, r137E, 0x01));

         body.emit(assign(r1374, body.constant(0u), 0x01));


      body.instructions = f137A_parent_instructions;
      body.emit(f137A);

      /* END IF */


   body.instructions = f1378_parent_instructions;
   body.emit(f1378);

   /* END IF */

   body.emit(assign(r1372, r1375, 0x01));

   body.emit(assign(r1373, r1374, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
uint_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1382 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1382);
   ir_variable *const r1383 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r1385 = equal(r1382, body.constant(0u));
   ir_if *f1384 = new(mem_ctx) ir_if(operand(r1385).val);
   exec_list *const f1384_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1384->then_instructions;

      body.emit(assign(r1383, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1384->else_instructions;

      ir_variable *const r1386 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1386, r1382, 0x01));

      ir_variable *const r1387 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1388 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1388);
      /* IF CONDITION */
      ir_expression *const r138A = equal(r1382, body.constant(0u));
      ir_if *f1389 = new(mem_ctx) ir_if(operand(r138A).val);
      exec_list *const f1389_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1389->then_instructions;

         body.emit(assign(r1387, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1389->else_instructions;

         body.emit(assign(r1388, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r138C = bit_and(r1382, body.constant(4294901760u));
         ir_expression *const r138D = equal(r138C, body.constant(0u));
         ir_if *f138B = new(mem_ctx) ir_if(operand(r138D).val);
         exec_list *const f138B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f138B->then_instructions;

            body.emit(assign(r1388, body.constant(int(16)), 0x01));

            body.emit(assign(r1386, lshift(r1382, body.constant(int(16))), 0x01));


         body.instructions = f138B_parent_instructions;
         body.emit(f138B);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r138F = bit_and(r1386, body.constant(4278190080u));
         ir_expression *const r1390 = equal(r138F, body.constant(0u));
         ir_if *f138E = new(mem_ctx) ir_if(operand(r1390).val);
         exec_list *const f138E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f138E->then_instructions;

            body.emit(assign(r1388, add(r1388, body.constant(int(8))), 0x01));

            body.emit(assign(r1386, lshift(r1386, body.constant(int(8))), 0x01));


         body.instructions = f138E_parent_instructions;
         body.emit(f138E);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1392 = bit_and(r1386, body.constant(4026531840u));
         ir_expression *const r1393 = equal(r1392, body.constant(0u));
         ir_if *f1391 = new(mem_ctx) ir_if(operand(r1393).val);
         exec_list *const f1391_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1391->then_instructions;

            body.emit(assign(r1388, add(r1388, body.constant(int(4))), 0x01));

            body.emit(assign(r1386, lshift(r1386, body.constant(int(4))), 0x01));


         body.instructions = f1391_parent_instructions;
         body.emit(f1391);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1395 = bit_and(r1386, body.constant(3221225472u));
         ir_expression *const r1396 = equal(r1395, body.constant(0u));
         ir_if *f1394 = new(mem_ctx) ir_if(operand(r1396).val);
         exec_list *const f1394_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1394->then_instructions;

            body.emit(assign(r1388, add(r1388, body.constant(int(2))), 0x01));

            body.emit(assign(r1386, lshift(r1386, body.constant(int(2))), 0x01));


         body.instructions = f1394_parent_instructions;
         body.emit(f1394);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1398 = bit_and(r1386, body.constant(2147483648u));
         ir_expression *const r1399 = equal(r1398, body.constant(0u));
         ir_if *f1397 = new(mem_ctx) ir_if(operand(r1399).val);
         exec_list *const f1397_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1397->then_instructions;

            body.emit(assign(r1388, add(r1388, body.constant(int(1))), 0x01));


         body.instructions = f1397_parent_instructions;
         body.emit(f1397);

         /* END IF */

         body.emit(assign(r1387, r1388, 0x01));


      body.instructions = f1389_parent_instructions;
      body.emit(f1389);

      /* END IF */

      ir_variable *const r139A = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r139A, add(r1387, body.constant(int(21))), 0x01));

      ir_variable *const r139B = body.make_temp(glsl_type::uint_type, "a0");
      body.emit(assign(r139B, body.constant(0u), 0x01));

      ir_variable *const r139C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r139C);
      ir_variable *const r139D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r139D);
      ir_variable *const r139E = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r139F = neg(r139A);
      body.emit(assign(r139E, bit_and(r139F, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r13A1 = equal(r139A, body.constant(int(0)));
      ir_if *f13A0 = new(mem_ctx) ir_if(operand(r13A1).val);
      exec_list *const f13A0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f13A0->then_instructions;

         body.emit(assign(r139D, body.constant(0u), 0x01));

         body.emit(assign(r139C, r1382, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f13A0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r13A3 = less(r139A, body.constant(int(32)));
         ir_if *f13A2 = new(mem_ctx) ir_if(operand(r13A3).val);
         exec_list *const f13A2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f13A2->then_instructions;

            ir_expression *const r13A4 = rshift(r1382, r139E);
            body.emit(assign(r139D, bit_or(body.constant(0u), r13A4), 0x01));

            body.emit(assign(r139C, lshift(r1382, r139A), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f13A2->else_instructions;

            ir_variable *const r13A5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r13A7 = less(r139A, body.constant(int(64)));
            ir_if *f13A6 = new(mem_ctx) ir_if(operand(r13A7).val);
            exec_list *const f13A6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f13A6->then_instructions;

               ir_expression *const r13A8 = add(r139A, body.constant(int(-32)));
               body.emit(assign(r13A5, lshift(r1382, r13A8), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f13A6->else_instructions;

               body.emit(assign(r13A5, body.constant(0u), 0x01));


            body.instructions = f13A6_parent_instructions;
            body.emit(f13A6);

            /* END IF */

            body.emit(assign(r139D, r13A5, 0x01));

            body.emit(assign(r139C, body.constant(0u), 0x01));


         body.instructions = f13A2_parent_instructions;
         body.emit(f13A2);

         /* END IF */


      body.instructions = f13A0_parent_instructions;
      body.emit(f13A0);

      /* END IF */

      ir_variable *const r13A9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r13A9);
      ir_expression *const r13AA = sub(body.constant(int(1074)), r139A);
      ir_expression *const r13AB = expr(ir_unop_i2u, r13AA);
      ir_expression *const r13AC = lshift(r13AB, body.constant(int(20)));
      body.emit(assign(r13A9, add(r13AC, r139D), 0x02));

      body.emit(assign(r13A9, r139C, 0x01));

      body.emit(assign(r1383, r13A9, 0x03));


   body.instructions = f1384_parent_instructions;
   body.emit(f1384);

   /* END IF */

   body.emit(ret(r1383));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_uint(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r13AD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r13AD);
   ir_variable *const r13AE = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r13AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r13AF);
   ir_variable *const r13B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r13B0);
   ir_variable *const r13B1 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r13B1, swizzle_x(r13AD), 0x01));

   body.emit(assign(r13B0, r13B1, 0x01));

   ir_variable *const r13B2 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r13B2, bit_and(swizzle_y(r13AD), body.constant(1048575u)), 0x01));

   body.emit(assign(r13AF, r13B2, 0x01));

   ir_variable *const r13B3 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r13B4 = rshift(swizzle_y(r13AD), body.constant(int(20)));
   ir_expression *const r13B5 = bit_and(r13B4, body.constant(2047u));
   body.emit(assign(r13B3, expr(ir_unop_u2i, r13B5), 0x01));

   ir_variable *const r13B6 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r13B6, rshift(swizzle_y(r13AD), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r13B8 = nequal(r13B6, body.constant(0u));
   ir_if *f13B7 = new(mem_ctx) ir_if(operand(r13B8).val);
   exec_list *const f13B7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f13B7->then_instructions;

      body.emit(assign(r13AE, body.constant(0u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f13B7->else_instructions;

      /* IF CONDITION */
      ir_expression *const r13BA = equal(r13B3, body.constant(int(2047)));
      ir_expression *const r13BB = bit_or(r13B2, swizzle_x(r13AD));
      ir_expression *const r13BC = nequal(r13BB, body.constant(0u));
      ir_expression *const r13BD = logic_and(r13BA, r13BC);
      ir_if *f13B9 = new(mem_ctx) ir_if(operand(r13BD).val);
      exec_list *const f13B9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f13B9->then_instructions;

         body.emit(assign(r13AE, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f13B9->else_instructions;

         /* IF CONDITION */
         ir_expression *const r13BF = nequal(r13B3, body.constant(int(0)));
         ir_if *f13BE = new(mem_ctx) ir_if(operand(r13BF).val);
         exec_list *const f13BE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f13BE->then_instructions;

            body.emit(assign(r13AF, bit_or(r13B2, body.constant(1048576u)), 0x01));


         body.instructions = f13BE_parent_instructions;
         body.emit(f13BE);

         /* END IF */

         ir_variable *const r13C0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r13C0, sub(body.constant(int(1063)), r13B3), 0x01));

         /* IF CONDITION */
         ir_expression *const r13C2 = less(body.constant(int(0)), r13C0);
         ir_if *f13C1 = new(mem_ctx) ir_if(operand(r13C2).val);
         exec_list *const f13C1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f13C1->then_instructions;

            ir_variable *const r13C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r13C3);
            ir_variable *const r13C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r13C4);
            ir_variable *const r13C5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r13C6 = neg(r13C0);
            body.emit(assign(r13C5, bit_and(r13C6, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r13C8 = equal(r13C0, body.constant(int(0)));
            ir_if *f13C7 = new(mem_ctx) ir_if(operand(r13C8).val);
            exec_list *const f13C7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f13C7->then_instructions;

               body.emit(assign(r13C3, r13B1, 0x01));

               body.emit(assign(r13C4, r13AF, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f13C7->else_instructions;

               /* IF CONDITION */
               ir_expression *const r13CA = less(r13C0, body.constant(int(32)));
               ir_if *f13C9 = new(mem_ctx) ir_if(operand(r13CA).val);
               exec_list *const f13C9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f13C9->then_instructions;

                  ir_expression *const r13CB = lshift(r13AF, r13C5);
                  ir_expression *const r13CC = rshift(swizzle_x(r13AD), r13C0);
                  ir_expression *const r13CD = bit_or(r13CB, r13CC);
                  ir_expression *const r13CE = lshift(swizzle_x(r13AD), r13C5);
                  ir_expression *const r13CF = nequal(r13CE, body.constant(0u));
                  ir_expression *const r13D0 = expr(ir_unop_b2i, r13CF);
                  ir_expression *const r13D1 = expr(ir_unop_i2u, r13D0);
                  body.emit(assign(r13C3, bit_or(r13CD, r13D1), 0x01));

                  body.emit(assign(r13C4, rshift(r13AF, r13C0), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f13C9->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r13D3 = equal(r13C0, body.constant(int(32)));
                  ir_if *f13D2 = new(mem_ctx) ir_if(operand(r13D3).val);
                  exec_list *const f13D2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f13D2->then_instructions;

                     ir_expression *const r13D4 = nequal(swizzle_x(r13AD), body.constant(0u));
                     ir_expression *const r13D5 = expr(ir_unop_b2i, r13D4);
                     ir_expression *const r13D6 = expr(ir_unop_i2u, r13D5);
                     body.emit(assign(r13C3, bit_or(r13AF, r13D6), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f13D2->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r13D8 = less(r13C0, body.constant(int(64)));
                     ir_if *f13D7 = new(mem_ctx) ir_if(operand(r13D8).val);
                     exec_list *const f13D7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f13D7->then_instructions;

                        ir_expression *const r13D9 = bit_and(r13C0, body.constant(int(31)));
                        ir_expression *const r13DA = rshift(r13AF, r13D9);
                        ir_expression *const r13DB = lshift(r13AF, r13C5);
                        ir_expression *const r13DC = bit_or(r13DB, swizzle_x(r13AD));
                        ir_expression *const r13DD = nequal(r13DC, body.constant(0u));
                        ir_expression *const r13DE = expr(ir_unop_b2i, r13DD);
                        ir_expression *const r13DF = expr(ir_unop_i2u, r13DE);
                        body.emit(assign(r13C3, bit_or(r13DA, r13DF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f13D7->else_instructions;

                        ir_expression *const r13E0 = bit_or(r13AF, swizzle_x(r13AD));
                        ir_expression *const r13E1 = nequal(r13E0, body.constant(0u));
                        ir_expression *const r13E2 = expr(ir_unop_b2i, r13E1);
                        body.emit(assign(r13C3, expr(ir_unop_i2u, r13E2), 0x01));


                     body.instructions = f13D7_parent_instructions;
                     body.emit(f13D7);

                     /* END IF */


                  body.instructions = f13D2_parent_instructions;
                  body.emit(f13D2);

                  /* END IF */

                  body.emit(assign(r13C4, body.constant(0u), 0x01));


               body.instructions = f13C9_parent_instructions;
               body.emit(f13C9);

               /* END IF */


            body.instructions = f13C7_parent_instructions;
            body.emit(f13C7);

            /* END IF */

            body.emit(assign(r13AF, r13C4, 0x01));

            body.emit(assign(r13B0, r13C3, 0x01));


         body.instructions = f13C1_parent_instructions;
         body.emit(f13C1);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r13E4 = bit_and(r13AF, body.constant(4294963200u));
         ir_expression *const r13E5 = nequal(r13E4, body.constant(0u));
         ir_if *f13E3 = new(mem_ctx) ir_if(operand(r13E5).val);
         exec_list *const f13E3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f13E3->then_instructions;

            ir_variable *const r13E6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r13E8 = nequal(r13B6, body.constant(0u));
            ir_if *f13E7 = new(mem_ctx) ir_if(operand(r13E8).val);
            exec_list *const f13E7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f13E7->then_instructions;

               body.emit(assign(r13E6, body.constant(0u), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f13E7->else_instructions;

               body.emit(assign(r13E6, body.constant(4294967295u), 0x01));


            body.instructions = f13E7_parent_instructions;
            body.emit(f13E7);

            /* END IF */

            body.emit(assign(r13AE, r13E6, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f13E3->else_instructions;

            ir_variable *const r13E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r13E9);
            ir_variable *const r13EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r13EA);
            ir_expression *const r13EB = lshift(r13AF, body.constant(int(20)));
            ir_expression *const r13EC = rshift(r13B0, body.constant(int(12)));
            body.emit(assign(r13E9, bit_or(r13EB, r13EC), 0x01));

            body.emit(assign(r13EA, rshift(r13AF, body.constant(int(12))), 0x01));

            /* IF CONDITION */
            ir_expression *const r13EE = nequal(r13B6, body.constant(0u));
            ir_expression *const r13EF = nequal(r13E9, body.constant(0u));
            ir_expression *const r13F0 = logic_and(r13EE, r13EF);
            ir_if *f13ED = new(mem_ctx) ir_if(operand(r13F0).val);
            exec_list *const f13ED_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f13ED->then_instructions;

               ir_variable *const r13F1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r13F3 = nequal(r13B6, body.constant(0u));
               ir_if *f13F2 = new(mem_ctx) ir_if(operand(r13F3).val);
               exec_list *const f13F2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f13F2->then_instructions;

                  body.emit(assign(r13F1, body.constant(0u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f13F2->else_instructions;

                  body.emit(assign(r13F1, body.constant(4294967295u), 0x01));


               body.instructions = f13F2_parent_instructions;
               body.emit(f13F2);

               /* END IF */

               body.emit(assign(r13AE, r13F1, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f13ED->else_instructions;

               body.emit(assign(r13AE, r13E9, 0x01));


            body.instructions = f13ED_parent_instructions;
            body.emit(f13ED);

            /* END IF */


         body.instructions = f13E3_parent_instructions;
         body.emit(f13E3);

         /* END IF */


      body.instructions = f13B9_parent_instructions;
      body.emit(f13B9);

      /* END IF */


   body.instructions = f13B7_parent_instructions;
   body.emit(f13B7);

   /* END IF */

   body.emit(ret(r13AE));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ftrunc64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r13F4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r13F4);
   ir_variable *const r13F5 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r13F6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r13F7 = rshift(swizzle_y(r13F4), body.constant(int(20)));
   ir_expression *const r13F8 = bit_and(r13F7, body.constant(2047u));
   ir_expression *const r13F9 = expr(ir_unop_u2i, r13F8);
   body.emit(assign(r13F6, add(r13F9, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r13FB = less(r13F6, body.constant(int(0)));
   ir_if *f13FA = new(mem_ctx) ir_if(operand(r13FB).val);
   exec_list *const f13FA_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f13FA->then_instructions;

      body.emit(assign(r13F5, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f13FA->else_instructions;

      /* IF CONDITION */
      ir_expression *const r13FD = greater(r13F6, body.constant(int(52)));
      ir_if *f13FC = new(mem_ctx) ir_if(operand(r13FD).val);
      exec_list *const f13FC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f13FC->then_instructions;

         body.emit(assign(r13F5, r13F4, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f13FC->else_instructions;

         ir_variable *const r13FE = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r13FE, sub(body.constant(int(52)), r13F6), 0x01));

         ir_variable *const r13FF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1401 = gequal(r13FE, body.constant(int(32)));
         ir_if *f1400 = new(mem_ctx) ir_if(operand(r1401).val);
         exec_list *const f1400_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1400->then_instructions;

            body.emit(assign(r13FF, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1400->else_instructions;

            body.emit(assign(r13FF, lshift(body.constant(4294967295u), r13FE), 0x01));


         body.instructions = f1400_parent_instructions;
         body.emit(f1400);

         /* END IF */

         ir_variable *const r1402 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1404 = less(r13FE, body.constant(int(33)));
         ir_if *f1403 = new(mem_ctx) ir_if(operand(r1404).val);
         exec_list *const f1403_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1403->then_instructions;

            body.emit(assign(r1402, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1403->else_instructions;

            ir_expression *const r1405 = add(r13FE, body.constant(int(-32)));
            body.emit(assign(r1402, lshift(body.constant(4294967295u), r1405), 0x01));


         body.instructions = f1403_parent_instructions;
         body.emit(f1403);

         /* END IF */

         ir_variable *const r1406 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r1406, bit_and(r13FF, swizzle_x(r13F4)), 0x01));

         body.emit(assign(r1406, bit_and(r1402, swizzle_y(r13F4)), 0x02));

         body.emit(assign(r13F5, r1406, 0x03));


      body.instructions = f13FC_parent_instructions;
      body.emit(f13FC);

      /* END IF */


   body.instructions = f13FA_parent_instructions;
   body.emit(f13FA);

   /* END IF */

   body.emit(ret(r13F5));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffloor64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1407 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1407);
   ir_variable *const r1408 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1409 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r140A = rshift(swizzle_y(r1407), body.constant(int(20)));
   ir_expression *const r140B = bit_and(r140A, body.constant(2047u));
   ir_expression *const r140C = expr(ir_unop_u2i, r140B);
   body.emit(assign(r1409, add(r140C, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r140E = less(r1409, body.constant(int(0)));
   ir_if *f140D = new(mem_ctx) ir_if(operand(r140E).val);
   exec_list *const f140D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f140D->then_instructions;

      body.emit(assign(r1408, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f140D->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1410 = greater(r1409, body.constant(int(52)));
      ir_if *f140F = new(mem_ctx) ir_if(operand(r1410).val);
      exec_list *const f140F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f140F->then_instructions;

         body.emit(assign(r1408, r1407, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f140F->else_instructions;

         ir_variable *const r1411 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1411, sub(body.constant(int(52)), r1409), 0x01));

         ir_variable *const r1412 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1414 = gequal(r1411, body.constant(int(32)));
         ir_if *f1413 = new(mem_ctx) ir_if(operand(r1414).val);
         exec_list *const f1413_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1413->then_instructions;

            body.emit(assign(r1412, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1413->else_instructions;

            body.emit(assign(r1412, lshift(body.constant(4294967295u), r1411), 0x01));


         body.instructions = f1413_parent_instructions;
         body.emit(f1413);

         /* END IF */

         ir_variable *const r1415 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1417 = less(r1411, body.constant(int(33)));
         ir_if *f1416 = new(mem_ctx) ir_if(operand(r1417).val);
         exec_list *const f1416_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1416->then_instructions;

            body.emit(assign(r1415, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1416->else_instructions;

            ir_expression *const r1418 = add(r1411, body.constant(int(-32)));
            body.emit(assign(r1415, lshift(body.constant(4294967295u), r1418), 0x01));


         body.instructions = f1416_parent_instructions;
         body.emit(f1416);

         /* END IF */

         ir_variable *const r1419 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r1419, bit_and(r1412, swizzle_x(r1407)), 0x01));

         body.emit(assign(r1419, bit_and(r1415, swizzle_y(r1407)), 0x02));

         body.emit(assign(r1408, r1419, 0x03));


      body.instructions = f140F_parent_instructions;
      body.emit(f140F);

      /* END IF */


   body.instructions = f140D_parent_instructions;
   body.emit(f140D);

   /* END IF */

   ir_variable *const r141A = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r141B = rshift(swizzle_y(r1407), body.constant(int(31)));
   ir_expression *const r141C = expr(ir_unop_u2i, r141B);
   body.emit(assign(r141A, expr(ir_unop_i2b, r141C), 0x01));

   ir_variable *const r141D = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r141F = expr(ir_unop_logic_not, r141A);
   ir_if *f141E = new(mem_ctx) ir_if(operand(r141F).val);
   exec_list *const f141E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f141E->then_instructions;

      body.emit(assign(r141D, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f141E->else_instructions;

      ir_variable *const r1420 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r1421 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r1421);
      ir_variable *const r1422 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r1422);
      ir_expression *const r1423 = rshift(swizzle_y(r1407), body.constant(int(20)));
      ir_expression *const r1424 = bit_and(r1423, body.constant(2047u));
      ir_expression *const r1425 = expr(ir_unop_u2i, r1424);
      ir_expression *const r1426 = equal(r1425, body.constant(int(2047)));
      ir_expression *const r1427 = bit_and(swizzle_y(r1407), body.constant(1048575u));
      ir_expression *const r1428 = bit_or(r1427, swizzle_x(r1407));
      ir_expression *const r1429 = nequal(r1428, body.constant(0u));
      body.emit(assign(r1422, logic_and(r1426, r1429), 0x01));

      ir_expression *const r142A = rshift(swizzle_y(r1408), body.constant(int(20)));
      ir_expression *const r142B = bit_and(r142A, body.constant(2047u));
      ir_expression *const r142C = expr(ir_unop_u2i, r142B);
      ir_expression *const r142D = equal(r142C, body.constant(int(2047)));
      ir_expression *const r142E = bit_and(swizzle_y(r1408), body.constant(1048575u));
      ir_expression *const r142F = bit_or(r142E, swizzle_x(r1408));
      ir_expression *const r1430 = nequal(r142F, body.constant(0u));
      body.emit(assign(r1421, logic_and(r142D, r1430), 0x01));

      /* IF CONDITION */
      ir_expression *const r1432 = logic_or(r1422, r1421);
      ir_if *f1431 = new(mem_ctx) ir_if(operand(r1432).val);
      exec_list *const f1431_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1431->then_instructions;

         body.emit(assign(r1420, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1431->else_instructions;

         ir_expression *const r1433 = equal(swizzle_x(r1407), swizzle_x(r1408));
         ir_expression *const r1434 = equal(swizzle_y(r1407), swizzle_y(r1408));
         ir_expression *const r1435 = equal(swizzle_x(r1407), body.constant(0u));
         ir_expression *const r1436 = bit_or(swizzle_y(r1407), swizzle_y(r1408));
         ir_expression *const r1437 = lshift(r1436, body.constant(int(1)));
         ir_expression *const r1438 = equal(r1437, body.constant(0u));
         ir_expression *const r1439 = logic_and(r1435, r1438);
         ir_expression *const r143A = logic_or(r1434, r1439);
         body.emit(assign(r1420, logic_and(r1433, r143A), 0x01));


      body.instructions = f1431_parent_instructions;
      body.emit(f1431);

      /* END IF */

      body.emit(assign(r141D, r1420, 0x01));


   body.instructions = f141E_parent_instructions;
   body.emit(f141E);

   /* END IF */

   ir_variable *const r143B = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f143C = new(mem_ctx) ir_if(operand(r141D).val);
   exec_list *const f143C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f143C->then_instructions;

      body.emit(assign(r143B, r1408, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f143C->else_instructions;

      ir_variable *const r143D = body.make_temp(glsl_type::uvec2_type, "a");
      body.emit(assign(r143D, body.constant(0u), 0x01));

      body.emit(assign(r143D, body.constant(3220176896u), 0x02));

      ir_variable *const r143E = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r143F = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r143F, rshift(swizzle_y(r1408), body.constant(int(31))), 0x01));

      ir_variable *const r1440 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1440, body.constant(1u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1442 = equal(r143F, body.constant(1u));
      ir_if *f1441 = new(mem_ctx) ir_if(operand(r1442).val);
      exec_list *const f1441_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1441->then_instructions;

         ir_variable *const r1443 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r1443, body.constant(true), 0x01));

         ir_variable *const r1444 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r1445 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r1445);
         ir_variable *const r1446 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r1446);
         ir_variable *const r1447 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r1447);
         ir_variable *const r1448 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r1448);
         ir_variable *const r1449 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r1449);
         ir_variable *const r144A = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r144A);
         ir_variable *const r144B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r144B);
         ir_variable *const r144C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r144C);
         body.emit(assign(r144C, body.constant(0u), 0x01));

         body.emit(assign(r144B, body.constant(0u), 0x01));

         ir_variable *const r144D = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r144D, swizzle_x(r1408), 0x01));

         body.emit(assign(r1449, r144D, 0x01));

         ir_variable *const r144E = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r144E, bit_and(swizzle_y(r1408), body.constant(1048575u)), 0x01));

         body.emit(assign(r1448, r144E, 0x01));

         ir_variable *const r144F = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r144F, body.constant(0u), 0x01));

         body.emit(assign(r1447, r144F, 0x01));

         ir_variable *const r1450 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r1450, body.constant(0u), 0x01));

         body.emit(assign(r1446, r1450, 0x01));

         ir_variable *const r1451 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r1452 = rshift(swizzle_y(r1408), body.constant(int(20)));
         ir_expression *const r1453 = bit_and(r1452, body.constant(2047u));
         body.emit(assign(r1451, expr(ir_unop_u2i, r1453), 0x01));

         ir_variable *const r1454 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r1454, body.constant(int(1023)), 0x01));

         ir_variable *const r1455 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1455, add(r1451, body.constant(int(-1023))), 0x01));

         body.emit(assign(r1445, r1455, 0x01));

         /* IF CONDITION */
         ir_expression *const r1457 = less(body.constant(int(0)), r1455);
         ir_if *f1456 = new(mem_ctx) ir_if(operand(r1457).val);
         exec_list *const f1456_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1456->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1459 = equal(r1451, body.constant(int(2047)));
            ir_if *f1458 = new(mem_ctx) ir_if(operand(r1459).val);
            exec_list *const f1458_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1458->then_instructions;

               /* IF CONDITION */
               ir_expression *const r145B = bit_or(r144E, swizzle_x(r1408));
               ir_expression *const r145C = nequal(r145B, body.constant(0u));
               ir_if *f145A = new(mem_ctx) ir_if(operand(r145C).val);
               exec_list *const f145A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f145A->then_instructions;

                  ir_variable *const r145D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r145D, swizzle_x(r1408), 0x01));

                  ir_variable *const r145E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r145E, body.constant(0u), 0x01));

                  ir_variable *const r145F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r1460 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r1461 = rshift(swizzle_y(r1408), body.constant(int(19)));
                  ir_expression *const r1462 = bit_and(r1461, body.constant(4095u));
                  ir_expression *const r1463 = equal(r1462, body.constant(4094u));
                  ir_expression *const r1464 = nequal(swizzle_x(r1408), body.constant(0u));
                  ir_expression *const r1465 = bit_and(swizzle_y(r1408), body.constant(524287u));
                  ir_expression *const r1466 = nequal(r1465, body.constant(0u));
                  ir_expression *const r1467 = logic_or(r1464, r1466);
                  body.emit(assign(r1460, logic_and(r1463, r1467), 0x01));

                  ir_variable *const r1468 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  body.emit(assign(r1468, body.constant(false), 0x01));

                  body.emit(assign(r145D, bit_or(swizzle_y(r1408), body.constant(524288u)), 0x02));

                  body.emit(assign(r145E, body.constant(3220701184u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r146A = lshift(swizzle_y(r1408), body.constant(int(1)));
                  ir_expression *const r146B = lequal(body.constant(4292870144u), r146A);
                  ir_expression *const r146C = nequal(swizzle_x(r1408), body.constant(0u));
                  ir_expression *const r146D = bit_and(swizzle_y(r1408), body.constant(1048575u));
                  ir_expression *const r146E = nequal(r146D, body.constant(0u));
                  ir_expression *const r146F = logic_or(r146C, r146E);
                  ir_expression *const r1470 = logic_and(r146B, r146F);
                  ir_if *f1469 = new(mem_ctx) ir_if(operand(r1470).val);
                  exec_list *const f1469_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1469->then_instructions;

                     ir_variable *const r1471 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_constant *const r1473 = body.constant(false);
                     ir_if *f1472 = new(mem_ctx) ir_if(operand(r1473).val);
                     exec_list *const f1472_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1472->then_instructions;

                        body.emit(assign(r1471, r145E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1472->else_instructions;

                        body.emit(assign(r1471, r145D, 0x03));


                     body.instructions = f1472_parent_instructions;
                     body.emit(f1472);

                     /* END IF */

                     body.emit(assign(r145F, r1471, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1469->else_instructions;

                     body.emit(assign(r145F, r145E, 0x03));


                  body.instructions = f1469_parent_instructions;
                  body.emit(f1469);

                  /* END IF */

                  body.emit(assign(r1444, r145F, 0x03));

                  body.emit(assign(r1443, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f145A->else_instructions;

                  body.emit(assign(r1444, r1408, 0x03));

                  body.emit(assign(r1443, body.constant(false), 0x01));


               body.instructions = f145A_parent_instructions;
               body.emit(f145A);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1458->else_instructions;

               /* IF CONDITION */
               ir_constant *const r1475 = body.constant(false);
               ir_if *f1474 = new(mem_ctx) ir_if(operand(r1475).val);
               exec_list *const f1474_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1474->then_instructions;

                  body.emit(assign(r1445, add(r1455, body.constant(int(-1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1474->else_instructions;

                  body.emit(assign(r1446, body.constant(1048576u), 0x01));


               body.instructions = f1474_parent_instructions;
               body.emit(f1474);

               /* END IF */

               ir_variable *const r1476 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r1476, body.constant(0u), 0x01));

               ir_variable *const r1477 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r1477);
               ir_variable *const r1478 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1478);
               ir_variable *const r1479 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1479);
               ir_variable *const r147A = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r147B = neg(r1445);
               body.emit(assign(r147A, bit_and(r147B, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r147D = equal(r1445, body.constant(int(0)));
               ir_if *f147C = new(mem_ctx) ir_if(operand(r147D).val);
               exec_list *const f147C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f147C->then_instructions;

                  body.emit(assign(r1477, r1476, 0x01));

                  body.emit(assign(r1478, r144F, 0x01));

                  body.emit(assign(r1479, r1446, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f147C->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r147F = less(r1445, body.constant(int(32)));
                  ir_if *f147E = new(mem_ctx) ir_if(operand(r147F).val);
                  exec_list *const f147E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f147E->then_instructions;

                     body.emit(assign(r1477, body.constant(0u), 0x01));

                     ir_expression *const r1480 = lshift(r1446, r147A);
                     body.emit(assign(r1478, bit_or(r1480, body.constant(0u)), 0x01));

                     body.emit(assign(r1479, rshift(r1446, r1445), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f147E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1482 = equal(r1445, body.constant(int(32)));
                     ir_if *f1481 = new(mem_ctx) ir_if(operand(r1482).val);
                     exec_list *const f1481_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1481->then_instructions;

                        body.emit(assign(r1477, r144F, 0x01));

                        body.emit(assign(r1478, r1446, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1481->else_instructions;

                        body.emit(assign(r1476, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1484 = less(r1445, body.constant(int(64)));
                        ir_if *f1483 = new(mem_ctx) ir_if(operand(r1484).val);
                        exec_list *const f1483_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1483->then_instructions;

                           body.emit(assign(r1477, lshift(r1446, r147A), 0x01));

                           ir_expression *const r1485 = bit_and(r1445, body.constant(int(31)));
                           body.emit(assign(r1478, rshift(r1446, r1485), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1483->else_instructions;

                           ir_variable *const r1486 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1488 = equal(r1445, body.constant(int(64)));
                           ir_if *f1487 = new(mem_ctx) ir_if(operand(r1488).val);
                           exec_list *const f1487_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1487->then_instructions;

                              body.emit(assign(r1486, r1446, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1487->else_instructions;

                              ir_expression *const r1489 = nequal(r1446, body.constant(0u));
                              ir_expression *const r148A = expr(ir_unop_b2i, r1489);
                              body.emit(assign(r1486, expr(ir_unop_i2u, r148A), 0x01));


                           body.instructions = f1487_parent_instructions;
                           body.emit(f1487);

                           /* END IF */

                           body.emit(assign(r1477, r1486, 0x01));

                           body.emit(assign(r1478, body.constant(0u), 0x01));


                        body.instructions = f1483_parent_instructions;
                        body.emit(f1483);

                        /* END IF */


                     body.instructions = f1481_parent_instructions;
                     body.emit(f1481);

                     /* END IF */

                     body.emit(assign(r1479, body.constant(0u), 0x01));


                  body.instructions = f147E_parent_instructions;
                  body.emit(f147E);

                  /* END IF */

                  ir_expression *const r148B = nequal(r1476, body.constant(0u));
                  ir_expression *const r148C = expr(ir_unop_b2i, r148B);
                  ir_expression *const r148D = expr(ir_unop_i2u, r148C);
                  body.emit(assign(r1477, bit_or(r1477, r148D), 0x01));


               body.instructions = f147C_parent_instructions;
               body.emit(f147C);

               /* END IF */

               body.emit(assign(r1446, r1479, 0x01));

               body.emit(assign(r1447, r1478, 0x01));

               body.emit(assign(r144B, r1477, 0x01));

               body.emit(assign(r144A, r1451, 0x01));


            body.instructions = f1458_parent_instructions;
            body.emit(f1458);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1456->else_instructions;

            /* IF CONDITION */
            ir_expression *const r148F = less(r1445, body.constant(int(0)));
            ir_if *f148E = new(mem_ctx) ir_if(operand(r148F).val);
            exec_list *const f148E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f148E->then_instructions;

               /* IF CONDITION */
               ir_constant *const r1491 = body.constant(false);
               ir_if *f1490 = new(mem_ctx) ir_if(operand(r1491).val);
               exec_list *const f1490_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1490->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1493 = bit_or(r1446, r1447);
                  ir_expression *const r1494 = nequal(r1493, body.constant(0u));
                  ir_if *f1492 = new(mem_ctx) ir_if(operand(r1494).val);
                  exec_list *const f1492_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1492->then_instructions;

                     ir_variable *const r1495 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1495, swizzle_x(r1408), 0x01));

                     ir_variable *const r1496 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1496, body.constant(0u), 0x01));

                     ir_variable *const r1497 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1498 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r1499 = rshift(swizzle_y(r1408), body.constant(int(19)));
                     ir_expression *const r149A = bit_and(r1499, body.constant(4095u));
                     ir_expression *const r149B = equal(r149A, body.constant(4094u));
                     ir_expression *const r149C = nequal(swizzle_x(r1408), body.constant(0u));
                     ir_expression *const r149D = bit_and(swizzle_y(r1408), body.constant(524287u));
                     ir_expression *const r149E = nequal(r149D, body.constant(0u));
                     ir_expression *const r149F = logic_or(r149C, r149E);
                     body.emit(assign(r1498, logic_and(r149B, r149F), 0x01));

                     ir_variable *const r14A0 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r14A0, body.constant(false), 0x01));

                     body.emit(assign(r1495, bit_or(swizzle_y(r1408), body.constant(524288u)), 0x02));

                     body.emit(assign(r1496, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r14A2 = lshift(swizzle_y(r1408), body.constant(int(1)));
                     ir_expression *const r14A3 = lequal(body.constant(4292870144u), r14A2);
                     ir_expression *const r14A4 = nequal(swizzle_x(r1408), body.constant(0u));
                     ir_expression *const r14A5 = bit_and(swizzle_y(r1408), body.constant(1048575u));
                     ir_expression *const r14A6 = nequal(r14A5, body.constant(0u));
                     ir_expression *const r14A7 = logic_or(r14A4, r14A6);
                     ir_expression *const r14A8 = logic_and(r14A3, r14A7);
                     ir_if *f14A1 = new(mem_ctx) ir_if(operand(r14A8).val);
                     exec_list *const f14A1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14A1->then_instructions;

                        ir_variable *const r14A9 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r14AB = body.constant(false);
                        ir_if *f14AA = new(mem_ctx) ir_if(operand(r14AB).val);
                        exec_list *const f14AA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f14AA->then_instructions;

                           body.emit(assign(r14A9, r1496, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f14AA->else_instructions;

                           body.emit(assign(r14A9, r1495, 0x03));


                        body.instructions = f14AA_parent_instructions;
                        body.emit(f14AA);

                        /* END IF */

                        body.emit(assign(r1497, r14A9, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f14A1->else_instructions;

                        body.emit(assign(r1497, r1496, 0x03));


                     body.instructions = f14A1_parent_instructions;
                     body.emit(f14A1);

                     /* END IF */

                     body.emit(assign(r1444, r1497, 0x03));

                     body.emit(assign(r1443, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1492->else_instructions;

                     ir_variable *const r14AC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r14AC);
                     ir_expression *const r14AD = lshift(r143F, body.constant(int(31)));
                     body.emit(assign(r14AC, add(r14AD, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r14AC, body.constant(0u), 0x01));

                     body.emit(assign(r1444, r14AC, 0x03));

                     body.emit(assign(r1443, body.constant(false), 0x01));


                  body.instructions = f1492_parent_instructions;
                  body.emit(f1492);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1490->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r14AF = equal(r1451, body.constant(int(0)));
                  ir_if *f14AE = new(mem_ctx) ir_if(operand(r14AF).val);
                  exec_list *const f14AE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14AE->then_instructions;

                     body.emit(assign(r1445, add(r1445, body.constant(int(1))), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14AE->else_instructions;

                     body.emit(assign(r1448, bit_or(r144E, body.constant(1048576u)), 0x01));


                  body.instructions = f14AE_parent_instructions;
                  body.emit(f14AE);

                  /* END IF */

                  ir_variable *const r14B0 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r14B0, body.constant(0u), 0x01));

                  ir_variable *const r14B1 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r14B1, neg(r1445), 0x01));

                  ir_variable *const r14B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r14B2);
                  ir_variable *const r14B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r14B3);
                  ir_variable *const r14B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r14B4);
                  ir_variable *const r14B5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r14B6 = neg(r14B1);
                  body.emit(assign(r14B5, bit_and(r14B6, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r14B8 = equal(r14B1, body.constant(int(0)));
                  ir_if *f14B7 = new(mem_ctx) ir_if(operand(r14B8).val);
                  exec_list *const f14B7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14B7->then_instructions;

                     body.emit(assign(r14B2, r14B0, 0x01));

                     body.emit(assign(r14B3, r144D, 0x01));

                     body.emit(assign(r14B4, r1448, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14B7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r14BA = less(r14B1, body.constant(int(32)));
                     ir_if *f14B9 = new(mem_ctx) ir_if(operand(r14BA).val);
                     exec_list *const f14B9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14B9->then_instructions;

                        body.emit(assign(r14B2, lshift(swizzle_x(r1408), r14B5), 0x01));

                        ir_expression *const r14BB = lshift(r1448, r14B5);
                        ir_expression *const r14BC = rshift(swizzle_x(r1408), r14B1);
                        body.emit(assign(r14B3, bit_or(r14BB, r14BC), 0x01));

                        body.emit(assign(r14B4, rshift(r1448, r14B1), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f14B9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r14BE = equal(r14B1, body.constant(int(32)));
                        ir_if *f14BD = new(mem_ctx) ir_if(operand(r14BE).val);
                        exec_list *const f14BD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f14BD->then_instructions;

                           body.emit(assign(r14B2, r144D, 0x01));

                           body.emit(assign(r14B3, r1448, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f14BD->else_instructions;

                           body.emit(assign(r14B0, bit_or(body.constant(0u), swizzle_x(r1408)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r14C0 = less(r14B1, body.constant(int(64)));
                           ir_if *f14BF = new(mem_ctx) ir_if(operand(r14C0).val);
                           exec_list *const f14BF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f14BF->then_instructions;

                              body.emit(assign(r14B2, lshift(r1448, r14B5), 0x01));

                              ir_expression *const r14C1 = bit_and(r14B1, body.constant(int(31)));
                              body.emit(assign(r14B3, rshift(r1448, r14C1), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f14BF->else_instructions;

                              ir_variable *const r14C2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r14C4 = equal(r14B1, body.constant(int(64)));
                              ir_if *f14C3 = new(mem_ctx) ir_if(operand(r14C4).val);
                              exec_list *const f14C3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f14C3->then_instructions;

                                 body.emit(assign(r14C2, r1448, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f14C3->else_instructions;

                                 ir_expression *const r14C5 = nequal(r1448, body.constant(0u));
                                 ir_expression *const r14C6 = expr(ir_unop_b2i, r14C5);
                                 body.emit(assign(r14C2, expr(ir_unop_i2u, r14C6), 0x01));


                              body.instructions = f14C3_parent_instructions;
                              body.emit(f14C3);

                              /* END IF */

                              body.emit(assign(r14B2, r14C2, 0x01));

                              body.emit(assign(r14B3, body.constant(0u), 0x01));


                           body.instructions = f14BF_parent_instructions;
                           body.emit(f14BF);

                           /* END IF */


                        body.instructions = f14BD_parent_instructions;
                        body.emit(f14BD);

                        /* END IF */

                        body.emit(assign(r14B4, body.constant(0u), 0x01));


                     body.instructions = f14B9_parent_instructions;
                     body.emit(f14B9);

                     /* END IF */

                     ir_expression *const r14C7 = nequal(r14B0, body.constant(0u));
                     ir_expression *const r14C8 = expr(ir_unop_b2i, r14C7);
                     ir_expression *const r14C9 = expr(ir_unop_i2u, r14C8);
                     body.emit(assign(r14B2, bit_or(r14B2, r14C9), 0x01));


                  body.instructions = f14B7_parent_instructions;
                  body.emit(f14B7);

                  /* END IF */

                  body.emit(assign(r1448, r14B4, 0x01));

                  body.emit(assign(r1449, r14B3, 0x01));

                  body.emit(assign(r144B, r14B2, 0x01));

                  body.emit(assign(r144A, r1454, 0x01));


               body.instructions = f1490_parent_instructions;
               body.emit(f1490);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f148E->else_instructions;

               /* IF CONDITION */
               ir_expression *const r14CB = equal(r1451, body.constant(int(2047)));
               ir_if *f14CA = new(mem_ctx) ir_if(operand(r14CB).val);
               exec_list *const f14CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14CA->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r14CD = bit_or(r1448, r1449);
                  ir_expression *const r14CE = bit_or(r1446, r1447);
                  ir_expression *const r14CF = bit_or(r14CD, r14CE);
                  ir_expression *const r14D0 = nequal(r14CF, body.constant(0u));
                  ir_if *f14CC = new(mem_ctx) ir_if(operand(r14D0).val);
                  exec_list *const f14CC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14CC->then_instructions;

                     ir_variable *const r14D1 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r14D1, swizzle_x(r1408), 0x01));

                     ir_variable *const r14D2 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r14D2, body.constant(0u), 0x01));

                     ir_variable *const r14D3 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r14D4 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r14D5 = rshift(swizzle_y(r1408), body.constant(int(19)));
                     ir_expression *const r14D6 = bit_and(r14D5, body.constant(4095u));
                     ir_expression *const r14D7 = equal(r14D6, body.constant(4094u));
                     ir_expression *const r14D8 = nequal(swizzle_x(r1408), body.constant(0u));
                     ir_expression *const r14D9 = bit_and(swizzle_y(r1408), body.constant(524287u));
                     ir_expression *const r14DA = nequal(r14D9, body.constant(0u));
                     ir_expression *const r14DB = logic_or(r14D8, r14DA);
                     body.emit(assign(r14D4, logic_and(r14D7, r14DB), 0x01));

                     ir_variable *const r14DC = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r14DC, body.constant(false), 0x01));

                     body.emit(assign(r14D1, bit_or(swizzle_y(r1408), body.constant(524288u)), 0x02));

                     body.emit(assign(r14D2, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r14DE = lshift(swizzle_y(r1408), body.constant(int(1)));
                     ir_expression *const r14DF = lequal(body.constant(4292870144u), r14DE);
                     ir_expression *const r14E0 = nequal(swizzle_x(r1408), body.constant(0u));
                     ir_expression *const r14E1 = bit_and(swizzle_y(r1408), body.constant(1048575u));
                     ir_expression *const r14E2 = nequal(r14E1, body.constant(0u));
                     ir_expression *const r14E3 = logic_or(r14E0, r14E2);
                     ir_expression *const r14E4 = logic_and(r14DF, r14E3);
                     ir_if *f14DD = new(mem_ctx) ir_if(operand(r14E4).val);
                     exec_list *const f14DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14DD->then_instructions;

                        ir_variable *const r14E5 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r14E7 = body.constant(false);
                        ir_if *f14E6 = new(mem_ctx) ir_if(operand(r14E7).val);
                        exec_list *const f14E6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f14E6->then_instructions;

                           body.emit(assign(r14E5, r14D2, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f14E6->else_instructions;

                           body.emit(assign(r14E5, r14D1, 0x03));


                        body.instructions = f14E6_parent_instructions;
                        body.emit(f14E6);

                        /* END IF */

                        body.emit(assign(r14D3, r14E5, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f14DD->else_instructions;

                        body.emit(assign(r14D3, r14D2, 0x03));


                     body.instructions = f14DD_parent_instructions;
                     body.emit(f14DD);

                     /* END IF */

                     body.emit(assign(r1444, r14D3, 0x03));

                     body.emit(assign(r1443, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14CC->else_instructions;

                     body.emit(assign(r1444, r1408, 0x03));

                     body.emit(assign(r1443, body.constant(false), 0x01));


                  body.instructions = f14CC_parent_instructions;
                  body.emit(f14CC);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14CA->else_instructions;

                  ir_variable *const r14E8 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r14E9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r14E9, add(r1449, r1447), 0x01));

                  ir_expression *const r14EA = add(r1448, r1446);
                  ir_expression *const r14EB = less(r14E9, r1449);
                  ir_expression *const r14EC = expr(ir_unop_b2i, r14EB);
                  ir_expression *const r14ED = expr(ir_unop_i2u, r14EC);
                  body.emit(assign(r14E8, add(r14EA, r14ED), 0x01));

                  body.emit(assign(r144C, r14E8, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r14EF = equal(r1451, body.constant(int(0)));
                  ir_if *f14EE = new(mem_ctx) ir_if(operand(r14EF).val);
                  exec_list *const f14EE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14EE->then_instructions;

                     ir_variable *const r14F0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r14F0);
                     ir_expression *const r14F1 = lshift(r143F, body.constant(int(31)));
                     body.emit(assign(r14F0, add(r14F1, r14E8), 0x02));

                     body.emit(assign(r14F0, r14E9, 0x01));

                     body.emit(assign(r1444, r14F0, 0x03));

                     body.emit(assign(r1443, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14EE->else_instructions;

                     body.emit(assign(r144C, bit_or(r14E8, body.constant(2097152u)), 0x01));

                     body.emit(assign(r144A, r1451, 0x01));

                     ir_variable *const r14F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r14F2);
                     ir_variable *const r14F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r14F3);
                     ir_variable *const r14F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r14F4);
                     body.emit(assign(r14F2, lshift(r14E9, body.constant(int(31))), 0x01));

                     ir_expression *const r14F5 = lshift(r144C, body.constant(int(31)));
                     ir_expression *const r14F6 = rshift(r14E9, body.constant(int(1)));
                     body.emit(assign(r14F3, bit_or(r14F5, r14F6), 0x01));

                     body.emit(assign(r14F4, rshift(r144C, body.constant(int(1))), 0x01));

                     body.emit(assign(r14F2, bit_or(r14F2, body.constant(0u)), 0x01));

                     body.emit(assign(r144C, r14F4, 0x01));

                     body.emit(assign(r144B, r14F2, 0x01));

                     ir_variable *const r14F7 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r14F7, r1451, 0x01));

                     ir_variable *const r14F8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r14F8, r14F4, 0x01));

                     ir_variable *const r14F9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r14F9, r14F3, 0x01));

                     ir_variable *const r14FA = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r14FA, r14F2, 0x01));

                     ir_variable *const r14FB = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r14FB, body.constant(true), 0x01));

                     ir_variable *const r14FC = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r14FD = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r14FD);
                     ir_expression *const r14FE = expr(ir_unop_u2i, r14F2);
                     body.emit(assign(r14FD, less(r14FE, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1500 = lequal(body.constant(int(2045)), r1451);
                     ir_if *f14FF = new(mem_ctx) ir_if(operand(r1500).val);
                     exec_list *const f14FF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14FF->then_instructions;

                        ir_variable *const r1501 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1503 = less(body.constant(int(2045)), r1451);
                        ir_if *f1502 = new(mem_ctx) ir_if(operand(r1503).val);
                        exec_list *const f1502_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1502->then_instructions;

                           body.emit(assign(r1501, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1502->else_instructions;

                           ir_variable *const r1504 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1506 = equal(r1451, body.constant(int(2045)));
                           ir_if *f1505 = new(mem_ctx) ir_if(operand(r1506).val);
                           exec_list *const f1505_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1505->then_instructions;

                              ir_expression *const r1507 = equal(body.constant(2097151u), r14F4);
                              ir_expression *const r1508 = equal(body.constant(4294967295u), r14F3);
                              body.emit(assign(r1504, logic_and(r1507, r1508), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1505->else_instructions;

                              body.emit(assign(r1504, body.constant(false), 0x01));


                           body.instructions = f1505_parent_instructions;
                           body.emit(f1505);

                           /* END IF */

                           body.emit(assign(r1501, logic_and(r1504, r14FD), 0x01));


                        body.instructions = f1502_parent_instructions;
                        body.emit(f1502);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1509 = new(mem_ctx) ir_if(operand(r1501).val);
                        exec_list *const f1509_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1509->then_instructions;

                           ir_variable *const r150A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r150A);
                           ir_expression *const r150B = lshift(r143F, body.constant(int(31)));
                           body.emit(assign(r150A, add(r150B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r150A, body.constant(0u), 0x01));

                           body.emit(assign(r14FC, r150A, 0x03));

                           body.emit(assign(r14FB, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1509->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r150D = less(r1451, body.constant(int(0)));
                           ir_if *f150C = new(mem_ctx) ir_if(operand(r150D).val);
                           exec_list *const f150C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f150C->then_instructions;

                              ir_variable *const r150E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r150E, r14F2, 0x01));

                              ir_variable *const r150F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r150F, neg(r1451), 0x01));

                              ir_variable *const r1510 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1510);
                              ir_variable *const r1511 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1511);
                              ir_variable *const r1512 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1512);
                              ir_variable *const r1513 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1514 = neg(r150F);
                              body.emit(assign(r1513, bit_and(r1514, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1516 = equal(r150F, body.constant(int(0)));
                              ir_if *f1515 = new(mem_ctx) ir_if(operand(r1516).val);
                              exec_list *const f1515_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1515->then_instructions;

                                 body.emit(assign(r1510, r14F2, 0x01));

                                 body.emit(assign(r1511, r14F3, 0x01));

                                 body.emit(assign(r1512, r14F4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1515->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1518 = less(r150F, body.constant(int(32)));
                                 ir_if *f1517 = new(mem_ctx) ir_if(operand(r1518).val);
                                 exec_list *const f1517_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1517->then_instructions;

                                    body.emit(assign(r1510, lshift(r14F3, r1513), 0x01));

                                    ir_expression *const r1519 = lshift(r14F4, r1513);
                                    ir_expression *const r151A = rshift(r14F3, r150F);
                                    body.emit(assign(r1511, bit_or(r1519, r151A), 0x01));

                                    body.emit(assign(r1512, rshift(r14F4, r150F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1517->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r151C = equal(r150F, body.constant(int(32)));
                                    ir_if *f151B = new(mem_ctx) ir_if(operand(r151C).val);
                                    exec_list *const f151B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f151B->then_instructions;

                                       body.emit(assign(r1510, r14F3, 0x01));

                                       body.emit(assign(r1511, r14F4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f151B->else_instructions;

                                       body.emit(assign(r150E, bit_or(r14F2, r14F3), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r151E = less(r150F, body.constant(int(64)));
                                       ir_if *f151D = new(mem_ctx) ir_if(operand(r151E).val);
                                       exec_list *const f151D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f151D->then_instructions;

                                          body.emit(assign(r1510, lshift(r14F4, r1513), 0x01));

                                          ir_expression *const r151F = bit_and(r150F, body.constant(int(31)));
                                          body.emit(assign(r1511, rshift(r14F4, r151F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f151D->else_instructions;

                                          ir_variable *const r1520 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1522 = equal(r150F, body.constant(int(64)));
                                          ir_if *f1521 = new(mem_ctx) ir_if(operand(r1522).val);
                                          exec_list *const f1521_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1521->then_instructions;

                                             body.emit(assign(r1520, r14F4, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1521->else_instructions;

                                             ir_expression *const r1523 = nequal(r14F4, body.constant(0u));
                                             ir_expression *const r1524 = expr(ir_unop_b2i, r1523);
                                             body.emit(assign(r1520, expr(ir_unop_i2u, r1524), 0x01));


                                          body.instructions = f1521_parent_instructions;
                                          body.emit(f1521);

                                          /* END IF */

                                          body.emit(assign(r1510, r1520, 0x01));

                                          body.emit(assign(r1511, body.constant(0u), 0x01));


                                       body.instructions = f151D_parent_instructions;
                                       body.emit(f151D);

                                       /* END IF */


                                    body.instructions = f151B_parent_instructions;
                                    body.emit(f151B);

                                    /* END IF */

                                    body.emit(assign(r1512, body.constant(0u), 0x01));


                                 body.instructions = f1517_parent_instructions;
                                 body.emit(f1517);

                                 /* END IF */

                                 ir_expression *const r1525 = nequal(r150E, body.constant(0u));
                                 ir_expression *const r1526 = expr(ir_unop_b2i, r1525);
                                 ir_expression *const r1527 = expr(ir_unop_i2u, r1526);
                                 body.emit(assign(r1510, bit_or(r1510, r1527), 0x01));


                              body.instructions = f1515_parent_instructions;
                              body.emit(f1515);

                              /* END IF */

                              body.emit(assign(r14F8, r1512, 0x01));

                              body.emit(assign(r14F9, r1511, 0x01));

                              body.emit(assign(r14FA, r1510, 0x01));

                              body.emit(assign(r14F7, body.constant(int(0)), 0x01));

                              body.emit(assign(r14FD, less(r1510, body.constant(0u)), 0x01));


                           body.instructions = f150C_parent_instructions;
                           body.emit(f150C);

                           /* END IF */


                        body.instructions = f1509_parent_instructions;
                        body.emit(f1509);

                        /* END IF */


                     body.instructions = f14FF_parent_instructions;
                     body.emit(f14FF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f1528 = new(mem_ctx) ir_if(operand(r14FB).val);
                     exec_list *const f1528_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1528->then_instructions;

                        /* IF CONDITION */
                        ir_if *f1529 = new(mem_ctx) ir_if(operand(r14FD).val);
                        exec_list *const f1529_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1529->then_instructions;

                           ir_variable *const r152A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r152A, add(r14F9, body.constant(1u)), 0x01));

                           ir_expression *const r152B = less(r152A, r14F9);
                           ir_expression *const r152C = expr(ir_unop_b2i, r152B);
                           ir_expression *const r152D = expr(ir_unop_i2u, r152C);
                           body.emit(assign(r14F8, add(r14F8, r152D), 0x01));

                           ir_expression *const r152E = equal(r14FA, body.constant(0u));
                           ir_expression *const r152F = expr(ir_unop_b2i, r152E);
                           ir_expression *const r1530 = expr(ir_unop_i2u, r152F);
                           ir_expression *const r1531 = add(r14FA, r1530);
                           ir_expression *const r1532 = bit_and(r1531, body.constant(1u));
                           ir_expression *const r1533 = expr(ir_unop_bit_not, r1532);
                           body.emit(assign(r14F9, bit_and(r152A, r1533), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1529->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1535 = bit_or(r14F8, r14F9);
                           ir_expression *const r1536 = equal(r1535, body.constant(0u));
                           ir_if *f1534 = new(mem_ctx) ir_if(operand(r1536).val);
                           exec_list *const f1534_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1534->then_instructions;

                              body.emit(assign(r14F7, body.constant(int(0)), 0x01));


                           body.instructions = f1534_parent_instructions;
                           body.emit(f1534);

                           /* END IF */


                        body.instructions = f1529_parent_instructions;
                        body.emit(f1529);

                        /* END IF */

                        ir_variable *const r1537 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r1537);
                        ir_expression *const r1538 = lshift(r143F, body.constant(int(31)));
                        ir_expression *const r1539 = expr(ir_unop_i2u, r14F7);
                        ir_expression *const r153A = lshift(r1539, body.constant(int(20)));
                        ir_expression *const r153B = add(r1538, r153A);
                        body.emit(assign(r1537, add(r153B, r14F8), 0x02));

                        body.emit(assign(r1537, r14F9, 0x01));

                        body.emit(assign(r14FC, r1537, 0x03));

                        body.emit(assign(r14FB, body.constant(false), 0x01));


                     body.instructions = f1528_parent_instructions;
                     body.emit(f1528);

                     /* END IF */

                     body.emit(assign(r1444, r14FC, 0x03));

                     body.emit(assign(r1443, body.constant(false), 0x01));


                  body.instructions = f14EE_parent_instructions;
                  body.emit(f14EE);

                  /* END IF */


               body.instructions = f14CA_parent_instructions;
               body.emit(f14CA);

               /* END IF */


            body.instructions = f148E_parent_instructions;
            body.emit(f148E);

            /* END IF */


         body.instructions = f1456_parent_instructions;
         body.emit(f1456);

         /* END IF */

         /* IF CONDITION */
         ir_if *f153C = new(mem_ctx) ir_if(operand(r1443).val);
         exec_list *const f153C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f153C->then_instructions;

            body.emit(assign(r1448, bit_or(r1448, body.constant(1048576u)), 0x01));

            ir_variable *const r153D = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r153E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r153E, add(r1449, r1447), 0x01));

            ir_expression *const r153F = add(r1448, r1446);
            ir_expression *const r1540 = less(r153E, r1449);
            ir_expression *const r1541 = expr(ir_unop_b2i, r1540);
            ir_expression *const r1542 = expr(ir_unop_i2u, r1541);
            body.emit(assign(r153D, add(r153F, r1542), 0x01));

            body.emit(assign(r144C, r153D, 0x01));

            body.emit(assign(r144A, add(r144A, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1544 = less(r153D, body.constant(2097152u));
            ir_if *f1543 = new(mem_ctx) ir_if(operand(r1544).val);
            exec_list *const f1543_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1543->then_instructions;

               ir_variable *const r1545 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1545, r144A, 0x01));

               ir_variable *const r1546 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1546, r153D, 0x01));

               ir_variable *const r1547 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1547, r153E, 0x01));

               ir_variable *const r1548 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1548, r144B, 0x01));

               ir_variable *const r1549 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1549, body.constant(true), 0x01));

               ir_variable *const r154A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r154B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r154B);
               ir_expression *const r154C = expr(ir_unop_u2i, r144B);
               body.emit(assign(r154B, less(r154C, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r154E = lequal(body.constant(int(2045)), r144A);
               ir_if *f154D = new(mem_ctx) ir_if(operand(r154E).val);
               exec_list *const f154D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f154D->then_instructions;

                  ir_variable *const r154F = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1551 = less(body.constant(int(2045)), r144A);
                  ir_if *f1550 = new(mem_ctx) ir_if(operand(r1551).val);
                  exec_list *const f1550_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1550->then_instructions;

                     body.emit(assign(r154F, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1550->else_instructions;

                     ir_variable *const r1552 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1554 = equal(r144A, body.constant(int(2045)));
                     ir_if *f1553 = new(mem_ctx) ir_if(operand(r1554).val);
                     exec_list *const f1553_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1553->then_instructions;

                        ir_expression *const r1555 = equal(body.constant(2097151u), r153D);
                        ir_expression *const r1556 = equal(body.constant(4294967295u), r153E);
                        body.emit(assign(r1552, logic_and(r1555, r1556), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1553->else_instructions;

                        body.emit(assign(r1552, body.constant(false), 0x01));


                     body.instructions = f1553_parent_instructions;
                     body.emit(f1553);

                     /* END IF */

                     body.emit(assign(r154F, logic_and(r1552, r154B), 0x01));


                  body.instructions = f1550_parent_instructions;
                  body.emit(f1550);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1557 = new(mem_ctx) ir_if(operand(r154F).val);
                  exec_list *const f1557_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1557->then_instructions;

                     ir_variable *const r1558 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1558);
                     ir_expression *const r1559 = lshift(r143F, body.constant(int(31)));
                     body.emit(assign(r1558, add(r1559, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1558, body.constant(0u), 0x01));

                     body.emit(assign(r154A, r1558, 0x03));

                     body.emit(assign(r1549, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1557->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r155B = less(r144A, body.constant(int(0)));
                     ir_if *f155A = new(mem_ctx) ir_if(operand(r155B).val);
                     exec_list *const f155A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f155A->then_instructions;

                        ir_variable *const r155C = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r155C, r144B, 0x01));

                        ir_variable *const r155D = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r155D, neg(r144A), 0x01));

                        ir_variable *const r155E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r155E);
                        ir_variable *const r155F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r155F);
                        ir_variable *const r1560 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1560);
                        ir_variable *const r1561 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1562 = neg(r155D);
                        body.emit(assign(r1561, bit_and(r1562, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1564 = equal(r155D, body.constant(int(0)));
                        ir_if *f1563 = new(mem_ctx) ir_if(operand(r1564).val);
                        exec_list *const f1563_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1563->then_instructions;

                           body.emit(assign(r155E, r144B, 0x01));

                           body.emit(assign(r155F, r153E, 0x01));

                           body.emit(assign(r1560, r153D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1563->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1566 = less(r155D, body.constant(int(32)));
                           ir_if *f1565 = new(mem_ctx) ir_if(operand(r1566).val);
                           exec_list *const f1565_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1565->then_instructions;

                              body.emit(assign(r155E, lshift(r153E, r1561), 0x01));

                              ir_expression *const r1567 = lshift(r153D, r1561);
                              ir_expression *const r1568 = rshift(r153E, r155D);
                              body.emit(assign(r155F, bit_or(r1567, r1568), 0x01));

                              body.emit(assign(r1560, rshift(r153D, r155D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1565->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r156A = equal(r155D, body.constant(int(32)));
                              ir_if *f1569 = new(mem_ctx) ir_if(operand(r156A).val);
                              exec_list *const f1569_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1569->then_instructions;

                                 body.emit(assign(r155E, r153E, 0x01));

                                 body.emit(assign(r155F, r153D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1569->else_instructions;

                                 body.emit(assign(r155C, bit_or(r144B, r153E), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r156C = less(r155D, body.constant(int(64)));
                                 ir_if *f156B = new(mem_ctx) ir_if(operand(r156C).val);
                                 exec_list *const f156B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f156B->then_instructions;

                                    body.emit(assign(r155E, lshift(r153D, r1561), 0x01));

                                    ir_expression *const r156D = bit_and(r155D, body.constant(int(31)));
                                    body.emit(assign(r155F, rshift(r153D, r156D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f156B->else_instructions;

                                    ir_variable *const r156E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1570 = equal(r155D, body.constant(int(64)));
                                    ir_if *f156F = new(mem_ctx) ir_if(operand(r1570).val);
                                    exec_list *const f156F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f156F->then_instructions;

                                       body.emit(assign(r156E, r153D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f156F->else_instructions;

                                       ir_expression *const r1571 = nequal(r153D, body.constant(0u));
                                       ir_expression *const r1572 = expr(ir_unop_b2i, r1571);
                                       body.emit(assign(r156E, expr(ir_unop_i2u, r1572), 0x01));


                                    body.instructions = f156F_parent_instructions;
                                    body.emit(f156F);

                                    /* END IF */

                                    body.emit(assign(r155E, r156E, 0x01));

                                    body.emit(assign(r155F, body.constant(0u), 0x01));


                                 body.instructions = f156B_parent_instructions;
                                 body.emit(f156B);

                                 /* END IF */


                              body.instructions = f1569_parent_instructions;
                              body.emit(f1569);

                              /* END IF */

                              body.emit(assign(r1560, body.constant(0u), 0x01));


                           body.instructions = f1565_parent_instructions;
                           body.emit(f1565);

                           /* END IF */

                           ir_expression *const r1573 = nequal(r155C, body.constant(0u));
                           ir_expression *const r1574 = expr(ir_unop_b2i, r1573);
                           ir_expression *const r1575 = expr(ir_unop_i2u, r1574);
                           body.emit(assign(r155E, bit_or(r155E, r1575), 0x01));


                        body.instructions = f1563_parent_instructions;
                        body.emit(f1563);

                        /* END IF */

                        body.emit(assign(r1546, r1560, 0x01));

                        body.emit(assign(r1547, r155F, 0x01));

                        body.emit(assign(r1548, r155E, 0x01));

                        body.emit(assign(r1545, body.constant(int(0)), 0x01));

                        body.emit(assign(r154B, less(r155E, body.constant(0u)), 0x01));


                     body.instructions = f155A_parent_instructions;
                     body.emit(f155A);

                     /* END IF */


                  body.instructions = f1557_parent_instructions;
                  body.emit(f1557);

                  /* END IF */


               body.instructions = f154D_parent_instructions;
               body.emit(f154D);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1576 = new(mem_ctx) ir_if(operand(r1549).val);
               exec_list *const f1576_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1576->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1577 = new(mem_ctx) ir_if(operand(r154B).val);
                  exec_list *const f1577_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1577->then_instructions;

                     ir_variable *const r1578 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1578, add(r1547, body.constant(1u)), 0x01));

                     ir_expression *const r1579 = less(r1578, r1547);
                     ir_expression *const r157A = expr(ir_unop_b2i, r1579);
                     ir_expression *const r157B = expr(ir_unop_i2u, r157A);
                     body.emit(assign(r1546, add(r1546, r157B), 0x01));

                     ir_expression *const r157C = equal(r1548, body.constant(0u));
                     ir_expression *const r157D = expr(ir_unop_b2i, r157C);
                     ir_expression *const r157E = expr(ir_unop_i2u, r157D);
                     ir_expression *const r157F = add(r1548, r157E);
                     ir_expression *const r1580 = bit_and(r157F, body.constant(1u));
                     ir_expression *const r1581 = expr(ir_unop_bit_not, r1580);
                     body.emit(assign(r1547, bit_and(r1578, r1581), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1577->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1583 = bit_or(r1546, r1547);
                     ir_expression *const r1584 = equal(r1583, body.constant(0u));
                     ir_if *f1582 = new(mem_ctx) ir_if(operand(r1584).val);
                     exec_list *const f1582_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1582->then_instructions;

                        body.emit(assign(r1545, body.constant(int(0)), 0x01));


                     body.instructions = f1582_parent_instructions;
                     body.emit(f1582);

                     /* END IF */


                  body.instructions = f1577_parent_instructions;
                  body.emit(f1577);

                  /* END IF */

                  ir_variable *const r1585 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1585);
                  ir_expression *const r1586 = lshift(r143F, body.constant(int(31)));
                  ir_expression *const r1587 = expr(ir_unop_i2u, r1545);
                  ir_expression *const r1588 = lshift(r1587, body.constant(int(20)));
                  ir_expression *const r1589 = add(r1586, r1588);
                  body.emit(assign(r1585, add(r1589, r1546), 0x02));

                  body.emit(assign(r1585, r1547, 0x01));

                  body.emit(assign(r154A, r1585, 0x03));

                  body.emit(assign(r1549, body.constant(false), 0x01));


               body.instructions = f1576_parent_instructions;
               body.emit(f1576);

               /* END IF */

               body.emit(assign(r1444, r154A, 0x03));

               body.emit(assign(r1443, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1543->else_instructions;

               body.emit(assign(r144A, add(r144A, body.constant(int(1))), 0x01));

               ir_variable *const r158A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r158A);
               ir_variable *const r158B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r158B);
               ir_variable *const r158C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r158C);
               body.emit(assign(r158A, lshift(r153E, body.constant(int(31))), 0x01));

               ir_expression *const r158D = lshift(r153D, body.constant(int(31)));
               ir_expression *const r158E = rshift(r153E, body.constant(int(1)));
               body.emit(assign(r158B, bit_or(r158D, r158E), 0x01));

               body.emit(assign(r158C, rshift(r153D, body.constant(int(1))), 0x01));

               ir_expression *const r158F = nequal(r144B, body.constant(0u));
               ir_expression *const r1590 = expr(ir_unop_b2i, r158F);
               ir_expression *const r1591 = expr(ir_unop_i2u, r1590);
               body.emit(assign(r158A, bit_or(r158A, r1591), 0x01));

               body.emit(assign(r144C, r158C, 0x01));

               body.emit(assign(r144B, r158A, 0x01));

               ir_variable *const r1592 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1592, r144A, 0x01));

               ir_variable *const r1593 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1593, r158C, 0x01));

               ir_variable *const r1594 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1594, r158B, 0x01));

               ir_variable *const r1595 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1595, r158A, 0x01));

               ir_variable *const r1596 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1596, body.constant(true), 0x01));

               ir_variable *const r1597 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1598 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1598);
               ir_expression *const r1599 = expr(ir_unop_u2i, r158A);
               body.emit(assign(r1598, less(r1599, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r159B = lequal(body.constant(int(2045)), r144A);
               ir_if *f159A = new(mem_ctx) ir_if(operand(r159B).val);
               exec_list *const f159A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f159A->then_instructions;

                  ir_variable *const r159C = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r159E = less(body.constant(int(2045)), r144A);
                  ir_if *f159D = new(mem_ctx) ir_if(operand(r159E).val);
                  exec_list *const f159D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f159D->then_instructions;

                     body.emit(assign(r159C, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f159D->else_instructions;

                     ir_variable *const r159F = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r15A1 = equal(r144A, body.constant(int(2045)));
                     ir_if *f15A0 = new(mem_ctx) ir_if(operand(r15A1).val);
                     exec_list *const f15A0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15A0->then_instructions;

                        ir_expression *const r15A2 = equal(body.constant(2097151u), r158C);
                        ir_expression *const r15A3 = equal(body.constant(4294967295u), r158B);
                        body.emit(assign(r159F, logic_and(r15A2, r15A3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f15A0->else_instructions;

                        body.emit(assign(r159F, body.constant(false), 0x01));


                     body.instructions = f15A0_parent_instructions;
                     body.emit(f15A0);

                     /* END IF */

                     body.emit(assign(r159C, logic_and(r159F, r1598), 0x01));


                  body.instructions = f159D_parent_instructions;
                  body.emit(f159D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f15A4 = new(mem_ctx) ir_if(operand(r159C).val);
                  exec_list *const f15A4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15A4->then_instructions;

                     ir_variable *const r15A5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r15A5);
                     ir_expression *const r15A6 = lshift(r143F, body.constant(int(31)));
                     body.emit(assign(r15A5, add(r15A6, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r15A5, body.constant(0u), 0x01));

                     body.emit(assign(r1597, r15A5, 0x03));

                     body.emit(assign(r1596, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15A4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15A8 = less(r144A, body.constant(int(0)));
                     ir_if *f15A7 = new(mem_ctx) ir_if(operand(r15A8).val);
                     exec_list *const f15A7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15A7->then_instructions;

                        ir_variable *const r15A9 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r15A9, r158A, 0x01));

                        ir_variable *const r15AA = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r15AA, neg(r144A), 0x01));

                        ir_variable *const r15AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r15AB);
                        ir_variable *const r15AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r15AC);
                        ir_variable *const r15AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r15AD);
                        ir_variable *const r15AE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r15AF = neg(r15AA);
                        body.emit(assign(r15AE, bit_and(r15AF, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r15B1 = equal(r15AA, body.constant(int(0)));
                        ir_if *f15B0 = new(mem_ctx) ir_if(operand(r15B1).val);
                        exec_list *const f15B0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f15B0->then_instructions;

                           body.emit(assign(r15AB, r158A, 0x01));

                           body.emit(assign(r15AC, r158B, 0x01));

                           body.emit(assign(r15AD, r158C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f15B0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r15B3 = less(r15AA, body.constant(int(32)));
                           ir_if *f15B2 = new(mem_ctx) ir_if(operand(r15B3).val);
                           exec_list *const f15B2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f15B2->then_instructions;

                              body.emit(assign(r15AB, lshift(r158B, r15AE), 0x01));

                              ir_expression *const r15B4 = lshift(r158C, r15AE);
                              ir_expression *const r15B5 = rshift(r158B, r15AA);
                              body.emit(assign(r15AC, bit_or(r15B4, r15B5), 0x01));

                              body.emit(assign(r15AD, rshift(r158C, r15AA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f15B2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r15B7 = equal(r15AA, body.constant(int(32)));
                              ir_if *f15B6 = new(mem_ctx) ir_if(operand(r15B7).val);
                              exec_list *const f15B6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f15B6->then_instructions;

                                 body.emit(assign(r15AB, r158B, 0x01));

                                 body.emit(assign(r15AC, r158C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f15B6->else_instructions;

                                 body.emit(assign(r15A9, bit_or(r158A, r158B), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r15B9 = less(r15AA, body.constant(int(64)));
                                 ir_if *f15B8 = new(mem_ctx) ir_if(operand(r15B9).val);
                                 exec_list *const f15B8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f15B8->then_instructions;

                                    body.emit(assign(r15AB, lshift(r158C, r15AE), 0x01));

                                    ir_expression *const r15BA = bit_and(r15AA, body.constant(int(31)));
                                    body.emit(assign(r15AC, rshift(r158C, r15BA), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f15B8->else_instructions;

                                    ir_variable *const r15BB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r15BD = equal(r15AA, body.constant(int(64)));
                                    ir_if *f15BC = new(mem_ctx) ir_if(operand(r15BD).val);
                                    exec_list *const f15BC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f15BC->then_instructions;

                                       body.emit(assign(r15BB, r158C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f15BC->else_instructions;

                                       ir_expression *const r15BE = nequal(r158C, body.constant(0u));
                                       ir_expression *const r15BF = expr(ir_unop_b2i, r15BE);
                                       body.emit(assign(r15BB, expr(ir_unop_i2u, r15BF), 0x01));


                                    body.instructions = f15BC_parent_instructions;
                                    body.emit(f15BC);

                                    /* END IF */

                                    body.emit(assign(r15AB, r15BB, 0x01));

                                    body.emit(assign(r15AC, body.constant(0u), 0x01));


                                 body.instructions = f15B8_parent_instructions;
                                 body.emit(f15B8);

                                 /* END IF */


                              body.instructions = f15B6_parent_instructions;
                              body.emit(f15B6);

                              /* END IF */

                              body.emit(assign(r15AD, body.constant(0u), 0x01));


                           body.instructions = f15B2_parent_instructions;
                           body.emit(f15B2);

                           /* END IF */

                           ir_expression *const r15C0 = nequal(r15A9, body.constant(0u));
                           ir_expression *const r15C1 = expr(ir_unop_b2i, r15C0);
                           ir_expression *const r15C2 = expr(ir_unop_i2u, r15C1);
                           body.emit(assign(r15AB, bit_or(r15AB, r15C2), 0x01));


                        body.instructions = f15B0_parent_instructions;
                        body.emit(f15B0);

                        /* END IF */

                        body.emit(assign(r1593, r15AD, 0x01));

                        body.emit(assign(r1594, r15AC, 0x01));

                        body.emit(assign(r1595, r15AB, 0x01));

                        body.emit(assign(r1592, body.constant(int(0)), 0x01));

                        body.emit(assign(r1598, less(r15AB, body.constant(0u)), 0x01));


                     body.instructions = f15A7_parent_instructions;
                     body.emit(f15A7);

                     /* END IF */


                  body.instructions = f15A4_parent_instructions;
                  body.emit(f15A4);

                  /* END IF */


               body.instructions = f159A_parent_instructions;
               body.emit(f159A);

               /* END IF */

               /* IF CONDITION */
               ir_if *f15C3 = new(mem_ctx) ir_if(operand(r1596).val);
               exec_list *const f15C3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15C3->then_instructions;

                  /* IF CONDITION */
                  ir_if *f15C4 = new(mem_ctx) ir_if(operand(r1598).val);
                  exec_list *const f15C4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15C4->then_instructions;

                     ir_variable *const r15C5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r15C5, add(r1594, body.constant(1u)), 0x01));

                     ir_expression *const r15C6 = less(r15C5, r1594);
                     ir_expression *const r15C7 = expr(ir_unop_b2i, r15C6);
                     ir_expression *const r15C8 = expr(ir_unop_i2u, r15C7);
                     body.emit(assign(r1593, add(r1593, r15C8), 0x01));

                     ir_expression *const r15C9 = equal(r1595, body.constant(0u));
                     ir_expression *const r15CA = expr(ir_unop_b2i, r15C9);
                     ir_expression *const r15CB = expr(ir_unop_i2u, r15CA);
                     ir_expression *const r15CC = add(r1595, r15CB);
                     ir_expression *const r15CD = bit_and(r15CC, body.constant(1u));
                     ir_expression *const r15CE = expr(ir_unop_bit_not, r15CD);
                     body.emit(assign(r1594, bit_and(r15C5, r15CE), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15C4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15D0 = bit_or(r1593, r1594);
                     ir_expression *const r15D1 = equal(r15D0, body.constant(0u));
                     ir_if *f15CF = new(mem_ctx) ir_if(operand(r15D1).val);
                     exec_list *const f15CF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15CF->then_instructions;

                        body.emit(assign(r1592, body.constant(int(0)), 0x01));


                     body.instructions = f15CF_parent_instructions;
                     body.emit(f15CF);

                     /* END IF */


                  body.instructions = f15C4_parent_instructions;
                  body.emit(f15C4);

                  /* END IF */

                  ir_variable *const r15D2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r15D2);
                  ir_expression *const r15D3 = lshift(r143F, body.constant(int(31)));
                  ir_expression *const r15D4 = expr(ir_unop_i2u, r1592);
                  ir_expression *const r15D5 = lshift(r15D4, body.constant(int(20)));
                  ir_expression *const r15D6 = add(r15D3, r15D5);
                  body.emit(assign(r15D2, add(r15D6, r1593), 0x02));

                  body.emit(assign(r15D2, r1594, 0x01));

                  body.emit(assign(r1597, r15D2, 0x03));

                  body.emit(assign(r1596, body.constant(false), 0x01));


               body.instructions = f15C3_parent_instructions;
               body.emit(f15C3);

               /* END IF */

               body.emit(assign(r1444, r1597, 0x03));

               body.emit(assign(r1443, body.constant(false), 0x01));


            body.instructions = f1543_parent_instructions;
            body.emit(f1543);

            /* END IF */


         body.instructions = f153C_parent_instructions;
         body.emit(f153C);

         /* END IF */

         body.emit(assign(r143E, r1444, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1441->else_instructions;

         ir_variable *const r15D7 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r15D7, r143F, 0x01));

         ir_variable *const r15D8 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r15D9 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r15D9);
         ir_variable *const r15DA = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r15DA);
         ir_variable *const r15DB = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r15DB);
         ir_variable *const r15DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r15DC);
         ir_variable *const r15DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r15DD);
         ir_variable *const r15DE = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r15DE);
         ir_variable *const r15DF = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r15DF);
         ir_variable *const r15E0 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r15E0);
         ir_variable *const r15E1 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r15E2 = rshift(swizzle_y(r1408), body.constant(int(20)));
         ir_expression *const r15E3 = bit_and(r15E2, body.constant(2047u));
         body.emit(assign(r15E1, expr(ir_unop_u2i, r15E3), 0x01));

         body.emit(assign(r15DB, r15E1, 0x01));

         ir_variable *const r15E4 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r15E4, body.constant(int(1023)), 0x01));

         body.emit(assign(r15DA, r15E4, 0x01));

         body.emit(assign(r15D9, add(r15E1, body.constant(int(-1023))), 0x01));

         ir_variable *const r15E5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r15E5, lshift(swizzle_x(r1408), body.constant(int(10))), 0x01));

         ir_variable *const r15E6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r15E7 = bit_and(swizzle_y(r1408), body.constant(1048575u));
         ir_expression *const r15E8 = lshift(r15E7, body.constant(int(10)));
         ir_expression *const r15E9 = rshift(swizzle_x(r1408), body.constant(int(22)));
         body.emit(assign(r15E6, bit_or(r15E8, r15E9), 0x01));

         body.emit(assign(r15DE, r15E6, 0x01));

         body.emit(assign(r15DF, r15E5, 0x01));

         ir_variable *const r15EA = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r15EA, body.constant(0u), 0x01));

         ir_variable *const r15EB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r15EB, body.constant(0u), 0x01));

         body.emit(assign(r15DC, r15EB, 0x01));

         body.emit(assign(r15DD, r15EA, 0x01));

         /* IF CONDITION */
         ir_expression *const r15ED = less(body.constant(int(0)), r15D9);
         ir_if *f15EC = new(mem_ctx) ir_if(operand(r15ED).val);
         exec_list *const f15EC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f15EC->then_instructions;

            /* IF CONDITION */
            ir_expression *const r15EF = equal(r15E1, body.constant(int(2047)));
            ir_if *f15EE = new(mem_ctx) ir_if(operand(r15EF).val);
            exec_list *const f15EE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f15EE->then_instructions;

               /* IF CONDITION */
               ir_expression *const r15F1 = bit_or(r15E6, r15E5);
               ir_expression *const r15F2 = nequal(r15F1, body.constant(0u));
               ir_if *f15F0 = new(mem_ctx) ir_if(operand(r15F2).val);
               exec_list *const f15F0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15F0->then_instructions;

                  ir_variable *const r15F3 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r15F3, swizzle_x(r1408), 0x01));

                  ir_variable *const r15F4 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r15F4, body.constant(0u), 0x01));

                  ir_variable *const r15F5 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r15F6 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r15F7 = rshift(swizzle_y(r1408), body.constant(int(19)));
                  ir_expression *const r15F8 = bit_and(r15F7, body.constant(4095u));
                  ir_expression *const r15F9 = equal(r15F8, body.constant(4094u));
                  ir_expression *const r15FA = nequal(swizzle_x(r1408), body.constant(0u));
                  ir_expression *const r15FB = bit_and(swizzle_y(r1408), body.constant(524287u));
                  ir_expression *const r15FC = nequal(r15FB, body.constant(0u));
                  ir_expression *const r15FD = logic_or(r15FA, r15FC);
                  body.emit(assign(r15F6, logic_and(r15F9, r15FD), 0x01));

                  ir_variable *const r15FE = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  body.emit(assign(r15FE, body.constant(false), 0x01));

                  body.emit(assign(r15F3, bit_or(swizzle_y(r1408), body.constant(524288u)), 0x02));

                  body.emit(assign(r15F4, body.constant(3220701184u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1600 = lshift(swizzle_y(r1408), body.constant(int(1)));
                  ir_expression *const r1601 = lequal(body.constant(4292870144u), r1600);
                  ir_expression *const r1602 = nequal(swizzle_x(r1408), body.constant(0u));
                  ir_expression *const r1603 = bit_and(swizzle_y(r1408), body.constant(1048575u));
                  ir_expression *const r1604 = nequal(r1603, body.constant(0u));
                  ir_expression *const r1605 = logic_or(r1602, r1604);
                  ir_expression *const r1606 = logic_and(r1601, r1605);
                  ir_if *f15FF = new(mem_ctx) ir_if(operand(r1606).val);
                  exec_list *const f15FF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15FF->then_instructions;

                     ir_variable *const r1607 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_constant *const r1609 = body.constant(false);
                     ir_if *f1608 = new(mem_ctx) ir_if(operand(r1609).val);
                     exec_list *const f1608_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1608->then_instructions;

                        body.emit(assign(r1607, r15F4, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1608->else_instructions;

                        body.emit(assign(r1607, r15F3, 0x03));


                     body.instructions = f1608_parent_instructions;
                     body.emit(f1608);

                     /* END IF */

                     body.emit(assign(r15F5, r1607, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15FF->else_instructions;

                     body.emit(assign(r15F5, r15F4, 0x03));


                  body.instructions = f15FF_parent_instructions;
                  body.emit(f15FF);

                  /* END IF */

                  body.emit(assign(r15D8, r15F5, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f15F0->else_instructions;

                  body.emit(assign(r15D8, r1408, 0x03));


               body.instructions = f15F0_parent_instructions;
               body.emit(f15F0);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f15EE->else_instructions;

               /* IF CONDITION */
               ir_constant *const r160B = body.constant(false);
               ir_if *f160A = new(mem_ctx) ir_if(operand(r160B).val);
               exec_list *const f160A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f160A->then_instructions;

                  body.emit(assign(r15D9, add(r15D9, body.constant(int(-1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f160A->else_instructions;

                  body.emit(assign(r15DC, body.constant(1073741824u), 0x01));


               body.instructions = f160A_parent_instructions;
               body.emit(f160A);

               /* END IF */

               ir_variable *const r160C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r160C);
               ir_variable *const r160D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r160D);
               ir_variable *const r160E = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r160F = neg(r15D9);
               body.emit(assign(r160E, bit_and(r160F, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1611 = equal(r15D9, body.constant(int(0)));
               ir_if *f1610 = new(mem_ctx) ir_if(operand(r1611).val);
               exec_list *const f1610_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1610->then_instructions;

                  body.emit(assign(r160C, r15EA, 0x01));

                  body.emit(assign(r160D, r15DC, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1610->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1613 = less(r15D9, body.constant(int(32)));
                  ir_if *f1612 = new(mem_ctx) ir_if(operand(r1613).val);
                  exec_list *const f1612_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1612->then_instructions;

                     ir_expression *const r1614 = lshift(r15DC, r160E);
                     ir_expression *const r1615 = bit_or(r1614, body.constant(0u));
                     ir_expression *const r1616 = nequal(body.constant(0u), body.constant(0u));
                     ir_expression *const r1617 = expr(ir_unop_b2i, r1616);
                     ir_expression *const r1618 = expr(ir_unop_i2u, r1617);
                     body.emit(assign(r160C, bit_or(r1615, r1618), 0x01));

                     body.emit(assign(r160D, rshift(r15DC, r15D9), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1612->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r161A = equal(r15D9, body.constant(int(32)));
                     ir_if *f1619 = new(mem_ctx) ir_if(operand(r161A).val);
                     exec_list *const f1619_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1619->then_instructions;

                        body.emit(assign(r160C, bit_or(r15DC, body.constant(0u)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1619->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r161C = less(r15D9, body.constant(int(64)));
                        ir_if *f161B = new(mem_ctx) ir_if(operand(r161C).val);
                        exec_list *const f161B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f161B->then_instructions;

                           ir_expression *const r161D = bit_and(r15D9, body.constant(int(31)));
                           ir_expression *const r161E = rshift(r15DC, r161D);
                           ir_expression *const r161F = lshift(r15DC, r160E);
                           ir_expression *const r1620 = bit_or(r161F, body.constant(0u));
                           ir_expression *const r1621 = nequal(r1620, body.constant(0u));
                           ir_expression *const r1622 = expr(ir_unop_b2i, r1621);
                           ir_expression *const r1623 = expr(ir_unop_i2u, r1622);
                           body.emit(assign(r160C, bit_or(r161E, r1623), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f161B->else_instructions;

                           ir_expression *const r1624 = bit_or(r15DC, body.constant(0u));
                           ir_expression *const r1625 = nequal(r1624, body.constant(0u));
                           ir_expression *const r1626 = expr(ir_unop_b2i, r1625);
                           body.emit(assign(r160C, expr(ir_unop_i2u, r1626), 0x01));


                        body.instructions = f161B_parent_instructions;
                        body.emit(f161B);

                        /* END IF */


                     body.instructions = f1619_parent_instructions;
                     body.emit(f1619);

                     /* END IF */

                     body.emit(assign(r160D, body.constant(0u), 0x01));


                  body.instructions = f1612_parent_instructions;
                  body.emit(f1612);

                  /* END IF */


               body.instructions = f1610_parent_instructions;
               body.emit(f1610);

               /* END IF */

               body.emit(assign(r15DC, r160D, 0x01));

               body.emit(assign(r15DD, r160C, 0x01));

               body.emit(assign(r15DE, bit_or(r15E6, body.constant(1073741824u)), 0x01));

               ir_variable *const r1627 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1628 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1628, sub(r15E5, r160C), 0x01));

               ir_expression *const r1629 = sub(r15DE, r160D);
               ir_expression *const r162A = less(r15E5, r160C);
               ir_expression *const r162B = expr(ir_unop_b2i, r162A);
               ir_expression *const r162C = expr(ir_unop_i2u, r162B);
               body.emit(assign(r1627, sub(r1629, r162C), 0x01));

               body.emit(assign(r15E0, add(r15E1, body.constant(int(-1))), 0x01));

               ir_variable *const r162D = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r162D, add(r15E0, body.constant(int(-10))), 0x01));

               ir_variable *const r162E = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r162E, r1627, 0x01));

               ir_variable *const r162F = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r162F, r1628, 0x01));

               ir_variable *const r1630 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1630);
               ir_variable *const r1631 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1631);
               /* IF CONDITION */
               ir_expression *const r1633 = equal(r1627, body.constant(0u));
               ir_if *f1632 = new(mem_ctx) ir_if(operand(r1633).val);
               exec_list *const f1632_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1632->then_instructions;

                  body.emit(assign(r162E, r1628, 0x01));

                  body.emit(assign(r162F, body.constant(0u), 0x01));

                  body.emit(assign(r162D, add(r162D, body.constant(int(-32))), 0x01));


               body.instructions = f1632_parent_instructions;
               body.emit(f1632);

               /* END IF */

               ir_variable *const r1634 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1634, r162E, 0x01));

               ir_variable *const r1635 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1636 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1636);
               /* IF CONDITION */
               ir_expression *const r1638 = equal(r162E, body.constant(0u));
               ir_if *f1637 = new(mem_ctx) ir_if(operand(r1638).val);
               exec_list *const f1637_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1637->then_instructions;

                  body.emit(assign(r1635, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1637->else_instructions;

                  body.emit(assign(r1636, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r163A = bit_and(r162E, body.constant(4294901760u));
                  ir_expression *const r163B = equal(r163A, body.constant(0u));
                  ir_if *f1639 = new(mem_ctx) ir_if(operand(r163B).val);
                  exec_list *const f1639_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1639->then_instructions;

                     body.emit(assign(r1636, body.constant(int(16)), 0x01));

                     body.emit(assign(r1634, lshift(r162E, body.constant(int(16))), 0x01));


                  body.instructions = f1639_parent_instructions;
                  body.emit(f1639);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r163D = bit_and(r1634, body.constant(4278190080u));
                  ir_expression *const r163E = equal(r163D, body.constant(0u));
                  ir_if *f163C = new(mem_ctx) ir_if(operand(r163E).val);
                  exec_list *const f163C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f163C->then_instructions;

                     body.emit(assign(r1636, add(r1636, body.constant(int(8))), 0x01));

                     body.emit(assign(r1634, lshift(r1634, body.constant(int(8))), 0x01));


                  body.instructions = f163C_parent_instructions;
                  body.emit(f163C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1640 = bit_and(r1634, body.constant(4026531840u));
                  ir_expression *const r1641 = equal(r1640, body.constant(0u));
                  ir_if *f163F = new(mem_ctx) ir_if(operand(r1641).val);
                  exec_list *const f163F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f163F->then_instructions;

                     body.emit(assign(r1636, add(r1636, body.constant(int(4))), 0x01));

                     body.emit(assign(r1634, lshift(r1634, body.constant(int(4))), 0x01));


                  body.instructions = f163F_parent_instructions;
                  body.emit(f163F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1643 = bit_and(r1634, body.constant(3221225472u));
                  ir_expression *const r1644 = equal(r1643, body.constant(0u));
                  ir_if *f1642 = new(mem_ctx) ir_if(operand(r1644).val);
                  exec_list *const f1642_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1642->then_instructions;

                     body.emit(assign(r1636, add(r1636, body.constant(int(2))), 0x01));

                     body.emit(assign(r1634, lshift(r1634, body.constant(int(2))), 0x01));


                  body.instructions = f1642_parent_instructions;
                  body.emit(f1642);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1646 = bit_and(r1634, body.constant(2147483648u));
                  ir_expression *const r1647 = equal(r1646, body.constant(0u));
                  ir_if *f1645 = new(mem_ctx) ir_if(operand(r1647).val);
                  exec_list *const f1645_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1645->then_instructions;

                     body.emit(assign(r1636, add(r1636, body.constant(int(1))), 0x01));


                  body.instructions = f1645_parent_instructions;
                  body.emit(f1645);

                  /* END IF */

                  body.emit(assign(r1635, r1636, 0x01));


               body.instructions = f1637_parent_instructions;
               body.emit(f1637);

               /* END IF */

               body.emit(assign(r1631, add(r1635, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1649 = lequal(body.constant(int(0)), r1631);
               ir_if *f1648 = new(mem_ctx) ir_if(operand(r1649).val);
               exec_list *const f1648_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1648->then_instructions;

                  body.emit(assign(r1630, body.constant(0u), 0x01));

                  ir_variable *const r164A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r164A, lshift(r162F, r1631), 0x01));

                  ir_variable *const r164B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r164D = equal(r1631, body.constant(int(0)));
                  ir_if *f164C = new(mem_ctx) ir_if(operand(r164D).val);
                  exec_list *const f164C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f164C->then_instructions;

                     body.emit(assign(r164B, r162E, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f164C->else_instructions;

                     ir_expression *const r164E = lshift(r162E, r1631);
                     ir_expression *const r164F = neg(r1631);
                     ir_expression *const r1650 = bit_and(r164F, body.constant(int(31)));
                     ir_expression *const r1651 = rshift(r162F, r1650);
                     body.emit(assign(r164B, bit_or(r164E, r1651), 0x01));


                  body.instructions = f164C_parent_instructions;
                  body.emit(f164C);

                  /* END IF */

                  body.emit(assign(r162E, r164B, 0x01));

                  body.emit(assign(r162F, r164A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1648->else_instructions;

                  ir_variable *const r1652 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1652, body.constant(0u), 0x01));

                  ir_variable *const r1653 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1653, neg(r1631), 0x01));

                  ir_variable *const r1654 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1654);
                  ir_variable *const r1655 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1655);
                  ir_variable *const r1656 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1656);
                  ir_variable *const r1657 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1658 = neg(r1653);
                  body.emit(assign(r1657, bit_and(r1658, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r165A = equal(r1653, body.constant(int(0)));
                  ir_if *f1659 = new(mem_ctx) ir_if(operand(r165A).val);
                  exec_list *const f1659_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1659->then_instructions;

                     body.emit(assign(r1654, r1652, 0x01));

                     body.emit(assign(r1655, r162F, 0x01));

                     body.emit(assign(r1656, r162E, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1659->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r165C = less(r1653, body.constant(int(32)));
                     ir_if *f165B = new(mem_ctx) ir_if(operand(r165C).val);
                     exec_list *const f165B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f165B->then_instructions;

                        body.emit(assign(r1654, lshift(r162F, r1657), 0x01));

                        ir_expression *const r165D = lshift(r162E, r1657);
                        ir_expression *const r165E = rshift(r162F, r1653);
                        body.emit(assign(r1655, bit_or(r165D, r165E), 0x01));

                        body.emit(assign(r1656, rshift(r162E, r1653), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f165B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1660 = equal(r1653, body.constant(int(32)));
                        ir_if *f165F = new(mem_ctx) ir_if(operand(r1660).val);
                        exec_list *const f165F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f165F->then_instructions;

                           body.emit(assign(r1654, r162F, 0x01));

                           body.emit(assign(r1655, r162E, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f165F->else_instructions;

                           body.emit(assign(r1652, bit_or(body.constant(0u), r162F), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1662 = less(r1653, body.constant(int(64)));
                           ir_if *f1661 = new(mem_ctx) ir_if(operand(r1662).val);
                           exec_list *const f1661_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1661->then_instructions;

                              body.emit(assign(r1654, lshift(r162E, r1657), 0x01));

                              ir_expression *const r1663 = bit_and(r1653, body.constant(int(31)));
                              body.emit(assign(r1655, rshift(r162E, r1663), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1661->else_instructions;

                              ir_variable *const r1664 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1666 = equal(r1653, body.constant(int(64)));
                              ir_if *f1665 = new(mem_ctx) ir_if(operand(r1666).val);
                              exec_list *const f1665_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1665->then_instructions;

                                 body.emit(assign(r1664, r162E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1665->else_instructions;

                                 ir_expression *const r1667 = nequal(r162E, body.constant(0u));
                                 ir_expression *const r1668 = expr(ir_unop_b2i, r1667);
                                 body.emit(assign(r1664, expr(ir_unop_i2u, r1668), 0x01));


                              body.instructions = f1665_parent_instructions;
                              body.emit(f1665);

                              /* END IF */

                              body.emit(assign(r1654, r1664, 0x01));

                              body.emit(assign(r1655, body.constant(0u), 0x01));


                           body.instructions = f1661_parent_instructions;
                           body.emit(f1661);

                           /* END IF */


                        body.instructions = f165F_parent_instructions;
                        body.emit(f165F);

                        /* END IF */

                        body.emit(assign(r1656, body.constant(0u), 0x01));


                     body.instructions = f165B_parent_instructions;
                     body.emit(f165B);

                     /* END IF */

                     ir_expression *const r1669 = nequal(r1652, body.constant(0u));
                     ir_expression *const r166A = expr(ir_unop_b2i, r1669);
                     ir_expression *const r166B = expr(ir_unop_i2u, r166A);
                     body.emit(assign(r1654, bit_or(r1654, r166B), 0x01));


                  body.instructions = f1659_parent_instructions;
                  body.emit(f1659);

                  /* END IF */

                  body.emit(assign(r162E, r1656, 0x01));

                  body.emit(assign(r162F, r1655, 0x01));

                  body.emit(assign(r1630, r1654, 0x01));


               body.instructions = f1648_parent_instructions;
               body.emit(f1648);

               /* END IF */

               body.emit(assign(r162D, sub(r162D, r1631), 0x01));

               ir_variable *const r166C = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r166C, r162D, 0x01));

               ir_variable *const r166D = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r166D, r162E, 0x01));

               ir_variable *const r166E = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r166E, r162F, 0x01));

               ir_variable *const r166F = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r166F, r1630, 0x01));

               ir_variable *const r1670 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1670, body.constant(true), 0x01));

               ir_variable *const r1671 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1672 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1672);
               ir_expression *const r1673 = expr(ir_unop_u2i, r1630);
               body.emit(assign(r1672, less(r1673, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1675 = lequal(body.constant(int(2045)), r162D);
               ir_if *f1674 = new(mem_ctx) ir_if(operand(r1675).val);
               exec_list *const f1674_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1674->then_instructions;

                  ir_variable *const r1676 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1678 = less(body.constant(int(2045)), r162D);
                  ir_if *f1677 = new(mem_ctx) ir_if(operand(r1678).val);
                  exec_list *const f1677_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1677->then_instructions;

                     body.emit(assign(r1676, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1677->else_instructions;

                     ir_variable *const r1679 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r167B = equal(r162D, body.constant(int(2045)));
                     ir_if *f167A = new(mem_ctx) ir_if(operand(r167B).val);
                     exec_list *const f167A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f167A->then_instructions;

                        ir_expression *const r167C = equal(body.constant(2097151u), r162E);
                        ir_expression *const r167D = equal(body.constant(4294967295u), r162F);
                        body.emit(assign(r1679, logic_and(r167C, r167D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f167A->else_instructions;

                        body.emit(assign(r1679, body.constant(false), 0x01));


                     body.instructions = f167A_parent_instructions;
                     body.emit(f167A);

                     /* END IF */

                     body.emit(assign(r1676, logic_and(r1679, r1672), 0x01));


                  body.instructions = f1677_parent_instructions;
                  body.emit(f1677);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f167E = new(mem_ctx) ir_if(operand(r1676).val);
                  exec_list *const f167E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f167E->then_instructions;

                     ir_variable *const r167F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r167F);
                     ir_expression *const r1680 = lshift(r143F, body.constant(int(31)));
                     body.emit(assign(r167F, add(r1680, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r167F, body.constant(0u), 0x01));

                     body.emit(assign(r1671, r167F, 0x03));

                     body.emit(assign(r1670, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f167E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1682 = less(r162D, body.constant(int(0)));
                     ir_if *f1681 = new(mem_ctx) ir_if(operand(r1682).val);
                     exec_list *const f1681_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1681->then_instructions;

                        ir_variable *const r1683 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1683, r1630, 0x01));

                        ir_variable *const r1684 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1684, neg(r162D), 0x01));

                        ir_variable *const r1685 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1685);
                        ir_variable *const r1686 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1686);
                        ir_variable *const r1687 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1687);
                        ir_variable *const r1688 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1689 = neg(r1684);
                        body.emit(assign(r1688, bit_and(r1689, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r168B = equal(r1684, body.constant(int(0)));
                        ir_if *f168A = new(mem_ctx) ir_if(operand(r168B).val);
                        exec_list *const f168A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f168A->then_instructions;

                           body.emit(assign(r1685, r1630, 0x01));

                           body.emit(assign(r1686, r162F, 0x01));

                           body.emit(assign(r1687, r162E, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f168A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r168D = less(r1684, body.constant(int(32)));
                           ir_if *f168C = new(mem_ctx) ir_if(operand(r168D).val);
                           exec_list *const f168C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f168C->then_instructions;

                              body.emit(assign(r1685, lshift(r162F, r1688), 0x01));

                              ir_expression *const r168E = lshift(r162E, r1688);
                              ir_expression *const r168F = rshift(r162F, r1684);
                              body.emit(assign(r1686, bit_or(r168E, r168F), 0x01));

                              body.emit(assign(r1687, rshift(r162E, r1684), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f168C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1691 = equal(r1684, body.constant(int(32)));
                              ir_if *f1690 = new(mem_ctx) ir_if(operand(r1691).val);
                              exec_list *const f1690_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1690->then_instructions;

                                 body.emit(assign(r1685, r162F, 0x01));

                                 body.emit(assign(r1686, r162E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1690->else_instructions;

                                 body.emit(assign(r1683, bit_or(r1630, r162F), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1693 = less(r1684, body.constant(int(64)));
                                 ir_if *f1692 = new(mem_ctx) ir_if(operand(r1693).val);
                                 exec_list *const f1692_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1692->then_instructions;

                                    body.emit(assign(r1685, lshift(r162E, r1688), 0x01));

                                    ir_expression *const r1694 = bit_and(r1684, body.constant(int(31)));
                                    body.emit(assign(r1686, rshift(r162E, r1694), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1692->else_instructions;

                                    ir_variable *const r1695 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1697 = equal(r1684, body.constant(int(64)));
                                    ir_if *f1696 = new(mem_ctx) ir_if(operand(r1697).val);
                                    exec_list *const f1696_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1696->then_instructions;

                                       body.emit(assign(r1695, r162E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1696->else_instructions;

                                       ir_expression *const r1698 = nequal(r162E, body.constant(0u));
                                       ir_expression *const r1699 = expr(ir_unop_b2i, r1698);
                                       body.emit(assign(r1695, expr(ir_unop_i2u, r1699), 0x01));


                                    body.instructions = f1696_parent_instructions;
                                    body.emit(f1696);

                                    /* END IF */

                                    body.emit(assign(r1685, r1695, 0x01));

                                    body.emit(assign(r1686, body.constant(0u), 0x01));


                                 body.instructions = f1692_parent_instructions;
                                 body.emit(f1692);

                                 /* END IF */


                              body.instructions = f1690_parent_instructions;
                              body.emit(f1690);

                              /* END IF */

                              body.emit(assign(r1687, body.constant(0u), 0x01));


                           body.instructions = f168C_parent_instructions;
                           body.emit(f168C);

                           /* END IF */

                           ir_expression *const r169A = nequal(r1683, body.constant(0u));
                           ir_expression *const r169B = expr(ir_unop_b2i, r169A);
                           ir_expression *const r169C = expr(ir_unop_i2u, r169B);
                           body.emit(assign(r1685, bit_or(r1685, r169C), 0x01));


                        body.instructions = f168A_parent_instructions;
                        body.emit(f168A);

                        /* END IF */

                        body.emit(assign(r166D, r1687, 0x01));

                        body.emit(assign(r166E, r1686, 0x01));

                        body.emit(assign(r166F, r1685, 0x01));

                        body.emit(assign(r166C, body.constant(int(0)), 0x01));

                        body.emit(assign(r1672, less(r1685, body.constant(0u)), 0x01));


                     body.instructions = f1681_parent_instructions;
                     body.emit(f1681);

                     /* END IF */


                  body.instructions = f167E_parent_instructions;
                  body.emit(f167E);

                  /* END IF */


               body.instructions = f1674_parent_instructions;
               body.emit(f1674);

               /* END IF */

               /* IF CONDITION */
               ir_if *f169D = new(mem_ctx) ir_if(operand(r1670).val);
               exec_list *const f169D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f169D->then_instructions;

                  /* IF CONDITION */
                  ir_if *f169E = new(mem_ctx) ir_if(operand(r1672).val);
                  exec_list *const f169E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f169E->then_instructions;

                     ir_variable *const r169F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r169F, add(r166E, body.constant(1u)), 0x01));

                     ir_expression *const r16A0 = less(r169F, r166E);
                     ir_expression *const r16A1 = expr(ir_unop_b2i, r16A0);
                     ir_expression *const r16A2 = expr(ir_unop_i2u, r16A1);
                     body.emit(assign(r166D, add(r166D, r16A2), 0x01));

                     ir_expression *const r16A3 = equal(r166F, body.constant(0u));
                     ir_expression *const r16A4 = expr(ir_unop_b2i, r16A3);
                     ir_expression *const r16A5 = expr(ir_unop_i2u, r16A4);
                     ir_expression *const r16A6 = add(r166F, r16A5);
                     ir_expression *const r16A7 = bit_and(r16A6, body.constant(1u));
                     ir_expression *const r16A8 = expr(ir_unop_bit_not, r16A7);
                     body.emit(assign(r166E, bit_and(r169F, r16A8), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f169E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r16AA = bit_or(r166D, r166E);
                     ir_expression *const r16AB = equal(r16AA, body.constant(0u));
                     ir_if *f16A9 = new(mem_ctx) ir_if(operand(r16AB).val);
                     exec_list *const f16A9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f16A9->then_instructions;

                        body.emit(assign(r166C, body.constant(int(0)), 0x01));


                     body.instructions = f16A9_parent_instructions;
                     body.emit(f16A9);

                     /* END IF */


                  body.instructions = f169E_parent_instructions;
                  body.emit(f169E);

                  /* END IF */

                  ir_variable *const r16AC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r16AC);
                  ir_expression *const r16AD = lshift(r143F, body.constant(int(31)));
                  ir_expression *const r16AE = expr(ir_unop_i2u, r166C);
                  ir_expression *const r16AF = lshift(r16AE, body.constant(int(20)));
                  ir_expression *const r16B0 = add(r16AD, r16AF);
                  body.emit(assign(r16AC, add(r16B0, r166D), 0x02));

                  body.emit(assign(r16AC, r166E, 0x01));

                  body.emit(assign(r1671, r16AC, 0x03));

                  body.emit(assign(r1670, body.constant(false), 0x01));


               body.instructions = f169D_parent_instructions;
               body.emit(f169D);

               /* END IF */

               body.emit(assign(r15D8, r1671, 0x03));


            body.instructions = f15EE_parent_instructions;
            body.emit(f15EE);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f15EC->else_instructions;

            /* IF CONDITION */
            ir_expression *const r16B2 = less(r15D9, body.constant(int(0)));
            ir_if *f16B1 = new(mem_ctx) ir_if(operand(r16B2).val);
            exec_list *const f16B1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16B1->then_instructions;

               /* IF CONDITION */
               ir_constant *const r16B4 = body.constant(false);
               ir_if *f16B3 = new(mem_ctx) ir_if(operand(r16B4).val);
               exec_list *const f16B3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f16B3->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r16B6 = bit_or(r15DC, r15DD);
                  ir_expression *const r16B7 = nequal(r16B6, body.constant(0u));
                  ir_if *f16B5 = new(mem_ctx) ir_if(operand(r16B7).val);
                  exec_list *const f16B5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f16B5->then_instructions;

                     ir_variable *const r16B8 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r16B8, swizzle_x(r1408), 0x01));

                     ir_variable *const r16B9 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r16B9, body.constant(0u), 0x01));

                     ir_variable *const r16BA = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r16BB = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r16BC = rshift(swizzle_y(r1408), body.constant(int(19)));
                     ir_expression *const r16BD = bit_and(r16BC, body.constant(4095u));
                     ir_expression *const r16BE = equal(r16BD, body.constant(4094u));
                     ir_expression *const r16BF = nequal(swizzle_x(r1408), body.constant(0u));
                     ir_expression *const r16C0 = bit_and(swizzle_y(r1408), body.constant(524287u));
                     ir_expression *const r16C1 = nequal(r16C0, body.constant(0u));
                     ir_expression *const r16C2 = logic_or(r16BF, r16C1);
                     body.emit(assign(r16BB, logic_and(r16BE, r16C2), 0x01));

                     ir_variable *const r16C3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r16C3, body.constant(false), 0x01));

                     body.emit(assign(r16B8, bit_or(swizzle_y(r1408), body.constant(524288u)), 0x02));

                     body.emit(assign(r16B9, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r16C5 = lshift(swizzle_y(r1408), body.constant(int(1)));
                     ir_expression *const r16C6 = lequal(body.constant(4292870144u), r16C5);
                     ir_expression *const r16C7 = nequal(swizzle_x(r1408), body.constant(0u));
                     ir_expression *const r16C8 = bit_and(swizzle_y(r1408), body.constant(1048575u));
                     ir_expression *const r16C9 = nequal(r16C8, body.constant(0u));
                     ir_expression *const r16CA = logic_or(r16C7, r16C9);
                     ir_expression *const r16CB = logic_and(r16C6, r16CA);
                     ir_if *f16C4 = new(mem_ctx) ir_if(operand(r16CB).val);
                     exec_list *const f16C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f16C4->then_instructions;

                        ir_variable *const r16CC = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r16CE = body.constant(false);
                        ir_if *f16CD = new(mem_ctx) ir_if(operand(r16CE).val);
                        exec_list *const f16CD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f16CD->then_instructions;

                           body.emit(assign(r16CC, r16B9, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f16CD->else_instructions;

                           body.emit(assign(r16CC, r16B8, 0x03));


                        body.instructions = f16CD_parent_instructions;
                        body.emit(f16CD);

                        /* END IF */

                        body.emit(assign(r16BA, r16CC, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f16C4->else_instructions;

                        body.emit(assign(r16BA, r16B9, 0x03));


                     body.instructions = f16C4_parent_instructions;
                     body.emit(f16C4);

                     /* END IF */

                     body.emit(assign(r15D8, r16BA, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f16B5->else_instructions;

                     ir_variable *const r16CF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r16CF);
                     ir_expression *const r16D0 = bit_xor(r143F, body.constant(1u));
                     ir_expression *const r16D1 = lshift(r16D0, body.constant(int(31)));
                     body.emit(assign(r16CF, add(r16D1, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r16CF, body.constant(0u), 0x01));

                     body.emit(assign(r15D8, r16CF, 0x03));


                  body.instructions = f16B5_parent_instructions;
                  body.emit(f16B5);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f16B3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r16D3 = equal(r15E1, body.constant(int(0)));
                  ir_if *f16D2 = new(mem_ctx) ir_if(operand(r16D3).val);
                  exec_list *const f16D2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f16D2->then_instructions;

                     body.emit(assign(r15D9, add(r15D9, body.constant(int(1))), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f16D2->else_instructions;

                     body.emit(assign(r15DE, bit_or(r15DE, body.constant(1073741824u)), 0x01));


                  body.instructions = f16D2_parent_instructions;
                  body.emit(f16D2);

                  /* END IF */

                  ir_variable *const r16D4 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r16D4, neg(r15D9), 0x01));

                  ir_variable *const r16D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r16D5);
                  ir_variable *const r16D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r16D6);
                  ir_variable *const r16D7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r16D8 = neg(r16D4);
                  body.emit(assign(r16D7, bit_and(r16D8, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r16DA = equal(r16D4, body.constant(int(0)));
                  ir_if *f16D9 = new(mem_ctx) ir_if(operand(r16DA).val);
                  exec_list *const f16D9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f16D9->then_instructions;

                     body.emit(assign(r16D5, r15E5, 0x01));

                     body.emit(assign(r16D6, r15DE, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f16D9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r16DC = less(r16D4, body.constant(int(32)));
                     ir_if *f16DB = new(mem_ctx) ir_if(operand(r16DC).val);
                     exec_list *const f16DB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f16DB->then_instructions;

                        ir_expression *const r16DD = lshift(r15DE, r16D7);
                        ir_expression *const r16DE = rshift(r15E5, r16D4);
                        ir_expression *const r16DF = bit_or(r16DD, r16DE);
                        ir_expression *const r16E0 = lshift(r15E5, r16D7);
                        ir_expression *const r16E1 = nequal(r16E0, body.constant(0u));
                        ir_expression *const r16E2 = expr(ir_unop_b2i, r16E1);
                        ir_expression *const r16E3 = expr(ir_unop_i2u, r16E2);
                        body.emit(assign(r16D5, bit_or(r16DF, r16E3), 0x01));

                        body.emit(assign(r16D6, rshift(r15DE, r16D4), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f16DB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r16E5 = equal(r16D4, body.constant(int(32)));
                        ir_if *f16E4 = new(mem_ctx) ir_if(operand(r16E5).val);
                        exec_list *const f16E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f16E4->then_instructions;

                           ir_expression *const r16E6 = nequal(r15E5, body.constant(0u));
                           ir_expression *const r16E7 = expr(ir_unop_b2i, r16E6);
                           ir_expression *const r16E8 = expr(ir_unop_i2u, r16E7);
                           body.emit(assign(r16D5, bit_or(r15DE, r16E8), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f16E4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r16EA = less(r16D4, body.constant(int(64)));
                           ir_if *f16E9 = new(mem_ctx) ir_if(operand(r16EA).val);
                           exec_list *const f16E9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f16E9->then_instructions;

                              ir_expression *const r16EB = bit_and(r16D4, body.constant(int(31)));
                              ir_expression *const r16EC = rshift(r15DE, r16EB);
                              ir_expression *const r16ED = lshift(r15DE, r16D7);
                              ir_expression *const r16EE = bit_or(r16ED, r15E5);
                              ir_expression *const r16EF = nequal(r16EE, body.constant(0u));
                              ir_expression *const r16F0 = expr(ir_unop_b2i, r16EF);
                              ir_expression *const r16F1 = expr(ir_unop_i2u, r16F0);
                              body.emit(assign(r16D5, bit_or(r16EC, r16F1), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f16E9->else_instructions;

                              ir_expression *const r16F2 = bit_or(r15DE, r15E5);
                              ir_expression *const r16F3 = nequal(r16F2, body.constant(0u));
                              ir_expression *const r16F4 = expr(ir_unop_b2i, r16F3);
                              body.emit(assign(r16D5, expr(ir_unop_i2u, r16F4), 0x01));


                           body.instructions = f16E9_parent_instructions;
                           body.emit(f16E9);

                           /* END IF */


                        body.instructions = f16E4_parent_instructions;
                        body.emit(f16E4);

                        /* END IF */

                        body.emit(assign(r16D6, body.constant(0u), 0x01));


                     body.instructions = f16DB_parent_instructions;
                     body.emit(f16DB);

                     /* END IF */


                  body.instructions = f16D9_parent_instructions;
                  body.emit(f16D9);

                  /* END IF */

                  body.emit(assign(r15DE, r16D6, 0x01));

                  body.emit(assign(r15DF, r16D5, 0x01));

                  body.emit(assign(r15DC, bit_or(r15DC, body.constant(1073741824u)), 0x01));

                  ir_variable *const r16F5 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r16F6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r16F6, sub(r15DD, r16D5), 0x01));

                  ir_expression *const r16F7 = sub(r15DC, r16D6);
                  ir_expression *const r16F8 = less(r15DD, r16D5);
                  ir_expression *const r16F9 = expr(ir_unop_b2i, r16F8);
                  ir_expression *const r16FA = expr(ir_unop_i2u, r16F9);
                  body.emit(assign(r16F5, sub(r16F7, r16FA), 0x01));

                  body.emit(assign(r15D7, bit_xor(r143F, body.constant(1u)), 0x01));

                  body.emit(assign(r15E0, body.constant(int(1022)), 0x01));

                  ir_variable *const r16FB = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r16FB, body.constant(int(1012)), 0x01));

                  ir_variable *const r16FC = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r16FC, r16F5, 0x01));

                  ir_variable *const r16FD = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r16FD, r16F6, 0x01));

                  ir_variable *const r16FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r16FE);
                  ir_variable *const r16FF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r16FF);
                  /* IF CONDITION */
                  ir_expression *const r1701 = equal(r16F5, body.constant(0u));
                  ir_if *f1700 = new(mem_ctx) ir_if(operand(r1701).val);
                  exec_list *const f1700_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1700->then_instructions;

                     body.emit(assign(r16FC, r16F6, 0x01));

                     body.emit(assign(r16FD, body.constant(0u), 0x01));

                     body.emit(assign(r16FB, body.constant(int(980)), 0x01));


                  body.instructions = f1700_parent_instructions;
                  body.emit(f1700);

                  /* END IF */

                  ir_variable *const r1702 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r1702, r16FC, 0x01));

                  ir_variable *const r1703 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1704 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1704);
                  /* IF CONDITION */
                  ir_expression *const r1706 = equal(r16FC, body.constant(0u));
                  ir_if *f1705 = new(mem_ctx) ir_if(operand(r1706).val);
                  exec_list *const f1705_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1705->then_instructions;

                     body.emit(assign(r1703, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1705->else_instructions;

                     body.emit(assign(r1704, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1708 = bit_and(r16FC, body.constant(4294901760u));
                     ir_expression *const r1709 = equal(r1708, body.constant(0u));
                     ir_if *f1707 = new(mem_ctx) ir_if(operand(r1709).val);
                     exec_list *const f1707_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1707->then_instructions;

                        body.emit(assign(r1704, body.constant(int(16)), 0x01));

                        body.emit(assign(r1702, lshift(r16FC, body.constant(int(16))), 0x01));


                     body.instructions = f1707_parent_instructions;
                     body.emit(f1707);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r170B = bit_and(r1702, body.constant(4278190080u));
                     ir_expression *const r170C = equal(r170B, body.constant(0u));
                     ir_if *f170A = new(mem_ctx) ir_if(operand(r170C).val);
                     exec_list *const f170A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f170A->then_instructions;

                        body.emit(assign(r1704, add(r1704, body.constant(int(8))), 0x01));

                        body.emit(assign(r1702, lshift(r1702, body.constant(int(8))), 0x01));


                     body.instructions = f170A_parent_instructions;
                     body.emit(f170A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r170E = bit_and(r1702, body.constant(4026531840u));
                     ir_expression *const r170F = equal(r170E, body.constant(0u));
                     ir_if *f170D = new(mem_ctx) ir_if(operand(r170F).val);
                     exec_list *const f170D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f170D->then_instructions;

                        body.emit(assign(r1704, add(r1704, body.constant(int(4))), 0x01));

                        body.emit(assign(r1702, lshift(r1702, body.constant(int(4))), 0x01));


                     body.instructions = f170D_parent_instructions;
                     body.emit(f170D);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1711 = bit_and(r1702, body.constant(3221225472u));
                     ir_expression *const r1712 = equal(r1711, body.constant(0u));
                     ir_if *f1710 = new(mem_ctx) ir_if(operand(r1712).val);
                     exec_list *const f1710_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1710->then_instructions;

                        body.emit(assign(r1704, add(r1704, body.constant(int(2))), 0x01));

                        body.emit(assign(r1702, lshift(r1702, body.constant(int(2))), 0x01));


                     body.instructions = f1710_parent_instructions;
                     body.emit(f1710);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1714 = bit_and(r1702, body.constant(2147483648u));
                     ir_expression *const r1715 = equal(r1714, body.constant(0u));
                     ir_if *f1713 = new(mem_ctx) ir_if(operand(r1715).val);
                     exec_list *const f1713_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1713->then_instructions;

                        body.emit(assign(r1704, add(r1704, body.constant(int(1))), 0x01));


                     body.instructions = f1713_parent_instructions;
                     body.emit(f1713);

                     /* END IF */

                     body.emit(assign(r1703, r1704, 0x01));


                  body.instructions = f1705_parent_instructions;
                  body.emit(f1705);

                  /* END IF */

                  body.emit(assign(r16FF, add(r1703, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1717 = lequal(body.constant(int(0)), r16FF);
                  ir_if *f1716 = new(mem_ctx) ir_if(operand(r1717).val);
                  exec_list *const f1716_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1716->then_instructions;

                     body.emit(assign(r16FE, body.constant(0u), 0x01));

                     ir_variable *const r1718 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1718, lshift(r16FD, r16FF), 0x01));

                     ir_variable *const r1719 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r171B = equal(r16FF, body.constant(int(0)));
                     ir_if *f171A = new(mem_ctx) ir_if(operand(r171B).val);
                     exec_list *const f171A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f171A->then_instructions;

                        body.emit(assign(r1719, r16FC, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f171A->else_instructions;

                        ir_expression *const r171C = lshift(r16FC, r16FF);
                        ir_expression *const r171D = neg(r16FF);
                        ir_expression *const r171E = bit_and(r171D, body.constant(int(31)));
                        ir_expression *const r171F = rshift(r16FD, r171E);
                        body.emit(assign(r1719, bit_or(r171C, r171F), 0x01));


                     body.instructions = f171A_parent_instructions;
                     body.emit(f171A);

                     /* END IF */

                     body.emit(assign(r16FC, r1719, 0x01));

                     body.emit(assign(r16FD, r1718, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1716->else_instructions;

                     ir_variable *const r1720 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r1720, body.constant(0u), 0x01));

                     ir_variable *const r1721 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r1721, neg(r16FF), 0x01));

                     ir_variable *const r1722 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r1722);
                     ir_variable *const r1723 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r1723);
                     ir_variable *const r1724 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r1724);
                     ir_variable *const r1725 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r1726 = neg(r1721);
                     body.emit(assign(r1725, bit_and(r1726, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1728 = equal(r1721, body.constant(int(0)));
                     ir_if *f1727 = new(mem_ctx) ir_if(operand(r1728).val);
                     exec_list *const f1727_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1727->then_instructions;

                        body.emit(assign(r1722, r1720, 0x01));

                        body.emit(assign(r1723, r16FD, 0x01));

                        body.emit(assign(r1724, r16FC, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1727->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r172A = less(r1721, body.constant(int(32)));
                        ir_if *f1729 = new(mem_ctx) ir_if(operand(r172A).val);
                        exec_list *const f1729_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1729->then_instructions;

                           body.emit(assign(r1722, lshift(r16FD, r1725), 0x01));

                           ir_expression *const r172B = lshift(r16FC, r1725);
                           ir_expression *const r172C = rshift(r16FD, r1721);
                           body.emit(assign(r1723, bit_or(r172B, r172C), 0x01));

                           body.emit(assign(r1724, rshift(r16FC, r1721), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1729->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r172E = equal(r1721, body.constant(int(32)));
                           ir_if *f172D = new(mem_ctx) ir_if(operand(r172E).val);
                           exec_list *const f172D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f172D->then_instructions;

                              body.emit(assign(r1722, r16FD, 0x01));

                              body.emit(assign(r1723, r16FC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f172D->else_instructions;

                              body.emit(assign(r1720, bit_or(body.constant(0u), r16FD), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1730 = less(r1721, body.constant(int(64)));
                              ir_if *f172F = new(mem_ctx) ir_if(operand(r1730).val);
                              exec_list *const f172F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f172F->then_instructions;

                                 body.emit(assign(r1722, lshift(r16FC, r1725), 0x01));

                                 ir_expression *const r1731 = bit_and(r1721, body.constant(int(31)));
                                 body.emit(assign(r1723, rshift(r16FC, r1731), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f172F->else_instructions;

                                 ir_variable *const r1732 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1734 = equal(r1721, body.constant(int(64)));
                                 ir_if *f1733 = new(mem_ctx) ir_if(operand(r1734).val);
                                 exec_list *const f1733_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1733->then_instructions;

                                    body.emit(assign(r1732, r16FC, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1733->else_instructions;

                                    ir_expression *const r1735 = nequal(r16FC, body.constant(0u));
                                    ir_expression *const r1736 = expr(ir_unop_b2i, r1735);
                                    body.emit(assign(r1732, expr(ir_unop_i2u, r1736), 0x01));


                                 body.instructions = f1733_parent_instructions;
                                 body.emit(f1733);

                                 /* END IF */

                                 body.emit(assign(r1722, r1732, 0x01));

                                 body.emit(assign(r1723, body.constant(0u), 0x01));


                              body.instructions = f172F_parent_instructions;
                              body.emit(f172F);

                              /* END IF */


                           body.instructions = f172D_parent_instructions;
                           body.emit(f172D);

                           /* END IF */

                           body.emit(assign(r1724, body.constant(0u), 0x01));


                        body.instructions = f1729_parent_instructions;
                        body.emit(f1729);

                        /* END IF */

                        ir_expression *const r1737 = nequal(r1720, body.constant(0u));
                        ir_expression *const r1738 = expr(ir_unop_b2i, r1737);
                        ir_expression *const r1739 = expr(ir_unop_i2u, r1738);
                        body.emit(assign(r1722, bit_or(r1722, r1739), 0x01));


                     body.instructions = f1727_parent_instructions;
                     body.emit(f1727);

                     /* END IF */

                     body.emit(assign(r16FC, r1724, 0x01));

                     body.emit(assign(r16FD, r1723, 0x01));

                     body.emit(assign(r16FE, r1722, 0x01));


                  body.instructions = f1716_parent_instructions;
                  body.emit(f1716);

                  /* END IF */

                  body.emit(assign(r16FB, sub(r16FB, r16FF), 0x01));

                  ir_variable *const r173A = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r173A, r16FB, 0x01));

                  ir_variable *const r173B = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r173B, r16FC, 0x01));

                  ir_variable *const r173C = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r173C, r16FD, 0x01));

                  ir_variable *const r173D = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r173D, r16FE, 0x01));

                  ir_variable *const r173E = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r173E, body.constant(true), 0x01));

                  ir_variable *const r173F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r1740 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r1740);
                  ir_expression *const r1741 = expr(ir_unop_u2i, r16FE);
                  body.emit(assign(r1740, less(r1741, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1743 = lequal(body.constant(int(2045)), r16FB);
                  ir_if *f1742 = new(mem_ctx) ir_if(operand(r1743).val);
                  exec_list *const f1742_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1742->then_instructions;

                     ir_variable *const r1744 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1746 = less(body.constant(int(2045)), r16FB);
                     ir_if *f1745 = new(mem_ctx) ir_if(operand(r1746).val);
                     exec_list *const f1745_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1745->then_instructions;

                        body.emit(assign(r1744, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1745->else_instructions;

                        ir_variable *const r1747 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1749 = equal(r16FB, body.constant(int(2045)));
                        ir_if *f1748 = new(mem_ctx) ir_if(operand(r1749).val);
                        exec_list *const f1748_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1748->then_instructions;

                           ir_expression *const r174A = equal(body.constant(2097151u), r16FC);
                           ir_expression *const r174B = equal(body.constant(4294967295u), r16FD);
                           body.emit(assign(r1747, logic_and(r174A, r174B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1748->else_instructions;

                           body.emit(assign(r1747, body.constant(false), 0x01));


                        body.instructions = f1748_parent_instructions;
                        body.emit(f1748);

                        /* END IF */

                        body.emit(assign(r1744, logic_and(r1747, r1740), 0x01));


                     body.instructions = f1745_parent_instructions;
                     body.emit(f1745);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f174C = new(mem_ctx) ir_if(operand(r1744).val);
                     exec_list *const f174C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f174C->then_instructions;

                        ir_variable *const r174D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r174D);
                        ir_expression *const r174E = lshift(r15D7, body.constant(int(31)));
                        body.emit(assign(r174D, add(r174E, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r174D, body.constant(0u), 0x01));

                        body.emit(assign(r173F, r174D, 0x03));

                        body.emit(assign(r173E, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f174C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1750 = less(r16FB, body.constant(int(0)));
                        ir_if *f174F = new(mem_ctx) ir_if(operand(r1750).val);
                        exec_list *const f174F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f174F->then_instructions;

                           ir_variable *const r1751 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r1751, r16FE, 0x01));

                           ir_variable *const r1752 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r1752, neg(r16FB), 0x01));

                           ir_variable *const r1753 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r1753);
                           ir_variable *const r1754 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r1754);
                           ir_variable *const r1755 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r1755);
                           ir_variable *const r1756 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r1757 = neg(r1752);
                           body.emit(assign(r1756, bit_and(r1757, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1759 = equal(r1752, body.constant(int(0)));
                           ir_if *f1758 = new(mem_ctx) ir_if(operand(r1759).val);
                           exec_list *const f1758_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1758->then_instructions;

                              body.emit(assign(r1753, r16FE, 0x01));

                              body.emit(assign(r1754, r16FD, 0x01));

                              body.emit(assign(r1755, r16FC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1758->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r175B = less(r1752, body.constant(int(32)));
                              ir_if *f175A = new(mem_ctx) ir_if(operand(r175B).val);
                              exec_list *const f175A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f175A->then_instructions;

                                 body.emit(assign(r1753, lshift(r16FD, r1756), 0x01));

                                 ir_expression *const r175C = lshift(r16FC, r1756);
                                 ir_expression *const r175D = rshift(r16FD, r1752);
                                 body.emit(assign(r1754, bit_or(r175C, r175D), 0x01));

                                 body.emit(assign(r1755, rshift(r16FC, r1752), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f175A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r175F = equal(r1752, body.constant(int(32)));
                                 ir_if *f175E = new(mem_ctx) ir_if(operand(r175F).val);
                                 exec_list *const f175E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f175E->then_instructions;

                                    body.emit(assign(r1753, r16FD, 0x01));

                                    body.emit(assign(r1754, r16FC, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f175E->else_instructions;

                                    body.emit(assign(r1751, bit_or(r16FE, r16FD), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1761 = less(r1752, body.constant(int(64)));
                                    ir_if *f1760 = new(mem_ctx) ir_if(operand(r1761).val);
                                    exec_list *const f1760_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1760->then_instructions;

                                       body.emit(assign(r1753, lshift(r16FC, r1756), 0x01));

                                       ir_expression *const r1762 = bit_and(r1752, body.constant(int(31)));
                                       body.emit(assign(r1754, rshift(r16FC, r1762), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1760->else_instructions;

                                       ir_variable *const r1763 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r1765 = equal(r1752, body.constant(int(64)));
                                       ir_if *f1764 = new(mem_ctx) ir_if(operand(r1765).val);
                                       exec_list *const f1764_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1764->then_instructions;

                                          body.emit(assign(r1763, r16FC, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1764->else_instructions;

                                          ir_expression *const r1766 = nequal(r16FC, body.constant(0u));
                                          ir_expression *const r1767 = expr(ir_unop_b2i, r1766);
                                          body.emit(assign(r1763, expr(ir_unop_i2u, r1767), 0x01));


                                       body.instructions = f1764_parent_instructions;
                                       body.emit(f1764);

                                       /* END IF */

                                       body.emit(assign(r1753, r1763, 0x01));

                                       body.emit(assign(r1754, body.constant(0u), 0x01));


                                    body.instructions = f1760_parent_instructions;
                                    body.emit(f1760);

                                    /* END IF */


                                 body.instructions = f175E_parent_instructions;
                                 body.emit(f175E);

                                 /* END IF */

                                 body.emit(assign(r1755, body.constant(0u), 0x01));


                              body.instructions = f175A_parent_instructions;
                              body.emit(f175A);

                              /* END IF */

                              ir_expression *const r1768 = nequal(r1751, body.constant(0u));
                              ir_expression *const r1769 = expr(ir_unop_b2i, r1768);
                              ir_expression *const r176A = expr(ir_unop_i2u, r1769);
                              body.emit(assign(r1753, bit_or(r1753, r176A), 0x01));


                           body.instructions = f1758_parent_instructions;
                           body.emit(f1758);

                           /* END IF */

                           body.emit(assign(r173B, r1755, 0x01));

                           body.emit(assign(r173C, r1754, 0x01));

                           body.emit(assign(r173D, r1753, 0x01));

                           body.emit(assign(r173A, body.constant(int(0)), 0x01));

                           body.emit(assign(r1740, less(r1753, body.constant(0u)), 0x01));


                        body.instructions = f174F_parent_instructions;
                        body.emit(f174F);

                        /* END IF */


                     body.instructions = f174C_parent_instructions;
                     body.emit(f174C);

                     /* END IF */


                  body.instructions = f1742_parent_instructions;
                  body.emit(f1742);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f176B = new(mem_ctx) ir_if(operand(r173E).val);
                  exec_list *const f176B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f176B->then_instructions;

                     /* IF CONDITION */
                     ir_if *f176C = new(mem_ctx) ir_if(operand(r1740).val);
                     exec_list *const f176C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f176C->then_instructions;

                        ir_variable *const r176D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r176D, add(r173C, body.constant(1u)), 0x01));

                        ir_expression *const r176E = less(r176D, r173C);
                        ir_expression *const r176F = expr(ir_unop_b2i, r176E);
                        ir_expression *const r1770 = expr(ir_unop_i2u, r176F);
                        body.emit(assign(r173B, add(r173B, r1770), 0x01));

                        ir_expression *const r1771 = equal(r173D, body.constant(0u));
                        ir_expression *const r1772 = expr(ir_unop_b2i, r1771);
                        ir_expression *const r1773 = expr(ir_unop_i2u, r1772);
                        ir_expression *const r1774 = add(r173D, r1773);
                        ir_expression *const r1775 = bit_and(r1774, body.constant(1u));
                        ir_expression *const r1776 = expr(ir_unop_bit_not, r1775);
                        body.emit(assign(r173C, bit_and(r176D, r1776), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f176C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1778 = bit_or(r173B, r173C);
                        ir_expression *const r1779 = equal(r1778, body.constant(0u));
                        ir_if *f1777 = new(mem_ctx) ir_if(operand(r1779).val);
                        exec_list *const f1777_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1777->then_instructions;

                           body.emit(assign(r173A, body.constant(int(0)), 0x01));


                        body.instructions = f1777_parent_instructions;
                        body.emit(f1777);

                        /* END IF */


                     body.instructions = f176C_parent_instructions;
                     body.emit(f176C);

                     /* END IF */

                     ir_variable *const r177A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r177A);
                     ir_expression *const r177B = lshift(r15D7, body.constant(int(31)));
                     ir_expression *const r177C = expr(ir_unop_i2u, r173A);
                     ir_expression *const r177D = lshift(r177C, body.constant(int(20)));
                     ir_expression *const r177E = add(r177B, r177D);
                     body.emit(assign(r177A, add(r177E, r173B), 0x02));

                     body.emit(assign(r177A, r173C, 0x01));

                     body.emit(assign(r173F, r177A, 0x03));

                     body.emit(assign(r173E, body.constant(false), 0x01));


                  body.instructions = f176B_parent_instructions;
                  body.emit(f176B);

                  /* END IF */

                  body.emit(assign(r15D8, r173F, 0x03));


               body.instructions = f16B3_parent_instructions;
               body.emit(f16B3);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16B1->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1780 = equal(r15E1, body.constant(int(2047)));
               ir_if *f177F = new(mem_ctx) ir_if(operand(r1780).val);
               exec_list *const f177F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f177F->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1782 = bit_or(r15DE, r15DF);
                  ir_expression *const r1783 = bit_or(r15DC, r15DD);
                  ir_expression *const r1784 = bit_or(r1782, r1783);
                  ir_expression *const r1785 = nequal(r1784, body.constant(0u));
                  ir_if *f1781 = new(mem_ctx) ir_if(operand(r1785).val);
                  exec_list *const f1781_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1781->then_instructions;

                     ir_variable *const r1786 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1786, swizzle_x(r1408), 0x01));

                     ir_variable *const r1787 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1787, body.constant(0u), 0x01));

                     ir_variable *const r1788 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1789 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r178A = rshift(swizzle_y(r1408), body.constant(int(19)));
                     ir_expression *const r178B = bit_and(r178A, body.constant(4095u));
                     ir_expression *const r178C = equal(r178B, body.constant(4094u));
                     ir_expression *const r178D = nequal(swizzle_x(r1408), body.constant(0u));
                     ir_expression *const r178E = bit_and(swizzle_y(r1408), body.constant(524287u));
                     ir_expression *const r178F = nequal(r178E, body.constant(0u));
                     ir_expression *const r1790 = logic_or(r178D, r178F);
                     body.emit(assign(r1789, logic_and(r178C, r1790), 0x01));

                     ir_variable *const r1791 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r1791, body.constant(false), 0x01));

                     body.emit(assign(r1786, bit_or(swizzle_y(r1408), body.constant(524288u)), 0x02));

                     body.emit(assign(r1787, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1793 = lshift(swizzle_y(r1408), body.constant(int(1)));
                     ir_expression *const r1794 = lequal(body.constant(4292870144u), r1793);
                     ir_expression *const r1795 = nequal(swizzle_x(r1408), body.constant(0u));
                     ir_expression *const r1796 = bit_and(swizzle_y(r1408), body.constant(1048575u));
                     ir_expression *const r1797 = nequal(r1796, body.constant(0u));
                     ir_expression *const r1798 = logic_or(r1795, r1797);
                     ir_expression *const r1799 = logic_and(r1794, r1798);
                     ir_if *f1792 = new(mem_ctx) ir_if(operand(r1799).val);
                     exec_list *const f1792_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1792->then_instructions;

                        ir_variable *const r179A = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r179C = body.constant(false);
                        ir_if *f179B = new(mem_ctx) ir_if(operand(r179C).val);
                        exec_list *const f179B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f179B->then_instructions;

                           body.emit(assign(r179A, r1787, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f179B->else_instructions;

                           body.emit(assign(r179A, r1786, 0x03));


                        body.instructions = f179B_parent_instructions;
                        body.emit(f179B);

                        /* END IF */

                        body.emit(assign(r1788, r179A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1792->else_instructions;

                        body.emit(assign(r1788, r1787, 0x03));


                     body.instructions = f1792_parent_instructions;
                     body.emit(f1792);

                     /* END IF */

                     body.emit(assign(r15D8, r1788, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1781->else_instructions;

                     ir_constant_data r179D_data;
                     memset(&r179D_data, 0, sizeof(ir_constant_data));
                     r179D_data.u[0] = 4294967295;
                     r179D_data.u[1] = 4294967295;
                     ir_constant *const r179D = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r179D_data);
                     body.emit(assign(r15D8, r179D, 0x03));


                  body.instructions = f1781_parent_instructions;
                  body.emit(f1781);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f177F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r179F = equal(r15E1, body.constant(int(0)));
                  ir_if *f179E = new(mem_ctx) ir_if(operand(r179F).val);
                  exec_list *const f179E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f179E->then_instructions;

                     body.emit(assign(r15DB, body.constant(int(1)), 0x01));

                     body.emit(assign(r15DA, body.constant(int(1)), 0x01));


                  body.instructions = f179E_parent_instructions;
                  body.emit(f179E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r17A1 = less(r15DC, r15DE);
                  ir_if *f17A0 = new(mem_ctx) ir_if(operand(r17A1).val);
                  exec_list *const f17A0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17A0->then_instructions;

                     ir_variable *const r17A2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r17A3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r17A3, sub(r15DF, r15DD), 0x01));

                     ir_expression *const r17A4 = sub(r15DE, r15DC);
                     ir_expression *const r17A5 = less(r15DF, r15DD);
                     ir_expression *const r17A6 = expr(ir_unop_b2i, r17A5);
                     ir_expression *const r17A7 = expr(ir_unop_i2u, r17A6);
                     body.emit(assign(r17A2, sub(r17A4, r17A7), 0x01));

                     body.emit(assign(r15E0, add(r15DB, body.constant(int(-1))), 0x01));

                     ir_variable *const r17A8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r17A8, add(r15E0, body.constant(int(-10))), 0x01));

                     ir_variable *const r17A9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r17A9, r17A2, 0x01));

                     ir_variable *const r17AA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r17AA, r17A3, 0x01));

                     ir_variable *const r17AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r17AB);
                     ir_variable *const r17AC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r17AC);
                     /* IF CONDITION */
                     ir_expression *const r17AE = equal(r17A2, body.constant(0u));
                     ir_if *f17AD = new(mem_ctx) ir_if(operand(r17AE).val);
                     exec_list *const f17AD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17AD->then_instructions;

                        body.emit(assign(r17A9, r17A3, 0x01));

                        body.emit(assign(r17AA, body.constant(0u), 0x01));

                        body.emit(assign(r17A8, add(r17A8, body.constant(int(-32))), 0x01));


                     body.instructions = f17AD_parent_instructions;
                     body.emit(f17AD);

                     /* END IF */

                     ir_variable *const r17AF = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r17AF, r17A9, 0x01));

                     ir_variable *const r17B0 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r17B1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r17B1);
                     /* IF CONDITION */
                     ir_expression *const r17B3 = equal(r17A9, body.constant(0u));
                     ir_if *f17B2 = new(mem_ctx) ir_if(operand(r17B3).val);
                     exec_list *const f17B2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17B2->then_instructions;

                        body.emit(assign(r17B0, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f17B2->else_instructions;

                        body.emit(assign(r17B1, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r17B5 = bit_and(r17A9, body.constant(4294901760u));
                        ir_expression *const r17B6 = equal(r17B5, body.constant(0u));
                        ir_if *f17B4 = new(mem_ctx) ir_if(operand(r17B6).val);
                        exec_list *const f17B4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f17B4->then_instructions;

                           body.emit(assign(r17B1, body.constant(int(16)), 0x01));

                           body.emit(assign(r17AF, lshift(r17A9, body.constant(int(16))), 0x01));


                        body.instructions = f17B4_parent_instructions;
                        body.emit(f17B4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r17B8 = bit_and(r17AF, body.constant(4278190080u));
                        ir_expression *const r17B9 = equal(r17B8, body.constant(0u));
                        ir_if *f17B7 = new(mem_ctx) ir_if(operand(r17B9).val);
                        exec_list *const f17B7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f17B7->then_instructions;

                           body.emit(assign(r17B1, add(r17B1, body.constant(int(8))), 0x01));

                           body.emit(assign(r17AF, lshift(r17AF, body.constant(int(8))), 0x01));


                        body.instructions = f17B7_parent_instructions;
                        body.emit(f17B7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r17BB = bit_and(r17AF, body.constant(4026531840u));
                        ir_expression *const r17BC = equal(r17BB, body.constant(0u));
                        ir_if *f17BA = new(mem_ctx) ir_if(operand(r17BC).val);
                        exec_list *const f17BA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f17BA->then_instructions;

                           body.emit(assign(r17B1, add(r17B1, body.constant(int(4))), 0x01));

                           body.emit(assign(r17AF, lshift(r17AF, body.constant(int(4))), 0x01));


                        body.instructions = f17BA_parent_instructions;
                        body.emit(f17BA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r17BE = bit_and(r17AF, body.constant(3221225472u));
                        ir_expression *const r17BF = equal(r17BE, body.constant(0u));
                        ir_if *f17BD = new(mem_ctx) ir_if(operand(r17BF).val);
                        exec_list *const f17BD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f17BD->then_instructions;

                           body.emit(assign(r17B1, add(r17B1, body.constant(int(2))), 0x01));

                           body.emit(assign(r17AF, lshift(r17AF, body.constant(int(2))), 0x01));


                        body.instructions = f17BD_parent_instructions;
                        body.emit(f17BD);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r17C1 = bit_and(r17AF, body.constant(2147483648u));
                        ir_expression *const r17C2 = equal(r17C1, body.constant(0u));
                        ir_if *f17C0 = new(mem_ctx) ir_if(operand(r17C2).val);
                        exec_list *const f17C0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f17C0->then_instructions;

                           body.emit(assign(r17B1, add(r17B1, body.constant(int(1))), 0x01));


                        body.instructions = f17C0_parent_instructions;
                        body.emit(f17C0);

                        /* END IF */

                        body.emit(assign(r17B0, r17B1, 0x01));


                     body.instructions = f17B2_parent_instructions;
                     body.emit(f17B2);

                     /* END IF */

                     body.emit(assign(r17AC, add(r17B0, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r17C4 = lequal(body.constant(int(0)), r17AC);
                     ir_if *f17C3 = new(mem_ctx) ir_if(operand(r17C4).val);
                     exec_list *const f17C3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17C3->then_instructions;

                        body.emit(assign(r17AB, body.constant(0u), 0x01));

                        ir_variable *const r17C5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r17C5, lshift(r17AA, r17AC), 0x01));

                        ir_variable *const r17C6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r17C8 = equal(r17AC, body.constant(int(0)));
                        ir_if *f17C7 = new(mem_ctx) ir_if(operand(r17C8).val);
                        exec_list *const f17C7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f17C7->then_instructions;

                           body.emit(assign(r17C6, r17A9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f17C7->else_instructions;

                           ir_expression *const r17C9 = lshift(r17A9, r17AC);
                           ir_expression *const r17CA = neg(r17AC);
                           ir_expression *const r17CB = bit_and(r17CA, body.constant(int(31)));
                           ir_expression *const r17CC = rshift(r17AA, r17CB);
                           body.emit(assign(r17C6, bit_or(r17C9, r17CC), 0x01));


                        body.instructions = f17C7_parent_instructions;
                        body.emit(f17C7);

                        /* END IF */

                        body.emit(assign(r17A9, r17C6, 0x01));

                        body.emit(assign(r17AA, r17C5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f17C3->else_instructions;

                        ir_variable *const r17CD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r17CD, body.constant(0u), 0x01));

                        ir_variable *const r17CE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r17CE, neg(r17AC), 0x01));

                        ir_variable *const r17CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r17CF);
                        ir_variable *const r17D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r17D0);
                        ir_variable *const r17D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r17D1);
                        ir_variable *const r17D2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r17D3 = neg(r17CE);
                        body.emit(assign(r17D2, bit_and(r17D3, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r17D5 = equal(r17CE, body.constant(int(0)));
                        ir_if *f17D4 = new(mem_ctx) ir_if(operand(r17D5).val);
                        exec_list *const f17D4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f17D4->then_instructions;

                           body.emit(assign(r17CF, r17CD, 0x01));

                           body.emit(assign(r17D0, r17AA, 0x01));

                           body.emit(assign(r17D1, r17A9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f17D4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r17D7 = less(r17CE, body.constant(int(32)));
                           ir_if *f17D6 = new(mem_ctx) ir_if(operand(r17D7).val);
                           exec_list *const f17D6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f17D6->then_instructions;

                              body.emit(assign(r17CF, lshift(r17AA, r17D2), 0x01));

                              ir_expression *const r17D8 = lshift(r17A9, r17D2);
                              ir_expression *const r17D9 = rshift(r17AA, r17CE);
                              body.emit(assign(r17D0, bit_or(r17D8, r17D9), 0x01));

                              body.emit(assign(r17D1, rshift(r17A9, r17CE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f17D6->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r17DB = equal(r17CE, body.constant(int(32)));
                              ir_if *f17DA = new(mem_ctx) ir_if(operand(r17DB).val);
                              exec_list *const f17DA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f17DA->then_instructions;

                                 body.emit(assign(r17CF, r17AA, 0x01));

                                 body.emit(assign(r17D0, r17A9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f17DA->else_instructions;

                                 body.emit(assign(r17CD, bit_or(body.constant(0u), r17AA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r17DD = less(r17CE, body.constant(int(64)));
                                 ir_if *f17DC = new(mem_ctx) ir_if(operand(r17DD).val);
                                 exec_list *const f17DC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f17DC->then_instructions;

                                    body.emit(assign(r17CF, lshift(r17A9, r17D2), 0x01));

                                    ir_expression *const r17DE = bit_and(r17CE, body.constant(int(31)));
                                    body.emit(assign(r17D0, rshift(r17A9, r17DE), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f17DC->else_instructions;

                                    ir_variable *const r17DF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r17E1 = equal(r17CE, body.constant(int(64)));
                                    ir_if *f17E0 = new(mem_ctx) ir_if(operand(r17E1).val);
                                    exec_list *const f17E0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f17E0->then_instructions;

                                       body.emit(assign(r17DF, r17A9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f17E0->else_instructions;

                                       ir_expression *const r17E2 = nequal(r17A9, body.constant(0u));
                                       ir_expression *const r17E3 = expr(ir_unop_b2i, r17E2);
                                       body.emit(assign(r17DF, expr(ir_unop_i2u, r17E3), 0x01));


                                    body.instructions = f17E0_parent_instructions;
                                    body.emit(f17E0);

                                    /* END IF */

                                    body.emit(assign(r17CF, r17DF, 0x01));

                                    body.emit(assign(r17D0, body.constant(0u), 0x01));


                                 body.instructions = f17DC_parent_instructions;
                                 body.emit(f17DC);

                                 /* END IF */


                              body.instructions = f17DA_parent_instructions;
                              body.emit(f17DA);

                              /* END IF */

                              body.emit(assign(r17D1, body.constant(0u), 0x01));


                           body.instructions = f17D6_parent_instructions;
                           body.emit(f17D6);

                           /* END IF */

                           ir_expression *const r17E4 = nequal(r17CD, body.constant(0u));
                           ir_expression *const r17E5 = expr(ir_unop_b2i, r17E4);
                           ir_expression *const r17E6 = expr(ir_unop_i2u, r17E5);
                           body.emit(assign(r17CF, bit_or(r17CF, r17E6), 0x01));


                        body.instructions = f17D4_parent_instructions;
                        body.emit(f17D4);

                        /* END IF */

                        body.emit(assign(r17A9, r17D1, 0x01));

                        body.emit(assign(r17AA, r17D0, 0x01));

                        body.emit(assign(r17AB, r17CF, 0x01));


                     body.instructions = f17C3_parent_instructions;
                     body.emit(f17C3);

                     /* END IF */

                     body.emit(assign(r17A8, sub(r17A8, r17AC), 0x01));

                     ir_variable *const r17E7 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r17E7, r17A8, 0x01));

                     ir_variable *const r17E8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r17E8, r17A9, 0x01));

                     ir_variable *const r17E9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r17E9, r17AA, 0x01));

                     ir_variable *const r17EA = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r17EA, r17AB, 0x01));

                     ir_variable *const r17EB = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r17EB, body.constant(true), 0x01));

                     ir_variable *const r17EC = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r17ED = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r17ED);
                     ir_expression *const r17EE = expr(ir_unop_u2i, r17AB);
                     body.emit(assign(r17ED, less(r17EE, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r17F0 = lequal(body.constant(int(2045)), r17A8);
                     ir_if *f17EF = new(mem_ctx) ir_if(operand(r17F0).val);
                     exec_list *const f17EF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17EF->then_instructions;

                        ir_variable *const r17F1 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r17F3 = less(body.constant(int(2045)), r17A8);
                        ir_if *f17F2 = new(mem_ctx) ir_if(operand(r17F3).val);
                        exec_list *const f17F2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f17F2->then_instructions;

                           body.emit(assign(r17F1, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f17F2->else_instructions;

                           ir_variable *const r17F4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r17F6 = equal(r17A8, body.constant(int(2045)));
                           ir_if *f17F5 = new(mem_ctx) ir_if(operand(r17F6).val);
                           exec_list *const f17F5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f17F5->then_instructions;

                              ir_expression *const r17F7 = equal(body.constant(2097151u), r17A9);
                              ir_expression *const r17F8 = equal(body.constant(4294967295u), r17AA);
                              body.emit(assign(r17F4, logic_and(r17F7, r17F8), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f17F5->else_instructions;

                              body.emit(assign(r17F4, body.constant(false), 0x01));


                           body.instructions = f17F5_parent_instructions;
                           body.emit(f17F5);

                           /* END IF */

                           body.emit(assign(r17F1, logic_and(r17F4, r17ED), 0x01));


                        body.instructions = f17F2_parent_instructions;
                        body.emit(f17F2);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f17F9 = new(mem_ctx) ir_if(operand(r17F1).val);
                        exec_list *const f17F9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f17F9->then_instructions;

                           ir_variable *const r17FA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r17FA);
                           ir_expression *const r17FB = lshift(r15D7, body.constant(int(31)));
                           body.emit(assign(r17FA, add(r17FB, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r17FA, body.constant(0u), 0x01));

                           body.emit(assign(r17EC, r17FA, 0x03));

                           body.emit(assign(r17EB, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f17F9->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r17FD = less(r17A8, body.constant(int(0)));
                           ir_if *f17FC = new(mem_ctx) ir_if(operand(r17FD).val);
                           exec_list *const f17FC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f17FC->then_instructions;

                              ir_variable *const r17FE = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r17FE, r17AB, 0x01));

                              ir_variable *const r17FF = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r17FF, neg(r17A8), 0x01));

                              ir_variable *const r1800 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1800);
                              ir_variable *const r1801 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1801);
                              ir_variable *const r1802 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1802);
                              ir_variable *const r1803 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1804 = neg(r17FF);
                              body.emit(assign(r1803, bit_and(r1804, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1806 = equal(r17FF, body.constant(int(0)));
                              ir_if *f1805 = new(mem_ctx) ir_if(operand(r1806).val);
                              exec_list *const f1805_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1805->then_instructions;

                                 body.emit(assign(r1800, r17AB, 0x01));

                                 body.emit(assign(r1801, r17AA, 0x01));

                                 body.emit(assign(r1802, r17A9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1805->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1808 = less(r17FF, body.constant(int(32)));
                                 ir_if *f1807 = new(mem_ctx) ir_if(operand(r1808).val);
                                 exec_list *const f1807_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1807->then_instructions;

                                    body.emit(assign(r1800, lshift(r17AA, r1803), 0x01));

                                    ir_expression *const r1809 = lshift(r17A9, r1803);
                                    ir_expression *const r180A = rshift(r17AA, r17FF);
                                    body.emit(assign(r1801, bit_or(r1809, r180A), 0x01));

                                    body.emit(assign(r1802, rshift(r17A9, r17FF), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1807->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r180C = equal(r17FF, body.constant(int(32)));
                                    ir_if *f180B = new(mem_ctx) ir_if(operand(r180C).val);
                                    exec_list *const f180B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f180B->then_instructions;

                                       body.emit(assign(r1800, r17AA, 0x01));

                                       body.emit(assign(r1801, r17A9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f180B->else_instructions;

                                       body.emit(assign(r17FE, bit_or(r17AB, r17AA), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r180E = less(r17FF, body.constant(int(64)));
                                       ir_if *f180D = new(mem_ctx) ir_if(operand(r180E).val);
                                       exec_list *const f180D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f180D->then_instructions;

                                          body.emit(assign(r1800, lshift(r17A9, r1803), 0x01));

                                          ir_expression *const r180F = bit_and(r17FF, body.constant(int(31)));
                                          body.emit(assign(r1801, rshift(r17A9, r180F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f180D->else_instructions;

                                          ir_variable *const r1810 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1812 = equal(r17FF, body.constant(int(64)));
                                          ir_if *f1811 = new(mem_ctx) ir_if(operand(r1812).val);
                                          exec_list *const f1811_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1811->then_instructions;

                                             body.emit(assign(r1810, r17A9, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1811->else_instructions;

                                             ir_expression *const r1813 = nequal(r17A9, body.constant(0u));
                                             ir_expression *const r1814 = expr(ir_unop_b2i, r1813);
                                             body.emit(assign(r1810, expr(ir_unop_i2u, r1814), 0x01));


                                          body.instructions = f1811_parent_instructions;
                                          body.emit(f1811);

                                          /* END IF */

                                          body.emit(assign(r1800, r1810, 0x01));

                                          body.emit(assign(r1801, body.constant(0u), 0x01));


                                       body.instructions = f180D_parent_instructions;
                                       body.emit(f180D);

                                       /* END IF */


                                    body.instructions = f180B_parent_instructions;
                                    body.emit(f180B);

                                    /* END IF */

                                    body.emit(assign(r1802, body.constant(0u), 0x01));


                                 body.instructions = f1807_parent_instructions;
                                 body.emit(f1807);

                                 /* END IF */

                                 ir_expression *const r1815 = nequal(r17FE, body.constant(0u));
                                 ir_expression *const r1816 = expr(ir_unop_b2i, r1815);
                                 ir_expression *const r1817 = expr(ir_unop_i2u, r1816);
                                 body.emit(assign(r1800, bit_or(r1800, r1817), 0x01));


                              body.instructions = f1805_parent_instructions;
                              body.emit(f1805);

                              /* END IF */

                              body.emit(assign(r17E8, r1802, 0x01));

                              body.emit(assign(r17E9, r1801, 0x01));

                              body.emit(assign(r17EA, r1800, 0x01));

                              body.emit(assign(r17E7, body.constant(int(0)), 0x01));

                              body.emit(assign(r17ED, less(r1800, body.constant(0u)), 0x01));


                           body.instructions = f17FC_parent_instructions;
                           body.emit(f17FC);

                           /* END IF */


                        body.instructions = f17F9_parent_instructions;
                        body.emit(f17F9);

                        /* END IF */


                     body.instructions = f17EF_parent_instructions;
                     body.emit(f17EF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f1818 = new(mem_ctx) ir_if(operand(r17EB).val);
                     exec_list *const f1818_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1818->then_instructions;

                        /* IF CONDITION */
                        ir_if *f1819 = new(mem_ctx) ir_if(operand(r17ED).val);
                        exec_list *const f1819_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1819->then_instructions;

                           ir_variable *const r181A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r181A, add(r17E9, body.constant(1u)), 0x01));

                           ir_expression *const r181B = less(r181A, r17E9);
                           ir_expression *const r181C = expr(ir_unop_b2i, r181B);
                           ir_expression *const r181D = expr(ir_unop_i2u, r181C);
                           body.emit(assign(r17E8, add(r17E8, r181D), 0x01));

                           ir_expression *const r181E = equal(r17EA, body.constant(0u));
                           ir_expression *const r181F = expr(ir_unop_b2i, r181E);
                           ir_expression *const r1820 = expr(ir_unop_i2u, r181F);
                           ir_expression *const r1821 = add(r17EA, r1820);
                           ir_expression *const r1822 = bit_and(r1821, body.constant(1u));
                           ir_expression *const r1823 = expr(ir_unop_bit_not, r1822);
                           body.emit(assign(r17E9, bit_and(r181A, r1823), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1819->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1825 = bit_or(r17E8, r17E9);
                           ir_expression *const r1826 = equal(r1825, body.constant(0u));
                           ir_if *f1824 = new(mem_ctx) ir_if(operand(r1826).val);
                           exec_list *const f1824_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1824->then_instructions;

                              body.emit(assign(r17E7, body.constant(int(0)), 0x01));


                           body.instructions = f1824_parent_instructions;
                           body.emit(f1824);

                           /* END IF */


                        body.instructions = f1819_parent_instructions;
                        body.emit(f1819);

                        /* END IF */

                        ir_variable *const r1827 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r1827);
                        ir_expression *const r1828 = lshift(r15D7, body.constant(int(31)));
                        ir_expression *const r1829 = expr(ir_unop_i2u, r17E7);
                        ir_expression *const r182A = lshift(r1829, body.constant(int(20)));
                        ir_expression *const r182B = add(r1828, r182A);
                        body.emit(assign(r1827, add(r182B, r17E8), 0x02));

                        body.emit(assign(r1827, r17E9, 0x01));

                        body.emit(assign(r17EC, r1827, 0x03));

                        body.emit(assign(r17EB, body.constant(false), 0x01));


                     body.instructions = f1818_parent_instructions;
                     body.emit(f1818);

                     /* END IF */

                     body.emit(assign(r15D8, r17EC, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17A0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r182D = less(r15DE, r15DC);
                     ir_if *f182C = new(mem_ctx) ir_if(operand(r182D).val);
                     exec_list *const f182C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f182C->then_instructions;

                        ir_variable *const r182E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r182F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r182F, sub(r15DD, r15DF), 0x01));

                        ir_expression *const r1830 = sub(r15DC, r15DE);
                        ir_expression *const r1831 = less(r15DD, r15DF);
                        ir_expression *const r1832 = expr(ir_unop_b2i, r1831);
                        ir_expression *const r1833 = expr(ir_unop_i2u, r1832);
                        body.emit(assign(r182E, sub(r1830, r1833), 0x01));

                        body.emit(assign(r15D7, bit_xor(r15D7, body.constant(1u)), 0x01));

                        body.emit(assign(r15E0, add(r15DA, body.constant(int(-1))), 0x01));

                        ir_variable *const r1834 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r1834, add(r15E0, body.constant(int(-10))), 0x01));

                        ir_variable *const r1835 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r1835, r182E, 0x01));

                        ir_variable *const r1836 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1836, r182F, 0x01));

                        ir_variable *const r1837 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r1837);
                        ir_variable *const r1838 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r1838);
                        /* IF CONDITION */
                        ir_expression *const r183A = equal(r182E, body.constant(0u));
                        ir_if *f1839 = new(mem_ctx) ir_if(operand(r183A).val);
                        exec_list *const f1839_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1839->then_instructions;

                           body.emit(assign(r1835, r182F, 0x01));

                           body.emit(assign(r1836, body.constant(0u), 0x01));

                           body.emit(assign(r1834, add(r1834, body.constant(int(-32))), 0x01));


                        body.instructions = f1839_parent_instructions;
                        body.emit(f1839);

                        /* END IF */

                        ir_variable *const r183B = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r183B, r1835, 0x01));

                        ir_variable *const r183C = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r183D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r183D);
                        /* IF CONDITION */
                        ir_expression *const r183F = equal(r1835, body.constant(0u));
                        ir_if *f183E = new(mem_ctx) ir_if(operand(r183F).val);
                        exec_list *const f183E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f183E->then_instructions;

                           body.emit(assign(r183C, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f183E->else_instructions;

                           body.emit(assign(r183D, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1841 = bit_and(r1835, body.constant(4294901760u));
                           ir_expression *const r1842 = equal(r1841, body.constant(0u));
                           ir_if *f1840 = new(mem_ctx) ir_if(operand(r1842).val);
                           exec_list *const f1840_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1840->then_instructions;

                              body.emit(assign(r183D, body.constant(int(16)), 0x01));

                              body.emit(assign(r183B, lshift(r1835, body.constant(int(16))), 0x01));


                           body.instructions = f1840_parent_instructions;
                           body.emit(f1840);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1844 = bit_and(r183B, body.constant(4278190080u));
                           ir_expression *const r1845 = equal(r1844, body.constant(0u));
                           ir_if *f1843 = new(mem_ctx) ir_if(operand(r1845).val);
                           exec_list *const f1843_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1843->then_instructions;

                              body.emit(assign(r183D, add(r183D, body.constant(int(8))), 0x01));

                              body.emit(assign(r183B, lshift(r183B, body.constant(int(8))), 0x01));


                           body.instructions = f1843_parent_instructions;
                           body.emit(f1843);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1847 = bit_and(r183B, body.constant(4026531840u));
                           ir_expression *const r1848 = equal(r1847, body.constant(0u));
                           ir_if *f1846 = new(mem_ctx) ir_if(operand(r1848).val);
                           exec_list *const f1846_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1846->then_instructions;

                              body.emit(assign(r183D, add(r183D, body.constant(int(4))), 0x01));

                              body.emit(assign(r183B, lshift(r183B, body.constant(int(4))), 0x01));


                           body.instructions = f1846_parent_instructions;
                           body.emit(f1846);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r184A = bit_and(r183B, body.constant(3221225472u));
                           ir_expression *const r184B = equal(r184A, body.constant(0u));
                           ir_if *f1849 = new(mem_ctx) ir_if(operand(r184B).val);
                           exec_list *const f1849_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1849->then_instructions;

                              body.emit(assign(r183D, add(r183D, body.constant(int(2))), 0x01));

                              body.emit(assign(r183B, lshift(r183B, body.constant(int(2))), 0x01));


                           body.instructions = f1849_parent_instructions;
                           body.emit(f1849);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r184D = bit_and(r183B, body.constant(2147483648u));
                           ir_expression *const r184E = equal(r184D, body.constant(0u));
                           ir_if *f184C = new(mem_ctx) ir_if(operand(r184E).val);
                           exec_list *const f184C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f184C->then_instructions;

                              body.emit(assign(r183D, add(r183D, body.constant(int(1))), 0x01));


                           body.instructions = f184C_parent_instructions;
                           body.emit(f184C);

                           /* END IF */

                           body.emit(assign(r183C, r183D, 0x01));


                        body.instructions = f183E_parent_instructions;
                        body.emit(f183E);

                        /* END IF */

                        body.emit(assign(r1838, add(r183C, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1850 = lequal(body.constant(int(0)), r1838);
                        ir_if *f184F = new(mem_ctx) ir_if(operand(r1850).val);
                        exec_list *const f184F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f184F->then_instructions;

                           body.emit(assign(r1837, body.constant(0u), 0x01));

                           ir_variable *const r1851 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1851, lshift(r1836, r1838), 0x01));

                           ir_variable *const r1852 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1854 = equal(r1838, body.constant(int(0)));
                           ir_if *f1853 = new(mem_ctx) ir_if(operand(r1854).val);
                           exec_list *const f1853_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1853->then_instructions;

                              body.emit(assign(r1852, r1835, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1853->else_instructions;

                              ir_expression *const r1855 = lshift(r1835, r1838);
                              ir_expression *const r1856 = neg(r1838);
                              ir_expression *const r1857 = bit_and(r1856, body.constant(int(31)));
                              ir_expression *const r1858 = rshift(r1836, r1857);
                              body.emit(assign(r1852, bit_or(r1855, r1858), 0x01));


                           body.instructions = f1853_parent_instructions;
                           body.emit(f1853);

                           /* END IF */

                           body.emit(assign(r1835, r1852, 0x01));

                           body.emit(assign(r1836, r1851, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f184F->else_instructions;

                           ir_variable *const r1859 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r1859, body.constant(0u), 0x01));

                           ir_variable *const r185A = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r185A, neg(r1838), 0x01));

                           ir_variable *const r185B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r185B);
                           ir_variable *const r185C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r185C);
                           ir_variable *const r185D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r185D);
                           ir_variable *const r185E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r185F = neg(r185A);
                           body.emit(assign(r185E, bit_and(r185F, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1861 = equal(r185A, body.constant(int(0)));
                           ir_if *f1860 = new(mem_ctx) ir_if(operand(r1861).val);
                           exec_list *const f1860_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1860->then_instructions;

                              body.emit(assign(r185B, r1859, 0x01));

                              body.emit(assign(r185C, r1836, 0x01));

                              body.emit(assign(r185D, r1835, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1860->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1863 = less(r185A, body.constant(int(32)));
                              ir_if *f1862 = new(mem_ctx) ir_if(operand(r1863).val);
                              exec_list *const f1862_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1862->then_instructions;

                                 body.emit(assign(r185B, lshift(r1836, r185E), 0x01));

                                 ir_expression *const r1864 = lshift(r1835, r185E);
                                 ir_expression *const r1865 = rshift(r1836, r185A);
                                 body.emit(assign(r185C, bit_or(r1864, r1865), 0x01));

                                 body.emit(assign(r185D, rshift(r1835, r185A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1862->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1867 = equal(r185A, body.constant(int(32)));
                                 ir_if *f1866 = new(mem_ctx) ir_if(operand(r1867).val);
                                 exec_list *const f1866_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1866->then_instructions;

                                    body.emit(assign(r185B, r1836, 0x01));

                                    body.emit(assign(r185C, r1835, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1866->else_instructions;

                                    body.emit(assign(r1859, bit_or(body.constant(0u), r1836), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1869 = less(r185A, body.constant(int(64)));
                                    ir_if *f1868 = new(mem_ctx) ir_if(operand(r1869).val);
                                    exec_list *const f1868_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1868->then_instructions;

                                       body.emit(assign(r185B, lshift(r1835, r185E), 0x01));

                                       ir_expression *const r186A = bit_and(r185A, body.constant(int(31)));
                                       body.emit(assign(r185C, rshift(r1835, r186A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1868->else_instructions;

                                       ir_variable *const r186B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r186D = equal(r185A, body.constant(int(64)));
                                       ir_if *f186C = new(mem_ctx) ir_if(operand(r186D).val);
                                       exec_list *const f186C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f186C->then_instructions;

                                          body.emit(assign(r186B, r1835, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f186C->else_instructions;

                                          ir_expression *const r186E = nequal(r1835, body.constant(0u));
                                          ir_expression *const r186F = expr(ir_unop_b2i, r186E);
                                          body.emit(assign(r186B, expr(ir_unop_i2u, r186F), 0x01));


                                       body.instructions = f186C_parent_instructions;
                                       body.emit(f186C);

                                       /* END IF */

                                       body.emit(assign(r185B, r186B, 0x01));

                                       body.emit(assign(r185C, body.constant(0u), 0x01));


                                    body.instructions = f1868_parent_instructions;
                                    body.emit(f1868);

                                    /* END IF */


                                 body.instructions = f1866_parent_instructions;
                                 body.emit(f1866);

                                 /* END IF */

                                 body.emit(assign(r185D, body.constant(0u), 0x01));


                              body.instructions = f1862_parent_instructions;
                              body.emit(f1862);

                              /* END IF */

                              ir_expression *const r1870 = nequal(r1859, body.constant(0u));
                              ir_expression *const r1871 = expr(ir_unop_b2i, r1870);
                              ir_expression *const r1872 = expr(ir_unop_i2u, r1871);
                              body.emit(assign(r185B, bit_or(r185B, r1872), 0x01));


                           body.instructions = f1860_parent_instructions;
                           body.emit(f1860);

                           /* END IF */

                           body.emit(assign(r1835, r185D, 0x01));

                           body.emit(assign(r1836, r185C, 0x01));

                           body.emit(assign(r1837, r185B, 0x01));


                        body.instructions = f184F_parent_instructions;
                        body.emit(f184F);

                        /* END IF */

                        body.emit(assign(r1834, sub(r1834, r1838), 0x01));

                        ir_variable *const r1873 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r1873, r1834, 0x01));

                        ir_variable *const r1874 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r1874, r1835, 0x01));

                        ir_variable *const r1875 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1875, r1836, 0x01));

                        ir_variable *const r1876 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r1876, r1837, 0x01));

                        ir_variable *const r1877 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r1877, body.constant(true), 0x01));

                        ir_variable *const r1878 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r1879 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r1879);
                        ir_expression *const r187A = expr(ir_unop_u2i, r1837);
                        body.emit(assign(r1879, less(r187A, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r187C = lequal(body.constant(int(2045)), r1834);
                        ir_if *f187B = new(mem_ctx) ir_if(operand(r187C).val);
                        exec_list *const f187B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f187B->then_instructions;

                           ir_variable *const r187D = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r187F = less(body.constant(int(2045)), r1834);
                           ir_if *f187E = new(mem_ctx) ir_if(operand(r187F).val);
                           exec_list *const f187E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f187E->then_instructions;

                              body.emit(assign(r187D, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f187E->else_instructions;

                              ir_variable *const r1880 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1882 = equal(r1834, body.constant(int(2045)));
                              ir_if *f1881 = new(mem_ctx) ir_if(operand(r1882).val);
                              exec_list *const f1881_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1881->then_instructions;

                                 ir_expression *const r1883 = equal(body.constant(2097151u), r1835);
                                 ir_expression *const r1884 = equal(body.constant(4294967295u), r1836);
                                 body.emit(assign(r1880, logic_and(r1883, r1884), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1881->else_instructions;

                                 body.emit(assign(r1880, body.constant(false), 0x01));


                              body.instructions = f1881_parent_instructions;
                              body.emit(f1881);

                              /* END IF */

                              body.emit(assign(r187D, logic_and(r1880, r1879), 0x01));


                           body.instructions = f187E_parent_instructions;
                           body.emit(f187E);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1885 = new(mem_ctx) ir_if(operand(r187D).val);
                           exec_list *const f1885_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1885->then_instructions;

                              ir_variable *const r1886 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1886);
                              ir_expression *const r1887 = lshift(r15D7, body.constant(int(31)));
                              body.emit(assign(r1886, add(r1887, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r1886, body.constant(0u), 0x01));

                              body.emit(assign(r1878, r1886, 0x03));

                              body.emit(assign(r1877, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1885->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1889 = less(r1834, body.constant(int(0)));
                              ir_if *f1888 = new(mem_ctx) ir_if(operand(r1889).val);
                              exec_list *const f1888_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1888->then_instructions;

                                 ir_variable *const r188A = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r188A, r1837, 0x01));

                                 ir_variable *const r188B = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r188B, neg(r1834), 0x01));

                                 ir_variable *const r188C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r188C);
                                 ir_variable *const r188D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r188D);
                                 ir_variable *const r188E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r188E);
                                 ir_variable *const r188F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r1890 = neg(r188B);
                                 body.emit(assign(r188F, bit_and(r1890, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1892 = equal(r188B, body.constant(int(0)));
                                 ir_if *f1891 = new(mem_ctx) ir_if(operand(r1892).val);
                                 exec_list *const f1891_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1891->then_instructions;

                                    body.emit(assign(r188C, r1837, 0x01));

                                    body.emit(assign(r188D, r1836, 0x01));

                                    body.emit(assign(r188E, r1835, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1891->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1894 = less(r188B, body.constant(int(32)));
                                    ir_if *f1893 = new(mem_ctx) ir_if(operand(r1894).val);
                                    exec_list *const f1893_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1893->then_instructions;

                                       body.emit(assign(r188C, lshift(r1836, r188F), 0x01));

                                       ir_expression *const r1895 = lshift(r1835, r188F);
                                       ir_expression *const r1896 = rshift(r1836, r188B);
                                       body.emit(assign(r188D, bit_or(r1895, r1896), 0x01));

                                       body.emit(assign(r188E, rshift(r1835, r188B), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1893->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1898 = equal(r188B, body.constant(int(32)));
                                       ir_if *f1897 = new(mem_ctx) ir_if(operand(r1898).val);
                                       exec_list *const f1897_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1897->then_instructions;

                                          body.emit(assign(r188C, r1836, 0x01));

                                          body.emit(assign(r188D, r1835, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1897->else_instructions;

                                          body.emit(assign(r188A, bit_or(r1837, r1836), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r189A = less(r188B, body.constant(int(64)));
                                          ir_if *f1899 = new(mem_ctx) ir_if(operand(r189A).val);
                                          exec_list *const f1899_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1899->then_instructions;

                                             body.emit(assign(r188C, lshift(r1835, r188F), 0x01));

                                             ir_expression *const r189B = bit_and(r188B, body.constant(int(31)));
                                             body.emit(assign(r188D, rshift(r1835, r189B), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1899->else_instructions;

                                             ir_variable *const r189C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r189E = equal(r188B, body.constant(int(64)));
                                             ir_if *f189D = new(mem_ctx) ir_if(operand(r189E).val);
                                             exec_list *const f189D_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f189D->then_instructions;

                                                body.emit(assign(r189C, r1835, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f189D->else_instructions;

                                                ir_expression *const r189F = nequal(r1835, body.constant(0u));
                                                ir_expression *const r18A0 = expr(ir_unop_b2i, r189F);
                                                body.emit(assign(r189C, expr(ir_unop_i2u, r18A0), 0x01));


                                             body.instructions = f189D_parent_instructions;
                                             body.emit(f189D);

                                             /* END IF */

                                             body.emit(assign(r188C, r189C, 0x01));

                                             body.emit(assign(r188D, body.constant(0u), 0x01));


                                          body.instructions = f1899_parent_instructions;
                                          body.emit(f1899);

                                          /* END IF */


                                       body.instructions = f1897_parent_instructions;
                                       body.emit(f1897);

                                       /* END IF */

                                       body.emit(assign(r188E, body.constant(0u), 0x01));


                                    body.instructions = f1893_parent_instructions;
                                    body.emit(f1893);

                                    /* END IF */

                                    ir_expression *const r18A1 = nequal(r188A, body.constant(0u));
                                    ir_expression *const r18A2 = expr(ir_unop_b2i, r18A1);
                                    ir_expression *const r18A3 = expr(ir_unop_i2u, r18A2);
                                    body.emit(assign(r188C, bit_or(r188C, r18A3), 0x01));


                                 body.instructions = f1891_parent_instructions;
                                 body.emit(f1891);

                                 /* END IF */

                                 body.emit(assign(r1874, r188E, 0x01));

                                 body.emit(assign(r1875, r188D, 0x01));

                                 body.emit(assign(r1876, r188C, 0x01));

                                 body.emit(assign(r1873, body.constant(int(0)), 0x01));

                                 body.emit(assign(r1879, less(r188C, body.constant(0u)), 0x01));


                              body.instructions = f1888_parent_instructions;
                              body.emit(f1888);

                              /* END IF */


                           body.instructions = f1885_parent_instructions;
                           body.emit(f1885);

                           /* END IF */


                        body.instructions = f187B_parent_instructions;
                        body.emit(f187B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f18A4 = new(mem_ctx) ir_if(operand(r1877).val);
                        exec_list *const f18A4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f18A4->then_instructions;

                           /* IF CONDITION */
                           ir_if *f18A5 = new(mem_ctx) ir_if(operand(r1879).val);
                           exec_list *const f18A5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f18A5->then_instructions;

                              ir_variable *const r18A6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r18A6, add(r1875, body.constant(1u)), 0x01));

                              ir_expression *const r18A7 = less(r18A6, r1875);
                              ir_expression *const r18A8 = expr(ir_unop_b2i, r18A7);
                              ir_expression *const r18A9 = expr(ir_unop_i2u, r18A8);
                              body.emit(assign(r1874, add(r1874, r18A9), 0x01));

                              ir_expression *const r18AA = equal(r1876, body.constant(0u));
                              ir_expression *const r18AB = expr(ir_unop_b2i, r18AA);
                              ir_expression *const r18AC = expr(ir_unop_i2u, r18AB);
                              ir_expression *const r18AD = add(r1876, r18AC);
                              ir_expression *const r18AE = bit_and(r18AD, body.constant(1u));
                              ir_expression *const r18AF = expr(ir_unop_bit_not, r18AE);
                              body.emit(assign(r1875, bit_and(r18A6, r18AF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f18A5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r18B1 = bit_or(r1874, r1875);
                              ir_expression *const r18B2 = equal(r18B1, body.constant(0u));
                              ir_if *f18B0 = new(mem_ctx) ir_if(operand(r18B2).val);
                              exec_list *const f18B0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18B0->then_instructions;

                                 body.emit(assign(r1873, body.constant(int(0)), 0x01));


                              body.instructions = f18B0_parent_instructions;
                              body.emit(f18B0);

                              /* END IF */


                           body.instructions = f18A5_parent_instructions;
                           body.emit(f18A5);

                           /* END IF */

                           ir_variable *const r18B3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r18B3);
                           ir_expression *const r18B4 = lshift(r15D7, body.constant(int(31)));
                           ir_expression *const r18B5 = expr(ir_unop_i2u, r1873);
                           ir_expression *const r18B6 = lshift(r18B5, body.constant(int(20)));
                           ir_expression *const r18B7 = add(r18B4, r18B6);
                           body.emit(assign(r18B3, add(r18B7, r1874), 0x02));

                           body.emit(assign(r18B3, r1875, 0x01));

                           body.emit(assign(r1878, r18B3, 0x03));

                           body.emit(assign(r1877, body.constant(false), 0x01));


                        body.instructions = f18A4_parent_instructions;
                        body.emit(f18A4);

                        /* END IF */

                        body.emit(assign(r15D8, r1878, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f182C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r18B9 = less(r15DD, r15DF);
                        ir_if *f18B8 = new(mem_ctx) ir_if(operand(r18B9).val);
                        exec_list *const f18B8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f18B8->then_instructions;

                           ir_variable *const r18BA = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r18BB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r18BB, sub(r15DF, r15DD), 0x01));

                           ir_expression *const r18BC = sub(r15DE, r15DC);
                           ir_expression *const r18BD = less(r15DF, r15DD);
                           ir_expression *const r18BE = expr(ir_unop_b2i, r18BD);
                           ir_expression *const r18BF = expr(ir_unop_i2u, r18BE);
                           body.emit(assign(r18BA, sub(r18BC, r18BF), 0x01));

                           body.emit(assign(r15E0, add(r15DB, body.constant(int(-1))), 0x01));

                           ir_variable *const r18C0 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r18C0, add(r15E0, body.constant(int(-10))), 0x01));

                           ir_variable *const r18C1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r18C1, r18BA, 0x01));

                           ir_variable *const r18C2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r18C2, r18BB, 0x01));

                           ir_variable *const r18C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r18C3);
                           ir_variable *const r18C4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r18C4);
                           /* IF CONDITION */
                           ir_expression *const r18C6 = equal(r18BA, body.constant(0u));
                           ir_if *f18C5 = new(mem_ctx) ir_if(operand(r18C6).val);
                           exec_list *const f18C5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f18C5->then_instructions;

                              body.emit(assign(r18C1, r18BB, 0x01));

                              body.emit(assign(r18C2, body.constant(0u), 0x01));

                              body.emit(assign(r18C0, add(r18C0, body.constant(int(-32))), 0x01));


                           body.instructions = f18C5_parent_instructions;
                           body.emit(f18C5);

                           /* END IF */

                           ir_variable *const r18C7 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r18C7, r18C1, 0x01));

                           ir_variable *const r18C8 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r18C9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r18C9);
                           /* IF CONDITION */
                           ir_expression *const r18CB = equal(r18C1, body.constant(0u));
                           ir_if *f18CA = new(mem_ctx) ir_if(operand(r18CB).val);
                           exec_list *const f18CA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f18CA->then_instructions;

                              body.emit(assign(r18C8, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f18CA->else_instructions;

                              body.emit(assign(r18C9, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r18CD = bit_and(r18C1, body.constant(4294901760u));
                              ir_expression *const r18CE = equal(r18CD, body.constant(0u));
                              ir_if *f18CC = new(mem_ctx) ir_if(operand(r18CE).val);
                              exec_list *const f18CC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18CC->then_instructions;

                                 body.emit(assign(r18C9, body.constant(int(16)), 0x01));

                                 body.emit(assign(r18C7, lshift(r18C1, body.constant(int(16))), 0x01));


                              body.instructions = f18CC_parent_instructions;
                              body.emit(f18CC);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r18D0 = bit_and(r18C7, body.constant(4278190080u));
                              ir_expression *const r18D1 = equal(r18D0, body.constant(0u));
                              ir_if *f18CF = new(mem_ctx) ir_if(operand(r18D1).val);
                              exec_list *const f18CF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18CF->then_instructions;

                                 body.emit(assign(r18C9, add(r18C9, body.constant(int(8))), 0x01));

                                 body.emit(assign(r18C7, lshift(r18C7, body.constant(int(8))), 0x01));


                              body.instructions = f18CF_parent_instructions;
                              body.emit(f18CF);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r18D3 = bit_and(r18C7, body.constant(4026531840u));
                              ir_expression *const r18D4 = equal(r18D3, body.constant(0u));
                              ir_if *f18D2 = new(mem_ctx) ir_if(operand(r18D4).val);
                              exec_list *const f18D2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18D2->then_instructions;

                                 body.emit(assign(r18C9, add(r18C9, body.constant(int(4))), 0x01));

                                 body.emit(assign(r18C7, lshift(r18C7, body.constant(int(4))), 0x01));


                              body.instructions = f18D2_parent_instructions;
                              body.emit(f18D2);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r18D6 = bit_and(r18C7, body.constant(3221225472u));
                              ir_expression *const r18D7 = equal(r18D6, body.constant(0u));
                              ir_if *f18D5 = new(mem_ctx) ir_if(operand(r18D7).val);
                              exec_list *const f18D5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18D5->then_instructions;

                                 body.emit(assign(r18C9, add(r18C9, body.constant(int(2))), 0x01));

                                 body.emit(assign(r18C7, lshift(r18C7, body.constant(int(2))), 0x01));


                              body.instructions = f18D5_parent_instructions;
                              body.emit(f18D5);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r18D9 = bit_and(r18C7, body.constant(2147483648u));
                              ir_expression *const r18DA = equal(r18D9, body.constant(0u));
                              ir_if *f18D8 = new(mem_ctx) ir_if(operand(r18DA).val);
                              exec_list *const f18D8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18D8->then_instructions;

                                 body.emit(assign(r18C9, add(r18C9, body.constant(int(1))), 0x01));


                              body.instructions = f18D8_parent_instructions;
                              body.emit(f18D8);

                              /* END IF */

                              body.emit(assign(r18C8, r18C9, 0x01));


                           body.instructions = f18CA_parent_instructions;
                           body.emit(f18CA);

                           /* END IF */

                           body.emit(assign(r18C4, add(r18C8, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r18DC = lequal(body.constant(int(0)), r18C4);
                           ir_if *f18DB = new(mem_ctx) ir_if(operand(r18DC).val);
                           exec_list *const f18DB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f18DB->then_instructions;

                              body.emit(assign(r18C3, body.constant(0u), 0x01));

                              ir_variable *const r18DD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r18DD, lshift(r18C2, r18C4), 0x01));

                              ir_variable *const r18DE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r18E0 = equal(r18C4, body.constant(int(0)));
                              ir_if *f18DF = new(mem_ctx) ir_if(operand(r18E0).val);
                              exec_list *const f18DF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18DF->then_instructions;

                                 body.emit(assign(r18DE, r18C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f18DF->else_instructions;

                                 ir_expression *const r18E1 = lshift(r18C1, r18C4);
                                 ir_expression *const r18E2 = neg(r18C4);
                                 ir_expression *const r18E3 = bit_and(r18E2, body.constant(int(31)));
                                 ir_expression *const r18E4 = rshift(r18C2, r18E3);
                                 body.emit(assign(r18DE, bit_or(r18E1, r18E4), 0x01));


                              body.instructions = f18DF_parent_instructions;
                              body.emit(f18DF);

                              /* END IF */

                              body.emit(assign(r18C1, r18DE, 0x01));

                              body.emit(assign(r18C2, r18DD, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f18DB->else_instructions;

                              ir_variable *const r18E5 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r18E5, body.constant(0u), 0x01));

                              ir_variable *const r18E6 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r18E6, neg(r18C4), 0x01));

                              ir_variable *const r18E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r18E7);
                              ir_variable *const r18E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r18E8);
                              ir_variable *const r18E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r18E9);
                              ir_variable *const r18EA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r18EB = neg(r18E6);
                              body.emit(assign(r18EA, bit_and(r18EB, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r18ED = equal(r18E6, body.constant(int(0)));
                              ir_if *f18EC = new(mem_ctx) ir_if(operand(r18ED).val);
                              exec_list *const f18EC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18EC->then_instructions;

                                 body.emit(assign(r18E7, r18E5, 0x01));

                                 body.emit(assign(r18E8, r18C2, 0x01));

                                 body.emit(assign(r18E9, r18C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f18EC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r18EF = less(r18E6, body.constant(int(32)));
                                 ir_if *f18EE = new(mem_ctx) ir_if(operand(r18EF).val);
                                 exec_list *const f18EE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f18EE->then_instructions;

                                    body.emit(assign(r18E7, lshift(r18C2, r18EA), 0x01));

                                    ir_expression *const r18F0 = lshift(r18C1, r18EA);
                                    ir_expression *const r18F1 = rshift(r18C2, r18E6);
                                    body.emit(assign(r18E8, bit_or(r18F0, r18F1), 0x01));

                                    body.emit(assign(r18E9, rshift(r18C1, r18E6), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f18EE->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r18F3 = equal(r18E6, body.constant(int(32)));
                                    ir_if *f18F2 = new(mem_ctx) ir_if(operand(r18F3).val);
                                    exec_list *const f18F2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f18F2->then_instructions;

                                       body.emit(assign(r18E7, r18C2, 0x01));

                                       body.emit(assign(r18E8, r18C1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f18F2->else_instructions;

                                       body.emit(assign(r18E5, bit_or(body.constant(0u), r18C2), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r18F5 = less(r18E6, body.constant(int(64)));
                                       ir_if *f18F4 = new(mem_ctx) ir_if(operand(r18F5).val);
                                       exec_list *const f18F4_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f18F4->then_instructions;

                                          body.emit(assign(r18E7, lshift(r18C1, r18EA), 0x01));

                                          ir_expression *const r18F6 = bit_and(r18E6, body.constant(int(31)));
                                          body.emit(assign(r18E8, rshift(r18C1, r18F6), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f18F4->else_instructions;

                                          ir_variable *const r18F7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r18F9 = equal(r18E6, body.constant(int(64)));
                                          ir_if *f18F8 = new(mem_ctx) ir_if(operand(r18F9).val);
                                          exec_list *const f18F8_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f18F8->then_instructions;

                                             body.emit(assign(r18F7, r18C1, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f18F8->else_instructions;

                                             ir_expression *const r18FA = nequal(r18C1, body.constant(0u));
                                             ir_expression *const r18FB = expr(ir_unop_b2i, r18FA);
                                             body.emit(assign(r18F7, expr(ir_unop_i2u, r18FB), 0x01));


                                          body.instructions = f18F8_parent_instructions;
                                          body.emit(f18F8);

                                          /* END IF */

                                          body.emit(assign(r18E7, r18F7, 0x01));

                                          body.emit(assign(r18E8, body.constant(0u), 0x01));


                                       body.instructions = f18F4_parent_instructions;
                                       body.emit(f18F4);

                                       /* END IF */


                                    body.instructions = f18F2_parent_instructions;
                                    body.emit(f18F2);

                                    /* END IF */

                                    body.emit(assign(r18E9, body.constant(0u), 0x01));


                                 body.instructions = f18EE_parent_instructions;
                                 body.emit(f18EE);

                                 /* END IF */

                                 ir_expression *const r18FC = nequal(r18E5, body.constant(0u));
                                 ir_expression *const r18FD = expr(ir_unop_b2i, r18FC);
                                 ir_expression *const r18FE = expr(ir_unop_i2u, r18FD);
                                 body.emit(assign(r18E7, bit_or(r18E7, r18FE), 0x01));


                              body.instructions = f18EC_parent_instructions;
                              body.emit(f18EC);

                              /* END IF */

                              body.emit(assign(r18C1, r18E9, 0x01));

                              body.emit(assign(r18C2, r18E8, 0x01));

                              body.emit(assign(r18C3, r18E7, 0x01));


                           body.instructions = f18DB_parent_instructions;
                           body.emit(f18DB);

                           /* END IF */

                           body.emit(assign(r18C0, sub(r18C0, r18C4), 0x01));

                           ir_variable *const r18FF = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r18FF, r18C0, 0x01));

                           ir_variable *const r1900 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1900, r18C1, 0x01));

                           ir_variable *const r1901 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1901, r18C2, 0x01));

                           ir_variable *const r1902 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r1902, r18C3, 0x01));

                           ir_variable *const r1903 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r1903, body.constant(true), 0x01));

                           ir_variable *const r1904 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r1905 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r1905);
                           ir_expression *const r1906 = expr(ir_unop_u2i, r18C3);
                           body.emit(assign(r1905, less(r1906, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1908 = lequal(body.constant(int(2045)), r18C0);
                           ir_if *f1907 = new(mem_ctx) ir_if(operand(r1908).val);
                           exec_list *const f1907_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1907->then_instructions;

                              ir_variable *const r1909 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r190B = less(body.constant(int(2045)), r18C0);
                              ir_if *f190A = new(mem_ctx) ir_if(operand(r190B).val);
                              exec_list *const f190A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f190A->then_instructions;

                                 body.emit(assign(r1909, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f190A->else_instructions;

                                 ir_variable *const r190C = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r190E = equal(r18C0, body.constant(int(2045)));
                                 ir_if *f190D = new(mem_ctx) ir_if(operand(r190E).val);
                                 exec_list *const f190D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f190D->then_instructions;

                                    ir_expression *const r190F = equal(body.constant(2097151u), r18C1);
                                    ir_expression *const r1910 = equal(body.constant(4294967295u), r18C2);
                                    body.emit(assign(r190C, logic_and(r190F, r1910), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f190D->else_instructions;

                                    body.emit(assign(r190C, body.constant(false), 0x01));


                                 body.instructions = f190D_parent_instructions;
                                 body.emit(f190D);

                                 /* END IF */

                                 body.emit(assign(r1909, logic_and(r190C, r1905), 0x01));


                              body.instructions = f190A_parent_instructions;
                              body.emit(f190A);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f1911 = new(mem_ctx) ir_if(operand(r1909).val);
                              exec_list *const f1911_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1911->then_instructions;

                                 ir_variable *const r1912 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r1912);
                                 ir_expression *const r1913 = lshift(r15D7, body.constant(int(31)));
                                 body.emit(assign(r1912, add(r1913, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r1912, body.constant(0u), 0x01));

                                 body.emit(assign(r1904, r1912, 0x03));

                                 body.emit(assign(r1903, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1911->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1915 = less(r18C0, body.constant(int(0)));
                                 ir_if *f1914 = new(mem_ctx) ir_if(operand(r1915).val);
                                 exec_list *const f1914_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1914->then_instructions;

                                    ir_variable *const r1916 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r1916, r18C3, 0x01));

                                    ir_variable *const r1917 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r1917, neg(r18C0), 0x01));

                                    ir_variable *const r1918 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r1918);
                                    ir_variable *const r1919 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r1919);
                                    ir_variable *const r191A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r191A);
                                    ir_variable *const r191B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r191C = neg(r1917);
                                    body.emit(assign(r191B, bit_and(r191C, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r191E = equal(r1917, body.constant(int(0)));
                                    ir_if *f191D = new(mem_ctx) ir_if(operand(r191E).val);
                                    exec_list *const f191D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f191D->then_instructions;

                                       body.emit(assign(r1918, r18C3, 0x01));

                                       body.emit(assign(r1919, r18C2, 0x01));

                                       body.emit(assign(r191A, r18C1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f191D->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1920 = less(r1917, body.constant(int(32)));
                                       ir_if *f191F = new(mem_ctx) ir_if(operand(r1920).val);
                                       exec_list *const f191F_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f191F->then_instructions;

                                          body.emit(assign(r1918, lshift(r18C2, r191B), 0x01));

                                          ir_expression *const r1921 = lshift(r18C1, r191B);
                                          ir_expression *const r1922 = rshift(r18C2, r1917);
                                          body.emit(assign(r1919, bit_or(r1921, r1922), 0x01));

                                          body.emit(assign(r191A, rshift(r18C1, r1917), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f191F->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r1924 = equal(r1917, body.constant(int(32)));
                                          ir_if *f1923 = new(mem_ctx) ir_if(operand(r1924).val);
                                          exec_list *const f1923_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1923->then_instructions;

                                             body.emit(assign(r1918, r18C2, 0x01));

                                             body.emit(assign(r1919, r18C1, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1923->else_instructions;

                                             body.emit(assign(r1916, bit_or(r18C3, r18C2), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r1926 = less(r1917, body.constant(int(64)));
                                             ir_if *f1925 = new(mem_ctx) ir_if(operand(r1926).val);
                                             exec_list *const f1925_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1925->then_instructions;

                                                body.emit(assign(r1918, lshift(r18C1, r191B), 0x01));

                                                ir_expression *const r1927 = bit_and(r1917, body.constant(int(31)));
                                                body.emit(assign(r1919, rshift(r18C1, r1927), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1925->else_instructions;

                                                ir_variable *const r1928 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r192A = equal(r1917, body.constant(int(64)));
                                                ir_if *f1929 = new(mem_ctx) ir_if(operand(r192A).val);
                                                exec_list *const f1929_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f1929->then_instructions;

                                                   body.emit(assign(r1928, r18C1, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f1929->else_instructions;

                                                   ir_expression *const r192B = nequal(r18C1, body.constant(0u));
                                                   ir_expression *const r192C = expr(ir_unop_b2i, r192B);
                                                   body.emit(assign(r1928, expr(ir_unop_i2u, r192C), 0x01));


                                                body.instructions = f1929_parent_instructions;
                                                body.emit(f1929);

                                                /* END IF */

                                                body.emit(assign(r1918, r1928, 0x01));

                                                body.emit(assign(r1919, body.constant(0u), 0x01));


                                             body.instructions = f1925_parent_instructions;
                                             body.emit(f1925);

                                             /* END IF */


                                          body.instructions = f1923_parent_instructions;
                                          body.emit(f1923);

                                          /* END IF */

                                          body.emit(assign(r191A, body.constant(0u), 0x01));


                                       body.instructions = f191F_parent_instructions;
                                       body.emit(f191F);

                                       /* END IF */

                                       ir_expression *const r192D = nequal(r1916, body.constant(0u));
                                       ir_expression *const r192E = expr(ir_unop_b2i, r192D);
                                       ir_expression *const r192F = expr(ir_unop_i2u, r192E);
                                       body.emit(assign(r1918, bit_or(r1918, r192F), 0x01));


                                    body.instructions = f191D_parent_instructions;
                                    body.emit(f191D);

                                    /* END IF */

                                    body.emit(assign(r1900, r191A, 0x01));

                                    body.emit(assign(r1901, r1919, 0x01));

                                    body.emit(assign(r1902, r1918, 0x01));

                                    body.emit(assign(r18FF, body.constant(int(0)), 0x01));

                                    body.emit(assign(r1905, less(r1918, body.constant(0u)), 0x01));


                                 body.instructions = f1914_parent_instructions;
                                 body.emit(f1914);

                                 /* END IF */


                              body.instructions = f1911_parent_instructions;
                              body.emit(f1911);

                              /* END IF */


                           body.instructions = f1907_parent_instructions;
                           body.emit(f1907);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1930 = new(mem_ctx) ir_if(operand(r1903).val);
                           exec_list *const f1930_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1930->then_instructions;

                              /* IF CONDITION */
                              ir_if *f1931 = new(mem_ctx) ir_if(operand(r1905).val);
                              exec_list *const f1931_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1931->then_instructions;

                                 ir_variable *const r1932 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r1932, add(r1901, body.constant(1u)), 0x01));

                                 ir_expression *const r1933 = less(r1932, r1901);
                                 ir_expression *const r1934 = expr(ir_unop_b2i, r1933);
                                 ir_expression *const r1935 = expr(ir_unop_i2u, r1934);
                                 body.emit(assign(r1900, add(r1900, r1935), 0x01));

                                 ir_expression *const r1936 = equal(r1902, body.constant(0u));
                                 ir_expression *const r1937 = expr(ir_unop_b2i, r1936);
                                 ir_expression *const r1938 = expr(ir_unop_i2u, r1937);
                                 ir_expression *const r1939 = add(r1902, r1938);
                                 ir_expression *const r193A = bit_and(r1939, body.constant(1u));
                                 ir_expression *const r193B = expr(ir_unop_bit_not, r193A);
                                 body.emit(assign(r1901, bit_and(r1932, r193B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1931->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r193D = bit_or(r1900, r1901);
                                 ir_expression *const r193E = equal(r193D, body.constant(0u));
                                 ir_if *f193C = new(mem_ctx) ir_if(operand(r193E).val);
                                 exec_list *const f193C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f193C->then_instructions;

                                    body.emit(assign(r18FF, body.constant(int(0)), 0x01));


                                 body.instructions = f193C_parent_instructions;
                                 body.emit(f193C);

                                 /* END IF */


                              body.instructions = f1931_parent_instructions;
                              body.emit(f1931);

                              /* END IF */

                              ir_variable *const r193F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r193F);
                              ir_expression *const r1940 = lshift(r15D7, body.constant(int(31)));
                              ir_expression *const r1941 = expr(ir_unop_i2u, r18FF);
                              ir_expression *const r1942 = lshift(r1941, body.constant(int(20)));
                              ir_expression *const r1943 = add(r1940, r1942);
                              body.emit(assign(r193F, add(r1943, r1900), 0x02));

                              body.emit(assign(r193F, r1901, 0x01));

                              body.emit(assign(r1904, r193F, 0x03));

                              body.emit(assign(r1903, body.constant(false), 0x01));


                           body.instructions = f1930_parent_instructions;
                           body.emit(f1930);

                           /* END IF */

                           body.emit(assign(r15D8, r1904, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f18B8->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1945 = less(r15DF, r15DD);
                           ir_if *f1944 = new(mem_ctx) ir_if(operand(r1945).val);
                           exec_list *const f1944_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1944->then_instructions;

                              ir_variable *const r1946 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r1947 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1947, sub(r15DD, r15DF), 0x01));

                              ir_expression *const r1948 = sub(r15DC, r15DE);
                              ir_expression *const r1949 = less(r15DD, r15DF);
                              ir_expression *const r194A = expr(ir_unop_b2i, r1949);
                              ir_expression *const r194B = expr(ir_unop_i2u, r194A);
                              body.emit(assign(r1946, sub(r1948, r194B), 0x01));

                              body.emit(assign(r15D7, bit_xor(r15D7, body.constant(1u)), 0x01));

                              body.emit(assign(r15E0, add(r15DA, body.constant(int(-1))), 0x01));

                              ir_variable *const r194C = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r194C, add(r15E0, body.constant(int(-10))), 0x01));

                              ir_variable *const r194D = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r194D, r1946, 0x01));

                              ir_variable *const r194E = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r194E, r1947, 0x01));

                              ir_variable *const r194F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r194F);
                              ir_variable *const r1950 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r1950);
                              /* IF CONDITION */
                              ir_expression *const r1952 = equal(r1946, body.constant(0u));
                              ir_if *f1951 = new(mem_ctx) ir_if(operand(r1952).val);
                              exec_list *const f1951_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1951->then_instructions;

                                 body.emit(assign(r194D, r1947, 0x01));

                                 body.emit(assign(r194E, body.constant(0u), 0x01));

                                 body.emit(assign(r194C, add(r194C, body.constant(int(-32))), 0x01));


                              body.instructions = f1951_parent_instructions;
                              body.emit(f1951);

                              /* END IF */

                              ir_variable *const r1953 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r1953, r194D, 0x01));

                              ir_variable *const r1954 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r1955 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r1955);
                              /* IF CONDITION */
                              ir_expression *const r1957 = equal(r194D, body.constant(0u));
                              ir_if *f1956 = new(mem_ctx) ir_if(operand(r1957).val);
                              exec_list *const f1956_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1956->then_instructions;

                                 body.emit(assign(r1954, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1956->else_instructions;

                                 body.emit(assign(r1955, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1959 = bit_and(r194D, body.constant(4294901760u));
                                 ir_expression *const r195A = equal(r1959, body.constant(0u));
                                 ir_if *f1958 = new(mem_ctx) ir_if(operand(r195A).val);
                                 exec_list *const f1958_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1958->then_instructions;

                                    body.emit(assign(r1955, body.constant(int(16)), 0x01));

                                    body.emit(assign(r1953, lshift(r194D, body.constant(int(16))), 0x01));


                                 body.instructions = f1958_parent_instructions;
                                 body.emit(f1958);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r195C = bit_and(r1953, body.constant(4278190080u));
                                 ir_expression *const r195D = equal(r195C, body.constant(0u));
                                 ir_if *f195B = new(mem_ctx) ir_if(operand(r195D).val);
                                 exec_list *const f195B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f195B->then_instructions;

                                    body.emit(assign(r1955, add(r1955, body.constant(int(8))), 0x01));

                                    body.emit(assign(r1953, lshift(r1953, body.constant(int(8))), 0x01));


                                 body.instructions = f195B_parent_instructions;
                                 body.emit(f195B);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r195F = bit_and(r1953, body.constant(4026531840u));
                                 ir_expression *const r1960 = equal(r195F, body.constant(0u));
                                 ir_if *f195E = new(mem_ctx) ir_if(operand(r1960).val);
                                 exec_list *const f195E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f195E->then_instructions;

                                    body.emit(assign(r1955, add(r1955, body.constant(int(4))), 0x01));

                                    body.emit(assign(r1953, lshift(r1953, body.constant(int(4))), 0x01));


                                 body.instructions = f195E_parent_instructions;
                                 body.emit(f195E);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1962 = bit_and(r1953, body.constant(3221225472u));
                                 ir_expression *const r1963 = equal(r1962, body.constant(0u));
                                 ir_if *f1961 = new(mem_ctx) ir_if(operand(r1963).val);
                                 exec_list *const f1961_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1961->then_instructions;

                                    body.emit(assign(r1955, add(r1955, body.constant(int(2))), 0x01));

                                    body.emit(assign(r1953, lshift(r1953, body.constant(int(2))), 0x01));


                                 body.instructions = f1961_parent_instructions;
                                 body.emit(f1961);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1965 = bit_and(r1953, body.constant(2147483648u));
                                 ir_expression *const r1966 = equal(r1965, body.constant(0u));
                                 ir_if *f1964 = new(mem_ctx) ir_if(operand(r1966).val);
                                 exec_list *const f1964_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1964->then_instructions;

                                    body.emit(assign(r1955, add(r1955, body.constant(int(1))), 0x01));


                                 body.instructions = f1964_parent_instructions;
                                 body.emit(f1964);

                                 /* END IF */

                                 body.emit(assign(r1954, r1955, 0x01));


                              body.instructions = f1956_parent_instructions;
                              body.emit(f1956);

                              /* END IF */

                              body.emit(assign(r1950, add(r1954, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1968 = lequal(body.constant(int(0)), r1950);
                              ir_if *f1967 = new(mem_ctx) ir_if(operand(r1968).val);
                              exec_list *const f1967_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1967->then_instructions;

                                 body.emit(assign(r194F, body.constant(0u), 0x01));

                                 ir_variable *const r1969 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r1969, lshift(r194E, r1950), 0x01));

                                 ir_variable *const r196A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r196C = equal(r1950, body.constant(int(0)));
                                 ir_if *f196B = new(mem_ctx) ir_if(operand(r196C).val);
                                 exec_list *const f196B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f196B->then_instructions;

                                    body.emit(assign(r196A, r194D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f196B->else_instructions;

                                    ir_expression *const r196D = lshift(r194D, r1950);
                                    ir_expression *const r196E = neg(r1950);
                                    ir_expression *const r196F = bit_and(r196E, body.constant(int(31)));
                                    ir_expression *const r1970 = rshift(r194E, r196F);
                                    body.emit(assign(r196A, bit_or(r196D, r1970), 0x01));


                                 body.instructions = f196B_parent_instructions;
                                 body.emit(f196B);

                                 /* END IF */

                                 body.emit(assign(r194D, r196A, 0x01));

                                 body.emit(assign(r194E, r1969, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1967->else_instructions;

                                 ir_variable *const r1971 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1971, body.constant(0u), 0x01));

                                 ir_variable *const r1972 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1972, neg(r1950), 0x01));

                                 ir_variable *const r1973 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1973);
                                 ir_variable *const r1974 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1974);
                                 ir_variable *const r1975 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1975);
                                 ir_variable *const r1976 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r1977 = neg(r1972);
                                 body.emit(assign(r1976, bit_and(r1977, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1979 = equal(r1972, body.constant(int(0)));
                                 ir_if *f1978 = new(mem_ctx) ir_if(operand(r1979).val);
                                 exec_list *const f1978_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1978->then_instructions;

                                    body.emit(assign(r1973, r1971, 0x01));

                                    body.emit(assign(r1974, r194E, 0x01));

                                    body.emit(assign(r1975, r194D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1978->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r197B = less(r1972, body.constant(int(32)));
                                    ir_if *f197A = new(mem_ctx) ir_if(operand(r197B).val);
                                    exec_list *const f197A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f197A->then_instructions;

                                       body.emit(assign(r1973, lshift(r194E, r1976), 0x01));

                                       ir_expression *const r197C = lshift(r194D, r1976);
                                       ir_expression *const r197D = rshift(r194E, r1972);
                                       body.emit(assign(r1974, bit_or(r197C, r197D), 0x01));

                                       body.emit(assign(r1975, rshift(r194D, r1972), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f197A->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r197F = equal(r1972, body.constant(int(32)));
                                       ir_if *f197E = new(mem_ctx) ir_if(operand(r197F).val);
                                       exec_list *const f197E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f197E->then_instructions;

                                          body.emit(assign(r1973, r194E, 0x01));

                                          body.emit(assign(r1974, r194D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f197E->else_instructions;

                                          body.emit(assign(r1971, bit_or(body.constant(0u), r194E), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1981 = less(r1972, body.constant(int(64)));
                                          ir_if *f1980 = new(mem_ctx) ir_if(operand(r1981).val);
                                          exec_list *const f1980_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1980->then_instructions;

                                             body.emit(assign(r1973, lshift(r194D, r1976), 0x01));

                                             ir_expression *const r1982 = bit_and(r1972, body.constant(int(31)));
                                             body.emit(assign(r1974, rshift(r194D, r1982), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1980->else_instructions;

                                             ir_variable *const r1983 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1985 = equal(r1972, body.constant(int(64)));
                                             ir_if *f1984 = new(mem_ctx) ir_if(operand(r1985).val);
                                             exec_list *const f1984_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1984->then_instructions;

                                                body.emit(assign(r1983, r194D, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1984->else_instructions;

                                                ir_expression *const r1986 = nequal(r194D, body.constant(0u));
                                                ir_expression *const r1987 = expr(ir_unop_b2i, r1986);
                                                body.emit(assign(r1983, expr(ir_unop_i2u, r1987), 0x01));


                                             body.instructions = f1984_parent_instructions;
                                             body.emit(f1984);

                                             /* END IF */

                                             body.emit(assign(r1973, r1983, 0x01));

                                             body.emit(assign(r1974, body.constant(0u), 0x01));


                                          body.instructions = f1980_parent_instructions;
                                          body.emit(f1980);

                                          /* END IF */


                                       body.instructions = f197E_parent_instructions;
                                       body.emit(f197E);

                                       /* END IF */

                                       body.emit(assign(r1975, body.constant(0u), 0x01));


                                    body.instructions = f197A_parent_instructions;
                                    body.emit(f197A);

                                    /* END IF */

                                    ir_expression *const r1988 = nequal(r1971, body.constant(0u));
                                    ir_expression *const r1989 = expr(ir_unop_b2i, r1988);
                                    ir_expression *const r198A = expr(ir_unop_i2u, r1989);
                                    body.emit(assign(r1973, bit_or(r1973, r198A), 0x01));


                                 body.instructions = f1978_parent_instructions;
                                 body.emit(f1978);

                                 /* END IF */

                                 body.emit(assign(r194D, r1975, 0x01));

                                 body.emit(assign(r194E, r1974, 0x01));

                                 body.emit(assign(r194F, r1973, 0x01));


                              body.instructions = f1967_parent_instructions;
                              body.emit(f1967);

                              /* END IF */

                              body.emit(assign(r194C, sub(r194C, r1950), 0x01));

                              ir_variable *const r198B = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r198B, r194C, 0x01));

                              ir_variable *const r198C = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r198C, r194D, 0x01));

                              ir_variable *const r198D = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r198D, r194E, 0x01));

                              ir_variable *const r198E = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r198E, r194F, 0x01));

                              ir_variable *const r198F = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r198F, body.constant(true), 0x01));

                              ir_variable *const r1990 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r1991 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r1991);
                              ir_expression *const r1992 = expr(ir_unop_u2i, r194F);
                              body.emit(assign(r1991, less(r1992, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1994 = lequal(body.constant(int(2045)), r194C);
                              ir_if *f1993 = new(mem_ctx) ir_if(operand(r1994).val);
                              exec_list *const f1993_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1993->then_instructions;

                                 ir_variable *const r1995 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1997 = less(body.constant(int(2045)), r194C);
                                 ir_if *f1996 = new(mem_ctx) ir_if(operand(r1997).val);
                                 exec_list *const f1996_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1996->then_instructions;

                                    body.emit(assign(r1995, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1996->else_instructions;

                                    ir_variable *const r1998 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r199A = equal(r194C, body.constant(int(2045)));
                                    ir_if *f1999 = new(mem_ctx) ir_if(operand(r199A).val);
                                    exec_list *const f1999_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1999->then_instructions;

                                       ir_expression *const r199B = equal(body.constant(2097151u), r194D);
                                       ir_expression *const r199C = equal(body.constant(4294967295u), r194E);
                                       body.emit(assign(r1998, logic_and(r199B, r199C), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1999->else_instructions;

                                       body.emit(assign(r1998, body.constant(false), 0x01));


                                    body.instructions = f1999_parent_instructions;
                                    body.emit(f1999);

                                    /* END IF */

                                    body.emit(assign(r1995, logic_and(r1998, r1991), 0x01));


                                 body.instructions = f1996_parent_instructions;
                                 body.emit(f1996);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f199D = new(mem_ctx) ir_if(operand(r1995).val);
                                 exec_list *const f199D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f199D->then_instructions;

                                    ir_variable *const r199E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r199E);
                                    ir_expression *const r199F = lshift(r15D7, body.constant(int(31)));
                                    body.emit(assign(r199E, add(r199F, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r199E, body.constant(0u), 0x01));

                                    body.emit(assign(r1990, r199E, 0x03));

                                    body.emit(assign(r198F, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f199D->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r19A1 = less(r194C, body.constant(int(0)));
                                    ir_if *f19A0 = new(mem_ctx) ir_if(operand(r19A1).val);
                                    exec_list *const f19A0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f19A0->then_instructions;

                                       ir_variable *const r19A2 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r19A2, r194F, 0x01));

                                       ir_variable *const r19A3 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r19A3, neg(r194C), 0x01));

                                       ir_variable *const r19A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r19A4);
                                       ir_variable *const r19A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r19A5);
                                       ir_variable *const r19A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r19A6);
                                       ir_variable *const r19A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r19A8 = neg(r19A3);
                                       body.emit(assign(r19A7, bit_and(r19A8, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r19AA = equal(r19A3, body.constant(int(0)));
                                       ir_if *f19A9 = new(mem_ctx) ir_if(operand(r19AA).val);
                                       exec_list *const f19A9_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f19A9->then_instructions;

                                          body.emit(assign(r19A4, r194F, 0x01));

                                          body.emit(assign(r19A5, r194E, 0x01));

                                          body.emit(assign(r19A6, r194D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f19A9->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r19AC = less(r19A3, body.constant(int(32)));
                                          ir_if *f19AB = new(mem_ctx) ir_if(operand(r19AC).val);
                                          exec_list *const f19AB_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f19AB->then_instructions;

                                             body.emit(assign(r19A4, lshift(r194E, r19A7), 0x01));

                                             ir_expression *const r19AD = lshift(r194D, r19A7);
                                             ir_expression *const r19AE = rshift(r194E, r19A3);
                                             body.emit(assign(r19A5, bit_or(r19AD, r19AE), 0x01));

                                             body.emit(assign(r19A6, rshift(r194D, r19A3), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f19AB->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r19B0 = equal(r19A3, body.constant(int(32)));
                                             ir_if *f19AF = new(mem_ctx) ir_if(operand(r19B0).val);
                                             exec_list *const f19AF_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f19AF->then_instructions;

                                                body.emit(assign(r19A4, r194E, 0x01));

                                                body.emit(assign(r19A5, r194D, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f19AF->else_instructions;

                                                body.emit(assign(r19A2, bit_or(r194F, r194E), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r19B2 = less(r19A3, body.constant(int(64)));
                                                ir_if *f19B1 = new(mem_ctx) ir_if(operand(r19B2).val);
                                                exec_list *const f19B1_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f19B1->then_instructions;

                                                   body.emit(assign(r19A4, lshift(r194D, r19A7), 0x01));

                                                   ir_expression *const r19B3 = bit_and(r19A3, body.constant(int(31)));
                                                   body.emit(assign(r19A5, rshift(r194D, r19B3), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f19B1->else_instructions;

                                                   ir_variable *const r19B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r19B6 = equal(r19A3, body.constant(int(64)));
                                                   ir_if *f19B5 = new(mem_ctx) ir_if(operand(r19B6).val);
                                                   exec_list *const f19B5_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f19B5->then_instructions;

                                                      body.emit(assign(r19B4, r194D, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f19B5->else_instructions;

                                                      ir_expression *const r19B7 = nequal(r194D, body.constant(0u));
                                                      ir_expression *const r19B8 = expr(ir_unop_b2i, r19B7);
                                                      body.emit(assign(r19B4, expr(ir_unop_i2u, r19B8), 0x01));


                                                   body.instructions = f19B5_parent_instructions;
                                                   body.emit(f19B5);

                                                   /* END IF */

                                                   body.emit(assign(r19A4, r19B4, 0x01));

                                                   body.emit(assign(r19A5, body.constant(0u), 0x01));


                                                body.instructions = f19B1_parent_instructions;
                                                body.emit(f19B1);

                                                /* END IF */


                                             body.instructions = f19AF_parent_instructions;
                                             body.emit(f19AF);

                                             /* END IF */

                                             body.emit(assign(r19A6, body.constant(0u), 0x01));


                                          body.instructions = f19AB_parent_instructions;
                                          body.emit(f19AB);

                                          /* END IF */

                                          ir_expression *const r19B9 = nequal(r19A2, body.constant(0u));
                                          ir_expression *const r19BA = expr(ir_unop_b2i, r19B9);
                                          ir_expression *const r19BB = expr(ir_unop_i2u, r19BA);
                                          body.emit(assign(r19A4, bit_or(r19A4, r19BB), 0x01));


                                       body.instructions = f19A9_parent_instructions;
                                       body.emit(f19A9);

                                       /* END IF */

                                       body.emit(assign(r198C, r19A6, 0x01));

                                       body.emit(assign(r198D, r19A5, 0x01));

                                       body.emit(assign(r198E, r19A4, 0x01));

                                       body.emit(assign(r198B, body.constant(int(0)), 0x01));

                                       body.emit(assign(r1991, less(r19A4, body.constant(0u)), 0x01));


                                    body.instructions = f19A0_parent_instructions;
                                    body.emit(f19A0);

                                    /* END IF */


                                 body.instructions = f199D_parent_instructions;
                                 body.emit(f199D);

                                 /* END IF */


                              body.instructions = f1993_parent_instructions;
                              body.emit(f1993);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f19BC = new(mem_ctx) ir_if(operand(r198F).val);
                              exec_list *const f19BC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f19BC->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f19BD = new(mem_ctx) ir_if(operand(r1991).val);
                                 exec_list *const f19BD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f19BD->then_instructions;

                                    ir_variable *const r19BE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r19BE, add(r198D, body.constant(1u)), 0x01));

                                    ir_expression *const r19BF = less(r19BE, r198D);
                                    ir_expression *const r19C0 = expr(ir_unop_b2i, r19BF);
                                    ir_expression *const r19C1 = expr(ir_unop_i2u, r19C0);
                                    body.emit(assign(r198C, add(r198C, r19C1), 0x01));

                                    ir_expression *const r19C2 = equal(r198E, body.constant(0u));
                                    ir_expression *const r19C3 = expr(ir_unop_b2i, r19C2);
                                    ir_expression *const r19C4 = expr(ir_unop_i2u, r19C3);
                                    ir_expression *const r19C5 = add(r198E, r19C4);
                                    ir_expression *const r19C6 = bit_and(r19C5, body.constant(1u));
                                    ir_expression *const r19C7 = expr(ir_unop_bit_not, r19C6);
                                    body.emit(assign(r198D, bit_and(r19BE, r19C7), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f19BD->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r19C9 = bit_or(r198C, r198D);
                                    ir_expression *const r19CA = equal(r19C9, body.constant(0u));
                                    ir_if *f19C8 = new(mem_ctx) ir_if(operand(r19CA).val);
                                    exec_list *const f19C8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f19C8->then_instructions;

                                       body.emit(assign(r198B, body.constant(int(0)), 0x01));


                                    body.instructions = f19C8_parent_instructions;
                                    body.emit(f19C8);

                                    /* END IF */


                                 body.instructions = f19BD_parent_instructions;
                                 body.emit(f19BD);

                                 /* END IF */

                                 ir_variable *const r19CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r19CB);
                                 ir_expression *const r19CC = lshift(r15D7, body.constant(int(31)));
                                 ir_expression *const r19CD = expr(ir_unop_i2u, r198B);
                                 ir_expression *const r19CE = lshift(r19CD, body.constant(int(20)));
                                 ir_expression *const r19CF = add(r19CC, r19CE);
                                 body.emit(assign(r19CB, add(r19CF, r198C), 0x02));

                                 body.emit(assign(r19CB, r198D, 0x01));

                                 body.emit(assign(r1990, r19CB, 0x03));

                                 body.emit(assign(r198F, body.constant(false), 0x01));


                              body.instructions = f19BC_parent_instructions;
                              body.emit(f19BC);

                              /* END IF */

                              body.emit(assign(r15D8, r1990, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1944->else_instructions;

                              ir_variable *const r19D0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r19D0);
                              body.emit(assign(r19D0, body.constant(0u), 0x02));

                              body.emit(assign(r19D0, body.constant(0u), 0x01));

                              body.emit(assign(r15D8, r19D0, 0x03));


                           body.instructions = f1944_parent_instructions;
                           body.emit(f1944);

                           /* END IF */


                        body.instructions = f18B8_parent_instructions;
                        body.emit(f18B8);

                        /* END IF */


                     body.instructions = f182C_parent_instructions;
                     body.emit(f182C);

                     /* END IF */


                  body.instructions = f17A0_parent_instructions;
                  body.emit(f17A0);

                  /* END IF */


               body.instructions = f177F_parent_instructions;
               body.emit(f177F);

               /* END IF */


            body.instructions = f16B1_parent_instructions;
            body.emit(f16B1);

            /* END IF */


         body.instructions = f15EC_parent_instructions;
         body.emit(f15EC);

         /* END IF */

         body.emit(assign(r143E, r15D8, 0x03));


      body.instructions = f1441_parent_instructions;
      body.emit(f1441);

      /* END IF */

      body.emit(assign(r143B, r143E, 0x03));


   body.instructions = f143C_parent_instructions;
   body.emit(f143C);

   /* END IF */

   body.emit(ret(r143B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fceil64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r19D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r19D1);
   ir_variable *const r19D2 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r19D3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r19D4 = rshift(swizzle_y(r19D1), body.constant(int(20)));
   ir_expression *const r19D5 = bit_and(r19D4, body.constant(2047u));
   ir_expression *const r19D6 = expr(ir_unop_u2i, r19D5);
   body.emit(assign(r19D3, add(r19D6, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r19D8 = less(r19D3, body.constant(int(0)));
   ir_if *f19D7 = new(mem_ctx) ir_if(operand(r19D8).val);
   exec_list *const f19D7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f19D7->then_instructions;

      body.emit(assign(r19D2, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f19D7->else_instructions;

      /* IF CONDITION */
      ir_expression *const r19DA = greater(r19D3, body.constant(int(52)));
      ir_if *f19D9 = new(mem_ctx) ir_if(operand(r19DA).val);
      exec_list *const f19D9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19D9->then_instructions;

         body.emit(assign(r19D2, r19D1, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f19D9->else_instructions;

         ir_variable *const r19DB = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r19DB, sub(body.constant(int(52)), r19D3), 0x01));

         ir_variable *const r19DC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r19DE = gequal(r19DB, body.constant(int(32)));
         ir_if *f19DD = new(mem_ctx) ir_if(operand(r19DE).val);
         exec_list *const f19DD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19DD->then_instructions;

            body.emit(assign(r19DC, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f19DD->else_instructions;

            body.emit(assign(r19DC, lshift(body.constant(4294967295u), r19DB), 0x01));


         body.instructions = f19DD_parent_instructions;
         body.emit(f19DD);

         /* END IF */

         ir_variable *const r19DF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r19E1 = less(r19DB, body.constant(int(33)));
         ir_if *f19E0 = new(mem_ctx) ir_if(operand(r19E1).val);
         exec_list *const f19E0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19E0->then_instructions;

            body.emit(assign(r19DF, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f19E0->else_instructions;

            ir_expression *const r19E2 = add(r19DB, body.constant(int(-32)));
            body.emit(assign(r19DF, lshift(body.constant(4294967295u), r19E2), 0x01));


         body.instructions = f19E0_parent_instructions;
         body.emit(f19E0);

         /* END IF */

         ir_variable *const r19E3 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r19E3, bit_and(r19DC, swizzle_x(r19D1)), 0x01));

         body.emit(assign(r19E3, bit_and(r19DF, swizzle_y(r19D1)), 0x02));

         body.emit(assign(r19D2, r19E3, 0x03));


      body.instructions = f19D9_parent_instructions;
      body.emit(f19D9);

      /* END IF */


   body.instructions = f19D7_parent_instructions;
   body.emit(f19D7);

   /* END IF */

   ir_variable *const r19E4 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r19E4, rshift(swizzle_y(r19D1), body.constant(int(31))), 0x01));

   ir_variable *const r19E5 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r19E7 = expr(ir_unop_u2i, r19E4);
   ir_expression *const r19E8 = expr(ir_unop_i2b, r19E7);
   ir_if *f19E6 = new(mem_ctx) ir_if(operand(r19E8).val);
   exec_list *const f19E6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f19E6->then_instructions;

      body.emit(assign(r19E5, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f19E6->else_instructions;

      ir_variable *const r19E9 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r19EA = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r19EA);
      ir_variable *const r19EB = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r19EB);
      ir_expression *const r19EC = rshift(swizzle_y(r19D1), body.constant(int(20)));
      ir_expression *const r19ED = bit_and(r19EC, body.constant(2047u));
      ir_expression *const r19EE = expr(ir_unop_u2i, r19ED);
      ir_expression *const r19EF = equal(r19EE, body.constant(int(2047)));
      ir_expression *const r19F0 = bit_and(swizzle_y(r19D1), body.constant(1048575u));
      ir_expression *const r19F1 = bit_or(r19F0, swizzle_x(r19D1));
      ir_expression *const r19F2 = nequal(r19F1, body.constant(0u));
      body.emit(assign(r19EB, logic_and(r19EF, r19F2), 0x01));

      ir_expression *const r19F3 = rshift(swizzle_y(r19D2), body.constant(int(20)));
      ir_expression *const r19F4 = bit_and(r19F3, body.constant(2047u));
      ir_expression *const r19F5 = expr(ir_unop_u2i, r19F4);
      ir_expression *const r19F6 = equal(r19F5, body.constant(int(2047)));
      ir_expression *const r19F7 = bit_and(swizzle_y(r19D2), body.constant(1048575u));
      ir_expression *const r19F8 = bit_or(r19F7, swizzle_x(r19D2));
      ir_expression *const r19F9 = nequal(r19F8, body.constant(0u));
      body.emit(assign(r19EA, logic_and(r19F6, r19F9), 0x01));

      /* IF CONDITION */
      ir_expression *const r19FB = logic_or(r19EB, r19EA);
      ir_if *f19FA = new(mem_ctx) ir_if(operand(r19FB).val);
      exec_list *const f19FA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19FA->then_instructions;

         body.emit(assign(r19E9, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f19FA->else_instructions;

         ir_expression *const r19FC = equal(swizzle_x(r19D1), swizzle_x(r19D2));
         ir_expression *const r19FD = equal(swizzle_y(r19D1), swizzle_y(r19D2));
         ir_expression *const r19FE = equal(swizzle_x(r19D1), body.constant(0u));
         ir_expression *const r19FF = bit_or(swizzle_y(r19D1), swizzle_y(r19D2));
         ir_expression *const r1A00 = lshift(r19FF, body.constant(int(1)));
         ir_expression *const r1A01 = equal(r1A00, body.constant(0u));
         ir_expression *const r1A02 = logic_and(r19FE, r1A01);
         ir_expression *const r1A03 = logic_or(r19FD, r1A02);
         body.emit(assign(r19E9, logic_and(r19FC, r1A03), 0x01));


      body.instructions = f19FA_parent_instructions;
      body.emit(f19FA);

      /* END IF */

      body.emit(assign(r19E5, r19E9, 0x01));


   body.instructions = f19E6_parent_instructions;
   body.emit(f19E6);

   /* END IF */

   ir_variable *const r1A04 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f1A05 = new(mem_ctx) ir_if(operand(r19E5).val);
   exec_list *const f1A05_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A05->then_instructions;

      body.emit(assign(r1A04, r19D2, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A05->else_instructions;

      ir_variable *const r1A06 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r1A07 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1A07, rshift(swizzle_y(r19D2), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1A09 = equal(r1A07, body.constant(0u));
      ir_if *f1A08 = new(mem_ctx) ir_if(operand(r1A09).val);
      exec_list *const f1A08_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A08->then_instructions;

         ir_variable *const r1A0A = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r1A0A, body.constant(true), 0x01));

         ir_variable *const r1A0B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r1A0C = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r1A0C);
         ir_variable *const r1A0D = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r1A0D);
         ir_variable *const r1A0E = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r1A0E);
         ir_variable *const r1A0F = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r1A0F);
         ir_variable *const r1A10 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r1A10);
         ir_variable *const r1A11 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r1A11);
         ir_variable *const r1A12 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r1A12);
         ir_variable *const r1A13 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r1A13);
         body.emit(assign(r1A13, body.constant(0u), 0x01));

         body.emit(assign(r1A12, body.constant(0u), 0x01));

         ir_variable *const r1A14 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r1A14, swizzle_x(r19D2), 0x01));

         body.emit(assign(r1A10, r1A14, 0x01));

         ir_variable *const r1A15 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r1A15, bit_and(swizzle_y(r19D2), body.constant(1048575u)), 0x01));

         body.emit(assign(r1A0F, r1A15, 0x01));

         ir_variable *const r1A16 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r1A16, body.constant(0u), 0x01));

         body.emit(assign(r1A0E, body.constant(0u), 0x01));

         body.emit(assign(r1A0D, body.constant(0u), 0x01));

         ir_variable *const r1A17 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r1A18 = rshift(swizzle_y(r19D2), body.constant(int(20)));
         ir_expression *const r1A19 = bit_and(r1A18, body.constant(2047u));
         body.emit(assign(r1A17, expr(ir_unop_u2i, r1A19), 0x01));

         ir_variable *const r1A1A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r1A1A, body.constant(int(1023)), 0x01));

         ir_variable *const r1A1B = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1A1B, add(r1A17, body.constant(int(-1023))), 0x01));

         body.emit(assign(r1A0C, r1A1B, 0x01));

         /* IF CONDITION */
         ir_expression *const r1A1D = less(body.constant(int(0)), r1A1B);
         ir_if *f1A1C = new(mem_ctx) ir_if(operand(r1A1D).val);
         exec_list *const f1A1C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A1C->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1A1F = equal(r1A17, body.constant(int(2047)));
            ir_if *f1A1E = new(mem_ctx) ir_if(operand(r1A1F).val);
            exec_list *const f1A1E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1A1E->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1A21 = bit_or(r1A15, swizzle_x(r19D2));
               ir_expression *const r1A22 = nequal(r1A21, body.constant(0u));
               ir_if *f1A20 = new(mem_ctx) ir_if(operand(r1A22).val);
               exec_list *const f1A20_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1A20->then_instructions;

                  ir_variable *const r1A23 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1A23, swizzle_x(r19D2), 0x01));

                  ir_variable *const r1A24 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1A24, body.constant(0u), 0x01));

                  ir_variable *const r1A25 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r1A23, bit_or(swizzle_y(r19D2), body.constant(524288u)), 0x02));

                  body.emit(assign(r1A24, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1A27 = lshift(swizzle_y(r19D2), body.constant(int(1)));
                  ir_expression *const r1A28 = lequal(body.constant(4292870144u), r1A27);
                  ir_expression *const r1A29 = nequal(swizzle_x(r19D2), body.constant(0u));
                  ir_expression *const r1A2A = bit_and(swizzle_y(r19D2), body.constant(1048575u));
                  ir_expression *const r1A2B = nequal(r1A2A, body.constant(0u));
                  ir_expression *const r1A2C = logic_or(r1A29, r1A2B);
                  ir_expression *const r1A2D = logic_and(r1A28, r1A2C);
                  ir_if *f1A26 = new(mem_ctx) ir_if(operand(r1A2D).val);
                  exec_list *const f1A26_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1A26->then_instructions;

                     body.emit(assign(r1A25, r1A23, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1A26->else_instructions;

                     body.emit(assign(r1A25, r1A24, 0x03));


                  body.instructions = f1A26_parent_instructions;
                  body.emit(f1A26);

                  /* END IF */

                  body.emit(assign(r1A0B, r1A25, 0x03));

                  body.emit(assign(r1A0A, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1A20->else_instructions;

                  body.emit(assign(r1A0B, r19D2, 0x03));

                  body.emit(assign(r1A0A, body.constant(false), 0x01));


               body.instructions = f1A20_parent_instructions;
               body.emit(f1A20);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1A1E->else_instructions;

               body.emit(assign(r1A0D, body.constant(1048576u), 0x01));

               ir_variable *const r1A2E = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r1A2E, body.constant(0u), 0x01));

               ir_variable *const r1A2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r1A2F);
               ir_variable *const r1A30 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1A30);
               ir_variable *const r1A31 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1A31);
               ir_variable *const r1A32 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1A33 = neg(r1A1B);
               body.emit(assign(r1A32, bit_and(r1A33, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1A35 = equal(r1A1B, body.constant(int(0)));
               ir_if *f1A34 = new(mem_ctx) ir_if(operand(r1A35).val);
               exec_list *const f1A34_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1A34->then_instructions;

                  body.emit(assign(r1A2F, r1A2E, 0x01));

                  body.emit(assign(r1A30, body.constant(0u), 0x01));

                  body.emit(assign(r1A31, r1A0D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1A34->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1A37 = less(r1A1B, body.constant(int(32)));
                  ir_if *f1A36 = new(mem_ctx) ir_if(operand(r1A37).val);
                  exec_list *const f1A36_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1A36->then_instructions;

                     body.emit(assign(r1A2F, body.constant(0u), 0x01));

                     ir_expression *const r1A38 = lshift(body.constant(1048576u), r1A32);
                     body.emit(assign(r1A30, bit_or(r1A38, body.constant(0u)), 0x01));

                     body.emit(assign(r1A31, rshift(body.constant(1048576u), r1A1B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1A36->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1A3A = equal(r1A1B, body.constant(int(32)));
                     ir_if *f1A39 = new(mem_ctx) ir_if(operand(r1A3A).val);
                     exec_list *const f1A39_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1A39->then_instructions;

                        body.emit(assign(r1A2F, body.constant(0u), 0x01));

                        body.emit(assign(r1A30, r1A0D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1A39->else_instructions;

                        body.emit(assign(r1A2E, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1A3C = less(r1A1B, body.constant(int(64)));
                        ir_if *f1A3B = new(mem_ctx) ir_if(operand(r1A3C).val);
                        exec_list *const f1A3B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A3B->then_instructions;

                           body.emit(assign(r1A2F, lshift(body.constant(1048576u), r1A32), 0x01));

                           ir_expression *const r1A3D = bit_and(r1A1B, body.constant(int(31)));
                           body.emit(assign(r1A30, rshift(body.constant(1048576u), r1A3D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1A3B->else_instructions;

                           ir_variable *const r1A3E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1A40 = equal(r1A1B, body.constant(int(64)));
                           ir_if *f1A3F = new(mem_ctx) ir_if(operand(r1A40).val);
                           exec_list *const f1A3F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1A3F->then_instructions;

                              body.emit(assign(r1A3E, r1A0D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1A3F->else_instructions;

                              body.emit(assign(r1A3E, body.constant(1u), 0x01));


                           body.instructions = f1A3F_parent_instructions;
                           body.emit(f1A3F);

                           /* END IF */

                           body.emit(assign(r1A2F, r1A3E, 0x01));

                           body.emit(assign(r1A30, body.constant(0u), 0x01));


                        body.instructions = f1A3B_parent_instructions;
                        body.emit(f1A3B);

                        /* END IF */


                     body.instructions = f1A39_parent_instructions;
                     body.emit(f1A39);

                     /* END IF */

                     body.emit(assign(r1A31, body.constant(0u), 0x01));


                  body.instructions = f1A36_parent_instructions;
                  body.emit(f1A36);

                  /* END IF */

                  ir_expression *const r1A41 = nequal(r1A2E, body.constant(0u));
                  ir_expression *const r1A42 = expr(ir_unop_b2i, r1A41);
                  ir_expression *const r1A43 = expr(ir_unop_i2u, r1A42);
                  body.emit(assign(r1A2F, bit_or(r1A2F, r1A43), 0x01));


               body.instructions = f1A34_parent_instructions;
               body.emit(f1A34);

               /* END IF */

               body.emit(assign(r1A0D, r1A31, 0x01));

               body.emit(assign(r1A0E, r1A30, 0x01));

               body.emit(assign(r1A12, r1A2F, 0x01));

               body.emit(assign(r1A11, r1A17, 0x01));


            body.instructions = f1A1E_parent_instructions;
            body.emit(f1A1E);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A1C->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1A45 = less(r1A1B, body.constant(int(0)));
            ir_if *f1A44 = new(mem_ctx) ir_if(operand(r1A45).val);
            exec_list *const f1A44_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1A44->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1A47 = equal(r1A17, body.constant(int(0)));
               ir_if *f1A46 = new(mem_ctx) ir_if(operand(r1A47).val);
               exec_list *const f1A46_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1A46->then_instructions;

                  body.emit(assign(r1A0C, add(r1A1B, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1A46->else_instructions;

                  body.emit(assign(r1A0F, bit_or(r1A15, body.constant(1048576u)), 0x01));


               body.instructions = f1A46_parent_instructions;
               body.emit(f1A46);

               /* END IF */

               ir_variable *const r1A48 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r1A48, body.constant(0u), 0x01));

               ir_variable *const r1A49 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1A49, neg(r1A0C), 0x01));

               ir_variable *const r1A4A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r1A4A);
               ir_variable *const r1A4B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1A4B);
               ir_variable *const r1A4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1A4C);
               ir_variable *const r1A4D = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1A4E = neg(r1A49);
               body.emit(assign(r1A4D, bit_and(r1A4E, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1A50 = equal(r1A49, body.constant(int(0)));
               ir_if *f1A4F = new(mem_ctx) ir_if(operand(r1A50).val);
               exec_list *const f1A4F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1A4F->then_instructions;

                  body.emit(assign(r1A4A, r1A48, 0x01));

                  body.emit(assign(r1A4B, r1A14, 0x01));

                  body.emit(assign(r1A4C, r1A0F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1A4F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1A52 = less(r1A49, body.constant(int(32)));
                  ir_if *f1A51 = new(mem_ctx) ir_if(operand(r1A52).val);
                  exec_list *const f1A51_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1A51->then_instructions;

                     body.emit(assign(r1A4A, lshift(swizzle_x(r19D2), r1A4D), 0x01));

                     ir_expression *const r1A53 = lshift(r1A0F, r1A4D);
                     ir_expression *const r1A54 = rshift(swizzle_x(r19D2), r1A49);
                     body.emit(assign(r1A4B, bit_or(r1A53, r1A54), 0x01));

                     body.emit(assign(r1A4C, rshift(r1A0F, r1A49), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1A51->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1A56 = equal(r1A49, body.constant(int(32)));
                     ir_if *f1A55 = new(mem_ctx) ir_if(operand(r1A56).val);
                     exec_list *const f1A55_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1A55->then_instructions;

                        body.emit(assign(r1A4A, r1A14, 0x01));

                        body.emit(assign(r1A4B, r1A0F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1A55->else_instructions;

                        body.emit(assign(r1A48, bit_or(body.constant(0u), swizzle_x(r19D2)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1A58 = less(r1A49, body.constant(int(64)));
                        ir_if *f1A57 = new(mem_ctx) ir_if(operand(r1A58).val);
                        exec_list *const f1A57_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A57->then_instructions;

                           body.emit(assign(r1A4A, lshift(r1A0F, r1A4D), 0x01));

                           ir_expression *const r1A59 = bit_and(r1A49, body.constant(int(31)));
                           body.emit(assign(r1A4B, rshift(r1A0F, r1A59), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1A57->else_instructions;

                           ir_variable *const r1A5A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1A5C = equal(r1A49, body.constant(int(64)));
                           ir_if *f1A5B = new(mem_ctx) ir_if(operand(r1A5C).val);
                           exec_list *const f1A5B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1A5B->then_instructions;

                              body.emit(assign(r1A5A, r1A0F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1A5B->else_instructions;

                              ir_expression *const r1A5D = nequal(r1A0F, body.constant(0u));
                              ir_expression *const r1A5E = expr(ir_unop_b2i, r1A5D);
                              body.emit(assign(r1A5A, expr(ir_unop_i2u, r1A5E), 0x01));


                           body.instructions = f1A5B_parent_instructions;
                           body.emit(f1A5B);

                           /* END IF */

                           body.emit(assign(r1A4A, r1A5A, 0x01));

                           body.emit(assign(r1A4B, body.constant(0u), 0x01));


                        body.instructions = f1A57_parent_instructions;
                        body.emit(f1A57);

                        /* END IF */


                     body.instructions = f1A55_parent_instructions;
                     body.emit(f1A55);

                     /* END IF */

                     body.emit(assign(r1A4C, body.constant(0u), 0x01));


                  body.instructions = f1A51_parent_instructions;
                  body.emit(f1A51);

                  /* END IF */

                  ir_expression *const r1A5F = nequal(r1A48, body.constant(0u));
                  ir_expression *const r1A60 = expr(ir_unop_b2i, r1A5F);
                  ir_expression *const r1A61 = expr(ir_unop_i2u, r1A60);
                  body.emit(assign(r1A4A, bit_or(r1A4A, r1A61), 0x01));


               body.instructions = f1A4F_parent_instructions;
               body.emit(f1A4F);

               /* END IF */

               body.emit(assign(r1A0F, r1A4C, 0x01));

               body.emit(assign(r1A10, r1A4B, 0x01));

               body.emit(assign(r1A12, r1A4A, 0x01));

               body.emit(assign(r1A11, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1A44->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1A63 = equal(r1A17, body.constant(int(2047)));
               ir_if *f1A62 = new(mem_ctx) ir_if(operand(r1A63).val);
               exec_list *const f1A62_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1A62->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1A65 = bit_or(r1A0F, r1A10);
                  ir_expression *const r1A66 = bit_or(r1A0D, r1A0E);
                  ir_expression *const r1A67 = bit_or(r1A65, r1A66);
                  ir_expression *const r1A68 = nequal(r1A67, body.constant(0u));
                  ir_if *f1A64 = new(mem_ctx) ir_if(operand(r1A68).val);
                  exec_list *const f1A64_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1A64->then_instructions;

                     ir_variable *const r1A69 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1A69, swizzle_x(r19D2), 0x01));

                     ir_variable *const r1A6A = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1A6A, body.constant(0u), 0x01));

                     ir_variable *const r1A6B = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r1A69, bit_or(swizzle_y(r19D2), body.constant(524288u)), 0x02));

                     body.emit(assign(r1A6A, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1A6D = lshift(swizzle_y(r19D2), body.constant(int(1)));
                     ir_expression *const r1A6E = lequal(body.constant(4292870144u), r1A6D);
                     ir_expression *const r1A6F = nequal(swizzle_x(r19D2), body.constant(0u));
                     ir_expression *const r1A70 = bit_and(swizzle_y(r19D2), body.constant(1048575u));
                     ir_expression *const r1A71 = nequal(r1A70, body.constant(0u));
                     ir_expression *const r1A72 = logic_or(r1A6F, r1A71);
                     ir_expression *const r1A73 = logic_and(r1A6E, r1A72);
                     ir_if *f1A6C = new(mem_ctx) ir_if(operand(r1A73).val);
                     exec_list *const f1A6C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1A6C->then_instructions;

                        body.emit(assign(r1A6B, r1A69, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1A6C->else_instructions;

                        body.emit(assign(r1A6B, r1A6A, 0x03));


                     body.instructions = f1A6C_parent_instructions;
                     body.emit(f1A6C);

                     /* END IF */

                     body.emit(assign(r1A0B, r1A6B, 0x03));

                     body.emit(assign(r1A0A, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1A64->else_instructions;

                     body.emit(assign(r1A0B, r19D2, 0x03));

                     body.emit(assign(r1A0A, body.constant(false), 0x01));


                  body.instructions = f1A64_parent_instructions;
                  body.emit(f1A64);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1A62->else_instructions;

                  ir_variable *const r1A74 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r1A75 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1A75, add(r1A10, r1A0E), 0x01));

                  ir_expression *const r1A76 = add(r1A0F, r1A0D);
                  ir_expression *const r1A77 = less(r1A75, r1A10);
                  ir_expression *const r1A78 = expr(ir_unop_b2i, r1A77);
                  ir_expression *const r1A79 = expr(ir_unop_i2u, r1A78);
                  body.emit(assign(r1A74, add(r1A76, r1A79), 0x01));

                  body.emit(assign(r1A13, r1A74, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1A7B = equal(r1A17, body.constant(int(0)));
                  ir_if *f1A7A = new(mem_ctx) ir_if(operand(r1A7B).val);
                  exec_list *const f1A7A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1A7A->then_instructions;

                     ir_variable *const r1A7C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1A7C);
                     ir_expression *const r1A7D = lshift(r1A07, body.constant(int(31)));
                     body.emit(assign(r1A7C, add(r1A7D, r1A74), 0x02));

                     body.emit(assign(r1A7C, r1A75, 0x01));

                     body.emit(assign(r1A0B, r1A7C, 0x03));

                     body.emit(assign(r1A0A, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1A7A->else_instructions;

                     body.emit(assign(r1A13, bit_or(r1A74, body.constant(2097152u)), 0x01));

                     body.emit(assign(r1A11, r1A17, 0x01));

                     ir_variable *const r1A7E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r1A7E);
                     ir_variable *const r1A7F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r1A7F);
                     ir_variable *const r1A80 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r1A80);
                     body.emit(assign(r1A7E, lshift(r1A75, body.constant(int(31))), 0x01));

                     ir_expression *const r1A81 = lshift(r1A13, body.constant(int(31)));
                     ir_expression *const r1A82 = rshift(r1A75, body.constant(int(1)));
                     body.emit(assign(r1A7F, bit_or(r1A81, r1A82), 0x01));

                     body.emit(assign(r1A80, rshift(r1A13, body.constant(int(1))), 0x01));

                     body.emit(assign(r1A7E, bit_or(r1A7E, body.constant(0u)), 0x01));

                     body.emit(assign(r1A13, r1A80, 0x01));

                     body.emit(assign(r1A12, r1A7E, 0x01));

                     ir_variable *const r1A83 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1A83, r1A17, 0x01));

                     ir_variable *const r1A84 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1A84, r1A80, 0x01));

                     ir_variable *const r1A85 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1A85, r1A7F, 0x01));

                     ir_variable *const r1A86 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1A86, r1A7E, 0x01));

                     ir_variable *const r1A87 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1A87, body.constant(true), 0x01));

                     ir_variable *const r1A88 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1A89 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1A89);
                     ir_expression *const r1A8A = expr(ir_unop_u2i, r1A7E);
                     body.emit(assign(r1A89, less(r1A8A, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1A8C = lequal(body.constant(int(2045)), r1A17);
                     ir_if *f1A8B = new(mem_ctx) ir_if(operand(r1A8C).val);
                     exec_list *const f1A8B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1A8B->then_instructions;

                        ir_variable *const r1A8D = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1A8F = less(body.constant(int(2045)), r1A17);
                        ir_if *f1A8E = new(mem_ctx) ir_if(operand(r1A8F).val);
                        exec_list *const f1A8E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A8E->then_instructions;

                           body.emit(assign(r1A8D, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1A8E->else_instructions;

                           ir_variable *const r1A90 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1A92 = equal(r1A17, body.constant(int(2045)));
                           ir_if *f1A91 = new(mem_ctx) ir_if(operand(r1A92).val);
                           exec_list *const f1A91_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1A91->then_instructions;

                              ir_expression *const r1A93 = equal(body.constant(2097151u), r1A80);
                              ir_expression *const r1A94 = equal(body.constant(4294967295u), r1A7F);
                              body.emit(assign(r1A90, logic_and(r1A93, r1A94), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1A91->else_instructions;

                              body.emit(assign(r1A90, body.constant(false), 0x01));


                           body.instructions = f1A91_parent_instructions;
                           body.emit(f1A91);

                           /* END IF */

                           body.emit(assign(r1A8D, logic_and(r1A90, r1A89), 0x01));


                        body.instructions = f1A8E_parent_instructions;
                        body.emit(f1A8E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1A95 = new(mem_ctx) ir_if(operand(r1A8D).val);
                        exec_list *const f1A95_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A95->then_instructions;

                           ir_variable *const r1A96 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1A96);
                           ir_expression *const r1A97 = lshift(r1A07, body.constant(int(31)));
                           body.emit(assign(r1A96, add(r1A97, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1A96, body.constant(0u), 0x01));

                           body.emit(assign(r1A88, r1A96, 0x03));

                           body.emit(assign(r1A87, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1A95->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1A99 = less(r1A17, body.constant(int(0)));
                           ir_if *f1A98 = new(mem_ctx) ir_if(operand(r1A99).val);
                           exec_list *const f1A98_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1A98->then_instructions;

                              ir_variable *const r1A9A = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1A9A, r1A7E, 0x01));

                              ir_variable *const r1A9B = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1A9B, neg(r1A17), 0x01));

                              ir_variable *const r1A9C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1A9C);
                              ir_variable *const r1A9D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1A9D);
                              ir_variable *const r1A9E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1A9E);
                              ir_variable *const r1A9F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1AA0 = neg(r1A9B);
                              body.emit(assign(r1A9F, bit_and(r1AA0, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1AA2 = equal(r1A9B, body.constant(int(0)));
                              ir_if *f1AA1 = new(mem_ctx) ir_if(operand(r1AA2).val);
                              exec_list *const f1AA1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1AA1->then_instructions;

                                 body.emit(assign(r1A9C, r1A7E, 0x01));

                                 body.emit(assign(r1A9D, r1A7F, 0x01));

                                 body.emit(assign(r1A9E, r1A80, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1AA1->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1AA4 = less(r1A9B, body.constant(int(32)));
                                 ir_if *f1AA3 = new(mem_ctx) ir_if(operand(r1AA4).val);
                                 exec_list *const f1AA3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1AA3->then_instructions;

                                    body.emit(assign(r1A9C, lshift(r1A7F, r1A9F), 0x01));

                                    ir_expression *const r1AA5 = lshift(r1A80, r1A9F);
                                    ir_expression *const r1AA6 = rshift(r1A7F, r1A9B);
                                    body.emit(assign(r1A9D, bit_or(r1AA5, r1AA6), 0x01));

                                    body.emit(assign(r1A9E, rshift(r1A80, r1A9B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1AA3->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1AA8 = equal(r1A9B, body.constant(int(32)));
                                    ir_if *f1AA7 = new(mem_ctx) ir_if(operand(r1AA8).val);
                                    exec_list *const f1AA7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1AA7->then_instructions;

                                       body.emit(assign(r1A9C, r1A7F, 0x01));

                                       body.emit(assign(r1A9D, r1A80, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1AA7->else_instructions;

                                       body.emit(assign(r1A9A, bit_or(r1A7E, r1A7F), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1AAA = less(r1A9B, body.constant(int(64)));
                                       ir_if *f1AA9 = new(mem_ctx) ir_if(operand(r1AAA).val);
                                       exec_list *const f1AA9_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1AA9->then_instructions;

                                          body.emit(assign(r1A9C, lshift(r1A80, r1A9F), 0x01));

                                          ir_expression *const r1AAB = bit_and(r1A9B, body.constant(int(31)));
                                          body.emit(assign(r1A9D, rshift(r1A80, r1AAB), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1AA9->else_instructions;

                                          ir_variable *const r1AAC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1AAE = equal(r1A9B, body.constant(int(64)));
                                          ir_if *f1AAD = new(mem_ctx) ir_if(operand(r1AAE).val);
                                          exec_list *const f1AAD_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1AAD->then_instructions;

                                             body.emit(assign(r1AAC, r1A80, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1AAD->else_instructions;

                                             ir_expression *const r1AAF = nequal(r1A80, body.constant(0u));
                                             ir_expression *const r1AB0 = expr(ir_unop_b2i, r1AAF);
                                             body.emit(assign(r1AAC, expr(ir_unop_i2u, r1AB0), 0x01));


                                          body.instructions = f1AAD_parent_instructions;
                                          body.emit(f1AAD);

                                          /* END IF */

                                          body.emit(assign(r1A9C, r1AAC, 0x01));

                                          body.emit(assign(r1A9D, body.constant(0u), 0x01));


                                       body.instructions = f1AA9_parent_instructions;
                                       body.emit(f1AA9);

                                       /* END IF */


                                    body.instructions = f1AA7_parent_instructions;
                                    body.emit(f1AA7);

                                    /* END IF */

                                    body.emit(assign(r1A9E, body.constant(0u), 0x01));


                                 body.instructions = f1AA3_parent_instructions;
                                 body.emit(f1AA3);

                                 /* END IF */

                                 ir_expression *const r1AB1 = nequal(r1A9A, body.constant(0u));
                                 ir_expression *const r1AB2 = expr(ir_unop_b2i, r1AB1);
                                 ir_expression *const r1AB3 = expr(ir_unop_i2u, r1AB2);
                                 body.emit(assign(r1A9C, bit_or(r1A9C, r1AB3), 0x01));


                              body.instructions = f1AA1_parent_instructions;
                              body.emit(f1AA1);

                              /* END IF */

                              body.emit(assign(r1A84, r1A9E, 0x01));

                              body.emit(assign(r1A85, r1A9D, 0x01));

                              body.emit(assign(r1A86, r1A9C, 0x01));

                              body.emit(assign(r1A83, body.constant(int(0)), 0x01));

                              body.emit(assign(r1A89, less(r1A9C, body.constant(0u)), 0x01));


                           body.instructions = f1A98_parent_instructions;
                           body.emit(f1A98);

                           /* END IF */


                        body.instructions = f1A95_parent_instructions;
                        body.emit(f1A95);

                        /* END IF */


                     body.instructions = f1A8B_parent_instructions;
                     body.emit(f1A8B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f1AB4 = new(mem_ctx) ir_if(operand(r1A87).val);
                     exec_list *const f1AB4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1AB4->then_instructions;

                        /* IF CONDITION */
                        ir_if *f1AB5 = new(mem_ctx) ir_if(operand(r1A89).val);
                        exec_list *const f1AB5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1AB5->then_instructions;

                           ir_variable *const r1AB6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r1AB6, add(r1A85, body.constant(1u)), 0x01));

                           ir_expression *const r1AB7 = less(r1AB6, r1A85);
                           ir_expression *const r1AB8 = expr(ir_unop_b2i, r1AB7);
                           ir_expression *const r1AB9 = expr(ir_unop_i2u, r1AB8);
                           body.emit(assign(r1A84, add(r1A84, r1AB9), 0x01));

                           ir_expression *const r1ABA = equal(r1A86, body.constant(0u));
                           ir_expression *const r1ABB = expr(ir_unop_b2i, r1ABA);
                           ir_expression *const r1ABC = expr(ir_unop_i2u, r1ABB);
                           ir_expression *const r1ABD = add(r1A86, r1ABC);
                           ir_expression *const r1ABE = bit_and(r1ABD, body.constant(1u));
                           ir_expression *const r1ABF = expr(ir_unop_bit_not, r1ABE);
                           body.emit(assign(r1A85, bit_and(r1AB6, r1ABF), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1AB5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1AC1 = bit_or(r1A84, r1A85);
                           ir_expression *const r1AC2 = equal(r1AC1, body.constant(0u));
                           ir_if *f1AC0 = new(mem_ctx) ir_if(operand(r1AC2).val);
                           exec_list *const f1AC0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1AC0->then_instructions;

                              body.emit(assign(r1A83, body.constant(int(0)), 0x01));


                           body.instructions = f1AC0_parent_instructions;
                           body.emit(f1AC0);

                           /* END IF */


                        body.instructions = f1AB5_parent_instructions;
                        body.emit(f1AB5);

                        /* END IF */

                        ir_variable *const r1AC3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r1AC3);
                        ir_expression *const r1AC4 = lshift(r1A07, body.constant(int(31)));
                        ir_expression *const r1AC5 = expr(ir_unop_i2u, r1A83);
                        ir_expression *const r1AC6 = lshift(r1AC5, body.constant(int(20)));
                        ir_expression *const r1AC7 = add(r1AC4, r1AC6);
                        body.emit(assign(r1AC3, add(r1AC7, r1A84), 0x02));

                        body.emit(assign(r1AC3, r1A85, 0x01));

                        body.emit(assign(r1A88, r1AC3, 0x03));

                        body.emit(assign(r1A87, body.constant(false), 0x01));


                     body.instructions = f1AB4_parent_instructions;
                     body.emit(f1AB4);

                     /* END IF */

                     body.emit(assign(r1A0B, r1A88, 0x03));

                     body.emit(assign(r1A0A, body.constant(false), 0x01));


                  body.instructions = f1A7A_parent_instructions;
                  body.emit(f1A7A);

                  /* END IF */


               body.instructions = f1A62_parent_instructions;
               body.emit(f1A62);

               /* END IF */


            body.instructions = f1A44_parent_instructions;
            body.emit(f1A44);

            /* END IF */


         body.instructions = f1A1C_parent_instructions;
         body.emit(f1A1C);

         /* END IF */

         /* IF CONDITION */
         ir_if *f1AC8 = new(mem_ctx) ir_if(operand(r1A0A).val);
         exec_list *const f1AC8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1AC8->then_instructions;

            body.emit(assign(r1A0F, bit_or(r1A0F, body.constant(1048576u)), 0x01));

            ir_variable *const r1AC9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r1ACA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r1ACA, add(r1A10, r1A0E), 0x01));

            ir_expression *const r1ACB = add(r1A0F, r1A0D);
            ir_expression *const r1ACC = less(r1ACA, r1A10);
            ir_expression *const r1ACD = expr(ir_unop_b2i, r1ACC);
            ir_expression *const r1ACE = expr(ir_unop_i2u, r1ACD);
            body.emit(assign(r1AC9, add(r1ACB, r1ACE), 0x01));

            body.emit(assign(r1A13, r1AC9, 0x01));

            body.emit(assign(r1A11, add(r1A11, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1AD0 = less(r1AC9, body.constant(2097152u));
            ir_if *f1ACF = new(mem_ctx) ir_if(operand(r1AD0).val);
            exec_list *const f1ACF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1ACF->then_instructions;

               ir_variable *const r1AD1 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1AD1, r1A11, 0x01));

               ir_variable *const r1AD2 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1AD2, r1AC9, 0x01));

               ir_variable *const r1AD3 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1AD3, r1ACA, 0x01));

               ir_variable *const r1AD4 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1AD4, r1A12, 0x01));

               ir_variable *const r1AD5 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1AD5, body.constant(true), 0x01));

               ir_variable *const r1AD6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1AD7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1AD7);
               ir_expression *const r1AD8 = expr(ir_unop_u2i, r1A12);
               body.emit(assign(r1AD7, less(r1AD8, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1ADA = lequal(body.constant(int(2045)), r1A11);
               ir_if *f1AD9 = new(mem_ctx) ir_if(operand(r1ADA).val);
               exec_list *const f1AD9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1AD9->then_instructions;

                  ir_variable *const r1ADB = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1ADD = less(body.constant(int(2045)), r1A11);
                  ir_if *f1ADC = new(mem_ctx) ir_if(operand(r1ADD).val);
                  exec_list *const f1ADC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1ADC->then_instructions;

                     body.emit(assign(r1ADB, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1ADC->else_instructions;

                     ir_variable *const r1ADE = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1AE0 = equal(r1A11, body.constant(int(2045)));
                     ir_if *f1ADF = new(mem_ctx) ir_if(operand(r1AE0).val);
                     exec_list *const f1ADF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1ADF->then_instructions;

                        ir_expression *const r1AE1 = equal(body.constant(2097151u), r1AC9);
                        ir_expression *const r1AE2 = equal(body.constant(4294967295u), r1ACA);
                        body.emit(assign(r1ADE, logic_and(r1AE1, r1AE2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1ADF->else_instructions;

                        body.emit(assign(r1ADE, body.constant(false), 0x01));


                     body.instructions = f1ADF_parent_instructions;
                     body.emit(f1ADF);

                     /* END IF */

                     body.emit(assign(r1ADB, logic_and(r1ADE, r1AD7), 0x01));


                  body.instructions = f1ADC_parent_instructions;
                  body.emit(f1ADC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1AE3 = new(mem_ctx) ir_if(operand(r1ADB).val);
                  exec_list *const f1AE3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1AE3->then_instructions;

                     ir_variable *const r1AE4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1AE4);
                     ir_expression *const r1AE5 = lshift(r1A07, body.constant(int(31)));
                     body.emit(assign(r1AE4, add(r1AE5, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1AE4, body.constant(0u), 0x01));

                     body.emit(assign(r1AD6, r1AE4, 0x03));

                     body.emit(assign(r1AD5, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1AE3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1AE7 = less(r1A11, body.constant(int(0)));
                     ir_if *f1AE6 = new(mem_ctx) ir_if(operand(r1AE7).val);
                     exec_list *const f1AE6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1AE6->then_instructions;

                        ir_variable *const r1AE8 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1AE8, r1A12, 0x01));

                        ir_variable *const r1AE9 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1AE9, neg(r1A11), 0x01));

                        ir_variable *const r1AEA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1AEA);
                        ir_variable *const r1AEB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1AEB);
                        ir_variable *const r1AEC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1AEC);
                        ir_variable *const r1AED = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1AEE = neg(r1AE9);
                        body.emit(assign(r1AED, bit_and(r1AEE, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1AF0 = equal(r1AE9, body.constant(int(0)));
                        ir_if *f1AEF = new(mem_ctx) ir_if(operand(r1AF0).val);
                        exec_list *const f1AEF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1AEF->then_instructions;

                           body.emit(assign(r1AEA, r1A12, 0x01));

                           body.emit(assign(r1AEB, r1ACA, 0x01));

                           body.emit(assign(r1AEC, r1AC9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1AEF->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1AF2 = less(r1AE9, body.constant(int(32)));
                           ir_if *f1AF1 = new(mem_ctx) ir_if(operand(r1AF2).val);
                           exec_list *const f1AF1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1AF1->then_instructions;

                              body.emit(assign(r1AEA, lshift(r1ACA, r1AED), 0x01));

                              ir_expression *const r1AF3 = lshift(r1AC9, r1AED);
                              ir_expression *const r1AF4 = rshift(r1ACA, r1AE9);
                              body.emit(assign(r1AEB, bit_or(r1AF3, r1AF4), 0x01));

                              body.emit(assign(r1AEC, rshift(r1AC9, r1AE9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1AF1->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1AF6 = equal(r1AE9, body.constant(int(32)));
                              ir_if *f1AF5 = new(mem_ctx) ir_if(operand(r1AF6).val);
                              exec_list *const f1AF5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1AF5->then_instructions;

                                 body.emit(assign(r1AEA, r1ACA, 0x01));

                                 body.emit(assign(r1AEB, r1AC9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1AF5->else_instructions;

                                 body.emit(assign(r1AE8, bit_or(r1A12, r1ACA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1AF8 = less(r1AE9, body.constant(int(64)));
                                 ir_if *f1AF7 = new(mem_ctx) ir_if(operand(r1AF8).val);
                                 exec_list *const f1AF7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1AF7->then_instructions;

                                    body.emit(assign(r1AEA, lshift(r1AC9, r1AED), 0x01));

                                    ir_expression *const r1AF9 = bit_and(r1AE9, body.constant(int(31)));
                                    body.emit(assign(r1AEB, rshift(r1AC9, r1AF9), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1AF7->else_instructions;

                                    ir_variable *const r1AFA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1AFC = equal(r1AE9, body.constant(int(64)));
                                    ir_if *f1AFB = new(mem_ctx) ir_if(operand(r1AFC).val);
                                    exec_list *const f1AFB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1AFB->then_instructions;

                                       body.emit(assign(r1AFA, r1AC9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1AFB->else_instructions;

                                       ir_expression *const r1AFD = nequal(r1AC9, body.constant(0u));
                                       ir_expression *const r1AFE = expr(ir_unop_b2i, r1AFD);
                                       body.emit(assign(r1AFA, expr(ir_unop_i2u, r1AFE), 0x01));


                                    body.instructions = f1AFB_parent_instructions;
                                    body.emit(f1AFB);

                                    /* END IF */

                                    body.emit(assign(r1AEA, r1AFA, 0x01));

                                    body.emit(assign(r1AEB, body.constant(0u), 0x01));


                                 body.instructions = f1AF7_parent_instructions;
                                 body.emit(f1AF7);

                                 /* END IF */


                              body.instructions = f1AF5_parent_instructions;
                              body.emit(f1AF5);

                              /* END IF */

                              body.emit(assign(r1AEC, body.constant(0u), 0x01));


                           body.instructions = f1AF1_parent_instructions;
                           body.emit(f1AF1);

                           /* END IF */

                           ir_expression *const r1AFF = nequal(r1AE8, body.constant(0u));
                           ir_expression *const r1B00 = expr(ir_unop_b2i, r1AFF);
                           ir_expression *const r1B01 = expr(ir_unop_i2u, r1B00);
                           body.emit(assign(r1AEA, bit_or(r1AEA, r1B01), 0x01));


                        body.instructions = f1AEF_parent_instructions;
                        body.emit(f1AEF);

                        /* END IF */

                        body.emit(assign(r1AD2, r1AEC, 0x01));

                        body.emit(assign(r1AD3, r1AEB, 0x01));

                        body.emit(assign(r1AD4, r1AEA, 0x01));

                        body.emit(assign(r1AD1, body.constant(int(0)), 0x01));

                        body.emit(assign(r1AD7, less(r1AEA, body.constant(0u)), 0x01));


                     body.instructions = f1AE6_parent_instructions;
                     body.emit(f1AE6);

                     /* END IF */


                  body.instructions = f1AE3_parent_instructions;
                  body.emit(f1AE3);

                  /* END IF */


               body.instructions = f1AD9_parent_instructions;
               body.emit(f1AD9);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1B02 = new(mem_ctx) ir_if(operand(r1AD5).val);
               exec_list *const f1B02_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1B02->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1B03 = new(mem_ctx) ir_if(operand(r1AD7).val);
                  exec_list *const f1B03_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1B03->then_instructions;

                     ir_variable *const r1B04 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1B04, add(r1AD3, body.constant(1u)), 0x01));

                     ir_expression *const r1B05 = less(r1B04, r1AD3);
                     ir_expression *const r1B06 = expr(ir_unop_b2i, r1B05);
                     ir_expression *const r1B07 = expr(ir_unop_i2u, r1B06);
                     body.emit(assign(r1AD2, add(r1AD2, r1B07), 0x01));

                     ir_expression *const r1B08 = equal(r1AD4, body.constant(0u));
                     ir_expression *const r1B09 = expr(ir_unop_b2i, r1B08);
                     ir_expression *const r1B0A = expr(ir_unop_i2u, r1B09);
                     ir_expression *const r1B0B = add(r1AD4, r1B0A);
                     ir_expression *const r1B0C = bit_and(r1B0B, body.constant(1u));
                     ir_expression *const r1B0D = expr(ir_unop_bit_not, r1B0C);
                     body.emit(assign(r1AD3, bit_and(r1B04, r1B0D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1B03->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1B0F = bit_or(r1AD2, r1AD3);
                     ir_expression *const r1B10 = equal(r1B0F, body.constant(0u));
                     ir_if *f1B0E = new(mem_ctx) ir_if(operand(r1B10).val);
                     exec_list *const f1B0E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1B0E->then_instructions;

                        body.emit(assign(r1AD1, body.constant(int(0)), 0x01));


                     body.instructions = f1B0E_parent_instructions;
                     body.emit(f1B0E);

                     /* END IF */


                  body.instructions = f1B03_parent_instructions;
                  body.emit(f1B03);

                  /* END IF */

                  ir_variable *const r1B11 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1B11);
                  ir_expression *const r1B12 = lshift(r1A07, body.constant(int(31)));
                  ir_expression *const r1B13 = expr(ir_unop_i2u, r1AD1);
                  ir_expression *const r1B14 = lshift(r1B13, body.constant(int(20)));
                  ir_expression *const r1B15 = add(r1B12, r1B14);
                  body.emit(assign(r1B11, add(r1B15, r1AD2), 0x02));

                  body.emit(assign(r1B11, r1AD3, 0x01));

                  body.emit(assign(r1AD6, r1B11, 0x03));

                  body.emit(assign(r1AD5, body.constant(false), 0x01));


               body.instructions = f1B02_parent_instructions;
               body.emit(f1B02);

               /* END IF */

               body.emit(assign(r1A0B, r1AD6, 0x03));

               body.emit(assign(r1A0A, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1ACF->else_instructions;

               body.emit(assign(r1A11, add(r1A11, body.constant(int(1))), 0x01));

               ir_variable *const r1B16 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r1B16);
               ir_variable *const r1B17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1B17);
               ir_variable *const r1B18 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1B18);
               body.emit(assign(r1B16, lshift(r1ACA, body.constant(int(31))), 0x01));

               ir_expression *const r1B19 = lshift(r1AC9, body.constant(int(31)));
               ir_expression *const r1B1A = rshift(r1ACA, body.constant(int(1)));
               body.emit(assign(r1B17, bit_or(r1B19, r1B1A), 0x01));

               body.emit(assign(r1B18, rshift(r1AC9, body.constant(int(1))), 0x01));

               ir_expression *const r1B1B = nequal(r1A12, body.constant(0u));
               ir_expression *const r1B1C = expr(ir_unop_b2i, r1B1B);
               ir_expression *const r1B1D = expr(ir_unop_i2u, r1B1C);
               body.emit(assign(r1B16, bit_or(r1B16, r1B1D), 0x01));

               body.emit(assign(r1A13, r1B18, 0x01));

               body.emit(assign(r1A12, r1B16, 0x01));

               ir_variable *const r1B1E = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1B1E, r1A11, 0x01));

               ir_variable *const r1B1F = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1B1F, r1B18, 0x01));

               ir_variable *const r1B20 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1B20, r1B17, 0x01));

               ir_variable *const r1B21 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1B21, r1B16, 0x01));

               ir_variable *const r1B22 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1B22, body.constant(true), 0x01));

               ir_variable *const r1B23 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1B24 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1B24);
               ir_expression *const r1B25 = expr(ir_unop_u2i, r1B16);
               body.emit(assign(r1B24, less(r1B25, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1B27 = lequal(body.constant(int(2045)), r1A11);
               ir_if *f1B26 = new(mem_ctx) ir_if(operand(r1B27).val);
               exec_list *const f1B26_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1B26->then_instructions;

                  ir_variable *const r1B28 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1B2A = less(body.constant(int(2045)), r1A11);
                  ir_if *f1B29 = new(mem_ctx) ir_if(operand(r1B2A).val);
                  exec_list *const f1B29_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1B29->then_instructions;

                     body.emit(assign(r1B28, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1B29->else_instructions;

                     ir_variable *const r1B2B = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1B2D = equal(r1A11, body.constant(int(2045)));
                     ir_if *f1B2C = new(mem_ctx) ir_if(operand(r1B2D).val);
                     exec_list *const f1B2C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1B2C->then_instructions;

                        ir_expression *const r1B2E = equal(body.constant(2097151u), r1B18);
                        ir_expression *const r1B2F = equal(body.constant(4294967295u), r1B17);
                        body.emit(assign(r1B2B, logic_and(r1B2E, r1B2F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1B2C->else_instructions;

                        body.emit(assign(r1B2B, body.constant(false), 0x01));


                     body.instructions = f1B2C_parent_instructions;
                     body.emit(f1B2C);

                     /* END IF */

                     body.emit(assign(r1B28, logic_and(r1B2B, r1B24), 0x01));


                  body.instructions = f1B29_parent_instructions;
                  body.emit(f1B29);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1B30 = new(mem_ctx) ir_if(operand(r1B28).val);
                  exec_list *const f1B30_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1B30->then_instructions;

                     ir_variable *const r1B31 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1B31);
                     ir_expression *const r1B32 = lshift(r1A07, body.constant(int(31)));
                     body.emit(assign(r1B31, add(r1B32, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1B31, body.constant(0u), 0x01));

                     body.emit(assign(r1B23, r1B31, 0x03));

                     body.emit(assign(r1B22, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1B30->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1B34 = less(r1A11, body.constant(int(0)));
                     ir_if *f1B33 = new(mem_ctx) ir_if(operand(r1B34).val);
                     exec_list *const f1B33_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1B33->then_instructions;

                        ir_variable *const r1B35 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1B35, r1B16, 0x01));

                        ir_variable *const r1B36 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1B36, neg(r1A11), 0x01));

                        ir_variable *const r1B37 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1B37);
                        ir_variable *const r1B38 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1B38);
                        ir_variable *const r1B39 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1B39);
                        ir_variable *const r1B3A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1B3B = neg(r1B36);
                        body.emit(assign(r1B3A, bit_and(r1B3B, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1B3D = equal(r1B36, body.constant(int(0)));
                        ir_if *f1B3C = new(mem_ctx) ir_if(operand(r1B3D).val);
                        exec_list *const f1B3C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1B3C->then_instructions;

                           body.emit(assign(r1B37, r1B16, 0x01));

                           body.emit(assign(r1B38, r1B17, 0x01));

                           body.emit(assign(r1B39, r1B18, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1B3C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1B3F = less(r1B36, body.constant(int(32)));
                           ir_if *f1B3E = new(mem_ctx) ir_if(operand(r1B3F).val);
                           exec_list *const f1B3E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1B3E->then_instructions;

                              body.emit(assign(r1B37, lshift(r1B17, r1B3A), 0x01));

                              ir_expression *const r1B40 = lshift(r1B18, r1B3A);
                              ir_expression *const r1B41 = rshift(r1B17, r1B36);
                              body.emit(assign(r1B38, bit_or(r1B40, r1B41), 0x01));

                              body.emit(assign(r1B39, rshift(r1B18, r1B36), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1B3E->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1B43 = equal(r1B36, body.constant(int(32)));
                              ir_if *f1B42 = new(mem_ctx) ir_if(operand(r1B43).val);
                              exec_list *const f1B42_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1B42->then_instructions;

                                 body.emit(assign(r1B37, r1B17, 0x01));

                                 body.emit(assign(r1B38, r1B18, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1B42->else_instructions;

                                 body.emit(assign(r1B35, bit_or(r1B16, r1B17), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1B45 = less(r1B36, body.constant(int(64)));
                                 ir_if *f1B44 = new(mem_ctx) ir_if(operand(r1B45).val);
                                 exec_list *const f1B44_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1B44->then_instructions;

                                    body.emit(assign(r1B37, lshift(r1B18, r1B3A), 0x01));

                                    ir_expression *const r1B46 = bit_and(r1B36, body.constant(int(31)));
                                    body.emit(assign(r1B38, rshift(r1B18, r1B46), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1B44->else_instructions;

                                    ir_variable *const r1B47 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1B49 = equal(r1B36, body.constant(int(64)));
                                    ir_if *f1B48 = new(mem_ctx) ir_if(operand(r1B49).val);
                                    exec_list *const f1B48_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1B48->then_instructions;

                                       body.emit(assign(r1B47, r1B18, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1B48->else_instructions;

                                       ir_expression *const r1B4A = nequal(r1B18, body.constant(0u));
                                       ir_expression *const r1B4B = expr(ir_unop_b2i, r1B4A);
                                       body.emit(assign(r1B47, expr(ir_unop_i2u, r1B4B), 0x01));


                                    body.instructions = f1B48_parent_instructions;
                                    body.emit(f1B48);

                                    /* END IF */

                                    body.emit(assign(r1B37, r1B47, 0x01));

                                    body.emit(assign(r1B38, body.constant(0u), 0x01));


                                 body.instructions = f1B44_parent_instructions;
                                 body.emit(f1B44);

                                 /* END IF */


                              body.instructions = f1B42_parent_instructions;
                              body.emit(f1B42);

                              /* END IF */

                              body.emit(assign(r1B39, body.constant(0u), 0x01));


                           body.instructions = f1B3E_parent_instructions;
                           body.emit(f1B3E);

                           /* END IF */

                           ir_expression *const r1B4C = nequal(r1B35, body.constant(0u));
                           ir_expression *const r1B4D = expr(ir_unop_b2i, r1B4C);
                           ir_expression *const r1B4E = expr(ir_unop_i2u, r1B4D);
                           body.emit(assign(r1B37, bit_or(r1B37, r1B4E), 0x01));


                        body.instructions = f1B3C_parent_instructions;
                        body.emit(f1B3C);

                        /* END IF */

                        body.emit(assign(r1B1F, r1B39, 0x01));

                        body.emit(assign(r1B20, r1B38, 0x01));

                        body.emit(assign(r1B21, r1B37, 0x01));

                        body.emit(assign(r1B1E, body.constant(int(0)), 0x01));

                        body.emit(assign(r1B24, less(r1B37, body.constant(0u)), 0x01));


                     body.instructions = f1B33_parent_instructions;
                     body.emit(f1B33);

                     /* END IF */


                  body.instructions = f1B30_parent_instructions;
                  body.emit(f1B30);

                  /* END IF */


               body.instructions = f1B26_parent_instructions;
               body.emit(f1B26);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1B4F = new(mem_ctx) ir_if(operand(r1B22).val);
               exec_list *const f1B4F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1B4F->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1B50 = new(mem_ctx) ir_if(operand(r1B24).val);
                  exec_list *const f1B50_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1B50->then_instructions;

                     ir_variable *const r1B51 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1B51, add(r1B20, body.constant(1u)), 0x01));

                     ir_expression *const r1B52 = less(r1B51, r1B20);
                     ir_expression *const r1B53 = expr(ir_unop_b2i, r1B52);
                     ir_expression *const r1B54 = expr(ir_unop_i2u, r1B53);
                     body.emit(assign(r1B1F, add(r1B1F, r1B54), 0x01));

                     ir_expression *const r1B55 = equal(r1B21, body.constant(0u));
                     ir_expression *const r1B56 = expr(ir_unop_b2i, r1B55);
                     ir_expression *const r1B57 = expr(ir_unop_i2u, r1B56);
                     ir_expression *const r1B58 = add(r1B21, r1B57);
                     ir_expression *const r1B59 = bit_and(r1B58, body.constant(1u));
                     ir_expression *const r1B5A = expr(ir_unop_bit_not, r1B59);
                     body.emit(assign(r1B20, bit_and(r1B51, r1B5A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1B50->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1B5C = bit_or(r1B1F, r1B20);
                     ir_expression *const r1B5D = equal(r1B5C, body.constant(0u));
                     ir_if *f1B5B = new(mem_ctx) ir_if(operand(r1B5D).val);
                     exec_list *const f1B5B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1B5B->then_instructions;

                        body.emit(assign(r1B1E, body.constant(int(0)), 0x01));


                     body.instructions = f1B5B_parent_instructions;
                     body.emit(f1B5B);

                     /* END IF */


                  body.instructions = f1B50_parent_instructions;
                  body.emit(f1B50);

                  /* END IF */

                  ir_variable *const r1B5E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1B5E);
                  ir_expression *const r1B5F = lshift(r1A07, body.constant(int(31)));
                  ir_expression *const r1B60 = expr(ir_unop_i2u, r1B1E);
                  ir_expression *const r1B61 = lshift(r1B60, body.constant(int(20)));
                  ir_expression *const r1B62 = add(r1B5F, r1B61);
                  body.emit(assign(r1B5E, add(r1B62, r1B1F), 0x02));

                  body.emit(assign(r1B5E, r1B20, 0x01));

                  body.emit(assign(r1B23, r1B5E, 0x03));

                  body.emit(assign(r1B22, body.constant(false), 0x01));


               body.instructions = f1B4F_parent_instructions;
               body.emit(f1B4F);

               /* END IF */

               body.emit(assign(r1A0B, r1B23, 0x03));

               body.emit(assign(r1A0A, body.constant(false), 0x01));


            body.instructions = f1ACF_parent_instructions;
            body.emit(f1ACF);

            /* END IF */


         body.instructions = f1AC8_parent_instructions;
         body.emit(f1AC8);

         /* END IF */

         body.emit(assign(r1A06, r1A0B, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A08->else_instructions;

         ir_variable *const r1B63 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r1B63, r1A07, 0x01));

         ir_variable *const r1B64 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r1B65 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r1B65);
         ir_variable *const r1B66 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r1B66);
         ir_variable *const r1B67 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r1B67);
         ir_variable *const r1B68 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r1B68);
         ir_variable *const r1B69 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r1B69);
         ir_variable *const r1B6A = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r1B6A);
         ir_variable *const r1B6B = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r1B6B);
         ir_variable *const r1B6C = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r1B6C);
         ir_variable *const r1B6D = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r1B6D, body.constant(0u), 0x01));

         ir_variable *const r1B6E = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r1B6F = rshift(swizzle_y(r19D2), body.constant(int(20)));
         ir_expression *const r1B70 = bit_and(r1B6F, body.constant(2047u));
         body.emit(assign(r1B6E, expr(ir_unop_u2i, r1B70), 0x01));

         body.emit(assign(r1B67, r1B6E, 0x01));

         body.emit(assign(r1B66, body.constant(int(1023)), 0x01));

         body.emit(assign(r1B65, add(r1B6E, body.constant(int(-1023))), 0x01));

         ir_variable *const r1B71 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1B71, lshift(swizzle_x(r19D2), body.constant(int(10))), 0x01));

         ir_variable *const r1B72 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r1B73 = bit_and(swizzle_y(r19D2), body.constant(1048575u));
         ir_expression *const r1B74 = lshift(r1B73, body.constant(int(10)));
         ir_expression *const r1B75 = rshift(swizzle_x(r19D2), body.constant(int(22)));
         body.emit(assign(r1B72, bit_or(r1B74, r1B75), 0x01));

         body.emit(assign(r1B6A, r1B72, 0x01));

         body.emit(assign(r1B6B, r1B71, 0x01));

         ir_variable *const r1B76 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1B76, body.constant(0u), 0x01));

         ir_variable *const r1B77 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r1B77, body.constant(0u), 0x01));

         body.emit(assign(r1B68, r1B77, 0x01));

         body.emit(assign(r1B69, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r1B79 = less(body.constant(int(0)), r1B65);
         ir_if *f1B78 = new(mem_ctx) ir_if(operand(r1B79).val);
         exec_list *const f1B78_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B78->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1B7B = equal(r1B6E, body.constant(int(2047)));
            ir_if *f1B7A = new(mem_ctx) ir_if(operand(r1B7B).val);
            exec_list *const f1B7A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1B7A->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1B7D = bit_or(r1B72, r1B71);
               ir_expression *const r1B7E = nequal(r1B7D, body.constant(0u));
               ir_if *f1B7C = new(mem_ctx) ir_if(operand(r1B7E).val);
               exec_list *const f1B7C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1B7C->then_instructions;

                  ir_variable *const r1B7F = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1B7F, swizzle_x(r19D2), 0x01));

                  ir_variable *const r1B80 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1B80, body.constant(0u), 0x01));

                  ir_variable *const r1B81 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r1B7F, bit_or(swizzle_y(r19D2), body.constant(524288u)), 0x02));

                  body.emit(assign(r1B80, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1B83 = lshift(swizzle_y(r19D2), body.constant(int(1)));
                  ir_expression *const r1B84 = lequal(body.constant(4292870144u), r1B83);
                  ir_expression *const r1B85 = nequal(swizzle_x(r19D2), body.constant(0u));
                  ir_expression *const r1B86 = bit_and(swizzle_y(r19D2), body.constant(1048575u));
                  ir_expression *const r1B87 = nequal(r1B86, body.constant(0u));
                  ir_expression *const r1B88 = logic_or(r1B85, r1B87);
                  ir_expression *const r1B89 = logic_and(r1B84, r1B88);
                  ir_if *f1B82 = new(mem_ctx) ir_if(operand(r1B89).val);
                  exec_list *const f1B82_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1B82->then_instructions;

                     body.emit(assign(r1B81, r1B7F, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1B82->else_instructions;

                     body.emit(assign(r1B81, r1B80, 0x03));


                  body.instructions = f1B82_parent_instructions;
                  body.emit(f1B82);

                  /* END IF */

                  body.emit(assign(r1B64, r1B81, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1B7C->else_instructions;

                  body.emit(assign(r1B64, r19D2, 0x03));


               body.instructions = f1B7C_parent_instructions;
               body.emit(f1B7C);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1B7A->else_instructions;

               body.emit(assign(r1B68, body.constant(1073741824u), 0x01));

               ir_variable *const r1B8A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1B8A);
               ir_variable *const r1B8B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1B8B);
               ir_variable *const r1B8C = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1B8D = neg(r1B65);
               body.emit(assign(r1B8C, bit_and(r1B8D, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1B8F = equal(r1B65, body.constant(int(0)));
               ir_if *f1B8E = new(mem_ctx) ir_if(operand(r1B8F).val);
               exec_list *const f1B8E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1B8E->then_instructions;

                  body.emit(assign(r1B8A, body.constant(0u), 0x01));

                  body.emit(assign(r1B8B, r1B68, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1B8E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1B91 = less(r1B65, body.constant(int(32)));
                  ir_if *f1B90 = new(mem_ctx) ir_if(operand(r1B91).val);
                  exec_list *const f1B90_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1B90->then_instructions;

                     ir_expression *const r1B92 = lshift(body.constant(1073741824u), r1B8C);
                     ir_expression *const r1B93 = bit_or(r1B92, body.constant(0u));
                     body.emit(assign(r1B8A, bit_or(r1B93, body.constant(0u)), 0x01));

                     body.emit(assign(r1B8B, rshift(body.constant(1073741824u), r1B65), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1B90->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1B95 = equal(r1B65, body.constant(int(32)));
                     ir_if *f1B94 = new(mem_ctx) ir_if(operand(r1B95).val);
                     exec_list *const f1B94_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1B94->then_instructions;

                        body.emit(assign(r1B8A, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1B94->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1B97 = less(r1B65, body.constant(int(64)));
                        ir_if *f1B96 = new(mem_ctx) ir_if(operand(r1B97).val);
                        exec_list *const f1B96_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1B96->then_instructions;

                           ir_expression *const r1B98 = bit_and(r1B65, body.constant(int(31)));
                           ir_expression *const r1B99 = rshift(body.constant(1073741824u), r1B98);
                           ir_expression *const r1B9A = lshift(body.constant(1073741824u), r1B8C);
                           ir_expression *const r1B9B = bit_or(r1B9A, body.constant(0u));
                           ir_expression *const r1B9C = nequal(r1B9B, body.constant(0u));
                           ir_expression *const r1B9D = expr(ir_unop_b2i, r1B9C);
                           ir_expression *const r1B9E = expr(ir_unop_i2u, r1B9D);
                           body.emit(assign(r1B8A, bit_or(r1B99, r1B9E), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1B96->else_instructions;

                           body.emit(assign(r1B8A, body.constant(1u), 0x01));


                        body.instructions = f1B96_parent_instructions;
                        body.emit(f1B96);

                        /* END IF */


                     body.instructions = f1B94_parent_instructions;
                     body.emit(f1B94);

                     /* END IF */

                     body.emit(assign(r1B8B, body.constant(0u), 0x01));


                  body.instructions = f1B90_parent_instructions;
                  body.emit(f1B90);

                  /* END IF */


               body.instructions = f1B8E_parent_instructions;
               body.emit(f1B8E);

               /* END IF */

               body.emit(assign(r1B68, r1B8B, 0x01));

               body.emit(assign(r1B69, r1B8A, 0x01));

               body.emit(assign(r1B6A, bit_or(r1B72, body.constant(1073741824u)), 0x01));

               ir_variable *const r1B9F = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1BA0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1BA0, sub(r1B71, r1B8A), 0x01));

               ir_expression *const r1BA1 = sub(r1B6A, r1B8B);
               ir_expression *const r1BA2 = less(r1B71, r1B8A);
               ir_expression *const r1BA3 = expr(ir_unop_b2i, r1BA2);
               ir_expression *const r1BA4 = expr(ir_unop_i2u, r1BA3);
               body.emit(assign(r1B9F, sub(r1BA1, r1BA4), 0x01));

               body.emit(assign(r1B6C, add(r1B6E, body.constant(int(-1))), 0x01));

               ir_variable *const r1BA5 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1BA5, add(r1B6C, body.constant(int(-10))), 0x01));

               ir_variable *const r1BA6 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1BA6, r1B9F, 0x01));

               ir_variable *const r1BA7 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1BA7, r1BA0, 0x01));

               ir_variable *const r1BA8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1BA8);
               ir_variable *const r1BA9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1BA9);
               /* IF CONDITION */
               ir_expression *const r1BAB = equal(r1B9F, body.constant(0u));
               ir_if *f1BAA = new(mem_ctx) ir_if(operand(r1BAB).val);
               exec_list *const f1BAA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BAA->then_instructions;

                  body.emit(assign(r1BA6, r1BA0, 0x01));

                  body.emit(assign(r1BA7, body.constant(0u), 0x01));

                  body.emit(assign(r1BA5, add(r1BA5, body.constant(int(-32))), 0x01));


               body.instructions = f1BAA_parent_instructions;
               body.emit(f1BAA);

               /* END IF */

               ir_variable *const r1BAC = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1BAC, r1BA6, 0x01));

               ir_variable *const r1BAD = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1BAE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1BAE);
               /* IF CONDITION */
               ir_expression *const r1BB0 = equal(r1BA6, body.constant(0u));
               ir_if *f1BAF = new(mem_ctx) ir_if(operand(r1BB0).val);
               exec_list *const f1BAF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BAF->then_instructions;

                  body.emit(assign(r1BAD, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1BAF->else_instructions;

                  body.emit(assign(r1BAE, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1BB2 = bit_and(r1BA6, body.constant(4294901760u));
                  ir_expression *const r1BB3 = equal(r1BB2, body.constant(0u));
                  ir_if *f1BB1 = new(mem_ctx) ir_if(operand(r1BB3).val);
                  exec_list *const f1BB1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BB1->then_instructions;

                     body.emit(assign(r1BAE, body.constant(int(16)), 0x01));

                     body.emit(assign(r1BAC, lshift(r1BA6, body.constant(int(16))), 0x01));


                  body.instructions = f1BB1_parent_instructions;
                  body.emit(f1BB1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1BB5 = bit_and(r1BAC, body.constant(4278190080u));
                  ir_expression *const r1BB6 = equal(r1BB5, body.constant(0u));
                  ir_if *f1BB4 = new(mem_ctx) ir_if(operand(r1BB6).val);
                  exec_list *const f1BB4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BB4->then_instructions;

                     body.emit(assign(r1BAE, add(r1BAE, body.constant(int(8))), 0x01));

                     body.emit(assign(r1BAC, lshift(r1BAC, body.constant(int(8))), 0x01));


                  body.instructions = f1BB4_parent_instructions;
                  body.emit(f1BB4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1BB8 = bit_and(r1BAC, body.constant(4026531840u));
                  ir_expression *const r1BB9 = equal(r1BB8, body.constant(0u));
                  ir_if *f1BB7 = new(mem_ctx) ir_if(operand(r1BB9).val);
                  exec_list *const f1BB7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BB7->then_instructions;

                     body.emit(assign(r1BAE, add(r1BAE, body.constant(int(4))), 0x01));

                     body.emit(assign(r1BAC, lshift(r1BAC, body.constant(int(4))), 0x01));


                  body.instructions = f1BB7_parent_instructions;
                  body.emit(f1BB7);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1BBB = bit_and(r1BAC, body.constant(3221225472u));
                  ir_expression *const r1BBC = equal(r1BBB, body.constant(0u));
                  ir_if *f1BBA = new(mem_ctx) ir_if(operand(r1BBC).val);
                  exec_list *const f1BBA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BBA->then_instructions;

                     body.emit(assign(r1BAE, add(r1BAE, body.constant(int(2))), 0x01));

                     body.emit(assign(r1BAC, lshift(r1BAC, body.constant(int(2))), 0x01));


                  body.instructions = f1BBA_parent_instructions;
                  body.emit(f1BBA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1BBE = bit_and(r1BAC, body.constant(2147483648u));
                  ir_expression *const r1BBF = equal(r1BBE, body.constant(0u));
                  ir_if *f1BBD = new(mem_ctx) ir_if(operand(r1BBF).val);
                  exec_list *const f1BBD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BBD->then_instructions;

                     body.emit(assign(r1BAE, add(r1BAE, body.constant(int(1))), 0x01));


                  body.instructions = f1BBD_parent_instructions;
                  body.emit(f1BBD);

                  /* END IF */

                  body.emit(assign(r1BAD, r1BAE, 0x01));


               body.instructions = f1BAF_parent_instructions;
               body.emit(f1BAF);

               /* END IF */

               body.emit(assign(r1BA9, add(r1BAD, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1BC1 = lequal(body.constant(int(0)), r1BA9);
               ir_if *f1BC0 = new(mem_ctx) ir_if(operand(r1BC1).val);
               exec_list *const f1BC0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BC0->then_instructions;

                  body.emit(assign(r1BA8, body.constant(0u), 0x01));

                  ir_variable *const r1BC2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1BC2, lshift(r1BA7, r1BA9), 0x01));

                  ir_variable *const r1BC3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1BC5 = equal(r1BA9, body.constant(int(0)));
                  ir_if *f1BC4 = new(mem_ctx) ir_if(operand(r1BC5).val);
                  exec_list *const f1BC4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BC4->then_instructions;

                     body.emit(assign(r1BC3, r1BA6, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1BC4->else_instructions;

                     ir_expression *const r1BC6 = lshift(r1BA6, r1BA9);
                     ir_expression *const r1BC7 = neg(r1BA9);
                     ir_expression *const r1BC8 = bit_and(r1BC7, body.constant(int(31)));
                     ir_expression *const r1BC9 = rshift(r1BA7, r1BC8);
                     body.emit(assign(r1BC3, bit_or(r1BC6, r1BC9), 0x01));


                  body.instructions = f1BC4_parent_instructions;
                  body.emit(f1BC4);

                  /* END IF */

                  body.emit(assign(r1BA6, r1BC3, 0x01));

                  body.emit(assign(r1BA7, r1BC2, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1BC0->else_instructions;

                  ir_variable *const r1BCA = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1BCA, body.constant(0u), 0x01));

                  ir_variable *const r1BCB = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1BCB, neg(r1BA9), 0x01));

                  ir_variable *const r1BCC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1BCC);
                  ir_variable *const r1BCD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1BCD);
                  ir_variable *const r1BCE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1BCE);
                  ir_variable *const r1BCF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1BD0 = neg(r1BCB);
                  body.emit(assign(r1BCF, bit_and(r1BD0, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1BD2 = equal(r1BCB, body.constant(int(0)));
                  ir_if *f1BD1 = new(mem_ctx) ir_if(operand(r1BD2).val);
                  exec_list *const f1BD1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BD1->then_instructions;

                     body.emit(assign(r1BCC, r1BCA, 0x01));

                     body.emit(assign(r1BCD, r1BA7, 0x01));

                     body.emit(assign(r1BCE, r1BA6, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1BD1->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1BD4 = less(r1BCB, body.constant(int(32)));
                     ir_if *f1BD3 = new(mem_ctx) ir_if(operand(r1BD4).val);
                     exec_list *const f1BD3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BD3->then_instructions;

                        body.emit(assign(r1BCC, lshift(r1BA7, r1BCF), 0x01));

                        ir_expression *const r1BD5 = lshift(r1BA6, r1BCF);
                        ir_expression *const r1BD6 = rshift(r1BA7, r1BCB);
                        body.emit(assign(r1BCD, bit_or(r1BD5, r1BD6), 0x01));

                        body.emit(assign(r1BCE, rshift(r1BA6, r1BCB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1BD3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1BD8 = equal(r1BCB, body.constant(int(32)));
                        ir_if *f1BD7 = new(mem_ctx) ir_if(operand(r1BD8).val);
                        exec_list *const f1BD7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1BD7->then_instructions;

                           body.emit(assign(r1BCC, r1BA7, 0x01));

                           body.emit(assign(r1BCD, r1BA6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1BD7->else_instructions;

                           body.emit(assign(r1BCA, bit_or(body.constant(0u), r1BA7), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1BDA = less(r1BCB, body.constant(int(64)));
                           ir_if *f1BD9 = new(mem_ctx) ir_if(operand(r1BDA).val);
                           exec_list *const f1BD9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1BD9->then_instructions;

                              body.emit(assign(r1BCC, lshift(r1BA6, r1BCF), 0x01));

                              ir_expression *const r1BDB = bit_and(r1BCB, body.constant(int(31)));
                              body.emit(assign(r1BCD, rshift(r1BA6, r1BDB), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1BD9->else_instructions;

                              ir_variable *const r1BDC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1BDE = equal(r1BCB, body.constant(int(64)));
                              ir_if *f1BDD = new(mem_ctx) ir_if(operand(r1BDE).val);
                              exec_list *const f1BDD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1BDD->then_instructions;

                                 body.emit(assign(r1BDC, r1BA6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1BDD->else_instructions;

                                 ir_expression *const r1BDF = nequal(r1BA6, body.constant(0u));
                                 ir_expression *const r1BE0 = expr(ir_unop_b2i, r1BDF);
                                 body.emit(assign(r1BDC, expr(ir_unop_i2u, r1BE0), 0x01));


                              body.instructions = f1BDD_parent_instructions;
                              body.emit(f1BDD);

                              /* END IF */

                              body.emit(assign(r1BCC, r1BDC, 0x01));

                              body.emit(assign(r1BCD, body.constant(0u), 0x01));


                           body.instructions = f1BD9_parent_instructions;
                           body.emit(f1BD9);

                           /* END IF */


                        body.instructions = f1BD7_parent_instructions;
                        body.emit(f1BD7);

                        /* END IF */

                        body.emit(assign(r1BCE, body.constant(0u), 0x01));


                     body.instructions = f1BD3_parent_instructions;
                     body.emit(f1BD3);

                     /* END IF */

                     ir_expression *const r1BE1 = nequal(r1BCA, body.constant(0u));
                     ir_expression *const r1BE2 = expr(ir_unop_b2i, r1BE1);
                     ir_expression *const r1BE3 = expr(ir_unop_i2u, r1BE2);
                     body.emit(assign(r1BCC, bit_or(r1BCC, r1BE3), 0x01));


                  body.instructions = f1BD1_parent_instructions;
                  body.emit(f1BD1);

                  /* END IF */

                  body.emit(assign(r1BA6, r1BCE, 0x01));

                  body.emit(assign(r1BA7, r1BCD, 0x01));

                  body.emit(assign(r1BA8, r1BCC, 0x01));


               body.instructions = f1BC0_parent_instructions;
               body.emit(f1BC0);

               /* END IF */

               body.emit(assign(r1BA5, sub(r1BA5, r1BA9), 0x01));

               ir_variable *const r1BE4 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1BE4, r1BA5, 0x01));

               ir_variable *const r1BE5 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1BE5, r1BA6, 0x01));

               ir_variable *const r1BE6 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1BE6, r1BA7, 0x01));

               ir_variable *const r1BE7 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1BE7, r1BA8, 0x01));

               ir_variable *const r1BE8 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1BE8, body.constant(true), 0x01));

               ir_variable *const r1BE9 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1BEA = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1BEA);
               ir_expression *const r1BEB = expr(ir_unop_u2i, r1BA8);
               body.emit(assign(r1BEA, less(r1BEB, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1BED = lequal(body.constant(int(2045)), r1BA5);
               ir_if *f1BEC = new(mem_ctx) ir_if(operand(r1BED).val);
               exec_list *const f1BEC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BEC->then_instructions;

                  ir_variable *const r1BEE = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1BF0 = less(body.constant(int(2045)), r1BA5);
                  ir_if *f1BEF = new(mem_ctx) ir_if(operand(r1BF0).val);
                  exec_list *const f1BEF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BEF->then_instructions;

                     body.emit(assign(r1BEE, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1BEF->else_instructions;

                     ir_variable *const r1BF1 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1BF3 = equal(r1BA5, body.constant(int(2045)));
                     ir_if *f1BF2 = new(mem_ctx) ir_if(operand(r1BF3).val);
                     exec_list *const f1BF2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BF2->then_instructions;

                        ir_expression *const r1BF4 = equal(body.constant(2097151u), r1BA6);
                        ir_expression *const r1BF5 = equal(body.constant(4294967295u), r1BA7);
                        body.emit(assign(r1BF1, logic_and(r1BF4, r1BF5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1BF2->else_instructions;

                        body.emit(assign(r1BF1, body.constant(false), 0x01));


                     body.instructions = f1BF2_parent_instructions;
                     body.emit(f1BF2);

                     /* END IF */

                     body.emit(assign(r1BEE, logic_and(r1BF1, r1BEA), 0x01));


                  body.instructions = f1BEF_parent_instructions;
                  body.emit(f1BEF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1BF6 = new(mem_ctx) ir_if(operand(r1BEE).val);
                  exec_list *const f1BF6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BF6->then_instructions;

                     ir_variable *const r1BF7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1BF7);
                     ir_expression *const r1BF8 = lshift(r1A07, body.constant(int(31)));
                     body.emit(assign(r1BF7, add(r1BF8, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1BF7, body.constant(0u), 0x01));

                     body.emit(assign(r1BE9, r1BF7, 0x03));

                     body.emit(assign(r1BE8, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1BF6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1BFA = less(r1BA5, body.constant(int(0)));
                     ir_if *f1BF9 = new(mem_ctx) ir_if(operand(r1BFA).val);
                     exec_list *const f1BF9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BF9->then_instructions;

                        ir_variable *const r1BFB = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1BFB, r1BA8, 0x01));

                        ir_variable *const r1BFC = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1BFC, neg(r1BA5), 0x01));

                        ir_variable *const r1BFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1BFD);
                        ir_variable *const r1BFE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1BFE);
                        ir_variable *const r1BFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1BFF);
                        ir_variable *const r1C00 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1C01 = neg(r1BFC);
                        body.emit(assign(r1C00, bit_and(r1C01, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1C03 = equal(r1BFC, body.constant(int(0)));
                        ir_if *f1C02 = new(mem_ctx) ir_if(operand(r1C03).val);
                        exec_list *const f1C02_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1C02->then_instructions;

                           body.emit(assign(r1BFD, r1BA8, 0x01));

                           body.emit(assign(r1BFE, r1BA7, 0x01));

                           body.emit(assign(r1BFF, r1BA6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1C02->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1C05 = less(r1BFC, body.constant(int(32)));
                           ir_if *f1C04 = new(mem_ctx) ir_if(operand(r1C05).val);
                           exec_list *const f1C04_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1C04->then_instructions;

                              body.emit(assign(r1BFD, lshift(r1BA7, r1C00), 0x01));

                              ir_expression *const r1C06 = lshift(r1BA6, r1C00);
                              ir_expression *const r1C07 = rshift(r1BA7, r1BFC);
                              body.emit(assign(r1BFE, bit_or(r1C06, r1C07), 0x01));

                              body.emit(assign(r1BFF, rshift(r1BA6, r1BFC), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1C04->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1C09 = equal(r1BFC, body.constant(int(32)));
                              ir_if *f1C08 = new(mem_ctx) ir_if(operand(r1C09).val);
                              exec_list *const f1C08_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1C08->then_instructions;

                                 body.emit(assign(r1BFD, r1BA7, 0x01));

                                 body.emit(assign(r1BFE, r1BA6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1C08->else_instructions;

                                 body.emit(assign(r1BFB, bit_or(r1BA8, r1BA7), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1C0B = less(r1BFC, body.constant(int(64)));
                                 ir_if *f1C0A = new(mem_ctx) ir_if(operand(r1C0B).val);
                                 exec_list *const f1C0A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1C0A->then_instructions;

                                    body.emit(assign(r1BFD, lshift(r1BA6, r1C00), 0x01));

                                    ir_expression *const r1C0C = bit_and(r1BFC, body.constant(int(31)));
                                    body.emit(assign(r1BFE, rshift(r1BA6, r1C0C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1C0A->else_instructions;

                                    ir_variable *const r1C0D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1C0F = equal(r1BFC, body.constant(int(64)));
                                    ir_if *f1C0E = new(mem_ctx) ir_if(operand(r1C0F).val);
                                    exec_list *const f1C0E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1C0E->then_instructions;

                                       body.emit(assign(r1C0D, r1BA6, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1C0E->else_instructions;

                                       ir_expression *const r1C10 = nequal(r1BA6, body.constant(0u));
                                       ir_expression *const r1C11 = expr(ir_unop_b2i, r1C10);
                                       body.emit(assign(r1C0D, expr(ir_unop_i2u, r1C11), 0x01));


                                    body.instructions = f1C0E_parent_instructions;
                                    body.emit(f1C0E);

                                    /* END IF */

                                    body.emit(assign(r1BFD, r1C0D, 0x01));

                                    body.emit(assign(r1BFE, body.constant(0u), 0x01));


                                 body.instructions = f1C0A_parent_instructions;
                                 body.emit(f1C0A);

                                 /* END IF */


                              body.instructions = f1C08_parent_instructions;
                              body.emit(f1C08);

                              /* END IF */

                              body.emit(assign(r1BFF, body.constant(0u), 0x01));


                           body.instructions = f1C04_parent_instructions;
                           body.emit(f1C04);

                           /* END IF */

                           ir_expression *const r1C12 = nequal(r1BFB, body.constant(0u));
                           ir_expression *const r1C13 = expr(ir_unop_b2i, r1C12);
                           ir_expression *const r1C14 = expr(ir_unop_i2u, r1C13);
                           body.emit(assign(r1BFD, bit_or(r1BFD, r1C14), 0x01));


                        body.instructions = f1C02_parent_instructions;
                        body.emit(f1C02);

                        /* END IF */

                        body.emit(assign(r1BE5, r1BFF, 0x01));

                        body.emit(assign(r1BE6, r1BFE, 0x01));

                        body.emit(assign(r1BE7, r1BFD, 0x01));

                        body.emit(assign(r1BE4, body.constant(int(0)), 0x01));

                        body.emit(assign(r1BEA, less(r1BFD, body.constant(0u)), 0x01));


                     body.instructions = f1BF9_parent_instructions;
                     body.emit(f1BF9);

                     /* END IF */


                  body.instructions = f1BF6_parent_instructions;
                  body.emit(f1BF6);

                  /* END IF */


               body.instructions = f1BEC_parent_instructions;
               body.emit(f1BEC);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1C15 = new(mem_ctx) ir_if(operand(r1BE8).val);
               exec_list *const f1C15_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C15->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1C16 = new(mem_ctx) ir_if(operand(r1BEA).val);
                  exec_list *const f1C16_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C16->then_instructions;

                     ir_variable *const r1C17 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1C17, add(r1BE6, body.constant(1u)), 0x01));

                     ir_expression *const r1C18 = less(r1C17, r1BE6);
                     ir_expression *const r1C19 = expr(ir_unop_b2i, r1C18);
                     ir_expression *const r1C1A = expr(ir_unop_i2u, r1C19);
                     body.emit(assign(r1BE5, add(r1BE5, r1C1A), 0x01));

                     ir_expression *const r1C1B = equal(r1BE7, body.constant(0u));
                     ir_expression *const r1C1C = expr(ir_unop_b2i, r1C1B);
                     ir_expression *const r1C1D = expr(ir_unop_i2u, r1C1C);
                     ir_expression *const r1C1E = add(r1BE7, r1C1D);
                     ir_expression *const r1C1F = bit_and(r1C1E, body.constant(1u));
                     ir_expression *const r1C20 = expr(ir_unop_bit_not, r1C1F);
                     body.emit(assign(r1BE6, bit_and(r1C17, r1C20), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1C16->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1C22 = bit_or(r1BE5, r1BE6);
                     ir_expression *const r1C23 = equal(r1C22, body.constant(0u));
                     ir_if *f1C21 = new(mem_ctx) ir_if(operand(r1C23).val);
                     exec_list *const f1C21_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1C21->then_instructions;

                        body.emit(assign(r1BE4, body.constant(int(0)), 0x01));


                     body.instructions = f1C21_parent_instructions;
                     body.emit(f1C21);

                     /* END IF */


                  body.instructions = f1C16_parent_instructions;
                  body.emit(f1C16);

                  /* END IF */

                  ir_variable *const r1C24 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1C24);
                  ir_expression *const r1C25 = lshift(r1A07, body.constant(int(31)));
                  ir_expression *const r1C26 = expr(ir_unop_i2u, r1BE4);
                  ir_expression *const r1C27 = lshift(r1C26, body.constant(int(20)));
                  ir_expression *const r1C28 = add(r1C25, r1C27);
                  body.emit(assign(r1C24, add(r1C28, r1BE5), 0x02));

                  body.emit(assign(r1C24, r1BE6, 0x01));

                  body.emit(assign(r1BE9, r1C24, 0x03));

                  body.emit(assign(r1BE8, body.constant(false), 0x01));


               body.instructions = f1C15_parent_instructions;
               body.emit(f1C15);

               /* END IF */

               body.emit(assign(r1B64, r1BE9, 0x03));


            body.instructions = f1B7A_parent_instructions;
            body.emit(f1B7A);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B78->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1C2A = less(r1B65, body.constant(int(0)));
            ir_if *f1C29 = new(mem_ctx) ir_if(operand(r1C2A).val);
            exec_list *const f1C29_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C29->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1C2C = equal(r1B6E, body.constant(int(0)));
               ir_if *f1C2B = new(mem_ctx) ir_if(operand(r1C2C).val);
               exec_list *const f1C2B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C2B->then_instructions;

                  body.emit(assign(r1B65, add(r1B65, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C2B->else_instructions;

                  body.emit(assign(r1B6A, bit_or(r1B6A, body.constant(1073741824u)), 0x01));


               body.instructions = f1C2B_parent_instructions;
               body.emit(f1C2B);

               /* END IF */

               ir_variable *const r1C2D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1C2D, neg(r1B65), 0x01));

               ir_variable *const r1C2E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1C2E);
               ir_variable *const r1C2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1C2F);
               ir_variable *const r1C30 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1C31 = neg(r1C2D);
               body.emit(assign(r1C30, bit_and(r1C31, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1C33 = equal(r1C2D, body.constant(int(0)));
               ir_if *f1C32 = new(mem_ctx) ir_if(operand(r1C33).val);
               exec_list *const f1C32_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C32->then_instructions;

                  body.emit(assign(r1C2E, r1B71, 0x01));

                  body.emit(assign(r1C2F, r1B6A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C32->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1C35 = less(r1C2D, body.constant(int(32)));
                  ir_if *f1C34 = new(mem_ctx) ir_if(operand(r1C35).val);
                  exec_list *const f1C34_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C34->then_instructions;

                     ir_expression *const r1C36 = lshift(r1B6A, r1C30);
                     ir_expression *const r1C37 = rshift(r1B71, r1C2D);
                     ir_expression *const r1C38 = bit_or(r1C36, r1C37);
                     ir_expression *const r1C39 = lshift(r1B71, r1C30);
                     ir_expression *const r1C3A = nequal(r1C39, body.constant(0u));
                     ir_expression *const r1C3B = expr(ir_unop_b2i, r1C3A);
                     ir_expression *const r1C3C = expr(ir_unop_i2u, r1C3B);
                     body.emit(assign(r1C2E, bit_or(r1C38, r1C3C), 0x01));

                     body.emit(assign(r1C2F, rshift(r1B6A, r1C2D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1C34->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1C3E = equal(r1C2D, body.constant(int(32)));
                     ir_if *f1C3D = new(mem_ctx) ir_if(operand(r1C3E).val);
                     exec_list *const f1C3D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1C3D->then_instructions;

                        ir_expression *const r1C3F = nequal(r1B71, body.constant(0u));
                        ir_expression *const r1C40 = expr(ir_unop_b2i, r1C3F);
                        ir_expression *const r1C41 = expr(ir_unop_i2u, r1C40);
                        body.emit(assign(r1C2E, bit_or(r1B6A, r1C41), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1C3D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1C43 = less(r1C2D, body.constant(int(64)));
                        ir_if *f1C42 = new(mem_ctx) ir_if(operand(r1C43).val);
                        exec_list *const f1C42_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1C42->then_instructions;

                           ir_expression *const r1C44 = bit_and(r1C2D, body.constant(int(31)));
                           ir_expression *const r1C45 = rshift(r1B6A, r1C44);
                           ir_expression *const r1C46 = lshift(r1B6A, r1C30);
                           ir_expression *const r1C47 = bit_or(r1C46, r1B71);
                           ir_expression *const r1C48 = nequal(r1C47, body.constant(0u));
                           ir_expression *const r1C49 = expr(ir_unop_b2i, r1C48);
                           ir_expression *const r1C4A = expr(ir_unop_i2u, r1C49);
                           body.emit(assign(r1C2E, bit_or(r1C45, r1C4A), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1C42->else_instructions;

                           ir_expression *const r1C4B = bit_or(r1B6A, r1B71);
                           ir_expression *const r1C4C = nequal(r1C4B, body.constant(0u));
                           ir_expression *const r1C4D = expr(ir_unop_b2i, r1C4C);
                           body.emit(assign(r1C2E, expr(ir_unop_i2u, r1C4D), 0x01));


                        body.instructions = f1C42_parent_instructions;
                        body.emit(f1C42);

                        /* END IF */


                     body.instructions = f1C3D_parent_instructions;
                     body.emit(f1C3D);

                     /* END IF */

                     body.emit(assign(r1C2F, body.constant(0u), 0x01));


                  body.instructions = f1C34_parent_instructions;
                  body.emit(f1C34);

                  /* END IF */


               body.instructions = f1C32_parent_instructions;
               body.emit(f1C32);

               /* END IF */

               body.emit(assign(r1B6A, r1C2F, 0x01));

               body.emit(assign(r1B6B, r1C2E, 0x01));

               body.emit(assign(r1B68, bit_or(r1B68, body.constant(1073741824u)), 0x01));

               ir_variable *const r1C4E = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1C4F = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1C4F, sub(r1B69, r1C2E), 0x01));

               ir_expression *const r1C50 = sub(r1B68, r1C2F);
               ir_expression *const r1C51 = less(r1B69, r1C2E);
               ir_expression *const r1C52 = expr(ir_unop_b2i, r1C51);
               ir_expression *const r1C53 = expr(ir_unop_i2u, r1C52);
               body.emit(assign(r1C4E, sub(r1C50, r1C53), 0x01));

               body.emit(assign(r1B63, bit_xor(r1A07, body.constant(1u)), 0x01));

               body.emit(assign(r1B6C, body.constant(int(1022)), 0x01));

               ir_variable *const r1C54 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1C54, body.constant(int(1012)), 0x01));

               ir_variable *const r1C55 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1C55, r1C4E, 0x01));

               ir_variable *const r1C56 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1C56, r1C4F, 0x01));

               ir_variable *const r1C57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1C57);
               ir_variable *const r1C58 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1C58);
               /* IF CONDITION */
               ir_expression *const r1C5A = equal(r1C4E, body.constant(0u));
               ir_if *f1C59 = new(mem_ctx) ir_if(operand(r1C5A).val);
               exec_list *const f1C59_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C59->then_instructions;

                  body.emit(assign(r1C55, r1C4F, 0x01));

                  body.emit(assign(r1C56, body.constant(0u), 0x01));

                  body.emit(assign(r1C54, body.constant(int(980)), 0x01));


               body.instructions = f1C59_parent_instructions;
               body.emit(f1C59);

               /* END IF */

               ir_variable *const r1C5B = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1C5B, r1C55, 0x01));

               ir_variable *const r1C5C = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1C5D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1C5D);
               /* IF CONDITION */
               ir_expression *const r1C5F = equal(r1C55, body.constant(0u));
               ir_if *f1C5E = new(mem_ctx) ir_if(operand(r1C5F).val);
               exec_list *const f1C5E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C5E->then_instructions;

                  body.emit(assign(r1C5C, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C5E->else_instructions;

                  body.emit(assign(r1C5D, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1C61 = bit_and(r1C55, body.constant(4294901760u));
                  ir_expression *const r1C62 = equal(r1C61, body.constant(0u));
                  ir_if *f1C60 = new(mem_ctx) ir_if(operand(r1C62).val);
                  exec_list *const f1C60_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C60->then_instructions;

                     body.emit(assign(r1C5D, body.constant(int(16)), 0x01));

                     body.emit(assign(r1C5B, lshift(r1C55, body.constant(int(16))), 0x01));


                  body.instructions = f1C60_parent_instructions;
                  body.emit(f1C60);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1C64 = bit_and(r1C5B, body.constant(4278190080u));
                  ir_expression *const r1C65 = equal(r1C64, body.constant(0u));
                  ir_if *f1C63 = new(mem_ctx) ir_if(operand(r1C65).val);
                  exec_list *const f1C63_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C63->then_instructions;

                     body.emit(assign(r1C5D, add(r1C5D, body.constant(int(8))), 0x01));

                     body.emit(assign(r1C5B, lshift(r1C5B, body.constant(int(8))), 0x01));


                  body.instructions = f1C63_parent_instructions;
                  body.emit(f1C63);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1C67 = bit_and(r1C5B, body.constant(4026531840u));
                  ir_expression *const r1C68 = equal(r1C67, body.constant(0u));
                  ir_if *f1C66 = new(mem_ctx) ir_if(operand(r1C68).val);
                  exec_list *const f1C66_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C66->then_instructions;

                     body.emit(assign(r1C5D, add(r1C5D, body.constant(int(4))), 0x01));

                     body.emit(assign(r1C5B, lshift(r1C5B, body.constant(int(4))), 0x01));


                  body.instructions = f1C66_parent_instructions;
                  body.emit(f1C66);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1C6A = bit_and(r1C5B, body.constant(3221225472u));
                  ir_expression *const r1C6B = equal(r1C6A, body.constant(0u));
                  ir_if *f1C69 = new(mem_ctx) ir_if(operand(r1C6B).val);
                  exec_list *const f1C69_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C69->then_instructions;

                     body.emit(assign(r1C5D, add(r1C5D, body.constant(int(2))), 0x01));

                     body.emit(assign(r1C5B, lshift(r1C5B, body.constant(int(2))), 0x01));


                  body.instructions = f1C69_parent_instructions;
                  body.emit(f1C69);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1C6D = bit_and(r1C5B, body.constant(2147483648u));
                  ir_expression *const r1C6E = equal(r1C6D, body.constant(0u));
                  ir_if *f1C6C = new(mem_ctx) ir_if(operand(r1C6E).val);
                  exec_list *const f1C6C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C6C->then_instructions;

                     body.emit(assign(r1C5D, add(r1C5D, body.constant(int(1))), 0x01));


                  body.instructions = f1C6C_parent_instructions;
                  body.emit(f1C6C);

                  /* END IF */

                  body.emit(assign(r1C5C, r1C5D, 0x01));


               body.instructions = f1C5E_parent_instructions;
               body.emit(f1C5E);

               /* END IF */

               body.emit(assign(r1C58, add(r1C5C, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1C70 = lequal(body.constant(int(0)), r1C58);
               ir_if *f1C6F = new(mem_ctx) ir_if(operand(r1C70).val);
               exec_list *const f1C6F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C6F->then_instructions;

                  body.emit(assign(r1C57, body.constant(0u), 0x01));

                  ir_variable *const r1C71 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1C71, lshift(r1C56, r1C58), 0x01));

                  ir_variable *const r1C72 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1C74 = equal(r1C58, body.constant(int(0)));
                  ir_if *f1C73 = new(mem_ctx) ir_if(operand(r1C74).val);
                  exec_list *const f1C73_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C73->then_instructions;

                     body.emit(assign(r1C72, r1C55, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1C73->else_instructions;

                     ir_expression *const r1C75 = lshift(r1C55, r1C58);
                     ir_expression *const r1C76 = neg(r1C58);
                     ir_expression *const r1C77 = bit_and(r1C76, body.constant(int(31)));
                     ir_expression *const r1C78 = rshift(r1C56, r1C77);
                     body.emit(assign(r1C72, bit_or(r1C75, r1C78), 0x01));


                  body.instructions = f1C73_parent_instructions;
                  body.emit(f1C73);

                  /* END IF */

                  body.emit(assign(r1C55, r1C72, 0x01));

                  body.emit(assign(r1C56, r1C71, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C6F->else_instructions;

                  ir_variable *const r1C79 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1C79, body.constant(0u), 0x01));

                  ir_variable *const r1C7A = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1C7A, neg(r1C58), 0x01));

                  ir_variable *const r1C7B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1C7B);
                  ir_variable *const r1C7C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1C7C);
                  ir_variable *const r1C7D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1C7D);
                  ir_variable *const r1C7E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1C7F = neg(r1C7A);
                  body.emit(assign(r1C7E, bit_and(r1C7F, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1C81 = equal(r1C7A, body.constant(int(0)));
                  ir_if *f1C80 = new(mem_ctx) ir_if(operand(r1C81).val);
                  exec_list *const f1C80_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C80->then_instructions;

                     body.emit(assign(r1C7B, r1C79, 0x01));

                     body.emit(assign(r1C7C, r1C56, 0x01));

                     body.emit(assign(r1C7D, r1C55, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1C80->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1C83 = less(r1C7A, body.constant(int(32)));
                     ir_if *f1C82 = new(mem_ctx) ir_if(operand(r1C83).val);
                     exec_list *const f1C82_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1C82->then_instructions;

                        body.emit(assign(r1C7B, lshift(r1C56, r1C7E), 0x01));

                        ir_expression *const r1C84 = lshift(r1C55, r1C7E);
                        ir_expression *const r1C85 = rshift(r1C56, r1C7A);
                        body.emit(assign(r1C7C, bit_or(r1C84, r1C85), 0x01));

                        body.emit(assign(r1C7D, rshift(r1C55, r1C7A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1C82->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1C87 = equal(r1C7A, body.constant(int(32)));
                        ir_if *f1C86 = new(mem_ctx) ir_if(operand(r1C87).val);
                        exec_list *const f1C86_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1C86->then_instructions;

                           body.emit(assign(r1C7B, r1C56, 0x01));

                           body.emit(assign(r1C7C, r1C55, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1C86->else_instructions;

                           body.emit(assign(r1C79, bit_or(body.constant(0u), r1C56), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1C89 = less(r1C7A, body.constant(int(64)));
                           ir_if *f1C88 = new(mem_ctx) ir_if(operand(r1C89).val);
                           exec_list *const f1C88_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1C88->then_instructions;

                              body.emit(assign(r1C7B, lshift(r1C55, r1C7E), 0x01));

                              ir_expression *const r1C8A = bit_and(r1C7A, body.constant(int(31)));
                              body.emit(assign(r1C7C, rshift(r1C55, r1C8A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1C88->else_instructions;

                              ir_variable *const r1C8B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1C8D = equal(r1C7A, body.constant(int(64)));
                              ir_if *f1C8C = new(mem_ctx) ir_if(operand(r1C8D).val);
                              exec_list *const f1C8C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1C8C->then_instructions;

                                 body.emit(assign(r1C8B, r1C55, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1C8C->else_instructions;

                                 ir_expression *const r1C8E = nequal(r1C55, body.constant(0u));
                                 ir_expression *const r1C8F = expr(ir_unop_b2i, r1C8E);
                                 body.emit(assign(r1C8B, expr(ir_unop_i2u, r1C8F), 0x01));


                              body.instructions = f1C8C_parent_instructions;
                              body.emit(f1C8C);

                              /* END IF */

                              body.emit(assign(r1C7B, r1C8B, 0x01));

                              body.emit(assign(r1C7C, body.constant(0u), 0x01));


                           body.instructions = f1C88_parent_instructions;
                           body.emit(f1C88);

                           /* END IF */


                        body.instructions = f1C86_parent_instructions;
                        body.emit(f1C86);

                        /* END IF */

                        body.emit(assign(r1C7D, body.constant(0u), 0x01));


                     body.instructions = f1C82_parent_instructions;
                     body.emit(f1C82);

                     /* END IF */

                     ir_expression *const r1C90 = nequal(r1C79, body.constant(0u));
                     ir_expression *const r1C91 = expr(ir_unop_b2i, r1C90);
                     ir_expression *const r1C92 = expr(ir_unop_i2u, r1C91);
                     body.emit(assign(r1C7B, bit_or(r1C7B, r1C92), 0x01));


                  body.instructions = f1C80_parent_instructions;
                  body.emit(f1C80);

                  /* END IF */

                  body.emit(assign(r1C55, r1C7D, 0x01));

                  body.emit(assign(r1C56, r1C7C, 0x01));

                  body.emit(assign(r1C57, r1C7B, 0x01));


               body.instructions = f1C6F_parent_instructions;
               body.emit(f1C6F);

               /* END IF */

               body.emit(assign(r1C54, sub(r1C54, r1C58), 0x01));

               ir_variable *const r1C93 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1C93, r1C54, 0x01));

               ir_variable *const r1C94 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1C94, r1C55, 0x01));

               ir_variable *const r1C95 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1C95, r1C56, 0x01));

               ir_variable *const r1C96 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1C96, r1C57, 0x01));

               ir_variable *const r1C97 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1C97, body.constant(true), 0x01));

               ir_variable *const r1C98 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1C99 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1C99);
               ir_expression *const r1C9A = expr(ir_unop_u2i, r1C57);
               body.emit(assign(r1C99, less(r1C9A, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1C9C = lequal(body.constant(int(2045)), r1C54);
               ir_if *f1C9B = new(mem_ctx) ir_if(operand(r1C9C).val);
               exec_list *const f1C9B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C9B->then_instructions;

                  ir_variable *const r1C9D = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1C9F = less(body.constant(int(2045)), r1C54);
                  ir_if *f1C9E = new(mem_ctx) ir_if(operand(r1C9F).val);
                  exec_list *const f1C9E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C9E->then_instructions;

                     body.emit(assign(r1C9D, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1C9E->else_instructions;

                     ir_variable *const r1CA0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1CA2 = equal(r1C54, body.constant(int(2045)));
                     ir_if *f1CA1 = new(mem_ctx) ir_if(operand(r1CA2).val);
                     exec_list *const f1CA1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1CA1->then_instructions;

                        ir_expression *const r1CA3 = equal(body.constant(2097151u), r1C55);
                        ir_expression *const r1CA4 = equal(body.constant(4294967295u), r1C56);
                        body.emit(assign(r1CA0, logic_and(r1CA3, r1CA4), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1CA1->else_instructions;

                        body.emit(assign(r1CA0, body.constant(false), 0x01));


                     body.instructions = f1CA1_parent_instructions;
                     body.emit(f1CA1);

                     /* END IF */

                     body.emit(assign(r1C9D, logic_and(r1CA0, r1C99), 0x01));


                  body.instructions = f1C9E_parent_instructions;
                  body.emit(f1C9E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1CA5 = new(mem_ctx) ir_if(operand(r1C9D).val);
                  exec_list *const f1CA5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CA5->then_instructions;

                     ir_variable *const r1CA6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1CA6);
                     ir_expression *const r1CA7 = lshift(r1B63, body.constant(int(31)));
                     body.emit(assign(r1CA6, add(r1CA7, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1CA6, body.constant(0u), 0x01));

                     body.emit(assign(r1C98, r1CA6, 0x03));

                     body.emit(assign(r1C97, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1CA5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1CA9 = less(r1C54, body.constant(int(0)));
                     ir_if *f1CA8 = new(mem_ctx) ir_if(operand(r1CA9).val);
                     exec_list *const f1CA8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1CA8->then_instructions;

                        ir_variable *const r1CAA = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1CAA, r1C57, 0x01));

                        ir_variable *const r1CAB = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1CAB, neg(r1C54), 0x01));

                        ir_variable *const r1CAC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1CAC);
                        ir_variable *const r1CAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1CAD);
                        ir_variable *const r1CAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1CAE);
                        ir_variable *const r1CAF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1CB0 = neg(r1CAB);
                        body.emit(assign(r1CAF, bit_and(r1CB0, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1CB2 = equal(r1CAB, body.constant(int(0)));
                        ir_if *f1CB1 = new(mem_ctx) ir_if(operand(r1CB2).val);
                        exec_list *const f1CB1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1CB1->then_instructions;

                           body.emit(assign(r1CAC, r1C57, 0x01));

                           body.emit(assign(r1CAD, r1C56, 0x01));

                           body.emit(assign(r1CAE, r1C55, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1CB1->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1CB4 = less(r1CAB, body.constant(int(32)));
                           ir_if *f1CB3 = new(mem_ctx) ir_if(operand(r1CB4).val);
                           exec_list *const f1CB3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1CB3->then_instructions;

                              body.emit(assign(r1CAC, lshift(r1C56, r1CAF), 0x01));

                              ir_expression *const r1CB5 = lshift(r1C55, r1CAF);
                              ir_expression *const r1CB6 = rshift(r1C56, r1CAB);
                              body.emit(assign(r1CAD, bit_or(r1CB5, r1CB6), 0x01));

                              body.emit(assign(r1CAE, rshift(r1C55, r1CAB), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1CB3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1CB8 = equal(r1CAB, body.constant(int(32)));
                              ir_if *f1CB7 = new(mem_ctx) ir_if(operand(r1CB8).val);
                              exec_list *const f1CB7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1CB7->then_instructions;

                                 body.emit(assign(r1CAC, r1C56, 0x01));

                                 body.emit(assign(r1CAD, r1C55, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1CB7->else_instructions;

                                 body.emit(assign(r1CAA, bit_or(r1C57, r1C56), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1CBA = less(r1CAB, body.constant(int(64)));
                                 ir_if *f1CB9 = new(mem_ctx) ir_if(operand(r1CBA).val);
                                 exec_list *const f1CB9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1CB9->then_instructions;

                                    body.emit(assign(r1CAC, lshift(r1C55, r1CAF), 0x01));

                                    ir_expression *const r1CBB = bit_and(r1CAB, body.constant(int(31)));
                                    body.emit(assign(r1CAD, rshift(r1C55, r1CBB), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1CB9->else_instructions;

                                    ir_variable *const r1CBC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1CBE = equal(r1CAB, body.constant(int(64)));
                                    ir_if *f1CBD = new(mem_ctx) ir_if(operand(r1CBE).val);
                                    exec_list *const f1CBD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1CBD->then_instructions;

                                       body.emit(assign(r1CBC, r1C55, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1CBD->else_instructions;

                                       ir_expression *const r1CBF = nequal(r1C55, body.constant(0u));
                                       ir_expression *const r1CC0 = expr(ir_unop_b2i, r1CBF);
                                       body.emit(assign(r1CBC, expr(ir_unop_i2u, r1CC0), 0x01));


                                    body.instructions = f1CBD_parent_instructions;
                                    body.emit(f1CBD);

                                    /* END IF */

                                    body.emit(assign(r1CAC, r1CBC, 0x01));

                                    body.emit(assign(r1CAD, body.constant(0u), 0x01));


                                 body.instructions = f1CB9_parent_instructions;
                                 body.emit(f1CB9);

                                 /* END IF */


                              body.instructions = f1CB7_parent_instructions;
                              body.emit(f1CB7);

                              /* END IF */

                              body.emit(assign(r1CAE, body.constant(0u), 0x01));


                           body.instructions = f1CB3_parent_instructions;
                           body.emit(f1CB3);

                           /* END IF */

                           ir_expression *const r1CC1 = nequal(r1CAA, body.constant(0u));
                           ir_expression *const r1CC2 = expr(ir_unop_b2i, r1CC1);
                           ir_expression *const r1CC3 = expr(ir_unop_i2u, r1CC2);
                           body.emit(assign(r1CAC, bit_or(r1CAC, r1CC3), 0x01));


                        body.instructions = f1CB1_parent_instructions;
                        body.emit(f1CB1);

                        /* END IF */

                        body.emit(assign(r1C94, r1CAE, 0x01));

                        body.emit(assign(r1C95, r1CAD, 0x01));

                        body.emit(assign(r1C96, r1CAC, 0x01));

                        body.emit(assign(r1C93, body.constant(int(0)), 0x01));

                        body.emit(assign(r1C99, less(r1CAC, body.constant(0u)), 0x01));


                     body.instructions = f1CA8_parent_instructions;
                     body.emit(f1CA8);

                     /* END IF */


                  body.instructions = f1CA5_parent_instructions;
                  body.emit(f1CA5);

                  /* END IF */


               body.instructions = f1C9B_parent_instructions;
               body.emit(f1C9B);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1CC4 = new(mem_ctx) ir_if(operand(r1C97).val);
               exec_list *const f1CC4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CC4->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1CC5 = new(mem_ctx) ir_if(operand(r1C99).val);
                  exec_list *const f1CC5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CC5->then_instructions;

                     ir_variable *const r1CC6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1CC6, add(r1C95, body.constant(1u)), 0x01));

                     ir_expression *const r1CC7 = less(r1CC6, r1C95);
                     ir_expression *const r1CC8 = expr(ir_unop_b2i, r1CC7);
                     ir_expression *const r1CC9 = expr(ir_unop_i2u, r1CC8);
                     body.emit(assign(r1C94, add(r1C94, r1CC9), 0x01));

                     ir_expression *const r1CCA = equal(r1C96, body.constant(0u));
                     ir_expression *const r1CCB = expr(ir_unop_b2i, r1CCA);
                     ir_expression *const r1CCC = expr(ir_unop_i2u, r1CCB);
                     ir_expression *const r1CCD = add(r1C96, r1CCC);
                     ir_expression *const r1CCE = bit_and(r1CCD, body.constant(1u));
                     ir_expression *const r1CCF = expr(ir_unop_bit_not, r1CCE);
                     body.emit(assign(r1C95, bit_and(r1CC6, r1CCF), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1CC5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1CD1 = bit_or(r1C94, r1C95);
                     ir_expression *const r1CD2 = equal(r1CD1, body.constant(0u));
                     ir_if *f1CD0 = new(mem_ctx) ir_if(operand(r1CD2).val);
                     exec_list *const f1CD0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1CD0->then_instructions;

                        body.emit(assign(r1C93, body.constant(int(0)), 0x01));


                     body.instructions = f1CD0_parent_instructions;
                     body.emit(f1CD0);

                     /* END IF */


                  body.instructions = f1CC5_parent_instructions;
                  body.emit(f1CC5);

                  /* END IF */

                  ir_variable *const r1CD3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1CD3);
                  ir_expression *const r1CD4 = lshift(r1B63, body.constant(int(31)));
                  ir_expression *const r1CD5 = expr(ir_unop_i2u, r1C93);
                  ir_expression *const r1CD6 = lshift(r1CD5, body.constant(int(20)));
                  ir_expression *const r1CD7 = add(r1CD4, r1CD6);
                  body.emit(assign(r1CD3, add(r1CD7, r1C94), 0x02));

                  body.emit(assign(r1CD3, r1C95, 0x01));

                  body.emit(assign(r1C98, r1CD3, 0x03));

                  body.emit(assign(r1C97, body.constant(false), 0x01));


               body.instructions = f1CC4_parent_instructions;
               body.emit(f1CC4);

               /* END IF */

               body.emit(assign(r1B64, r1C98, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C29->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1CD9 = equal(r1B6E, body.constant(int(2047)));
               ir_if *f1CD8 = new(mem_ctx) ir_if(operand(r1CD9).val);
               exec_list *const f1CD8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CD8->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1CDB = bit_or(r1B6A, r1B6B);
                  ir_expression *const r1CDC = bit_or(r1B68, r1B69);
                  ir_expression *const r1CDD = bit_or(r1CDB, r1CDC);
                  ir_expression *const r1CDE = nequal(r1CDD, body.constant(0u));
                  ir_if *f1CDA = new(mem_ctx) ir_if(operand(r1CDE).val);
                  exec_list *const f1CDA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CDA->then_instructions;

                     ir_variable *const r1CDF = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1CDF, swizzle_x(r19D2), 0x01));

                     ir_variable *const r1CE0 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1CE0, body.constant(0u), 0x01));

                     ir_variable *const r1CE1 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r1CDF, bit_or(swizzle_y(r19D2), body.constant(524288u)), 0x02));

                     body.emit(assign(r1CE0, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1CE3 = lshift(swizzle_y(r19D2), body.constant(int(1)));
                     ir_expression *const r1CE4 = lequal(body.constant(4292870144u), r1CE3);
                     ir_expression *const r1CE5 = nequal(swizzle_x(r19D2), body.constant(0u));
                     ir_expression *const r1CE6 = bit_and(swizzle_y(r19D2), body.constant(1048575u));
                     ir_expression *const r1CE7 = nequal(r1CE6, body.constant(0u));
                     ir_expression *const r1CE8 = logic_or(r1CE5, r1CE7);
                     ir_expression *const r1CE9 = logic_and(r1CE4, r1CE8);
                     ir_if *f1CE2 = new(mem_ctx) ir_if(operand(r1CE9).val);
                     exec_list *const f1CE2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1CE2->then_instructions;

                        body.emit(assign(r1CE1, r1CDF, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1CE2->else_instructions;

                        body.emit(assign(r1CE1, r1CE0, 0x03));


                     body.instructions = f1CE2_parent_instructions;
                     body.emit(f1CE2);

                     /* END IF */

                     body.emit(assign(r1B64, r1CE1, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1CDA->else_instructions;

                     ir_constant_data r1CEA_data;
                     memset(&r1CEA_data, 0, sizeof(ir_constant_data));
                     r1CEA_data.u[0] = 4294967295;
                     r1CEA_data.u[1] = 4294967295;
                     ir_constant *const r1CEA = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1CEA_data);
                     body.emit(assign(r1B64, r1CEA, 0x03));


                  body.instructions = f1CDA_parent_instructions;
                  body.emit(f1CDA);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CD8->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1CEC = equal(r1B6E, body.constant(int(0)));
                  ir_if *f1CEB = new(mem_ctx) ir_if(operand(r1CEC).val);
                  exec_list *const f1CEB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CEB->then_instructions;

                     body.emit(assign(r1B67, body.constant(int(1)), 0x01));

                     body.emit(assign(r1B66, body.constant(int(1)), 0x01));


                  body.instructions = f1CEB_parent_instructions;
                  body.emit(f1CEB);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1CEE = less(r1B68, r1B6A);
                  ir_if *f1CED = new(mem_ctx) ir_if(operand(r1CEE).val);
                  exec_list *const f1CED_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CED->then_instructions;

                     ir_variable *const r1CEF = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r1CF0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1CF0, sub(r1B6B, r1B69), 0x01));

                     ir_expression *const r1CF1 = sub(r1B6A, r1B68);
                     ir_expression *const r1CF2 = less(r1B6B, r1B69);
                     ir_expression *const r1CF3 = expr(ir_unop_b2i, r1CF2);
                     ir_expression *const r1CF4 = expr(ir_unop_i2u, r1CF3);
                     body.emit(assign(r1CEF, sub(r1CF1, r1CF4), 0x01));

                     body.emit(assign(r1B6C, add(r1B67, body.constant(int(-1))), 0x01));

                     ir_variable *const r1CF5 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1CF5, add(r1B6C, body.constant(int(-10))), 0x01));

                     ir_variable *const r1CF6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1CF6, r1CEF, 0x01));

                     ir_variable *const r1CF7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1CF7, r1CF0, 0x01));

                     ir_variable *const r1CF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r1CF8);
                     ir_variable *const r1CF9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1CF9);
                     /* IF CONDITION */
                     ir_expression *const r1CFB = equal(r1CEF, body.constant(0u));
                     ir_if *f1CFA = new(mem_ctx) ir_if(operand(r1CFB).val);
                     exec_list *const f1CFA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1CFA->then_instructions;

                        body.emit(assign(r1CF6, r1CF0, 0x01));

                        body.emit(assign(r1CF7, body.constant(0u), 0x01));

                        body.emit(assign(r1CF5, add(r1CF5, body.constant(int(-32))), 0x01));


                     body.instructions = f1CFA_parent_instructions;
                     body.emit(f1CFA);

                     /* END IF */

                     ir_variable *const r1CFC = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1CFC, r1CF6, 0x01));

                     ir_variable *const r1CFD = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1CFE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1CFE);
                     /* IF CONDITION */
                     ir_expression *const r1D00 = equal(r1CF6, body.constant(0u));
                     ir_if *f1CFF = new(mem_ctx) ir_if(operand(r1D00).val);
                     exec_list *const f1CFF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1CFF->then_instructions;

                        body.emit(assign(r1CFD, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1CFF->else_instructions;

                        body.emit(assign(r1CFE, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1D02 = bit_and(r1CF6, body.constant(4294901760u));
                        ir_expression *const r1D03 = equal(r1D02, body.constant(0u));
                        ir_if *f1D01 = new(mem_ctx) ir_if(operand(r1D03).val);
                        exec_list *const f1D01_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D01->then_instructions;

                           body.emit(assign(r1CFE, body.constant(int(16)), 0x01));

                           body.emit(assign(r1CFC, lshift(r1CF6, body.constant(int(16))), 0x01));


                        body.instructions = f1D01_parent_instructions;
                        body.emit(f1D01);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1D05 = bit_and(r1CFC, body.constant(4278190080u));
                        ir_expression *const r1D06 = equal(r1D05, body.constant(0u));
                        ir_if *f1D04 = new(mem_ctx) ir_if(operand(r1D06).val);
                        exec_list *const f1D04_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D04->then_instructions;

                           body.emit(assign(r1CFE, add(r1CFE, body.constant(int(8))), 0x01));

                           body.emit(assign(r1CFC, lshift(r1CFC, body.constant(int(8))), 0x01));


                        body.instructions = f1D04_parent_instructions;
                        body.emit(f1D04);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1D08 = bit_and(r1CFC, body.constant(4026531840u));
                        ir_expression *const r1D09 = equal(r1D08, body.constant(0u));
                        ir_if *f1D07 = new(mem_ctx) ir_if(operand(r1D09).val);
                        exec_list *const f1D07_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D07->then_instructions;

                           body.emit(assign(r1CFE, add(r1CFE, body.constant(int(4))), 0x01));

                           body.emit(assign(r1CFC, lshift(r1CFC, body.constant(int(4))), 0x01));


                        body.instructions = f1D07_parent_instructions;
                        body.emit(f1D07);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1D0B = bit_and(r1CFC, body.constant(3221225472u));
                        ir_expression *const r1D0C = equal(r1D0B, body.constant(0u));
                        ir_if *f1D0A = new(mem_ctx) ir_if(operand(r1D0C).val);
                        exec_list *const f1D0A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D0A->then_instructions;

                           body.emit(assign(r1CFE, add(r1CFE, body.constant(int(2))), 0x01));

                           body.emit(assign(r1CFC, lshift(r1CFC, body.constant(int(2))), 0x01));


                        body.instructions = f1D0A_parent_instructions;
                        body.emit(f1D0A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1D0E = bit_and(r1CFC, body.constant(2147483648u));
                        ir_expression *const r1D0F = equal(r1D0E, body.constant(0u));
                        ir_if *f1D0D = new(mem_ctx) ir_if(operand(r1D0F).val);
                        exec_list *const f1D0D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D0D->then_instructions;

                           body.emit(assign(r1CFE, add(r1CFE, body.constant(int(1))), 0x01));


                        body.instructions = f1D0D_parent_instructions;
                        body.emit(f1D0D);

                        /* END IF */

                        body.emit(assign(r1CFD, r1CFE, 0x01));


                     body.instructions = f1CFF_parent_instructions;
                     body.emit(f1CFF);

                     /* END IF */

                     body.emit(assign(r1CF9, add(r1CFD, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1D11 = lequal(body.constant(int(0)), r1CF9);
                     ir_if *f1D10 = new(mem_ctx) ir_if(operand(r1D11).val);
                     exec_list *const f1D10_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D10->then_instructions;

                        body.emit(assign(r1CF8, body.constant(0u), 0x01));

                        ir_variable *const r1D12 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1D12, lshift(r1CF7, r1CF9), 0x01));

                        ir_variable *const r1D13 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1D15 = equal(r1CF9, body.constant(int(0)));
                        ir_if *f1D14 = new(mem_ctx) ir_if(operand(r1D15).val);
                        exec_list *const f1D14_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D14->then_instructions;

                           body.emit(assign(r1D13, r1CF6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D14->else_instructions;

                           ir_expression *const r1D16 = lshift(r1CF6, r1CF9);
                           ir_expression *const r1D17 = neg(r1CF9);
                           ir_expression *const r1D18 = bit_and(r1D17, body.constant(int(31)));
                           ir_expression *const r1D19 = rshift(r1CF7, r1D18);
                           body.emit(assign(r1D13, bit_or(r1D16, r1D19), 0x01));


                        body.instructions = f1D14_parent_instructions;
                        body.emit(f1D14);

                        /* END IF */

                        body.emit(assign(r1CF6, r1D13, 0x01));

                        body.emit(assign(r1CF7, r1D12, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D10->else_instructions;

                        ir_variable *const r1D1A = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1D1A, body.constant(0u), 0x01));

                        ir_variable *const r1D1B = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1D1B, neg(r1CF9), 0x01));

                        ir_variable *const r1D1C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1D1C);
                        ir_variable *const r1D1D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1D1D);
                        ir_variable *const r1D1E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1D1E);
                        ir_variable *const r1D1F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1D20 = neg(r1D1B);
                        body.emit(assign(r1D1F, bit_and(r1D20, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1D22 = equal(r1D1B, body.constant(int(0)));
                        ir_if *f1D21 = new(mem_ctx) ir_if(operand(r1D22).val);
                        exec_list *const f1D21_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D21->then_instructions;

                           body.emit(assign(r1D1C, r1D1A, 0x01));

                           body.emit(assign(r1D1D, r1CF7, 0x01));

                           body.emit(assign(r1D1E, r1CF6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D21->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1D24 = less(r1D1B, body.constant(int(32)));
                           ir_if *f1D23 = new(mem_ctx) ir_if(operand(r1D24).val);
                           exec_list *const f1D23_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D23->then_instructions;

                              body.emit(assign(r1D1C, lshift(r1CF7, r1D1F), 0x01));

                              ir_expression *const r1D25 = lshift(r1CF6, r1D1F);
                              ir_expression *const r1D26 = rshift(r1CF7, r1D1B);
                              body.emit(assign(r1D1D, bit_or(r1D25, r1D26), 0x01));

                              body.emit(assign(r1D1E, rshift(r1CF6, r1D1B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1D23->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1D28 = equal(r1D1B, body.constant(int(32)));
                              ir_if *f1D27 = new(mem_ctx) ir_if(operand(r1D28).val);
                              exec_list *const f1D27_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1D27->then_instructions;

                                 body.emit(assign(r1D1C, r1CF7, 0x01));

                                 body.emit(assign(r1D1D, r1CF6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1D27->else_instructions;

                                 body.emit(assign(r1D1A, bit_or(body.constant(0u), r1CF7), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1D2A = less(r1D1B, body.constant(int(64)));
                                 ir_if *f1D29 = new(mem_ctx) ir_if(operand(r1D2A).val);
                                 exec_list *const f1D29_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1D29->then_instructions;

                                    body.emit(assign(r1D1C, lshift(r1CF6, r1D1F), 0x01));

                                    ir_expression *const r1D2B = bit_and(r1D1B, body.constant(int(31)));
                                    body.emit(assign(r1D1D, rshift(r1CF6, r1D2B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1D29->else_instructions;

                                    ir_variable *const r1D2C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1D2E = equal(r1D1B, body.constant(int(64)));
                                    ir_if *f1D2D = new(mem_ctx) ir_if(operand(r1D2E).val);
                                    exec_list *const f1D2D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1D2D->then_instructions;

                                       body.emit(assign(r1D2C, r1CF6, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1D2D->else_instructions;

                                       ir_expression *const r1D2F = nequal(r1CF6, body.constant(0u));
                                       ir_expression *const r1D30 = expr(ir_unop_b2i, r1D2F);
                                       body.emit(assign(r1D2C, expr(ir_unop_i2u, r1D30), 0x01));


                                    body.instructions = f1D2D_parent_instructions;
                                    body.emit(f1D2D);

                                    /* END IF */

                                    body.emit(assign(r1D1C, r1D2C, 0x01));

                                    body.emit(assign(r1D1D, body.constant(0u), 0x01));


                                 body.instructions = f1D29_parent_instructions;
                                 body.emit(f1D29);

                                 /* END IF */


                              body.instructions = f1D27_parent_instructions;
                              body.emit(f1D27);

                              /* END IF */

                              body.emit(assign(r1D1E, body.constant(0u), 0x01));


                           body.instructions = f1D23_parent_instructions;
                           body.emit(f1D23);

                           /* END IF */

                           ir_expression *const r1D31 = nequal(r1D1A, body.constant(0u));
                           ir_expression *const r1D32 = expr(ir_unop_b2i, r1D31);
                           ir_expression *const r1D33 = expr(ir_unop_i2u, r1D32);
                           body.emit(assign(r1D1C, bit_or(r1D1C, r1D33), 0x01));


                        body.instructions = f1D21_parent_instructions;
                        body.emit(f1D21);

                        /* END IF */

                        body.emit(assign(r1CF6, r1D1E, 0x01));

                        body.emit(assign(r1CF7, r1D1D, 0x01));

                        body.emit(assign(r1CF8, r1D1C, 0x01));


                     body.instructions = f1D10_parent_instructions;
                     body.emit(f1D10);

                     /* END IF */

                     body.emit(assign(r1CF5, sub(r1CF5, r1CF9), 0x01));

                     ir_variable *const r1D34 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1D34, r1CF5, 0x01));

                     ir_variable *const r1D35 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1D35, r1CF6, 0x01));

                     ir_variable *const r1D36 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1D36, r1CF7, 0x01));

                     ir_variable *const r1D37 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1D37, r1CF8, 0x01));

                     ir_variable *const r1D38 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1D38, body.constant(true), 0x01));

                     ir_variable *const r1D39 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1D3A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1D3A);
                     ir_expression *const r1D3B = expr(ir_unop_u2i, r1CF8);
                     body.emit(assign(r1D3A, less(r1D3B, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1D3D = lequal(body.constant(int(2045)), r1CF5);
                     ir_if *f1D3C = new(mem_ctx) ir_if(operand(r1D3D).val);
                     exec_list *const f1D3C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D3C->then_instructions;

                        ir_variable *const r1D3E = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1D40 = less(body.constant(int(2045)), r1CF5);
                        ir_if *f1D3F = new(mem_ctx) ir_if(operand(r1D40).val);
                        exec_list *const f1D3F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D3F->then_instructions;

                           body.emit(assign(r1D3E, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D3F->else_instructions;

                           ir_variable *const r1D41 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1D43 = equal(r1CF5, body.constant(int(2045)));
                           ir_if *f1D42 = new(mem_ctx) ir_if(operand(r1D43).val);
                           exec_list *const f1D42_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D42->then_instructions;

                              ir_expression *const r1D44 = equal(body.constant(2097151u), r1CF6);
                              ir_expression *const r1D45 = equal(body.constant(4294967295u), r1CF7);
                              body.emit(assign(r1D41, logic_and(r1D44, r1D45), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1D42->else_instructions;

                              body.emit(assign(r1D41, body.constant(false), 0x01));


                           body.instructions = f1D42_parent_instructions;
                           body.emit(f1D42);

                           /* END IF */

                           body.emit(assign(r1D3E, logic_and(r1D41, r1D3A), 0x01));


                        body.instructions = f1D3F_parent_instructions;
                        body.emit(f1D3F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1D46 = new(mem_ctx) ir_if(operand(r1D3E).val);
                        exec_list *const f1D46_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D46->then_instructions;

                           ir_variable *const r1D47 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1D47);
                           ir_expression *const r1D48 = lshift(r1B63, body.constant(int(31)));
                           body.emit(assign(r1D47, add(r1D48, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1D47, body.constant(0u), 0x01));

                           body.emit(assign(r1D39, r1D47, 0x03));

                           body.emit(assign(r1D38, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D46->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1D4A = less(r1CF5, body.constant(int(0)));
                           ir_if *f1D49 = new(mem_ctx) ir_if(operand(r1D4A).val);
                           exec_list *const f1D49_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D49->then_instructions;

                              ir_variable *const r1D4B = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1D4B, r1CF8, 0x01));

                              ir_variable *const r1D4C = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1D4C, neg(r1CF5), 0x01));

                              ir_variable *const r1D4D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1D4D);
                              ir_variable *const r1D4E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1D4E);
                              ir_variable *const r1D4F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1D4F);
                              ir_variable *const r1D50 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1D51 = neg(r1D4C);
                              body.emit(assign(r1D50, bit_and(r1D51, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1D53 = equal(r1D4C, body.constant(int(0)));
                              ir_if *f1D52 = new(mem_ctx) ir_if(operand(r1D53).val);
                              exec_list *const f1D52_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1D52->then_instructions;

                                 body.emit(assign(r1D4D, r1CF8, 0x01));

                                 body.emit(assign(r1D4E, r1CF7, 0x01));

                                 body.emit(assign(r1D4F, r1CF6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1D52->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1D55 = less(r1D4C, body.constant(int(32)));
                                 ir_if *f1D54 = new(mem_ctx) ir_if(operand(r1D55).val);
                                 exec_list *const f1D54_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1D54->then_instructions;

                                    body.emit(assign(r1D4D, lshift(r1CF7, r1D50), 0x01));

                                    ir_expression *const r1D56 = lshift(r1CF6, r1D50);
                                    ir_expression *const r1D57 = rshift(r1CF7, r1D4C);
                                    body.emit(assign(r1D4E, bit_or(r1D56, r1D57), 0x01));

                                    body.emit(assign(r1D4F, rshift(r1CF6, r1D4C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1D54->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1D59 = equal(r1D4C, body.constant(int(32)));
                                    ir_if *f1D58 = new(mem_ctx) ir_if(operand(r1D59).val);
                                    exec_list *const f1D58_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1D58->then_instructions;

                                       body.emit(assign(r1D4D, r1CF7, 0x01));

                                       body.emit(assign(r1D4E, r1CF6, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1D58->else_instructions;

                                       body.emit(assign(r1D4B, bit_or(r1CF8, r1CF7), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1D5B = less(r1D4C, body.constant(int(64)));
                                       ir_if *f1D5A = new(mem_ctx) ir_if(operand(r1D5B).val);
                                       exec_list *const f1D5A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1D5A->then_instructions;

                                          body.emit(assign(r1D4D, lshift(r1CF6, r1D50), 0x01));

                                          ir_expression *const r1D5C = bit_and(r1D4C, body.constant(int(31)));
                                          body.emit(assign(r1D4E, rshift(r1CF6, r1D5C), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1D5A->else_instructions;

                                          ir_variable *const r1D5D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1D5F = equal(r1D4C, body.constant(int(64)));
                                          ir_if *f1D5E = new(mem_ctx) ir_if(operand(r1D5F).val);
                                          exec_list *const f1D5E_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1D5E->then_instructions;

                                             body.emit(assign(r1D5D, r1CF6, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1D5E->else_instructions;

                                             ir_expression *const r1D60 = nequal(r1CF6, body.constant(0u));
                                             ir_expression *const r1D61 = expr(ir_unop_b2i, r1D60);
                                             body.emit(assign(r1D5D, expr(ir_unop_i2u, r1D61), 0x01));


                                          body.instructions = f1D5E_parent_instructions;
                                          body.emit(f1D5E);

                                          /* END IF */

                                          body.emit(assign(r1D4D, r1D5D, 0x01));

                                          body.emit(assign(r1D4E, body.constant(0u), 0x01));


                                       body.instructions = f1D5A_parent_instructions;
                                       body.emit(f1D5A);

                                       /* END IF */


                                    body.instructions = f1D58_parent_instructions;
                                    body.emit(f1D58);

                                    /* END IF */

                                    body.emit(assign(r1D4F, body.constant(0u), 0x01));


                                 body.instructions = f1D54_parent_instructions;
                                 body.emit(f1D54);

                                 /* END IF */

                                 ir_expression *const r1D62 = nequal(r1D4B, body.constant(0u));
                                 ir_expression *const r1D63 = expr(ir_unop_b2i, r1D62);
                                 ir_expression *const r1D64 = expr(ir_unop_i2u, r1D63);
                                 body.emit(assign(r1D4D, bit_or(r1D4D, r1D64), 0x01));


                              body.instructions = f1D52_parent_instructions;
                              body.emit(f1D52);

                              /* END IF */

                              body.emit(assign(r1D35, r1D4F, 0x01));

                              body.emit(assign(r1D36, r1D4E, 0x01));

                              body.emit(assign(r1D37, r1D4D, 0x01));

                              body.emit(assign(r1D34, body.constant(int(0)), 0x01));

                              body.emit(assign(r1D3A, less(r1D4D, body.constant(0u)), 0x01));


                           body.instructions = f1D49_parent_instructions;
                           body.emit(f1D49);

                           /* END IF */


                        body.instructions = f1D46_parent_instructions;
                        body.emit(f1D46);

                        /* END IF */


                     body.instructions = f1D3C_parent_instructions;
                     body.emit(f1D3C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f1D65 = new(mem_ctx) ir_if(operand(r1D38).val);
                     exec_list *const f1D65_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D65->then_instructions;

                        /* IF CONDITION */
                        ir_if *f1D66 = new(mem_ctx) ir_if(operand(r1D3A).val);
                        exec_list *const f1D66_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D66->then_instructions;

                           ir_variable *const r1D67 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r1D67, add(r1D36, body.constant(1u)), 0x01));

                           ir_expression *const r1D68 = less(r1D67, r1D36);
                           ir_expression *const r1D69 = expr(ir_unop_b2i, r1D68);
                           ir_expression *const r1D6A = expr(ir_unop_i2u, r1D69);
                           body.emit(assign(r1D35, add(r1D35, r1D6A), 0x01));

                           ir_expression *const r1D6B = equal(r1D37, body.constant(0u));
                           ir_expression *const r1D6C = expr(ir_unop_b2i, r1D6B);
                           ir_expression *const r1D6D = expr(ir_unop_i2u, r1D6C);
                           ir_expression *const r1D6E = add(r1D37, r1D6D);
                           ir_expression *const r1D6F = bit_and(r1D6E, body.constant(1u));
                           ir_expression *const r1D70 = expr(ir_unop_bit_not, r1D6F);
                           body.emit(assign(r1D36, bit_and(r1D67, r1D70), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D66->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1D72 = bit_or(r1D35, r1D36);
                           ir_expression *const r1D73 = equal(r1D72, body.constant(0u));
                           ir_if *f1D71 = new(mem_ctx) ir_if(operand(r1D73).val);
                           exec_list *const f1D71_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D71->then_instructions;

                              body.emit(assign(r1D34, body.constant(int(0)), 0x01));


                           body.instructions = f1D71_parent_instructions;
                           body.emit(f1D71);

                           /* END IF */


                        body.instructions = f1D66_parent_instructions;
                        body.emit(f1D66);

                        /* END IF */

                        ir_variable *const r1D74 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r1D74);
                        ir_expression *const r1D75 = lshift(r1B63, body.constant(int(31)));
                        ir_expression *const r1D76 = expr(ir_unop_i2u, r1D34);
                        ir_expression *const r1D77 = lshift(r1D76, body.constant(int(20)));
                        ir_expression *const r1D78 = add(r1D75, r1D77);
                        body.emit(assign(r1D74, add(r1D78, r1D35), 0x02));

                        body.emit(assign(r1D74, r1D36, 0x01));

                        body.emit(assign(r1D39, r1D74, 0x03));

                        body.emit(assign(r1D38, body.constant(false), 0x01));


                     body.instructions = f1D65_parent_instructions;
                     body.emit(f1D65);

                     /* END IF */

                     body.emit(assign(r1B64, r1D39, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1CED->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D7A = less(r1B6A, r1B68);
                     ir_if *f1D79 = new(mem_ctx) ir_if(operand(r1D7A).val);
                     exec_list *const f1D79_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D79->then_instructions;

                        ir_variable *const r1D7B = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r1D7C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1D7C, sub(r1B69, r1B6B), 0x01));

                        ir_expression *const r1D7D = sub(r1B68, r1B6A);
                        ir_expression *const r1D7E = less(r1B69, r1B6B);
                        ir_expression *const r1D7F = expr(ir_unop_b2i, r1D7E);
                        ir_expression *const r1D80 = expr(ir_unop_i2u, r1D7F);
                        body.emit(assign(r1D7B, sub(r1D7D, r1D80), 0x01));

                        body.emit(assign(r1B63, bit_xor(r1B63, body.constant(1u)), 0x01));

                        body.emit(assign(r1B6C, add(r1B66, body.constant(int(-1))), 0x01));

                        ir_variable *const r1D81 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r1D81, add(r1B6C, body.constant(int(-10))), 0x01));

                        ir_variable *const r1D82 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r1D82, r1D7B, 0x01));

                        ir_variable *const r1D83 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1D83, r1D7C, 0x01));

                        ir_variable *const r1D84 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r1D84);
                        ir_variable *const r1D85 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r1D85);
                        /* IF CONDITION */
                        ir_expression *const r1D87 = equal(r1D7B, body.constant(0u));
                        ir_if *f1D86 = new(mem_ctx) ir_if(operand(r1D87).val);
                        exec_list *const f1D86_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D86->then_instructions;

                           body.emit(assign(r1D82, r1D7C, 0x01));

                           body.emit(assign(r1D83, body.constant(0u), 0x01));

                           body.emit(assign(r1D81, add(r1D81, body.constant(int(-32))), 0x01));


                        body.instructions = f1D86_parent_instructions;
                        body.emit(f1D86);

                        /* END IF */

                        ir_variable *const r1D88 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r1D88, r1D82, 0x01));

                        ir_variable *const r1D89 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r1D8A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r1D8A);
                        /* IF CONDITION */
                        ir_expression *const r1D8C = equal(r1D82, body.constant(0u));
                        ir_if *f1D8B = new(mem_ctx) ir_if(operand(r1D8C).val);
                        exec_list *const f1D8B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D8B->then_instructions;

                           body.emit(assign(r1D89, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D8B->else_instructions;

                           body.emit(assign(r1D8A, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1D8E = bit_and(r1D82, body.constant(4294901760u));
                           ir_expression *const r1D8F = equal(r1D8E, body.constant(0u));
                           ir_if *f1D8D = new(mem_ctx) ir_if(operand(r1D8F).val);
                           exec_list *const f1D8D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D8D->then_instructions;

                              body.emit(assign(r1D8A, body.constant(int(16)), 0x01));

                              body.emit(assign(r1D88, lshift(r1D82, body.constant(int(16))), 0x01));


                           body.instructions = f1D8D_parent_instructions;
                           body.emit(f1D8D);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1D91 = bit_and(r1D88, body.constant(4278190080u));
                           ir_expression *const r1D92 = equal(r1D91, body.constant(0u));
                           ir_if *f1D90 = new(mem_ctx) ir_if(operand(r1D92).val);
                           exec_list *const f1D90_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D90->then_instructions;

                              body.emit(assign(r1D8A, add(r1D8A, body.constant(int(8))), 0x01));

                              body.emit(assign(r1D88, lshift(r1D88, body.constant(int(8))), 0x01));


                           body.instructions = f1D90_parent_instructions;
                           body.emit(f1D90);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1D94 = bit_and(r1D88, body.constant(4026531840u));
                           ir_expression *const r1D95 = equal(r1D94, body.constant(0u));
                           ir_if *f1D93 = new(mem_ctx) ir_if(operand(r1D95).val);
                           exec_list *const f1D93_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D93->then_instructions;

                              body.emit(assign(r1D8A, add(r1D8A, body.constant(int(4))), 0x01));

                              body.emit(assign(r1D88, lshift(r1D88, body.constant(int(4))), 0x01));


                           body.instructions = f1D93_parent_instructions;
                           body.emit(f1D93);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1D97 = bit_and(r1D88, body.constant(3221225472u));
                           ir_expression *const r1D98 = equal(r1D97, body.constant(0u));
                           ir_if *f1D96 = new(mem_ctx) ir_if(operand(r1D98).val);
                           exec_list *const f1D96_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D96->then_instructions;

                              body.emit(assign(r1D8A, add(r1D8A, body.constant(int(2))), 0x01));

                              body.emit(assign(r1D88, lshift(r1D88, body.constant(int(2))), 0x01));


                           body.instructions = f1D96_parent_instructions;
                           body.emit(f1D96);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1D9A = bit_and(r1D88, body.constant(2147483648u));
                           ir_expression *const r1D9B = equal(r1D9A, body.constant(0u));
                           ir_if *f1D99 = new(mem_ctx) ir_if(operand(r1D9B).val);
                           exec_list *const f1D99_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D99->then_instructions;

                              body.emit(assign(r1D8A, add(r1D8A, body.constant(int(1))), 0x01));


                           body.instructions = f1D99_parent_instructions;
                           body.emit(f1D99);

                           /* END IF */

                           body.emit(assign(r1D89, r1D8A, 0x01));


                        body.instructions = f1D8B_parent_instructions;
                        body.emit(f1D8B);

                        /* END IF */

                        body.emit(assign(r1D85, add(r1D89, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1D9D = lequal(body.constant(int(0)), r1D85);
                        ir_if *f1D9C = new(mem_ctx) ir_if(operand(r1D9D).val);
                        exec_list *const f1D9C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D9C->then_instructions;

                           body.emit(assign(r1D84, body.constant(0u), 0x01));

                           ir_variable *const r1D9E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1D9E, lshift(r1D83, r1D85), 0x01));

                           ir_variable *const r1D9F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1DA1 = equal(r1D85, body.constant(int(0)));
                           ir_if *f1DA0 = new(mem_ctx) ir_if(operand(r1DA1).val);
                           exec_list *const f1DA0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1DA0->then_instructions;

                              body.emit(assign(r1D9F, r1D82, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1DA0->else_instructions;

                              ir_expression *const r1DA2 = lshift(r1D82, r1D85);
                              ir_expression *const r1DA3 = neg(r1D85);
                              ir_expression *const r1DA4 = bit_and(r1DA3, body.constant(int(31)));
                              ir_expression *const r1DA5 = rshift(r1D83, r1DA4);
                              body.emit(assign(r1D9F, bit_or(r1DA2, r1DA5), 0x01));


                           body.instructions = f1DA0_parent_instructions;
                           body.emit(f1DA0);

                           /* END IF */

                           body.emit(assign(r1D82, r1D9F, 0x01));

                           body.emit(assign(r1D83, r1D9E, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D9C->else_instructions;

                           ir_variable *const r1DA6 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r1DA6, body.constant(0u), 0x01));

                           ir_variable *const r1DA7 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r1DA7, neg(r1D85), 0x01));

                           ir_variable *const r1DA8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r1DA8);
                           ir_variable *const r1DA9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r1DA9);
                           ir_variable *const r1DAA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r1DAA);
                           ir_variable *const r1DAB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r1DAC = neg(r1DA7);
                           body.emit(assign(r1DAB, bit_and(r1DAC, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1DAE = equal(r1DA7, body.constant(int(0)));
                           ir_if *f1DAD = new(mem_ctx) ir_if(operand(r1DAE).val);
                           exec_list *const f1DAD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1DAD->then_instructions;

                              body.emit(assign(r1DA8, r1DA6, 0x01));

                              body.emit(assign(r1DA9, r1D83, 0x01));

                              body.emit(assign(r1DAA, r1D82, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1DAD->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1DB0 = less(r1DA7, body.constant(int(32)));
                              ir_if *f1DAF = new(mem_ctx) ir_if(operand(r1DB0).val);
                              exec_list *const f1DAF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1DAF->then_instructions;

                                 body.emit(assign(r1DA8, lshift(r1D83, r1DAB), 0x01));

                                 ir_expression *const r1DB1 = lshift(r1D82, r1DAB);
                                 ir_expression *const r1DB2 = rshift(r1D83, r1DA7);
                                 body.emit(assign(r1DA9, bit_or(r1DB1, r1DB2), 0x01));

                                 body.emit(assign(r1DAA, rshift(r1D82, r1DA7), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1DAF->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1DB4 = equal(r1DA7, body.constant(int(32)));
                                 ir_if *f1DB3 = new(mem_ctx) ir_if(operand(r1DB4).val);
                                 exec_list *const f1DB3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1DB3->then_instructions;

                                    body.emit(assign(r1DA8, r1D83, 0x01));

                                    body.emit(assign(r1DA9, r1D82, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1DB3->else_instructions;

                                    body.emit(assign(r1DA6, bit_or(body.constant(0u), r1D83), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1DB6 = less(r1DA7, body.constant(int(64)));
                                    ir_if *f1DB5 = new(mem_ctx) ir_if(operand(r1DB6).val);
                                    exec_list *const f1DB5_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1DB5->then_instructions;

                                       body.emit(assign(r1DA8, lshift(r1D82, r1DAB), 0x01));

                                       ir_expression *const r1DB7 = bit_and(r1DA7, body.constant(int(31)));
                                       body.emit(assign(r1DA9, rshift(r1D82, r1DB7), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1DB5->else_instructions;

                                       ir_variable *const r1DB8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r1DBA = equal(r1DA7, body.constant(int(64)));
                                       ir_if *f1DB9 = new(mem_ctx) ir_if(operand(r1DBA).val);
                                       exec_list *const f1DB9_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1DB9->then_instructions;

                                          body.emit(assign(r1DB8, r1D82, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1DB9->else_instructions;

                                          ir_expression *const r1DBB = nequal(r1D82, body.constant(0u));
                                          ir_expression *const r1DBC = expr(ir_unop_b2i, r1DBB);
                                          body.emit(assign(r1DB8, expr(ir_unop_i2u, r1DBC), 0x01));


                                       body.instructions = f1DB9_parent_instructions;
                                       body.emit(f1DB9);

                                       /* END IF */

                                       body.emit(assign(r1DA8, r1DB8, 0x01));

                                       body.emit(assign(r1DA9, body.constant(0u), 0x01));


                                    body.instructions = f1DB5_parent_instructions;
                                    body.emit(f1DB5);

                                    /* END IF */


                                 body.instructions = f1DB3_parent_instructions;
                                 body.emit(f1DB3);

                                 /* END IF */

                                 body.emit(assign(r1DAA, body.constant(0u), 0x01));


                              body.instructions = f1DAF_parent_instructions;
                              body.emit(f1DAF);

                              /* END IF */

                              ir_expression *const r1DBD = nequal(r1DA6, body.constant(0u));
                              ir_expression *const r1DBE = expr(ir_unop_b2i, r1DBD);
                              ir_expression *const r1DBF = expr(ir_unop_i2u, r1DBE);
                              body.emit(assign(r1DA8, bit_or(r1DA8, r1DBF), 0x01));


                           body.instructions = f1DAD_parent_instructions;
                           body.emit(f1DAD);

                           /* END IF */

                           body.emit(assign(r1D82, r1DAA, 0x01));

                           body.emit(assign(r1D83, r1DA9, 0x01));

                           body.emit(assign(r1D84, r1DA8, 0x01));


                        body.instructions = f1D9C_parent_instructions;
                        body.emit(f1D9C);

                        /* END IF */

                        body.emit(assign(r1D81, sub(r1D81, r1D85), 0x01));

                        ir_variable *const r1DC0 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r1DC0, r1D81, 0x01));

                        ir_variable *const r1DC1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r1DC1, r1D82, 0x01));

                        ir_variable *const r1DC2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1DC2, r1D83, 0x01));

                        ir_variable *const r1DC3 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r1DC3, r1D84, 0x01));

                        ir_variable *const r1DC4 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r1DC4, body.constant(true), 0x01));

                        ir_variable *const r1DC5 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r1DC6 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r1DC6);
                        ir_expression *const r1DC7 = expr(ir_unop_u2i, r1D84);
                        body.emit(assign(r1DC6, less(r1DC7, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1DC9 = lequal(body.constant(int(2045)), r1D81);
                        ir_if *f1DC8 = new(mem_ctx) ir_if(operand(r1DC9).val);
                        exec_list *const f1DC8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1DC8->then_instructions;

                           ir_variable *const r1DCA = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1DCC = less(body.constant(int(2045)), r1D81);
                           ir_if *f1DCB = new(mem_ctx) ir_if(operand(r1DCC).val);
                           exec_list *const f1DCB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1DCB->then_instructions;

                              body.emit(assign(r1DCA, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1DCB->else_instructions;

                              ir_variable *const r1DCD = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1DCF = equal(r1D81, body.constant(int(2045)));
                              ir_if *f1DCE = new(mem_ctx) ir_if(operand(r1DCF).val);
                              exec_list *const f1DCE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1DCE->then_instructions;

                                 ir_expression *const r1DD0 = equal(body.constant(2097151u), r1D82);
                                 ir_expression *const r1DD1 = equal(body.constant(4294967295u), r1D83);
                                 body.emit(assign(r1DCD, logic_and(r1DD0, r1DD1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1DCE->else_instructions;

                                 body.emit(assign(r1DCD, body.constant(false), 0x01));


                              body.instructions = f1DCE_parent_instructions;
                              body.emit(f1DCE);

                              /* END IF */

                              body.emit(assign(r1DCA, logic_and(r1DCD, r1DC6), 0x01));


                           body.instructions = f1DCB_parent_instructions;
                           body.emit(f1DCB);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1DD2 = new(mem_ctx) ir_if(operand(r1DCA).val);
                           exec_list *const f1DD2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1DD2->then_instructions;

                              ir_variable *const r1DD3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1DD3);
                              ir_expression *const r1DD4 = lshift(r1B63, body.constant(int(31)));
                              body.emit(assign(r1DD3, add(r1DD4, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r1DD3, body.constant(0u), 0x01));

                              body.emit(assign(r1DC5, r1DD3, 0x03));

                              body.emit(assign(r1DC4, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1DD2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1DD6 = less(r1D81, body.constant(int(0)));
                              ir_if *f1DD5 = new(mem_ctx) ir_if(operand(r1DD6).val);
                              exec_list *const f1DD5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1DD5->then_instructions;

                                 ir_variable *const r1DD7 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1DD7, r1D84, 0x01));

                                 ir_variable *const r1DD8 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1DD8, neg(r1D81), 0x01));

                                 ir_variable *const r1DD9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1DD9);
                                 ir_variable *const r1DDA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1DDA);
                                 ir_variable *const r1DDB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1DDB);
                                 ir_variable *const r1DDC = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r1DDD = neg(r1DD8);
                                 body.emit(assign(r1DDC, bit_and(r1DDD, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1DDF = equal(r1DD8, body.constant(int(0)));
                                 ir_if *f1DDE = new(mem_ctx) ir_if(operand(r1DDF).val);
                                 exec_list *const f1DDE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1DDE->then_instructions;

                                    body.emit(assign(r1DD9, r1D84, 0x01));

                                    body.emit(assign(r1DDA, r1D83, 0x01));

                                    body.emit(assign(r1DDB, r1D82, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1DDE->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1DE1 = less(r1DD8, body.constant(int(32)));
                                    ir_if *f1DE0 = new(mem_ctx) ir_if(operand(r1DE1).val);
                                    exec_list *const f1DE0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1DE0->then_instructions;

                                       body.emit(assign(r1DD9, lshift(r1D83, r1DDC), 0x01));

                                       ir_expression *const r1DE2 = lshift(r1D82, r1DDC);
                                       ir_expression *const r1DE3 = rshift(r1D83, r1DD8);
                                       body.emit(assign(r1DDA, bit_or(r1DE2, r1DE3), 0x01));

                                       body.emit(assign(r1DDB, rshift(r1D82, r1DD8), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1DE0->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1DE5 = equal(r1DD8, body.constant(int(32)));
                                       ir_if *f1DE4 = new(mem_ctx) ir_if(operand(r1DE5).val);
                                       exec_list *const f1DE4_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1DE4->then_instructions;

                                          body.emit(assign(r1DD9, r1D83, 0x01));

                                          body.emit(assign(r1DDA, r1D82, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1DE4->else_instructions;

                                          body.emit(assign(r1DD7, bit_or(r1D84, r1D83), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1DE7 = less(r1DD8, body.constant(int(64)));
                                          ir_if *f1DE6 = new(mem_ctx) ir_if(operand(r1DE7).val);
                                          exec_list *const f1DE6_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1DE6->then_instructions;

                                             body.emit(assign(r1DD9, lshift(r1D82, r1DDC), 0x01));

                                             ir_expression *const r1DE8 = bit_and(r1DD8, body.constant(int(31)));
                                             body.emit(assign(r1DDA, rshift(r1D82, r1DE8), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1DE6->else_instructions;

                                             ir_variable *const r1DE9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1DEB = equal(r1DD8, body.constant(int(64)));
                                             ir_if *f1DEA = new(mem_ctx) ir_if(operand(r1DEB).val);
                                             exec_list *const f1DEA_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1DEA->then_instructions;

                                                body.emit(assign(r1DE9, r1D82, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1DEA->else_instructions;

                                                ir_expression *const r1DEC = nequal(r1D82, body.constant(0u));
                                                ir_expression *const r1DED = expr(ir_unop_b2i, r1DEC);
                                                body.emit(assign(r1DE9, expr(ir_unop_i2u, r1DED), 0x01));


                                             body.instructions = f1DEA_parent_instructions;
                                             body.emit(f1DEA);

                                             /* END IF */

                                             body.emit(assign(r1DD9, r1DE9, 0x01));

                                             body.emit(assign(r1DDA, body.constant(0u), 0x01));


                                          body.instructions = f1DE6_parent_instructions;
                                          body.emit(f1DE6);

                                          /* END IF */


                                       body.instructions = f1DE4_parent_instructions;
                                       body.emit(f1DE4);

                                       /* END IF */

                                       body.emit(assign(r1DDB, body.constant(0u), 0x01));


                                    body.instructions = f1DE0_parent_instructions;
                                    body.emit(f1DE0);

                                    /* END IF */

                                    ir_expression *const r1DEE = nequal(r1DD7, body.constant(0u));
                                    ir_expression *const r1DEF = expr(ir_unop_b2i, r1DEE);
                                    ir_expression *const r1DF0 = expr(ir_unop_i2u, r1DEF);
                                    body.emit(assign(r1DD9, bit_or(r1DD9, r1DF0), 0x01));


                                 body.instructions = f1DDE_parent_instructions;
                                 body.emit(f1DDE);

                                 /* END IF */

                                 body.emit(assign(r1DC1, r1DDB, 0x01));

                                 body.emit(assign(r1DC2, r1DDA, 0x01));

                                 body.emit(assign(r1DC3, r1DD9, 0x01));

                                 body.emit(assign(r1DC0, body.constant(int(0)), 0x01));

                                 body.emit(assign(r1DC6, less(r1DD9, body.constant(0u)), 0x01));


                              body.instructions = f1DD5_parent_instructions;
                              body.emit(f1DD5);

                              /* END IF */


                           body.instructions = f1DD2_parent_instructions;
                           body.emit(f1DD2);

                           /* END IF */


                        body.instructions = f1DC8_parent_instructions;
                        body.emit(f1DC8);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1DF1 = new(mem_ctx) ir_if(operand(r1DC4).val);
                        exec_list *const f1DF1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1DF1->then_instructions;

                           /* IF CONDITION */
                           ir_if *f1DF2 = new(mem_ctx) ir_if(operand(r1DC6).val);
                           exec_list *const f1DF2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1DF2->then_instructions;

                              ir_variable *const r1DF3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r1DF3, add(r1DC2, body.constant(1u)), 0x01));

                              ir_expression *const r1DF4 = less(r1DF3, r1DC2);
                              ir_expression *const r1DF5 = expr(ir_unop_b2i, r1DF4);
                              ir_expression *const r1DF6 = expr(ir_unop_i2u, r1DF5);
                              body.emit(assign(r1DC1, add(r1DC1, r1DF6), 0x01));

                              ir_expression *const r1DF7 = equal(r1DC3, body.constant(0u));
                              ir_expression *const r1DF8 = expr(ir_unop_b2i, r1DF7);
                              ir_expression *const r1DF9 = expr(ir_unop_i2u, r1DF8);
                              ir_expression *const r1DFA = add(r1DC3, r1DF9);
                              ir_expression *const r1DFB = bit_and(r1DFA, body.constant(1u));
                              ir_expression *const r1DFC = expr(ir_unop_bit_not, r1DFB);
                              body.emit(assign(r1DC2, bit_and(r1DF3, r1DFC), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1DF2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1DFE = bit_or(r1DC1, r1DC2);
                              ir_expression *const r1DFF = equal(r1DFE, body.constant(0u));
                              ir_if *f1DFD = new(mem_ctx) ir_if(operand(r1DFF).val);
                              exec_list *const f1DFD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1DFD->then_instructions;

                                 body.emit(assign(r1DC0, body.constant(int(0)), 0x01));


                              body.instructions = f1DFD_parent_instructions;
                              body.emit(f1DFD);

                              /* END IF */


                           body.instructions = f1DF2_parent_instructions;
                           body.emit(f1DF2);

                           /* END IF */

                           ir_variable *const r1E00 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1E00);
                           ir_expression *const r1E01 = lshift(r1B63, body.constant(int(31)));
                           ir_expression *const r1E02 = expr(ir_unop_i2u, r1DC0);
                           ir_expression *const r1E03 = lshift(r1E02, body.constant(int(20)));
                           ir_expression *const r1E04 = add(r1E01, r1E03);
                           body.emit(assign(r1E00, add(r1E04, r1DC1), 0x02));

                           body.emit(assign(r1E00, r1DC2, 0x01));

                           body.emit(assign(r1DC5, r1E00, 0x03));

                           body.emit(assign(r1DC4, body.constant(false), 0x01));


                        body.instructions = f1DF1_parent_instructions;
                        body.emit(f1DF1);

                        /* END IF */

                        body.emit(assign(r1B64, r1DC5, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D79->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1E06 = less(r1B69, r1B6B);
                        ir_if *f1E05 = new(mem_ctx) ir_if(operand(r1E06).val);
                        exec_list *const f1E05_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E05->then_instructions;

                           ir_variable *const r1E07 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r1E08 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1E08, sub(r1B6B, r1B69), 0x01));

                           ir_expression *const r1E09 = sub(r1B6A, r1B68);
                           ir_expression *const r1E0A = less(r1B6B, r1B69);
                           ir_expression *const r1E0B = expr(ir_unop_b2i, r1E0A);
                           ir_expression *const r1E0C = expr(ir_unop_i2u, r1E0B);
                           body.emit(assign(r1E07, sub(r1E09, r1E0C), 0x01));

                           body.emit(assign(r1B6C, add(r1B67, body.constant(int(-1))), 0x01));

                           ir_variable *const r1E0D = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1E0D, add(r1B6C, body.constant(int(-10))), 0x01));

                           ir_variable *const r1E0E = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1E0E, r1E07, 0x01));

                           ir_variable *const r1E0F = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1E0F, r1E08, 0x01));

                           ir_variable *const r1E10 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r1E10);
                           ir_variable *const r1E11 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1E11);
                           /* IF CONDITION */
                           ir_expression *const r1E13 = equal(r1E07, body.constant(0u));
                           ir_if *f1E12 = new(mem_ctx) ir_if(operand(r1E13).val);
                           exec_list *const f1E12_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E12->then_instructions;

                              body.emit(assign(r1E0E, r1E08, 0x01));

                              body.emit(assign(r1E0F, body.constant(0u), 0x01));

                              body.emit(assign(r1E0D, add(r1E0D, body.constant(int(-32))), 0x01));


                           body.instructions = f1E12_parent_instructions;
                           body.emit(f1E12);

                           /* END IF */

                           ir_variable *const r1E14 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r1E14, r1E0E, 0x01));

                           ir_variable *const r1E15 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r1E16 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1E16);
                           /* IF CONDITION */
                           ir_expression *const r1E18 = equal(r1E0E, body.constant(0u));
                           ir_if *f1E17 = new(mem_ctx) ir_if(operand(r1E18).val);
                           exec_list *const f1E17_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E17->then_instructions;

                              body.emit(assign(r1E15, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1E17->else_instructions;

                              body.emit(assign(r1E16, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1E1A = bit_and(r1E0E, body.constant(4294901760u));
                              ir_expression *const r1E1B = equal(r1E1A, body.constant(0u));
                              ir_if *f1E19 = new(mem_ctx) ir_if(operand(r1E1B).val);
                              exec_list *const f1E19_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E19->then_instructions;

                                 body.emit(assign(r1E16, body.constant(int(16)), 0x01));

                                 body.emit(assign(r1E14, lshift(r1E0E, body.constant(int(16))), 0x01));


                              body.instructions = f1E19_parent_instructions;
                              body.emit(f1E19);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1E1D = bit_and(r1E14, body.constant(4278190080u));
                              ir_expression *const r1E1E = equal(r1E1D, body.constant(0u));
                              ir_if *f1E1C = new(mem_ctx) ir_if(operand(r1E1E).val);
                              exec_list *const f1E1C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E1C->then_instructions;

                                 body.emit(assign(r1E16, add(r1E16, body.constant(int(8))), 0x01));

                                 body.emit(assign(r1E14, lshift(r1E14, body.constant(int(8))), 0x01));


                              body.instructions = f1E1C_parent_instructions;
                              body.emit(f1E1C);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1E20 = bit_and(r1E14, body.constant(4026531840u));
                              ir_expression *const r1E21 = equal(r1E20, body.constant(0u));
                              ir_if *f1E1F = new(mem_ctx) ir_if(operand(r1E21).val);
                              exec_list *const f1E1F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E1F->then_instructions;

                                 body.emit(assign(r1E16, add(r1E16, body.constant(int(4))), 0x01));

                                 body.emit(assign(r1E14, lshift(r1E14, body.constant(int(4))), 0x01));


                              body.instructions = f1E1F_parent_instructions;
                              body.emit(f1E1F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1E23 = bit_and(r1E14, body.constant(3221225472u));
                              ir_expression *const r1E24 = equal(r1E23, body.constant(0u));
                              ir_if *f1E22 = new(mem_ctx) ir_if(operand(r1E24).val);
                              exec_list *const f1E22_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E22->then_instructions;

                                 body.emit(assign(r1E16, add(r1E16, body.constant(int(2))), 0x01));

                                 body.emit(assign(r1E14, lshift(r1E14, body.constant(int(2))), 0x01));


                              body.instructions = f1E22_parent_instructions;
                              body.emit(f1E22);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1E26 = bit_and(r1E14, body.constant(2147483648u));
                              ir_expression *const r1E27 = equal(r1E26, body.constant(0u));
                              ir_if *f1E25 = new(mem_ctx) ir_if(operand(r1E27).val);
                              exec_list *const f1E25_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E25->then_instructions;

                                 body.emit(assign(r1E16, add(r1E16, body.constant(int(1))), 0x01));


                              body.instructions = f1E25_parent_instructions;
                              body.emit(f1E25);

                              /* END IF */

                              body.emit(assign(r1E15, r1E16, 0x01));


                           body.instructions = f1E17_parent_instructions;
                           body.emit(f1E17);

                           /* END IF */

                           body.emit(assign(r1E11, add(r1E15, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1E29 = lequal(body.constant(int(0)), r1E11);
                           ir_if *f1E28 = new(mem_ctx) ir_if(operand(r1E29).val);
                           exec_list *const f1E28_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E28->then_instructions;

                              body.emit(assign(r1E10, body.constant(0u), 0x01));

                              ir_variable *const r1E2A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1E2A, lshift(r1E0F, r1E11), 0x01));

                              ir_variable *const r1E2B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1E2D = equal(r1E11, body.constant(int(0)));
                              ir_if *f1E2C = new(mem_ctx) ir_if(operand(r1E2D).val);
                              exec_list *const f1E2C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E2C->then_instructions;

                                 body.emit(assign(r1E2B, r1E0E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1E2C->else_instructions;

                                 ir_expression *const r1E2E = lshift(r1E0E, r1E11);
                                 ir_expression *const r1E2F = neg(r1E11);
                                 ir_expression *const r1E30 = bit_and(r1E2F, body.constant(int(31)));
                                 ir_expression *const r1E31 = rshift(r1E0F, r1E30);
                                 body.emit(assign(r1E2B, bit_or(r1E2E, r1E31), 0x01));


                              body.instructions = f1E2C_parent_instructions;
                              body.emit(f1E2C);

                              /* END IF */

                              body.emit(assign(r1E0E, r1E2B, 0x01));

                              body.emit(assign(r1E0F, r1E2A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1E28->else_instructions;

                              ir_variable *const r1E32 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1E32, body.constant(0u), 0x01));

                              ir_variable *const r1E33 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1E33, neg(r1E11), 0x01));

                              ir_variable *const r1E34 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1E34);
                              ir_variable *const r1E35 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1E35);
                              ir_variable *const r1E36 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1E36);
                              ir_variable *const r1E37 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1E38 = neg(r1E33);
                              body.emit(assign(r1E37, bit_and(r1E38, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1E3A = equal(r1E33, body.constant(int(0)));
                              ir_if *f1E39 = new(mem_ctx) ir_if(operand(r1E3A).val);
                              exec_list *const f1E39_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E39->then_instructions;

                                 body.emit(assign(r1E34, r1E32, 0x01));

                                 body.emit(assign(r1E35, r1E0F, 0x01));

                                 body.emit(assign(r1E36, r1E0E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1E39->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1E3C = less(r1E33, body.constant(int(32)));
                                 ir_if *f1E3B = new(mem_ctx) ir_if(operand(r1E3C).val);
                                 exec_list *const f1E3B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1E3B->then_instructions;

                                    body.emit(assign(r1E34, lshift(r1E0F, r1E37), 0x01));

                                    ir_expression *const r1E3D = lshift(r1E0E, r1E37);
                                    ir_expression *const r1E3E = rshift(r1E0F, r1E33);
                                    body.emit(assign(r1E35, bit_or(r1E3D, r1E3E), 0x01));

                                    body.emit(assign(r1E36, rshift(r1E0E, r1E33), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1E3B->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1E40 = equal(r1E33, body.constant(int(32)));
                                    ir_if *f1E3F = new(mem_ctx) ir_if(operand(r1E40).val);
                                    exec_list *const f1E3F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1E3F->then_instructions;

                                       body.emit(assign(r1E34, r1E0F, 0x01));

                                       body.emit(assign(r1E35, r1E0E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1E3F->else_instructions;

                                       body.emit(assign(r1E32, bit_or(body.constant(0u), r1E0F), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1E42 = less(r1E33, body.constant(int(64)));
                                       ir_if *f1E41 = new(mem_ctx) ir_if(operand(r1E42).val);
                                       exec_list *const f1E41_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1E41->then_instructions;

                                          body.emit(assign(r1E34, lshift(r1E0E, r1E37), 0x01));

                                          ir_expression *const r1E43 = bit_and(r1E33, body.constant(int(31)));
                                          body.emit(assign(r1E35, rshift(r1E0E, r1E43), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1E41->else_instructions;

                                          ir_variable *const r1E44 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1E46 = equal(r1E33, body.constant(int(64)));
                                          ir_if *f1E45 = new(mem_ctx) ir_if(operand(r1E46).val);
                                          exec_list *const f1E45_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1E45->then_instructions;

                                             body.emit(assign(r1E44, r1E0E, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1E45->else_instructions;

                                             ir_expression *const r1E47 = nequal(r1E0E, body.constant(0u));
                                             ir_expression *const r1E48 = expr(ir_unop_b2i, r1E47);
                                             body.emit(assign(r1E44, expr(ir_unop_i2u, r1E48), 0x01));


                                          body.instructions = f1E45_parent_instructions;
                                          body.emit(f1E45);

                                          /* END IF */

                                          body.emit(assign(r1E34, r1E44, 0x01));

                                          body.emit(assign(r1E35, body.constant(0u), 0x01));


                                       body.instructions = f1E41_parent_instructions;
                                       body.emit(f1E41);

                                       /* END IF */


                                    body.instructions = f1E3F_parent_instructions;
                                    body.emit(f1E3F);

                                    /* END IF */

                                    body.emit(assign(r1E36, body.constant(0u), 0x01));


                                 body.instructions = f1E3B_parent_instructions;
                                 body.emit(f1E3B);

                                 /* END IF */

                                 ir_expression *const r1E49 = nequal(r1E32, body.constant(0u));
                                 ir_expression *const r1E4A = expr(ir_unop_b2i, r1E49);
                                 ir_expression *const r1E4B = expr(ir_unop_i2u, r1E4A);
                                 body.emit(assign(r1E34, bit_or(r1E34, r1E4B), 0x01));


                              body.instructions = f1E39_parent_instructions;
                              body.emit(f1E39);

                              /* END IF */

                              body.emit(assign(r1E0E, r1E36, 0x01));

                              body.emit(assign(r1E0F, r1E35, 0x01));

                              body.emit(assign(r1E10, r1E34, 0x01));


                           body.instructions = f1E28_parent_instructions;
                           body.emit(f1E28);

                           /* END IF */

                           body.emit(assign(r1E0D, sub(r1E0D, r1E11), 0x01));

                           ir_variable *const r1E4C = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1E4C, r1E0D, 0x01));

                           ir_variable *const r1E4D = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1E4D, r1E0E, 0x01));

                           ir_variable *const r1E4E = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1E4E, r1E0F, 0x01));

                           ir_variable *const r1E4F = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r1E4F, r1E10, 0x01));

                           ir_variable *const r1E50 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r1E50, body.constant(true), 0x01));

                           ir_variable *const r1E51 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r1E52 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r1E52);
                           ir_expression *const r1E53 = expr(ir_unop_u2i, r1E10);
                           body.emit(assign(r1E52, less(r1E53, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1E55 = lequal(body.constant(int(2045)), r1E0D);
                           ir_if *f1E54 = new(mem_ctx) ir_if(operand(r1E55).val);
                           exec_list *const f1E54_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E54->then_instructions;

                              ir_variable *const r1E56 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1E58 = less(body.constant(int(2045)), r1E0D);
                              ir_if *f1E57 = new(mem_ctx) ir_if(operand(r1E58).val);
                              exec_list *const f1E57_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E57->then_instructions;

                                 body.emit(assign(r1E56, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1E57->else_instructions;

                                 ir_variable *const r1E59 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1E5B = equal(r1E0D, body.constant(int(2045)));
                                 ir_if *f1E5A = new(mem_ctx) ir_if(operand(r1E5B).val);
                                 exec_list *const f1E5A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1E5A->then_instructions;

                                    ir_expression *const r1E5C = equal(body.constant(2097151u), r1E0E);
                                    ir_expression *const r1E5D = equal(body.constant(4294967295u), r1E0F);
                                    body.emit(assign(r1E59, logic_and(r1E5C, r1E5D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1E5A->else_instructions;

                                    body.emit(assign(r1E59, body.constant(false), 0x01));


                                 body.instructions = f1E5A_parent_instructions;
                                 body.emit(f1E5A);

                                 /* END IF */

                                 body.emit(assign(r1E56, logic_and(r1E59, r1E52), 0x01));


                              body.instructions = f1E57_parent_instructions;
                              body.emit(f1E57);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f1E5E = new(mem_ctx) ir_if(operand(r1E56).val);
                              exec_list *const f1E5E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E5E->then_instructions;

                                 ir_variable *const r1E5F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r1E5F);
                                 ir_expression *const r1E60 = lshift(r1B63, body.constant(int(31)));
                                 body.emit(assign(r1E5F, add(r1E60, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r1E5F, body.constant(0u), 0x01));

                                 body.emit(assign(r1E51, r1E5F, 0x03));

                                 body.emit(assign(r1E50, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1E5E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1E62 = less(r1E0D, body.constant(int(0)));
                                 ir_if *f1E61 = new(mem_ctx) ir_if(operand(r1E62).val);
                                 exec_list *const f1E61_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1E61->then_instructions;

                                    ir_variable *const r1E63 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r1E63, r1E10, 0x01));

                                    ir_variable *const r1E64 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r1E64, neg(r1E0D), 0x01));

                                    ir_variable *const r1E65 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r1E65);
                                    ir_variable *const r1E66 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r1E66);
                                    ir_variable *const r1E67 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r1E67);
                                    ir_variable *const r1E68 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r1E69 = neg(r1E64);
                                    body.emit(assign(r1E68, bit_and(r1E69, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1E6B = equal(r1E64, body.constant(int(0)));
                                    ir_if *f1E6A = new(mem_ctx) ir_if(operand(r1E6B).val);
                                    exec_list *const f1E6A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1E6A->then_instructions;

                                       body.emit(assign(r1E65, r1E10, 0x01));

                                       body.emit(assign(r1E66, r1E0F, 0x01));

                                       body.emit(assign(r1E67, r1E0E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1E6A->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1E6D = less(r1E64, body.constant(int(32)));
                                       ir_if *f1E6C = new(mem_ctx) ir_if(operand(r1E6D).val);
                                       exec_list *const f1E6C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1E6C->then_instructions;

                                          body.emit(assign(r1E65, lshift(r1E0F, r1E68), 0x01));

                                          ir_expression *const r1E6E = lshift(r1E0E, r1E68);
                                          ir_expression *const r1E6F = rshift(r1E0F, r1E64);
                                          body.emit(assign(r1E66, bit_or(r1E6E, r1E6F), 0x01));

                                          body.emit(assign(r1E67, rshift(r1E0E, r1E64), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1E6C->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r1E71 = equal(r1E64, body.constant(int(32)));
                                          ir_if *f1E70 = new(mem_ctx) ir_if(operand(r1E71).val);
                                          exec_list *const f1E70_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1E70->then_instructions;

                                             body.emit(assign(r1E65, r1E0F, 0x01));

                                             body.emit(assign(r1E66, r1E0E, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1E70->else_instructions;

                                             body.emit(assign(r1E63, bit_or(r1E10, r1E0F), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r1E73 = less(r1E64, body.constant(int(64)));
                                             ir_if *f1E72 = new(mem_ctx) ir_if(operand(r1E73).val);
                                             exec_list *const f1E72_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1E72->then_instructions;

                                                body.emit(assign(r1E65, lshift(r1E0E, r1E68), 0x01));

                                                ir_expression *const r1E74 = bit_and(r1E64, body.constant(int(31)));
                                                body.emit(assign(r1E66, rshift(r1E0E, r1E74), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1E72->else_instructions;

                                                ir_variable *const r1E75 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r1E77 = equal(r1E64, body.constant(int(64)));
                                                ir_if *f1E76 = new(mem_ctx) ir_if(operand(r1E77).val);
                                                exec_list *const f1E76_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f1E76->then_instructions;

                                                   body.emit(assign(r1E75, r1E0E, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f1E76->else_instructions;

                                                   ir_expression *const r1E78 = nequal(r1E0E, body.constant(0u));
                                                   ir_expression *const r1E79 = expr(ir_unop_b2i, r1E78);
                                                   body.emit(assign(r1E75, expr(ir_unop_i2u, r1E79), 0x01));


                                                body.instructions = f1E76_parent_instructions;
                                                body.emit(f1E76);

                                                /* END IF */

                                                body.emit(assign(r1E65, r1E75, 0x01));

                                                body.emit(assign(r1E66, body.constant(0u), 0x01));


                                             body.instructions = f1E72_parent_instructions;
                                             body.emit(f1E72);

                                             /* END IF */


                                          body.instructions = f1E70_parent_instructions;
                                          body.emit(f1E70);

                                          /* END IF */

                                          body.emit(assign(r1E67, body.constant(0u), 0x01));


                                       body.instructions = f1E6C_parent_instructions;
                                       body.emit(f1E6C);

                                       /* END IF */

                                       ir_expression *const r1E7A = nequal(r1E63, body.constant(0u));
                                       ir_expression *const r1E7B = expr(ir_unop_b2i, r1E7A);
                                       ir_expression *const r1E7C = expr(ir_unop_i2u, r1E7B);
                                       body.emit(assign(r1E65, bit_or(r1E65, r1E7C), 0x01));


                                    body.instructions = f1E6A_parent_instructions;
                                    body.emit(f1E6A);

                                    /* END IF */

                                    body.emit(assign(r1E4D, r1E67, 0x01));

                                    body.emit(assign(r1E4E, r1E66, 0x01));

                                    body.emit(assign(r1E4F, r1E65, 0x01));

                                    body.emit(assign(r1E4C, body.constant(int(0)), 0x01));

                                    body.emit(assign(r1E52, less(r1E65, body.constant(0u)), 0x01));


                                 body.instructions = f1E61_parent_instructions;
                                 body.emit(f1E61);

                                 /* END IF */


                              body.instructions = f1E5E_parent_instructions;
                              body.emit(f1E5E);

                              /* END IF */


                           body.instructions = f1E54_parent_instructions;
                           body.emit(f1E54);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1E7D = new(mem_ctx) ir_if(operand(r1E50).val);
                           exec_list *const f1E7D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E7D->then_instructions;

                              /* IF CONDITION */
                              ir_if *f1E7E = new(mem_ctx) ir_if(operand(r1E52).val);
                              exec_list *const f1E7E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E7E->then_instructions;

                                 ir_variable *const r1E7F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r1E7F, add(r1E4E, body.constant(1u)), 0x01));

                                 ir_expression *const r1E80 = less(r1E7F, r1E4E);
                                 ir_expression *const r1E81 = expr(ir_unop_b2i, r1E80);
                                 ir_expression *const r1E82 = expr(ir_unop_i2u, r1E81);
                                 body.emit(assign(r1E4D, add(r1E4D, r1E82), 0x01));

                                 ir_expression *const r1E83 = equal(r1E4F, body.constant(0u));
                                 ir_expression *const r1E84 = expr(ir_unop_b2i, r1E83);
                                 ir_expression *const r1E85 = expr(ir_unop_i2u, r1E84);
                                 ir_expression *const r1E86 = add(r1E4F, r1E85);
                                 ir_expression *const r1E87 = bit_and(r1E86, body.constant(1u));
                                 ir_expression *const r1E88 = expr(ir_unop_bit_not, r1E87);
                                 body.emit(assign(r1E4E, bit_and(r1E7F, r1E88), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1E7E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1E8A = bit_or(r1E4D, r1E4E);
                                 ir_expression *const r1E8B = equal(r1E8A, body.constant(0u));
                                 ir_if *f1E89 = new(mem_ctx) ir_if(operand(r1E8B).val);
                                 exec_list *const f1E89_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1E89->then_instructions;

                                    body.emit(assign(r1E4C, body.constant(int(0)), 0x01));


                                 body.instructions = f1E89_parent_instructions;
                                 body.emit(f1E89);

                                 /* END IF */


                              body.instructions = f1E7E_parent_instructions;
                              body.emit(f1E7E);

                              /* END IF */

                              ir_variable *const r1E8C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1E8C);
                              ir_expression *const r1E8D = lshift(r1B63, body.constant(int(31)));
                              ir_expression *const r1E8E = expr(ir_unop_i2u, r1E4C);
                              ir_expression *const r1E8F = lshift(r1E8E, body.constant(int(20)));
                              ir_expression *const r1E90 = add(r1E8D, r1E8F);
                              body.emit(assign(r1E8C, add(r1E90, r1E4D), 0x02));

                              body.emit(assign(r1E8C, r1E4E, 0x01));

                              body.emit(assign(r1E51, r1E8C, 0x03));

                              body.emit(assign(r1E50, body.constant(false), 0x01));


                           body.instructions = f1E7D_parent_instructions;
                           body.emit(f1E7D);

                           /* END IF */

                           body.emit(assign(r1B64, r1E51, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E05->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1E92 = less(r1B6B, r1B69);
                           ir_if *f1E91 = new(mem_ctx) ir_if(operand(r1E92).val);
                           exec_list *const f1E91_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E91->then_instructions;

                              ir_variable *const r1E93 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r1E94 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1E94, sub(r1B69, r1B6B), 0x01));

                              ir_expression *const r1E95 = sub(r1B68, r1B6A);
                              ir_expression *const r1E96 = less(r1B69, r1B6B);
                              ir_expression *const r1E97 = expr(ir_unop_b2i, r1E96);
                              ir_expression *const r1E98 = expr(ir_unop_i2u, r1E97);
                              body.emit(assign(r1E93, sub(r1E95, r1E98), 0x01));

                              body.emit(assign(r1B63, bit_xor(r1B63, body.constant(1u)), 0x01));

                              body.emit(assign(r1B6C, add(r1B66, body.constant(int(-1))), 0x01));

                              ir_variable *const r1E99 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r1E99, add(r1B6C, body.constant(int(-10))), 0x01));

                              ir_variable *const r1E9A = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r1E9A, r1E93, 0x01));

                              ir_variable *const r1E9B = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r1E9B, r1E94, 0x01));

                              ir_variable *const r1E9C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r1E9C);
                              ir_variable *const r1E9D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r1E9D);
                              /* IF CONDITION */
                              ir_expression *const r1E9F = equal(r1E93, body.constant(0u));
                              ir_if *f1E9E = new(mem_ctx) ir_if(operand(r1E9F).val);
                              exec_list *const f1E9E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E9E->then_instructions;

                                 body.emit(assign(r1E9A, r1E94, 0x01));

                                 body.emit(assign(r1E9B, body.constant(0u), 0x01));

                                 body.emit(assign(r1E99, add(r1E99, body.constant(int(-32))), 0x01));


                              body.instructions = f1E9E_parent_instructions;
                              body.emit(f1E9E);

                              /* END IF */

                              ir_variable *const r1EA0 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r1EA0, r1E9A, 0x01));

                              ir_variable *const r1EA1 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r1EA2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r1EA2);
                              /* IF CONDITION */
                              ir_expression *const r1EA4 = equal(r1E9A, body.constant(0u));
                              ir_if *f1EA3 = new(mem_ctx) ir_if(operand(r1EA4).val);
                              exec_list *const f1EA3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1EA3->then_instructions;

                                 body.emit(assign(r1EA1, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1EA3->else_instructions;

                                 body.emit(assign(r1EA2, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1EA6 = bit_and(r1E9A, body.constant(4294901760u));
                                 ir_expression *const r1EA7 = equal(r1EA6, body.constant(0u));
                                 ir_if *f1EA5 = new(mem_ctx) ir_if(operand(r1EA7).val);
                                 exec_list *const f1EA5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1EA5->then_instructions;

                                    body.emit(assign(r1EA2, body.constant(int(16)), 0x01));

                                    body.emit(assign(r1EA0, lshift(r1E9A, body.constant(int(16))), 0x01));


                                 body.instructions = f1EA5_parent_instructions;
                                 body.emit(f1EA5);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1EA9 = bit_and(r1EA0, body.constant(4278190080u));
                                 ir_expression *const r1EAA = equal(r1EA9, body.constant(0u));
                                 ir_if *f1EA8 = new(mem_ctx) ir_if(operand(r1EAA).val);
                                 exec_list *const f1EA8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1EA8->then_instructions;

                                    body.emit(assign(r1EA2, add(r1EA2, body.constant(int(8))), 0x01));

                                    body.emit(assign(r1EA0, lshift(r1EA0, body.constant(int(8))), 0x01));


                                 body.instructions = f1EA8_parent_instructions;
                                 body.emit(f1EA8);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1EAC = bit_and(r1EA0, body.constant(4026531840u));
                                 ir_expression *const r1EAD = equal(r1EAC, body.constant(0u));
                                 ir_if *f1EAB = new(mem_ctx) ir_if(operand(r1EAD).val);
                                 exec_list *const f1EAB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1EAB->then_instructions;

                                    body.emit(assign(r1EA2, add(r1EA2, body.constant(int(4))), 0x01));

                                    body.emit(assign(r1EA0, lshift(r1EA0, body.constant(int(4))), 0x01));


                                 body.instructions = f1EAB_parent_instructions;
                                 body.emit(f1EAB);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1EAF = bit_and(r1EA0, body.constant(3221225472u));
                                 ir_expression *const r1EB0 = equal(r1EAF, body.constant(0u));
                                 ir_if *f1EAE = new(mem_ctx) ir_if(operand(r1EB0).val);
                                 exec_list *const f1EAE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1EAE->then_instructions;

                                    body.emit(assign(r1EA2, add(r1EA2, body.constant(int(2))), 0x01));

                                    body.emit(assign(r1EA0, lshift(r1EA0, body.constant(int(2))), 0x01));


                                 body.instructions = f1EAE_parent_instructions;
                                 body.emit(f1EAE);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1EB2 = bit_and(r1EA0, body.constant(2147483648u));
                                 ir_expression *const r1EB3 = equal(r1EB2, body.constant(0u));
                                 ir_if *f1EB1 = new(mem_ctx) ir_if(operand(r1EB3).val);
                                 exec_list *const f1EB1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1EB1->then_instructions;

                                    body.emit(assign(r1EA2, add(r1EA2, body.constant(int(1))), 0x01));


                                 body.instructions = f1EB1_parent_instructions;
                                 body.emit(f1EB1);

                                 /* END IF */

                                 body.emit(assign(r1EA1, r1EA2, 0x01));


                              body.instructions = f1EA3_parent_instructions;
                              body.emit(f1EA3);

                              /* END IF */

                              body.emit(assign(r1E9D, add(r1EA1, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1EB5 = lequal(body.constant(int(0)), r1E9D);
                              ir_if *f1EB4 = new(mem_ctx) ir_if(operand(r1EB5).val);
                              exec_list *const f1EB4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1EB4->then_instructions;

                                 body.emit(assign(r1E9C, body.constant(0u), 0x01));

                                 ir_variable *const r1EB6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r1EB6, lshift(r1E9B, r1E9D), 0x01));

                                 ir_variable *const r1EB7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1EB9 = equal(r1E9D, body.constant(int(0)));
                                 ir_if *f1EB8 = new(mem_ctx) ir_if(operand(r1EB9).val);
                                 exec_list *const f1EB8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1EB8->then_instructions;

                                    body.emit(assign(r1EB7, r1E9A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1EB8->else_instructions;

                                    ir_expression *const r1EBA = lshift(r1E9A, r1E9D);
                                    ir_expression *const r1EBB = neg(r1E9D);
                                    ir_expression *const r1EBC = bit_and(r1EBB, body.constant(int(31)));
                                    ir_expression *const r1EBD = rshift(r1E9B, r1EBC);
                                    body.emit(assign(r1EB7, bit_or(r1EBA, r1EBD), 0x01));


                                 body.instructions = f1EB8_parent_instructions;
                                 body.emit(f1EB8);

                                 /* END IF */

                                 body.emit(assign(r1E9A, r1EB7, 0x01));

                                 body.emit(assign(r1E9B, r1EB6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1EB4->else_instructions;

                                 ir_variable *const r1EBE = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1EBE, body.constant(0u), 0x01));

                                 ir_variable *const r1EBF = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1EBF, neg(r1E9D), 0x01));

                                 ir_variable *const r1EC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1EC0);
                                 ir_variable *const r1EC1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1EC1);
                                 ir_variable *const r1EC2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1EC2);
                                 ir_variable *const r1EC3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r1EC4 = neg(r1EBF);
                                 body.emit(assign(r1EC3, bit_and(r1EC4, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1EC6 = equal(r1EBF, body.constant(int(0)));
                                 ir_if *f1EC5 = new(mem_ctx) ir_if(operand(r1EC6).val);
                                 exec_list *const f1EC5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1EC5->then_instructions;

                                    body.emit(assign(r1EC0, r1EBE, 0x01));

                                    body.emit(assign(r1EC1, r1E9B, 0x01));

                                    body.emit(assign(r1EC2, r1E9A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1EC5->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1EC8 = less(r1EBF, body.constant(int(32)));
                                    ir_if *f1EC7 = new(mem_ctx) ir_if(operand(r1EC8).val);
                                    exec_list *const f1EC7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1EC7->then_instructions;

                                       body.emit(assign(r1EC0, lshift(r1E9B, r1EC3), 0x01));

                                       ir_expression *const r1EC9 = lshift(r1E9A, r1EC3);
                                       ir_expression *const r1ECA = rshift(r1E9B, r1EBF);
                                       body.emit(assign(r1EC1, bit_or(r1EC9, r1ECA), 0x01));

                                       body.emit(assign(r1EC2, rshift(r1E9A, r1EBF), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1EC7->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1ECC = equal(r1EBF, body.constant(int(32)));
                                       ir_if *f1ECB = new(mem_ctx) ir_if(operand(r1ECC).val);
                                       exec_list *const f1ECB_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1ECB->then_instructions;

                                          body.emit(assign(r1EC0, r1E9B, 0x01));

                                          body.emit(assign(r1EC1, r1E9A, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1ECB->else_instructions;

                                          body.emit(assign(r1EBE, bit_or(body.constant(0u), r1E9B), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1ECE = less(r1EBF, body.constant(int(64)));
                                          ir_if *f1ECD = new(mem_ctx) ir_if(operand(r1ECE).val);
                                          exec_list *const f1ECD_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1ECD->then_instructions;

                                             body.emit(assign(r1EC0, lshift(r1E9A, r1EC3), 0x01));

                                             ir_expression *const r1ECF = bit_and(r1EBF, body.constant(int(31)));
                                             body.emit(assign(r1EC1, rshift(r1E9A, r1ECF), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1ECD->else_instructions;

                                             ir_variable *const r1ED0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1ED2 = equal(r1EBF, body.constant(int(64)));
                                             ir_if *f1ED1 = new(mem_ctx) ir_if(operand(r1ED2).val);
                                             exec_list *const f1ED1_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1ED1->then_instructions;

                                                body.emit(assign(r1ED0, r1E9A, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1ED1->else_instructions;

                                                ir_expression *const r1ED3 = nequal(r1E9A, body.constant(0u));
                                                ir_expression *const r1ED4 = expr(ir_unop_b2i, r1ED3);
                                                body.emit(assign(r1ED0, expr(ir_unop_i2u, r1ED4), 0x01));


                                             body.instructions = f1ED1_parent_instructions;
                                             body.emit(f1ED1);

                                             /* END IF */

                                             body.emit(assign(r1EC0, r1ED0, 0x01));

                                             body.emit(assign(r1EC1, body.constant(0u), 0x01));


                                          body.instructions = f1ECD_parent_instructions;
                                          body.emit(f1ECD);

                                          /* END IF */


                                       body.instructions = f1ECB_parent_instructions;
                                       body.emit(f1ECB);

                                       /* END IF */

                                       body.emit(assign(r1EC2, body.constant(0u), 0x01));


                                    body.instructions = f1EC7_parent_instructions;
                                    body.emit(f1EC7);

                                    /* END IF */

                                    ir_expression *const r1ED5 = nequal(r1EBE, body.constant(0u));
                                    ir_expression *const r1ED6 = expr(ir_unop_b2i, r1ED5);
                                    ir_expression *const r1ED7 = expr(ir_unop_i2u, r1ED6);
                                    body.emit(assign(r1EC0, bit_or(r1EC0, r1ED7), 0x01));


                                 body.instructions = f1EC5_parent_instructions;
                                 body.emit(f1EC5);

                                 /* END IF */

                                 body.emit(assign(r1E9A, r1EC2, 0x01));

                                 body.emit(assign(r1E9B, r1EC1, 0x01));

                                 body.emit(assign(r1E9C, r1EC0, 0x01));


                              body.instructions = f1EB4_parent_instructions;
                              body.emit(f1EB4);

                              /* END IF */

                              body.emit(assign(r1E99, sub(r1E99, r1E9D), 0x01));

                              ir_variable *const r1ED8 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r1ED8, r1E99, 0x01));

                              ir_variable *const r1ED9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r1ED9, r1E9A, 0x01));

                              ir_variable *const r1EDA = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r1EDA, r1E9B, 0x01));

                              ir_variable *const r1EDB = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r1EDB, r1E9C, 0x01));

                              ir_variable *const r1EDC = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r1EDC, body.constant(true), 0x01));

                              ir_variable *const r1EDD = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r1EDE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r1EDE);
                              ir_expression *const r1EDF = expr(ir_unop_u2i, r1E9C);
                              body.emit(assign(r1EDE, less(r1EDF, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1EE1 = lequal(body.constant(int(2045)), r1E99);
                              ir_if *f1EE0 = new(mem_ctx) ir_if(operand(r1EE1).val);
                              exec_list *const f1EE0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1EE0->then_instructions;

                                 ir_variable *const r1EE2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1EE4 = less(body.constant(int(2045)), r1E99);
                                 ir_if *f1EE3 = new(mem_ctx) ir_if(operand(r1EE4).val);
                                 exec_list *const f1EE3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1EE3->then_instructions;

                                    body.emit(assign(r1EE2, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1EE3->else_instructions;

                                    ir_variable *const r1EE5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1EE7 = equal(r1E99, body.constant(int(2045)));
                                    ir_if *f1EE6 = new(mem_ctx) ir_if(operand(r1EE7).val);
                                    exec_list *const f1EE6_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1EE6->then_instructions;

                                       ir_expression *const r1EE8 = equal(body.constant(2097151u), r1E9A);
                                       ir_expression *const r1EE9 = equal(body.constant(4294967295u), r1E9B);
                                       body.emit(assign(r1EE5, logic_and(r1EE8, r1EE9), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1EE6->else_instructions;

                                       body.emit(assign(r1EE5, body.constant(false), 0x01));


                                    body.instructions = f1EE6_parent_instructions;
                                    body.emit(f1EE6);

                                    /* END IF */

                                    body.emit(assign(r1EE2, logic_and(r1EE5, r1EDE), 0x01));


                                 body.instructions = f1EE3_parent_instructions;
                                 body.emit(f1EE3);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f1EEA = new(mem_ctx) ir_if(operand(r1EE2).val);
                                 exec_list *const f1EEA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1EEA->then_instructions;

                                    ir_variable *const r1EEB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r1EEB);
                                    ir_expression *const r1EEC = lshift(r1B63, body.constant(int(31)));
                                    body.emit(assign(r1EEB, add(r1EEC, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r1EEB, body.constant(0u), 0x01));

                                    body.emit(assign(r1EDD, r1EEB, 0x03));

                                    body.emit(assign(r1EDC, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1EEA->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1EEE = less(r1E99, body.constant(int(0)));
                                    ir_if *f1EED = new(mem_ctx) ir_if(operand(r1EEE).val);
                                    exec_list *const f1EED_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1EED->then_instructions;

                                       ir_variable *const r1EEF = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r1EEF, r1E9C, 0x01));

                                       ir_variable *const r1EF0 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r1EF0, neg(r1E99), 0x01));

                                       ir_variable *const r1EF1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r1EF1);
                                       ir_variable *const r1EF2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r1EF2);
                                       ir_variable *const r1EF3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r1EF3);
                                       ir_variable *const r1EF4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r1EF5 = neg(r1EF0);
                                       body.emit(assign(r1EF4, bit_and(r1EF5, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1EF7 = equal(r1EF0, body.constant(int(0)));
                                       ir_if *f1EF6 = new(mem_ctx) ir_if(operand(r1EF7).val);
                                       exec_list *const f1EF6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1EF6->then_instructions;

                                          body.emit(assign(r1EF1, r1E9C, 0x01));

                                          body.emit(assign(r1EF2, r1E9B, 0x01));

                                          body.emit(assign(r1EF3, r1E9A, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1EF6->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r1EF9 = less(r1EF0, body.constant(int(32)));
                                          ir_if *f1EF8 = new(mem_ctx) ir_if(operand(r1EF9).val);
                                          exec_list *const f1EF8_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1EF8->then_instructions;

                                             body.emit(assign(r1EF1, lshift(r1E9B, r1EF4), 0x01));

                                             ir_expression *const r1EFA = lshift(r1E9A, r1EF4);
                                             ir_expression *const r1EFB = rshift(r1E9B, r1EF0);
                                             body.emit(assign(r1EF2, bit_or(r1EFA, r1EFB), 0x01));

                                             body.emit(assign(r1EF3, rshift(r1E9A, r1EF0), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1EF8->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r1EFD = equal(r1EF0, body.constant(int(32)));
                                             ir_if *f1EFC = new(mem_ctx) ir_if(operand(r1EFD).val);
                                             exec_list *const f1EFC_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1EFC->then_instructions;

                                                body.emit(assign(r1EF1, r1E9B, 0x01));

                                                body.emit(assign(r1EF2, r1E9A, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1EFC->else_instructions;

                                                body.emit(assign(r1EEF, bit_or(r1E9C, r1E9B), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r1EFF = less(r1EF0, body.constant(int(64)));
                                                ir_if *f1EFE = new(mem_ctx) ir_if(operand(r1EFF).val);
                                                exec_list *const f1EFE_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f1EFE->then_instructions;

                                                   body.emit(assign(r1EF1, lshift(r1E9A, r1EF4), 0x01));

                                                   ir_expression *const r1F00 = bit_and(r1EF0, body.constant(int(31)));
                                                   body.emit(assign(r1EF2, rshift(r1E9A, r1F00), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f1EFE->else_instructions;

                                                   ir_variable *const r1F01 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r1F03 = equal(r1EF0, body.constant(int(64)));
                                                   ir_if *f1F02 = new(mem_ctx) ir_if(operand(r1F03).val);
                                                   exec_list *const f1F02_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f1F02->then_instructions;

                                                      body.emit(assign(r1F01, r1E9A, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f1F02->else_instructions;

                                                      ir_expression *const r1F04 = nequal(r1E9A, body.constant(0u));
                                                      ir_expression *const r1F05 = expr(ir_unop_b2i, r1F04);
                                                      body.emit(assign(r1F01, expr(ir_unop_i2u, r1F05), 0x01));


                                                   body.instructions = f1F02_parent_instructions;
                                                   body.emit(f1F02);

                                                   /* END IF */

                                                   body.emit(assign(r1EF1, r1F01, 0x01));

                                                   body.emit(assign(r1EF2, body.constant(0u), 0x01));


                                                body.instructions = f1EFE_parent_instructions;
                                                body.emit(f1EFE);

                                                /* END IF */


                                             body.instructions = f1EFC_parent_instructions;
                                             body.emit(f1EFC);

                                             /* END IF */

                                             body.emit(assign(r1EF3, body.constant(0u), 0x01));


                                          body.instructions = f1EF8_parent_instructions;
                                          body.emit(f1EF8);

                                          /* END IF */

                                          ir_expression *const r1F06 = nequal(r1EEF, body.constant(0u));
                                          ir_expression *const r1F07 = expr(ir_unop_b2i, r1F06);
                                          ir_expression *const r1F08 = expr(ir_unop_i2u, r1F07);
                                          body.emit(assign(r1EF1, bit_or(r1EF1, r1F08), 0x01));


                                       body.instructions = f1EF6_parent_instructions;
                                       body.emit(f1EF6);

                                       /* END IF */

                                       body.emit(assign(r1ED9, r1EF3, 0x01));

                                       body.emit(assign(r1EDA, r1EF2, 0x01));

                                       body.emit(assign(r1EDB, r1EF1, 0x01));

                                       body.emit(assign(r1ED8, body.constant(int(0)), 0x01));

                                       body.emit(assign(r1EDE, less(r1EF1, body.constant(0u)), 0x01));


                                    body.instructions = f1EED_parent_instructions;
                                    body.emit(f1EED);

                                    /* END IF */


                                 body.instructions = f1EEA_parent_instructions;
                                 body.emit(f1EEA);

                                 /* END IF */


                              body.instructions = f1EE0_parent_instructions;
                              body.emit(f1EE0);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f1F09 = new(mem_ctx) ir_if(operand(r1EDC).val);
                              exec_list *const f1F09_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F09->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f1F0A = new(mem_ctx) ir_if(operand(r1EDE).val);
                                 exec_list *const f1F0A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1F0A->then_instructions;

                                    ir_variable *const r1F0B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r1F0B, add(r1EDA, body.constant(1u)), 0x01));

                                    ir_expression *const r1F0C = less(r1F0B, r1EDA);
                                    ir_expression *const r1F0D = expr(ir_unop_b2i, r1F0C);
                                    ir_expression *const r1F0E = expr(ir_unop_i2u, r1F0D);
                                    body.emit(assign(r1ED9, add(r1ED9, r1F0E), 0x01));

                                    ir_expression *const r1F0F = equal(r1EDB, body.constant(0u));
                                    ir_expression *const r1F10 = expr(ir_unop_b2i, r1F0F);
                                    ir_expression *const r1F11 = expr(ir_unop_i2u, r1F10);
                                    ir_expression *const r1F12 = add(r1EDB, r1F11);
                                    ir_expression *const r1F13 = bit_and(r1F12, body.constant(1u));
                                    ir_expression *const r1F14 = expr(ir_unop_bit_not, r1F13);
                                    body.emit(assign(r1EDA, bit_and(r1F0B, r1F14), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1F0A->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1F16 = bit_or(r1ED9, r1EDA);
                                    ir_expression *const r1F17 = equal(r1F16, body.constant(0u));
                                    ir_if *f1F15 = new(mem_ctx) ir_if(operand(r1F17).val);
                                    exec_list *const f1F15_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1F15->then_instructions;

                                       body.emit(assign(r1ED8, body.constant(int(0)), 0x01));


                                    body.instructions = f1F15_parent_instructions;
                                    body.emit(f1F15);

                                    /* END IF */


                                 body.instructions = f1F0A_parent_instructions;
                                 body.emit(f1F0A);

                                 /* END IF */

                                 ir_variable *const r1F18 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r1F18);
                                 ir_expression *const r1F19 = lshift(r1B63, body.constant(int(31)));
                                 ir_expression *const r1F1A = expr(ir_unop_i2u, r1ED8);
                                 ir_expression *const r1F1B = lshift(r1F1A, body.constant(int(20)));
                                 ir_expression *const r1F1C = add(r1F19, r1F1B);
                                 body.emit(assign(r1F18, add(r1F1C, r1ED9), 0x02));

                                 body.emit(assign(r1F18, r1EDA, 0x01));

                                 body.emit(assign(r1EDD, r1F18, 0x03));

                                 body.emit(assign(r1EDC, body.constant(false), 0x01));


                              body.instructions = f1F09_parent_instructions;
                              body.emit(f1F09);

                              /* END IF */

                              body.emit(assign(r1B64, r1EDD, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1E91->else_instructions;

                              ir_variable *const r1F1D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1F1D);
                              body.emit(assign(r1F1D, body.constant(0u), 0x02));

                              body.emit(assign(r1F1D, body.constant(0u), 0x01));

                              body.emit(assign(r1B64, r1F1D, 0x03));


                           body.instructions = f1E91_parent_instructions;
                           body.emit(f1E91);

                           /* END IF */


                        body.instructions = f1E05_parent_instructions;
                        body.emit(f1E05);

                        /* END IF */


                     body.instructions = f1D79_parent_instructions;
                     body.emit(f1D79);

                     /* END IF */


                  body.instructions = f1CED_parent_instructions;
                  body.emit(f1CED);

                  /* END IF */


               body.instructions = f1CD8_parent_instructions;
               body.emit(f1CD8);

               /* END IF */


            body.instructions = f1C29_parent_instructions;
            body.emit(f1C29);

            /* END IF */


         body.instructions = f1B78_parent_instructions;
         body.emit(f1B78);

         /* END IF */

         body.emit(assign(r1A06, r1B64, 0x03));


      body.instructions = f1A08_parent_instructions;
      body.emit(f1A08);

      /* END IF */

      body.emit(assign(r1A04, r1A06, 0x03));


   body.instructions = f1A05_parent_instructions;
   body.emit(f1A05);

   /* END IF */

   body.emit(ret(r1A04));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffract64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1F1E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1F1E);
   ir_variable *const r1F1F = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1F20 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1F21 = rshift(swizzle_y(r1F1E), body.constant(int(20)));
   ir_expression *const r1F22 = bit_and(r1F21, body.constant(2047u));
   ir_expression *const r1F23 = expr(ir_unop_u2i, r1F22);
   body.emit(assign(r1F20, add(r1F23, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1F25 = less(r1F20, body.constant(int(0)));
   ir_if *f1F24 = new(mem_ctx) ir_if(operand(r1F25).val);
   exec_list *const f1F24_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1F24->then_instructions;

      body.emit(assign(r1F1F, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1F24->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1F27 = greater(r1F20, body.constant(int(52)));
      ir_if *f1F26 = new(mem_ctx) ir_if(operand(r1F27).val);
      exec_list *const f1F26_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1F26->then_instructions;

         body.emit(assign(r1F1F, r1F1E, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1F26->else_instructions;

         ir_variable *const r1F28 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1F28, sub(body.constant(int(52)), r1F20), 0x01));

         ir_variable *const r1F29 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1F2B = gequal(r1F28, body.constant(int(32)));
         ir_if *f1F2A = new(mem_ctx) ir_if(operand(r1F2B).val);
         exec_list *const f1F2A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1F2A->then_instructions;

            body.emit(assign(r1F29, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1F2A->else_instructions;

            body.emit(assign(r1F29, lshift(body.constant(4294967295u), r1F28), 0x01));


         body.instructions = f1F2A_parent_instructions;
         body.emit(f1F2A);

         /* END IF */

         ir_variable *const r1F2C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1F2E = less(r1F28, body.constant(int(33)));
         ir_if *f1F2D = new(mem_ctx) ir_if(operand(r1F2E).val);
         exec_list *const f1F2D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1F2D->then_instructions;

            body.emit(assign(r1F2C, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1F2D->else_instructions;

            ir_expression *const r1F2F = add(r1F28, body.constant(int(-32)));
            body.emit(assign(r1F2C, lshift(body.constant(4294967295u), r1F2F), 0x01));


         body.instructions = f1F2D_parent_instructions;
         body.emit(f1F2D);

         /* END IF */

         ir_variable *const r1F30 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r1F30, bit_and(r1F29, swizzle_x(r1F1E)), 0x01));

         body.emit(assign(r1F30, bit_and(r1F2C, swizzle_y(r1F1E)), 0x02));

         body.emit(assign(r1F1F, r1F30, 0x03));


      body.instructions = f1F26_parent_instructions;
      body.emit(f1F26);

      /* END IF */


   body.instructions = f1F24_parent_instructions;
   body.emit(f1F24);

   /* END IF */

   ir_variable *const r1F31 = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r1F32 = rshift(swizzle_y(r1F1E), body.constant(int(31)));
   ir_expression *const r1F33 = expr(ir_unop_u2i, r1F32);
   body.emit(assign(r1F31, expr(ir_unop_i2b, r1F33), 0x01));

   ir_variable *const r1F34 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r1F36 = expr(ir_unop_logic_not, r1F31);
   ir_if *f1F35 = new(mem_ctx) ir_if(operand(r1F36).val);
   exec_list *const f1F35_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1F35->then_instructions;

      body.emit(assign(r1F34, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1F35->else_instructions;

      ir_variable *const r1F37 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r1F38 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r1F38);
      ir_variable *const r1F39 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r1F39);
      ir_expression *const r1F3A = rshift(swizzle_y(r1F1E), body.constant(int(20)));
      ir_expression *const r1F3B = bit_and(r1F3A, body.constant(2047u));
      ir_expression *const r1F3C = expr(ir_unop_u2i, r1F3B);
      ir_expression *const r1F3D = equal(r1F3C, body.constant(int(2047)));
      ir_expression *const r1F3E = bit_and(swizzle_y(r1F1E), body.constant(1048575u));
      ir_expression *const r1F3F = bit_or(r1F3E, swizzle_x(r1F1E));
      ir_expression *const r1F40 = nequal(r1F3F, body.constant(0u));
      body.emit(assign(r1F39, logic_and(r1F3D, r1F40), 0x01));

      ir_expression *const r1F41 = rshift(swizzle_y(r1F1F), body.constant(int(20)));
      ir_expression *const r1F42 = bit_and(r1F41, body.constant(2047u));
      ir_expression *const r1F43 = expr(ir_unop_u2i, r1F42);
      ir_expression *const r1F44 = equal(r1F43, body.constant(int(2047)));
      ir_expression *const r1F45 = bit_and(swizzle_y(r1F1F), body.constant(1048575u));
      ir_expression *const r1F46 = bit_or(r1F45, swizzle_x(r1F1F));
      ir_expression *const r1F47 = nequal(r1F46, body.constant(0u));
      body.emit(assign(r1F38, logic_and(r1F44, r1F47), 0x01));

      /* IF CONDITION */
      ir_expression *const r1F49 = logic_or(r1F39, r1F38);
      ir_if *f1F48 = new(mem_ctx) ir_if(operand(r1F49).val);
      exec_list *const f1F48_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1F48->then_instructions;

         body.emit(assign(r1F37, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1F48->else_instructions;

         ir_expression *const r1F4A = equal(swizzle_x(r1F1E), swizzle_x(r1F1F));
         ir_expression *const r1F4B = equal(swizzle_y(r1F1E), swizzle_y(r1F1F));
         ir_expression *const r1F4C = equal(swizzle_x(r1F1E), body.constant(0u));
         ir_expression *const r1F4D = bit_or(swizzle_y(r1F1E), swizzle_y(r1F1F));
         ir_expression *const r1F4E = lshift(r1F4D, body.constant(int(1)));
         ir_expression *const r1F4F = equal(r1F4E, body.constant(0u));
         ir_expression *const r1F50 = logic_and(r1F4C, r1F4F);
         ir_expression *const r1F51 = logic_or(r1F4B, r1F50);
         body.emit(assign(r1F37, logic_and(r1F4A, r1F51), 0x01));


      body.instructions = f1F48_parent_instructions;
      body.emit(f1F48);

      /* END IF */

      body.emit(assign(r1F34, r1F37, 0x01));


   body.instructions = f1F35_parent_instructions;
   body.emit(f1F35);

   /* END IF */

   ir_variable *const r1F52 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f1F53 = new(mem_ctx) ir_if(operand(r1F34).val);
   exec_list *const f1F53_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1F53->then_instructions;

      body.emit(assign(r1F52, r1F1F, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1F53->else_instructions;

      ir_variable *const r1F54 = body.make_temp(glsl_type::uvec2_type, "a");
      body.emit(assign(r1F54, body.constant(0u), 0x01));

      body.emit(assign(r1F54, body.constant(3220176896u), 0x02));

      ir_variable *const r1F55 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r1F56 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1F56, rshift(swizzle_y(r1F1F), body.constant(int(31))), 0x01));

      ir_variable *const r1F57 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1F57, body.constant(1u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1F59 = equal(r1F56, body.constant(1u));
      ir_if *f1F58 = new(mem_ctx) ir_if(operand(r1F59).val);
      exec_list *const f1F58_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1F58->then_instructions;

         ir_variable *const r1F5A = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r1F5A, body.constant(true), 0x01));

         ir_variable *const r1F5B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r1F5C = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r1F5C);
         ir_variable *const r1F5D = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r1F5D);
         ir_variable *const r1F5E = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r1F5E);
         ir_variable *const r1F5F = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r1F5F);
         ir_variable *const r1F60 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r1F60);
         ir_variable *const r1F61 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r1F61);
         ir_variable *const r1F62 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r1F62);
         ir_variable *const r1F63 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r1F63);
         body.emit(assign(r1F63, body.constant(0u), 0x01));

         body.emit(assign(r1F62, body.constant(0u), 0x01));

         ir_variable *const r1F64 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r1F64, swizzle_x(r1F1F), 0x01));

         body.emit(assign(r1F60, r1F64, 0x01));

         ir_variable *const r1F65 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r1F65, bit_and(swizzle_y(r1F1F), body.constant(1048575u)), 0x01));

         body.emit(assign(r1F5F, r1F65, 0x01));

         ir_variable *const r1F66 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r1F66, body.constant(0u), 0x01));

         body.emit(assign(r1F5E, r1F66, 0x01));

         ir_variable *const r1F67 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r1F67, body.constant(0u), 0x01));

         body.emit(assign(r1F5D, r1F67, 0x01));

         ir_variable *const r1F68 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r1F69 = rshift(swizzle_y(r1F1F), body.constant(int(20)));
         ir_expression *const r1F6A = bit_and(r1F69, body.constant(2047u));
         body.emit(assign(r1F68, expr(ir_unop_u2i, r1F6A), 0x01));

         ir_variable *const r1F6B = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r1F6B, body.constant(int(1023)), 0x01));

         ir_variable *const r1F6C = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1F6C, add(r1F68, body.constant(int(-1023))), 0x01));

         body.emit(assign(r1F5C, r1F6C, 0x01));

         /* IF CONDITION */
         ir_expression *const r1F6E = less(body.constant(int(0)), r1F6C);
         ir_if *f1F6D = new(mem_ctx) ir_if(operand(r1F6E).val);
         exec_list *const f1F6D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1F6D->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1F70 = equal(r1F68, body.constant(int(2047)));
            ir_if *f1F6F = new(mem_ctx) ir_if(operand(r1F70).val);
            exec_list *const f1F6F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1F6F->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1F72 = bit_or(r1F65, swizzle_x(r1F1F));
               ir_expression *const r1F73 = nequal(r1F72, body.constant(0u));
               ir_if *f1F71 = new(mem_ctx) ir_if(operand(r1F73).val);
               exec_list *const f1F71_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F71->then_instructions;

                  ir_variable *const r1F74 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1F74, swizzle_x(r1F1F), 0x01));

                  ir_variable *const r1F75 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1F75, body.constant(0u), 0x01));

                  ir_variable *const r1F76 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r1F77 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r1F78 = rshift(swizzle_y(r1F1F), body.constant(int(19)));
                  ir_expression *const r1F79 = bit_and(r1F78, body.constant(4095u));
                  ir_expression *const r1F7A = equal(r1F79, body.constant(4094u));
                  ir_expression *const r1F7B = nequal(swizzle_x(r1F1F), body.constant(0u));
                  ir_expression *const r1F7C = bit_and(swizzle_y(r1F1F), body.constant(524287u));
                  ir_expression *const r1F7D = nequal(r1F7C, body.constant(0u));
                  ir_expression *const r1F7E = logic_or(r1F7B, r1F7D);
                  body.emit(assign(r1F77, logic_and(r1F7A, r1F7E), 0x01));

                  ir_variable *const r1F7F = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  body.emit(assign(r1F7F, body.constant(false), 0x01));

                  body.emit(assign(r1F74, bit_or(swizzle_y(r1F1F), body.constant(524288u)), 0x02));

                  body.emit(assign(r1F75, body.constant(3220701184u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1F81 = lshift(swizzle_y(r1F1F), body.constant(int(1)));
                  ir_expression *const r1F82 = lequal(body.constant(4292870144u), r1F81);
                  ir_expression *const r1F83 = nequal(swizzle_x(r1F1F), body.constant(0u));
                  ir_expression *const r1F84 = bit_and(swizzle_y(r1F1F), body.constant(1048575u));
                  ir_expression *const r1F85 = nequal(r1F84, body.constant(0u));
                  ir_expression *const r1F86 = logic_or(r1F83, r1F85);
                  ir_expression *const r1F87 = logic_and(r1F82, r1F86);
                  ir_if *f1F80 = new(mem_ctx) ir_if(operand(r1F87).val);
                  exec_list *const f1F80_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F80->then_instructions;

                     ir_variable *const r1F88 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_constant *const r1F8A = body.constant(false);
                     ir_if *f1F89 = new(mem_ctx) ir_if(operand(r1F8A).val);
                     exec_list *const f1F89_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F89->then_instructions;

                        body.emit(assign(r1F88, r1F75, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1F89->else_instructions;

                        body.emit(assign(r1F88, r1F74, 0x03));


                     body.instructions = f1F89_parent_instructions;
                     body.emit(f1F89);

                     /* END IF */

                     body.emit(assign(r1F76, r1F88, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F80->else_instructions;

                     body.emit(assign(r1F76, r1F75, 0x03));


                  body.instructions = f1F80_parent_instructions;
                  body.emit(f1F80);

                  /* END IF */

                  body.emit(assign(r1F5B, r1F76, 0x03));

                  body.emit(assign(r1F5A, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F71->else_instructions;

                  body.emit(assign(r1F5B, r1F1F, 0x03));

                  body.emit(assign(r1F5A, body.constant(false), 0x01));


               body.instructions = f1F71_parent_instructions;
               body.emit(f1F71);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1F6F->else_instructions;

               /* IF CONDITION */
               ir_constant *const r1F8C = body.constant(false);
               ir_if *f1F8B = new(mem_ctx) ir_if(operand(r1F8C).val);
               exec_list *const f1F8B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F8B->then_instructions;

                  body.emit(assign(r1F5C, add(r1F6C, body.constant(int(-1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F8B->else_instructions;

                  body.emit(assign(r1F5D, body.constant(1048576u), 0x01));


               body.instructions = f1F8B_parent_instructions;
               body.emit(f1F8B);

               /* END IF */

               ir_variable *const r1F8D = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r1F8D, body.constant(0u), 0x01));

               ir_variable *const r1F8E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r1F8E);
               ir_variable *const r1F8F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1F8F);
               ir_variable *const r1F90 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1F90);
               ir_variable *const r1F91 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1F92 = neg(r1F5C);
               body.emit(assign(r1F91, bit_and(r1F92, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1F94 = equal(r1F5C, body.constant(int(0)));
               ir_if *f1F93 = new(mem_ctx) ir_if(operand(r1F94).val);
               exec_list *const f1F93_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F93->then_instructions;

                  body.emit(assign(r1F8E, r1F8D, 0x01));

                  body.emit(assign(r1F8F, r1F66, 0x01));

                  body.emit(assign(r1F90, r1F5D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F93->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1F96 = less(r1F5C, body.constant(int(32)));
                  ir_if *f1F95 = new(mem_ctx) ir_if(operand(r1F96).val);
                  exec_list *const f1F95_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F95->then_instructions;

                     body.emit(assign(r1F8E, body.constant(0u), 0x01));

                     ir_expression *const r1F97 = lshift(r1F5D, r1F91);
                     body.emit(assign(r1F8F, bit_or(r1F97, body.constant(0u)), 0x01));

                     body.emit(assign(r1F90, rshift(r1F5D, r1F5C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F95->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1F99 = equal(r1F5C, body.constant(int(32)));
                     ir_if *f1F98 = new(mem_ctx) ir_if(operand(r1F99).val);
                     exec_list *const f1F98_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F98->then_instructions;

                        body.emit(assign(r1F8E, r1F66, 0x01));

                        body.emit(assign(r1F8F, r1F5D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1F98->else_instructions;

                        body.emit(assign(r1F8D, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1F9B = less(r1F5C, body.constant(int(64)));
                        ir_if *f1F9A = new(mem_ctx) ir_if(operand(r1F9B).val);
                        exec_list *const f1F9A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F9A->then_instructions;

                           body.emit(assign(r1F8E, lshift(r1F5D, r1F91), 0x01));

                           ir_expression *const r1F9C = bit_and(r1F5C, body.constant(int(31)));
                           body.emit(assign(r1F8F, rshift(r1F5D, r1F9C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1F9A->else_instructions;

                           ir_variable *const r1F9D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1F9F = equal(r1F5C, body.constant(int(64)));
                           ir_if *f1F9E = new(mem_ctx) ir_if(operand(r1F9F).val);
                           exec_list *const f1F9E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F9E->then_instructions;

                              body.emit(assign(r1F9D, r1F5D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F9E->else_instructions;

                              ir_expression *const r1FA0 = nequal(r1F5D, body.constant(0u));
                              ir_expression *const r1FA1 = expr(ir_unop_b2i, r1FA0);
                              body.emit(assign(r1F9D, expr(ir_unop_i2u, r1FA1), 0x01));


                           body.instructions = f1F9E_parent_instructions;
                           body.emit(f1F9E);

                           /* END IF */

                           body.emit(assign(r1F8E, r1F9D, 0x01));

                           body.emit(assign(r1F8F, body.constant(0u), 0x01));


                        body.instructions = f1F9A_parent_instructions;
                        body.emit(f1F9A);

                        /* END IF */


                     body.instructions = f1F98_parent_instructions;
                     body.emit(f1F98);

                     /* END IF */

                     body.emit(assign(r1F90, body.constant(0u), 0x01));


                  body.instructions = f1F95_parent_instructions;
                  body.emit(f1F95);

                  /* END IF */

                  ir_expression *const r1FA2 = nequal(r1F8D, body.constant(0u));
                  ir_expression *const r1FA3 = expr(ir_unop_b2i, r1FA2);
                  ir_expression *const r1FA4 = expr(ir_unop_i2u, r1FA3);
                  body.emit(assign(r1F8E, bit_or(r1F8E, r1FA4), 0x01));


               body.instructions = f1F93_parent_instructions;
               body.emit(f1F93);

               /* END IF */

               body.emit(assign(r1F5D, r1F90, 0x01));

               body.emit(assign(r1F5E, r1F8F, 0x01));

               body.emit(assign(r1F62, r1F8E, 0x01));

               body.emit(assign(r1F61, r1F68, 0x01));


            body.instructions = f1F6F_parent_instructions;
            body.emit(f1F6F);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1F6D->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1FA6 = less(r1F5C, body.constant(int(0)));
            ir_if *f1FA5 = new(mem_ctx) ir_if(operand(r1FA6).val);
            exec_list *const f1FA5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1FA5->then_instructions;

               /* IF CONDITION */
               ir_constant *const r1FA8 = body.constant(false);
               ir_if *f1FA7 = new(mem_ctx) ir_if(operand(r1FA8).val);
               exec_list *const f1FA7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1FA7->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1FAA = bit_or(r1F5D, r1F5E);
                  ir_expression *const r1FAB = nequal(r1FAA, body.constant(0u));
                  ir_if *f1FA9 = new(mem_ctx) ir_if(operand(r1FAB).val);
                  exec_list *const f1FA9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FA9->then_instructions;

                     ir_variable *const r1FAC = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1FAC, swizzle_x(r1F1F), 0x01));

                     ir_variable *const r1FAD = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1FAD, body.constant(0u), 0x01));

                     ir_variable *const r1FAE = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1FAF = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r1FB0 = rshift(swizzle_y(r1F1F), body.constant(int(19)));
                     ir_expression *const r1FB1 = bit_and(r1FB0, body.constant(4095u));
                     ir_expression *const r1FB2 = equal(r1FB1, body.constant(4094u));
                     ir_expression *const r1FB3 = nequal(swizzle_x(r1F1F), body.constant(0u));
                     ir_expression *const r1FB4 = bit_and(swizzle_y(r1F1F), body.constant(524287u));
                     ir_expression *const r1FB5 = nequal(r1FB4, body.constant(0u));
                     ir_expression *const r1FB6 = logic_or(r1FB3, r1FB5);
                     body.emit(assign(r1FAF, logic_and(r1FB2, r1FB6), 0x01));

                     ir_variable *const r1FB7 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r1FB7, body.constant(false), 0x01));

                     body.emit(assign(r1FAC, bit_or(swizzle_y(r1F1F), body.constant(524288u)), 0x02));

                     body.emit(assign(r1FAD, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1FB9 = lshift(swizzle_y(r1F1F), body.constant(int(1)));
                     ir_expression *const r1FBA = lequal(body.constant(4292870144u), r1FB9);
                     ir_expression *const r1FBB = nequal(swizzle_x(r1F1F), body.constant(0u));
                     ir_expression *const r1FBC = bit_and(swizzle_y(r1F1F), body.constant(1048575u));
                     ir_expression *const r1FBD = nequal(r1FBC, body.constant(0u));
                     ir_expression *const r1FBE = logic_or(r1FBB, r1FBD);
                     ir_expression *const r1FBF = logic_and(r1FBA, r1FBE);
                     ir_if *f1FB8 = new(mem_ctx) ir_if(operand(r1FBF).val);
                     exec_list *const f1FB8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FB8->then_instructions;

                        ir_variable *const r1FC0 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r1FC2 = body.constant(false);
                        ir_if *f1FC1 = new(mem_ctx) ir_if(operand(r1FC2).val);
                        exec_list *const f1FC1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FC1->then_instructions;

                           body.emit(assign(r1FC0, r1FAD, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1FC1->else_instructions;

                           body.emit(assign(r1FC0, r1FAC, 0x03));


                        body.instructions = f1FC1_parent_instructions;
                        body.emit(f1FC1);

                        /* END IF */

                        body.emit(assign(r1FAE, r1FC0, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1FB8->else_instructions;

                        body.emit(assign(r1FAE, r1FAD, 0x03));


                     body.instructions = f1FB8_parent_instructions;
                     body.emit(f1FB8);

                     /* END IF */

                     body.emit(assign(r1F5B, r1FAE, 0x03));

                     body.emit(assign(r1F5A, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1FA9->else_instructions;

                     ir_variable *const r1FC3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1FC3);
                     ir_expression *const r1FC4 = lshift(r1F56, body.constant(int(31)));
                     body.emit(assign(r1FC3, add(r1FC4, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1FC3, body.constant(0u), 0x01));

                     body.emit(assign(r1F5B, r1FC3, 0x03));

                     body.emit(assign(r1F5A, body.constant(false), 0x01));


                  body.instructions = f1FA9_parent_instructions;
                  body.emit(f1FA9);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1FA7->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1FC6 = equal(r1F68, body.constant(int(0)));
                  ir_if *f1FC5 = new(mem_ctx) ir_if(operand(r1FC6).val);
                  exec_list *const f1FC5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FC5->then_instructions;

                     body.emit(assign(r1F5C, add(r1F5C, body.constant(int(1))), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1FC5->else_instructions;

                     body.emit(assign(r1F5F, bit_or(r1F65, body.constant(1048576u)), 0x01));


                  body.instructions = f1FC5_parent_instructions;
                  body.emit(f1FC5);

                  /* END IF */

                  ir_variable *const r1FC7 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1FC7, body.constant(0u), 0x01));

                  ir_variable *const r1FC8 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1FC8, neg(r1F5C), 0x01));

                  ir_variable *const r1FC9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1FC9);
                  ir_variable *const r1FCA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1FCA);
                  ir_variable *const r1FCB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1FCB);
                  ir_variable *const r1FCC = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1FCD = neg(r1FC8);
                  body.emit(assign(r1FCC, bit_and(r1FCD, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1FCF = equal(r1FC8, body.constant(int(0)));
                  ir_if *f1FCE = new(mem_ctx) ir_if(operand(r1FCF).val);
                  exec_list *const f1FCE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FCE->then_instructions;

                     body.emit(assign(r1FC9, r1FC7, 0x01));

                     body.emit(assign(r1FCA, r1F64, 0x01));

                     body.emit(assign(r1FCB, r1F5F, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1FCE->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1FD1 = less(r1FC8, body.constant(int(32)));
                     ir_if *f1FD0 = new(mem_ctx) ir_if(operand(r1FD1).val);
                     exec_list *const f1FD0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FD0->then_instructions;

                        body.emit(assign(r1FC9, lshift(swizzle_x(r1F1F), r1FCC), 0x01));

                        ir_expression *const r1FD2 = lshift(r1F5F, r1FCC);
                        ir_expression *const r1FD3 = rshift(swizzle_x(r1F1F), r1FC8);
                        body.emit(assign(r1FCA, bit_or(r1FD2, r1FD3), 0x01));

                        body.emit(assign(r1FCB, rshift(r1F5F, r1FC8), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1FD0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1FD5 = equal(r1FC8, body.constant(int(32)));
                        ir_if *f1FD4 = new(mem_ctx) ir_if(operand(r1FD5).val);
                        exec_list *const f1FD4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FD4->then_instructions;

                           body.emit(assign(r1FC9, r1F64, 0x01));

                           body.emit(assign(r1FCA, r1F5F, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1FD4->else_instructions;

                           body.emit(assign(r1FC7, bit_or(body.constant(0u), swizzle_x(r1F1F)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1FD7 = less(r1FC8, body.constant(int(64)));
                           ir_if *f1FD6 = new(mem_ctx) ir_if(operand(r1FD7).val);
                           exec_list *const f1FD6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1FD6->then_instructions;

                              body.emit(assign(r1FC9, lshift(r1F5F, r1FCC), 0x01));

                              ir_expression *const r1FD8 = bit_and(r1FC8, body.constant(int(31)));
                              body.emit(assign(r1FCA, rshift(r1F5F, r1FD8), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1FD6->else_instructions;

                              ir_variable *const r1FD9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1FDB = equal(r1FC8, body.constant(int(64)));
                              ir_if *f1FDA = new(mem_ctx) ir_if(operand(r1FDB).val);
                              exec_list *const f1FDA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FDA->then_instructions;

                                 body.emit(assign(r1FD9, r1F5F, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FDA->else_instructions;

                                 ir_expression *const r1FDC = nequal(r1F5F, body.constant(0u));
                                 ir_expression *const r1FDD = expr(ir_unop_b2i, r1FDC);
                                 body.emit(assign(r1FD9, expr(ir_unop_i2u, r1FDD), 0x01));


                              body.instructions = f1FDA_parent_instructions;
                              body.emit(f1FDA);

                              /* END IF */

                              body.emit(assign(r1FC9, r1FD9, 0x01));

                              body.emit(assign(r1FCA, body.constant(0u), 0x01));


                           body.instructions = f1FD6_parent_instructions;
                           body.emit(f1FD6);

                           /* END IF */


                        body.instructions = f1FD4_parent_instructions;
                        body.emit(f1FD4);

                        /* END IF */

                        body.emit(assign(r1FCB, body.constant(0u), 0x01));


                     body.instructions = f1FD0_parent_instructions;
                     body.emit(f1FD0);

                     /* END IF */

                     ir_expression *const r1FDE = nequal(r1FC7, body.constant(0u));
                     ir_expression *const r1FDF = expr(ir_unop_b2i, r1FDE);
                     ir_expression *const r1FE0 = expr(ir_unop_i2u, r1FDF);
                     body.emit(assign(r1FC9, bit_or(r1FC9, r1FE0), 0x01));


                  body.instructions = f1FCE_parent_instructions;
                  body.emit(f1FCE);

                  /* END IF */

                  body.emit(assign(r1F5F, r1FCB, 0x01));

                  body.emit(assign(r1F60, r1FCA, 0x01));

                  body.emit(assign(r1F62, r1FC9, 0x01));

                  body.emit(assign(r1F61, r1F6B, 0x01));


               body.instructions = f1FA7_parent_instructions;
               body.emit(f1FA7);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1FA5->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1FE2 = equal(r1F68, body.constant(int(2047)));
               ir_if *f1FE1 = new(mem_ctx) ir_if(operand(r1FE2).val);
               exec_list *const f1FE1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1FE1->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1FE4 = bit_or(r1F5F, r1F60);
                  ir_expression *const r1FE5 = bit_or(r1F5D, r1F5E);
                  ir_expression *const r1FE6 = bit_or(r1FE4, r1FE5);
                  ir_expression *const r1FE7 = nequal(r1FE6, body.constant(0u));
                  ir_if *f1FE3 = new(mem_ctx) ir_if(operand(r1FE7).val);
                  exec_list *const f1FE3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FE3->then_instructions;

                     ir_variable *const r1FE8 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1FE8, swizzle_x(r1F1F), 0x01));

                     ir_variable *const r1FE9 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1FE9, body.constant(0u), 0x01));

                     ir_variable *const r1FEA = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1FEB = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r1FEC = rshift(swizzle_y(r1F1F), body.constant(int(19)));
                     ir_expression *const r1FED = bit_and(r1FEC, body.constant(4095u));
                     ir_expression *const r1FEE = equal(r1FED, body.constant(4094u));
                     ir_expression *const r1FEF = nequal(swizzle_x(r1F1F), body.constant(0u));
                     ir_expression *const r1FF0 = bit_and(swizzle_y(r1F1F), body.constant(524287u));
                     ir_expression *const r1FF1 = nequal(r1FF0, body.constant(0u));
                     ir_expression *const r1FF2 = logic_or(r1FEF, r1FF1);
                     body.emit(assign(r1FEB, logic_and(r1FEE, r1FF2), 0x01));

                     ir_variable *const r1FF3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r1FF3, body.constant(false), 0x01));

                     body.emit(assign(r1FE8, bit_or(swizzle_y(r1F1F), body.constant(524288u)), 0x02));

                     body.emit(assign(r1FE9, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1FF5 = lshift(swizzle_y(r1F1F), body.constant(int(1)));
                     ir_expression *const r1FF6 = lequal(body.constant(4292870144u), r1FF5);
                     ir_expression *const r1FF7 = nequal(swizzle_x(r1F1F), body.constant(0u));
                     ir_expression *const r1FF8 = bit_and(swizzle_y(r1F1F), body.constant(1048575u));
                     ir_expression *const r1FF9 = nequal(r1FF8, body.constant(0u));
                     ir_expression *const r1FFA = logic_or(r1FF7, r1FF9);
                     ir_expression *const r1FFB = logic_and(r1FF6, r1FFA);
                     ir_if *f1FF4 = new(mem_ctx) ir_if(operand(r1FFB).val);
                     exec_list *const f1FF4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FF4->then_instructions;

                        ir_variable *const r1FFC = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r1FFE = body.constant(false);
                        ir_if *f1FFD = new(mem_ctx) ir_if(operand(r1FFE).val);
                        exec_list *const f1FFD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FFD->then_instructions;

                           body.emit(assign(r1FFC, r1FE9, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1FFD->else_instructions;

                           body.emit(assign(r1FFC, r1FE8, 0x03));


                        body.instructions = f1FFD_parent_instructions;
                        body.emit(f1FFD);

                        /* END IF */

                        body.emit(assign(r1FEA, r1FFC, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1FF4->else_instructions;

                        body.emit(assign(r1FEA, r1FE9, 0x03));


                     body.instructions = f1FF4_parent_instructions;
                     body.emit(f1FF4);

                     /* END IF */

                     body.emit(assign(r1F5B, r1FEA, 0x03));

                     body.emit(assign(r1F5A, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1FE3->else_instructions;

                     body.emit(assign(r1F5B, r1F1F, 0x03));

                     body.emit(assign(r1F5A, body.constant(false), 0x01));


                  body.instructions = f1FE3_parent_instructions;
                  body.emit(f1FE3);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1FE1->else_instructions;

                  ir_variable *const r1FFF = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r2000 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2000, add(r1F60, r1F5E), 0x01));

                  ir_expression *const r2001 = add(r1F5F, r1F5D);
                  ir_expression *const r2002 = less(r2000, r1F60);
                  ir_expression *const r2003 = expr(ir_unop_b2i, r2002);
                  ir_expression *const r2004 = expr(ir_unop_i2u, r2003);
                  body.emit(assign(r1FFF, add(r2001, r2004), 0x01));

                  body.emit(assign(r1F63, r1FFF, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2006 = equal(r1F68, body.constant(int(0)));
                  ir_if *f2005 = new(mem_ctx) ir_if(operand(r2006).val);
                  exec_list *const f2005_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2005->then_instructions;

                     ir_variable *const r2007 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2007);
                     ir_expression *const r2008 = lshift(r1F56, body.constant(int(31)));
                     body.emit(assign(r2007, add(r2008, r1FFF), 0x02));

                     body.emit(assign(r2007, r2000, 0x01));

                     body.emit(assign(r1F5B, r2007, 0x03));

                     body.emit(assign(r1F5A, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2005->else_instructions;

                     body.emit(assign(r1F63, bit_or(r1FFF, body.constant(2097152u)), 0x01));

                     body.emit(assign(r1F61, r1F68, 0x01));

                     ir_variable *const r2009 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2009);
                     ir_variable *const r200A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r200A);
                     ir_variable *const r200B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r200B);
                     body.emit(assign(r2009, lshift(r2000, body.constant(int(31))), 0x01));

                     ir_expression *const r200C = lshift(r1F63, body.constant(int(31)));
                     ir_expression *const r200D = rshift(r2000, body.constant(int(1)));
                     body.emit(assign(r200A, bit_or(r200C, r200D), 0x01));

                     body.emit(assign(r200B, rshift(r1F63, body.constant(int(1))), 0x01));

                     body.emit(assign(r2009, bit_or(r2009, body.constant(0u)), 0x01));

                     body.emit(assign(r1F63, r200B, 0x01));

                     body.emit(assign(r1F62, r2009, 0x01));

                     ir_variable *const r200E = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r200E, r1F68, 0x01));

                     ir_variable *const r200F = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r200F, r200B, 0x01));

                     ir_variable *const r2010 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2010, r200A, 0x01));

                     ir_variable *const r2011 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2011, r2009, 0x01));

                     ir_variable *const r2012 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2012, body.constant(true), 0x01));

                     ir_variable *const r2013 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2014 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2014);
                     ir_expression *const r2015 = expr(ir_unop_u2i, r2009);
                     body.emit(assign(r2014, less(r2015, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2017 = lequal(body.constant(int(2045)), r1F68);
                     ir_if *f2016 = new(mem_ctx) ir_if(operand(r2017).val);
                     exec_list *const f2016_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2016->then_instructions;

                        ir_variable *const r2018 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r201A = less(body.constant(int(2045)), r1F68);
                        ir_if *f2019 = new(mem_ctx) ir_if(operand(r201A).val);
                        exec_list *const f2019_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2019->then_instructions;

                           body.emit(assign(r2018, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2019->else_instructions;

                           ir_variable *const r201B = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r201D = equal(r1F68, body.constant(int(2045)));
                           ir_if *f201C = new(mem_ctx) ir_if(operand(r201D).val);
                           exec_list *const f201C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f201C->then_instructions;

                              ir_expression *const r201E = equal(body.constant(2097151u), r200B);
                              ir_expression *const r201F = equal(body.constant(4294967295u), r200A);
                              body.emit(assign(r201B, logic_and(r201E, r201F), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f201C->else_instructions;

                              body.emit(assign(r201B, body.constant(false), 0x01));


                           body.instructions = f201C_parent_instructions;
                           body.emit(f201C);

                           /* END IF */

                           body.emit(assign(r2018, logic_and(r201B, r2014), 0x01));


                        body.instructions = f2019_parent_instructions;
                        body.emit(f2019);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2020 = new(mem_ctx) ir_if(operand(r2018).val);
                        exec_list *const f2020_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2020->then_instructions;

                           ir_variable *const r2021 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2021);
                           ir_expression *const r2022 = lshift(r1F56, body.constant(int(31)));
                           body.emit(assign(r2021, add(r2022, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2021, body.constant(0u), 0x01));

                           body.emit(assign(r2013, r2021, 0x03));

                           body.emit(assign(r2012, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2020->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2024 = less(r1F68, body.constant(int(0)));
                           ir_if *f2023 = new(mem_ctx) ir_if(operand(r2024).val);
                           exec_list *const f2023_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2023->then_instructions;

                              ir_variable *const r2025 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2025, r2009, 0x01));

                              ir_variable *const r2026 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2026, neg(r1F68), 0x01));

                              ir_variable *const r2027 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2027);
                              ir_variable *const r2028 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2028);
                              ir_variable *const r2029 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2029);
                              ir_variable *const r202A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r202B = neg(r2026);
                              body.emit(assign(r202A, bit_and(r202B, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r202D = equal(r2026, body.constant(int(0)));
                              ir_if *f202C = new(mem_ctx) ir_if(operand(r202D).val);
                              exec_list *const f202C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f202C->then_instructions;

                                 body.emit(assign(r2027, r2009, 0x01));

                                 body.emit(assign(r2028, r200A, 0x01));

                                 body.emit(assign(r2029, r200B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f202C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r202F = less(r2026, body.constant(int(32)));
                                 ir_if *f202E = new(mem_ctx) ir_if(operand(r202F).val);
                                 exec_list *const f202E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f202E->then_instructions;

                                    body.emit(assign(r2027, lshift(r200A, r202A), 0x01));

                                    ir_expression *const r2030 = lshift(r200B, r202A);
                                    ir_expression *const r2031 = rshift(r200A, r2026);
                                    body.emit(assign(r2028, bit_or(r2030, r2031), 0x01));

                                    body.emit(assign(r2029, rshift(r200B, r2026), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f202E->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2033 = equal(r2026, body.constant(int(32)));
                                    ir_if *f2032 = new(mem_ctx) ir_if(operand(r2033).val);
                                    exec_list *const f2032_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2032->then_instructions;

                                       body.emit(assign(r2027, r200A, 0x01));

                                       body.emit(assign(r2028, r200B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2032->else_instructions;

                                       body.emit(assign(r2025, bit_or(r2009, r200A), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2035 = less(r2026, body.constant(int(64)));
                                       ir_if *f2034 = new(mem_ctx) ir_if(operand(r2035).val);
                                       exec_list *const f2034_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2034->then_instructions;

                                          body.emit(assign(r2027, lshift(r200B, r202A), 0x01));

                                          ir_expression *const r2036 = bit_and(r2026, body.constant(int(31)));
                                          body.emit(assign(r2028, rshift(r200B, r2036), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2034->else_instructions;

                                          ir_variable *const r2037 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2039 = equal(r2026, body.constant(int(64)));
                                          ir_if *f2038 = new(mem_ctx) ir_if(operand(r2039).val);
                                          exec_list *const f2038_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2038->then_instructions;

                                             body.emit(assign(r2037, r200B, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2038->else_instructions;

                                             ir_expression *const r203A = nequal(r200B, body.constant(0u));
                                             ir_expression *const r203B = expr(ir_unop_b2i, r203A);
                                             body.emit(assign(r2037, expr(ir_unop_i2u, r203B), 0x01));


                                          body.instructions = f2038_parent_instructions;
                                          body.emit(f2038);

                                          /* END IF */

                                          body.emit(assign(r2027, r2037, 0x01));

                                          body.emit(assign(r2028, body.constant(0u), 0x01));


                                       body.instructions = f2034_parent_instructions;
                                       body.emit(f2034);

                                       /* END IF */


                                    body.instructions = f2032_parent_instructions;
                                    body.emit(f2032);

                                    /* END IF */

                                    body.emit(assign(r2029, body.constant(0u), 0x01));


                                 body.instructions = f202E_parent_instructions;
                                 body.emit(f202E);

                                 /* END IF */

                                 ir_expression *const r203C = nequal(r2025, body.constant(0u));
                                 ir_expression *const r203D = expr(ir_unop_b2i, r203C);
                                 ir_expression *const r203E = expr(ir_unop_i2u, r203D);
                                 body.emit(assign(r2027, bit_or(r2027, r203E), 0x01));


                              body.instructions = f202C_parent_instructions;
                              body.emit(f202C);

                              /* END IF */

                              body.emit(assign(r200F, r2029, 0x01));

                              body.emit(assign(r2010, r2028, 0x01));

                              body.emit(assign(r2011, r2027, 0x01));

                              body.emit(assign(r200E, body.constant(int(0)), 0x01));

                              body.emit(assign(r2014, less(r2027, body.constant(0u)), 0x01));


                           body.instructions = f2023_parent_instructions;
                           body.emit(f2023);

                           /* END IF */


                        body.instructions = f2020_parent_instructions;
                        body.emit(f2020);

                        /* END IF */


                     body.instructions = f2016_parent_instructions;
                     body.emit(f2016);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f203F = new(mem_ctx) ir_if(operand(r2012).val);
                     exec_list *const f203F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f203F->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2040 = new(mem_ctx) ir_if(operand(r2014).val);
                        exec_list *const f2040_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2040->then_instructions;

                           ir_variable *const r2041 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2041, add(r2010, body.constant(1u)), 0x01));

                           ir_expression *const r2042 = less(r2041, r2010);
                           ir_expression *const r2043 = expr(ir_unop_b2i, r2042);
                           ir_expression *const r2044 = expr(ir_unop_i2u, r2043);
                           body.emit(assign(r200F, add(r200F, r2044), 0x01));

                           ir_expression *const r2045 = equal(r2011, body.constant(0u));
                           ir_expression *const r2046 = expr(ir_unop_b2i, r2045);
                           ir_expression *const r2047 = expr(ir_unop_i2u, r2046);
                           ir_expression *const r2048 = add(r2011, r2047);
                           ir_expression *const r2049 = bit_and(r2048, body.constant(1u));
                           ir_expression *const r204A = expr(ir_unop_bit_not, r2049);
                           body.emit(assign(r2010, bit_and(r2041, r204A), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2040->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r204C = bit_or(r200F, r2010);
                           ir_expression *const r204D = equal(r204C, body.constant(0u));
                           ir_if *f204B = new(mem_ctx) ir_if(operand(r204D).val);
                           exec_list *const f204B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f204B->then_instructions;

                              body.emit(assign(r200E, body.constant(int(0)), 0x01));


                           body.instructions = f204B_parent_instructions;
                           body.emit(f204B);

                           /* END IF */


                        body.instructions = f2040_parent_instructions;
                        body.emit(f2040);

                        /* END IF */

                        ir_variable *const r204E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r204E);
                        ir_expression *const r204F = lshift(r1F56, body.constant(int(31)));
                        ir_expression *const r2050 = expr(ir_unop_i2u, r200E);
                        ir_expression *const r2051 = lshift(r2050, body.constant(int(20)));
                        ir_expression *const r2052 = add(r204F, r2051);
                        body.emit(assign(r204E, add(r2052, r200F), 0x02));

                        body.emit(assign(r204E, r2010, 0x01));

                        body.emit(assign(r2013, r204E, 0x03));

                        body.emit(assign(r2012, body.constant(false), 0x01));


                     body.instructions = f203F_parent_instructions;
                     body.emit(f203F);

                     /* END IF */

                     body.emit(assign(r1F5B, r2013, 0x03));

                     body.emit(assign(r1F5A, body.constant(false), 0x01));


                  body.instructions = f2005_parent_instructions;
                  body.emit(f2005);

                  /* END IF */


               body.instructions = f1FE1_parent_instructions;
               body.emit(f1FE1);

               /* END IF */


            body.instructions = f1FA5_parent_instructions;
            body.emit(f1FA5);

            /* END IF */


         body.instructions = f1F6D_parent_instructions;
         body.emit(f1F6D);

         /* END IF */

         /* IF CONDITION */
         ir_if *f2053 = new(mem_ctx) ir_if(operand(r1F5A).val);
         exec_list *const f2053_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2053->then_instructions;

            body.emit(assign(r1F5F, bit_or(r1F5F, body.constant(1048576u)), 0x01));

            ir_variable *const r2054 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2055 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r2055, add(r1F60, r1F5E), 0x01));

            ir_expression *const r2056 = add(r1F5F, r1F5D);
            ir_expression *const r2057 = less(r2055, r1F60);
            ir_expression *const r2058 = expr(ir_unop_b2i, r2057);
            ir_expression *const r2059 = expr(ir_unop_i2u, r2058);
            body.emit(assign(r2054, add(r2056, r2059), 0x01));

            body.emit(assign(r1F63, r2054, 0x01));

            body.emit(assign(r1F61, add(r1F61, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r205B = less(r2054, body.constant(2097152u));
            ir_if *f205A = new(mem_ctx) ir_if(operand(r205B).val);
            exec_list *const f205A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f205A->then_instructions;

               ir_variable *const r205C = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r205C, r1F61, 0x01));

               ir_variable *const r205D = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r205D, r2054, 0x01));

               ir_variable *const r205E = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r205E, r2055, 0x01));

               ir_variable *const r205F = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r205F, r1F62, 0x01));

               ir_variable *const r2060 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2060, body.constant(true), 0x01));

               ir_variable *const r2061 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2062 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2062);
               ir_expression *const r2063 = expr(ir_unop_u2i, r1F62);
               body.emit(assign(r2062, less(r2063, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2065 = lequal(body.constant(int(2045)), r1F61);
               ir_if *f2064 = new(mem_ctx) ir_if(operand(r2065).val);
               exec_list *const f2064_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2064->then_instructions;

                  ir_variable *const r2066 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2068 = less(body.constant(int(2045)), r1F61);
                  ir_if *f2067 = new(mem_ctx) ir_if(operand(r2068).val);
                  exec_list *const f2067_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2067->then_instructions;

                     body.emit(assign(r2066, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2067->else_instructions;

                     ir_variable *const r2069 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r206B = equal(r1F61, body.constant(int(2045)));
                     ir_if *f206A = new(mem_ctx) ir_if(operand(r206B).val);
                     exec_list *const f206A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f206A->then_instructions;

                        ir_expression *const r206C = equal(body.constant(2097151u), r2054);
                        ir_expression *const r206D = equal(body.constant(4294967295u), r2055);
                        body.emit(assign(r2069, logic_and(r206C, r206D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f206A->else_instructions;

                        body.emit(assign(r2069, body.constant(false), 0x01));


                     body.instructions = f206A_parent_instructions;
                     body.emit(f206A);

                     /* END IF */

                     body.emit(assign(r2066, logic_and(r2069, r2062), 0x01));


                  body.instructions = f2067_parent_instructions;
                  body.emit(f2067);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f206E = new(mem_ctx) ir_if(operand(r2066).val);
                  exec_list *const f206E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f206E->then_instructions;

                     ir_variable *const r206F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r206F);
                     ir_expression *const r2070 = lshift(r1F56, body.constant(int(31)));
                     body.emit(assign(r206F, add(r2070, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r206F, body.constant(0u), 0x01));

                     body.emit(assign(r2061, r206F, 0x03));

                     body.emit(assign(r2060, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f206E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2072 = less(r1F61, body.constant(int(0)));
                     ir_if *f2071 = new(mem_ctx) ir_if(operand(r2072).val);
                     exec_list *const f2071_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2071->then_instructions;

                        ir_variable *const r2073 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2073, r1F62, 0x01));

                        ir_variable *const r2074 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2074, neg(r1F61), 0x01));

                        ir_variable *const r2075 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2075);
                        ir_variable *const r2076 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2076);
                        ir_variable *const r2077 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2077);
                        ir_variable *const r2078 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2079 = neg(r2074);
                        body.emit(assign(r2078, bit_and(r2079, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r207B = equal(r2074, body.constant(int(0)));
                        ir_if *f207A = new(mem_ctx) ir_if(operand(r207B).val);
                        exec_list *const f207A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f207A->then_instructions;

                           body.emit(assign(r2075, r1F62, 0x01));

                           body.emit(assign(r2076, r2055, 0x01));

                           body.emit(assign(r2077, r2054, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f207A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r207D = less(r2074, body.constant(int(32)));
                           ir_if *f207C = new(mem_ctx) ir_if(operand(r207D).val);
                           exec_list *const f207C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f207C->then_instructions;

                              body.emit(assign(r2075, lshift(r2055, r2078), 0x01));

                              ir_expression *const r207E = lshift(r2054, r2078);
                              ir_expression *const r207F = rshift(r2055, r2074);
                              body.emit(assign(r2076, bit_or(r207E, r207F), 0x01));

                              body.emit(assign(r2077, rshift(r2054, r2074), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f207C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2081 = equal(r2074, body.constant(int(32)));
                              ir_if *f2080 = new(mem_ctx) ir_if(operand(r2081).val);
                              exec_list *const f2080_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2080->then_instructions;

                                 body.emit(assign(r2075, r2055, 0x01));

                                 body.emit(assign(r2076, r2054, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2080->else_instructions;

                                 body.emit(assign(r2073, bit_or(r1F62, r2055), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2083 = less(r2074, body.constant(int(64)));
                                 ir_if *f2082 = new(mem_ctx) ir_if(operand(r2083).val);
                                 exec_list *const f2082_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2082->then_instructions;

                                    body.emit(assign(r2075, lshift(r2054, r2078), 0x01));

                                    ir_expression *const r2084 = bit_and(r2074, body.constant(int(31)));
                                    body.emit(assign(r2076, rshift(r2054, r2084), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2082->else_instructions;

                                    ir_variable *const r2085 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2087 = equal(r2074, body.constant(int(64)));
                                    ir_if *f2086 = new(mem_ctx) ir_if(operand(r2087).val);
                                    exec_list *const f2086_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2086->then_instructions;

                                       body.emit(assign(r2085, r2054, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2086->else_instructions;

                                       ir_expression *const r2088 = nequal(r2054, body.constant(0u));
                                       ir_expression *const r2089 = expr(ir_unop_b2i, r2088);
                                       body.emit(assign(r2085, expr(ir_unop_i2u, r2089), 0x01));


                                    body.instructions = f2086_parent_instructions;
                                    body.emit(f2086);

                                    /* END IF */

                                    body.emit(assign(r2075, r2085, 0x01));

                                    body.emit(assign(r2076, body.constant(0u), 0x01));


                                 body.instructions = f2082_parent_instructions;
                                 body.emit(f2082);

                                 /* END IF */


                              body.instructions = f2080_parent_instructions;
                              body.emit(f2080);

                              /* END IF */

                              body.emit(assign(r2077, body.constant(0u), 0x01));


                           body.instructions = f207C_parent_instructions;
                           body.emit(f207C);

                           /* END IF */

                           ir_expression *const r208A = nequal(r2073, body.constant(0u));
                           ir_expression *const r208B = expr(ir_unop_b2i, r208A);
                           ir_expression *const r208C = expr(ir_unop_i2u, r208B);
                           body.emit(assign(r2075, bit_or(r2075, r208C), 0x01));


                        body.instructions = f207A_parent_instructions;
                        body.emit(f207A);

                        /* END IF */

                        body.emit(assign(r205D, r2077, 0x01));

                        body.emit(assign(r205E, r2076, 0x01));

                        body.emit(assign(r205F, r2075, 0x01));

                        body.emit(assign(r205C, body.constant(int(0)), 0x01));

                        body.emit(assign(r2062, less(r2075, body.constant(0u)), 0x01));


                     body.instructions = f2071_parent_instructions;
                     body.emit(f2071);

                     /* END IF */


                  body.instructions = f206E_parent_instructions;
                  body.emit(f206E);

                  /* END IF */


               body.instructions = f2064_parent_instructions;
               body.emit(f2064);

               /* END IF */

               /* IF CONDITION */
               ir_if *f208D = new(mem_ctx) ir_if(operand(r2060).val);
               exec_list *const f208D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f208D->then_instructions;

                  /* IF CONDITION */
                  ir_if *f208E = new(mem_ctx) ir_if(operand(r2062).val);
                  exec_list *const f208E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f208E->then_instructions;

                     ir_variable *const r208F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r208F, add(r205E, body.constant(1u)), 0x01));

                     ir_expression *const r2090 = less(r208F, r205E);
                     ir_expression *const r2091 = expr(ir_unop_b2i, r2090);
                     ir_expression *const r2092 = expr(ir_unop_i2u, r2091);
                     body.emit(assign(r205D, add(r205D, r2092), 0x01));

                     ir_expression *const r2093 = equal(r205F, body.constant(0u));
                     ir_expression *const r2094 = expr(ir_unop_b2i, r2093);
                     ir_expression *const r2095 = expr(ir_unop_i2u, r2094);
                     ir_expression *const r2096 = add(r205F, r2095);
                     ir_expression *const r2097 = bit_and(r2096, body.constant(1u));
                     ir_expression *const r2098 = expr(ir_unop_bit_not, r2097);
                     body.emit(assign(r205E, bit_and(r208F, r2098), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f208E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r209A = bit_or(r205D, r205E);
                     ir_expression *const r209B = equal(r209A, body.constant(0u));
                     ir_if *f2099 = new(mem_ctx) ir_if(operand(r209B).val);
                     exec_list *const f2099_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2099->then_instructions;

                        body.emit(assign(r205C, body.constant(int(0)), 0x01));


                     body.instructions = f2099_parent_instructions;
                     body.emit(f2099);

                     /* END IF */


                  body.instructions = f208E_parent_instructions;
                  body.emit(f208E);

                  /* END IF */

                  ir_variable *const r209C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r209C);
                  ir_expression *const r209D = lshift(r1F56, body.constant(int(31)));
                  ir_expression *const r209E = expr(ir_unop_i2u, r205C);
                  ir_expression *const r209F = lshift(r209E, body.constant(int(20)));
                  ir_expression *const r20A0 = add(r209D, r209F);
                  body.emit(assign(r209C, add(r20A0, r205D), 0x02));

                  body.emit(assign(r209C, r205E, 0x01));

                  body.emit(assign(r2061, r209C, 0x03));

                  body.emit(assign(r2060, body.constant(false), 0x01));


               body.instructions = f208D_parent_instructions;
               body.emit(f208D);

               /* END IF */

               body.emit(assign(r1F5B, r2061, 0x03));

               body.emit(assign(r1F5A, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f205A->else_instructions;

               body.emit(assign(r1F61, add(r1F61, body.constant(int(1))), 0x01));

               ir_variable *const r20A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r20A1);
               ir_variable *const r20A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r20A2);
               ir_variable *const r20A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r20A3);
               body.emit(assign(r20A1, lshift(r2055, body.constant(int(31))), 0x01));

               ir_expression *const r20A4 = lshift(r2054, body.constant(int(31)));
               ir_expression *const r20A5 = rshift(r2055, body.constant(int(1)));
               body.emit(assign(r20A2, bit_or(r20A4, r20A5), 0x01));

               body.emit(assign(r20A3, rshift(r2054, body.constant(int(1))), 0x01));

               ir_expression *const r20A6 = nequal(r1F62, body.constant(0u));
               ir_expression *const r20A7 = expr(ir_unop_b2i, r20A6);
               ir_expression *const r20A8 = expr(ir_unop_i2u, r20A7);
               body.emit(assign(r20A1, bit_or(r20A1, r20A8), 0x01));

               body.emit(assign(r1F63, r20A3, 0x01));

               body.emit(assign(r1F62, r20A1, 0x01));

               ir_variable *const r20A9 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r20A9, r1F61, 0x01));

               ir_variable *const r20AA = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r20AA, r20A3, 0x01));

               ir_variable *const r20AB = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r20AB, r20A2, 0x01));

               ir_variable *const r20AC = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r20AC, r20A1, 0x01));

               ir_variable *const r20AD = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r20AD, body.constant(true), 0x01));

               ir_variable *const r20AE = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r20AF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r20AF);
               ir_expression *const r20B0 = expr(ir_unop_u2i, r20A1);
               body.emit(assign(r20AF, less(r20B0, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r20B2 = lequal(body.constant(int(2045)), r1F61);
               ir_if *f20B1 = new(mem_ctx) ir_if(operand(r20B2).val);
               exec_list *const f20B1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f20B1->then_instructions;

                  ir_variable *const r20B3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r20B5 = less(body.constant(int(2045)), r1F61);
                  ir_if *f20B4 = new(mem_ctx) ir_if(operand(r20B5).val);
                  exec_list *const f20B4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20B4->then_instructions;

                     body.emit(assign(r20B3, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20B4->else_instructions;

                     ir_variable *const r20B6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r20B8 = equal(r1F61, body.constant(int(2045)));
                     ir_if *f20B7 = new(mem_ctx) ir_if(operand(r20B8).val);
                     exec_list *const f20B7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f20B7->then_instructions;

                        ir_expression *const r20B9 = equal(body.constant(2097151u), r20A3);
                        ir_expression *const r20BA = equal(body.constant(4294967295u), r20A2);
                        body.emit(assign(r20B6, logic_and(r20B9, r20BA), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f20B7->else_instructions;

                        body.emit(assign(r20B6, body.constant(false), 0x01));


                     body.instructions = f20B7_parent_instructions;
                     body.emit(f20B7);

                     /* END IF */

                     body.emit(assign(r20B3, logic_and(r20B6, r20AF), 0x01));


                  body.instructions = f20B4_parent_instructions;
                  body.emit(f20B4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f20BB = new(mem_ctx) ir_if(operand(r20B3).val);
                  exec_list *const f20BB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20BB->then_instructions;

                     ir_variable *const r20BC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r20BC);
                     ir_expression *const r20BD = lshift(r1F56, body.constant(int(31)));
                     body.emit(assign(r20BC, add(r20BD, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r20BC, body.constant(0u), 0x01));

                     body.emit(assign(r20AE, r20BC, 0x03));

                     body.emit(assign(r20AD, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20BB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r20BF = less(r1F61, body.constant(int(0)));
                     ir_if *f20BE = new(mem_ctx) ir_if(operand(r20BF).val);
                     exec_list *const f20BE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f20BE->then_instructions;

                        ir_variable *const r20C0 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r20C0, r20A1, 0x01));

                        ir_variable *const r20C1 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r20C1, neg(r1F61), 0x01));

                        ir_variable *const r20C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r20C2);
                        ir_variable *const r20C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r20C3);
                        ir_variable *const r20C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r20C4);
                        ir_variable *const r20C5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r20C6 = neg(r20C1);
                        body.emit(assign(r20C5, bit_and(r20C6, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r20C8 = equal(r20C1, body.constant(int(0)));
                        ir_if *f20C7 = new(mem_ctx) ir_if(operand(r20C8).val);
                        exec_list *const f20C7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20C7->then_instructions;

                           body.emit(assign(r20C2, r20A1, 0x01));

                           body.emit(assign(r20C3, r20A2, 0x01));

                           body.emit(assign(r20C4, r20A3, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f20C7->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r20CA = less(r20C1, body.constant(int(32)));
                           ir_if *f20C9 = new(mem_ctx) ir_if(operand(r20CA).val);
                           exec_list *const f20C9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20C9->then_instructions;

                              body.emit(assign(r20C2, lshift(r20A2, r20C5), 0x01));

                              ir_expression *const r20CB = lshift(r20A3, r20C5);
                              ir_expression *const r20CC = rshift(r20A2, r20C1);
                              body.emit(assign(r20C3, bit_or(r20CB, r20CC), 0x01));

                              body.emit(assign(r20C4, rshift(r20A3, r20C1), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20C9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r20CE = equal(r20C1, body.constant(int(32)));
                              ir_if *f20CD = new(mem_ctx) ir_if(operand(r20CE).val);
                              exec_list *const f20CD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20CD->then_instructions;

                                 body.emit(assign(r20C2, r20A2, 0x01));

                                 body.emit(assign(r20C3, r20A3, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f20CD->else_instructions;

                                 body.emit(assign(r20C0, bit_or(r20A1, r20A2), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r20D0 = less(r20C1, body.constant(int(64)));
                                 ir_if *f20CF = new(mem_ctx) ir_if(operand(r20D0).val);
                                 exec_list *const f20CF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f20CF->then_instructions;

                                    body.emit(assign(r20C2, lshift(r20A3, r20C5), 0x01));

                                    ir_expression *const r20D1 = bit_and(r20C1, body.constant(int(31)));
                                    body.emit(assign(r20C3, rshift(r20A3, r20D1), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f20CF->else_instructions;

                                    ir_variable *const r20D2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r20D4 = equal(r20C1, body.constant(int(64)));
                                    ir_if *f20D3 = new(mem_ctx) ir_if(operand(r20D4).val);
                                    exec_list *const f20D3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f20D3->then_instructions;

                                       body.emit(assign(r20D2, r20A3, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f20D3->else_instructions;

                                       ir_expression *const r20D5 = nequal(r20A3, body.constant(0u));
                                       ir_expression *const r20D6 = expr(ir_unop_b2i, r20D5);
                                       body.emit(assign(r20D2, expr(ir_unop_i2u, r20D6), 0x01));


                                    body.instructions = f20D3_parent_instructions;
                                    body.emit(f20D3);

                                    /* END IF */

                                    body.emit(assign(r20C2, r20D2, 0x01));

                                    body.emit(assign(r20C3, body.constant(0u), 0x01));


                                 body.instructions = f20CF_parent_instructions;
                                 body.emit(f20CF);

                                 /* END IF */


                              body.instructions = f20CD_parent_instructions;
                              body.emit(f20CD);

                              /* END IF */

                              body.emit(assign(r20C4, body.constant(0u), 0x01));


                           body.instructions = f20C9_parent_instructions;
                           body.emit(f20C9);

                           /* END IF */

                           ir_expression *const r20D7 = nequal(r20C0, body.constant(0u));
                           ir_expression *const r20D8 = expr(ir_unop_b2i, r20D7);
                           ir_expression *const r20D9 = expr(ir_unop_i2u, r20D8);
                           body.emit(assign(r20C2, bit_or(r20C2, r20D9), 0x01));


                        body.instructions = f20C7_parent_instructions;
                        body.emit(f20C7);

                        /* END IF */

                        body.emit(assign(r20AA, r20C4, 0x01));

                        body.emit(assign(r20AB, r20C3, 0x01));

                        body.emit(assign(r20AC, r20C2, 0x01));

                        body.emit(assign(r20A9, body.constant(int(0)), 0x01));

                        body.emit(assign(r20AF, less(r20C2, body.constant(0u)), 0x01));


                     body.instructions = f20BE_parent_instructions;
                     body.emit(f20BE);

                     /* END IF */


                  body.instructions = f20BB_parent_instructions;
                  body.emit(f20BB);

                  /* END IF */


               body.instructions = f20B1_parent_instructions;
               body.emit(f20B1);

               /* END IF */

               /* IF CONDITION */
               ir_if *f20DA = new(mem_ctx) ir_if(operand(r20AD).val);
               exec_list *const f20DA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f20DA->then_instructions;

                  /* IF CONDITION */
                  ir_if *f20DB = new(mem_ctx) ir_if(operand(r20AF).val);
                  exec_list *const f20DB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20DB->then_instructions;

                     ir_variable *const r20DC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r20DC, add(r20AB, body.constant(1u)), 0x01));

                     ir_expression *const r20DD = less(r20DC, r20AB);
                     ir_expression *const r20DE = expr(ir_unop_b2i, r20DD);
                     ir_expression *const r20DF = expr(ir_unop_i2u, r20DE);
                     body.emit(assign(r20AA, add(r20AA, r20DF), 0x01));

                     ir_expression *const r20E0 = equal(r20AC, body.constant(0u));
                     ir_expression *const r20E1 = expr(ir_unop_b2i, r20E0);
                     ir_expression *const r20E2 = expr(ir_unop_i2u, r20E1);
                     ir_expression *const r20E3 = add(r20AC, r20E2);
                     ir_expression *const r20E4 = bit_and(r20E3, body.constant(1u));
                     ir_expression *const r20E5 = expr(ir_unop_bit_not, r20E4);
                     body.emit(assign(r20AB, bit_and(r20DC, r20E5), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20DB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r20E7 = bit_or(r20AA, r20AB);
                     ir_expression *const r20E8 = equal(r20E7, body.constant(0u));
                     ir_if *f20E6 = new(mem_ctx) ir_if(operand(r20E8).val);
                     exec_list *const f20E6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f20E6->then_instructions;

                        body.emit(assign(r20A9, body.constant(int(0)), 0x01));


                     body.instructions = f20E6_parent_instructions;
                     body.emit(f20E6);

                     /* END IF */


                  body.instructions = f20DB_parent_instructions;
                  body.emit(f20DB);

                  /* END IF */

                  ir_variable *const r20E9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r20E9);
                  ir_expression *const r20EA = lshift(r1F56, body.constant(int(31)));
                  ir_expression *const r20EB = expr(ir_unop_i2u, r20A9);
                  ir_expression *const r20EC = lshift(r20EB, body.constant(int(20)));
                  ir_expression *const r20ED = add(r20EA, r20EC);
                  body.emit(assign(r20E9, add(r20ED, r20AA), 0x02));

                  body.emit(assign(r20E9, r20AB, 0x01));

                  body.emit(assign(r20AE, r20E9, 0x03));

                  body.emit(assign(r20AD, body.constant(false), 0x01));


               body.instructions = f20DA_parent_instructions;
               body.emit(f20DA);

               /* END IF */

               body.emit(assign(r1F5B, r20AE, 0x03));

               body.emit(assign(r1F5A, body.constant(false), 0x01));


            body.instructions = f205A_parent_instructions;
            body.emit(f205A);

            /* END IF */


         body.instructions = f2053_parent_instructions;
         body.emit(f2053);

         /* END IF */

         body.emit(assign(r1F55, r1F5B, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1F58->else_instructions;

         ir_variable *const r20EE = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r20EE, r1F56, 0x01));

         ir_variable *const r20EF = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r20F0 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r20F0);
         ir_variable *const r20F1 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r20F1);
         ir_variable *const r20F2 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r20F2);
         ir_variable *const r20F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r20F3);
         ir_variable *const r20F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r20F4);
         ir_variable *const r20F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r20F5);
         ir_variable *const r20F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r20F6);
         ir_variable *const r20F7 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r20F7);
         ir_variable *const r20F8 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r20F9 = rshift(swizzle_y(r1F1F), body.constant(int(20)));
         ir_expression *const r20FA = bit_and(r20F9, body.constant(2047u));
         body.emit(assign(r20F8, expr(ir_unop_u2i, r20FA), 0x01));

         body.emit(assign(r20F2, r20F8, 0x01));

         ir_variable *const r20FB = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r20FB, body.constant(int(1023)), 0x01));

         body.emit(assign(r20F1, r20FB, 0x01));

         body.emit(assign(r20F0, add(r20F8, body.constant(int(-1023))), 0x01));

         ir_variable *const r20FC = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r20FC, lshift(swizzle_x(r1F1F), body.constant(int(10))), 0x01));

         ir_variable *const r20FD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r20FE = bit_and(swizzle_y(r1F1F), body.constant(1048575u));
         ir_expression *const r20FF = lshift(r20FE, body.constant(int(10)));
         ir_expression *const r2100 = rshift(swizzle_x(r1F1F), body.constant(int(22)));
         body.emit(assign(r20FD, bit_or(r20FF, r2100), 0x01));

         body.emit(assign(r20F5, r20FD, 0x01));

         body.emit(assign(r20F6, r20FC, 0x01));

         ir_variable *const r2101 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r2101, body.constant(0u), 0x01));

         ir_variable *const r2102 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r2102, body.constant(0u), 0x01));

         body.emit(assign(r20F3, r2102, 0x01));

         body.emit(assign(r20F4, r2101, 0x01));

         /* IF CONDITION */
         ir_expression *const r2104 = less(body.constant(int(0)), r20F0);
         ir_if *f2103 = new(mem_ctx) ir_if(operand(r2104).val);
         exec_list *const f2103_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2103->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2106 = equal(r20F8, body.constant(int(2047)));
            ir_if *f2105 = new(mem_ctx) ir_if(operand(r2106).val);
            exec_list *const f2105_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2105->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2108 = bit_or(r20FD, r20FC);
               ir_expression *const r2109 = nequal(r2108, body.constant(0u));
               ir_if *f2107 = new(mem_ctx) ir_if(operand(r2109).val);
               exec_list *const f2107_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2107->then_instructions;

                  ir_variable *const r210A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r210A, swizzle_x(r1F1F), 0x01));

                  ir_variable *const r210B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r210B, body.constant(0u), 0x01));

                  ir_variable *const r210C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r210D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r210E = rshift(swizzle_y(r1F1F), body.constant(int(19)));
                  ir_expression *const r210F = bit_and(r210E, body.constant(4095u));
                  ir_expression *const r2110 = equal(r210F, body.constant(4094u));
                  ir_expression *const r2111 = nequal(swizzle_x(r1F1F), body.constant(0u));
                  ir_expression *const r2112 = bit_and(swizzle_y(r1F1F), body.constant(524287u));
                  ir_expression *const r2113 = nequal(r2112, body.constant(0u));
                  ir_expression *const r2114 = logic_or(r2111, r2113);
                  body.emit(assign(r210D, logic_and(r2110, r2114), 0x01));

                  ir_variable *const r2115 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  body.emit(assign(r2115, body.constant(false), 0x01));

                  body.emit(assign(r210A, bit_or(swizzle_y(r1F1F), body.constant(524288u)), 0x02));

                  body.emit(assign(r210B, body.constant(3220701184u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2117 = lshift(swizzle_y(r1F1F), body.constant(int(1)));
                  ir_expression *const r2118 = lequal(body.constant(4292870144u), r2117);
                  ir_expression *const r2119 = nequal(swizzle_x(r1F1F), body.constant(0u));
                  ir_expression *const r211A = bit_and(swizzle_y(r1F1F), body.constant(1048575u));
                  ir_expression *const r211B = nequal(r211A, body.constant(0u));
                  ir_expression *const r211C = logic_or(r2119, r211B);
                  ir_expression *const r211D = logic_and(r2118, r211C);
                  ir_if *f2116 = new(mem_ctx) ir_if(operand(r211D).val);
                  exec_list *const f2116_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2116->then_instructions;

                     ir_variable *const r211E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_constant *const r2120 = body.constant(false);
                     ir_if *f211F = new(mem_ctx) ir_if(operand(r2120).val);
                     exec_list *const f211F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f211F->then_instructions;

                        body.emit(assign(r211E, r210B, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f211F->else_instructions;

                        body.emit(assign(r211E, r210A, 0x03));


                     body.instructions = f211F_parent_instructions;
                     body.emit(f211F);

                     /* END IF */

                     body.emit(assign(r210C, r211E, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2116->else_instructions;

                     body.emit(assign(r210C, r210B, 0x03));


                  body.instructions = f2116_parent_instructions;
                  body.emit(f2116);

                  /* END IF */

                  body.emit(assign(r20EF, r210C, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2107->else_instructions;

                  body.emit(assign(r20EF, r1F1F, 0x03));


               body.instructions = f2107_parent_instructions;
               body.emit(f2107);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2105->else_instructions;

               /* IF CONDITION */
               ir_constant *const r2122 = body.constant(false);
               ir_if *f2121 = new(mem_ctx) ir_if(operand(r2122).val);
               exec_list *const f2121_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2121->then_instructions;

                  body.emit(assign(r20F0, add(r20F0, body.constant(int(-1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2121->else_instructions;

                  body.emit(assign(r20F3, body.constant(1073741824u), 0x01));


               body.instructions = f2121_parent_instructions;
               body.emit(f2121);

               /* END IF */

               ir_variable *const r2123 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2123);
               ir_variable *const r2124 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2124);
               ir_variable *const r2125 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2126 = neg(r20F0);
               body.emit(assign(r2125, bit_and(r2126, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2128 = equal(r20F0, body.constant(int(0)));
               ir_if *f2127 = new(mem_ctx) ir_if(operand(r2128).val);
               exec_list *const f2127_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2127->then_instructions;

                  body.emit(assign(r2123, r2101, 0x01));

                  body.emit(assign(r2124, r20F3, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2127->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r212A = less(r20F0, body.constant(int(32)));
                  ir_if *f2129 = new(mem_ctx) ir_if(operand(r212A).val);
                  exec_list *const f2129_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2129->then_instructions;

                     ir_expression *const r212B = lshift(r20F3, r2125);
                     ir_expression *const r212C = bit_or(r212B, body.constant(0u));
                     ir_expression *const r212D = nequal(body.constant(0u), body.constant(0u));
                     ir_expression *const r212E = expr(ir_unop_b2i, r212D);
                     ir_expression *const r212F = expr(ir_unop_i2u, r212E);
                     body.emit(assign(r2123, bit_or(r212C, r212F), 0x01));

                     body.emit(assign(r2124, rshift(r20F3, r20F0), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2129->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2131 = equal(r20F0, body.constant(int(32)));
                     ir_if *f2130 = new(mem_ctx) ir_if(operand(r2131).val);
                     exec_list *const f2130_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2130->then_instructions;

                        body.emit(assign(r2123, bit_or(r20F3, body.constant(0u)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2130->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2133 = less(r20F0, body.constant(int(64)));
                        ir_if *f2132 = new(mem_ctx) ir_if(operand(r2133).val);
                        exec_list *const f2132_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2132->then_instructions;

                           ir_expression *const r2134 = bit_and(r20F0, body.constant(int(31)));
                           ir_expression *const r2135 = rshift(r20F3, r2134);
                           ir_expression *const r2136 = lshift(r20F3, r2125);
                           ir_expression *const r2137 = bit_or(r2136, body.constant(0u));
                           ir_expression *const r2138 = nequal(r2137, body.constant(0u));
                           ir_expression *const r2139 = expr(ir_unop_b2i, r2138);
                           ir_expression *const r213A = expr(ir_unop_i2u, r2139);
                           body.emit(assign(r2123, bit_or(r2135, r213A), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2132->else_instructions;

                           ir_expression *const r213B = bit_or(r20F3, body.constant(0u));
                           ir_expression *const r213C = nequal(r213B, body.constant(0u));
                           ir_expression *const r213D = expr(ir_unop_b2i, r213C);
                           body.emit(assign(r2123, expr(ir_unop_i2u, r213D), 0x01));


                        body.instructions = f2132_parent_instructions;
                        body.emit(f2132);

                        /* END IF */


                     body.instructions = f2130_parent_instructions;
                     body.emit(f2130);

                     /* END IF */

                     body.emit(assign(r2124, body.constant(0u), 0x01));


                  body.instructions = f2129_parent_instructions;
                  body.emit(f2129);

                  /* END IF */


               body.instructions = f2127_parent_instructions;
               body.emit(f2127);

               /* END IF */

               body.emit(assign(r20F3, r2124, 0x01));

               body.emit(assign(r20F4, r2123, 0x01));

               body.emit(assign(r20F5, bit_or(r20FD, body.constant(1073741824u)), 0x01));

               ir_variable *const r213E = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r213F = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r213F, sub(r20FC, r2123), 0x01));

               ir_expression *const r2140 = sub(r20F5, r2124);
               ir_expression *const r2141 = less(r20FC, r2123);
               ir_expression *const r2142 = expr(ir_unop_b2i, r2141);
               ir_expression *const r2143 = expr(ir_unop_i2u, r2142);
               body.emit(assign(r213E, sub(r2140, r2143), 0x01));

               body.emit(assign(r20F7, add(r20F8, body.constant(int(-1))), 0x01));

               ir_variable *const r2144 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2144, add(r20F7, body.constant(int(-10))), 0x01));

               ir_variable *const r2145 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2145, r213E, 0x01));

               ir_variable *const r2146 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2146, r213F, 0x01));

               ir_variable *const r2147 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2147);
               ir_variable *const r2148 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2148);
               /* IF CONDITION */
               ir_expression *const r214A = equal(r213E, body.constant(0u));
               ir_if *f2149 = new(mem_ctx) ir_if(operand(r214A).val);
               exec_list *const f2149_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2149->then_instructions;

                  body.emit(assign(r2145, r213F, 0x01));

                  body.emit(assign(r2146, body.constant(0u), 0x01));

                  body.emit(assign(r2144, add(r2144, body.constant(int(-32))), 0x01));


               body.instructions = f2149_parent_instructions;
               body.emit(f2149);

               /* END IF */

               ir_variable *const r214B = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r214B, r2145, 0x01));

               ir_variable *const r214C = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r214D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r214D);
               /* IF CONDITION */
               ir_expression *const r214F = equal(r2145, body.constant(0u));
               ir_if *f214E = new(mem_ctx) ir_if(operand(r214F).val);
               exec_list *const f214E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f214E->then_instructions;

                  body.emit(assign(r214C, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f214E->else_instructions;

                  body.emit(assign(r214D, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2151 = bit_and(r2145, body.constant(4294901760u));
                  ir_expression *const r2152 = equal(r2151, body.constant(0u));
                  ir_if *f2150 = new(mem_ctx) ir_if(operand(r2152).val);
                  exec_list *const f2150_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2150->then_instructions;

                     body.emit(assign(r214D, body.constant(int(16)), 0x01));

                     body.emit(assign(r214B, lshift(r2145, body.constant(int(16))), 0x01));


                  body.instructions = f2150_parent_instructions;
                  body.emit(f2150);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2154 = bit_and(r214B, body.constant(4278190080u));
                  ir_expression *const r2155 = equal(r2154, body.constant(0u));
                  ir_if *f2153 = new(mem_ctx) ir_if(operand(r2155).val);
                  exec_list *const f2153_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2153->then_instructions;

                     body.emit(assign(r214D, add(r214D, body.constant(int(8))), 0x01));

                     body.emit(assign(r214B, lshift(r214B, body.constant(int(8))), 0x01));


                  body.instructions = f2153_parent_instructions;
                  body.emit(f2153);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2157 = bit_and(r214B, body.constant(4026531840u));
                  ir_expression *const r2158 = equal(r2157, body.constant(0u));
                  ir_if *f2156 = new(mem_ctx) ir_if(operand(r2158).val);
                  exec_list *const f2156_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2156->then_instructions;

                     body.emit(assign(r214D, add(r214D, body.constant(int(4))), 0x01));

                     body.emit(assign(r214B, lshift(r214B, body.constant(int(4))), 0x01));


                  body.instructions = f2156_parent_instructions;
                  body.emit(f2156);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r215A = bit_and(r214B, body.constant(3221225472u));
                  ir_expression *const r215B = equal(r215A, body.constant(0u));
                  ir_if *f2159 = new(mem_ctx) ir_if(operand(r215B).val);
                  exec_list *const f2159_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2159->then_instructions;

                     body.emit(assign(r214D, add(r214D, body.constant(int(2))), 0x01));

                     body.emit(assign(r214B, lshift(r214B, body.constant(int(2))), 0x01));


                  body.instructions = f2159_parent_instructions;
                  body.emit(f2159);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r215D = bit_and(r214B, body.constant(2147483648u));
                  ir_expression *const r215E = equal(r215D, body.constant(0u));
                  ir_if *f215C = new(mem_ctx) ir_if(operand(r215E).val);
                  exec_list *const f215C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f215C->then_instructions;

                     body.emit(assign(r214D, add(r214D, body.constant(int(1))), 0x01));


                  body.instructions = f215C_parent_instructions;
                  body.emit(f215C);

                  /* END IF */

                  body.emit(assign(r214C, r214D, 0x01));


               body.instructions = f214E_parent_instructions;
               body.emit(f214E);

               /* END IF */

               body.emit(assign(r2148, add(r214C, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2160 = lequal(body.constant(int(0)), r2148);
               ir_if *f215F = new(mem_ctx) ir_if(operand(r2160).val);
               exec_list *const f215F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f215F->then_instructions;

                  body.emit(assign(r2147, body.constant(0u), 0x01));

                  ir_variable *const r2161 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2161, lshift(r2146, r2148), 0x01));

                  ir_variable *const r2162 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2164 = equal(r2148, body.constant(int(0)));
                  ir_if *f2163 = new(mem_ctx) ir_if(operand(r2164).val);
                  exec_list *const f2163_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2163->then_instructions;

                     body.emit(assign(r2162, r2145, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2163->else_instructions;

                     ir_expression *const r2165 = lshift(r2145, r2148);
                     ir_expression *const r2166 = neg(r2148);
                     ir_expression *const r2167 = bit_and(r2166, body.constant(int(31)));
                     ir_expression *const r2168 = rshift(r2146, r2167);
                     body.emit(assign(r2162, bit_or(r2165, r2168), 0x01));


                  body.instructions = f2163_parent_instructions;
                  body.emit(f2163);

                  /* END IF */

                  body.emit(assign(r2145, r2162, 0x01));

                  body.emit(assign(r2146, r2161, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f215F->else_instructions;

                  ir_variable *const r2169 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2169, body.constant(0u), 0x01));

                  ir_variable *const r216A = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r216A, neg(r2148), 0x01));

                  ir_variable *const r216B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r216B);
                  ir_variable *const r216C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r216C);
                  ir_variable *const r216D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r216D);
                  ir_variable *const r216E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r216F = neg(r216A);
                  body.emit(assign(r216E, bit_and(r216F, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2171 = equal(r216A, body.constant(int(0)));
                  ir_if *f2170 = new(mem_ctx) ir_if(operand(r2171).val);
                  exec_list *const f2170_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2170->then_instructions;

                     body.emit(assign(r216B, r2169, 0x01));

                     body.emit(assign(r216C, r2146, 0x01));

                     body.emit(assign(r216D, r2145, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2170->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2173 = less(r216A, body.constant(int(32)));
                     ir_if *f2172 = new(mem_ctx) ir_if(operand(r2173).val);
                     exec_list *const f2172_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2172->then_instructions;

                        body.emit(assign(r216B, lshift(r2146, r216E), 0x01));

                        ir_expression *const r2174 = lshift(r2145, r216E);
                        ir_expression *const r2175 = rshift(r2146, r216A);
                        body.emit(assign(r216C, bit_or(r2174, r2175), 0x01));

                        body.emit(assign(r216D, rshift(r2145, r216A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2172->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2177 = equal(r216A, body.constant(int(32)));
                        ir_if *f2176 = new(mem_ctx) ir_if(operand(r2177).val);
                        exec_list *const f2176_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2176->then_instructions;

                           body.emit(assign(r216B, r2146, 0x01));

                           body.emit(assign(r216C, r2145, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2176->else_instructions;

                           body.emit(assign(r2169, bit_or(body.constant(0u), r2146), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2179 = less(r216A, body.constant(int(64)));
                           ir_if *f2178 = new(mem_ctx) ir_if(operand(r2179).val);
                           exec_list *const f2178_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2178->then_instructions;

                              body.emit(assign(r216B, lshift(r2145, r216E), 0x01));

                              ir_expression *const r217A = bit_and(r216A, body.constant(int(31)));
                              body.emit(assign(r216C, rshift(r2145, r217A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2178->else_instructions;

                              ir_variable *const r217B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r217D = equal(r216A, body.constant(int(64)));
                              ir_if *f217C = new(mem_ctx) ir_if(operand(r217D).val);
                              exec_list *const f217C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f217C->then_instructions;

                                 body.emit(assign(r217B, r2145, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f217C->else_instructions;

                                 ir_expression *const r217E = nequal(r2145, body.constant(0u));
                                 ir_expression *const r217F = expr(ir_unop_b2i, r217E);
                                 body.emit(assign(r217B, expr(ir_unop_i2u, r217F), 0x01));


                              body.instructions = f217C_parent_instructions;
                              body.emit(f217C);

                              /* END IF */

                              body.emit(assign(r216B, r217B, 0x01));

                              body.emit(assign(r216C, body.constant(0u), 0x01));


                           body.instructions = f2178_parent_instructions;
                           body.emit(f2178);

                           /* END IF */


                        body.instructions = f2176_parent_instructions;
                        body.emit(f2176);

                        /* END IF */

                        body.emit(assign(r216D, body.constant(0u), 0x01));


                     body.instructions = f2172_parent_instructions;
                     body.emit(f2172);

                     /* END IF */

                     ir_expression *const r2180 = nequal(r2169, body.constant(0u));
                     ir_expression *const r2181 = expr(ir_unop_b2i, r2180);
                     ir_expression *const r2182 = expr(ir_unop_i2u, r2181);
                     body.emit(assign(r216B, bit_or(r216B, r2182), 0x01));


                  body.instructions = f2170_parent_instructions;
                  body.emit(f2170);

                  /* END IF */

                  body.emit(assign(r2145, r216D, 0x01));

                  body.emit(assign(r2146, r216C, 0x01));

                  body.emit(assign(r2147, r216B, 0x01));


               body.instructions = f215F_parent_instructions;
               body.emit(f215F);

               /* END IF */

               body.emit(assign(r2144, sub(r2144, r2148), 0x01));

               ir_variable *const r2183 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2183, r2144, 0x01));

               ir_variable *const r2184 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2184, r2145, 0x01));

               ir_variable *const r2185 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2185, r2146, 0x01));

               ir_variable *const r2186 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2186, r2147, 0x01));

               ir_variable *const r2187 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2187, body.constant(true), 0x01));

               ir_variable *const r2188 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2189 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2189);
               ir_expression *const r218A = expr(ir_unop_u2i, r2147);
               body.emit(assign(r2189, less(r218A, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r218C = lequal(body.constant(int(2045)), r2144);
               ir_if *f218B = new(mem_ctx) ir_if(operand(r218C).val);
               exec_list *const f218B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f218B->then_instructions;

                  ir_variable *const r218D = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r218F = less(body.constant(int(2045)), r2144);
                  ir_if *f218E = new(mem_ctx) ir_if(operand(r218F).val);
                  exec_list *const f218E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f218E->then_instructions;

                     body.emit(assign(r218D, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f218E->else_instructions;

                     ir_variable *const r2190 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2192 = equal(r2144, body.constant(int(2045)));
                     ir_if *f2191 = new(mem_ctx) ir_if(operand(r2192).val);
                     exec_list *const f2191_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2191->then_instructions;

                        ir_expression *const r2193 = equal(body.constant(2097151u), r2145);
                        ir_expression *const r2194 = equal(body.constant(4294967295u), r2146);
                        body.emit(assign(r2190, logic_and(r2193, r2194), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2191->else_instructions;

                        body.emit(assign(r2190, body.constant(false), 0x01));


                     body.instructions = f2191_parent_instructions;
                     body.emit(f2191);

                     /* END IF */

                     body.emit(assign(r218D, logic_and(r2190, r2189), 0x01));


                  body.instructions = f218E_parent_instructions;
                  body.emit(f218E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2195 = new(mem_ctx) ir_if(operand(r218D).val);
                  exec_list *const f2195_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2195->then_instructions;

                     ir_variable *const r2196 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2196);
                     ir_expression *const r2197 = lshift(r1F56, body.constant(int(31)));
                     body.emit(assign(r2196, add(r2197, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2196, body.constant(0u), 0x01));

                     body.emit(assign(r2188, r2196, 0x03));

                     body.emit(assign(r2187, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2195->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2199 = less(r2144, body.constant(int(0)));
                     ir_if *f2198 = new(mem_ctx) ir_if(operand(r2199).val);
                     exec_list *const f2198_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2198->then_instructions;

                        ir_variable *const r219A = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r219A, r2147, 0x01));

                        ir_variable *const r219B = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r219B, neg(r2144), 0x01));

                        ir_variable *const r219C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r219C);
                        ir_variable *const r219D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r219D);
                        ir_variable *const r219E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r219E);
                        ir_variable *const r219F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r21A0 = neg(r219B);
                        body.emit(assign(r219F, bit_and(r21A0, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r21A2 = equal(r219B, body.constant(int(0)));
                        ir_if *f21A1 = new(mem_ctx) ir_if(operand(r21A2).val);
                        exec_list *const f21A1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f21A1->then_instructions;

                           body.emit(assign(r219C, r2147, 0x01));

                           body.emit(assign(r219D, r2146, 0x01));

                           body.emit(assign(r219E, r2145, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f21A1->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r21A4 = less(r219B, body.constant(int(32)));
                           ir_if *f21A3 = new(mem_ctx) ir_if(operand(r21A4).val);
                           exec_list *const f21A3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f21A3->then_instructions;

                              body.emit(assign(r219C, lshift(r2146, r219F), 0x01));

                              ir_expression *const r21A5 = lshift(r2145, r219F);
                              ir_expression *const r21A6 = rshift(r2146, r219B);
                              body.emit(assign(r219D, bit_or(r21A5, r21A6), 0x01));

                              body.emit(assign(r219E, rshift(r2145, r219B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f21A3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r21A8 = equal(r219B, body.constant(int(32)));
                              ir_if *f21A7 = new(mem_ctx) ir_if(operand(r21A8).val);
                              exec_list *const f21A7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f21A7->then_instructions;

                                 body.emit(assign(r219C, r2146, 0x01));

                                 body.emit(assign(r219D, r2145, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f21A7->else_instructions;

                                 body.emit(assign(r219A, bit_or(r2147, r2146), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r21AA = less(r219B, body.constant(int(64)));
                                 ir_if *f21A9 = new(mem_ctx) ir_if(operand(r21AA).val);
                                 exec_list *const f21A9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21A9->then_instructions;

                                    body.emit(assign(r219C, lshift(r2145, r219F), 0x01));

                                    ir_expression *const r21AB = bit_and(r219B, body.constant(int(31)));
                                    body.emit(assign(r219D, rshift(r2145, r21AB), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f21A9->else_instructions;

                                    ir_variable *const r21AC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r21AE = equal(r219B, body.constant(int(64)));
                                    ir_if *f21AD = new(mem_ctx) ir_if(operand(r21AE).val);
                                    exec_list *const f21AD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f21AD->then_instructions;

                                       body.emit(assign(r21AC, r2145, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f21AD->else_instructions;

                                       ir_expression *const r21AF = nequal(r2145, body.constant(0u));
                                       ir_expression *const r21B0 = expr(ir_unop_b2i, r21AF);
                                       body.emit(assign(r21AC, expr(ir_unop_i2u, r21B0), 0x01));


                                    body.instructions = f21AD_parent_instructions;
                                    body.emit(f21AD);

                                    /* END IF */

                                    body.emit(assign(r219C, r21AC, 0x01));

                                    body.emit(assign(r219D, body.constant(0u), 0x01));


                                 body.instructions = f21A9_parent_instructions;
                                 body.emit(f21A9);

                                 /* END IF */


                              body.instructions = f21A7_parent_instructions;
                              body.emit(f21A7);

                              /* END IF */

                              body.emit(assign(r219E, body.constant(0u), 0x01));


                           body.instructions = f21A3_parent_instructions;
                           body.emit(f21A3);

                           /* END IF */

                           ir_expression *const r21B1 = nequal(r219A, body.constant(0u));
                           ir_expression *const r21B2 = expr(ir_unop_b2i, r21B1);
                           ir_expression *const r21B3 = expr(ir_unop_i2u, r21B2);
                           body.emit(assign(r219C, bit_or(r219C, r21B3), 0x01));


                        body.instructions = f21A1_parent_instructions;
                        body.emit(f21A1);

                        /* END IF */

                        body.emit(assign(r2184, r219E, 0x01));

                        body.emit(assign(r2185, r219D, 0x01));

                        body.emit(assign(r2186, r219C, 0x01));

                        body.emit(assign(r2183, body.constant(int(0)), 0x01));

                        body.emit(assign(r2189, less(r219C, body.constant(0u)), 0x01));


                     body.instructions = f2198_parent_instructions;
                     body.emit(f2198);

                     /* END IF */


                  body.instructions = f2195_parent_instructions;
                  body.emit(f2195);

                  /* END IF */


               body.instructions = f218B_parent_instructions;
               body.emit(f218B);

               /* END IF */

               /* IF CONDITION */
               ir_if *f21B4 = new(mem_ctx) ir_if(operand(r2187).val);
               exec_list *const f21B4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f21B4->then_instructions;

                  /* IF CONDITION */
                  ir_if *f21B5 = new(mem_ctx) ir_if(operand(r2189).val);
                  exec_list *const f21B5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f21B5->then_instructions;

                     ir_variable *const r21B6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r21B6, add(r2185, body.constant(1u)), 0x01));

                     ir_expression *const r21B7 = less(r21B6, r2185);
                     ir_expression *const r21B8 = expr(ir_unop_b2i, r21B7);
                     ir_expression *const r21B9 = expr(ir_unop_i2u, r21B8);
                     body.emit(assign(r2184, add(r2184, r21B9), 0x01));

                     ir_expression *const r21BA = equal(r2186, body.constant(0u));
                     ir_expression *const r21BB = expr(ir_unop_b2i, r21BA);
                     ir_expression *const r21BC = expr(ir_unop_i2u, r21BB);
                     ir_expression *const r21BD = add(r2186, r21BC);
                     ir_expression *const r21BE = bit_and(r21BD, body.constant(1u));
                     ir_expression *const r21BF = expr(ir_unop_bit_not, r21BE);
                     body.emit(assign(r2185, bit_and(r21B6, r21BF), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f21B5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r21C1 = bit_or(r2184, r2185);
                     ir_expression *const r21C2 = equal(r21C1, body.constant(0u));
                     ir_if *f21C0 = new(mem_ctx) ir_if(operand(r21C2).val);
                     exec_list *const f21C0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f21C0->then_instructions;

                        body.emit(assign(r2183, body.constant(int(0)), 0x01));


                     body.instructions = f21C0_parent_instructions;
                     body.emit(f21C0);

                     /* END IF */


                  body.instructions = f21B5_parent_instructions;
                  body.emit(f21B5);

                  /* END IF */

                  ir_variable *const r21C3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r21C3);
                  ir_expression *const r21C4 = lshift(r1F56, body.constant(int(31)));
                  ir_expression *const r21C5 = expr(ir_unop_i2u, r2183);
                  ir_expression *const r21C6 = lshift(r21C5, body.constant(int(20)));
                  ir_expression *const r21C7 = add(r21C4, r21C6);
                  body.emit(assign(r21C3, add(r21C7, r2184), 0x02));

                  body.emit(assign(r21C3, r2185, 0x01));

                  body.emit(assign(r2188, r21C3, 0x03));

                  body.emit(assign(r2187, body.constant(false), 0x01));


               body.instructions = f21B4_parent_instructions;
               body.emit(f21B4);

               /* END IF */

               body.emit(assign(r20EF, r2188, 0x03));


            body.instructions = f2105_parent_instructions;
            body.emit(f2105);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2103->else_instructions;

            /* IF CONDITION */
            ir_expression *const r21C9 = less(r20F0, body.constant(int(0)));
            ir_if *f21C8 = new(mem_ctx) ir_if(operand(r21C9).val);
            exec_list *const f21C8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f21C8->then_instructions;

               /* IF CONDITION */
               ir_constant *const r21CB = body.constant(false);
               ir_if *f21CA = new(mem_ctx) ir_if(operand(r21CB).val);
               exec_list *const f21CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f21CA->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r21CD = bit_or(r20F3, r20F4);
                  ir_expression *const r21CE = nequal(r21CD, body.constant(0u));
                  ir_if *f21CC = new(mem_ctx) ir_if(operand(r21CE).val);
                  exec_list *const f21CC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f21CC->then_instructions;

                     ir_variable *const r21CF = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r21CF, swizzle_x(r1F1F), 0x01));

                     ir_variable *const r21D0 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r21D0, body.constant(0u), 0x01));

                     ir_variable *const r21D1 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r21D2 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r21D3 = rshift(swizzle_y(r1F1F), body.constant(int(19)));
                     ir_expression *const r21D4 = bit_and(r21D3, body.constant(4095u));
                     ir_expression *const r21D5 = equal(r21D4, body.constant(4094u));
                     ir_expression *const r21D6 = nequal(swizzle_x(r1F1F), body.constant(0u));
                     ir_expression *const r21D7 = bit_and(swizzle_y(r1F1F), body.constant(524287u));
                     ir_expression *const r21D8 = nequal(r21D7, body.constant(0u));
                     ir_expression *const r21D9 = logic_or(r21D6, r21D8);
                     body.emit(assign(r21D2, logic_and(r21D5, r21D9), 0x01));

                     ir_variable *const r21DA = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r21DA, body.constant(false), 0x01));

                     body.emit(assign(r21CF, bit_or(swizzle_y(r1F1F), body.constant(524288u)), 0x02));

                     body.emit(assign(r21D0, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r21DC = lshift(swizzle_y(r1F1F), body.constant(int(1)));
                     ir_expression *const r21DD = lequal(body.constant(4292870144u), r21DC);
                     ir_expression *const r21DE = nequal(swizzle_x(r1F1F), body.constant(0u));
                     ir_expression *const r21DF = bit_and(swizzle_y(r1F1F), body.constant(1048575u));
                     ir_expression *const r21E0 = nequal(r21DF, body.constant(0u));
                     ir_expression *const r21E1 = logic_or(r21DE, r21E0);
                     ir_expression *const r21E2 = logic_and(r21DD, r21E1);
                     ir_if *f21DB = new(mem_ctx) ir_if(operand(r21E2).val);
                     exec_list *const f21DB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f21DB->then_instructions;

                        ir_variable *const r21E3 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r21E5 = body.constant(false);
                        ir_if *f21E4 = new(mem_ctx) ir_if(operand(r21E5).val);
                        exec_list *const f21E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f21E4->then_instructions;

                           body.emit(assign(r21E3, r21D0, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f21E4->else_instructions;

                           body.emit(assign(r21E3, r21CF, 0x03));


                        body.instructions = f21E4_parent_instructions;
                        body.emit(f21E4);

                        /* END IF */

                        body.emit(assign(r21D1, r21E3, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f21DB->else_instructions;

                        body.emit(assign(r21D1, r21D0, 0x03));


                     body.instructions = f21DB_parent_instructions;
                     body.emit(f21DB);

                     /* END IF */

                     body.emit(assign(r20EF, r21D1, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f21CC->else_instructions;

                     ir_variable *const r21E6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r21E6);
                     ir_expression *const r21E7 = bit_xor(r1F56, body.constant(1u));
                     ir_expression *const r21E8 = lshift(r21E7, body.constant(int(31)));
                     body.emit(assign(r21E6, add(r21E8, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r21E6, body.constant(0u), 0x01));

                     body.emit(assign(r20EF, r21E6, 0x03));


                  body.instructions = f21CC_parent_instructions;
                  body.emit(f21CC);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f21CA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r21EA = equal(r20F8, body.constant(int(0)));
                  ir_if *f21E9 = new(mem_ctx) ir_if(operand(r21EA).val);
                  exec_list *const f21E9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f21E9->then_instructions;

                     body.emit(assign(r20F0, add(r20F0, body.constant(int(1))), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f21E9->else_instructions;

                     body.emit(assign(r20F5, bit_or(r20F5, body.constant(1073741824u)), 0x01));


                  body.instructions = f21E9_parent_instructions;
                  body.emit(f21E9);

                  /* END IF */

                  ir_variable *const r21EB = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r21EB, neg(r20F0), 0x01));

                  ir_variable *const r21EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r21EC);
                  ir_variable *const r21ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r21ED);
                  ir_variable *const r21EE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r21EF = neg(r21EB);
                  body.emit(assign(r21EE, bit_and(r21EF, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r21F1 = equal(r21EB, body.constant(int(0)));
                  ir_if *f21F0 = new(mem_ctx) ir_if(operand(r21F1).val);
                  exec_list *const f21F0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f21F0->then_instructions;

                     body.emit(assign(r21EC, r20FC, 0x01));

                     body.emit(assign(r21ED, r20F5, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f21F0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r21F3 = less(r21EB, body.constant(int(32)));
                     ir_if *f21F2 = new(mem_ctx) ir_if(operand(r21F3).val);
                     exec_list *const f21F2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f21F2->then_instructions;

                        ir_expression *const r21F4 = lshift(r20F5, r21EE);
                        ir_expression *const r21F5 = rshift(r20FC, r21EB);
                        ir_expression *const r21F6 = bit_or(r21F4, r21F5);
                        ir_expression *const r21F7 = lshift(r20FC, r21EE);
                        ir_expression *const r21F8 = nequal(r21F7, body.constant(0u));
                        ir_expression *const r21F9 = expr(ir_unop_b2i, r21F8);
                        ir_expression *const r21FA = expr(ir_unop_i2u, r21F9);
                        body.emit(assign(r21EC, bit_or(r21F6, r21FA), 0x01));

                        body.emit(assign(r21ED, rshift(r20F5, r21EB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f21F2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r21FC = equal(r21EB, body.constant(int(32)));
                        ir_if *f21FB = new(mem_ctx) ir_if(operand(r21FC).val);
                        exec_list *const f21FB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f21FB->then_instructions;

                           ir_expression *const r21FD = nequal(r20FC, body.constant(0u));
                           ir_expression *const r21FE = expr(ir_unop_b2i, r21FD);
                           ir_expression *const r21FF = expr(ir_unop_i2u, r21FE);
                           body.emit(assign(r21EC, bit_or(r20F5, r21FF), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f21FB->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2201 = less(r21EB, body.constant(int(64)));
                           ir_if *f2200 = new(mem_ctx) ir_if(operand(r2201).val);
                           exec_list *const f2200_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2200->then_instructions;

                              ir_expression *const r2202 = bit_and(r21EB, body.constant(int(31)));
                              ir_expression *const r2203 = rshift(r20F5, r2202);
                              ir_expression *const r2204 = lshift(r20F5, r21EE);
                              ir_expression *const r2205 = bit_or(r2204, r20FC);
                              ir_expression *const r2206 = nequal(r2205, body.constant(0u));
                              ir_expression *const r2207 = expr(ir_unop_b2i, r2206);
                              ir_expression *const r2208 = expr(ir_unop_i2u, r2207);
                              body.emit(assign(r21EC, bit_or(r2203, r2208), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2200->else_instructions;

                              ir_expression *const r2209 = bit_or(r20F5, r20FC);
                              ir_expression *const r220A = nequal(r2209, body.constant(0u));
                              ir_expression *const r220B = expr(ir_unop_b2i, r220A);
                              body.emit(assign(r21EC, expr(ir_unop_i2u, r220B), 0x01));


                           body.instructions = f2200_parent_instructions;
                           body.emit(f2200);

                           /* END IF */


                        body.instructions = f21FB_parent_instructions;
                        body.emit(f21FB);

                        /* END IF */

                        body.emit(assign(r21ED, body.constant(0u), 0x01));


                     body.instructions = f21F2_parent_instructions;
                     body.emit(f21F2);

                     /* END IF */


                  body.instructions = f21F0_parent_instructions;
                  body.emit(f21F0);

                  /* END IF */

                  body.emit(assign(r20F5, r21ED, 0x01));

                  body.emit(assign(r20F6, r21EC, 0x01));

                  body.emit(assign(r20F3, bit_or(r20F3, body.constant(1073741824u)), 0x01));

                  ir_variable *const r220C = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r220D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r220D, sub(r20F4, r21EC), 0x01));

                  ir_expression *const r220E = sub(r20F3, r21ED);
                  ir_expression *const r220F = less(r20F4, r21EC);
                  ir_expression *const r2210 = expr(ir_unop_b2i, r220F);
                  ir_expression *const r2211 = expr(ir_unop_i2u, r2210);
                  body.emit(assign(r220C, sub(r220E, r2211), 0x01));

                  body.emit(assign(r20EE, bit_xor(r1F56, body.constant(1u)), 0x01));

                  body.emit(assign(r20F7, body.constant(int(1022)), 0x01));

                  ir_variable *const r2212 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r2212, body.constant(int(1012)), 0x01));

                  ir_variable *const r2213 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r2213, r220C, 0x01));

                  ir_variable *const r2214 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r2214, r220D, 0x01));

                  ir_variable *const r2215 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r2215);
                  ir_variable *const r2216 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2216);
                  /* IF CONDITION */
                  ir_expression *const r2218 = equal(r220C, body.constant(0u));
                  ir_if *f2217 = new(mem_ctx) ir_if(operand(r2218).val);
                  exec_list *const f2217_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2217->then_instructions;

                     body.emit(assign(r2213, r220D, 0x01));

                     body.emit(assign(r2214, body.constant(0u), 0x01));

                     body.emit(assign(r2212, body.constant(int(980)), 0x01));


                  body.instructions = f2217_parent_instructions;
                  body.emit(f2217);

                  /* END IF */

                  ir_variable *const r2219 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r2219, r2213, 0x01));

                  ir_variable *const r221A = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r221B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r221B);
                  /* IF CONDITION */
                  ir_expression *const r221D = equal(r2213, body.constant(0u));
                  ir_if *f221C = new(mem_ctx) ir_if(operand(r221D).val);
                  exec_list *const f221C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f221C->then_instructions;

                     body.emit(assign(r221A, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f221C->else_instructions;

                     body.emit(assign(r221B, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r221F = bit_and(r2213, body.constant(4294901760u));
                     ir_expression *const r2220 = equal(r221F, body.constant(0u));
                     ir_if *f221E = new(mem_ctx) ir_if(operand(r2220).val);
                     exec_list *const f221E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f221E->then_instructions;

                        body.emit(assign(r221B, body.constant(int(16)), 0x01));

                        body.emit(assign(r2219, lshift(r2213, body.constant(int(16))), 0x01));


                     body.instructions = f221E_parent_instructions;
                     body.emit(f221E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2222 = bit_and(r2219, body.constant(4278190080u));
                     ir_expression *const r2223 = equal(r2222, body.constant(0u));
                     ir_if *f2221 = new(mem_ctx) ir_if(operand(r2223).val);
                     exec_list *const f2221_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2221->then_instructions;

                        body.emit(assign(r221B, add(r221B, body.constant(int(8))), 0x01));

                        body.emit(assign(r2219, lshift(r2219, body.constant(int(8))), 0x01));


                     body.instructions = f2221_parent_instructions;
                     body.emit(f2221);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2225 = bit_and(r2219, body.constant(4026531840u));
                     ir_expression *const r2226 = equal(r2225, body.constant(0u));
                     ir_if *f2224 = new(mem_ctx) ir_if(operand(r2226).val);
                     exec_list *const f2224_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2224->then_instructions;

                        body.emit(assign(r221B, add(r221B, body.constant(int(4))), 0x01));

                        body.emit(assign(r2219, lshift(r2219, body.constant(int(4))), 0x01));


                     body.instructions = f2224_parent_instructions;
                     body.emit(f2224);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2228 = bit_and(r2219, body.constant(3221225472u));
                     ir_expression *const r2229 = equal(r2228, body.constant(0u));
                     ir_if *f2227 = new(mem_ctx) ir_if(operand(r2229).val);
                     exec_list *const f2227_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2227->then_instructions;

                        body.emit(assign(r221B, add(r221B, body.constant(int(2))), 0x01));

                        body.emit(assign(r2219, lshift(r2219, body.constant(int(2))), 0x01));


                     body.instructions = f2227_parent_instructions;
                     body.emit(f2227);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r222B = bit_and(r2219, body.constant(2147483648u));
                     ir_expression *const r222C = equal(r222B, body.constant(0u));
                     ir_if *f222A = new(mem_ctx) ir_if(operand(r222C).val);
                     exec_list *const f222A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f222A->then_instructions;

                        body.emit(assign(r221B, add(r221B, body.constant(int(1))), 0x01));


                     body.instructions = f222A_parent_instructions;
                     body.emit(f222A);

                     /* END IF */

                     body.emit(assign(r221A, r221B, 0x01));


                  body.instructions = f221C_parent_instructions;
                  body.emit(f221C);

                  /* END IF */

                  body.emit(assign(r2216, add(r221A, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r222E = lequal(body.constant(int(0)), r2216);
                  ir_if *f222D = new(mem_ctx) ir_if(operand(r222E).val);
                  exec_list *const f222D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f222D->then_instructions;

                     body.emit(assign(r2215, body.constant(0u), 0x01));

                     ir_variable *const r222F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r222F, lshift(r2214, r2216), 0x01));

                     ir_variable *const r2230 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2232 = equal(r2216, body.constant(int(0)));
                     ir_if *f2231 = new(mem_ctx) ir_if(operand(r2232).val);
                     exec_list *const f2231_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2231->then_instructions;

                        body.emit(assign(r2230, r2213, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2231->else_instructions;

                        ir_expression *const r2233 = lshift(r2213, r2216);
                        ir_expression *const r2234 = neg(r2216);
                        ir_expression *const r2235 = bit_and(r2234, body.constant(int(31)));
                        ir_expression *const r2236 = rshift(r2214, r2235);
                        body.emit(assign(r2230, bit_or(r2233, r2236), 0x01));


                     body.instructions = f2231_parent_instructions;
                     body.emit(f2231);

                     /* END IF */

                     body.emit(assign(r2213, r2230, 0x01));

                     body.emit(assign(r2214, r222F, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f222D->else_instructions;

                     ir_variable *const r2237 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2237, body.constant(0u), 0x01));

                     ir_variable *const r2238 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2238, neg(r2216), 0x01));

                     ir_variable *const r2239 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2239);
                     ir_variable *const r223A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r223A);
                     ir_variable *const r223B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r223B);
                     ir_variable *const r223C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r223D = neg(r2238);
                     body.emit(assign(r223C, bit_and(r223D, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r223F = equal(r2238, body.constant(int(0)));
                     ir_if *f223E = new(mem_ctx) ir_if(operand(r223F).val);
                     exec_list *const f223E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f223E->then_instructions;

                        body.emit(assign(r2239, r2237, 0x01));

                        body.emit(assign(r223A, r2214, 0x01));

                        body.emit(assign(r223B, r2213, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f223E->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2241 = less(r2238, body.constant(int(32)));
                        ir_if *f2240 = new(mem_ctx) ir_if(operand(r2241).val);
                        exec_list *const f2240_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2240->then_instructions;

                           body.emit(assign(r2239, lshift(r2214, r223C), 0x01));

                           ir_expression *const r2242 = lshift(r2213, r223C);
                           ir_expression *const r2243 = rshift(r2214, r2238);
                           body.emit(assign(r223A, bit_or(r2242, r2243), 0x01));

                           body.emit(assign(r223B, rshift(r2213, r2238), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2240->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2245 = equal(r2238, body.constant(int(32)));
                           ir_if *f2244 = new(mem_ctx) ir_if(operand(r2245).val);
                           exec_list *const f2244_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2244->then_instructions;

                              body.emit(assign(r2239, r2214, 0x01));

                              body.emit(assign(r223A, r2213, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2244->else_instructions;

                              body.emit(assign(r2237, bit_or(body.constant(0u), r2214), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2247 = less(r2238, body.constant(int(64)));
                              ir_if *f2246 = new(mem_ctx) ir_if(operand(r2247).val);
                              exec_list *const f2246_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2246->then_instructions;

                                 body.emit(assign(r2239, lshift(r2213, r223C), 0x01));

                                 ir_expression *const r2248 = bit_and(r2238, body.constant(int(31)));
                                 body.emit(assign(r223A, rshift(r2213, r2248), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2246->else_instructions;

                                 ir_variable *const r2249 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r224B = equal(r2238, body.constant(int(64)));
                                 ir_if *f224A = new(mem_ctx) ir_if(operand(r224B).val);
                                 exec_list *const f224A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f224A->then_instructions;

                                    body.emit(assign(r2249, r2213, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f224A->else_instructions;

                                    ir_expression *const r224C = nequal(r2213, body.constant(0u));
                                    ir_expression *const r224D = expr(ir_unop_b2i, r224C);
                                    body.emit(assign(r2249, expr(ir_unop_i2u, r224D), 0x01));


                                 body.instructions = f224A_parent_instructions;
                                 body.emit(f224A);

                                 /* END IF */

                                 body.emit(assign(r2239, r2249, 0x01));

                                 body.emit(assign(r223A, body.constant(0u), 0x01));


                              body.instructions = f2246_parent_instructions;
                              body.emit(f2246);

                              /* END IF */


                           body.instructions = f2244_parent_instructions;
                           body.emit(f2244);

                           /* END IF */

                           body.emit(assign(r223B, body.constant(0u), 0x01));


                        body.instructions = f2240_parent_instructions;
                        body.emit(f2240);

                        /* END IF */

                        ir_expression *const r224E = nequal(r2237, body.constant(0u));
                        ir_expression *const r224F = expr(ir_unop_b2i, r224E);
                        ir_expression *const r2250 = expr(ir_unop_i2u, r224F);
                        body.emit(assign(r2239, bit_or(r2239, r2250), 0x01));


                     body.instructions = f223E_parent_instructions;
                     body.emit(f223E);

                     /* END IF */

                     body.emit(assign(r2213, r223B, 0x01));

                     body.emit(assign(r2214, r223A, 0x01));

                     body.emit(assign(r2215, r2239, 0x01));


                  body.instructions = f222D_parent_instructions;
                  body.emit(f222D);

                  /* END IF */

                  body.emit(assign(r2212, sub(r2212, r2216), 0x01));

                  ir_variable *const r2251 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r2251, r2212, 0x01));

                  ir_variable *const r2252 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r2252, r2213, 0x01));

                  ir_variable *const r2253 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r2253, r2214, 0x01));

                  ir_variable *const r2254 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r2254, r2215, 0x01));

                  ir_variable *const r2255 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r2255, body.constant(true), 0x01));

                  ir_variable *const r2256 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2257 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r2257);
                  ir_expression *const r2258 = expr(ir_unop_u2i, r2215);
                  body.emit(assign(r2257, less(r2258, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r225A = lequal(body.constant(int(2045)), r2212);
                  ir_if *f2259 = new(mem_ctx) ir_if(operand(r225A).val);
                  exec_list *const f2259_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2259->then_instructions;

                     ir_variable *const r225B = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r225D = less(body.constant(int(2045)), r2212);
                     ir_if *f225C = new(mem_ctx) ir_if(operand(r225D).val);
                     exec_list *const f225C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f225C->then_instructions;

                        body.emit(assign(r225B, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f225C->else_instructions;

                        ir_variable *const r225E = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2260 = equal(r2212, body.constant(int(2045)));
                        ir_if *f225F = new(mem_ctx) ir_if(operand(r2260).val);
                        exec_list *const f225F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f225F->then_instructions;

                           ir_expression *const r2261 = equal(body.constant(2097151u), r2213);
                           ir_expression *const r2262 = equal(body.constant(4294967295u), r2214);
                           body.emit(assign(r225E, logic_and(r2261, r2262), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f225F->else_instructions;

                           body.emit(assign(r225E, body.constant(false), 0x01));


                        body.instructions = f225F_parent_instructions;
                        body.emit(f225F);

                        /* END IF */

                        body.emit(assign(r225B, logic_and(r225E, r2257), 0x01));


                     body.instructions = f225C_parent_instructions;
                     body.emit(f225C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2263 = new(mem_ctx) ir_if(operand(r225B).val);
                     exec_list *const f2263_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2263->then_instructions;

                        ir_variable *const r2264 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2264);
                        ir_expression *const r2265 = lshift(r20EE, body.constant(int(31)));
                        body.emit(assign(r2264, add(r2265, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r2264, body.constant(0u), 0x01));

                        body.emit(assign(r2256, r2264, 0x03));

                        body.emit(assign(r2255, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2263->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2267 = less(r2212, body.constant(int(0)));
                        ir_if *f2266 = new(mem_ctx) ir_if(operand(r2267).val);
                        exec_list *const f2266_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2266->then_instructions;

                           ir_variable *const r2268 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2268, r2215, 0x01));

                           ir_variable *const r2269 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2269, neg(r2212), 0x01));

                           ir_variable *const r226A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r226A);
                           ir_variable *const r226B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r226B);
                           ir_variable *const r226C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r226C);
                           ir_variable *const r226D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r226E = neg(r2269);
                           body.emit(assign(r226D, bit_and(r226E, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2270 = equal(r2269, body.constant(int(0)));
                           ir_if *f226F = new(mem_ctx) ir_if(operand(r2270).val);
                           exec_list *const f226F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f226F->then_instructions;

                              body.emit(assign(r226A, r2215, 0x01));

                              body.emit(assign(r226B, r2214, 0x01));

                              body.emit(assign(r226C, r2213, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f226F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2272 = less(r2269, body.constant(int(32)));
                              ir_if *f2271 = new(mem_ctx) ir_if(operand(r2272).val);
                              exec_list *const f2271_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2271->then_instructions;

                                 body.emit(assign(r226A, lshift(r2214, r226D), 0x01));

                                 ir_expression *const r2273 = lshift(r2213, r226D);
                                 ir_expression *const r2274 = rshift(r2214, r2269);
                                 body.emit(assign(r226B, bit_or(r2273, r2274), 0x01));

                                 body.emit(assign(r226C, rshift(r2213, r2269), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2271->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2276 = equal(r2269, body.constant(int(32)));
                                 ir_if *f2275 = new(mem_ctx) ir_if(operand(r2276).val);
                                 exec_list *const f2275_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2275->then_instructions;

                                    body.emit(assign(r226A, r2214, 0x01));

                                    body.emit(assign(r226B, r2213, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2275->else_instructions;

                                    body.emit(assign(r2268, bit_or(r2215, r2214), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2278 = less(r2269, body.constant(int(64)));
                                    ir_if *f2277 = new(mem_ctx) ir_if(operand(r2278).val);
                                    exec_list *const f2277_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2277->then_instructions;

                                       body.emit(assign(r226A, lshift(r2213, r226D), 0x01));

                                       ir_expression *const r2279 = bit_and(r2269, body.constant(int(31)));
                                       body.emit(assign(r226B, rshift(r2213, r2279), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2277->else_instructions;

                                       ir_variable *const r227A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r227C = equal(r2269, body.constant(int(64)));
                                       ir_if *f227B = new(mem_ctx) ir_if(operand(r227C).val);
                                       exec_list *const f227B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f227B->then_instructions;

                                          body.emit(assign(r227A, r2213, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f227B->else_instructions;

                                          ir_expression *const r227D = nequal(r2213, body.constant(0u));
                                          ir_expression *const r227E = expr(ir_unop_b2i, r227D);
                                          body.emit(assign(r227A, expr(ir_unop_i2u, r227E), 0x01));


                                       body.instructions = f227B_parent_instructions;
                                       body.emit(f227B);

                                       /* END IF */

                                       body.emit(assign(r226A, r227A, 0x01));

                                       body.emit(assign(r226B, body.constant(0u), 0x01));


                                    body.instructions = f2277_parent_instructions;
                                    body.emit(f2277);

                                    /* END IF */


                                 body.instructions = f2275_parent_instructions;
                                 body.emit(f2275);

                                 /* END IF */

                                 body.emit(assign(r226C, body.constant(0u), 0x01));


                              body.instructions = f2271_parent_instructions;
                              body.emit(f2271);

                              /* END IF */

                              ir_expression *const r227F = nequal(r2268, body.constant(0u));
                              ir_expression *const r2280 = expr(ir_unop_b2i, r227F);
                              ir_expression *const r2281 = expr(ir_unop_i2u, r2280);
                              body.emit(assign(r226A, bit_or(r226A, r2281), 0x01));


                           body.instructions = f226F_parent_instructions;
                           body.emit(f226F);

                           /* END IF */

                           body.emit(assign(r2252, r226C, 0x01));

                           body.emit(assign(r2253, r226B, 0x01));

                           body.emit(assign(r2254, r226A, 0x01));

                           body.emit(assign(r2251, body.constant(int(0)), 0x01));

                           body.emit(assign(r2257, less(r226A, body.constant(0u)), 0x01));


                        body.instructions = f2266_parent_instructions;
                        body.emit(f2266);

                        /* END IF */


                     body.instructions = f2263_parent_instructions;
                     body.emit(f2263);

                     /* END IF */


                  body.instructions = f2259_parent_instructions;
                  body.emit(f2259);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2282 = new(mem_ctx) ir_if(operand(r2255).val);
                  exec_list *const f2282_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2282->then_instructions;

                     /* IF CONDITION */
                     ir_if *f2283 = new(mem_ctx) ir_if(operand(r2257).val);
                     exec_list *const f2283_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2283->then_instructions;

                        ir_variable *const r2284 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r2284, add(r2253, body.constant(1u)), 0x01));

                        ir_expression *const r2285 = less(r2284, r2253);
                        ir_expression *const r2286 = expr(ir_unop_b2i, r2285);
                        ir_expression *const r2287 = expr(ir_unop_i2u, r2286);
                        body.emit(assign(r2252, add(r2252, r2287), 0x01));

                        ir_expression *const r2288 = equal(r2254, body.constant(0u));
                        ir_expression *const r2289 = expr(ir_unop_b2i, r2288);
                        ir_expression *const r228A = expr(ir_unop_i2u, r2289);
                        ir_expression *const r228B = add(r2254, r228A);
                        ir_expression *const r228C = bit_and(r228B, body.constant(1u));
                        ir_expression *const r228D = expr(ir_unop_bit_not, r228C);
                        body.emit(assign(r2253, bit_and(r2284, r228D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2283->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r228F = bit_or(r2252, r2253);
                        ir_expression *const r2290 = equal(r228F, body.constant(0u));
                        ir_if *f228E = new(mem_ctx) ir_if(operand(r2290).val);
                        exec_list *const f228E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f228E->then_instructions;

                           body.emit(assign(r2251, body.constant(int(0)), 0x01));


                        body.instructions = f228E_parent_instructions;
                        body.emit(f228E);

                        /* END IF */


                     body.instructions = f2283_parent_instructions;
                     body.emit(f2283);

                     /* END IF */

                     ir_variable *const r2291 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2291);
                     ir_expression *const r2292 = lshift(r20EE, body.constant(int(31)));
                     ir_expression *const r2293 = expr(ir_unop_i2u, r2251);
                     ir_expression *const r2294 = lshift(r2293, body.constant(int(20)));
                     ir_expression *const r2295 = add(r2292, r2294);
                     body.emit(assign(r2291, add(r2295, r2252), 0x02));

                     body.emit(assign(r2291, r2253, 0x01));

                     body.emit(assign(r2256, r2291, 0x03));

                     body.emit(assign(r2255, body.constant(false), 0x01));


                  body.instructions = f2282_parent_instructions;
                  body.emit(f2282);

                  /* END IF */

                  body.emit(assign(r20EF, r2256, 0x03));


               body.instructions = f21CA_parent_instructions;
               body.emit(f21CA);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f21C8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2297 = equal(r20F8, body.constant(int(2047)));
               ir_if *f2296 = new(mem_ctx) ir_if(operand(r2297).val);
               exec_list *const f2296_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2296->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2299 = bit_or(r20F5, r20F6);
                  ir_expression *const r229A = bit_or(r20F3, r20F4);
                  ir_expression *const r229B = bit_or(r2299, r229A);
                  ir_expression *const r229C = nequal(r229B, body.constant(0u));
                  ir_if *f2298 = new(mem_ctx) ir_if(operand(r229C).val);
                  exec_list *const f2298_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2298->then_instructions;

                     ir_variable *const r229D = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r229D, swizzle_x(r1F1F), 0x01));

                     ir_variable *const r229E = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r229E, body.constant(0u), 0x01));

                     ir_variable *const r229F = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r22A0 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r22A1 = rshift(swizzle_y(r1F1F), body.constant(int(19)));
                     ir_expression *const r22A2 = bit_and(r22A1, body.constant(4095u));
                     ir_expression *const r22A3 = equal(r22A2, body.constant(4094u));
                     ir_expression *const r22A4 = nequal(swizzle_x(r1F1F), body.constant(0u));
                     ir_expression *const r22A5 = bit_and(swizzle_y(r1F1F), body.constant(524287u));
                     ir_expression *const r22A6 = nequal(r22A5, body.constant(0u));
                     ir_expression *const r22A7 = logic_or(r22A4, r22A6);
                     body.emit(assign(r22A0, logic_and(r22A3, r22A7), 0x01));

                     ir_variable *const r22A8 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r22A8, body.constant(false), 0x01));

                     body.emit(assign(r229D, bit_or(swizzle_y(r1F1F), body.constant(524288u)), 0x02));

                     body.emit(assign(r229E, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r22AA = lshift(swizzle_y(r1F1F), body.constant(int(1)));
                     ir_expression *const r22AB = lequal(body.constant(4292870144u), r22AA);
                     ir_expression *const r22AC = nequal(swizzle_x(r1F1F), body.constant(0u));
                     ir_expression *const r22AD = bit_and(swizzle_y(r1F1F), body.constant(1048575u));
                     ir_expression *const r22AE = nequal(r22AD, body.constant(0u));
                     ir_expression *const r22AF = logic_or(r22AC, r22AE);
                     ir_expression *const r22B0 = logic_and(r22AB, r22AF);
                     ir_if *f22A9 = new(mem_ctx) ir_if(operand(r22B0).val);
                     exec_list *const f22A9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22A9->then_instructions;

                        ir_variable *const r22B1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r22B3 = body.constant(false);
                        ir_if *f22B2 = new(mem_ctx) ir_if(operand(r22B3).val);
                        exec_list *const f22B2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22B2->then_instructions;

                           body.emit(assign(r22B1, r229E, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22B2->else_instructions;

                           body.emit(assign(r22B1, r229D, 0x03));


                        body.instructions = f22B2_parent_instructions;
                        body.emit(f22B2);

                        /* END IF */

                        body.emit(assign(r229F, r22B1, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f22A9->else_instructions;

                        body.emit(assign(r229F, r229E, 0x03));


                     body.instructions = f22A9_parent_instructions;
                     body.emit(f22A9);

                     /* END IF */

                     body.emit(assign(r20EF, r229F, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2298->else_instructions;

                     ir_constant_data r22B4_data;
                     memset(&r22B4_data, 0, sizeof(ir_constant_data));
                     r22B4_data.u[0] = 4294967295;
                     r22B4_data.u[1] = 4294967295;
                     ir_constant *const r22B4 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r22B4_data);
                     body.emit(assign(r20EF, r22B4, 0x03));


                  body.instructions = f2298_parent_instructions;
                  body.emit(f2298);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2296->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r22B6 = equal(r20F8, body.constant(int(0)));
                  ir_if *f22B5 = new(mem_ctx) ir_if(operand(r22B6).val);
                  exec_list *const f22B5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f22B5->then_instructions;

                     body.emit(assign(r20F2, body.constant(int(1)), 0x01));

                     body.emit(assign(r20F1, body.constant(int(1)), 0x01));


                  body.instructions = f22B5_parent_instructions;
                  body.emit(f22B5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r22B8 = less(r20F3, r20F5);
                  ir_if *f22B7 = new(mem_ctx) ir_if(operand(r22B8).val);
                  exec_list *const f22B7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f22B7->then_instructions;

                     ir_variable *const r22B9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r22BA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r22BA, sub(r20F6, r20F4), 0x01));

                     ir_expression *const r22BB = sub(r20F5, r20F3);
                     ir_expression *const r22BC = less(r20F6, r20F4);
                     ir_expression *const r22BD = expr(ir_unop_b2i, r22BC);
                     ir_expression *const r22BE = expr(ir_unop_i2u, r22BD);
                     body.emit(assign(r22B9, sub(r22BB, r22BE), 0x01));

                     body.emit(assign(r20F7, add(r20F2, body.constant(int(-1))), 0x01));

                     ir_variable *const r22BF = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r22BF, add(r20F7, body.constant(int(-10))), 0x01));

                     ir_variable *const r22C0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r22C0, r22B9, 0x01));

                     ir_variable *const r22C1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r22C1, r22BA, 0x01));

                     ir_variable *const r22C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r22C2);
                     ir_variable *const r22C3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r22C3);
                     /* IF CONDITION */
                     ir_expression *const r22C5 = equal(r22B9, body.constant(0u));
                     ir_if *f22C4 = new(mem_ctx) ir_if(operand(r22C5).val);
                     exec_list *const f22C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22C4->then_instructions;

                        body.emit(assign(r22C0, r22BA, 0x01));

                        body.emit(assign(r22C1, body.constant(0u), 0x01));

                        body.emit(assign(r22BF, add(r22BF, body.constant(int(-32))), 0x01));


                     body.instructions = f22C4_parent_instructions;
                     body.emit(f22C4);

                     /* END IF */

                     ir_variable *const r22C6 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r22C6, r22C0, 0x01));

                     ir_variable *const r22C7 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r22C8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r22C8);
                     /* IF CONDITION */
                     ir_expression *const r22CA = equal(r22C0, body.constant(0u));
                     ir_if *f22C9 = new(mem_ctx) ir_if(operand(r22CA).val);
                     exec_list *const f22C9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22C9->then_instructions;

                        body.emit(assign(r22C7, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f22C9->else_instructions;

                        body.emit(assign(r22C8, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r22CC = bit_and(r22C0, body.constant(4294901760u));
                        ir_expression *const r22CD = equal(r22CC, body.constant(0u));
                        ir_if *f22CB = new(mem_ctx) ir_if(operand(r22CD).val);
                        exec_list *const f22CB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22CB->then_instructions;

                           body.emit(assign(r22C8, body.constant(int(16)), 0x01));

                           body.emit(assign(r22C6, lshift(r22C0, body.constant(int(16))), 0x01));


                        body.instructions = f22CB_parent_instructions;
                        body.emit(f22CB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r22CF = bit_and(r22C6, body.constant(4278190080u));
                        ir_expression *const r22D0 = equal(r22CF, body.constant(0u));
                        ir_if *f22CE = new(mem_ctx) ir_if(operand(r22D0).val);
                        exec_list *const f22CE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22CE->then_instructions;

                           body.emit(assign(r22C8, add(r22C8, body.constant(int(8))), 0x01));

                           body.emit(assign(r22C6, lshift(r22C6, body.constant(int(8))), 0x01));


                        body.instructions = f22CE_parent_instructions;
                        body.emit(f22CE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r22D2 = bit_and(r22C6, body.constant(4026531840u));
                        ir_expression *const r22D3 = equal(r22D2, body.constant(0u));
                        ir_if *f22D1 = new(mem_ctx) ir_if(operand(r22D3).val);
                        exec_list *const f22D1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22D1->then_instructions;

                           body.emit(assign(r22C8, add(r22C8, body.constant(int(4))), 0x01));

                           body.emit(assign(r22C6, lshift(r22C6, body.constant(int(4))), 0x01));


                        body.instructions = f22D1_parent_instructions;
                        body.emit(f22D1);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r22D5 = bit_and(r22C6, body.constant(3221225472u));
                        ir_expression *const r22D6 = equal(r22D5, body.constant(0u));
                        ir_if *f22D4 = new(mem_ctx) ir_if(operand(r22D6).val);
                        exec_list *const f22D4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22D4->then_instructions;

                           body.emit(assign(r22C8, add(r22C8, body.constant(int(2))), 0x01));

                           body.emit(assign(r22C6, lshift(r22C6, body.constant(int(2))), 0x01));


                        body.instructions = f22D4_parent_instructions;
                        body.emit(f22D4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r22D8 = bit_and(r22C6, body.constant(2147483648u));
                        ir_expression *const r22D9 = equal(r22D8, body.constant(0u));
                        ir_if *f22D7 = new(mem_ctx) ir_if(operand(r22D9).val);
                        exec_list *const f22D7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22D7->then_instructions;

                           body.emit(assign(r22C8, add(r22C8, body.constant(int(1))), 0x01));


                        body.instructions = f22D7_parent_instructions;
                        body.emit(f22D7);

                        /* END IF */

                        body.emit(assign(r22C7, r22C8, 0x01));


                     body.instructions = f22C9_parent_instructions;
                     body.emit(f22C9);

                     /* END IF */

                     body.emit(assign(r22C3, add(r22C7, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r22DB = lequal(body.constant(int(0)), r22C3);
                     ir_if *f22DA = new(mem_ctx) ir_if(operand(r22DB).val);
                     exec_list *const f22DA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22DA->then_instructions;

                        body.emit(assign(r22C2, body.constant(0u), 0x01));

                        ir_variable *const r22DC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r22DC, lshift(r22C1, r22C3), 0x01));

                        ir_variable *const r22DD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r22DF = equal(r22C3, body.constant(int(0)));
                        ir_if *f22DE = new(mem_ctx) ir_if(operand(r22DF).val);
                        exec_list *const f22DE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22DE->then_instructions;

                           body.emit(assign(r22DD, r22C0, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22DE->else_instructions;

                           ir_expression *const r22E0 = lshift(r22C0, r22C3);
                           ir_expression *const r22E1 = neg(r22C3);
                           ir_expression *const r22E2 = bit_and(r22E1, body.constant(int(31)));
                           ir_expression *const r22E3 = rshift(r22C1, r22E2);
                           body.emit(assign(r22DD, bit_or(r22E0, r22E3), 0x01));


                        body.instructions = f22DE_parent_instructions;
                        body.emit(f22DE);

                        /* END IF */

                        body.emit(assign(r22C0, r22DD, 0x01));

                        body.emit(assign(r22C1, r22DC, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f22DA->else_instructions;

                        ir_variable *const r22E4 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r22E4, body.constant(0u), 0x01));

                        ir_variable *const r22E5 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r22E5, neg(r22C3), 0x01));

                        ir_variable *const r22E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r22E6);
                        ir_variable *const r22E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r22E7);
                        ir_variable *const r22E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r22E8);
                        ir_variable *const r22E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r22EA = neg(r22E5);
                        body.emit(assign(r22E9, bit_and(r22EA, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r22EC = equal(r22E5, body.constant(int(0)));
                        ir_if *f22EB = new(mem_ctx) ir_if(operand(r22EC).val);
                        exec_list *const f22EB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22EB->then_instructions;

                           body.emit(assign(r22E6, r22E4, 0x01));

                           body.emit(assign(r22E7, r22C1, 0x01));

                           body.emit(assign(r22E8, r22C0, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22EB->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r22EE = less(r22E5, body.constant(int(32)));
                           ir_if *f22ED = new(mem_ctx) ir_if(operand(r22EE).val);
                           exec_list *const f22ED_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22ED->then_instructions;

                              body.emit(assign(r22E6, lshift(r22C1, r22E9), 0x01));

                              ir_expression *const r22EF = lshift(r22C0, r22E9);
                              ir_expression *const r22F0 = rshift(r22C1, r22E5);
                              body.emit(assign(r22E7, bit_or(r22EF, r22F0), 0x01));

                              body.emit(assign(r22E8, rshift(r22C0, r22E5), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f22ED->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r22F2 = equal(r22E5, body.constant(int(32)));
                              ir_if *f22F1 = new(mem_ctx) ir_if(operand(r22F2).val);
                              exec_list *const f22F1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f22F1->then_instructions;

                                 body.emit(assign(r22E6, r22C1, 0x01));

                                 body.emit(assign(r22E7, r22C0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f22F1->else_instructions;

                                 body.emit(assign(r22E4, bit_or(body.constant(0u), r22C1), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r22F4 = less(r22E5, body.constant(int(64)));
                                 ir_if *f22F3 = new(mem_ctx) ir_if(operand(r22F4).val);
                                 exec_list *const f22F3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f22F3->then_instructions;

                                    body.emit(assign(r22E6, lshift(r22C0, r22E9), 0x01));

                                    ir_expression *const r22F5 = bit_and(r22E5, body.constant(int(31)));
                                    body.emit(assign(r22E7, rshift(r22C0, r22F5), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f22F3->else_instructions;

                                    ir_variable *const r22F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r22F8 = equal(r22E5, body.constant(int(64)));
                                    ir_if *f22F7 = new(mem_ctx) ir_if(operand(r22F8).val);
                                    exec_list *const f22F7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f22F7->then_instructions;

                                       body.emit(assign(r22F6, r22C0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f22F7->else_instructions;

                                       ir_expression *const r22F9 = nequal(r22C0, body.constant(0u));
                                       ir_expression *const r22FA = expr(ir_unop_b2i, r22F9);
                                       body.emit(assign(r22F6, expr(ir_unop_i2u, r22FA), 0x01));


                                    body.instructions = f22F7_parent_instructions;
                                    body.emit(f22F7);

                                    /* END IF */

                                    body.emit(assign(r22E6, r22F6, 0x01));

                                    body.emit(assign(r22E7, body.constant(0u), 0x01));


                                 body.instructions = f22F3_parent_instructions;
                                 body.emit(f22F3);

                                 /* END IF */


                              body.instructions = f22F1_parent_instructions;
                              body.emit(f22F1);

                              /* END IF */

                              body.emit(assign(r22E8, body.constant(0u), 0x01));


                           body.instructions = f22ED_parent_instructions;
                           body.emit(f22ED);

                           /* END IF */

                           ir_expression *const r22FB = nequal(r22E4, body.constant(0u));
                           ir_expression *const r22FC = expr(ir_unop_b2i, r22FB);
                           ir_expression *const r22FD = expr(ir_unop_i2u, r22FC);
                           body.emit(assign(r22E6, bit_or(r22E6, r22FD), 0x01));


                        body.instructions = f22EB_parent_instructions;
                        body.emit(f22EB);

                        /* END IF */

                        body.emit(assign(r22C0, r22E8, 0x01));

                        body.emit(assign(r22C1, r22E7, 0x01));

                        body.emit(assign(r22C2, r22E6, 0x01));


                     body.instructions = f22DA_parent_instructions;
                     body.emit(f22DA);

                     /* END IF */

                     body.emit(assign(r22BF, sub(r22BF, r22C3), 0x01));

                     ir_variable *const r22FE = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r22FE, r22BF, 0x01));

                     ir_variable *const r22FF = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r22FF, r22C0, 0x01));

                     ir_variable *const r2300 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2300, r22C1, 0x01));

                     ir_variable *const r2301 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2301, r22C2, 0x01));

                     ir_variable *const r2302 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2302, body.constant(true), 0x01));

                     ir_variable *const r2303 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2304 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2304);
                     ir_expression *const r2305 = expr(ir_unop_u2i, r22C2);
                     body.emit(assign(r2304, less(r2305, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2307 = lequal(body.constant(int(2045)), r22BF);
                     ir_if *f2306 = new(mem_ctx) ir_if(operand(r2307).val);
                     exec_list *const f2306_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2306->then_instructions;

                        ir_variable *const r2308 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r230A = less(body.constant(int(2045)), r22BF);
                        ir_if *f2309 = new(mem_ctx) ir_if(operand(r230A).val);
                        exec_list *const f2309_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2309->then_instructions;

                           body.emit(assign(r2308, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2309->else_instructions;

                           ir_variable *const r230B = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r230D = equal(r22BF, body.constant(int(2045)));
                           ir_if *f230C = new(mem_ctx) ir_if(operand(r230D).val);
                           exec_list *const f230C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f230C->then_instructions;

                              ir_expression *const r230E = equal(body.constant(2097151u), r22C0);
                              ir_expression *const r230F = equal(body.constant(4294967295u), r22C1);
                              body.emit(assign(r230B, logic_and(r230E, r230F), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f230C->else_instructions;

                              body.emit(assign(r230B, body.constant(false), 0x01));


                           body.instructions = f230C_parent_instructions;
                           body.emit(f230C);

                           /* END IF */

                           body.emit(assign(r2308, logic_and(r230B, r2304), 0x01));


                        body.instructions = f2309_parent_instructions;
                        body.emit(f2309);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2310 = new(mem_ctx) ir_if(operand(r2308).val);
                        exec_list *const f2310_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2310->then_instructions;

                           ir_variable *const r2311 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2311);
                           ir_expression *const r2312 = lshift(r20EE, body.constant(int(31)));
                           body.emit(assign(r2311, add(r2312, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2311, body.constant(0u), 0x01));

                           body.emit(assign(r2303, r2311, 0x03));

                           body.emit(assign(r2302, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2310->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2314 = less(r22BF, body.constant(int(0)));
                           ir_if *f2313 = new(mem_ctx) ir_if(operand(r2314).val);
                           exec_list *const f2313_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2313->then_instructions;

                              ir_variable *const r2315 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2315, r22C2, 0x01));

                              ir_variable *const r2316 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2316, neg(r22BF), 0x01));

                              ir_variable *const r2317 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2317);
                              ir_variable *const r2318 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2318);
                              ir_variable *const r2319 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2319);
                              ir_variable *const r231A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r231B = neg(r2316);
                              body.emit(assign(r231A, bit_and(r231B, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r231D = equal(r2316, body.constant(int(0)));
                              ir_if *f231C = new(mem_ctx) ir_if(operand(r231D).val);
                              exec_list *const f231C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f231C->then_instructions;

                                 body.emit(assign(r2317, r22C2, 0x01));

                                 body.emit(assign(r2318, r22C1, 0x01));

                                 body.emit(assign(r2319, r22C0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f231C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r231F = less(r2316, body.constant(int(32)));
                                 ir_if *f231E = new(mem_ctx) ir_if(operand(r231F).val);
                                 exec_list *const f231E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f231E->then_instructions;

                                    body.emit(assign(r2317, lshift(r22C1, r231A), 0x01));

                                    ir_expression *const r2320 = lshift(r22C0, r231A);
                                    ir_expression *const r2321 = rshift(r22C1, r2316);
                                    body.emit(assign(r2318, bit_or(r2320, r2321), 0x01));

                                    body.emit(assign(r2319, rshift(r22C0, r2316), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f231E->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2323 = equal(r2316, body.constant(int(32)));
                                    ir_if *f2322 = new(mem_ctx) ir_if(operand(r2323).val);
                                    exec_list *const f2322_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2322->then_instructions;

                                       body.emit(assign(r2317, r22C1, 0x01));

                                       body.emit(assign(r2318, r22C0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2322->else_instructions;

                                       body.emit(assign(r2315, bit_or(r22C2, r22C1), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2325 = less(r2316, body.constant(int(64)));
                                       ir_if *f2324 = new(mem_ctx) ir_if(operand(r2325).val);
                                       exec_list *const f2324_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2324->then_instructions;

                                          body.emit(assign(r2317, lshift(r22C0, r231A), 0x01));

                                          ir_expression *const r2326 = bit_and(r2316, body.constant(int(31)));
                                          body.emit(assign(r2318, rshift(r22C0, r2326), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2324->else_instructions;

                                          ir_variable *const r2327 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2329 = equal(r2316, body.constant(int(64)));
                                          ir_if *f2328 = new(mem_ctx) ir_if(operand(r2329).val);
                                          exec_list *const f2328_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2328->then_instructions;

                                             body.emit(assign(r2327, r22C0, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2328->else_instructions;

                                             ir_expression *const r232A = nequal(r22C0, body.constant(0u));
                                             ir_expression *const r232B = expr(ir_unop_b2i, r232A);
                                             body.emit(assign(r2327, expr(ir_unop_i2u, r232B), 0x01));


                                          body.instructions = f2328_parent_instructions;
                                          body.emit(f2328);

                                          /* END IF */

                                          body.emit(assign(r2317, r2327, 0x01));

                                          body.emit(assign(r2318, body.constant(0u), 0x01));


                                       body.instructions = f2324_parent_instructions;
                                       body.emit(f2324);

                                       /* END IF */


                                    body.instructions = f2322_parent_instructions;
                                    body.emit(f2322);

                                    /* END IF */

                                    body.emit(assign(r2319, body.constant(0u), 0x01));


                                 body.instructions = f231E_parent_instructions;
                                 body.emit(f231E);

                                 /* END IF */

                                 ir_expression *const r232C = nequal(r2315, body.constant(0u));
                                 ir_expression *const r232D = expr(ir_unop_b2i, r232C);
                                 ir_expression *const r232E = expr(ir_unop_i2u, r232D);
                                 body.emit(assign(r2317, bit_or(r2317, r232E), 0x01));


                              body.instructions = f231C_parent_instructions;
                              body.emit(f231C);

                              /* END IF */

                              body.emit(assign(r22FF, r2319, 0x01));

                              body.emit(assign(r2300, r2318, 0x01));

                              body.emit(assign(r2301, r2317, 0x01));

                              body.emit(assign(r22FE, body.constant(int(0)), 0x01));

                              body.emit(assign(r2304, less(r2317, body.constant(0u)), 0x01));


                           body.instructions = f2313_parent_instructions;
                           body.emit(f2313);

                           /* END IF */


                        body.instructions = f2310_parent_instructions;
                        body.emit(f2310);

                        /* END IF */


                     body.instructions = f2306_parent_instructions;
                     body.emit(f2306);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f232F = new(mem_ctx) ir_if(operand(r2302).val);
                     exec_list *const f232F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f232F->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2330 = new(mem_ctx) ir_if(operand(r2304).val);
                        exec_list *const f2330_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2330->then_instructions;

                           ir_variable *const r2331 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2331, add(r2300, body.constant(1u)), 0x01));

                           ir_expression *const r2332 = less(r2331, r2300);
                           ir_expression *const r2333 = expr(ir_unop_b2i, r2332);
                           ir_expression *const r2334 = expr(ir_unop_i2u, r2333);
                           body.emit(assign(r22FF, add(r22FF, r2334), 0x01));

                           ir_expression *const r2335 = equal(r2301, body.constant(0u));
                           ir_expression *const r2336 = expr(ir_unop_b2i, r2335);
                           ir_expression *const r2337 = expr(ir_unop_i2u, r2336);
                           ir_expression *const r2338 = add(r2301, r2337);
                           ir_expression *const r2339 = bit_and(r2338, body.constant(1u));
                           ir_expression *const r233A = expr(ir_unop_bit_not, r2339);
                           body.emit(assign(r2300, bit_and(r2331, r233A), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2330->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r233C = bit_or(r22FF, r2300);
                           ir_expression *const r233D = equal(r233C, body.constant(0u));
                           ir_if *f233B = new(mem_ctx) ir_if(operand(r233D).val);
                           exec_list *const f233B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f233B->then_instructions;

                              body.emit(assign(r22FE, body.constant(int(0)), 0x01));


                           body.instructions = f233B_parent_instructions;
                           body.emit(f233B);

                           /* END IF */


                        body.instructions = f2330_parent_instructions;
                        body.emit(f2330);

                        /* END IF */

                        ir_variable *const r233E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r233E);
                        ir_expression *const r233F = lshift(r20EE, body.constant(int(31)));
                        ir_expression *const r2340 = expr(ir_unop_i2u, r22FE);
                        ir_expression *const r2341 = lshift(r2340, body.constant(int(20)));
                        ir_expression *const r2342 = add(r233F, r2341);
                        body.emit(assign(r233E, add(r2342, r22FF), 0x02));

                        body.emit(assign(r233E, r2300, 0x01));

                        body.emit(assign(r2303, r233E, 0x03));

                        body.emit(assign(r2302, body.constant(false), 0x01));


                     body.instructions = f232F_parent_instructions;
                     body.emit(f232F);

                     /* END IF */

                     body.emit(assign(r20EF, r2303, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f22B7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2344 = less(r20F5, r20F3);
                     ir_if *f2343 = new(mem_ctx) ir_if(operand(r2344).val);
                     exec_list *const f2343_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2343->then_instructions;

                        ir_variable *const r2345 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r2346 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2346, sub(r20F4, r20F6), 0x01));

                        ir_expression *const r2347 = sub(r20F3, r20F5);
                        ir_expression *const r2348 = less(r20F4, r20F6);
                        ir_expression *const r2349 = expr(ir_unop_b2i, r2348);
                        ir_expression *const r234A = expr(ir_unop_i2u, r2349);
                        body.emit(assign(r2345, sub(r2347, r234A), 0x01));

                        body.emit(assign(r20EE, bit_xor(r20EE, body.constant(1u)), 0x01));

                        body.emit(assign(r20F7, add(r20F1, body.constant(int(-1))), 0x01));

                        ir_variable *const r234B = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r234B, add(r20F7, body.constant(int(-10))), 0x01));

                        ir_variable *const r234C = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r234C, r2345, 0x01));

                        ir_variable *const r234D = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r234D, r2346, 0x01));

                        ir_variable *const r234E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r234E);
                        ir_variable *const r234F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r234F);
                        /* IF CONDITION */
                        ir_expression *const r2351 = equal(r2345, body.constant(0u));
                        ir_if *f2350 = new(mem_ctx) ir_if(operand(r2351).val);
                        exec_list *const f2350_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2350->then_instructions;

                           body.emit(assign(r234C, r2346, 0x01));

                           body.emit(assign(r234D, body.constant(0u), 0x01));

                           body.emit(assign(r234B, add(r234B, body.constant(int(-32))), 0x01));


                        body.instructions = f2350_parent_instructions;
                        body.emit(f2350);

                        /* END IF */

                        ir_variable *const r2352 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2352, r234C, 0x01));

                        ir_variable *const r2353 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r2354 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2354);
                        /* IF CONDITION */
                        ir_expression *const r2356 = equal(r234C, body.constant(0u));
                        ir_if *f2355 = new(mem_ctx) ir_if(operand(r2356).val);
                        exec_list *const f2355_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2355->then_instructions;

                           body.emit(assign(r2353, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2355->else_instructions;

                           body.emit(assign(r2354, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2358 = bit_and(r234C, body.constant(4294901760u));
                           ir_expression *const r2359 = equal(r2358, body.constant(0u));
                           ir_if *f2357 = new(mem_ctx) ir_if(operand(r2359).val);
                           exec_list *const f2357_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2357->then_instructions;

                              body.emit(assign(r2354, body.constant(int(16)), 0x01));

                              body.emit(assign(r2352, lshift(r234C, body.constant(int(16))), 0x01));


                           body.instructions = f2357_parent_instructions;
                           body.emit(f2357);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r235B = bit_and(r2352, body.constant(4278190080u));
                           ir_expression *const r235C = equal(r235B, body.constant(0u));
                           ir_if *f235A = new(mem_ctx) ir_if(operand(r235C).val);
                           exec_list *const f235A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f235A->then_instructions;

                              body.emit(assign(r2354, add(r2354, body.constant(int(8))), 0x01));

                              body.emit(assign(r2352, lshift(r2352, body.constant(int(8))), 0x01));


                           body.instructions = f235A_parent_instructions;
                           body.emit(f235A);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r235E = bit_and(r2352, body.constant(4026531840u));
                           ir_expression *const r235F = equal(r235E, body.constant(0u));
                           ir_if *f235D = new(mem_ctx) ir_if(operand(r235F).val);
                           exec_list *const f235D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f235D->then_instructions;

                              body.emit(assign(r2354, add(r2354, body.constant(int(4))), 0x01));

                              body.emit(assign(r2352, lshift(r2352, body.constant(int(4))), 0x01));


                           body.instructions = f235D_parent_instructions;
                           body.emit(f235D);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2361 = bit_and(r2352, body.constant(3221225472u));
                           ir_expression *const r2362 = equal(r2361, body.constant(0u));
                           ir_if *f2360 = new(mem_ctx) ir_if(operand(r2362).val);
                           exec_list *const f2360_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2360->then_instructions;

                              body.emit(assign(r2354, add(r2354, body.constant(int(2))), 0x01));

                              body.emit(assign(r2352, lshift(r2352, body.constant(int(2))), 0x01));


                           body.instructions = f2360_parent_instructions;
                           body.emit(f2360);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2364 = bit_and(r2352, body.constant(2147483648u));
                           ir_expression *const r2365 = equal(r2364, body.constant(0u));
                           ir_if *f2363 = new(mem_ctx) ir_if(operand(r2365).val);
                           exec_list *const f2363_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2363->then_instructions;

                              body.emit(assign(r2354, add(r2354, body.constant(int(1))), 0x01));


                           body.instructions = f2363_parent_instructions;
                           body.emit(f2363);

                           /* END IF */

                           body.emit(assign(r2353, r2354, 0x01));


                        body.instructions = f2355_parent_instructions;
                        body.emit(f2355);

                        /* END IF */

                        body.emit(assign(r234F, add(r2353, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2367 = lequal(body.constant(int(0)), r234F);
                        ir_if *f2366 = new(mem_ctx) ir_if(operand(r2367).val);
                        exec_list *const f2366_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2366->then_instructions;

                           body.emit(assign(r234E, body.constant(0u), 0x01));

                           ir_variable *const r2368 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2368, lshift(r234D, r234F), 0x01));

                           ir_variable *const r2369 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r236B = equal(r234F, body.constant(int(0)));
                           ir_if *f236A = new(mem_ctx) ir_if(operand(r236B).val);
                           exec_list *const f236A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f236A->then_instructions;

                              body.emit(assign(r2369, r234C, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f236A->else_instructions;

                              ir_expression *const r236C = lshift(r234C, r234F);
                              ir_expression *const r236D = neg(r234F);
                              ir_expression *const r236E = bit_and(r236D, body.constant(int(31)));
                              ir_expression *const r236F = rshift(r234D, r236E);
                              body.emit(assign(r2369, bit_or(r236C, r236F), 0x01));


                           body.instructions = f236A_parent_instructions;
                           body.emit(f236A);

                           /* END IF */

                           body.emit(assign(r234C, r2369, 0x01));

                           body.emit(assign(r234D, r2368, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2366->else_instructions;

                           ir_variable *const r2370 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2370, body.constant(0u), 0x01));

                           ir_variable *const r2371 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2371, neg(r234F), 0x01));

                           ir_variable *const r2372 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2372);
                           ir_variable *const r2373 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2373);
                           ir_variable *const r2374 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2374);
                           ir_variable *const r2375 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2376 = neg(r2371);
                           body.emit(assign(r2375, bit_and(r2376, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2378 = equal(r2371, body.constant(int(0)));
                           ir_if *f2377 = new(mem_ctx) ir_if(operand(r2378).val);
                           exec_list *const f2377_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2377->then_instructions;

                              body.emit(assign(r2372, r2370, 0x01));

                              body.emit(assign(r2373, r234D, 0x01));

                              body.emit(assign(r2374, r234C, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2377->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r237A = less(r2371, body.constant(int(32)));
                              ir_if *f2379 = new(mem_ctx) ir_if(operand(r237A).val);
                              exec_list *const f2379_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2379->then_instructions;

                                 body.emit(assign(r2372, lshift(r234D, r2375), 0x01));

                                 ir_expression *const r237B = lshift(r234C, r2375);
                                 ir_expression *const r237C = rshift(r234D, r2371);
                                 body.emit(assign(r2373, bit_or(r237B, r237C), 0x01));

                                 body.emit(assign(r2374, rshift(r234C, r2371), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2379->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r237E = equal(r2371, body.constant(int(32)));
                                 ir_if *f237D = new(mem_ctx) ir_if(operand(r237E).val);
                                 exec_list *const f237D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f237D->then_instructions;

                                    body.emit(assign(r2372, r234D, 0x01));

                                    body.emit(assign(r2373, r234C, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f237D->else_instructions;

                                    body.emit(assign(r2370, bit_or(body.constant(0u), r234D), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2380 = less(r2371, body.constant(int(64)));
                                    ir_if *f237F = new(mem_ctx) ir_if(operand(r2380).val);
                                    exec_list *const f237F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f237F->then_instructions;

                                       body.emit(assign(r2372, lshift(r234C, r2375), 0x01));

                                       ir_expression *const r2381 = bit_and(r2371, body.constant(int(31)));
                                       body.emit(assign(r2373, rshift(r234C, r2381), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f237F->else_instructions;

                                       ir_variable *const r2382 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2384 = equal(r2371, body.constant(int(64)));
                                       ir_if *f2383 = new(mem_ctx) ir_if(operand(r2384).val);
                                       exec_list *const f2383_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2383->then_instructions;

                                          body.emit(assign(r2382, r234C, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2383->else_instructions;

                                          ir_expression *const r2385 = nequal(r234C, body.constant(0u));
                                          ir_expression *const r2386 = expr(ir_unop_b2i, r2385);
                                          body.emit(assign(r2382, expr(ir_unop_i2u, r2386), 0x01));


                                       body.instructions = f2383_parent_instructions;
                                       body.emit(f2383);

                                       /* END IF */

                                       body.emit(assign(r2372, r2382, 0x01));

                                       body.emit(assign(r2373, body.constant(0u), 0x01));


                                    body.instructions = f237F_parent_instructions;
                                    body.emit(f237F);

                                    /* END IF */


                                 body.instructions = f237D_parent_instructions;
                                 body.emit(f237D);

                                 /* END IF */

                                 body.emit(assign(r2374, body.constant(0u), 0x01));


                              body.instructions = f2379_parent_instructions;
                              body.emit(f2379);

                              /* END IF */

                              ir_expression *const r2387 = nequal(r2370, body.constant(0u));
                              ir_expression *const r2388 = expr(ir_unop_b2i, r2387);
                              ir_expression *const r2389 = expr(ir_unop_i2u, r2388);
                              body.emit(assign(r2372, bit_or(r2372, r2389), 0x01));


                           body.instructions = f2377_parent_instructions;
                           body.emit(f2377);

                           /* END IF */

                           body.emit(assign(r234C, r2374, 0x01));

                           body.emit(assign(r234D, r2373, 0x01));

                           body.emit(assign(r234E, r2372, 0x01));


                        body.instructions = f2366_parent_instructions;
                        body.emit(f2366);

                        /* END IF */

                        body.emit(assign(r234B, sub(r234B, r234F), 0x01));

                        ir_variable *const r238A = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r238A, r234B, 0x01));

                        ir_variable *const r238B = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r238B, r234C, 0x01));

                        ir_variable *const r238C = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r238C, r234D, 0x01));

                        ir_variable *const r238D = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r238D, r234E, 0x01));

                        ir_variable *const r238E = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r238E, body.constant(true), 0x01));

                        ir_variable *const r238F = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r2390 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r2390);
                        ir_expression *const r2391 = expr(ir_unop_u2i, r234E);
                        body.emit(assign(r2390, less(r2391, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2393 = lequal(body.constant(int(2045)), r234B);
                        ir_if *f2392 = new(mem_ctx) ir_if(operand(r2393).val);
                        exec_list *const f2392_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2392->then_instructions;

                           ir_variable *const r2394 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2396 = less(body.constant(int(2045)), r234B);
                           ir_if *f2395 = new(mem_ctx) ir_if(operand(r2396).val);
                           exec_list *const f2395_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2395->then_instructions;

                              body.emit(assign(r2394, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2395->else_instructions;

                              ir_variable *const r2397 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2399 = equal(r234B, body.constant(int(2045)));
                              ir_if *f2398 = new(mem_ctx) ir_if(operand(r2399).val);
                              exec_list *const f2398_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2398->then_instructions;

                                 ir_expression *const r239A = equal(body.constant(2097151u), r234C);
                                 ir_expression *const r239B = equal(body.constant(4294967295u), r234D);
                                 body.emit(assign(r2397, logic_and(r239A, r239B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2398->else_instructions;

                                 body.emit(assign(r2397, body.constant(false), 0x01));


                              body.instructions = f2398_parent_instructions;
                              body.emit(f2398);

                              /* END IF */

                              body.emit(assign(r2394, logic_and(r2397, r2390), 0x01));


                           body.instructions = f2395_parent_instructions;
                           body.emit(f2395);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f239C = new(mem_ctx) ir_if(operand(r2394).val);
                           exec_list *const f239C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f239C->then_instructions;

                              ir_variable *const r239D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r239D);
                              ir_expression *const r239E = lshift(r20EE, body.constant(int(31)));
                              body.emit(assign(r239D, add(r239E, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r239D, body.constant(0u), 0x01));

                              body.emit(assign(r238F, r239D, 0x03));

                              body.emit(assign(r238E, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f239C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r23A0 = less(r234B, body.constant(int(0)));
                              ir_if *f239F = new(mem_ctx) ir_if(operand(r23A0).val);
                              exec_list *const f239F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f239F->then_instructions;

                                 ir_variable *const r23A1 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r23A1, r234E, 0x01));

                                 ir_variable *const r23A2 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r23A2, neg(r234B), 0x01));

                                 ir_variable *const r23A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r23A3);
                                 ir_variable *const r23A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r23A4);
                                 ir_variable *const r23A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r23A5);
                                 ir_variable *const r23A6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r23A7 = neg(r23A2);
                                 body.emit(assign(r23A6, bit_and(r23A7, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r23A9 = equal(r23A2, body.constant(int(0)));
                                 ir_if *f23A8 = new(mem_ctx) ir_if(operand(r23A9).val);
                                 exec_list *const f23A8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f23A8->then_instructions;

                                    body.emit(assign(r23A3, r234E, 0x01));

                                    body.emit(assign(r23A4, r234D, 0x01));

                                    body.emit(assign(r23A5, r234C, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f23A8->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r23AB = less(r23A2, body.constant(int(32)));
                                    ir_if *f23AA = new(mem_ctx) ir_if(operand(r23AB).val);
                                    exec_list *const f23AA_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f23AA->then_instructions;

                                       body.emit(assign(r23A3, lshift(r234D, r23A6), 0x01));

                                       ir_expression *const r23AC = lshift(r234C, r23A6);
                                       ir_expression *const r23AD = rshift(r234D, r23A2);
                                       body.emit(assign(r23A4, bit_or(r23AC, r23AD), 0x01));

                                       body.emit(assign(r23A5, rshift(r234C, r23A2), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f23AA->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r23AF = equal(r23A2, body.constant(int(32)));
                                       ir_if *f23AE = new(mem_ctx) ir_if(operand(r23AF).val);
                                       exec_list *const f23AE_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f23AE->then_instructions;

                                          body.emit(assign(r23A3, r234D, 0x01));

                                          body.emit(assign(r23A4, r234C, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f23AE->else_instructions;

                                          body.emit(assign(r23A1, bit_or(r234E, r234D), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r23B1 = less(r23A2, body.constant(int(64)));
                                          ir_if *f23B0 = new(mem_ctx) ir_if(operand(r23B1).val);
                                          exec_list *const f23B0_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f23B0->then_instructions;

                                             body.emit(assign(r23A3, lshift(r234C, r23A6), 0x01));

                                             ir_expression *const r23B2 = bit_and(r23A2, body.constant(int(31)));
                                             body.emit(assign(r23A4, rshift(r234C, r23B2), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f23B0->else_instructions;

                                             ir_variable *const r23B3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r23B5 = equal(r23A2, body.constant(int(64)));
                                             ir_if *f23B4 = new(mem_ctx) ir_if(operand(r23B5).val);
                                             exec_list *const f23B4_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f23B4->then_instructions;

                                                body.emit(assign(r23B3, r234C, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f23B4->else_instructions;

                                                ir_expression *const r23B6 = nequal(r234C, body.constant(0u));
                                                ir_expression *const r23B7 = expr(ir_unop_b2i, r23B6);
                                                body.emit(assign(r23B3, expr(ir_unop_i2u, r23B7), 0x01));


                                             body.instructions = f23B4_parent_instructions;
                                             body.emit(f23B4);

                                             /* END IF */

                                             body.emit(assign(r23A3, r23B3, 0x01));

                                             body.emit(assign(r23A4, body.constant(0u), 0x01));


                                          body.instructions = f23B0_parent_instructions;
                                          body.emit(f23B0);

                                          /* END IF */


                                       body.instructions = f23AE_parent_instructions;
                                       body.emit(f23AE);

                                       /* END IF */

                                       body.emit(assign(r23A5, body.constant(0u), 0x01));


                                    body.instructions = f23AA_parent_instructions;
                                    body.emit(f23AA);

                                    /* END IF */

                                    ir_expression *const r23B8 = nequal(r23A1, body.constant(0u));
                                    ir_expression *const r23B9 = expr(ir_unop_b2i, r23B8);
                                    ir_expression *const r23BA = expr(ir_unop_i2u, r23B9);
                                    body.emit(assign(r23A3, bit_or(r23A3, r23BA), 0x01));


                                 body.instructions = f23A8_parent_instructions;
                                 body.emit(f23A8);

                                 /* END IF */

                                 body.emit(assign(r238B, r23A5, 0x01));

                                 body.emit(assign(r238C, r23A4, 0x01));

                                 body.emit(assign(r238D, r23A3, 0x01));

                                 body.emit(assign(r238A, body.constant(int(0)), 0x01));

                                 body.emit(assign(r2390, less(r23A3, body.constant(0u)), 0x01));


                              body.instructions = f239F_parent_instructions;
                              body.emit(f239F);

                              /* END IF */


                           body.instructions = f239C_parent_instructions;
                           body.emit(f239C);

                           /* END IF */


                        body.instructions = f2392_parent_instructions;
                        body.emit(f2392);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f23BB = new(mem_ctx) ir_if(operand(r238E).val);
                        exec_list *const f23BB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f23BB->then_instructions;

                           /* IF CONDITION */
                           ir_if *f23BC = new(mem_ctx) ir_if(operand(r2390).val);
                           exec_list *const f23BC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f23BC->then_instructions;

                              ir_variable *const r23BD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r23BD, add(r238C, body.constant(1u)), 0x01));

                              ir_expression *const r23BE = less(r23BD, r238C);
                              ir_expression *const r23BF = expr(ir_unop_b2i, r23BE);
                              ir_expression *const r23C0 = expr(ir_unop_i2u, r23BF);
                              body.emit(assign(r238B, add(r238B, r23C0), 0x01));

                              ir_expression *const r23C1 = equal(r238D, body.constant(0u));
                              ir_expression *const r23C2 = expr(ir_unop_b2i, r23C1);
                              ir_expression *const r23C3 = expr(ir_unop_i2u, r23C2);
                              ir_expression *const r23C4 = add(r238D, r23C3);
                              ir_expression *const r23C5 = bit_and(r23C4, body.constant(1u));
                              ir_expression *const r23C6 = expr(ir_unop_bit_not, r23C5);
                              body.emit(assign(r238C, bit_and(r23BD, r23C6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f23BC->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r23C8 = bit_or(r238B, r238C);
                              ir_expression *const r23C9 = equal(r23C8, body.constant(0u));
                              ir_if *f23C7 = new(mem_ctx) ir_if(operand(r23C9).val);
                              exec_list *const f23C7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f23C7->then_instructions;

                                 body.emit(assign(r238A, body.constant(int(0)), 0x01));


                              body.instructions = f23C7_parent_instructions;
                              body.emit(f23C7);

                              /* END IF */


                           body.instructions = f23BC_parent_instructions;
                           body.emit(f23BC);

                           /* END IF */

                           ir_variable *const r23CA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r23CA);
                           ir_expression *const r23CB = lshift(r20EE, body.constant(int(31)));
                           ir_expression *const r23CC = expr(ir_unop_i2u, r238A);
                           ir_expression *const r23CD = lshift(r23CC, body.constant(int(20)));
                           ir_expression *const r23CE = add(r23CB, r23CD);
                           body.emit(assign(r23CA, add(r23CE, r238B), 0x02));

                           body.emit(assign(r23CA, r238C, 0x01));

                           body.emit(assign(r238F, r23CA, 0x03));

                           body.emit(assign(r238E, body.constant(false), 0x01));


                        body.instructions = f23BB_parent_instructions;
                        body.emit(f23BB);

                        /* END IF */

                        body.emit(assign(r20EF, r238F, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2343->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r23D0 = less(r20F4, r20F6);
                        ir_if *f23CF = new(mem_ctx) ir_if(operand(r23D0).val);
                        exec_list *const f23CF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f23CF->then_instructions;

                           ir_variable *const r23D1 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r23D2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r23D2, sub(r20F6, r20F4), 0x01));

                           ir_expression *const r23D3 = sub(r20F5, r20F3);
                           ir_expression *const r23D4 = less(r20F6, r20F4);
                           ir_expression *const r23D5 = expr(ir_unop_b2i, r23D4);
                           ir_expression *const r23D6 = expr(ir_unop_i2u, r23D5);
                           body.emit(assign(r23D1, sub(r23D3, r23D6), 0x01));

                           body.emit(assign(r20F7, add(r20F2, body.constant(int(-1))), 0x01));

                           ir_variable *const r23D7 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r23D7, add(r20F7, body.constant(int(-10))), 0x01));

                           ir_variable *const r23D8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r23D8, r23D1, 0x01));

                           ir_variable *const r23D9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r23D9, r23D2, 0x01));

                           ir_variable *const r23DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r23DA);
                           ir_variable *const r23DB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r23DB);
                           /* IF CONDITION */
                           ir_expression *const r23DD = equal(r23D1, body.constant(0u));
                           ir_if *f23DC = new(mem_ctx) ir_if(operand(r23DD).val);
                           exec_list *const f23DC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f23DC->then_instructions;

                              body.emit(assign(r23D8, r23D2, 0x01));

                              body.emit(assign(r23D9, body.constant(0u), 0x01));

                              body.emit(assign(r23D7, add(r23D7, body.constant(int(-32))), 0x01));


                           body.instructions = f23DC_parent_instructions;
                           body.emit(f23DC);

                           /* END IF */

                           ir_variable *const r23DE = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r23DE, r23D8, 0x01));

                           ir_variable *const r23DF = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r23E0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r23E0);
                           /* IF CONDITION */
                           ir_expression *const r23E2 = equal(r23D8, body.constant(0u));
                           ir_if *f23E1 = new(mem_ctx) ir_if(operand(r23E2).val);
                           exec_list *const f23E1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f23E1->then_instructions;

                              body.emit(assign(r23DF, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f23E1->else_instructions;

                              body.emit(assign(r23E0, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r23E4 = bit_and(r23D8, body.constant(4294901760u));
                              ir_expression *const r23E5 = equal(r23E4, body.constant(0u));
                              ir_if *f23E3 = new(mem_ctx) ir_if(operand(r23E5).val);
                              exec_list *const f23E3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f23E3->then_instructions;

                                 body.emit(assign(r23E0, body.constant(int(16)), 0x01));

                                 body.emit(assign(r23DE, lshift(r23D8, body.constant(int(16))), 0x01));


                              body.instructions = f23E3_parent_instructions;
                              body.emit(f23E3);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r23E7 = bit_and(r23DE, body.constant(4278190080u));
                              ir_expression *const r23E8 = equal(r23E7, body.constant(0u));
                              ir_if *f23E6 = new(mem_ctx) ir_if(operand(r23E8).val);
                              exec_list *const f23E6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f23E6->then_instructions;

                                 body.emit(assign(r23E0, add(r23E0, body.constant(int(8))), 0x01));

                                 body.emit(assign(r23DE, lshift(r23DE, body.constant(int(8))), 0x01));


                              body.instructions = f23E6_parent_instructions;
                              body.emit(f23E6);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r23EA = bit_and(r23DE, body.constant(4026531840u));
                              ir_expression *const r23EB = equal(r23EA, body.constant(0u));
                              ir_if *f23E9 = new(mem_ctx) ir_if(operand(r23EB).val);
                              exec_list *const f23E9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f23E9->then_instructions;

                                 body.emit(assign(r23E0, add(r23E0, body.constant(int(4))), 0x01));

                                 body.emit(assign(r23DE, lshift(r23DE, body.constant(int(4))), 0x01));


                              body.instructions = f23E9_parent_instructions;
                              body.emit(f23E9);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r23ED = bit_and(r23DE, body.constant(3221225472u));
                              ir_expression *const r23EE = equal(r23ED, body.constant(0u));
                              ir_if *f23EC = new(mem_ctx) ir_if(operand(r23EE).val);
                              exec_list *const f23EC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f23EC->then_instructions;

                                 body.emit(assign(r23E0, add(r23E0, body.constant(int(2))), 0x01));

                                 body.emit(assign(r23DE, lshift(r23DE, body.constant(int(2))), 0x01));


                              body.instructions = f23EC_parent_instructions;
                              body.emit(f23EC);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r23F0 = bit_and(r23DE, body.constant(2147483648u));
                              ir_expression *const r23F1 = equal(r23F0, body.constant(0u));
                              ir_if *f23EF = new(mem_ctx) ir_if(operand(r23F1).val);
                              exec_list *const f23EF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f23EF->then_instructions;

                                 body.emit(assign(r23E0, add(r23E0, body.constant(int(1))), 0x01));


                              body.instructions = f23EF_parent_instructions;
                              body.emit(f23EF);

                              /* END IF */

                              body.emit(assign(r23DF, r23E0, 0x01));


                           body.instructions = f23E1_parent_instructions;
                           body.emit(f23E1);

                           /* END IF */

                           body.emit(assign(r23DB, add(r23DF, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r23F3 = lequal(body.constant(int(0)), r23DB);
                           ir_if *f23F2 = new(mem_ctx) ir_if(operand(r23F3).val);
                           exec_list *const f23F2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f23F2->then_instructions;

                              body.emit(assign(r23DA, body.constant(0u), 0x01));

                              ir_variable *const r23F4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r23F4, lshift(r23D9, r23DB), 0x01));

                              ir_variable *const r23F5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r23F7 = equal(r23DB, body.constant(int(0)));
                              ir_if *f23F6 = new(mem_ctx) ir_if(operand(r23F7).val);
                              exec_list *const f23F6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f23F6->then_instructions;

                                 body.emit(assign(r23F5, r23D8, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f23F6->else_instructions;

                                 ir_expression *const r23F8 = lshift(r23D8, r23DB);
                                 ir_expression *const r23F9 = neg(r23DB);
                                 ir_expression *const r23FA = bit_and(r23F9, body.constant(int(31)));
                                 ir_expression *const r23FB = rshift(r23D9, r23FA);
                                 body.emit(assign(r23F5, bit_or(r23F8, r23FB), 0x01));


                              body.instructions = f23F6_parent_instructions;
                              body.emit(f23F6);

                              /* END IF */

                              body.emit(assign(r23D8, r23F5, 0x01));

                              body.emit(assign(r23D9, r23F4, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f23F2->else_instructions;

                              ir_variable *const r23FC = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r23FC, body.constant(0u), 0x01));

                              ir_variable *const r23FD = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r23FD, neg(r23DB), 0x01));

                              ir_variable *const r23FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r23FE);
                              ir_variable *const r23FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r23FF);
                              ir_variable *const r2400 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2400);
                              ir_variable *const r2401 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2402 = neg(r23FD);
                              body.emit(assign(r2401, bit_and(r2402, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2404 = equal(r23FD, body.constant(int(0)));
                              ir_if *f2403 = new(mem_ctx) ir_if(operand(r2404).val);
                              exec_list *const f2403_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2403->then_instructions;

                                 body.emit(assign(r23FE, r23FC, 0x01));

                                 body.emit(assign(r23FF, r23D9, 0x01));

                                 body.emit(assign(r2400, r23D8, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2403->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2406 = less(r23FD, body.constant(int(32)));
                                 ir_if *f2405 = new(mem_ctx) ir_if(operand(r2406).val);
                                 exec_list *const f2405_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2405->then_instructions;

                                    body.emit(assign(r23FE, lshift(r23D9, r2401), 0x01));

                                    ir_expression *const r2407 = lshift(r23D8, r2401);
                                    ir_expression *const r2408 = rshift(r23D9, r23FD);
                                    body.emit(assign(r23FF, bit_or(r2407, r2408), 0x01));

                                    body.emit(assign(r2400, rshift(r23D8, r23FD), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2405->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r240A = equal(r23FD, body.constant(int(32)));
                                    ir_if *f2409 = new(mem_ctx) ir_if(operand(r240A).val);
                                    exec_list *const f2409_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2409->then_instructions;

                                       body.emit(assign(r23FE, r23D9, 0x01));

                                       body.emit(assign(r23FF, r23D8, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2409->else_instructions;

                                       body.emit(assign(r23FC, bit_or(body.constant(0u), r23D9), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r240C = less(r23FD, body.constant(int(64)));
                                       ir_if *f240B = new(mem_ctx) ir_if(operand(r240C).val);
                                       exec_list *const f240B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f240B->then_instructions;

                                          body.emit(assign(r23FE, lshift(r23D8, r2401), 0x01));

                                          ir_expression *const r240D = bit_and(r23FD, body.constant(int(31)));
                                          body.emit(assign(r23FF, rshift(r23D8, r240D), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f240B->else_instructions;

                                          ir_variable *const r240E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2410 = equal(r23FD, body.constant(int(64)));
                                          ir_if *f240F = new(mem_ctx) ir_if(operand(r2410).val);
                                          exec_list *const f240F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f240F->then_instructions;

                                             body.emit(assign(r240E, r23D8, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f240F->else_instructions;

                                             ir_expression *const r2411 = nequal(r23D8, body.constant(0u));
                                             ir_expression *const r2412 = expr(ir_unop_b2i, r2411);
                                             body.emit(assign(r240E, expr(ir_unop_i2u, r2412), 0x01));


                                          body.instructions = f240F_parent_instructions;
                                          body.emit(f240F);

                                          /* END IF */

                                          body.emit(assign(r23FE, r240E, 0x01));

                                          body.emit(assign(r23FF, body.constant(0u), 0x01));


                                       body.instructions = f240B_parent_instructions;
                                       body.emit(f240B);

                                       /* END IF */


                                    body.instructions = f2409_parent_instructions;
                                    body.emit(f2409);

                                    /* END IF */

                                    body.emit(assign(r2400, body.constant(0u), 0x01));


                                 body.instructions = f2405_parent_instructions;
                                 body.emit(f2405);

                                 /* END IF */

                                 ir_expression *const r2413 = nequal(r23FC, body.constant(0u));
                                 ir_expression *const r2414 = expr(ir_unop_b2i, r2413);
                                 ir_expression *const r2415 = expr(ir_unop_i2u, r2414);
                                 body.emit(assign(r23FE, bit_or(r23FE, r2415), 0x01));


                              body.instructions = f2403_parent_instructions;
                              body.emit(f2403);

                              /* END IF */

                              body.emit(assign(r23D8, r2400, 0x01));

                              body.emit(assign(r23D9, r23FF, 0x01));

                              body.emit(assign(r23DA, r23FE, 0x01));


                           body.instructions = f23F2_parent_instructions;
                           body.emit(f23F2);

                           /* END IF */

                           body.emit(assign(r23D7, sub(r23D7, r23DB), 0x01));

                           ir_variable *const r2416 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2416, r23D7, 0x01));

                           ir_variable *const r2417 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2417, r23D8, 0x01));

                           ir_variable *const r2418 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2418, r23D9, 0x01));

                           ir_variable *const r2419 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r2419, r23DA, 0x01));

                           ir_variable *const r241A = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r241A, body.constant(true), 0x01));

                           ir_variable *const r241B = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r241C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r241C);
                           ir_expression *const r241D = expr(ir_unop_u2i, r23DA);
                           body.emit(assign(r241C, less(r241D, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r241F = lequal(body.constant(int(2045)), r23D7);
                           ir_if *f241E = new(mem_ctx) ir_if(operand(r241F).val);
                           exec_list *const f241E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f241E->then_instructions;

                              ir_variable *const r2420 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2422 = less(body.constant(int(2045)), r23D7);
                              ir_if *f2421 = new(mem_ctx) ir_if(operand(r2422).val);
                              exec_list *const f2421_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2421->then_instructions;

                                 body.emit(assign(r2420, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2421->else_instructions;

                                 ir_variable *const r2423 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2425 = equal(r23D7, body.constant(int(2045)));
                                 ir_if *f2424 = new(mem_ctx) ir_if(operand(r2425).val);
                                 exec_list *const f2424_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2424->then_instructions;

                                    ir_expression *const r2426 = equal(body.constant(2097151u), r23D8);
                                    ir_expression *const r2427 = equal(body.constant(4294967295u), r23D9);
                                    body.emit(assign(r2423, logic_and(r2426, r2427), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2424->else_instructions;

                                    body.emit(assign(r2423, body.constant(false), 0x01));


                                 body.instructions = f2424_parent_instructions;
                                 body.emit(f2424);

                                 /* END IF */

                                 body.emit(assign(r2420, logic_and(r2423, r241C), 0x01));


                              body.instructions = f2421_parent_instructions;
                              body.emit(f2421);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2428 = new(mem_ctx) ir_if(operand(r2420).val);
                              exec_list *const f2428_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2428->then_instructions;

                                 ir_variable *const r2429 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2429);
                                 ir_expression *const r242A = lshift(r20EE, body.constant(int(31)));
                                 body.emit(assign(r2429, add(r242A, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r2429, body.constant(0u), 0x01));

                                 body.emit(assign(r241B, r2429, 0x03));

                                 body.emit(assign(r241A, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2428->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r242C = less(r23D7, body.constant(int(0)));
                                 ir_if *f242B = new(mem_ctx) ir_if(operand(r242C).val);
                                 exec_list *const f242B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f242B->then_instructions;

                                    ir_variable *const r242D = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r242D, r23DA, 0x01));

                                    ir_variable *const r242E = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r242E, neg(r23D7), 0x01));

                                    ir_variable *const r242F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r242F);
                                    ir_variable *const r2430 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r2430);
                                    ir_variable *const r2431 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2431);
                                    ir_variable *const r2432 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2433 = neg(r242E);
                                    body.emit(assign(r2432, bit_and(r2433, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2435 = equal(r242E, body.constant(int(0)));
                                    ir_if *f2434 = new(mem_ctx) ir_if(operand(r2435).val);
                                    exec_list *const f2434_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2434->then_instructions;

                                       body.emit(assign(r242F, r23DA, 0x01));

                                       body.emit(assign(r2430, r23D9, 0x01));

                                       body.emit(assign(r2431, r23D8, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2434->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2437 = less(r242E, body.constant(int(32)));
                                       ir_if *f2436 = new(mem_ctx) ir_if(operand(r2437).val);
                                       exec_list *const f2436_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2436->then_instructions;

                                          body.emit(assign(r242F, lshift(r23D9, r2432), 0x01));

                                          ir_expression *const r2438 = lshift(r23D8, r2432);
                                          ir_expression *const r2439 = rshift(r23D9, r242E);
                                          body.emit(assign(r2430, bit_or(r2438, r2439), 0x01));

                                          body.emit(assign(r2431, rshift(r23D8, r242E), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2436->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r243B = equal(r242E, body.constant(int(32)));
                                          ir_if *f243A = new(mem_ctx) ir_if(operand(r243B).val);
                                          exec_list *const f243A_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f243A->then_instructions;

                                             body.emit(assign(r242F, r23D9, 0x01));

                                             body.emit(assign(r2430, r23D8, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f243A->else_instructions;

                                             body.emit(assign(r242D, bit_or(r23DA, r23D9), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r243D = less(r242E, body.constant(int(64)));
                                             ir_if *f243C = new(mem_ctx) ir_if(operand(r243D).val);
                                             exec_list *const f243C_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f243C->then_instructions;

                                                body.emit(assign(r242F, lshift(r23D8, r2432), 0x01));

                                                ir_expression *const r243E = bit_and(r242E, body.constant(int(31)));
                                                body.emit(assign(r2430, rshift(r23D8, r243E), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f243C->else_instructions;

                                                ir_variable *const r243F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2441 = equal(r242E, body.constant(int(64)));
                                                ir_if *f2440 = new(mem_ctx) ir_if(operand(r2441).val);
                                                exec_list *const f2440_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2440->then_instructions;

                                                   body.emit(assign(r243F, r23D8, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2440->else_instructions;

                                                   ir_expression *const r2442 = nequal(r23D8, body.constant(0u));
                                                   ir_expression *const r2443 = expr(ir_unop_b2i, r2442);
                                                   body.emit(assign(r243F, expr(ir_unop_i2u, r2443), 0x01));


                                                body.instructions = f2440_parent_instructions;
                                                body.emit(f2440);

                                                /* END IF */

                                                body.emit(assign(r242F, r243F, 0x01));

                                                body.emit(assign(r2430, body.constant(0u), 0x01));


                                             body.instructions = f243C_parent_instructions;
                                             body.emit(f243C);

                                             /* END IF */


                                          body.instructions = f243A_parent_instructions;
                                          body.emit(f243A);

                                          /* END IF */

                                          body.emit(assign(r2431, body.constant(0u), 0x01));


                                       body.instructions = f2436_parent_instructions;
                                       body.emit(f2436);

                                       /* END IF */

                                       ir_expression *const r2444 = nequal(r242D, body.constant(0u));
                                       ir_expression *const r2445 = expr(ir_unop_b2i, r2444);
                                       ir_expression *const r2446 = expr(ir_unop_i2u, r2445);
                                       body.emit(assign(r242F, bit_or(r242F, r2446), 0x01));


                                    body.instructions = f2434_parent_instructions;
                                    body.emit(f2434);

                                    /* END IF */

                                    body.emit(assign(r2417, r2431, 0x01));

                                    body.emit(assign(r2418, r2430, 0x01));

                                    body.emit(assign(r2419, r242F, 0x01));

                                    body.emit(assign(r2416, body.constant(int(0)), 0x01));

                                    body.emit(assign(r241C, less(r242F, body.constant(0u)), 0x01));


                                 body.instructions = f242B_parent_instructions;
                                 body.emit(f242B);

                                 /* END IF */


                              body.instructions = f2428_parent_instructions;
                              body.emit(f2428);

                              /* END IF */


                           body.instructions = f241E_parent_instructions;
                           body.emit(f241E);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2447 = new(mem_ctx) ir_if(operand(r241A).val);
                           exec_list *const f2447_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2447->then_instructions;

                              /* IF CONDITION */
                              ir_if *f2448 = new(mem_ctx) ir_if(operand(r241C).val);
                              exec_list *const f2448_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2448->then_instructions;

                                 ir_variable *const r2449 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r2449, add(r2418, body.constant(1u)), 0x01));

                                 ir_expression *const r244A = less(r2449, r2418);
                                 ir_expression *const r244B = expr(ir_unop_b2i, r244A);
                                 ir_expression *const r244C = expr(ir_unop_i2u, r244B);
                                 body.emit(assign(r2417, add(r2417, r244C), 0x01));

                                 ir_expression *const r244D = equal(r2419, body.constant(0u));
                                 ir_expression *const r244E = expr(ir_unop_b2i, r244D);
                                 ir_expression *const r244F = expr(ir_unop_i2u, r244E);
                                 ir_expression *const r2450 = add(r2419, r244F);
                                 ir_expression *const r2451 = bit_and(r2450, body.constant(1u));
                                 ir_expression *const r2452 = expr(ir_unop_bit_not, r2451);
                                 body.emit(assign(r2418, bit_and(r2449, r2452), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2448->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2454 = bit_or(r2417, r2418);
                                 ir_expression *const r2455 = equal(r2454, body.constant(0u));
                                 ir_if *f2453 = new(mem_ctx) ir_if(operand(r2455).val);
                                 exec_list *const f2453_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2453->then_instructions;

                                    body.emit(assign(r2416, body.constant(int(0)), 0x01));


                                 body.instructions = f2453_parent_instructions;
                                 body.emit(f2453);

                                 /* END IF */


                              body.instructions = f2448_parent_instructions;
                              body.emit(f2448);

                              /* END IF */

                              ir_variable *const r2456 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2456);
                              ir_expression *const r2457 = lshift(r20EE, body.constant(int(31)));
                              ir_expression *const r2458 = expr(ir_unop_i2u, r2416);
                              ir_expression *const r2459 = lshift(r2458, body.constant(int(20)));
                              ir_expression *const r245A = add(r2457, r2459);
                              body.emit(assign(r2456, add(r245A, r2417), 0x02));

                              body.emit(assign(r2456, r2418, 0x01));

                              body.emit(assign(r241B, r2456, 0x03));

                              body.emit(assign(r241A, body.constant(false), 0x01));


                           body.instructions = f2447_parent_instructions;
                           body.emit(f2447);

                           /* END IF */

                           body.emit(assign(r20EF, r241B, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f23CF->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r245C = less(r20F6, r20F4);
                           ir_if *f245B = new(mem_ctx) ir_if(operand(r245C).val);
                           exec_list *const f245B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f245B->then_instructions;

                              ir_variable *const r245D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r245E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r245E, sub(r20F4, r20F6), 0x01));

                              ir_expression *const r245F = sub(r20F3, r20F5);
                              ir_expression *const r2460 = less(r20F4, r20F6);
                              ir_expression *const r2461 = expr(ir_unop_b2i, r2460);
                              ir_expression *const r2462 = expr(ir_unop_i2u, r2461);
                              body.emit(assign(r245D, sub(r245F, r2462), 0x01));

                              body.emit(assign(r20EE, bit_xor(r20EE, body.constant(1u)), 0x01));

                              body.emit(assign(r20F7, add(r20F1, body.constant(int(-1))), 0x01));

                              ir_variable *const r2463 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2463, add(r20F7, body.constant(int(-10))), 0x01));

                              ir_variable *const r2464 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2464, r245D, 0x01));

                              ir_variable *const r2465 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2465, r245E, 0x01));

                              ir_variable *const r2466 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r2466);
                              ir_variable *const r2467 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2467);
                              /* IF CONDITION */
                              ir_expression *const r2469 = equal(r245D, body.constant(0u));
                              ir_if *f2468 = new(mem_ctx) ir_if(operand(r2469).val);
                              exec_list *const f2468_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2468->then_instructions;

                                 body.emit(assign(r2464, r245E, 0x01));

                                 body.emit(assign(r2465, body.constant(0u), 0x01));

                                 body.emit(assign(r2463, add(r2463, body.constant(int(-32))), 0x01));


                              body.instructions = f2468_parent_instructions;
                              body.emit(f2468);

                              /* END IF */

                              ir_variable *const r246A = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r246A, r2464, 0x01));

                              ir_variable *const r246B = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r246C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r246C);
                              /* IF CONDITION */
                              ir_expression *const r246E = equal(r2464, body.constant(0u));
                              ir_if *f246D = new(mem_ctx) ir_if(operand(r246E).val);
                              exec_list *const f246D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f246D->then_instructions;

                                 body.emit(assign(r246B, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f246D->else_instructions;

                                 body.emit(assign(r246C, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2470 = bit_and(r2464, body.constant(4294901760u));
                                 ir_expression *const r2471 = equal(r2470, body.constant(0u));
                                 ir_if *f246F = new(mem_ctx) ir_if(operand(r2471).val);
                                 exec_list *const f246F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f246F->then_instructions;

                                    body.emit(assign(r246C, body.constant(int(16)), 0x01));

                                    body.emit(assign(r246A, lshift(r2464, body.constant(int(16))), 0x01));


                                 body.instructions = f246F_parent_instructions;
                                 body.emit(f246F);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2473 = bit_and(r246A, body.constant(4278190080u));
                                 ir_expression *const r2474 = equal(r2473, body.constant(0u));
                                 ir_if *f2472 = new(mem_ctx) ir_if(operand(r2474).val);
                                 exec_list *const f2472_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2472->then_instructions;

                                    body.emit(assign(r246C, add(r246C, body.constant(int(8))), 0x01));

                                    body.emit(assign(r246A, lshift(r246A, body.constant(int(8))), 0x01));


                                 body.instructions = f2472_parent_instructions;
                                 body.emit(f2472);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2476 = bit_and(r246A, body.constant(4026531840u));
                                 ir_expression *const r2477 = equal(r2476, body.constant(0u));
                                 ir_if *f2475 = new(mem_ctx) ir_if(operand(r2477).val);
                                 exec_list *const f2475_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2475->then_instructions;

                                    body.emit(assign(r246C, add(r246C, body.constant(int(4))), 0x01));

                                    body.emit(assign(r246A, lshift(r246A, body.constant(int(4))), 0x01));


                                 body.instructions = f2475_parent_instructions;
                                 body.emit(f2475);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2479 = bit_and(r246A, body.constant(3221225472u));
                                 ir_expression *const r247A = equal(r2479, body.constant(0u));
                                 ir_if *f2478 = new(mem_ctx) ir_if(operand(r247A).val);
                                 exec_list *const f2478_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2478->then_instructions;

                                    body.emit(assign(r246C, add(r246C, body.constant(int(2))), 0x01));

                                    body.emit(assign(r246A, lshift(r246A, body.constant(int(2))), 0x01));


                                 body.instructions = f2478_parent_instructions;
                                 body.emit(f2478);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r247C = bit_and(r246A, body.constant(2147483648u));
                                 ir_expression *const r247D = equal(r247C, body.constant(0u));
                                 ir_if *f247B = new(mem_ctx) ir_if(operand(r247D).val);
                                 exec_list *const f247B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f247B->then_instructions;

                                    body.emit(assign(r246C, add(r246C, body.constant(int(1))), 0x01));


                                 body.instructions = f247B_parent_instructions;
                                 body.emit(f247B);

                                 /* END IF */

                                 body.emit(assign(r246B, r246C, 0x01));


                              body.instructions = f246D_parent_instructions;
                              body.emit(f246D);

                              /* END IF */

                              body.emit(assign(r2467, add(r246B, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r247F = lequal(body.constant(int(0)), r2467);
                              ir_if *f247E = new(mem_ctx) ir_if(operand(r247F).val);
                              exec_list *const f247E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f247E->then_instructions;

                                 body.emit(assign(r2466, body.constant(0u), 0x01));

                                 ir_variable *const r2480 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r2480, lshift(r2465, r2467), 0x01));

                                 ir_variable *const r2481 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2483 = equal(r2467, body.constant(int(0)));
                                 ir_if *f2482 = new(mem_ctx) ir_if(operand(r2483).val);
                                 exec_list *const f2482_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2482->then_instructions;

                                    body.emit(assign(r2481, r2464, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2482->else_instructions;

                                    ir_expression *const r2484 = lshift(r2464, r2467);
                                    ir_expression *const r2485 = neg(r2467);
                                    ir_expression *const r2486 = bit_and(r2485, body.constant(int(31)));
                                    ir_expression *const r2487 = rshift(r2465, r2486);
                                    body.emit(assign(r2481, bit_or(r2484, r2487), 0x01));


                                 body.instructions = f2482_parent_instructions;
                                 body.emit(f2482);

                                 /* END IF */

                                 body.emit(assign(r2464, r2481, 0x01));

                                 body.emit(assign(r2465, r2480, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f247E->else_instructions;

                                 ir_variable *const r2488 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2488, body.constant(0u), 0x01));

                                 ir_variable *const r2489 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2489, neg(r2467), 0x01));

                                 ir_variable *const r248A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r248A);
                                 ir_variable *const r248B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r248B);
                                 ir_variable *const r248C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r248C);
                                 ir_variable *const r248D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r248E = neg(r2489);
                                 body.emit(assign(r248D, bit_and(r248E, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2490 = equal(r2489, body.constant(int(0)));
                                 ir_if *f248F = new(mem_ctx) ir_if(operand(r2490).val);
                                 exec_list *const f248F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f248F->then_instructions;

                                    body.emit(assign(r248A, r2488, 0x01));

                                    body.emit(assign(r248B, r2465, 0x01));

                                    body.emit(assign(r248C, r2464, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f248F->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2492 = less(r2489, body.constant(int(32)));
                                    ir_if *f2491 = new(mem_ctx) ir_if(operand(r2492).val);
                                    exec_list *const f2491_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2491->then_instructions;

                                       body.emit(assign(r248A, lshift(r2465, r248D), 0x01));

                                       ir_expression *const r2493 = lshift(r2464, r248D);
                                       ir_expression *const r2494 = rshift(r2465, r2489);
                                       body.emit(assign(r248B, bit_or(r2493, r2494), 0x01));

                                       body.emit(assign(r248C, rshift(r2464, r2489), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2491->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2496 = equal(r2489, body.constant(int(32)));
                                       ir_if *f2495 = new(mem_ctx) ir_if(operand(r2496).val);
                                       exec_list *const f2495_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2495->then_instructions;

                                          body.emit(assign(r248A, r2465, 0x01));

                                          body.emit(assign(r248B, r2464, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2495->else_instructions;

                                          body.emit(assign(r2488, bit_or(body.constant(0u), r2465), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2498 = less(r2489, body.constant(int(64)));
                                          ir_if *f2497 = new(mem_ctx) ir_if(operand(r2498).val);
                                          exec_list *const f2497_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2497->then_instructions;

                                             body.emit(assign(r248A, lshift(r2464, r248D), 0x01));

                                             ir_expression *const r2499 = bit_and(r2489, body.constant(int(31)));
                                             body.emit(assign(r248B, rshift(r2464, r2499), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2497->else_instructions;

                                             ir_variable *const r249A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r249C = equal(r2489, body.constant(int(64)));
                                             ir_if *f249B = new(mem_ctx) ir_if(operand(r249C).val);
                                             exec_list *const f249B_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f249B->then_instructions;

                                                body.emit(assign(r249A, r2464, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f249B->else_instructions;

                                                ir_expression *const r249D = nequal(r2464, body.constant(0u));
                                                ir_expression *const r249E = expr(ir_unop_b2i, r249D);
                                                body.emit(assign(r249A, expr(ir_unop_i2u, r249E), 0x01));


                                             body.instructions = f249B_parent_instructions;
                                             body.emit(f249B);

                                             /* END IF */

                                             body.emit(assign(r248A, r249A, 0x01));

                                             body.emit(assign(r248B, body.constant(0u), 0x01));


                                          body.instructions = f2497_parent_instructions;
                                          body.emit(f2497);

                                          /* END IF */


                                       body.instructions = f2495_parent_instructions;
                                       body.emit(f2495);

                                       /* END IF */

                                       body.emit(assign(r248C, body.constant(0u), 0x01));


                                    body.instructions = f2491_parent_instructions;
                                    body.emit(f2491);

                                    /* END IF */

                                    ir_expression *const r249F = nequal(r2488, body.constant(0u));
                                    ir_expression *const r24A0 = expr(ir_unop_b2i, r249F);
                                    ir_expression *const r24A1 = expr(ir_unop_i2u, r24A0);
                                    body.emit(assign(r248A, bit_or(r248A, r24A1), 0x01));


                                 body.instructions = f248F_parent_instructions;
                                 body.emit(f248F);

                                 /* END IF */

                                 body.emit(assign(r2464, r248C, 0x01));

                                 body.emit(assign(r2465, r248B, 0x01));

                                 body.emit(assign(r2466, r248A, 0x01));


                              body.instructions = f247E_parent_instructions;
                              body.emit(f247E);

                              /* END IF */

                              body.emit(assign(r2463, sub(r2463, r2467), 0x01));

                              ir_variable *const r24A2 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r24A2, r2463, 0x01));

                              ir_variable *const r24A3 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r24A3, r2464, 0x01));

                              ir_variable *const r24A4 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r24A4, r2465, 0x01));

                              ir_variable *const r24A5 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r24A5, r2466, 0x01));

                              ir_variable *const r24A6 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r24A6, body.constant(true), 0x01));

                              ir_variable *const r24A7 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r24A8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r24A8);
                              ir_expression *const r24A9 = expr(ir_unop_u2i, r2466);
                              body.emit(assign(r24A8, less(r24A9, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r24AB = lequal(body.constant(int(2045)), r2463);
                              ir_if *f24AA = new(mem_ctx) ir_if(operand(r24AB).val);
                              exec_list *const f24AA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f24AA->then_instructions;

                                 ir_variable *const r24AC = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r24AE = less(body.constant(int(2045)), r2463);
                                 ir_if *f24AD = new(mem_ctx) ir_if(operand(r24AE).val);
                                 exec_list *const f24AD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f24AD->then_instructions;

                                    body.emit(assign(r24AC, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f24AD->else_instructions;

                                    ir_variable *const r24AF = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r24B1 = equal(r2463, body.constant(int(2045)));
                                    ir_if *f24B0 = new(mem_ctx) ir_if(operand(r24B1).val);
                                    exec_list *const f24B0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f24B0->then_instructions;

                                       ir_expression *const r24B2 = equal(body.constant(2097151u), r2464);
                                       ir_expression *const r24B3 = equal(body.constant(4294967295u), r2465);
                                       body.emit(assign(r24AF, logic_and(r24B2, r24B3), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f24B0->else_instructions;

                                       body.emit(assign(r24AF, body.constant(false), 0x01));


                                    body.instructions = f24B0_parent_instructions;
                                    body.emit(f24B0);

                                    /* END IF */

                                    body.emit(assign(r24AC, logic_and(r24AF, r24A8), 0x01));


                                 body.instructions = f24AD_parent_instructions;
                                 body.emit(f24AD);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f24B4 = new(mem_ctx) ir_if(operand(r24AC).val);
                                 exec_list *const f24B4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f24B4->then_instructions;

                                    ir_variable *const r24B5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r24B5);
                                    ir_expression *const r24B6 = lshift(r20EE, body.constant(int(31)));
                                    body.emit(assign(r24B5, add(r24B6, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r24B5, body.constant(0u), 0x01));

                                    body.emit(assign(r24A7, r24B5, 0x03));

                                    body.emit(assign(r24A6, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f24B4->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r24B8 = less(r2463, body.constant(int(0)));
                                    ir_if *f24B7 = new(mem_ctx) ir_if(operand(r24B8).val);
                                    exec_list *const f24B7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f24B7->then_instructions;

                                       ir_variable *const r24B9 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r24B9, r2466, 0x01));

                                       ir_variable *const r24BA = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r24BA, neg(r2463), 0x01));

                                       ir_variable *const r24BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r24BB);
                                       ir_variable *const r24BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r24BC);
                                       ir_variable *const r24BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r24BD);
                                       ir_variable *const r24BE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r24BF = neg(r24BA);
                                       body.emit(assign(r24BE, bit_and(r24BF, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r24C1 = equal(r24BA, body.constant(int(0)));
                                       ir_if *f24C0 = new(mem_ctx) ir_if(operand(r24C1).val);
                                       exec_list *const f24C0_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f24C0->then_instructions;

                                          body.emit(assign(r24BB, r2466, 0x01));

                                          body.emit(assign(r24BC, r2465, 0x01));

                                          body.emit(assign(r24BD, r2464, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f24C0->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r24C3 = less(r24BA, body.constant(int(32)));
                                          ir_if *f24C2 = new(mem_ctx) ir_if(operand(r24C3).val);
                                          exec_list *const f24C2_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f24C2->then_instructions;

                                             body.emit(assign(r24BB, lshift(r2465, r24BE), 0x01));

                                             ir_expression *const r24C4 = lshift(r2464, r24BE);
                                             ir_expression *const r24C5 = rshift(r2465, r24BA);
                                             body.emit(assign(r24BC, bit_or(r24C4, r24C5), 0x01));

                                             body.emit(assign(r24BD, rshift(r2464, r24BA), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f24C2->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r24C7 = equal(r24BA, body.constant(int(32)));
                                             ir_if *f24C6 = new(mem_ctx) ir_if(operand(r24C7).val);
                                             exec_list *const f24C6_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f24C6->then_instructions;

                                                body.emit(assign(r24BB, r2465, 0x01));

                                                body.emit(assign(r24BC, r2464, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f24C6->else_instructions;

                                                body.emit(assign(r24B9, bit_or(r2466, r2465), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r24C9 = less(r24BA, body.constant(int(64)));
                                                ir_if *f24C8 = new(mem_ctx) ir_if(operand(r24C9).val);
                                                exec_list *const f24C8_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f24C8->then_instructions;

                                                   body.emit(assign(r24BB, lshift(r2464, r24BE), 0x01));

                                                   ir_expression *const r24CA = bit_and(r24BA, body.constant(int(31)));
                                                   body.emit(assign(r24BC, rshift(r2464, r24CA), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f24C8->else_instructions;

                                                   ir_variable *const r24CB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r24CD = equal(r24BA, body.constant(int(64)));
                                                   ir_if *f24CC = new(mem_ctx) ir_if(operand(r24CD).val);
                                                   exec_list *const f24CC_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f24CC->then_instructions;

                                                      body.emit(assign(r24CB, r2464, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f24CC->else_instructions;

                                                      ir_expression *const r24CE = nequal(r2464, body.constant(0u));
                                                      ir_expression *const r24CF = expr(ir_unop_b2i, r24CE);
                                                      body.emit(assign(r24CB, expr(ir_unop_i2u, r24CF), 0x01));


                                                   body.instructions = f24CC_parent_instructions;
                                                   body.emit(f24CC);

                                                   /* END IF */

                                                   body.emit(assign(r24BB, r24CB, 0x01));

                                                   body.emit(assign(r24BC, body.constant(0u), 0x01));


                                                body.instructions = f24C8_parent_instructions;
                                                body.emit(f24C8);

                                                /* END IF */


                                             body.instructions = f24C6_parent_instructions;
                                             body.emit(f24C6);

                                             /* END IF */

                                             body.emit(assign(r24BD, body.constant(0u), 0x01));


                                          body.instructions = f24C2_parent_instructions;
                                          body.emit(f24C2);

                                          /* END IF */

                                          ir_expression *const r24D0 = nequal(r24B9, body.constant(0u));
                                          ir_expression *const r24D1 = expr(ir_unop_b2i, r24D0);
                                          ir_expression *const r24D2 = expr(ir_unop_i2u, r24D1);
                                          body.emit(assign(r24BB, bit_or(r24BB, r24D2), 0x01));


                                       body.instructions = f24C0_parent_instructions;
                                       body.emit(f24C0);

                                       /* END IF */

                                       body.emit(assign(r24A3, r24BD, 0x01));

                                       body.emit(assign(r24A4, r24BC, 0x01));

                                       body.emit(assign(r24A5, r24BB, 0x01));

                                       body.emit(assign(r24A2, body.constant(int(0)), 0x01));

                                       body.emit(assign(r24A8, less(r24BB, body.constant(0u)), 0x01));


                                    body.instructions = f24B7_parent_instructions;
                                    body.emit(f24B7);

                                    /* END IF */


                                 body.instructions = f24B4_parent_instructions;
                                 body.emit(f24B4);

                                 /* END IF */


                              body.instructions = f24AA_parent_instructions;
                              body.emit(f24AA);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f24D3 = new(mem_ctx) ir_if(operand(r24A6).val);
                              exec_list *const f24D3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f24D3->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f24D4 = new(mem_ctx) ir_if(operand(r24A8).val);
                                 exec_list *const f24D4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f24D4->then_instructions;

                                    ir_variable *const r24D5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r24D5, add(r24A4, body.constant(1u)), 0x01));

                                    ir_expression *const r24D6 = less(r24D5, r24A4);
                                    ir_expression *const r24D7 = expr(ir_unop_b2i, r24D6);
                                    ir_expression *const r24D8 = expr(ir_unop_i2u, r24D7);
                                    body.emit(assign(r24A3, add(r24A3, r24D8), 0x01));

                                    ir_expression *const r24D9 = equal(r24A5, body.constant(0u));
                                    ir_expression *const r24DA = expr(ir_unop_b2i, r24D9);
                                    ir_expression *const r24DB = expr(ir_unop_i2u, r24DA);
                                    ir_expression *const r24DC = add(r24A5, r24DB);
                                    ir_expression *const r24DD = bit_and(r24DC, body.constant(1u));
                                    ir_expression *const r24DE = expr(ir_unop_bit_not, r24DD);
                                    body.emit(assign(r24A4, bit_and(r24D5, r24DE), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f24D4->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r24E0 = bit_or(r24A3, r24A4);
                                    ir_expression *const r24E1 = equal(r24E0, body.constant(0u));
                                    ir_if *f24DF = new(mem_ctx) ir_if(operand(r24E1).val);
                                    exec_list *const f24DF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f24DF->then_instructions;

                                       body.emit(assign(r24A2, body.constant(int(0)), 0x01));


                                    body.instructions = f24DF_parent_instructions;
                                    body.emit(f24DF);

                                    /* END IF */


                                 body.instructions = f24D4_parent_instructions;
                                 body.emit(f24D4);

                                 /* END IF */

                                 ir_variable *const r24E2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r24E2);
                                 ir_expression *const r24E3 = lshift(r20EE, body.constant(int(31)));
                                 ir_expression *const r24E4 = expr(ir_unop_i2u, r24A2);
                                 ir_expression *const r24E5 = lshift(r24E4, body.constant(int(20)));
                                 ir_expression *const r24E6 = add(r24E3, r24E5);
                                 body.emit(assign(r24E2, add(r24E6, r24A3), 0x02));

                                 body.emit(assign(r24E2, r24A4, 0x01));

                                 body.emit(assign(r24A7, r24E2, 0x03));

                                 body.emit(assign(r24A6, body.constant(false), 0x01));


                              body.instructions = f24D3_parent_instructions;
                              body.emit(f24D3);

                              /* END IF */

                              body.emit(assign(r20EF, r24A7, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f245B->else_instructions;

                              ir_variable *const r24E7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r24E7);
                              body.emit(assign(r24E7, body.constant(0u), 0x02));

                              body.emit(assign(r24E7, body.constant(0u), 0x01));

                              body.emit(assign(r20EF, r24E7, 0x03));


                           body.instructions = f245B_parent_instructions;
                           body.emit(f245B);

                           /* END IF */


                        body.instructions = f23CF_parent_instructions;
                        body.emit(f23CF);

                        /* END IF */


                     body.instructions = f2343_parent_instructions;
                     body.emit(f2343);

                     /* END IF */


                  body.instructions = f22B7_parent_instructions;
                  body.emit(f22B7);

                  /* END IF */


               body.instructions = f2296_parent_instructions;
               body.emit(f2296);

               /* END IF */


            body.instructions = f21C8_parent_instructions;
            body.emit(f21C8);

            /* END IF */


         body.instructions = f2103_parent_instructions;
         body.emit(f2103);

         /* END IF */

         body.emit(assign(r1F55, r20EF, 0x03));


      body.instructions = f1F58_parent_instructions;
      body.emit(f1F58);

      /* END IF */

      body.emit(assign(r1F52, r1F55, 0x03));


   body.instructions = f1F53_parent_instructions;
   body.emit(f1F53);

   /* END IF */

   ir_variable *const r24E8 = body.make_temp(glsl_type::uvec2_type, "a");
   body.emit(assign(r24E8, r1F52, 0x03));

   ir_variable *const r24E9 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r24EB = lshift(swizzle_y(r1F52), body.constant(int(1)));
   ir_expression *const r24EC = lequal(body.constant(4292870144u), r24EB);
   ir_expression *const r24ED = nequal(swizzle_x(r1F52), body.constant(0u));
   ir_expression *const r24EE = bit_and(swizzle_y(r1F52), body.constant(1048575u));
   ir_expression *const r24EF = nequal(r24EE, body.constant(0u));
   ir_expression *const r24F0 = logic_or(r24ED, r24EF);
   ir_expression *const r24F1 = logic_and(r24EC, r24F0);
   ir_if *f24EA = new(mem_ctx) ir_if(operand(r24F1).val);
   exec_list *const f24EA_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f24EA->then_instructions;

      body.emit(assign(r24E9, r1F52, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f24EA->else_instructions;

      body.emit(assign(r24E8, bit_xor(swizzle_y(r1F52), body.constant(2147483648u)), 0x02));

      body.emit(assign(r24E9, r24E8, 0x03));


   body.instructions = f24EA_parent_instructions;
   body.emit(f24EA);

   /* END IF */

   ir_variable *const r24F2 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r24F3 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r24F3, rshift(swizzle_y(r1F1E), body.constant(int(31))), 0x01));

   ir_variable *const r24F4 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r24F4, rshift(swizzle_y(r24E9), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r24F6 = equal(r24F3, r24F4);
   ir_if *f24F5 = new(mem_ctx) ir_if(operand(r24F6).val);
   exec_list *const f24F5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f24F5->then_instructions;

      ir_variable *const r24F7 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r24F7, body.constant(true), 0x01));

      ir_variable *const r24F8 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r24F9 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r24F9);
      ir_variable *const r24FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r24FA);
      ir_variable *const r24FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r24FB);
      ir_variable *const r24FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r24FC);
      ir_variable *const r24FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r24FD);
      ir_variable *const r24FE = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r24FE);
      ir_variable *const r24FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r24FF);
      ir_variable *const r2500 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r2500);
      body.emit(assign(r2500, body.constant(0u), 0x01));

      body.emit(assign(r24FF, body.constant(0u), 0x01));

      ir_variable *const r2501 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r2501, swizzle_x(r1F1E), 0x01));

      body.emit(assign(r24FD, r2501, 0x01));

      ir_variable *const r2502 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r2502, bit_and(swizzle_y(r1F1E), body.constant(1048575u)), 0x01));

      body.emit(assign(r24FC, r2502, 0x01));

      ir_variable *const r2503 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r2503, swizzle_x(r24E9), 0x01));

      body.emit(assign(r24FB, r2503, 0x01));

      ir_variable *const r2504 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r2504, bit_and(swizzle_y(r24E9), body.constant(1048575u)), 0x01));

      body.emit(assign(r24FA, r2504, 0x01));

      ir_variable *const r2505 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r2506 = rshift(swizzle_y(r1F1E), body.constant(int(20)));
      ir_expression *const r2507 = bit_and(r2506, body.constant(2047u));
      body.emit(assign(r2505, expr(ir_unop_u2i, r2507), 0x01));

      ir_variable *const r2508 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r2509 = rshift(swizzle_y(r24E9), body.constant(int(20)));
      ir_expression *const r250A = bit_and(r2509, body.constant(2047u));
      body.emit(assign(r2508, expr(ir_unop_u2i, r250A), 0x01));

      ir_variable *const r250B = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r250B, sub(r2505, r2508), 0x01));

      body.emit(assign(r24F9, r250B, 0x01));

      /* IF CONDITION */
      ir_expression *const r250D = less(body.constant(int(0)), r250B);
      ir_if *f250C = new(mem_ctx) ir_if(operand(r250D).val);
      exec_list *const f250C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f250C->then_instructions;

         /* IF CONDITION */
         ir_expression *const r250F = equal(r2505, body.constant(int(2047)));
         ir_if *f250E = new(mem_ctx) ir_if(operand(r250F).val);
         exec_list *const f250E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f250E->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2511 = bit_or(r2502, swizzle_x(r1F1E));
            ir_expression *const r2512 = nequal(r2511, body.constant(0u));
            ir_if *f2510 = new(mem_ctx) ir_if(operand(r2512).val);
            exec_list *const f2510_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2510->then_instructions;

               ir_variable *const r2513 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r2513, swizzle_x(r1F1E), 0x01));

               ir_variable *const r2514 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r2514, swizzle_x(r24E9), 0x01));

               ir_variable *const r2515 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2516 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r2517 = rshift(swizzle_y(r1F1E), body.constant(int(19)));
               ir_expression *const r2518 = bit_and(r2517, body.constant(4095u));
               ir_expression *const r2519 = equal(r2518, body.constant(4094u));
               ir_expression *const r251A = nequal(swizzle_x(r1F1E), body.constant(0u));
               ir_expression *const r251B = bit_and(swizzle_y(r1F1E), body.constant(524287u));
               ir_expression *const r251C = nequal(r251B, body.constant(0u));
               ir_expression *const r251D = logic_or(r251A, r251C);
               body.emit(assign(r2516, logic_and(r2519, r251D), 0x01));

               ir_variable *const r251E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r251F = lshift(swizzle_y(r24E9), body.constant(int(1)));
               ir_expression *const r2520 = lequal(body.constant(4292870144u), r251F);
               ir_expression *const r2521 = nequal(swizzle_x(r24E9), body.constant(0u));
               ir_expression *const r2522 = bit_and(swizzle_y(r24E9), body.constant(1048575u));
               ir_expression *const r2523 = nequal(r2522, body.constant(0u));
               ir_expression *const r2524 = logic_or(r2521, r2523);
               body.emit(assign(r251E, logic_and(r2520, r2524), 0x01));

               body.emit(assign(r2513, bit_or(swizzle_y(r1F1E), body.constant(524288u)), 0x02));

               body.emit(assign(r2514, bit_or(swizzle_y(r24E9), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r2526 = lshift(swizzle_y(r1F1E), body.constant(int(1)));
               ir_expression *const r2527 = lequal(body.constant(4292870144u), r2526);
               ir_expression *const r2528 = nequal(swizzle_x(r1F1E), body.constant(0u));
               ir_expression *const r2529 = bit_and(swizzle_y(r1F1E), body.constant(1048575u));
               ir_expression *const r252A = nequal(r2529, body.constant(0u));
               ir_expression *const r252B = logic_or(r2528, r252A);
               ir_expression *const r252C = logic_and(r2527, r252B);
               ir_if *f2525 = new(mem_ctx) ir_if(operand(r252C).val);
               exec_list *const f2525_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2525->then_instructions;

                  ir_variable *const r252D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r252F = logic_and(r2516, r251E);
                  ir_if *f252E = new(mem_ctx) ir_if(operand(r252F).val);
                  exec_list *const f252E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f252E->then_instructions;

                     body.emit(assign(r252D, r2514, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f252E->else_instructions;

                     body.emit(assign(r252D, r2513, 0x03));


                  body.instructions = f252E_parent_instructions;
                  body.emit(f252E);

                  /* END IF */

                  body.emit(assign(r2515, r252D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2525->else_instructions;

                  body.emit(assign(r2515, r2514, 0x03));


               body.instructions = f2525_parent_instructions;
               body.emit(f2525);

               /* END IF */

               body.emit(assign(r24F8, r2515, 0x03));

               body.emit(assign(r24F7, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2510->else_instructions;

               body.emit(assign(r24F8, r1F1E, 0x03));

               body.emit(assign(r24F7, body.constant(false), 0x01));


            body.instructions = f2510_parent_instructions;
            body.emit(f2510);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f250E->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2531 = equal(r2508, body.constant(int(0)));
            ir_if *f2530 = new(mem_ctx) ir_if(operand(r2531).val);
            exec_list *const f2530_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2530->then_instructions;

               body.emit(assign(r24F9, add(r250B, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2530->else_instructions;

               body.emit(assign(r24FA, bit_or(r2504, body.constant(1048576u)), 0x01));


            body.instructions = f2530_parent_instructions;
            body.emit(f2530);

            /* END IF */

            ir_variable *const r2532 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r2532, body.constant(0u), 0x01));

            ir_variable *const r2533 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r2533);
            ir_variable *const r2534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r2534);
            ir_variable *const r2535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r2535);
            ir_variable *const r2536 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r2537 = neg(r24F9);
            body.emit(assign(r2536, bit_and(r2537, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2539 = equal(r24F9, body.constant(int(0)));
            ir_if *f2538 = new(mem_ctx) ir_if(operand(r2539).val);
            exec_list *const f2538_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2538->then_instructions;

               body.emit(assign(r2533, r2532, 0x01));

               body.emit(assign(r2534, r2503, 0x01));

               body.emit(assign(r2535, r24FA, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2538->else_instructions;

               /* IF CONDITION */
               ir_expression *const r253B = less(r24F9, body.constant(int(32)));
               ir_if *f253A = new(mem_ctx) ir_if(operand(r253B).val);
               exec_list *const f253A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f253A->then_instructions;

                  body.emit(assign(r2533, lshift(swizzle_x(r24E9), r2536), 0x01));

                  ir_expression *const r253C = lshift(r24FA, r2536);
                  ir_expression *const r253D = rshift(swizzle_x(r24E9), r24F9);
                  body.emit(assign(r2534, bit_or(r253C, r253D), 0x01));

                  body.emit(assign(r2535, rshift(r24FA, r24F9), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f253A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r253F = equal(r24F9, body.constant(int(32)));
                  ir_if *f253E = new(mem_ctx) ir_if(operand(r253F).val);
                  exec_list *const f253E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f253E->then_instructions;

                     body.emit(assign(r2533, r2503, 0x01));

                     body.emit(assign(r2534, r24FA, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f253E->else_instructions;

                     body.emit(assign(r2532, bit_or(body.constant(0u), swizzle_x(r24E9)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2541 = less(r24F9, body.constant(int(64)));
                     ir_if *f2540 = new(mem_ctx) ir_if(operand(r2541).val);
                     exec_list *const f2540_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2540->then_instructions;

                        body.emit(assign(r2533, lshift(r24FA, r2536), 0x01));

                        ir_expression *const r2542 = bit_and(r24F9, body.constant(int(31)));
                        body.emit(assign(r2534, rshift(r24FA, r2542), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2540->else_instructions;

                        ir_variable *const r2543 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2545 = equal(r24F9, body.constant(int(64)));
                        ir_if *f2544 = new(mem_ctx) ir_if(operand(r2545).val);
                        exec_list *const f2544_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2544->then_instructions;

                           body.emit(assign(r2543, r24FA, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2544->else_instructions;

                           ir_expression *const r2546 = nequal(r24FA, body.constant(0u));
                           ir_expression *const r2547 = expr(ir_unop_b2i, r2546);
                           body.emit(assign(r2543, expr(ir_unop_i2u, r2547), 0x01));


                        body.instructions = f2544_parent_instructions;
                        body.emit(f2544);

                        /* END IF */

                        body.emit(assign(r2533, r2543, 0x01));

                        body.emit(assign(r2534, body.constant(0u), 0x01));


                     body.instructions = f2540_parent_instructions;
                     body.emit(f2540);

                     /* END IF */


                  body.instructions = f253E_parent_instructions;
                  body.emit(f253E);

                  /* END IF */

                  body.emit(assign(r2535, body.constant(0u), 0x01));


               body.instructions = f253A_parent_instructions;
               body.emit(f253A);

               /* END IF */

               ir_expression *const r2548 = nequal(r2532, body.constant(0u));
               ir_expression *const r2549 = expr(ir_unop_b2i, r2548);
               ir_expression *const r254A = expr(ir_unop_i2u, r2549);
               body.emit(assign(r2533, bit_or(r2533, r254A), 0x01));


            body.instructions = f2538_parent_instructions;
            body.emit(f2538);

            /* END IF */

            body.emit(assign(r24FA, r2535, 0x01));

            body.emit(assign(r24FB, r2534, 0x01));

            body.emit(assign(r24FF, r2533, 0x01));

            body.emit(assign(r24FE, r2505, 0x01));


         body.instructions = f250E_parent_instructions;
         body.emit(f250E);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f250C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r254C = less(r24F9, body.constant(int(0)));
         ir_if *f254B = new(mem_ctx) ir_if(operand(r254C).val);
         exec_list *const f254B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f254B->then_instructions;

            /* IF CONDITION */
            ir_expression *const r254E = equal(r2508, body.constant(int(2047)));
            ir_if *f254D = new(mem_ctx) ir_if(operand(r254E).val);
            exec_list *const f254D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f254D->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2550 = bit_or(r24FA, r24FB);
               ir_expression *const r2551 = nequal(r2550, body.constant(0u));
               ir_if *f254F = new(mem_ctx) ir_if(operand(r2551).val);
               exec_list *const f254F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f254F->then_instructions;

                  ir_variable *const r2552 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2552, swizzle_x(r1F1E), 0x01));

                  ir_variable *const r2553 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2553, swizzle_x(r24E9), 0x01));

                  ir_variable *const r2554 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2555 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2556 = rshift(swizzle_y(r1F1E), body.constant(int(19)));
                  ir_expression *const r2557 = bit_and(r2556, body.constant(4095u));
                  ir_expression *const r2558 = equal(r2557, body.constant(4094u));
                  ir_expression *const r2559 = nequal(swizzle_x(r1F1E), body.constant(0u));
                  ir_expression *const r255A = bit_and(swizzle_y(r1F1E), body.constant(524287u));
                  ir_expression *const r255B = nequal(r255A, body.constant(0u));
                  ir_expression *const r255C = logic_or(r2559, r255B);
                  body.emit(assign(r2555, logic_and(r2558, r255C), 0x01));

                  ir_variable *const r255D = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r255E = lshift(swizzle_y(r24E9), body.constant(int(1)));
                  ir_expression *const r255F = lequal(body.constant(4292870144u), r255E);
                  ir_expression *const r2560 = nequal(swizzle_x(r24E9), body.constant(0u));
                  ir_expression *const r2561 = bit_and(swizzle_y(r24E9), body.constant(1048575u));
                  ir_expression *const r2562 = nequal(r2561, body.constant(0u));
                  ir_expression *const r2563 = logic_or(r2560, r2562);
                  body.emit(assign(r255D, logic_and(r255F, r2563), 0x01));

                  body.emit(assign(r2552, bit_or(swizzle_y(r1F1E), body.constant(524288u)), 0x02));

                  body.emit(assign(r2553, bit_or(swizzle_y(r24E9), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2565 = lshift(swizzle_y(r1F1E), body.constant(int(1)));
                  ir_expression *const r2566 = lequal(body.constant(4292870144u), r2565);
                  ir_expression *const r2567 = nequal(swizzle_x(r1F1E), body.constant(0u));
                  ir_expression *const r2568 = bit_and(swizzle_y(r1F1E), body.constant(1048575u));
                  ir_expression *const r2569 = nequal(r2568, body.constant(0u));
                  ir_expression *const r256A = logic_or(r2567, r2569);
                  ir_expression *const r256B = logic_and(r2566, r256A);
                  ir_if *f2564 = new(mem_ctx) ir_if(operand(r256B).val);
                  exec_list *const f2564_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2564->then_instructions;

                     ir_variable *const r256C = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r256E = logic_and(r2555, r255D);
                     ir_if *f256D = new(mem_ctx) ir_if(operand(r256E).val);
                     exec_list *const f256D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f256D->then_instructions;

                        body.emit(assign(r256C, r2553, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f256D->else_instructions;

                        body.emit(assign(r256C, r2552, 0x03));


                     body.instructions = f256D_parent_instructions;
                     body.emit(f256D);

                     /* END IF */

                     body.emit(assign(r2554, r256C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2564->else_instructions;

                     body.emit(assign(r2554, r2553, 0x03));


                  body.instructions = f2564_parent_instructions;
                  body.emit(f2564);

                  /* END IF */

                  body.emit(assign(r24F8, r2554, 0x03));

                  body.emit(assign(r24F7, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f254F->else_instructions;

                  ir_variable *const r256F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r256F);
                  ir_expression *const r2570 = lshift(r24F3, body.constant(int(31)));
                  body.emit(assign(r256F, add(r2570, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r256F, body.constant(0u), 0x01));

                  body.emit(assign(r24F8, r256F, 0x03));

                  body.emit(assign(r24F7, body.constant(false), 0x01));


               body.instructions = f254F_parent_instructions;
               body.emit(f254F);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f254D->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2572 = equal(r2505, body.constant(int(0)));
               ir_if *f2571 = new(mem_ctx) ir_if(operand(r2572).val);
               exec_list *const f2571_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2571->then_instructions;

                  body.emit(assign(r24F9, add(r24F9, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2571->else_instructions;

                  body.emit(assign(r24FC, bit_or(r2502, body.constant(1048576u)), 0x01));


               body.instructions = f2571_parent_instructions;
               body.emit(f2571);

               /* END IF */

               ir_variable *const r2573 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2573, body.constant(0u), 0x01));

               ir_variable *const r2574 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2574, neg(r24F9), 0x01));

               ir_variable *const r2575 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2575);
               ir_variable *const r2576 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2576);
               ir_variable *const r2577 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2577);
               ir_variable *const r2578 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2579 = neg(r2574);
               body.emit(assign(r2578, bit_and(r2579, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r257B = equal(r2574, body.constant(int(0)));
               ir_if *f257A = new(mem_ctx) ir_if(operand(r257B).val);
               exec_list *const f257A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f257A->then_instructions;

                  body.emit(assign(r2575, r2573, 0x01));

                  body.emit(assign(r2576, r2501, 0x01));

                  body.emit(assign(r2577, r24FC, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f257A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r257D = less(r2574, body.constant(int(32)));
                  ir_if *f257C = new(mem_ctx) ir_if(operand(r257D).val);
                  exec_list *const f257C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f257C->then_instructions;

                     body.emit(assign(r2575, lshift(swizzle_x(r1F1E), r2578), 0x01));

                     ir_expression *const r257E = lshift(r24FC, r2578);
                     ir_expression *const r257F = rshift(swizzle_x(r1F1E), r2574);
                     body.emit(assign(r2576, bit_or(r257E, r257F), 0x01));

                     body.emit(assign(r2577, rshift(r24FC, r2574), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f257C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2581 = equal(r2574, body.constant(int(32)));
                     ir_if *f2580 = new(mem_ctx) ir_if(operand(r2581).val);
                     exec_list *const f2580_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2580->then_instructions;

                        body.emit(assign(r2575, r2501, 0x01));

                        body.emit(assign(r2576, r24FC, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2580->else_instructions;

                        body.emit(assign(r2573, bit_or(body.constant(0u), swizzle_x(r1F1E)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2583 = less(r2574, body.constant(int(64)));
                        ir_if *f2582 = new(mem_ctx) ir_if(operand(r2583).val);
                        exec_list *const f2582_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2582->then_instructions;

                           body.emit(assign(r2575, lshift(r24FC, r2578), 0x01));

                           ir_expression *const r2584 = bit_and(r2574, body.constant(int(31)));
                           body.emit(assign(r2576, rshift(r24FC, r2584), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2582->else_instructions;

                           ir_variable *const r2585 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2587 = equal(r2574, body.constant(int(64)));
                           ir_if *f2586 = new(mem_ctx) ir_if(operand(r2587).val);
                           exec_list *const f2586_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2586->then_instructions;

                              body.emit(assign(r2585, r24FC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2586->else_instructions;

                              ir_expression *const r2588 = nequal(r24FC, body.constant(0u));
                              ir_expression *const r2589 = expr(ir_unop_b2i, r2588);
                              body.emit(assign(r2585, expr(ir_unop_i2u, r2589), 0x01));


                           body.instructions = f2586_parent_instructions;
                           body.emit(f2586);

                           /* END IF */

                           body.emit(assign(r2575, r2585, 0x01));

                           body.emit(assign(r2576, body.constant(0u), 0x01));


                        body.instructions = f2582_parent_instructions;
                        body.emit(f2582);

                        /* END IF */


                     body.instructions = f2580_parent_instructions;
                     body.emit(f2580);

                     /* END IF */

                     body.emit(assign(r2577, body.constant(0u), 0x01));


                  body.instructions = f257C_parent_instructions;
                  body.emit(f257C);

                  /* END IF */

                  ir_expression *const r258A = nequal(r2573, body.constant(0u));
                  ir_expression *const r258B = expr(ir_unop_b2i, r258A);
                  ir_expression *const r258C = expr(ir_unop_i2u, r258B);
                  body.emit(assign(r2575, bit_or(r2575, r258C), 0x01));


               body.instructions = f257A_parent_instructions;
               body.emit(f257A);

               /* END IF */

               body.emit(assign(r24FC, r2577, 0x01));

               body.emit(assign(r24FD, r2576, 0x01));

               body.emit(assign(r24FF, r2575, 0x01));

               body.emit(assign(r24FE, r2508, 0x01));


            body.instructions = f254D_parent_instructions;
            body.emit(f254D);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f254B->else_instructions;

            /* IF CONDITION */
            ir_expression *const r258E = equal(r2505, body.constant(int(2047)));
            ir_if *f258D = new(mem_ctx) ir_if(operand(r258E).val);
            exec_list *const f258D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f258D->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2590 = bit_or(r24FC, r24FD);
               ir_expression *const r2591 = bit_or(r24FA, r24FB);
               ir_expression *const r2592 = bit_or(r2590, r2591);
               ir_expression *const r2593 = nequal(r2592, body.constant(0u));
               ir_if *f258F = new(mem_ctx) ir_if(operand(r2593).val);
               exec_list *const f258F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f258F->then_instructions;

                  ir_variable *const r2594 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2594, swizzle_x(r1F1E), 0x01));

                  ir_variable *const r2595 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2595, swizzle_x(r24E9), 0x01));

                  ir_variable *const r2596 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2597 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2598 = rshift(swizzle_y(r1F1E), body.constant(int(19)));
                  ir_expression *const r2599 = bit_and(r2598, body.constant(4095u));
                  ir_expression *const r259A = equal(r2599, body.constant(4094u));
                  ir_expression *const r259B = nequal(swizzle_x(r1F1E), body.constant(0u));
                  ir_expression *const r259C = bit_and(swizzle_y(r1F1E), body.constant(524287u));
                  ir_expression *const r259D = nequal(r259C, body.constant(0u));
                  ir_expression *const r259E = logic_or(r259B, r259D);
                  body.emit(assign(r2597, logic_and(r259A, r259E), 0x01));

                  ir_variable *const r259F = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r25A0 = lshift(swizzle_y(r24E9), body.constant(int(1)));
                  ir_expression *const r25A1 = lequal(body.constant(4292870144u), r25A0);
                  ir_expression *const r25A2 = nequal(swizzle_x(r24E9), body.constant(0u));
                  ir_expression *const r25A3 = bit_and(swizzle_y(r24E9), body.constant(1048575u));
                  ir_expression *const r25A4 = nequal(r25A3, body.constant(0u));
                  ir_expression *const r25A5 = logic_or(r25A2, r25A4);
                  body.emit(assign(r259F, logic_and(r25A1, r25A5), 0x01));

                  body.emit(assign(r2594, bit_or(swizzle_y(r1F1E), body.constant(524288u)), 0x02));

                  body.emit(assign(r2595, bit_or(swizzle_y(r24E9), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r25A7 = lshift(swizzle_y(r1F1E), body.constant(int(1)));
                  ir_expression *const r25A8 = lequal(body.constant(4292870144u), r25A7);
                  ir_expression *const r25A9 = nequal(swizzle_x(r1F1E), body.constant(0u));
                  ir_expression *const r25AA = bit_and(swizzle_y(r1F1E), body.constant(1048575u));
                  ir_expression *const r25AB = nequal(r25AA, body.constant(0u));
                  ir_expression *const r25AC = logic_or(r25A9, r25AB);
                  ir_expression *const r25AD = logic_and(r25A8, r25AC);
                  ir_if *f25A6 = new(mem_ctx) ir_if(operand(r25AD).val);
                  exec_list *const f25A6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f25A6->then_instructions;

                     ir_variable *const r25AE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r25B0 = logic_and(r2597, r259F);
                     ir_if *f25AF = new(mem_ctx) ir_if(operand(r25B0).val);
                     exec_list *const f25AF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25AF->then_instructions;

                        body.emit(assign(r25AE, r2595, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f25AF->else_instructions;

                        body.emit(assign(r25AE, r2594, 0x03));


                     body.instructions = f25AF_parent_instructions;
                     body.emit(f25AF);

                     /* END IF */

                     body.emit(assign(r2596, r25AE, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f25A6->else_instructions;

                     body.emit(assign(r2596, r2595, 0x03));


                  body.instructions = f25A6_parent_instructions;
                  body.emit(f25A6);

                  /* END IF */

                  body.emit(assign(r24F8, r2596, 0x03));

                  body.emit(assign(r24F7, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f258F->else_instructions;

                  body.emit(assign(r24F8, r1F1E, 0x03));

                  body.emit(assign(r24F7, body.constant(false), 0x01));


               body.instructions = f258F_parent_instructions;
               body.emit(f258F);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f258D->else_instructions;

               ir_variable *const r25B1 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r25B2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r25B2, add(r24FD, r24FB), 0x01));

               ir_expression *const r25B3 = add(r24FC, r24FA);
               ir_expression *const r25B4 = less(r25B2, r24FD);
               ir_expression *const r25B5 = expr(ir_unop_b2i, r25B4);
               ir_expression *const r25B6 = expr(ir_unop_i2u, r25B5);
               body.emit(assign(r25B1, add(r25B3, r25B6), 0x01));

               body.emit(assign(r2500, r25B1, 0x01));

               /* IF CONDITION */
               ir_expression *const r25B8 = equal(r2505, body.constant(int(0)));
               ir_if *f25B7 = new(mem_ctx) ir_if(operand(r25B8).val);
               exec_list *const f25B7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f25B7->then_instructions;

                  ir_variable *const r25B9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r25B9);
                  ir_expression *const r25BA = lshift(r24F3, body.constant(int(31)));
                  body.emit(assign(r25B9, add(r25BA, r25B1), 0x02));

                  body.emit(assign(r25B9, r25B2, 0x01));

                  body.emit(assign(r24F8, r25B9, 0x03));

                  body.emit(assign(r24F7, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f25B7->else_instructions;

                  body.emit(assign(r2500, bit_or(r25B1, body.constant(2097152u)), 0x01));

                  body.emit(assign(r24FE, r2505, 0x01));

                  ir_variable *const r25BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r25BB);
                  ir_variable *const r25BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r25BC);
                  ir_variable *const r25BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r25BD);
                  body.emit(assign(r25BB, lshift(r25B2, body.constant(int(31))), 0x01));

                  ir_expression *const r25BE = lshift(r2500, body.constant(int(31)));
                  ir_expression *const r25BF = rshift(r25B2, body.constant(int(1)));
                  body.emit(assign(r25BC, bit_or(r25BE, r25BF), 0x01));

                  body.emit(assign(r25BD, rshift(r2500, body.constant(int(1))), 0x01));

                  body.emit(assign(r25BB, bit_or(r25BB, body.constant(0u)), 0x01));

                  body.emit(assign(r2500, r25BD, 0x01));

                  body.emit(assign(r24FF, r25BB, 0x01));

                  ir_variable *const r25C0 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r25C0, r2505, 0x01));

                  ir_variable *const r25C1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r25C1, r25BD, 0x01));

                  ir_variable *const r25C2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r25C2, r25BC, 0x01));

                  ir_variable *const r25C3 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r25C3, r25BB, 0x01));

                  ir_variable *const r25C4 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r25C4, body.constant(true), 0x01));

                  ir_variable *const r25C5 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r25C6 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r25C6);
                  ir_expression *const r25C7 = expr(ir_unop_u2i, r25BB);
                  body.emit(assign(r25C6, less(r25C7, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r25C9 = lequal(body.constant(int(2045)), r2505);
                  ir_if *f25C8 = new(mem_ctx) ir_if(operand(r25C9).val);
                  exec_list *const f25C8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f25C8->then_instructions;

                     ir_variable *const r25CA = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r25CC = less(body.constant(int(2045)), r2505);
                     ir_if *f25CB = new(mem_ctx) ir_if(operand(r25CC).val);
                     exec_list *const f25CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25CB->then_instructions;

                        body.emit(assign(r25CA, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f25CB->else_instructions;

                        ir_variable *const r25CD = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r25CF = equal(r2505, body.constant(int(2045)));
                        ir_if *f25CE = new(mem_ctx) ir_if(operand(r25CF).val);
                        exec_list *const f25CE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25CE->then_instructions;

                           ir_expression *const r25D0 = equal(body.constant(2097151u), r25BD);
                           ir_expression *const r25D1 = equal(body.constant(4294967295u), r25BC);
                           body.emit(assign(r25CD, logic_and(r25D0, r25D1), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f25CE->else_instructions;

                           body.emit(assign(r25CD, body.constant(false), 0x01));


                        body.instructions = f25CE_parent_instructions;
                        body.emit(f25CE);

                        /* END IF */

                        body.emit(assign(r25CA, logic_and(r25CD, r25C6), 0x01));


                     body.instructions = f25CB_parent_instructions;
                     body.emit(f25CB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f25D2 = new(mem_ctx) ir_if(operand(r25CA).val);
                     exec_list *const f25D2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25D2->then_instructions;

                        ir_variable *const r25D3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r25D3);
                        ir_expression *const r25D4 = lshift(r24F3, body.constant(int(31)));
                        body.emit(assign(r25D3, add(r25D4, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r25D3, body.constant(0u), 0x01));

                        body.emit(assign(r25C5, r25D3, 0x03));

                        body.emit(assign(r25C4, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f25D2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r25D6 = less(r2505, body.constant(int(0)));
                        ir_if *f25D5 = new(mem_ctx) ir_if(operand(r25D6).val);
                        exec_list *const f25D5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25D5->then_instructions;

                           ir_variable *const r25D7 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r25D7, r25BB, 0x01));

                           ir_variable *const r25D8 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r25D8, neg(r2505), 0x01));

                           ir_variable *const r25D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r25D9);
                           ir_variable *const r25DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r25DA);
                           ir_variable *const r25DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r25DB);
                           ir_variable *const r25DC = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r25DD = neg(r25D8);
                           body.emit(assign(r25DC, bit_and(r25DD, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r25DF = equal(r25D8, body.constant(int(0)));
                           ir_if *f25DE = new(mem_ctx) ir_if(operand(r25DF).val);
                           exec_list *const f25DE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25DE->then_instructions;

                              body.emit(assign(r25D9, r25BB, 0x01));

                              body.emit(assign(r25DA, r25BC, 0x01));

                              body.emit(assign(r25DB, r25BD, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25DE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r25E1 = less(r25D8, body.constant(int(32)));
                              ir_if *f25E0 = new(mem_ctx) ir_if(operand(r25E1).val);
                              exec_list *const f25E0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f25E0->then_instructions;

                                 body.emit(assign(r25D9, lshift(r25BC, r25DC), 0x01));

                                 ir_expression *const r25E2 = lshift(r25BD, r25DC);
                                 ir_expression *const r25E3 = rshift(r25BC, r25D8);
                                 body.emit(assign(r25DA, bit_or(r25E2, r25E3), 0x01));

                                 body.emit(assign(r25DB, rshift(r25BD, r25D8), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f25E0->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r25E5 = equal(r25D8, body.constant(int(32)));
                                 ir_if *f25E4 = new(mem_ctx) ir_if(operand(r25E5).val);
                                 exec_list *const f25E4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f25E4->then_instructions;

                                    body.emit(assign(r25D9, r25BC, 0x01));

                                    body.emit(assign(r25DA, r25BD, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f25E4->else_instructions;

                                    body.emit(assign(r25D7, bit_or(r25BB, r25BC), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r25E7 = less(r25D8, body.constant(int(64)));
                                    ir_if *f25E6 = new(mem_ctx) ir_if(operand(r25E7).val);
                                    exec_list *const f25E6_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f25E6->then_instructions;

                                       body.emit(assign(r25D9, lshift(r25BD, r25DC), 0x01));

                                       ir_expression *const r25E8 = bit_and(r25D8, body.constant(int(31)));
                                       body.emit(assign(r25DA, rshift(r25BD, r25E8), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f25E6->else_instructions;

                                       ir_variable *const r25E9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r25EB = equal(r25D8, body.constant(int(64)));
                                       ir_if *f25EA = new(mem_ctx) ir_if(operand(r25EB).val);
                                       exec_list *const f25EA_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f25EA->then_instructions;

                                          body.emit(assign(r25E9, r25BD, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f25EA->else_instructions;

                                          ir_expression *const r25EC = nequal(r25BD, body.constant(0u));
                                          ir_expression *const r25ED = expr(ir_unop_b2i, r25EC);
                                          body.emit(assign(r25E9, expr(ir_unop_i2u, r25ED), 0x01));


                                       body.instructions = f25EA_parent_instructions;
                                       body.emit(f25EA);

                                       /* END IF */

                                       body.emit(assign(r25D9, r25E9, 0x01));

                                       body.emit(assign(r25DA, body.constant(0u), 0x01));


                                    body.instructions = f25E6_parent_instructions;
                                    body.emit(f25E6);

                                    /* END IF */


                                 body.instructions = f25E4_parent_instructions;
                                 body.emit(f25E4);

                                 /* END IF */

                                 body.emit(assign(r25DB, body.constant(0u), 0x01));


                              body.instructions = f25E0_parent_instructions;
                              body.emit(f25E0);

                              /* END IF */

                              ir_expression *const r25EE = nequal(r25D7, body.constant(0u));
                              ir_expression *const r25EF = expr(ir_unop_b2i, r25EE);
                              ir_expression *const r25F0 = expr(ir_unop_i2u, r25EF);
                              body.emit(assign(r25D9, bit_or(r25D9, r25F0), 0x01));


                           body.instructions = f25DE_parent_instructions;
                           body.emit(f25DE);

                           /* END IF */

                           body.emit(assign(r25C1, r25DB, 0x01));

                           body.emit(assign(r25C2, r25DA, 0x01));

                           body.emit(assign(r25C3, r25D9, 0x01));

                           body.emit(assign(r25C0, body.constant(int(0)), 0x01));

                           body.emit(assign(r25C6, less(r25D9, body.constant(0u)), 0x01));


                        body.instructions = f25D5_parent_instructions;
                        body.emit(f25D5);

                        /* END IF */


                     body.instructions = f25D2_parent_instructions;
                     body.emit(f25D2);

                     /* END IF */


                  body.instructions = f25C8_parent_instructions;
                  body.emit(f25C8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f25F1 = new(mem_ctx) ir_if(operand(r25C4).val);
                  exec_list *const f25F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f25F1->then_instructions;

                     /* IF CONDITION */
                     ir_if *f25F2 = new(mem_ctx) ir_if(operand(r25C6).val);
                     exec_list *const f25F2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25F2->then_instructions;

                        ir_variable *const r25F3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r25F3, add(r25C2, body.constant(1u)), 0x01));

                        ir_expression *const r25F4 = less(r25F3, r25C2);
                        ir_expression *const r25F5 = expr(ir_unop_b2i, r25F4);
                        ir_expression *const r25F6 = expr(ir_unop_i2u, r25F5);
                        body.emit(assign(r25C1, add(r25C1, r25F6), 0x01));

                        ir_expression *const r25F7 = equal(r25C3, body.constant(0u));
                        ir_expression *const r25F8 = expr(ir_unop_b2i, r25F7);
                        ir_expression *const r25F9 = expr(ir_unop_i2u, r25F8);
                        ir_expression *const r25FA = add(r25C3, r25F9);
                        ir_expression *const r25FB = bit_and(r25FA, body.constant(1u));
                        ir_expression *const r25FC = expr(ir_unop_bit_not, r25FB);
                        body.emit(assign(r25C2, bit_and(r25F3, r25FC), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f25F2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r25FE = bit_or(r25C1, r25C2);
                        ir_expression *const r25FF = equal(r25FE, body.constant(0u));
                        ir_if *f25FD = new(mem_ctx) ir_if(operand(r25FF).val);
                        exec_list *const f25FD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25FD->then_instructions;

                           body.emit(assign(r25C0, body.constant(int(0)), 0x01));


                        body.instructions = f25FD_parent_instructions;
                        body.emit(f25FD);

                        /* END IF */


                     body.instructions = f25F2_parent_instructions;
                     body.emit(f25F2);

                     /* END IF */

                     ir_variable *const r2600 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2600);
                     ir_expression *const r2601 = lshift(r24F3, body.constant(int(31)));
                     ir_expression *const r2602 = expr(ir_unop_i2u, r25C0);
                     ir_expression *const r2603 = lshift(r2602, body.constant(int(20)));
                     ir_expression *const r2604 = add(r2601, r2603);
                     body.emit(assign(r2600, add(r2604, r25C1), 0x02));

                     body.emit(assign(r2600, r25C2, 0x01));

                     body.emit(assign(r25C5, r2600, 0x03));

                     body.emit(assign(r25C4, body.constant(false), 0x01));


                  body.instructions = f25F1_parent_instructions;
                  body.emit(f25F1);

                  /* END IF */

                  body.emit(assign(r24F8, r25C5, 0x03));

                  body.emit(assign(r24F7, body.constant(false), 0x01));


               body.instructions = f25B7_parent_instructions;
               body.emit(f25B7);

               /* END IF */


            body.instructions = f258D_parent_instructions;
            body.emit(f258D);

            /* END IF */


         body.instructions = f254B_parent_instructions;
         body.emit(f254B);

         /* END IF */


      body.instructions = f250C_parent_instructions;
      body.emit(f250C);

      /* END IF */

      /* IF CONDITION */
      ir_if *f2605 = new(mem_ctx) ir_if(operand(r24F7).val);
      exec_list *const f2605_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2605->then_instructions;

         body.emit(assign(r24FC, bit_or(r24FC, body.constant(1048576u)), 0x01));

         ir_variable *const r2606 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r2607 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r2607, add(r24FD, r24FB), 0x01));

         ir_expression *const r2608 = add(r24FC, r24FA);
         ir_expression *const r2609 = less(r2607, r24FD);
         ir_expression *const r260A = expr(ir_unop_b2i, r2609);
         ir_expression *const r260B = expr(ir_unop_i2u, r260A);
         body.emit(assign(r2606, add(r2608, r260B), 0x01));

         body.emit(assign(r2500, r2606, 0x01));

         body.emit(assign(r24FE, add(r24FE, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r260D = less(r2606, body.constant(2097152u));
         ir_if *f260C = new(mem_ctx) ir_if(operand(r260D).val);
         exec_list *const f260C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f260C->then_instructions;

            ir_variable *const r260E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r260E, r24FE, 0x01));

            ir_variable *const r260F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r260F, r2606, 0x01));

            ir_variable *const r2610 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2610, r2607, 0x01));

            ir_variable *const r2611 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r2611, r24FF, 0x01));

            ir_variable *const r2612 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r2612, body.constant(true), 0x01));

            ir_variable *const r2613 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r2614 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r2614);
            ir_expression *const r2615 = expr(ir_unop_u2i, r24FF);
            body.emit(assign(r2614, less(r2615, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2617 = lequal(body.constant(int(2045)), r24FE);
            ir_if *f2616 = new(mem_ctx) ir_if(operand(r2617).val);
            exec_list *const f2616_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2616->then_instructions;

               ir_variable *const r2618 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r261A = less(body.constant(int(2045)), r24FE);
               ir_if *f2619 = new(mem_ctx) ir_if(operand(r261A).val);
               exec_list *const f2619_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2619->then_instructions;

                  body.emit(assign(r2618, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2619->else_instructions;

                  ir_variable *const r261B = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r261D = equal(r24FE, body.constant(int(2045)));
                  ir_if *f261C = new(mem_ctx) ir_if(operand(r261D).val);
                  exec_list *const f261C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f261C->then_instructions;

                     ir_expression *const r261E = equal(body.constant(2097151u), r2606);
                     ir_expression *const r261F = equal(body.constant(4294967295u), r2607);
                     body.emit(assign(r261B, logic_and(r261E, r261F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f261C->else_instructions;

                     body.emit(assign(r261B, body.constant(false), 0x01));


                  body.instructions = f261C_parent_instructions;
                  body.emit(f261C);

                  /* END IF */

                  body.emit(assign(r2618, logic_and(r261B, r2614), 0x01));


               body.instructions = f2619_parent_instructions;
               body.emit(f2619);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2620 = new(mem_ctx) ir_if(operand(r2618).val);
               exec_list *const f2620_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2620->then_instructions;

                  ir_variable *const r2621 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2621);
                  ir_expression *const r2622 = lshift(r24F3, body.constant(int(31)));
                  body.emit(assign(r2621, add(r2622, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2621, body.constant(0u), 0x01));

                  body.emit(assign(r2613, r2621, 0x03));

                  body.emit(assign(r2612, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2620->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2624 = less(r24FE, body.constant(int(0)));
                  ir_if *f2623 = new(mem_ctx) ir_if(operand(r2624).val);
                  exec_list *const f2623_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2623->then_instructions;

                     ir_variable *const r2625 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2625, r24FF, 0x01));

                     ir_variable *const r2626 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2626, neg(r24FE), 0x01));

                     ir_variable *const r2627 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2627);
                     ir_variable *const r2628 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2628);
                     ir_variable *const r2629 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2629);
                     ir_variable *const r262A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r262B = neg(r2626);
                     body.emit(assign(r262A, bit_and(r262B, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r262D = equal(r2626, body.constant(int(0)));
                     ir_if *f262C = new(mem_ctx) ir_if(operand(r262D).val);
                     exec_list *const f262C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f262C->then_instructions;

                        body.emit(assign(r2627, r24FF, 0x01));

                        body.emit(assign(r2628, r2607, 0x01));

                        body.emit(assign(r2629, r2606, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f262C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r262F = less(r2626, body.constant(int(32)));
                        ir_if *f262E = new(mem_ctx) ir_if(operand(r262F).val);
                        exec_list *const f262E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f262E->then_instructions;

                           body.emit(assign(r2627, lshift(r2607, r262A), 0x01));

                           ir_expression *const r2630 = lshift(r2606, r262A);
                           ir_expression *const r2631 = rshift(r2607, r2626);
                           body.emit(assign(r2628, bit_or(r2630, r2631), 0x01));

                           body.emit(assign(r2629, rshift(r2606, r2626), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f262E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2633 = equal(r2626, body.constant(int(32)));
                           ir_if *f2632 = new(mem_ctx) ir_if(operand(r2633).val);
                           exec_list *const f2632_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2632->then_instructions;

                              body.emit(assign(r2627, r2607, 0x01));

                              body.emit(assign(r2628, r2606, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2632->else_instructions;

                              body.emit(assign(r2625, bit_or(r24FF, r2607), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2635 = less(r2626, body.constant(int(64)));
                              ir_if *f2634 = new(mem_ctx) ir_if(operand(r2635).val);
                              exec_list *const f2634_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2634->then_instructions;

                                 body.emit(assign(r2627, lshift(r2606, r262A), 0x01));

                                 ir_expression *const r2636 = bit_and(r2626, body.constant(int(31)));
                                 body.emit(assign(r2628, rshift(r2606, r2636), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2634->else_instructions;

                                 ir_variable *const r2637 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2639 = equal(r2626, body.constant(int(64)));
                                 ir_if *f2638 = new(mem_ctx) ir_if(operand(r2639).val);
                                 exec_list *const f2638_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2638->then_instructions;

                                    body.emit(assign(r2637, r2606, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2638->else_instructions;

                                    ir_expression *const r263A = nequal(r2606, body.constant(0u));
                                    ir_expression *const r263B = expr(ir_unop_b2i, r263A);
                                    body.emit(assign(r2637, expr(ir_unop_i2u, r263B), 0x01));


                                 body.instructions = f2638_parent_instructions;
                                 body.emit(f2638);

                                 /* END IF */

                                 body.emit(assign(r2627, r2637, 0x01));

                                 body.emit(assign(r2628, body.constant(0u), 0x01));


                              body.instructions = f2634_parent_instructions;
                              body.emit(f2634);

                              /* END IF */


                           body.instructions = f2632_parent_instructions;
                           body.emit(f2632);

                           /* END IF */

                           body.emit(assign(r2629, body.constant(0u), 0x01));


                        body.instructions = f262E_parent_instructions;
                        body.emit(f262E);

                        /* END IF */

                        ir_expression *const r263C = nequal(r2625, body.constant(0u));
                        ir_expression *const r263D = expr(ir_unop_b2i, r263C);
                        ir_expression *const r263E = expr(ir_unop_i2u, r263D);
                        body.emit(assign(r2627, bit_or(r2627, r263E), 0x01));


                     body.instructions = f262C_parent_instructions;
                     body.emit(f262C);

                     /* END IF */

                     body.emit(assign(r260F, r2629, 0x01));

                     body.emit(assign(r2610, r2628, 0x01));

                     body.emit(assign(r2611, r2627, 0x01));

                     body.emit(assign(r260E, body.constant(int(0)), 0x01));

                     body.emit(assign(r2614, less(r2627, body.constant(0u)), 0x01));


                  body.instructions = f2623_parent_instructions;
                  body.emit(f2623);

                  /* END IF */


               body.instructions = f2620_parent_instructions;
               body.emit(f2620);

               /* END IF */


            body.instructions = f2616_parent_instructions;
            body.emit(f2616);

            /* END IF */

            /* IF CONDITION */
            ir_if *f263F = new(mem_ctx) ir_if(operand(r2612).val);
            exec_list *const f263F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f263F->then_instructions;

               /* IF CONDITION */
               ir_if *f2640 = new(mem_ctx) ir_if(operand(r2614).val);
               exec_list *const f2640_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2640->then_instructions;

                  ir_variable *const r2641 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2641, add(r2610, body.constant(1u)), 0x01));

                  ir_expression *const r2642 = less(r2641, r2610);
                  ir_expression *const r2643 = expr(ir_unop_b2i, r2642);
                  ir_expression *const r2644 = expr(ir_unop_i2u, r2643);
                  body.emit(assign(r260F, add(r260F, r2644), 0x01));

                  ir_expression *const r2645 = equal(r2611, body.constant(0u));
                  ir_expression *const r2646 = expr(ir_unop_b2i, r2645);
                  ir_expression *const r2647 = expr(ir_unop_i2u, r2646);
                  ir_expression *const r2648 = add(r2611, r2647);
                  ir_expression *const r2649 = bit_and(r2648, body.constant(1u));
                  ir_expression *const r264A = expr(ir_unop_bit_not, r2649);
                  body.emit(assign(r2610, bit_and(r2641, r264A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2640->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r264C = bit_or(r260F, r2610);
                  ir_expression *const r264D = equal(r264C, body.constant(0u));
                  ir_if *f264B = new(mem_ctx) ir_if(operand(r264D).val);
                  exec_list *const f264B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f264B->then_instructions;

                     body.emit(assign(r260E, body.constant(int(0)), 0x01));


                  body.instructions = f264B_parent_instructions;
                  body.emit(f264B);

                  /* END IF */


               body.instructions = f2640_parent_instructions;
               body.emit(f2640);

               /* END IF */

               ir_variable *const r264E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r264E);
               ir_expression *const r264F = lshift(r24F3, body.constant(int(31)));
               ir_expression *const r2650 = expr(ir_unop_i2u, r260E);
               ir_expression *const r2651 = lshift(r2650, body.constant(int(20)));
               ir_expression *const r2652 = add(r264F, r2651);
               body.emit(assign(r264E, add(r2652, r260F), 0x02));

               body.emit(assign(r264E, r2610, 0x01));

               body.emit(assign(r2613, r264E, 0x03));

               body.emit(assign(r2612, body.constant(false), 0x01));


            body.instructions = f263F_parent_instructions;
            body.emit(f263F);

            /* END IF */

            body.emit(assign(r24F8, r2613, 0x03));

            body.emit(assign(r24F7, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f260C->else_instructions;

            body.emit(assign(r24FE, add(r24FE, body.constant(int(1))), 0x01));

            ir_variable *const r2653 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r2653);
            ir_variable *const r2654 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r2654);
            ir_variable *const r2655 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r2655);
            body.emit(assign(r2653, lshift(r2607, body.constant(int(31))), 0x01));

            ir_expression *const r2656 = lshift(r2606, body.constant(int(31)));
            ir_expression *const r2657 = rshift(r2607, body.constant(int(1)));
            body.emit(assign(r2654, bit_or(r2656, r2657), 0x01));

            body.emit(assign(r2655, rshift(r2606, body.constant(int(1))), 0x01));

            ir_expression *const r2658 = nequal(r24FF, body.constant(0u));
            ir_expression *const r2659 = expr(ir_unop_b2i, r2658);
            ir_expression *const r265A = expr(ir_unop_i2u, r2659);
            body.emit(assign(r2653, bit_or(r2653, r265A), 0x01));

            body.emit(assign(r2500, r2655, 0x01));

            body.emit(assign(r24FF, r2653, 0x01));

            ir_variable *const r265B = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r265B, r24FE, 0x01));

            ir_variable *const r265C = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r265C, r2655, 0x01));

            ir_variable *const r265D = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r265D, r2654, 0x01));

            ir_variable *const r265E = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r265E, r2653, 0x01));

            ir_variable *const r265F = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r265F, body.constant(true), 0x01));

            ir_variable *const r2660 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r2661 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r2661);
            ir_expression *const r2662 = expr(ir_unop_u2i, r2653);
            body.emit(assign(r2661, less(r2662, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2664 = lequal(body.constant(int(2045)), r24FE);
            ir_if *f2663 = new(mem_ctx) ir_if(operand(r2664).val);
            exec_list *const f2663_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2663->then_instructions;

               ir_variable *const r2665 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r2667 = less(body.constant(int(2045)), r24FE);
               ir_if *f2666 = new(mem_ctx) ir_if(operand(r2667).val);
               exec_list *const f2666_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2666->then_instructions;

                  body.emit(assign(r2665, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2666->else_instructions;

                  ir_variable *const r2668 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r266A = equal(r24FE, body.constant(int(2045)));
                  ir_if *f2669 = new(mem_ctx) ir_if(operand(r266A).val);
                  exec_list *const f2669_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2669->then_instructions;

                     ir_expression *const r266B = equal(body.constant(2097151u), r2655);
                     ir_expression *const r266C = equal(body.constant(4294967295u), r2654);
                     body.emit(assign(r2668, logic_and(r266B, r266C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2669->else_instructions;

                     body.emit(assign(r2668, body.constant(false), 0x01));


                  body.instructions = f2669_parent_instructions;
                  body.emit(f2669);

                  /* END IF */

                  body.emit(assign(r2665, logic_and(r2668, r2661), 0x01));


               body.instructions = f2666_parent_instructions;
               body.emit(f2666);

               /* END IF */

               /* IF CONDITION */
               ir_if *f266D = new(mem_ctx) ir_if(operand(r2665).val);
               exec_list *const f266D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f266D->then_instructions;

                  ir_variable *const r266E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r266E);
                  ir_expression *const r266F = lshift(r24F3, body.constant(int(31)));
                  body.emit(assign(r266E, add(r266F, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r266E, body.constant(0u), 0x01));

                  body.emit(assign(r2660, r266E, 0x03));

                  body.emit(assign(r265F, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f266D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2671 = less(r24FE, body.constant(int(0)));
                  ir_if *f2670 = new(mem_ctx) ir_if(operand(r2671).val);
                  exec_list *const f2670_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2670->then_instructions;

                     ir_variable *const r2672 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2672, r2653, 0x01));

                     ir_variable *const r2673 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2673, neg(r24FE), 0x01));

                     ir_variable *const r2674 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2674);
                     ir_variable *const r2675 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2675);
                     ir_variable *const r2676 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2676);
                     ir_variable *const r2677 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r2678 = neg(r2673);
                     body.emit(assign(r2677, bit_and(r2678, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r267A = equal(r2673, body.constant(int(0)));
                     ir_if *f2679 = new(mem_ctx) ir_if(operand(r267A).val);
                     exec_list *const f2679_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2679->then_instructions;

                        body.emit(assign(r2674, r2653, 0x01));

                        body.emit(assign(r2675, r2654, 0x01));

                        body.emit(assign(r2676, r2655, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2679->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r267C = less(r2673, body.constant(int(32)));
                        ir_if *f267B = new(mem_ctx) ir_if(operand(r267C).val);
                        exec_list *const f267B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f267B->then_instructions;

                           body.emit(assign(r2674, lshift(r2654, r2677), 0x01));

                           ir_expression *const r267D = lshift(r2655, r2677);
                           ir_expression *const r267E = rshift(r2654, r2673);
                           body.emit(assign(r2675, bit_or(r267D, r267E), 0x01));

                           body.emit(assign(r2676, rshift(r2655, r2673), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f267B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2680 = equal(r2673, body.constant(int(32)));
                           ir_if *f267F = new(mem_ctx) ir_if(operand(r2680).val);
                           exec_list *const f267F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f267F->then_instructions;

                              body.emit(assign(r2674, r2654, 0x01));

                              body.emit(assign(r2675, r2655, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f267F->else_instructions;

                              body.emit(assign(r2672, bit_or(r2653, r2654), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2682 = less(r2673, body.constant(int(64)));
                              ir_if *f2681 = new(mem_ctx) ir_if(operand(r2682).val);
                              exec_list *const f2681_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2681->then_instructions;

                                 body.emit(assign(r2674, lshift(r2655, r2677), 0x01));

                                 ir_expression *const r2683 = bit_and(r2673, body.constant(int(31)));
                                 body.emit(assign(r2675, rshift(r2655, r2683), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2681->else_instructions;

                                 ir_variable *const r2684 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2686 = equal(r2673, body.constant(int(64)));
                                 ir_if *f2685 = new(mem_ctx) ir_if(operand(r2686).val);
                                 exec_list *const f2685_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2685->then_instructions;

                                    body.emit(assign(r2684, r2655, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2685->else_instructions;

                                    ir_expression *const r2687 = nequal(r2655, body.constant(0u));
                                    ir_expression *const r2688 = expr(ir_unop_b2i, r2687);
                                    body.emit(assign(r2684, expr(ir_unop_i2u, r2688), 0x01));


                                 body.instructions = f2685_parent_instructions;
                                 body.emit(f2685);

                                 /* END IF */

                                 body.emit(assign(r2674, r2684, 0x01));

                                 body.emit(assign(r2675, body.constant(0u), 0x01));


                              body.instructions = f2681_parent_instructions;
                              body.emit(f2681);

                              /* END IF */


                           body.instructions = f267F_parent_instructions;
                           body.emit(f267F);

                           /* END IF */

                           body.emit(assign(r2676, body.constant(0u), 0x01));


                        body.instructions = f267B_parent_instructions;
                        body.emit(f267B);

                        /* END IF */

                        ir_expression *const r2689 = nequal(r2672, body.constant(0u));
                        ir_expression *const r268A = expr(ir_unop_b2i, r2689);
                        ir_expression *const r268B = expr(ir_unop_i2u, r268A);
                        body.emit(assign(r2674, bit_or(r2674, r268B), 0x01));


                     body.instructions = f2679_parent_instructions;
                     body.emit(f2679);

                     /* END IF */

                     body.emit(assign(r265C, r2676, 0x01));

                     body.emit(assign(r265D, r2675, 0x01));

                     body.emit(assign(r265E, r2674, 0x01));

                     body.emit(assign(r265B, body.constant(int(0)), 0x01));

                     body.emit(assign(r2661, less(r2674, body.constant(0u)), 0x01));


                  body.instructions = f2670_parent_instructions;
                  body.emit(f2670);

                  /* END IF */


               body.instructions = f266D_parent_instructions;
               body.emit(f266D);

               /* END IF */


            body.instructions = f2663_parent_instructions;
            body.emit(f2663);

            /* END IF */

            /* IF CONDITION */
            ir_if *f268C = new(mem_ctx) ir_if(operand(r265F).val);
            exec_list *const f268C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f268C->then_instructions;

               /* IF CONDITION */
               ir_if *f268D = new(mem_ctx) ir_if(operand(r2661).val);
               exec_list *const f268D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f268D->then_instructions;

                  ir_variable *const r268E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r268E, add(r265D, body.constant(1u)), 0x01));

                  ir_expression *const r268F = less(r268E, r265D);
                  ir_expression *const r2690 = expr(ir_unop_b2i, r268F);
                  ir_expression *const r2691 = expr(ir_unop_i2u, r2690);
                  body.emit(assign(r265C, add(r265C, r2691), 0x01));

                  ir_expression *const r2692 = equal(r265E, body.constant(0u));
                  ir_expression *const r2693 = expr(ir_unop_b2i, r2692);
                  ir_expression *const r2694 = expr(ir_unop_i2u, r2693);
                  ir_expression *const r2695 = add(r265E, r2694);
                  ir_expression *const r2696 = bit_and(r2695, body.constant(1u));
                  ir_expression *const r2697 = expr(ir_unop_bit_not, r2696);
                  body.emit(assign(r265D, bit_and(r268E, r2697), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f268D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2699 = bit_or(r265C, r265D);
                  ir_expression *const r269A = equal(r2699, body.constant(0u));
                  ir_if *f2698 = new(mem_ctx) ir_if(operand(r269A).val);
                  exec_list *const f2698_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2698->then_instructions;

                     body.emit(assign(r265B, body.constant(int(0)), 0x01));


                  body.instructions = f2698_parent_instructions;
                  body.emit(f2698);

                  /* END IF */


               body.instructions = f268D_parent_instructions;
               body.emit(f268D);

               /* END IF */

               ir_variable *const r269B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r269B);
               ir_expression *const r269C = lshift(r24F3, body.constant(int(31)));
               ir_expression *const r269D = expr(ir_unop_i2u, r265B);
               ir_expression *const r269E = lshift(r269D, body.constant(int(20)));
               ir_expression *const r269F = add(r269C, r269E);
               body.emit(assign(r269B, add(r269F, r265C), 0x02));

               body.emit(assign(r269B, r265D, 0x01));

               body.emit(assign(r2660, r269B, 0x03));

               body.emit(assign(r265F, body.constant(false), 0x01));


            body.instructions = f268C_parent_instructions;
            body.emit(f268C);

            /* END IF */

            body.emit(assign(r24F8, r2660, 0x03));

            body.emit(assign(r24F7, body.constant(false), 0x01));


         body.instructions = f260C_parent_instructions;
         body.emit(f260C);

         /* END IF */


      body.instructions = f2605_parent_instructions;
      body.emit(f2605);

      /* END IF */

      body.emit(assign(r24F2, r24F8, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f24F5->else_instructions;

      ir_variable *const r26A0 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r26A0, r24F3, 0x01));

      ir_variable *const r26A1 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r26A2 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r26A2);
      ir_variable *const r26A3 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r26A3);
      ir_variable *const r26A4 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r26A4);
      ir_variable *const r26A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r26A5);
      ir_variable *const r26A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r26A6);
      ir_variable *const r26A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r26A7);
      ir_variable *const r26A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r26A8);
      ir_variable *const r26A9 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r26A9);
      ir_variable *const r26AA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r26AB = rshift(swizzle_y(r1F1E), body.constant(int(20)));
      ir_expression *const r26AC = bit_and(r26AB, body.constant(2047u));
      body.emit(assign(r26AA, expr(ir_unop_u2i, r26AC), 0x01));

      body.emit(assign(r26A4, r26AA, 0x01));

      ir_variable *const r26AD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r26AE = rshift(swizzle_y(r24E9), body.constant(int(20)));
      ir_expression *const r26AF = bit_and(r26AE, body.constant(2047u));
      body.emit(assign(r26AD, expr(ir_unop_u2i, r26AF), 0x01));

      body.emit(assign(r26A3, r26AD, 0x01));

      body.emit(assign(r26A2, sub(r26AA, r26AD), 0x01));

      ir_variable *const r26B0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r26B0, lshift(swizzle_x(r1F1E), body.constant(int(10))), 0x01));

      ir_variable *const r26B1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r26B2 = bit_and(swizzle_y(r1F1E), body.constant(1048575u));
      ir_expression *const r26B3 = lshift(r26B2, body.constant(int(10)));
      ir_expression *const r26B4 = rshift(swizzle_x(r1F1E), body.constant(int(22)));
      body.emit(assign(r26B1, bit_or(r26B3, r26B4), 0x01));

      body.emit(assign(r26A7, r26B1, 0x01));

      body.emit(assign(r26A8, r26B0, 0x01));

      ir_variable *const r26B5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r26B5, lshift(swizzle_x(r24E9), body.constant(int(10))), 0x01));

      ir_variable *const r26B6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r26B7 = bit_and(swizzle_y(r24E9), body.constant(1048575u));
      ir_expression *const r26B8 = lshift(r26B7, body.constant(int(10)));
      ir_expression *const r26B9 = rshift(swizzle_x(r24E9), body.constant(int(22)));
      body.emit(assign(r26B6, bit_or(r26B8, r26B9), 0x01));

      body.emit(assign(r26A5, r26B6, 0x01));

      body.emit(assign(r26A6, r26B5, 0x01));

      /* IF CONDITION */
      ir_expression *const r26BB = less(body.constant(int(0)), r26A2);
      ir_if *f26BA = new(mem_ctx) ir_if(operand(r26BB).val);
      exec_list *const f26BA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f26BA->then_instructions;

         /* IF CONDITION */
         ir_expression *const r26BD = equal(r26AA, body.constant(int(2047)));
         ir_if *f26BC = new(mem_ctx) ir_if(operand(r26BD).val);
         exec_list *const f26BC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f26BC->then_instructions;

            /* IF CONDITION */
            ir_expression *const r26BF = bit_or(r26B1, r26B0);
            ir_expression *const r26C0 = nequal(r26BF, body.constant(0u));
            ir_if *f26BE = new(mem_ctx) ir_if(operand(r26C0).val);
            exec_list *const f26BE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f26BE->then_instructions;

               ir_variable *const r26C1 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r26C1, swizzle_x(r1F1E), 0x01));

               ir_variable *const r26C2 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r26C2, swizzle_x(r24E9), 0x01));

               ir_variable *const r26C3 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r26C4 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r26C5 = rshift(swizzle_y(r1F1E), body.constant(int(19)));
               ir_expression *const r26C6 = bit_and(r26C5, body.constant(4095u));
               ir_expression *const r26C7 = equal(r26C6, body.constant(4094u));
               ir_expression *const r26C8 = nequal(swizzle_x(r1F1E), body.constant(0u));
               ir_expression *const r26C9 = bit_and(swizzle_y(r1F1E), body.constant(524287u));
               ir_expression *const r26CA = nequal(r26C9, body.constant(0u));
               ir_expression *const r26CB = logic_or(r26C8, r26CA);
               body.emit(assign(r26C4, logic_and(r26C7, r26CB), 0x01));

               ir_variable *const r26CC = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r26CD = lshift(swizzle_y(r24E9), body.constant(int(1)));
               ir_expression *const r26CE = lequal(body.constant(4292870144u), r26CD);
               ir_expression *const r26CF = nequal(swizzle_x(r24E9), body.constant(0u));
               ir_expression *const r26D0 = bit_and(swizzle_y(r24E9), body.constant(1048575u));
               ir_expression *const r26D1 = nequal(r26D0, body.constant(0u));
               ir_expression *const r26D2 = logic_or(r26CF, r26D1);
               body.emit(assign(r26CC, logic_and(r26CE, r26D2), 0x01));

               body.emit(assign(r26C1, bit_or(swizzle_y(r1F1E), body.constant(524288u)), 0x02));

               body.emit(assign(r26C2, bit_or(swizzle_y(r24E9), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r26D4 = lshift(swizzle_y(r1F1E), body.constant(int(1)));
               ir_expression *const r26D5 = lequal(body.constant(4292870144u), r26D4);
               ir_expression *const r26D6 = nequal(swizzle_x(r1F1E), body.constant(0u));
               ir_expression *const r26D7 = bit_and(swizzle_y(r1F1E), body.constant(1048575u));
               ir_expression *const r26D8 = nequal(r26D7, body.constant(0u));
               ir_expression *const r26D9 = logic_or(r26D6, r26D8);
               ir_expression *const r26DA = logic_and(r26D5, r26D9);
               ir_if *f26D3 = new(mem_ctx) ir_if(operand(r26DA).val);
               exec_list *const f26D3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f26D3->then_instructions;

                  ir_variable *const r26DB = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r26DD = logic_and(r26C4, r26CC);
                  ir_if *f26DC = new(mem_ctx) ir_if(operand(r26DD).val);
                  exec_list *const f26DC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f26DC->then_instructions;

                     body.emit(assign(r26DB, r26C2, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f26DC->else_instructions;

                     body.emit(assign(r26DB, r26C1, 0x03));


                  body.instructions = f26DC_parent_instructions;
                  body.emit(f26DC);

                  /* END IF */

                  body.emit(assign(r26C3, r26DB, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f26D3->else_instructions;

                  body.emit(assign(r26C3, r26C2, 0x03));


               body.instructions = f26D3_parent_instructions;
               body.emit(f26D3);

               /* END IF */

               body.emit(assign(r26A1, r26C3, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f26BE->else_instructions;

               body.emit(assign(r26A1, r1F1E, 0x03));


            body.instructions = f26BE_parent_instructions;
            body.emit(f26BE);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f26BC->else_instructions;

            /* IF CONDITION */
            ir_expression *const r26DF = equal(r26AD, body.constant(int(0)));
            ir_if *f26DE = new(mem_ctx) ir_if(operand(r26DF).val);
            exec_list *const f26DE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f26DE->then_instructions;

               body.emit(assign(r26A2, add(r26A2, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f26DE->else_instructions;

               body.emit(assign(r26A5, bit_or(r26B6, body.constant(1073741824u)), 0x01));


            body.instructions = f26DE_parent_instructions;
            body.emit(f26DE);

            /* END IF */

            ir_variable *const r26E0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r26E0);
            ir_variable *const r26E1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r26E1);
            ir_variable *const r26E2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r26E3 = neg(r26A2);
            body.emit(assign(r26E2, bit_and(r26E3, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r26E5 = equal(r26A2, body.constant(int(0)));
            ir_if *f26E4 = new(mem_ctx) ir_if(operand(r26E5).val);
            exec_list *const f26E4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f26E4->then_instructions;

               body.emit(assign(r26E0, r26B5, 0x01));

               body.emit(assign(r26E1, r26A5, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f26E4->else_instructions;

               /* IF CONDITION */
               ir_expression *const r26E7 = less(r26A2, body.constant(int(32)));
               ir_if *f26E6 = new(mem_ctx) ir_if(operand(r26E7).val);
               exec_list *const f26E6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f26E6->then_instructions;

                  ir_expression *const r26E8 = lshift(r26A5, r26E2);
                  ir_expression *const r26E9 = rshift(r26B5, r26A2);
                  ir_expression *const r26EA = bit_or(r26E8, r26E9);
                  ir_expression *const r26EB = lshift(r26B5, r26E2);
                  ir_expression *const r26EC = nequal(r26EB, body.constant(0u));
                  ir_expression *const r26ED = expr(ir_unop_b2i, r26EC);
                  ir_expression *const r26EE = expr(ir_unop_i2u, r26ED);
                  body.emit(assign(r26E0, bit_or(r26EA, r26EE), 0x01));

                  body.emit(assign(r26E1, rshift(r26A5, r26A2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f26E6->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r26F0 = equal(r26A2, body.constant(int(32)));
                  ir_if *f26EF = new(mem_ctx) ir_if(operand(r26F0).val);
                  exec_list *const f26EF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f26EF->then_instructions;

                     ir_expression *const r26F1 = nequal(r26B5, body.constant(0u));
                     ir_expression *const r26F2 = expr(ir_unop_b2i, r26F1);
                     ir_expression *const r26F3 = expr(ir_unop_i2u, r26F2);
                     body.emit(assign(r26E0, bit_or(r26A5, r26F3), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f26EF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r26F5 = less(r26A2, body.constant(int(64)));
                     ir_if *f26F4 = new(mem_ctx) ir_if(operand(r26F5).val);
                     exec_list *const f26F4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f26F4->then_instructions;

                        ir_expression *const r26F6 = bit_and(r26A2, body.constant(int(31)));
                        ir_expression *const r26F7 = rshift(r26A5, r26F6);
                        ir_expression *const r26F8 = lshift(r26A5, r26E2);
                        ir_expression *const r26F9 = bit_or(r26F8, r26B5);
                        ir_expression *const r26FA = nequal(r26F9, body.constant(0u));
                        ir_expression *const r26FB = expr(ir_unop_b2i, r26FA);
                        ir_expression *const r26FC = expr(ir_unop_i2u, r26FB);
                        body.emit(assign(r26E0, bit_or(r26F7, r26FC), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f26F4->else_instructions;

                        ir_expression *const r26FD = bit_or(r26A5, r26B5);
                        ir_expression *const r26FE = nequal(r26FD, body.constant(0u));
                        ir_expression *const r26FF = expr(ir_unop_b2i, r26FE);
                        body.emit(assign(r26E0, expr(ir_unop_i2u, r26FF), 0x01));


                     body.instructions = f26F4_parent_instructions;
                     body.emit(f26F4);

                     /* END IF */


                  body.instructions = f26EF_parent_instructions;
                  body.emit(f26EF);

                  /* END IF */

                  body.emit(assign(r26E1, body.constant(0u), 0x01));


               body.instructions = f26E6_parent_instructions;
               body.emit(f26E6);

               /* END IF */


            body.instructions = f26E4_parent_instructions;
            body.emit(f26E4);

            /* END IF */

            body.emit(assign(r26A5, r26E1, 0x01));

            body.emit(assign(r26A6, r26E0, 0x01));

            body.emit(assign(r26A7, bit_or(r26B1, body.constant(1073741824u)), 0x01));

            ir_variable *const r2700 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2701 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r2701, sub(r26B0, r26E0), 0x01));

            ir_expression *const r2702 = sub(r26A7, r26E1);
            ir_expression *const r2703 = less(r26B0, r26E0);
            ir_expression *const r2704 = expr(ir_unop_b2i, r2703);
            ir_expression *const r2705 = expr(ir_unop_i2u, r2704);
            body.emit(assign(r2700, sub(r2702, r2705), 0x01));

            body.emit(assign(r26A9, add(r26AA, body.constant(int(-1))), 0x01));

            ir_variable *const r2706 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r2706, add(r26A9, body.constant(int(-10))), 0x01));

            ir_variable *const r2707 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r2707, r2700, 0x01));

            ir_variable *const r2708 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2708, r2701, 0x01));

            ir_variable *const r2709 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r2709);
            ir_variable *const r270A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r270A);
            /* IF CONDITION */
            ir_expression *const r270C = equal(r2700, body.constant(0u));
            ir_if *f270B = new(mem_ctx) ir_if(operand(r270C).val);
            exec_list *const f270B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f270B->then_instructions;

               body.emit(assign(r2707, r2701, 0x01));

               body.emit(assign(r2708, body.constant(0u), 0x01));

               body.emit(assign(r2706, add(r2706, body.constant(int(-32))), 0x01));


            body.instructions = f270B_parent_instructions;
            body.emit(f270B);

            /* END IF */

            ir_variable *const r270D = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r270D, r2707, 0x01));

            ir_variable *const r270E = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r270F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r270F);
            /* IF CONDITION */
            ir_expression *const r2711 = equal(r2707, body.constant(0u));
            ir_if *f2710 = new(mem_ctx) ir_if(operand(r2711).val);
            exec_list *const f2710_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2710->then_instructions;

               body.emit(assign(r270E, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2710->else_instructions;

               body.emit(assign(r270F, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r2713 = bit_and(r2707, body.constant(4294901760u));
               ir_expression *const r2714 = equal(r2713, body.constant(0u));
               ir_if *f2712 = new(mem_ctx) ir_if(operand(r2714).val);
               exec_list *const f2712_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2712->then_instructions;

                  body.emit(assign(r270F, body.constant(int(16)), 0x01));

                  body.emit(assign(r270D, lshift(r2707, body.constant(int(16))), 0x01));


               body.instructions = f2712_parent_instructions;
               body.emit(f2712);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2716 = bit_and(r270D, body.constant(4278190080u));
               ir_expression *const r2717 = equal(r2716, body.constant(0u));
               ir_if *f2715 = new(mem_ctx) ir_if(operand(r2717).val);
               exec_list *const f2715_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2715->then_instructions;

                  body.emit(assign(r270F, add(r270F, body.constant(int(8))), 0x01));

                  body.emit(assign(r270D, lshift(r270D, body.constant(int(8))), 0x01));


               body.instructions = f2715_parent_instructions;
               body.emit(f2715);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2719 = bit_and(r270D, body.constant(4026531840u));
               ir_expression *const r271A = equal(r2719, body.constant(0u));
               ir_if *f2718 = new(mem_ctx) ir_if(operand(r271A).val);
               exec_list *const f2718_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2718->then_instructions;

                  body.emit(assign(r270F, add(r270F, body.constant(int(4))), 0x01));

                  body.emit(assign(r270D, lshift(r270D, body.constant(int(4))), 0x01));


               body.instructions = f2718_parent_instructions;
               body.emit(f2718);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r271C = bit_and(r270D, body.constant(3221225472u));
               ir_expression *const r271D = equal(r271C, body.constant(0u));
               ir_if *f271B = new(mem_ctx) ir_if(operand(r271D).val);
               exec_list *const f271B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f271B->then_instructions;

                  body.emit(assign(r270F, add(r270F, body.constant(int(2))), 0x01));

                  body.emit(assign(r270D, lshift(r270D, body.constant(int(2))), 0x01));


               body.instructions = f271B_parent_instructions;
               body.emit(f271B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r271F = bit_and(r270D, body.constant(2147483648u));
               ir_expression *const r2720 = equal(r271F, body.constant(0u));
               ir_if *f271E = new(mem_ctx) ir_if(operand(r2720).val);
               exec_list *const f271E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f271E->then_instructions;

                  body.emit(assign(r270F, add(r270F, body.constant(int(1))), 0x01));


               body.instructions = f271E_parent_instructions;
               body.emit(f271E);

               /* END IF */

               body.emit(assign(r270E, r270F, 0x01));


            body.instructions = f2710_parent_instructions;
            body.emit(f2710);

            /* END IF */

            body.emit(assign(r270A, add(r270E, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2722 = lequal(body.constant(int(0)), r270A);
            ir_if *f2721 = new(mem_ctx) ir_if(operand(r2722).val);
            exec_list *const f2721_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2721->then_instructions;

               body.emit(assign(r2709, body.constant(0u), 0x01));

               ir_variable *const r2723 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2723, lshift(r2708, r270A), 0x01));

               ir_variable *const r2724 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r2726 = equal(r270A, body.constant(int(0)));
               ir_if *f2725 = new(mem_ctx) ir_if(operand(r2726).val);
               exec_list *const f2725_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2725->then_instructions;

                  body.emit(assign(r2724, r2707, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2725->else_instructions;

                  ir_expression *const r2727 = lshift(r2707, r270A);
                  ir_expression *const r2728 = neg(r270A);
                  ir_expression *const r2729 = bit_and(r2728, body.constant(int(31)));
                  ir_expression *const r272A = rshift(r2708, r2729);
                  body.emit(assign(r2724, bit_or(r2727, r272A), 0x01));


               body.instructions = f2725_parent_instructions;
               body.emit(f2725);

               /* END IF */

               body.emit(assign(r2707, r2724, 0x01));

               body.emit(assign(r2708, r2723, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2721->else_instructions;

               ir_variable *const r272B = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r272B, body.constant(0u), 0x01));

               ir_variable *const r272C = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r272C, neg(r270A), 0x01));

               ir_variable *const r272D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r272D);
               ir_variable *const r272E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r272E);
               ir_variable *const r272F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r272F);
               ir_variable *const r2730 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2731 = neg(r272C);
               body.emit(assign(r2730, bit_and(r2731, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2733 = equal(r272C, body.constant(int(0)));
               ir_if *f2732 = new(mem_ctx) ir_if(operand(r2733).val);
               exec_list *const f2732_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2732->then_instructions;

                  body.emit(assign(r272D, r272B, 0x01));

                  body.emit(assign(r272E, r2708, 0x01));

                  body.emit(assign(r272F, r2707, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2732->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2735 = less(r272C, body.constant(int(32)));
                  ir_if *f2734 = new(mem_ctx) ir_if(operand(r2735).val);
                  exec_list *const f2734_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2734->then_instructions;

                     body.emit(assign(r272D, lshift(r2708, r2730), 0x01));

                     ir_expression *const r2736 = lshift(r2707, r2730);
                     ir_expression *const r2737 = rshift(r2708, r272C);
                     body.emit(assign(r272E, bit_or(r2736, r2737), 0x01));

                     body.emit(assign(r272F, rshift(r2707, r272C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2734->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2739 = equal(r272C, body.constant(int(32)));
                     ir_if *f2738 = new(mem_ctx) ir_if(operand(r2739).val);
                     exec_list *const f2738_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2738->then_instructions;

                        body.emit(assign(r272D, r2708, 0x01));

                        body.emit(assign(r272E, r2707, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2738->else_instructions;

                        body.emit(assign(r272B, bit_or(body.constant(0u), r2708), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r273B = less(r272C, body.constant(int(64)));
                        ir_if *f273A = new(mem_ctx) ir_if(operand(r273B).val);
                        exec_list *const f273A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f273A->then_instructions;

                           body.emit(assign(r272D, lshift(r2707, r2730), 0x01));

                           ir_expression *const r273C = bit_and(r272C, body.constant(int(31)));
                           body.emit(assign(r272E, rshift(r2707, r273C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f273A->else_instructions;

                           ir_variable *const r273D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r273F = equal(r272C, body.constant(int(64)));
                           ir_if *f273E = new(mem_ctx) ir_if(operand(r273F).val);
                           exec_list *const f273E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f273E->then_instructions;

                              body.emit(assign(r273D, r2707, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f273E->else_instructions;

                              ir_expression *const r2740 = nequal(r2707, body.constant(0u));
                              ir_expression *const r2741 = expr(ir_unop_b2i, r2740);
                              body.emit(assign(r273D, expr(ir_unop_i2u, r2741), 0x01));


                           body.instructions = f273E_parent_instructions;
                           body.emit(f273E);

                           /* END IF */

                           body.emit(assign(r272D, r273D, 0x01));

                           body.emit(assign(r272E, body.constant(0u), 0x01));


                        body.instructions = f273A_parent_instructions;
                        body.emit(f273A);

                        /* END IF */


                     body.instructions = f2738_parent_instructions;
                     body.emit(f2738);

                     /* END IF */

                     body.emit(assign(r272F, body.constant(0u), 0x01));


                  body.instructions = f2734_parent_instructions;
                  body.emit(f2734);

                  /* END IF */

                  ir_expression *const r2742 = nequal(r272B, body.constant(0u));
                  ir_expression *const r2743 = expr(ir_unop_b2i, r2742);
                  ir_expression *const r2744 = expr(ir_unop_i2u, r2743);
                  body.emit(assign(r272D, bit_or(r272D, r2744), 0x01));


               body.instructions = f2732_parent_instructions;
               body.emit(f2732);

               /* END IF */

               body.emit(assign(r2707, r272F, 0x01));

               body.emit(assign(r2708, r272E, 0x01));

               body.emit(assign(r2709, r272D, 0x01));


            body.instructions = f2721_parent_instructions;
            body.emit(f2721);

            /* END IF */

            body.emit(assign(r2706, sub(r2706, r270A), 0x01));

            ir_variable *const r2745 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r2745, r2706, 0x01));

            ir_variable *const r2746 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r2746, r2707, 0x01));

            ir_variable *const r2747 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2747, r2708, 0x01));

            ir_variable *const r2748 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r2748, r2709, 0x01));

            ir_variable *const r2749 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r2749, body.constant(true), 0x01));

            ir_variable *const r274A = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r274B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r274B);
            ir_expression *const r274C = expr(ir_unop_u2i, r2709);
            body.emit(assign(r274B, less(r274C, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r274E = lequal(body.constant(int(2045)), r2706);
            ir_if *f274D = new(mem_ctx) ir_if(operand(r274E).val);
            exec_list *const f274D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f274D->then_instructions;

               ir_variable *const r274F = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r2751 = less(body.constant(int(2045)), r2706);
               ir_if *f2750 = new(mem_ctx) ir_if(operand(r2751).val);
               exec_list *const f2750_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2750->then_instructions;

                  body.emit(assign(r274F, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2750->else_instructions;

                  ir_variable *const r2752 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2754 = equal(r2706, body.constant(int(2045)));
                  ir_if *f2753 = new(mem_ctx) ir_if(operand(r2754).val);
                  exec_list *const f2753_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2753->then_instructions;

                     ir_expression *const r2755 = equal(body.constant(2097151u), r2707);
                     ir_expression *const r2756 = equal(body.constant(4294967295u), r2708);
                     body.emit(assign(r2752, logic_and(r2755, r2756), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2753->else_instructions;

                     body.emit(assign(r2752, body.constant(false), 0x01));


                  body.instructions = f2753_parent_instructions;
                  body.emit(f2753);

                  /* END IF */

                  body.emit(assign(r274F, logic_and(r2752, r274B), 0x01));


               body.instructions = f2750_parent_instructions;
               body.emit(f2750);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2757 = new(mem_ctx) ir_if(operand(r274F).val);
               exec_list *const f2757_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2757->then_instructions;

                  ir_variable *const r2758 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2758);
                  ir_expression *const r2759 = lshift(r24F3, body.constant(int(31)));
                  body.emit(assign(r2758, add(r2759, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2758, body.constant(0u), 0x01));

                  body.emit(assign(r274A, r2758, 0x03));

                  body.emit(assign(r2749, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2757->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r275B = less(r2706, body.constant(int(0)));
                  ir_if *f275A = new(mem_ctx) ir_if(operand(r275B).val);
                  exec_list *const f275A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f275A->then_instructions;

                     ir_variable *const r275C = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r275C, r2709, 0x01));

                     ir_variable *const r275D = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r275D, neg(r2706), 0x01));

                     ir_variable *const r275E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r275E);
                     ir_variable *const r275F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r275F);
                     ir_variable *const r2760 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2760);
                     ir_variable *const r2761 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r2762 = neg(r275D);
                     body.emit(assign(r2761, bit_and(r2762, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2764 = equal(r275D, body.constant(int(0)));
                     ir_if *f2763 = new(mem_ctx) ir_if(operand(r2764).val);
                     exec_list *const f2763_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2763->then_instructions;

                        body.emit(assign(r275E, r2709, 0x01));

                        body.emit(assign(r275F, r2708, 0x01));

                        body.emit(assign(r2760, r2707, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2763->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2766 = less(r275D, body.constant(int(32)));
                        ir_if *f2765 = new(mem_ctx) ir_if(operand(r2766).val);
                        exec_list *const f2765_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2765->then_instructions;

                           body.emit(assign(r275E, lshift(r2708, r2761), 0x01));

                           ir_expression *const r2767 = lshift(r2707, r2761);
                           ir_expression *const r2768 = rshift(r2708, r275D);
                           body.emit(assign(r275F, bit_or(r2767, r2768), 0x01));

                           body.emit(assign(r2760, rshift(r2707, r275D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2765->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r276A = equal(r275D, body.constant(int(32)));
                           ir_if *f2769 = new(mem_ctx) ir_if(operand(r276A).val);
                           exec_list *const f2769_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2769->then_instructions;

                              body.emit(assign(r275E, r2708, 0x01));

                              body.emit(assign(r275F, r2707, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2769->else_instructions;

                              body.emit(assign(r275C, bit_or(r2709, r2708), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r276C = less(r275D, body.constant(int(64)));
                              ir_if *f276B = new(mem_ctx) ir_if(operand(r276C).val);
                              exec_list *const f276B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f276B->then_instructions;

                                 body.emit(assign(r275E, lshift(r2707, r2761), 0x01));

                                 ir_expression *const r276D = bit_and(r275D, body.constant(int(31)));
                                 body.emit(assign(r275F, rshift(r2707, r276D), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f276B->else_instructions;

                                 ir_variable *const r276E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2770 = equal(r275D, body.constant(int(64)));
                                 ir_if *f276F = new(mem_ctx) ir_if(operand(r2770).val);
                                 exec_list *const f276F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f276F->then_instructions;

                                    body.emit(assign(r276E, r2707, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f276F->else_instructions;

                                    ir_expression *const r2771 = nequal(r2707, body.constant(0u));
                                    ir_expression *const r2772 = expr(ir_unop_b2i, r2771);
                                    body.emit(assign(r276E, expr(ir_unop_i2u, r2772), 0x01));


                                 body.instructions = f276F_parent_instructions;
                                 body.emit(f276F);

                                 /* END IF */

                                 body.emit(assign(r275E, r276E, 0x01));

                                 body.emit(assign(r275F, body.constant(0u), 0x01));


                              body.instructions = f276B_parent_instructions;
                              body.emit(f276B);

                              /* END IF */


                           body.instructions = f2769_parent_instructions;
                           body.emit(f2769);

                           /* END IF */

                           body.emit(assign(r2760, body.constant(0u), 0x01));


                        body.instructions = f2765_parent_instructions;
                        body.emit(f2765);

                        /* END IF */

                        ir_expression *const r2773 = nequal(r275C, body.constant(0u));
                        ir_expression *const r2774 = expr(ir_unop_b2i, r2773);
                        ir_expression *const r2775 = expr(ir_unop_i2u, r2774);
                        body.emit(assign(r275E, bit_or(r275E, r2775), 0x01));


                     body.instructions = f2763_parent_instructions;
                     body.emit(f2763);

                     /* END IF */

                     body.emit(assign(r2746, r2760, 0x01));

                     body.emit(assign(r2747, r275F, 0x01));

                     body.emit(assign(r2748, r275E, 0x01));

                     body.emit(assign(r2745, body.constant(int(0)), 0x01));

                     body.emit(assign(r274B, less(r275E, body.constant(0u)), 0x01));


                  body.instructions = f275A_parent_instructions;
                  body.emit(f275A);

                  /* END IF */


               body.instructions = f2757_parent_instructions;
               body.emit(f2757);

               /* END IF */


            body.instructions = f274D_parent_instructions;
            body.emit(f274D);

            /* END IF */

            /* IF CONDITION */
            ir_if *f2776 = new(mem_ctx) ir_if(operand(r2749).val);
            exec_list *const f2776_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2776->then_instructions;

               /* IF CONDITION */
               ir_if *f2777 = new(mem_ctx) ir_if(operand(r274B).val);
               exec_list *const f2777_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2777->then_instructions;

                  ir_variable *const r2778 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2778, add(r2747, body.constant(1u)), 0x01));

                  ir_expression *const r2779 = less(r2778, r2747);
                  ir_expression *const r277A = expr(ir_unop_b2i, r2779);
                  ir_expression *const r277B = expr(ir_unop_i2u, r277A);
                  body.emit(assign(r2746, add(r2746, r277B), 0x01));

                  ir_expression *const r277C = equal(r2748, body.constant(0u));
                  ir_expression *const r277D = expr(ir_unop_b2i, r277C);
                  ir_expression *const r277E = expr(ir_unop_i2u, r277D);
                  ir_expression *const r277F = add(r2748, r277E);
                  ir_expression *const r2780 = bit_and(r277F, body.constant(1u));
                  ir_expression *const r2781 = expr(ir_unop_bit_not, r2780);
                  body.emit(assign(r2747, bit_and(r2778, r2781), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2777->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2783 = bit_or(r2746, r2747);
                  ir_expression *const r2784 = equal(r2783, body.constant(0u));
                  ir_if *f2782 = new(mem_ctx) ir_if(operand(r2784).val);
                  exec_list *const f2782_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2782->then_instructions;

                     body.emit(assign(r2745, body.constant(int(0)), 0x01));


                  body.instructions = f2782_parent_instructions;
                  body.emit(f2782);

                  /* END IF */


               body.instructions = f2777_parent_instructions;
               body.emit(f2777);

               /* END IF */

               ir_variable *const r2785 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r2785);
               ir_expression *const r2786 = lshift(r24F3, body.constant(int(31)));
               ir_expression *const r2787 = expr(ir_unop_i2u, r2745);
               ir_expression *const r2788 = lshift(r2787, body.constant(int(20)));
               ir_expression *const r2789 = add(r2786, r2788);
               body.emit(assign(r2785, add(r2789, r2746), 0x02));

               body.emit(assign(r2785, r2747, 0x01));

               body.emit(assign(r274A, r2785, 0x03));

               body.emit(assign(r2749, body.constant(false), 0x01));


            body.instructions = f2776_parent_instructions;
            body.emit(f2776);

            /* END IF */

            body.emit(assign(r26A1, r274A, 0x03));


         body.instructions = f26BC_parent_instructions;
         body.emit(f26BC);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f26BA->else_instructions;

         /* IF CONDITION */
         ir_expression *const r278B = less(r26A2, body.constant(int(0)));
         ir_if *f278A = new(mem_ctx) ir_if(operand(r278B).val);
         exec_list *const f278A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f278A->then_instructions;

            /* IF CONDITION */
            ir_expression *const r278D = equal(r26AD, body.constant(int(2047)));
            ir_if *f278C = new(mem_ctx) ir_if(operand(r278D).val);
            exec_list *const f278C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f278C->then_instructions;

               /* IF CONDITION */
               ir_expression *const r278F = bit_or(r26A5, r26A6);
               ir_expression *const r2790 = nequal(r278F, body.constant(0u));
               ir_if *f278E = new(mem_ctx) ir_if(operand(r2790).val);
               exec_list *const f278E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f278E->then_instructions;

                  ir_variable *const r2791 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2791, swizzle_x(r1F1E), 0x01));

                  ir_variable *const r2792 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2792, swizzle_x(r24E9), 0x01));

                  ir_variable *const r2793 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2794 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2795 = rshift(swizzle_y(r1F1E), body.constant(int(19)));
                  ir_expression *const r2796 = bit_and(r2795, body.constant(4095u));
                  ir_expression *const r2797 = equal(r2796, body.constant(4094u));
                  ir_expression *const r2798 = nequal(swizzle_x(r1F1E), body.constant(0u));
                  ir_expression *const r2799 = bit_and(swizzle_y(r1F1E), body.constant(524287u));
                  ir_expression *const r279A = nequal(r2799, body.constant(0u));
                  ir_expression *const r279B = logic_or(r2798, r279A);
                  body.emit(assign(r2794, logic_and(r2797, r279B), 0x01));

                  ir_variable *const r279C = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r279D = lshift(swizzle_y(r24E9), body.constant(int(1)));
                  ir_expression *const r279E = lequal(body.constant(4292870144u), r279D);
                  ir_expression *const r279F = nequal(swizzle_x(r24E9), body.constant(0u));
                  ir_expression *const r27A0 = bit_and(swizzle_y(r24E9), body.constant(1048575u));
                  ir_expression *const r27A1 = nequal(r27A0, body.constant(0u));
                  ir_expression *const r27A2 = logic_or(r279F, r27A1);
                  body.emit(assign(r279C, logic_and(r279E, r27A2), 0x01));

                  body.emit(assign(r2791, bit_or(swizzle_y(r1F1E), body.constant(524288u)), 0x02));

                  body.emit(assign(r2792, bit_or(swizzle_y(r24E9), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r27A4 = lshift(swizzle_y(r1F1E), body.constant(int(1)));
                  ir_expression *const r27A5 = lequal(body.constant(4292870144u), r27A4);
                  ir_expression *const r27A6 = nequal(swizzle_x(r1F1E), body.constant(0u));
                  ir_expression *const r27A7 = bit_and(swizzle_y(r1F1E), body.constant(1048575u));
                  ir_expression *const r27A8 = nequal(r27A7, body.constant(0u));
                  ir_expression *const r27A9 = logic_or(r27A6, r27A8);
                  ir_expression *const r27AA = logic_and(r27A5, r27A9);
                  ir_if *f27A3 = new(mem_ctx) ir_if(operand(r27AA).val);
                  exec_list *const f27A3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27A3->then_instructions;

                     ir_variable *const r27AB = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r27AD = logic_and(r2794, r279C);
                     ir_if *f27AC = new(mem_ctx) ir_if(operand(r27AD).val);
                     exec_list *const f27AC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f27AC->then_instructions;

                        body.emit(assign(r27AB, r2792, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f27AC->else_instructions;

                        body.emit(assign(r27AB, r2791, 0x03));


                     body.instructions = f27AC_parent_instructions;
                     body.emit(f27AC);

                     /* END IF */

                     body.emit(assign(r2793, r27AB, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27A3->else_instructions;

                     body.emit(assign(r2793, r2792, 0x03));


                  body.instructions = f27A3_parent_instructions;
                  body.emit(f27A3);

                  /* END IF */

                  body.emit(assign(r26A1, r2793, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f278E->else_instructions;

                  ir_variable *const r27AE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r27AE);
                  ir_expression *const r27AF = bit_xor(r24F3, body.constant(1u));
                  ir_expression *const r27B0 = lshift(r27AF, body.constant(int(31)));
                  body.emit(assign(r27AE, add(r27B0, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r27AE, body.constant(0u), 0x01));

                  body.emit(assign(r26A1, r27AE, 0x03));


               body.instructions = f278E_parent_instructions;
               body.emit(f278E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f278C->else_instructions;

               /* IF CONDITION */
               ir_expression *const r27B2 = equal(r26AA, body.constant(int(0)));
               ir_if *f27B1 = new(mem_ctx) ir_if(operand(r27B2).val);
               exec_list *const f27B1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27B1->then_instructions;

                  body.emit(assign(r26A2, add(r26A2, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f27B1->else_instructions;

                  body.emit(assign(r26A7, bit_or(r26A7, body.constant(1073741824u)), 0x01));


               body.instructions = f27B1_parent_instructions;
               body.emit(f27B1);

               /* END IF */

               ir_variable *const r27B3 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r27B3, neg(r26A2), 0x01));

               ir_variable *const r27B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r27B4);
               ir_variable *const r27B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r27B5);
               ir_variable *const r27B6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r27B7 = neg(r27B3);
               body.emit(assign(r27B6, bit_and(r27B7, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r27B9 = equal(r27B3, body.constant(int(0)));
               ir_if *f27B8 = new(mem_ctx) ir_if(operand(r27B9).val);
               exec_list *const f27B8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27B8->then_instructions;

                  body.emit(assign(r27B4, r26B0, 0x01));

                  body.emit(assign(r27B5, r26A7, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f27B8->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r27BB = less(r27B3, body.constant(int(32)));
                  ir_if *f27BA = new(mem_ctx) ir_if(operand(r27BB).val);
                  exec_list *const f27BA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27BA->then_instructions;

                     ir_expression *const r27BC = lshift(r26A7, r27B6);
                     ir_expression *const r27BD = rshift(r26B0, r27B3);
                     ir_expression *const r27BE = bit_or(r27BC, r27BD);
                     ir_expression *const r27BF = lshift(r26B0, r27B6);
                     ir_expression *const r27C0 = nequal(r27BF, body.constant(0u));
                     ir_expression *const r27C1 = expr(ir_unop_b2i, r27C0);
                     ir_expression *const r27C2 = expr(ir_unop_i2u, r27C1);
                     body.emit(assign(r27B4, bit_or(r27BE, r27C2), 0x01));

                     body.emit(assign(r27B5, rshift(r26A7, r27B3), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27BA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r27C4 = equal(r27B3, body.constant(int(32)));
                     ir_if *f27C3 = new(mem_ctx) ir_if(operand(r27C4).val);
                     exec_list *const f27C3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f27C3->then_instructions;

                        ir_expression *const r27C5 = nequal(r26B0, body.constant(0u));
                        ir_expression *const r27C6 = expr(ir_unop_b2i, r27C5);
                        ir_expression *const r27C7 = expr(ir_unop_i2u, r27C6);
                        body.emit(assign(r27B4, bit_or(r26A7, r27C7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f27C3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r27C9 = less(r27B3, body.constant(int(64)));
                        ir_if *f27C8 = new(mem_ctx) ir_if(operand(r27C9).val);
                        exec_list *const f27C8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f27C8->then_instructions;

                           ir_expression *const r27CA = bit_and(r27B3, body.constant(int(31)));
                           ir_expression *const r27CB = rshift(r26A7, r27CA);
                           ir_expression *const r27CC = lshift(r26A7, r27B6);
                           ir_expression *const r27CD = bit_or(r27CC, r26B0);
                           ir_expression *const r27CE = nequal(r27CD, body.constant(0u));
                           ir_expression *const r27CF = expr(ir_unop_b2i, r27CE);
                           ir_expression *const r27D0 = expr(ir_unop_i2u, r27CF);
                           body.emit(assign(r27B4, bit_or(r27CB, r27D0), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f27C8->else_instructions;

                           ir_expression *const r27D1 = bit_or(r26A7, r26B0);
                           ir_expression *const r27D2 = nequal(r27D1, body.constant(0u));
                           ir_expression *const r27D3 = expr(ir_unop_b2i, r27D2);
                           body.emit(assign(r27B4, expr(ir_unop_i2u, r27D3), 0x01));


                        body.instructions = f27C8_parent_instructions;
                        body.emit(f27C8);

                        /* END IF */


                     body.instructions = f27C3_parent_instructions;
                     body.emit(f27C3);

                     /* END IF */

                     body.emit(assign(r27B5, body.constant(0u), 0x01));


                  body.instructions = f27BA_parent_instructions;
                  body.emit(f27BA);

                  /* END IF */


               body.instructions = f27B8_parent_instructions;
               body.emit(f27B8);

               /* END IF */

               body.emit(assign(r26A7, r27B5, 0x01));

               body.emit(assign(r26A8, r27B4, 0x01));

               body.emit(assign(r26A5, bit_or(r26A5, body.constant(1073741824u)), 0x01));

               ir_variable *const r27D4 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r27D5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r27D5, sub(r26A6, r27B4), 0x01));

               ir_expression *const r27D6 = sub(r26A5, r27B5);
               ir_expression *const r27D7 = less(r26A6, r27B4);
               ir_expression *const r27D8 = expr(ir_unop_b2i, r27D7);
               ir_expression *const r27D9 = expr(ir_unop_i2u, r27D8);
               body.emit(assign(r27D4, sub(r27D6, r27D9), 0x01));

               body.emit(assign(r26A0, bit_xor(r24F3, body.constant(1u)), 0x01));

               body.emit(assign(r26A9, add(r26AD, body.constant(int(-1))), 0x01));

               ir_variable *const r27DA = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r27DA, add(r26A9, body.constant(int(-10))), 0x01));

               ir_variable *const r27DB = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r27DB, r27D4, 0x01));

               ir_variable *const r27DC = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r27DC, r27D5, 0x01));

               ir_variable *const r27DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r27DD);
               ir_variable *const r27DE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r27DE);
               /* IF CONDITION */
               ir_expression *const r27E0 = equal(r27D4, body.constant(0u));
               ir_if *f27DF = new(mem_ctx) ir_if(operand(r27E0).val);
               exec_list *const f27DF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27DF->then_instructions;

                  body.emit(assign(r27DB, r27D5, 0x01));

                  body.emit(assign(r27DC, body.constant(0u), 0x01));

                  body.emit(assign(r27DA, add(r27DA, body.constant(int(-32))), 0x01));


               body.instructions = f27DF_parent_instructions;
               body.emit(f27DF);

               /* END IF */

               ir_variable *const r27E1 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r27E1, r27DB, 0x01));

               ir_variable *const r27E2 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r27E3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r27E3);
               /* IF CONDITION */
               ir_expression *const r27E5 = equal(r27DB, body.constant(0u));
               ir_if *f27E4 = new(mem_ctx) ir_if(operand(r27E5).val);
               exec_list *const f27E4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27E4->then_instructions;

                  body.emit(assign(r27E2, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f27E4->else_instructions;

                  body.emit(assign(r27E3, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r27E7 = bit_and(r27DB, body.constant(4294901760u));
                  ir_expression *const r27E8 = equal(r27E7, body.constant(0u));
                  ir_if *f27E6 = new(mem_ctx) ir_if(operand(r27E8).val);
                  exec_list *const f27E6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27E6->then_instructions;

                     body.emit(assign(r27E3, body.constant(int(16)), 0x01));

                     body.emit(assign(r27E1, lshift(r27DB, body.constant(int(16))), 0x01));


                  body.instructions = f27E6_parent_instructions;
                  body.emit(f27E6);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r27EA = bit_and(r27E1, body.constant(4278190080u));
                  ir_expression *const r27EB = equal(r27EA, body.constant(0u));
                  ir_if *f27E9 = new(mem_ctx) ir_if(operand(r27EB).val);
                  exec_list *const f27E9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27E9->then_instructions;

                     body.emit(assign(r27E3, add(r27E3, body.constant(int(8))), 0x01));

                     body.emit(assign(r27E1, lshift(r27E1, body.constant(int(8))), 0x01));


                  body.instructions = f27E9_parent_instructions;
                  body.emit(f27E9);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r27ED = bit_and(r27E1, body.constant(4026531840u));
                  ir_expression *const r27EE = equal(r27ED, body.constant(0u));
                  ir_if *f27EC = new(mem_ctx) ir_if(operand(r27EE).val);
                  exec_list *const f27EC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27EC->then_instructions;

                     body.emit(assign(r27E3, add(r27E3, body.constant(int(4))), 0x01));

                     body.emit(assign(r27E1, lshift(r27E1, body.constant(int(4))), 0x01));


                  body.instructions = f27EC_parent_instructions;
                  body.emit(f27EC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r27F0 = bit_and(r27E1, body.constant(3221225472u));
                  ir_expression *const r27F1 = equal(r27F0, body.constant(0u));
                  ir_if *f27EF = new(mem_ctx) ir_if(operand(r27F1).val);
                  exec_list *const f27EF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27EF->then_instructions;

                     body.emit(assign(r27E3, add(r27E3, body.constant(int(2))), 0x01));

                     body.emit(assign(r27E1, lshift(r27E1, body.constant(int(2))), 0x01));


                  body.instructions = f27EF_parent_instructions;
                  body.emit(f27EF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r27F3 = bit_and(r27E1, body.constant(2147483648u));
                  ir_expression *const r27F4 = equal(r27F3, body.constant(0u));
                  ir_if *f27F2 = new(mem_ctx) ir_if(operand(r27F4).val);
                  exec_list *const f27F2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27F2->then_instructions;

                     body.emit(assign(r27E3, add(r27E3, body.constant(int(1))), 0x01));


                  body.instructions = f27F2_parent_instructions;
                  body.emit(f27F2);

                  /* END IF */

                  body.emit(assign(r27E2, r27E3, 0x01));


               body.instructions = f27E4_parent_instructions;
               body.emit(f27E4);

               /* END IF */

               body.emit(assign(r27DE, add(r27E2, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r27F6 = lequal(body.constant(int(0)), r27DE);
               ir_if *f27F5 = new(mem_ctx) ir_if(operand(r27F6).val);
               exec_list *const f27F5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27F5->then_instructions;

                  body.emit(assign(r27DD, body.constant(0u), 0x01));

                  ir_variable *const r27F7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r27F7, lshift(r27DC, r27DE), 0x01));

                  ir_variable *const r27F8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r27FA = equal(r27DE, body.constant(int(0)));
                  ir_if *f27F9 = new(mem_ctx) ir_if(operand(r27FA).val);
                  exec_list *const f27F9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27F9->then_instructions;

                     body.emit(assign(r27F8, r27DB, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27F9->else_instructions;

                     ir_expression *const r27FB = lshift(r27DB, r27DE);
                     ir_expression *const r27FC = neg(r27DE);
                     ir_expression *const r27FD = bit_and(r27FC, body.constant(int(31)));
                     ir_expression *const r27FE = rshift(r27DC, r27FD);
                     body.emit(assign(r27F8, bit_or(r27FB, r27FE), 0x01));


                  body.instructions = f27F9_parent_instructions;
                  body.emit(f27F9);

                  /* END IF */

                  body.emit(assign(r27DB, r27F8, 0x01));

                  body.emit(assign(r27DC, r27F7, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f27F5->else_instructions;

                  ir_variable *const r27FF = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r27FF, body.constant(0u), 0x01));

                  ir_variable *const r2800 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2800, neg(r27DE), 0x01));

                  ir_variable *const r2801 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2801);
                  ir_variable *const r2802 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2802);
                  ir_variable *const r2803 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2803);
                  ir_variable *const r2804 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2805 = neg(r2800);
                  body.emit(assign(r2804, bit_and(r2805, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2807 = equal(r2800, body.constant(int(0)));
                  ir_if *f2806 = new(mem_ctx) ir_if(operand(r2807).val);
                  exec_list *const f2806_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2806->then_instructions;

                     body.emit(assign(r2801, r27FF, 0x01));

                     body.emit(assign(r2802, r27DC, 0x01));

                     body.emit(assign(r2803, r27DB, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2806->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2809 = less(r2800, body.constant(int(32)));
                     ir_if *f2808 = new(mem_ctx) ir_if(operand(r2809).val);
                     exec_list *const f2808_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2808->then_instructions;

                        body.emit(assign(r2801, lshift(r27DC, r2804), 0x01));

                        ir_expression *const r280A = lshift(r27DB, r2804);
                        ir_expression *const r280B = rshift(r27DC, r2800);
                        body.emit(assign(r2802, bit_or(r280A, r280B), 0x01));

                        body.emit(assign(r2803, rshift(r27DB, r2800), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2808->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r280D = equal(r2800, body.constant(int(32)));
                        ir_if *f280C = new(mem_ctx) ir_if(operand(r280D).val);
                        exec_list *const f280C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f280C->then_instructions;

                           body.emit(assign(r2801, r27DC, 0x01));

                           body.emit(assign(r2802, r27DB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f280C->else_instructions;

                           body.emit(assign(r27FF, bit_or(body.constant(0u), r27DC), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r280F = less(r2800, body.constant(int(64)));
                           ir_if *f280E = new(mem_ctx) ir_if(operand(r280F).val);
                           exec_list *const f280E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f280E->then_instructions;

                              body.emit(assign(r2801, lshift(r27DB, r2804), 0x01));

                              ir_expression *const r2810 = bit_and(r2800, body.constant(int(31)));
                              body.emit(assign(r2802, rshift(r27DB, r2810), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f280E->else_instructions;

                              ir_variable *const r2811 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2813 = equal(r2800, body.constant(int(64)));
                              ir_if *f2812 = new(mem_ctx) ir_if(operand(r2813).val);
                              exec_list *const f2812_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2812->then_instructions;

                                 body.emit(assign(r2811, r27DB, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2812->else_instructions;

                                 ir_expression *const r2814 = nequal(r27DB, body.constant(0u));
                                 ir_expression *const r2815 = expr(ir_unop_b2i, r2814);
                                 body.emit(assign(r2811, expr(ir_unop_i2u, r2815), 0x01));


                              body.instructions = f2812_parent_instructions;
                              body.emit(f2812);

                              /* END IF */

                              body.emit(assign(r2801, r2811, 0x01));

                              body.emit(assign(r2802, body.constant(0u), 0x01));


                           body.instructions = f280E_parent_instructions;
                           body.emit(f280E);

                           /* END IF */


                        body.instructions = f280C_parent_instructions;
                        body.emit(f280C);

                        /* END IF */

                        body.emit(assign(r2803, body.constant(0u), 0x01));


                     body.instructions = f2808_parent_instructions;
                     body.emit(f2808);

                     /* END IF */

                     ir_expression *const r2816 = nequal(r27FF, body.constant(0u));
                     ir_expression *const r2817 = expr(ir_unop_b2i, r2816);
                     ir_expression *const r2818 = expr(ir_unop_i2u, r2817);
                     body.emit(assign(r2801, bit_or(r2801, r2818), 0x01));


                  body.instructions = f2806_parent_instructions;
                  body.emit(f2806);

                  /* END IF */

                  body.emit(assign(r27DB, r2803, 0x01));

                  body.emit(assign(r27DC, r2802, 0x01));

                  body.emit(assign(r27DD, r2801, 0x01));


               body.instructions = f27F5_parent_instructions;
               body.emit(f27F5);

               /* END IF */

               body.emit(assign(r27DA, sub(r27DA, r27DE), 0x01));

               ir_variable *const r2819 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2819, r27DA, 0x01));

               ir_variable *const r281A = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r281A, r27DB, 0x01));

               ir_variable *const r281B = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r281B, r27DC, 0x01));

               ir_variable *const r281C = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r281C, r27DD, 0x01));

               ir_variable *const r281D = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r281D, body.constant(true), 0x01));

               ir_variable *const r281E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r281F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r281F);
               ir_expression *const r2820 = expr(ir_unop_u2i, r27DD);
               body.emit(assign(r281F, less(r2820, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2822 = lequal(body.constant(int(2045)), r27DA);
               ir_if *f2821 = new(mem_ctx) ir_if(operand(r2822).val);
               exec_list *const f2821_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2821->then_instructions;

                  ir_variable *const r2823 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2825 = less(body.constant(int(2045)), r27DA);
                  ir_if *f2824 = new(mem_ctx) ir_if(operand(r2825).val);
                  exec_list *const f2824_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2824->then_instructions;

                     body.emit(assign(r2823, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2824->else_instructions;

                     ir_variable *const r2826 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2828 = equal(r27DA, body.constant(int(2045)));
                     ir_if *f2827 = new(mem_ctx) ir_if(operand(r2828).val);
                     exec_list *const f2827_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2827->then_instructions;

                        ir_expression *const r2829 = equal(body.constant(2097151u), r27DB);
                        ir_expression *const r282A = equal(body.constant(4294967295u), r27DC);
                        body.emit(assign(r2826, logic_and(r2829, r282A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2827->else_instructions;

                        body.emit(assign(r2826, body.constant(false), 0x01));


                     body.instructions = f2827_parent_instructions;
                     body.emit(f2827);

                     /* END IF */

                     body.emit(assign(r2823, logic_and(r2826, r281F), 0x01));


                  body.instructions = f2824_parent_instructions;
                  body.emit(f2824);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f282B = new(mem_ctx) ir_if(operand(r2823).val);
                  exec_list *const f282B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f282B->then_instructions;

                     ir_variable *const r282C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r282C);
                     ir_expression *const r282D = lshift(r26A0, body.constant(int(31)));
                     body.emit(assign(r282C, add(r282D, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r282C, body.constant(0u), 0x01));

                     body.emit(assign(r281E, r282C, 0x03));

                     body.emit(assign(r281D, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f282B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r282F = less(r27DA, body.constant(int(0)));
                     ir_if *f282E = new(mem_ctx) ir_if(operand(r282F).val);
                     exec_list *const f282E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f282E->then_instructions;

                        ir_variable *const r2830 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2830, r27DD, 0x01));

                        ir_variable *const r2831 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2831, neg(r27DA), 0x01));

                        ir_variable *const r2832 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2832);
                        ir_variable *const r2833 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2833);
                        ir_variable *const r2834 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2834);
                        ir_variable *const r2835 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2836 = neg(r2831);
                        body.emit(assign(r2835, bit_and(r2836, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2838 = equal(r2831, body.constant(int(0)));
                        ir_if *f2837 = new(mem_ctx) ir_if(operand(r2838).val);
                        exec_list *const f2837_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2837->then_instructions;

                           body.emit(assign(r2832, r27DD, 0x01));

                           body.emit(assign(r2833, r27DC, 0x01));

                           body.emit(assign(r2834, r27DB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2837->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r283A = less(r2831, body.constant(int(32)));
                           ir_if *f2839 = new(mem_ctx) ir_if(operand(r283A).val);
                           exec_list *const f2839_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2839->then_instructions;

                              body.emit(assign(r2832, lshift(r27DC, r2835), 0x01));

                              ir_expression *const r283B = lshift(r27DB, r2835);
                              ir_expression *const r283C = rshift(r27DC, r2831);
                              body.emit(assign(r2833, bit_or(r283B, r283C), 0x01));

                              body.emit(assign(r2834, rshift(r27DB, r2831), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2839->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r283E = equal(r2831, body.constant(int(32)));
                              ir_if *f283D = new(mem_ctx) ir_if(operand(r283E).val);
                              exec_list *const f283D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f283D->then_instructions;

                                 body.emit(assign(r2832, r27DC, 0x01));

                                 body.emit(assign(r2833, r27DB, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f283D->else_instructions;

                                 body.emit(assign(r2830, bit_or(r27DD, r27DC), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2840 = less(r2831, body.constant(int(64)));
                                 ir_if *f283F = new(mem_ctx) ir_if(operand(r2840).val);
                                 exec_list *const f283F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f283F->then_instructions;

                                    body.emit(assign(r2832, lshift(r27DB, r2835), 0x01));

                                    ir_expression *const r2841 = bit_and(r2831, body.constant(int(31)));
                                    body.emit(assign(r2833, rshift(r27DB, r2841), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f283F->else_instructions;

                                    ir_variable *const r2842 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2844 = equal(r2831, body.constant(int(64)));
                                    ir_if *f2843 = new(mem_ctx) ir_if(operand(r2844).val);
                                    exec_list *const f2843_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2843->then_instructions;

                                       body.emit(assign(r2842, r27DB, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2843->else_instructions;

                                       ir_expression *const r2845 = nequal(r27DB, body.constant(0u));
                                       ir_expression *const r2846 = expr(ir_unop_b2i, r2845);
                                       body.emit(assign(r2842, expr(ir_unop_i2u, r2846), 0x01));


                                    body.instructions = f2843_parent_instructions;
                                    body.emit(f2843);

                                    /* END IF */

                                    body.emit(assign(r2832, r2842, 0x01));

                                    body.emit(assign(r2833, body.constant(0u), 0x01));


                                 body.instructions = f283F_parent_instructions;
                                 body.emit(f283F);

                                 /* END IF */


                              body.instructions = f283D_parent_instructions;
                              body.emit(f283D);

                              /* END IF */

                              body.emit(assign(r2834, body.constant(0u), 0x01));


                           body.instructions = f2839_parent_instructions;
                           body.emit(f2839);

                           /* END IF */

                           ir_expression *const r2847 = nequal(r2830, body.constant(0u));
                           ir_expression *const r2848 = expr(ir_unop_b2i, r2847);
                           ir_expression *const r2849 = expr(ir_unop_i2u, r2848);
                           body.emit(assign(r2832, bit_or(r2832, r2849), 0x01));


                        body.instructions = f2837_parent_instructions;
                        body.emit(f2837);

                        /* END IF */

                        body.emit(assign(r281A, r2834, 0x01));

                        body.emit(assign(r281B, r2833, 0x01));

                        body.emit(assign(r281C, r2832, 0x01));

                        body.emit(assign(r2819, body.constant(int(0)), 0x01));

                        body.emit(assign(r281F, less(r2832, body.constant(0u)), 0x01));


                     body.instructions = f282E_parent_instructions;
                     body.emit(f282E);

                     /* END IF */


                  body.instructions = f282B_parent_instructions;
                  body.emit(f282B);

                  /* END IF */


               body.instructions = f2821_parent_instructions;
               body.emit(f2821);

               /* END IF */

               /* IF CONDITION */
               ir_if *f284A = new(mem_ctx) ir_if(operand(r281D).val);
               exec_list *const f284A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f284A->then_instructions;

                  /* IF CONDITION */
                  ir_if *f284B = new(mem_ctx) ir_if(operand(r281F).val);
                  exec_list *const f284B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f284B->then_instructions;

                     ir_variable *const r284C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r284C, add(r281B, body.constant(1u)), 0x01));

                     ir_expression *const r284D = less(r284C, r281B);
                     ir_expression *const r284E = expr(ir_unop_b2i, r284D);
                     ir_expression *const r284F = expr(ir_unop_i2u, r284E);
                     body.emit(assign(r281A, add(r281A, r284F), 0x01));

                     ir_expression *const r2850 = equal(r281C, body.constant(0u));
                     ir_expression *const r2851 = expr(ir_unop_b2i, r2850);
                     ir_expression *const r2852 = expr(ir_unop_i2u, r2851);
                     ir_expression *const r2853 = add(r281C, r2852);
                     ir_expression *const r2854 = bit_and(r2853, body.constant(1u));
                     ir_expression *const r2855 = expr(ir_unop_bit_not, r2854);
                     body.emit(assign(r281B, bit_and(r284C, r2855), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f284B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2857 = bit_or(r281A, r281B);
                     ir_expression *const r2858 = equal(r2857, body.constant(0u));
                     ir_if *f2856 = new(mem_ctx) ir_if(operand(r2858).val);
                     exec_list *const f2856_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2856->then_instructions;

                        body.emit(assign(r2819, body.constant(int(0)), 0x01));


                     body.instructions = f2856_parent_instructions;
                     body.emit(f2856);

                     /* END IF */


                  body.instructions = f284B_parent_instructions;
                  body.emit(f284B);

                  /* END IF */

                  ir_variable *const r2859 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2859);
                  ir_expression *const r285A = lshift(r26A0, body.constant(int(31)));
                  ir_expression *const r285B = expr(ir_unop_i2u, r2819);
                  ir_expression *const r285C = lshift(r285B, body.constant(int(20)));
                  ir_expression *const r285D = add(r285A, r285C);
                  body.emit(assign(r2859, add(r285D, r281A), 0x02));

                  body.emit(assign(r2859, r281B, 0x01));

                  body.emit(assign(r281E, r2859, 0x03));

                  body.emit(assign(r281D, body.constant(false), 0x01));


               body.instructions = f284A_parent_instructions;
               body.emit(f284A);

               /* END IF */

               body.emit(assign(r26A1, r281E, 0x03));


            body.instructions = f278C_parent_instructions;
            body.emit(f278C);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f278A->else_instructions;

            /* IF CONDITION */
            ir_expression *const r285F = equal(r26AA, body.constant(int(2047)));
            ir_if *f285E = new(mem_ctx) ir_if(operand(r285F).val);
            exec_list *const f285E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f285E->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2861 = bit_or(r26A7, r26A8);
               ir_expression *const r2862 = bit_or(r26A5, r26A6);
               ir_expression *const r2863 = bit_or(r2861, r2862);
               ir_expression *const r2864 = nequal(r2863, body.constant(0u));
               ir_if *f2860 = new(mem_ctx) ir_if(operand(r2864).val);
               exec_list *const f2860_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2860->then_instructions;

                  ir_variable *const r2865 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2865, swizzle_x(r1F1E), 0x01));

                  ir_variable *const r2866 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2866, swizzle_x(r24E9), 0x01));

                  ir_variable *const r2867 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2868 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2869 = rshift(swizzle_y(r1F1E), body.constant(int(19)));
                  ir_expression *const r286A = bit_and(r2869, body.constant(4095u));
                  ir_expression *const r286B = equal(r286A, body.constant(4094u));
                  ir_expression *const r286C = nequal(swizzle_x(r1F1E), body.constant(0u));
                  ir_expression *const r286D = bit_and(swizzle_y(r1F1E), body.constant(524287u));
                  ir_expression *const r286E = nequal(r286D, body.constant(0u));
                  ir_expression *const r286F = logic_or(r286C, r286E);
                  body.emit(assign(r2868, logic_and(r286B, r286F), 0x01));

                  ir_variable *const r2870 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2871 = lshift(swizzle_y(r24E9), body.constant(int(1)));
                  ir_expression *const r2872 = lequal(body.constant(4292870144u), r2871);
                  ir_expression *const r2873 = nequal(swizzle_x(r24E9), body.constant(0u));
                  ir_expression *const r2874 = bit_and(swizzle_y(r24E9), body.constant(1048575u));
                  ir_expression *const r2875 = nequal(r2874, body.constant(0u));
                  ir_expression *const r2876 = logic_or(r2873, r2875);
                  body.emit(assign(r2870, logic_and(r2872, r2876), 0x01));

                  body.emit(assign(r2865, bit_or(swizzle_y(r1F1E), body.constant(524288u)), 0x02));

                  body.emit(assign(r2866, bit_or(swizzle_y(r24E9), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2878 = lshift(swizzle_y(r1F1E), body.constant(int(1)));
                  ir_expression *const r2879 = lequal(body.constant(4292870144u), r2878);
                  ir_expression *const r287A = nequal(swizzle_x(r1F1E), body.constant(0u));
                  ir_expression *const r287B = bit_and(swizzle_y(r1F1E), body.constant(1048575u));
                  ir_expression *const r287C = nequal(r287B, body.constant(0u));
                  ir_expression *const r287D = logic_or(r287A, r287C);
                  ir_expression *const r287E = logic_and(r2879, r287D);
                  ir_if *f2877 = new(mem_ctx) ir_if(operand(r287E).val);
                  exec_list *const f2877_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2877->then_instructions;

                     ir_variable *const r287F = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2881 = logic_and(r2868, r2870);
                     ir_if *f2880 = new(mem_ctx) ir_if(operand(r2881).val);
                     exec_list *const f2880_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2880->then_instructions;

                        body.emit(assign(r287F, r2866, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2880->else_instructions;

                        body.emit(assign(r287F, r2865, 0x03));


                     body.instructions = f2880_parent_instructions;
                     body.emit(f2880);

                     /* END IF */

                     body.emit(assign(r2867, r287F, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2877->else_instructions;

                     body.emit(assign(r2867, r2866, 0x03));


                  body.instructions = f2877_parent_instructions;
                  body.emit(f2877);

                  /* END IF */

                  body.emit(assign(r26A1, r2867, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2860->else_instructions;

                  ir_constant_data r2882_data;
                  memset(&r2882_data, 0, sizeof(ir_constant_data));
                  r2882_data.u[0] = 4294967295;
                  r2882_data.u[1] = 4294967295;
                  ir_constant *const r2882 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r2882_data);
                  body.emit(assign(r26A1, r2882, 0x03));


               body.instructions = f2860_parent_instructions;
               body.emit(f2860);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f285E->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2884 = equal(r26AA, body.constant(int(0)));
               ir_if *f2883 = new(mem_ctx) ir_if(operand(r2884).val);
               exec_list *const f2883_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2883->then_instructions;

                  body.emit(assign(r26A4, body.constant(int(1)), 0x01));

                  body.emit(assign(r26A3, body.constant(int(1)), 0x01));


               body.instructions = f2883_parent_instructions;
               body.emit(f2883);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2886 = less(r26A5, r26A7);
               ir_if *f2885 = new(mem_ctx) ir_if(operand(r2886).val);
               exec_list *const f2885_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2885->then_instructions;

                  ir_variable *const r2887 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r2888 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2888, sub(r26A8, r26A6), 0x01));

                  ir_expression *const r2889 = sub(r26A7, r26A5);
                  ir_expression *const r288A = less(r26A8, r26A6);
                  ir_expression *const r288B = expr(ir_unop_b2i, r288A);
                  ir_expression *const r288C = expr(ir_unop_i2u, r288B);
                  body.emit(assign(r2887, sub(r2889, r288C), 0x01));

                  body.emit(assign(r26A9, add(r26A4, body.constant(int(-1))), 0x01));

                  ir_variable *const r288D = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r288D, add(r26A9, body.constant(int(-10))), 0x01));

                  ir_variable *const r288E = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r288E, r2887, 0x01));

                  ir_variable *const r288F = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r288F, r2888, 0x01));

                  ir_variable *const r2890 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r2890);
                  ir_variable *const r2891 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2891);
                  /* IF CONDITION */
                  ir_expression *const r2893 = equal(r2887, body.constant(0u));
                  ir_if *f2892 = new(mem_ctx) ir_if(operand(r2893).val);
                  exec_list *const f2892_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2892->then_instructions;

                     body.emit(assign(r288E, r2888, 0x01));

                     body.emit(assign(r288F, body.constant(0u), 0x01));

                     body.emit(assign(r288D, add(r288D, body.constant(int(-32))), 0x01));


                  body.instructions = f2892_parent_instructions;
                  body.emit(f2892);

                  /* END IF */

                  ir_variable *const r2894 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r2894, r288E, 0x01));

                  ir_variable *const r2895 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r2896 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2896);
                  /* IF CONDITION */
                  ir_expression *const r2898 = equal(r288E, body.constant(0u));
                  ir_if *f2897 = new(mem_ctx) ir_if(operand(r2898).val);
                  exec_list *const f2897_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2897->then_instructions;

                     body.emit(assign(r2895, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2897->else_instructions;

                     body.emit(assign(r2896, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r289A = bit_and(r288E, body.constant(4294901760u));
                     ir_expression *const r289B = equal(r289A, body.constant(0u));
                     ir_if *f2899 = new(mem_ctx) ir_if(operand(r289B).val);
                     exec_list *const f2899_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2899->then_instructions;

                        body.emit(assign(r2896, body.constant(int(16)), 0x01));

                        body.emit(assign(r2894, lshift(r288E, body.constant(int(16))), 0x01));


                     body.instructions = f2899_parent_instructions;
                     body.emit(f2899);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r289D = bit_and(r2894, body.constant(4278190080u));
                     ir_expression *const r289E = equal(r289D, body.constant(0u));
                     ir_if *f289C = new(mem_ctx) ir_if(operand(r289E).val);
                     exec_list *const f289C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f289C->then_instructions;

                        body.emit(assign(r2896, add(r2896, body.constant(int(8))), 0x01));

                        body.emit(assign(r2894, lshift(r2894, body.constant(int(8))), 0x01));


                     body.instructions = f289C_parent_instructions;
                     body.emit(f289C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r28A0 = bit_and(r2894, body.constant(4026531840u));
                     ir_expression *const r28A1 = equal(r28A0, body.constant(0u));
                     ir_if *f289F = new(mem_ctx) ir_if(operand(r28A1).val);
                     exec_list *const f289F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f289F->then_instructions;

                        body.emit(assign(r2896, add(r2896, body.constant(int(4))), 0x01));

                        body.emit(assign(r2894, lshift(r2894, body.constant(int(4))), 0x01));


                     body.instructions = f289F_parent_instructions;
                     body.emit(f289F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r28A3 = bit_and(r2894, body.constant(3221225472u));
                     ir_expression *const r28A4 = equal(r28A3, body.constant(0u));
                     ir_if *f28A2 = new(mem_ctx) ir_if(operand(r28A4).val);
                     exec_list *const f28A2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28A2->then_instructions;

                        body.emit(assign(r2896, add(r2896, body.constant(int(2))), 0x01));

                        body.emit(assign(r2894, lshift(r2894, body.constant(int(2))), 0x01));


                     body.instructions = f28A2_parent_instructions;
                     body.emit(f28A2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r28A6 = bit_and(r2894, body.constant(2147483648u));
                     ir_expression *const r28A7 = equal(r28A6, body.constant(0u));
                     ir_if *f28A5 = new(mem_ctx) ir_if(operand(r28A7).val);
                     exec_list *const f28A5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28A5->then_instructions;

                        body.emit(assign(r2896, add(r2896, body.constant(int(1))), 0x01));


                     body.instructions = f28A5_parent_instructions;
                     body.emit(f28A5);

                     /* END IF */

                     body.emit(assign(r2895, r2896, 0x01));


                  body.instructions = f2897_parent_instructions;
                  body.emit(f2897);

                  /* END IF */

                  body.emit(assign(r2891, add(r2895, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r28A9 = lequal(body.constant(int(0)), r2891);
                  ir_if *f28A8 = new(mem_ctx) ir_if(operand(r28A9).val);
                  exec_list *const f28A8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28A8->then_instructions;

                     body.emit(assign(r2890, body.constant(0u), 0x01));

                     ir_variable *const r28AA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r28AA, lshift(r288F, r2891), 0x01));

                     ir_variable *const r28AB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r28AD = equal(r2891, body.constant(int(0)));
                     ir_if *f28AC = new(mem_ctx) ir_if(operand(r28AD).val);
                     exec_list *const f28AC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28AC->then_instructions;

                        body.emit(assign(r28AB, r288E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28AC->else_instructions;

                        ir_expression *const r28AE = lshift(r288E, r2891);
                        ir_expression *const r28AF = neg(r2891);
                        ir_expression *const r28B0 = bit_and(r28AF, body.constant(int(31)));
                        ir_expression *const r28B1 = rshift(r288F, r28B0);
                        body.emit(assign(r28AB, bit_or(r28AE, r28B1), 0x01));


                     body.instructions = f28AC_parent_instructions;
                     body.emit(f28AC);

                     /* END IF */

                     body.emit(assign(r288E, r28AB, 0x01));

                     body.emit(assign(r288F, r28AA, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f28A8->else_instructions;

                     ir_variable *const r28B2 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r28B2, body.constant(0u), 0x01));

                     ir_variable *const r28B3 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r28B3, neg(r2891), 0x01));

                     ir_variable *const r28B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r28B4);
                     ir_variable *const r28B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r28B5);
                     ir_variable *const r28B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r28B6);
                     ir_variable *const r28B7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r28B8 = neg(r28B3);
                     body.emit(assign(r28B7, bit_and(r28B8, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r28BA = equal(r28B3, body.constant(int(0)));
                     ir_if *f28B9 = new(mem_ctx) ir_if(operand(r28BA).val);
                     exec_list *const f28B9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28B9->then_instructions;

                        body.emit(assign(r28B4, r28B2, 0x01));

                        body.emit(assign(r28B5, r288F, 0x01));

                        body.emit(assign(r28B6, r288E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28B9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r28BC = less(r28B3, body.constant(int(32)));
                        ir_if *f28BB = new(mem_ctx) ir_if(operand(r28BC).val);
                        exec_list *const f28BB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28BB->then_instructions;

                           body.emit(assign(r28B4, lshift(r288F, r28B7), 0x01));

                           ir_expression *const r28BD = lshift(r288E, r28B7);
                           ir_expression *const r28BE = rshift(r288F, r28B3);
                           body.emit(assign(r28B5, bit_or(r28BD, r28BE), 0x01));

                           body.emit(assign(r28B6, rshift(r288E, r28B3), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f28BB->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r28C0 = equal(r28B3, body.constant(int(32)));
                           ir_if *f28BF = new(mem_ctx) ir_if(operand(r28C0).val);
                           exec_list *const f28BF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f28BF->then_instructions;

                              body.emit(assign(r28B4, r288F, 0x01));

                              body.emit(assign(r28B5, r288E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f28BF->else_instructions;

                              body.emit(assign(r28B2, bit_or(body.constant(0u), r288F), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r28C2 = less(r28B3, body.constant(int(64)));
                              ir_if *f28C1 = new(mem_ctx) ir_if(operand(r28C2).val);
                              exec_list *const f28C1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f28C1->then_instructions;

                                 body.emit(assign(r28B4, lshift(r288E, r28B7), 0x01));

                                 ir_expression *const r28C3 = bit_and(r28B3, body.constant(int(31)));
                                 body.emit(assign(r28B5, rshift(r288E, r28C3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f28C1->else_instructions;

                                 ir_variable *const r28C4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r28C6 = equal(r28B3, body.constant(int(64)));
                                 ir_if *f28C5 = new(mem_ctx) ir_if(operand(r28C6).val);
                                 exec_list *const f28C5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f28C5->then_instructions;

                                    body.emit(assign(r28C4, r288E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f28C5->else_instructions;

                                    ir_expression *const r28C7 = nequal(r288E, body.constant(0u));
                                    ir_expression *const r28C8 = expr(ir_unop_b2i, r28C7);
                                    body.emit(assign(r28C4, expr(ir_unop_i2u, r28C8), 0x01));


                                 body.instructions = f28C5_parent_instructions;
                                 body.emit(f28C5);

                                 /* END IF */

                                 body.emit(assign(r28B4, r28C4, 0x01));

                                 body.emit(assign(r28B5, body.constant(0u), 0x01));


                              body.instructions = f28C1_parent_instructions;
                              body.emit(f28C1);

                              /* END IF */


                           body.instructions = f28BF_parent_instructions;
                           body.emit(f28BF);

                           /* END IF */

                           body.emit(assign(r28B6, body.constant(0u), 0x01));


                        body.instructions = f28BB_parent_instructions;
                        body.emit(f28BB);

                        /* END IF */

                        ir_expression *const r28C9 = nequal(r28B2, body.constant(0u));
                        ir_expression *const r28CA = expr(ir_unop_b2i, r28C9);
                        ir_expression *const r28CB = expr(ir_unop_i2u, r28CA);
                        body.emit(assign(r28B4, bit_or(r28B4, r28CB), 0x01));


                     body.instructions = f28B9_parent_instructions;
                     body.emit(f28B9);

                     /* END IF */

                     body.emit(assign(r288E, r28B6, 0x01));

                     body.emit(assign(r288F, r28B5, 0x01));

                     body.emit(assign(r2890, r28B4, 0x01));


                  body.instructions = f28A8_parent_instructions;
                  body.emit(f28A8);

                  /* END IF */

                  body.emit(assign(r288D, sub(r288D, r2891), 0x01));

                  ir_variable *const r28CC = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r28CC, r288D, 0x01));

                  ir_variable *const r28CD = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r28CD, r288E, 0x01));

                  ir_variable *const r28CE = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r28CE, r288F, 0x01));

                  ir_variable *const r28CF = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r28CF, r2890, 0x01));

                  ir_variable *const r28D0 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r28D0, body.constant(true), 0x01));

                  ir_variable *const r28D1 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r28D2 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r28D2);
                  ir_expression *const r28D3 = expr(ir_unop_u2i, r2890);
                  body.emit(assign(r28D2, less(r28D3, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r28D5 = lequal(body.constant(int(2045)), r288D);
                  ir_if *f28D4 = new(mem_ctx) ir_if(operand(r28D5).val);
                  exec_list *const f28D4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28D4->then_instructions;

                     ir_variable *const r28D6 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r28D8 = less(body.constant(int(2045)), r288D);
                     ir_if *f28D7 = new(mem_ctx) ir_if(operand(r28D8).val);
                     exec_list *const f28D7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28D7->then_instructions;

                        body.emit(assign(r28D6, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28D7->else_instructions;

                        ir_variable *const r28D9 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r28DB = equal(r288D, body.constant(int(2045)));
                        ir_if *f28DA = new(mem_ctx) ir_if(operand(r28DB).val);
                        exec_list *const f28DA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28DA->then_instructions;

                           ir_expression *const r28DC = equal(body.constant(2097151u), r288E);
                           ir_expression *const r28DD = equal(body.constant(4294967295u), r288F);
                           body.emit(assign(r28D9, logic_and(r28DC, r28DD), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f28DA->else_instructions;

                           body.emit(assign(r28D9, body.constant(false), 0x01));


                        body.instructions = f28DA_parent_instructions;
                        body.emit(f28DA);

                        /* END IF */

                        body.emit(assign(r28D6, logic_and(r28D9, r28D2), 0x01));


                     body.instructions = f28D7_parent_instructions;
                     body.emit(f28D7);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f28DE = new(mem_ctx) ir_if(operand(r28D6).val);
                     exec_list *const f28DE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28DE->then_instructions;

                        ir_variable *const r28DF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r28DF);
                        ir_expression *const r28E0 = lshift(r26A0, body.constant(int(31)));
                        body.emit(assign(r28DF, add(r28E0, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r28DF, body.constant(0u), 0x01));

                        body.emit(assign(r28D1, r28DF, 0x03));

                        body.emit(assign(r28D0, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28DE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r28E2 = less(r288D, body.constant(int(0)));
                        ir_if *f28E1 = new(mem_ctx) ir_if(operand(r28E2).val);
                        exec_list *const f28E1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28E1->then_instructions;

                           ir_variable *const r28E3 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r28E3, r2890, 0x01));

                           ir_variable *const r28E4 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r28E4, neg(r288D), 0x01));

                           ir_variable *const r28E5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r28E5);
                           ir_variable *const r28E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r28E6);
                           ir_variable *const r28E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r28E7);
                           ir_variable *const r28E8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r28E9 = neg(r28E4);
                           body.emit(assign(r28E8, bit_and(r28E9, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r28EB = equal(r28E4, body.constant(int(0)));
                           ir_if *f28EA = new(mem_ctx) ir_if(operand(r28EB).val);
                           exec_list *const f28EA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f28EA->then_instructions;

                              body.emit(assign(r28E5, r2890, 0x01));

                              body.emit(assign(r28E6, r288F, 0x01));

                              body.emit(assign(r28E7, r288E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f28EA->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r28ED = less(r28E4, body.constant(int(32)));
                              ir_if *f28EC = new(mem_ctx) ir_if(operand(r28ED).val);
                              exec_list *const f28EC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f28EC->then_instructions;

                                 body.emit(assign(r28E5, lshift(r288F, r28E8), 0x01));

                                 ir_expression *const r28EE = lshift(r288E, r28E8);
                                 ir_expression *const r28EF = rshift(r288F, r28E4);
                                 body.emit(assign(r28E6, bit_or(r28EE, r28EF), 0x01));

                                 body.emit(assign(r28E7, rshift(r288E, r28E4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f28EC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r28F1 = equal(r28E4, body.constant(int(32)));
                                 ir_if *f28F0 = new(mem_ctx) ir_if(operand(r28F1).val);
                                 exec_list *const f28F0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f28F0->then_instructions;

                                    body.emit(assign(r28E5, r288F, 0x01));

                                    body.emit(assign(r28E6, r288E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f28F0->else_instructions;

                                    body.emit(assign(r28E3, bit_or(r2890, r288F), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r28F3 = less(r28E4, body.constant(int(64)));
                                    ir_if *f28F2 = new(mem_ctx) ir_if(operand(r28F3).val);
                                    exec_list *const f28F2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f28F2->then_instructions;

                                       body.emit(assign(r28E5, lshift(r288E, r28E8), 0x01));

                                       ir_expression *const r28F4 = bit_and(r28E4, body.constant(int(31)));
                                       body.emit(assign(r28E6, rshift(r288E, r28F4), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f28F2->else_instructions;

                                       ir_variable *const r28F5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r28F7 = equal(r28E4, body.constant(int(64)));
                                       ir_if *f28F6 = new(mem_ctx) ir_if(operand(r28F7).val);
                                       exec_list *const f28F6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f28F6->then_instructions;

                                          body.emit(assign(r28F5, r288E, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f28F6->else_instructions;

                                          ir_expression *const r28F8 = nequal(r288E, body.constant(0u));
                                          ir_expression *const r28F9 = expr(ir_unop_b2i, r28F8);
                                          body.emit(assign(r28F5, expr(ir_unop_i2u, r28F9), 0x01));


                                       body.instructions = f28F6_parent_instructions;
                                       body.emit(f28F6);

                                       /* END IF */

                                       body.emit(assign(r28E5, r28F5, 0x01));

                                       body.emit(assign(r28E6, body.constant(0u), 0x01));


                                    body.instructions = f28F2_parent_instructions;
                                    body.emit(f28F2);

                                    /* END IF */


                                 body.instructions = f28F0_parent_instructions;
                                 body.emit(f28F0);

                                 /* END IF */

                                 body.emit(assign(r28E7, body.constant(0u), 0x01));


                              body.instructions = f28EC_parent_instructions;
                              body.emit(f28EC);

                              /* END IF */

                              ir_expression *const r28FA = nequal(r28E3, body.constant(0u));
                              ir_expression *const r28FB = expr(ir_unop_b2i, r28FA);
                              ir_expression *const r28FC = expr(ir_unop_i2u, r28FB);
                              body.emit(assign(r28E5, bit_or(r28E5, r28FC), 0x01));


                           body.instructions = f28EA_parent_instructions;
                           body.emit(f28EA);

                           /* END IF */

                           body.emit(assign(r28CD, r28E7, 0x01));

                           body.emit(assign(r28CE, r28E6, 0x01));

                           body.emit(assign(r28CF, r28E5, 0x01));

                           body.emit(assign(r28CC, body.constant(int(0)), 0x01));

                           body.emit(assign(r28D2, less(r28E5, body.constant(0u)), 0x01));


                        body.instructions = f28E1_parent_instructions;
                        body.emit(f28E1);

                        /* END IF */


                     body.instructions = f28DE_parent_instructions;
                     body.emit(f28DE);

                     /* END IF */


                  body.instructions = f28D4_parent_instructions;
                  body.emit(f28D4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f28FD = new(mem_ctx) ir_if(operand(r28D0).val);
                  exec_list *const f28FD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28FD->then_instructions;

                     /* IF CONDITION */
                     ir_if *f28FE = new(mem_ctx) ir_if(operand(r28D2).val);
                     exec_list *const f28FE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28FE->then_instructions;

                        ir_variable *const r28FF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r28FF, add(r28CE, body.constant(1u)), 0x01));

                        ir_expression *const r2900 = less(r28FF, r28CE);
                        ir_expression *const r2901 = expr(ir_unop_b2i, r2900);
                        ir_expression *const r2902 = expr(ir_unop_i2u, r2901);
                        body.emit(assign(r28CD, add(r28CD, r2902), 0x01));

                        ir_expression *const r2903 = equal(r28CF, body.constant(0u));
                        ir_expression *const r2904 = expr(ir_unop_b2i, r2903);
                        ir_expression *const r2905 = expr(ir_unop_i2u, r2904);
                        ir_expression *const r2906 = add(r28CF, r2905);
                        ir_expression *const r2907 = bit_and(r2906, body.constant(1u));
                        ir_expression *const r2908 = expr(ir_unop_bit_not, r2907);
                        body.emit(assign(r28CE, bit_and(r28FF, r2908), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28FE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r290A = bit_or(r28CD, r28CE);
                        ir_expression *const r290B = equal(r290A, body.constant(0u));
                        ir_if *f2909 = new(mem_ctx) ir_if(operand(r290B).val);
                        exec_list *const f2909_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2909->then_instructions;

                           body.emit(assign(r28CC, body.constant(int(0)), 0x01));


                        body.instructions = f2909_parent_instructions;
                        body.emit(f2909);

                        /* END IF */


                     body.instructions = f28FE_parent_instructions;
                     body.emit(f28FE);

                     /* END IF */

                     ir_variable *const r290C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r290C);
                     ir_expression *const r290D = lshift(r26A0, body.constant(int(31)));
                     ir_expression *const r290E = expr(ir_unop_i2u, r28CC);
                     ir_expression *const r290F = lshift(r290E, body.constant(int(20)));
                     ir_expression *const r2910 = add(r290D, r290F);
                     body.emit(assign(r290C, add(r2910, r28CD), 0x02));

                     body.emit(assign(r290C, r28CE, 0x01));

                     body.emit(assign(r28D1, r290C, 0x03));

                     body.emit(assign(r28D0, body.constant(false), 0x01));


                  body.instructions = f28FD_parent_instructions;
                  body.emit(f28FD);

                  /* END IF */

                  body.emit(assign(r26A1, r28D1, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2885->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2912 = less(r26A7, r26A5);
                  ir_if *f2911 = new(mem_ctx) ir_if(operand(r2912).val);
                  exec_list *const f2911_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2911->then_instructions;

                     ir_variable *const r2913 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r2914 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2914, sub(r26A6, r26A8), 0x01));

                     ir_expression *const r2915 = sub(r26A5, r26A7);
                     ir_expression *const r2916 = less(r26A6, r26A8);
                     ir_expression *const r2917 = expr(ir_unop_b2i, r2916);
                     ir_expression *const r2918 = expr(ir_unop_i2u, r2917);
                     body.emit(assign(r2913, sub(r2915, r2918), 0x01));

                     body.emit(assign(r26A0, bit_xor(r26A0, body.constant(1u)), 0x01));

                     body.emit(assign(r26A9, add(r26A3, body.constant(int(-1))), 0x01));

                     ir_variable *const r2919 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2919, add(r26A9, body.constant(int(-10))), 0x01));

                     ir_variable *const r291A = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r291A, r2913, 0x01));

                     ir_variable *const r291B = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r291B, r2914, 0x01));

                     ir_variable *const r291C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r291C);
                     ir_variable *const r291D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r291D);
                     /* IF CONDITION */
                     ir_expression *const r291F = equal(r2913, body.constant(0u));
                     ir_if *f291E = new(mem_ctx) ir_if(operand(r291F).val);
                     exec_list *const f291E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f291E->then_instructions;

                        body.emit(assign(r291A, r2914, 0x01));

                        body.emit(assign(r291B, body.constant(0u), 0x01));

                        body.emit(assign(r2919, add(r2919, body.constant(int(-32))), 0x01));


                     body.instructions = f291E_parent_instructions;
                     body.emit(f291E);

                     /* END IF */

                     ir_variable *const r2920 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r2920, r291A, 0x01));

                     ir_variable *const r2921 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r2922 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2922);
                     /* IF CONDITION */
                     ir_expression *const r2924 = equal(r291A, body.constant(0u));
                     ir_if *f2923 = new(mem_ctx) ir_if(operand(r2924).val);
                     exec_list *const f2923_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2923->then_instructions;

                        body.emit(assign(r2921, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2923->else_instructions;

                        body.emit(assign(r2922, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2926 = bit_and(r291A, body.constant(4294901760u));
                        ir_expression *const r2927 = equal(r2926, body.constant(0u));
                        ir_if *f2925 = new(mem_ctx) ir_if(operand(r2927).val);
                        exec_list *const f2925_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2925->then_instructions;

                           body.emit(assign(r2922, body.constant(int(16)), 0x01));

                           body.emit(assign(r2920, lshift(r291A, body.constant(int(16))), 0x01));


                        body.instructions = f2925_parent_instructions;
                        body.emit(f2925);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2929 = bit_and(r2920, body.constant(4278190080u));
                        ir_expression *const r292A = equal(r2929, body.constant(0u));
                        ir_if *f2928 = new(mem_ctx) ir_if(operand(r292A).val);
                        exec_list *const f2928_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2928->then_instructions;

                           body.emit(assign(r2922, add(r2922, body.constant(int(8))), 0x01));

                           body.emit(assign(r2920, lshift(r2920, body.constant(int(8))), 0x01));


                        body.instructions = f2928_parent_instructions;
                        body.emit(f2928);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r292C = bit_and(r2920, body.constant(4026531840u));
                        ir_expression *const r292D = equal(r292C, body.constant(0u));
                        ir_if *f292B = new(mem_ctx) ir_if(operand(r292D).val);
                        exec_list *const f292B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f292B->then_instructions;

                           body.emit(assign(r2922, add(r2922, body.constant(int(4))), 0x01));

                           body.emit(assign(r2920, lshift(r2920, body.constant(int(4))), 0x01));


                        body.instructions = f292B_parent_instructions;
                        body.emit(f292B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r292F = bit_and(r2920, body.constant(3221225472u));
                        ir_expression *const r2930 = equal(r292F, body.constant(0u));
                        ir_if *f292E = new(mem_ctx) ir_if(operand(r2930).val);
                        exec_list *const f292E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f292E->then_instructions;

                           body.emit(assign(r2922, add(r2922, body.constant(int(2))), 0x01));

                           body.emit(assign(r2920, lshift(r2920, body.constant(int(2))), 0x01));


                        body.instructions = f292E_parent_instructions;
                        body.emit(f292E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2932 = bit_and(r2920, body.constant(2147483648u));
                        ir_expression *const r2933 = equal(r2932, body.constant(0u));
                        ir_if *f2931 = new(mem_ctx) ir_if(operand(r2933).val);
                        exec_list *const f2931_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2931->then_instructions;

                           body.emit(assign(r2922, add(r2922, body.constant(int(1))), 0x01));


                        body.instructions = f2931_parent_instructions;
                        body.emit(f2931);

                        /* END IF */

                        body.emit(assign(r2921, r2922, 0x01));


                     body.instructions = f2923_parent_instructions;
                     body.emit(f2923);

                     /* END IF */

                     body.emit(assign(r291D, add(r2921, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2935 = lequal(body.constant(int(0)), r291D);
                     ir_if *f2934 = new(mem_ctx) ir_if(operand(r2935).val);
                     exec_list *const f2934_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2934->then_instructions;

                        body.emit(assign(r291C, body.constant(0u), 0x01));

                        ir_variable *const r2936 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2936, lshift(r291B, r291D), 0x01));

                        ir_variable *const r2937 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2939 = equal(r291D, body.constant(int(0)));
                        ir_if *f2938 = new(mem_ctx) ir_if(operand(r2939).val);
                        exec_list *const f2938_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2938->then_instructions;

                           body.emit(assign(r2937, r291A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2938->else_instructions;

                           ir_expression *const r293A = lshift(r291A, r291D);
                           ir_expression *const r293B = neg(r291D);
                           ir_expression *const r293C = bit_and(r293B, body.constant(int(31)));
                           ir_expression *const r293D = rshift(r291B, r293C);
                           body.emit(assign(r2937, bit_or(r293A, r293D), 0x01));


                        body.instructions = f2938_parent_instructions;
                        body.emit(f2938);

                        /* END IF */

                        body.emit(assign(r291A, r2937, 0x01));

                        body.emit(assign(r291B, r2936, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2934->else_instructions;

                        ir_variable *const r293E = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r293E, body.constant(0u), 0x01));

                        ir_variable *const r293F = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r293F, neg(r291D), 0x01));

                        ir_variable *const r2940 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2940);
                        ir_variable *const r2941 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2941);
                        ir_variable *const r2942 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2942);
                        ir_variable *const r2943 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2944 = neg(r293F);
                        body.emit(assign(r2943, bit_and(r2944, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2946 = equal(r293F, body.constant(int(0)));
                        ir_if *f2945 = new(mem_ctx) ir_if(operand(r2946).val);
                        exec_list *const f2945_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2945->then_instructions;

                           body.emit(assign(r2940, r293E, 0x01));

                           body.emit(assign(r2941, r291B, 0x01));

                           body.emit(assign(r2942, r291A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2945->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2948 = less(r293F, body.constant(int(32)));
                           ir_if *f2947 = new(mem_ctx) ir_if(operand(r2948).val);
                           exec_list *const f2947_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2947->then_instructions;

                              body.emit(assign(r2940, lshift(r291B, r2943), 0x01));

                              ir_expression *const r2949 = lshift(r291A, r2943);
                              ir_expression *const r294A = rshift(r291B, r293F);
                              body.emit(assign(r2941, bit_or(r2949, r294A), 0x01));

                              body.emit(assign(r2942, rshift(r291A, r293F), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2947->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r294C = equal(r293F, body.constant(int(32)));
                              ir_if *f294B = new(mem_ctx) ir_if(operand(r294C).val);
                              exec_list *const f294B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f294B->then_instructions;

                                 body.emit(assign(r2940, r291B, 0x01));

                                 body.emit(assign(r2941, r291A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f294B->else_instructions;

                                 body.emit(assign(r293E, bit_or(body.constant(0u), r291B), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r294E = less(r293F, body.constant(int(64)));
                                 ir_if *f294D = new(mem_ctx) ir_if(operand(r294E).val);
                                 exec_list *const f294D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f294D->then_instructions;

                                    body.emit(assign(r2940, lshift(r291A, r2943), 0x01));

                                    ir_expression *const r294F = bit_and(r293F, body.constant(int(31)));
                                    body.emit(assign(r2941, rshift(r291A, r294F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f294D->else_instructions;

                                    ir_variable *const r2950 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2952 = equal(r293F, body.constant(int(64)));
                                    ir_if *f2951 = new(mem_ctx) ir_if(operand(r2952).val);
                                    exec_list *const f2951_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2951->then_instructions;

                                       body.emit(assign(r2950, r291A, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2951->else_instructions;

                                       ir_expression *const r2953 = nequal(r291A, body.constant(0u));
                                       ir_expression *const r2954 = expr(ir_unop_b2i, r2953);
                                       body.emit(assign(r2950, expr(ir_unop_i2u, r2954), 0x01));


                                    body.instructions = f2951_parent_instructions;
                                    body.emit(f2951);

                                    /* END IF */

                                    body.emit(assign(r2940, r2950, 0x01));

                                    body.emit(assign(r2941, body.constant(0u), 0x01));


                                 body.instructions = f294D_parent_instructions;
                                 body.emit(f294D);

                                 /* END IF */


                              body.instructions = f294B_parent_instructions;
                              body.emit(f294B);

                              /* END IF */

                              body.emit(assign(r2942, body.constant(0u), 0x01));


                           body.instructions = f2947_parent_instructions;
                           body.emit(f2947);

                           /* END IF */

                           ir_expression *const r2955 = nequal(r293E, body.constant(0u));
                           ir_expression *const r2956 = expr(ir_unop_b2i, r2955);
                           ir_expression *const r2957 = expr(ir_unop_i2u, r2956);
                           body.emit(assign(r2940, bit_or(r2940, r2957), 0x01));


                        body.instructions = f2945_parent_instructions;
                        body.emit(f2945);

                        /* END IF */

                        body.emit(assign(r291A, r2942, 0x01));

                        body.emit(assign(r291B, r2941, 0x01));

                        body.emit(assign(r291C, r2940, 0x01));


                     body.instructions = f2934_parent_instructions;
                     body.emit(f2934);

                     /* END IF */

                     body.emit(assign(r2919, sub(r2919, r291D), 0x01));

                     ir_variable *const r2958 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2958, r2919, 0x01));

                     ir_variable *const r2959 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2959, r291A, 0x01));

                     ir_variable *const r295A = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r295A, r291B, 0x01));

                     ir_variable *const r295B = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r295B, r291C, 0x01));

                     ir_variable *const r295C = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r295C, body.constant(true), 0x01));

                     ir_variable *const r295D = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r295E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r295E);
                     ir_expression *const r295F = expr(ir_unop_u2i, r291C);
                     body.emit(assign(r295E, less(r295F, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2961 = lequal(body.constant(int(2045)), r2919);
                     ir_if *f2960 = new(mem_ctx) ir_if(operand(r2961).val);
                     exec_list *const f2960_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2960->then_instructions;

                        ir_variable *const r2962 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2964 = less(body.constant(int(2045)), r2919);
                        ir_if *f2963 = new(mem_ctx) ir_if(operand(r2964).val);
                        exec_list *const f2963_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2963->then_instructions;

                           body.emit(assign(r2962, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2963->else_instructions;

                           ir_variable *const r2965 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2967 = equal(r2919, body.constant(int(2045)));
                           ir_if *f2966 = new(mem_ctx) ir_if(operand(r2967).val);
                           exec_list *const f2966_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2966->then_instructions;

                              ir_expression *const r2968 = equal(body.constant(2097151u), r291A);
                              ir_expression *const r2969 = equal(body.constant(4294967295u), r291B);
                              body.emit(assign(r2965, logic_and(r2968, r2969), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2966->else_instructions;

                              body.emit(assign(r2965, body.constant(false), 0x01));


                           body.instructions = f2966_parent_instructions;
                           body.emit(f2966);

                           /* END IF */

                           body.emit(assign(r2962, logic_and(r2965, r295E), 0x01));


                        body.instructions = f2963_parent_instructions;
                        body.emit(f2963);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f296A = new(mem_ctx) ir_if(operand(r2962).val);
                        exec_list *const f296A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f296A->then_instructions;

                           ir_variable *const r296B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r296B);
                           ir_expression *const r296C = lshift(r26A0, body.constant(int(31)));
                           body.emit(assign(r296B, add(r296C, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r296B, body.constant(0u), 0x01));

                           body.emit(assign(r295D, r296B, 0x03));

                           body.emit(assign(r295C, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f296A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r296E = less(r2919, body.constant(int(0)));
                           ir_if *f296D = new(mem_ctx) ir_if(operand(r296E).val);
                           exec_list *const f296D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f296D->then_instructions;

                              ir_variable *const r296F = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r296F, r291C, 0x01));

                              ir_variable *const r2970 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2970, neg(r2919), 0x01));

                              ir_variable *const r2971 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2971);
                              ir_variable *const r2972 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2972);
                              ir_variable *const r2973 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2973);
                              ir_variable *const r2974 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2975 = neg(r2970);
                              body.emit(assign(r2974, bit_and(r2975, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2977 = equal(r2970, body.constant(int(0)));
                              ir_if *f2976 = new(mem_ctx) ir_if(operand(r2977).val);
                              exec_list *const f2976_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2976->then_instructions;

                                 body.emit(assign(r2971, r291C, 0x01));

                                 body.emit(assign(r2972, r291B, 0x01));

                                 body.emit(assign(r2973, r291A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2976->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2979 = less(r2970, body.constant(int(32)));
                                 ir_if *f2978 = new(mem_ctx) ir_if(operand(r2979).val);
                                 exec_list *const f2978_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2978->then_instructions;

                                    body.emit(assign(r2971, lshift(r291B, r2974), 0x01));

                                    ir_expression *const r297A = lshift(r291A, r2974);
                                    ir_expression *const r297B = rshift(r291B, r2970);
                                    body.emit(assign(r2972, bit_or(r297A, r297B), 0x01));

                                    body.emit(assign(r2973, rshift(r291A, r2970), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2978->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r297D = equal(r2970, body.constant(int(32)));
                                    ir_if *f297C = new(mem_ctx) ir_if(operand(r297D).val);
                                    exec_list *const f297C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f297C->then_instructions;

                                       body.emit(assign(r2971, r291B, 0x01));

                                       body.emit(assign(r2972, r291A, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f297C->else_instructions;

                                       body.emit(assign(r296F, bit_or(r291C, r291B), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r297F = less(r2970, body.constant(int(64)));
                                       ir_if *f297E = new(mem_ctx) ir_if(operand(r297F).val);
                                       exec_list *const f297E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f297E->then_instructions;

                                          body.emit(assign(r2971, lshift(r291A, r2974), 0x01));

                                          ir_expression *const r2980 = bit_and(r2970, body.constant(int(31)));
                                          body.emit(assign(r2972, rshift(r291A, r2980), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f297E->else_instructions;

                                          ir_variable *const r2981 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2983 = equal(r2970, body.constant(int(64)));
                                          ir_if *f2982 = new(mem_ctx) ir_if(operand(r2983).val);
                                          exec_list *const f2982_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2982->then_instructions;

                                             body.emit(assign(r2981, r291A, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2982->else_instructions;

                                             ir_expression *const r2984 = nequal(r291A, body.constant(0u));
                                             ir_expression *const r2985 = expr(ir_unop_b2i, r2984);
                                             body.emit(assign(r2981, expr(ir_unop_i2u, r2985), 0x01));


                                          body.instructions = f2982_parent_instructions;
                                          body.emit(f2982);

                                          /* END IF */

                                          body.emit(assign(r2971, r2981, 0x01));

                                          body.emit(assign(r2972, body.constant(0u), 0x01));


                                       body.instructions = f297E_parent_instructions;
                                       body.emit(f297E);

                                       /* END IF */


                                    body.instructions = f297C_parent_instructions;
                                    body.emit(f297C);

                                    /* END IF */

                                    body.emit(assign(r2973, body.constant(0u), 0x01));


                                 body.instructions = f2978_parent_instructions;
                                 body.emit(f2978);

                                 /* END IF */

                                 ir_expression *const r2986 = nequal(r296F, body.constant(0u));
                                 ir_expression *const r2987 = expr(ir_unop_b2i, r2986);
                                 ir_expression *const r2988 = expr(ir_unop_i2u, r2987);
                                 body.emit(assign(r2971, bit_or(r2971, r2988), 0x01));


                              body.instructions = f2976_parent_instructions;
                              body.emit(f2976);

                              /* END IF */

                              body.emit(assign(r2959, r2973, 0x01));

                              body.emit(assign(r295A, r2972, 0x01));

                              body.emit(assign(r295B, r2971, 0x01));

                              body.emit(assign(r2958, body.constant(int(0)), 0x01));

                              body.emit(assign(r295E, less(r2971, body.constant(0u)), 0x01));


                           body.instructions = f296D_parent_instructions;
                           body.emit(f296D);

                           /* END IF */


                        body.instructions = f296A_parent_instructions;
                        body.emit(f296A);

                        /* END IF */


                     body.instructions = f2960_parent_instructions;
                     body.emit(f2960);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2989 = new(mem_ctx) ir_if(operand(r295C).val);
                     exec_list *const f2989_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2989->then_instructions;

                        /* IF CONDITION */
                        ir_if *f298A = new(mem_ctx) ir_if(operand(r295E).val);
                        exec_list *const f298A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f298A->then_instructions;

                           ir_variable *const r298B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r298B, add(r295A, body.constant(1u)), 0x01));

                           ir_expression *const r298C = less(r298B, r295A);
                           ir_expression *const r298D = expr(ir_unop_b2i, r298C);
                           ir_expression *const r298E = expr(ir_unop_i2u, r298D);
                           body.emit(assign(r2959, add(r2959, r298E), 0x01));

                           ir_expression *const r298F = equal(r295B, body.constant(0u));
                           ir_expression *const r2990 = expr(ir_unop_b2i, r298F);
                           ir_expression *const r2991 = expr(ir_unop_i2u, r2990);
                           ir_expression *const r2992 = add(r295B, r2991);
                           ir_expression *const r2993 = bit_and(r2992, body.constant(1u));
                           ir_expression *const r2994 = expr(ir_unop_bit_not, r2993);
                           body.emit(assign(r295A, bit_and(r298B, r2994), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f298A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2996 = bit_or(r2959, r295A);
                           ir_expression *const r2997 = equal(r2996, body.constant(0u));
                           ir_if *f2995 = new(mem_ctx) ir_if(operand(r2997).val);
                           exec_list *const f2995_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2995->then_instructions;

                              body.emit(assign(r2958, body.constant(int(0)), 0x01));


                           body.instructions = f2995_parent_instructions;
                           body.emit(f2995);

                           /* END IF */


                        body.instructions = f298A_parent_instructions;
                        body.emit(f298A);

                        /* END IF */

                        ir_variable *const r2998 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2998);
                        ir_expression *const r2999 = lshift(r26A0, body.constant(int(31)));
                        ir_expression *const r299A = expr(ir_unop_i2u, r2958);
                        ir_expression *const r299B = lshift(r299A, body.constant(int(20)));
                        ir_expression *const r299C = add(r2999, r299B);
                        body.emit(assign(r2998, add(r299C, r2959), 0x02));

                        body.emit(assign(r2998, r295A, 0x01));

                        body.emit(assign(r295D, r2998, 0x03));

                        body.emit(assign(r295C, body.constant(false), 0x01));


                     body.instructions = f2989_parent_instructions;
                     body.emit(f2989);

                     /* END IF */

                     body.emit(assign(r26A1, r295D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2911->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r299E = less(r26A6, r26A8);
                     ir_if *f299D = new(mem_ctx) ir_if(operand(r299E).val);
                     exec_list *const f299D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f299D->then_instructions;

                        ir_variable *const r299F = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r29A0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r29A0, sub(r26A8, r26A6), 0x01));

                        ir_expression *const r29A1 = sub(r26A7, r26A5);
                        ir_expression *const r29A2 = less(r26A8, r26A6);
                        ir_expression *const r29A3 = expr(ir_unop_b2i, r29A2);
                        ir_expression *const r29A4 = expr(ir_unop_i2u, r29A3);
                        body.emit(assign(r299F, sub(r29A1, r29A4), 0x01));

                        body.emit(assign(r26A9, add(r26A4, body.constant(int(-1))), 0x01));

                        ir_variable *const r29A5 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r29A5, add(r26A9, body.constant(int(-10))), 0x01));

                        ir_variable *const r29A6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r29A6, r299F, 0x01));

                        ir_variable *const r29A7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r29A7, r29A0, 0x01));

                        ir_variable *const r29A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r29A8);
                        ir_variable *const r29A9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r29A9);
                        /* IF CONDITION */
                        ir_expression *const r29AB = equal(r299F, body.constant(0u));
                        ir_if *f29AA = new(mem_ctx) ir_if(operand(r29AB).val);
                        exec_list *const f29AA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29AA->then_instructions;

                           body.emit(assign(r29A6, r29A0, 0x01));

                           body.emit(assign(r29A7, body.constant(0u), 0x01));

                           body.emit(assign(r29A5, add(r29A5, body.constant(int(-32))), 0x01));


                        body.instructions = f29AA_parent_instructions;
                        body.emit(f29AA);

                        /* END IF */

                        ir_variable *const r29AC = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r29AC, r29A6, 0x01));

                        ir_variable *const r29AD = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r29AE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r29AE);
                        /* IF CONDITION */
                        ir_expression *const r29B0 = equal(r29A6, body.constant(0u));
                        ir_if *f29AF = new(mem_ctx) ir_if(operand(r29B0).val);
                        exec_list *const f29AF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29AF->then_instructions;

                           body.emit(assign(r29AD, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f29AF->else_instructions;

                           body.emit(assign(r29AE, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r29B2 = bit_and(r29A6, body.constant(4294901760u));
                           ir_expression *const r29B3 = equal(r29B2, body.constant(0u));
                           ir_if *f29B1 = new(mem_ctx) ir_if(operand(r29B3).val);
                           exec_list *const f29B1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29B1->then_instructions;

                              body.emit(assign(r29AE, body.constant(int(16)), 0x01));

                              body.emit(assign(r29AC, lshift(r29A6, body.constant(int(16))), 0x01));


                           body.instructions = f29B1_parent_instructions;
                           body.emit(f29B1);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r29B5 = bit_and(r29AC, body.constant(4278190080u));
                           ir_expression *const r29B6 = equal(r29B5, body.constant(0u));
                           ir_if *f29B4 = new(mem_ctx) ir_if(operand(r29B6).val);
                           exec_list *const f29B4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29B4->then_instructions;

                              body.emit(assign(r29AE, add(r29AE, body.constant(int(8))), 0x01));

                              body.emit(assign(r29AC, lshift(r29AC, body.constant(int(8))), 0x01));


                           body.instructions = f29B4_parent_instructions;
                           body.emit(f29B4);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r29B8 = bit_and(r29AC, body.constant(4026531840u));
                           ir_expression *const r29B9 = equal(r29B8, body.constant(0u));
                           ir_if *f29B7 = new(mem_ctx) ir_if(operand(r29B9).val);
                           exec_list *const f29B7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29B7->then_instructions;

                              body.emit(assign(r29AE, add(r29AE, body.constant(int(4))), 0x01));

                              body.emit(assign(r29AC, lshift(r29AC, body.constant(int(4))), 0x01));


                           body.instructions = f29B7_parent_instructions;
                           body.emit(f29B7);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r29BB = bit_and(r29AC, body.constant(3221225472u));
                           ir_expression *const r29BC = equal(r29BB, body.constant(0u));
                           ir_if *f29BA = new(mem_ctx) ir_if(operand(r29BC).val);
                           exec_list *const f29BA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29BA->then_instructions;

                              body.emit(assign(r29AE, add(r29AE, body.constant(int(2))), 0x01));

                              body.emit(assign(r29AC, lshift(r29AC, body.constant(int(2))), 0x01));


                           body.instructions = f29BA_parent_instructions;
                           body.emit(f29BA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r29BE = bit_and(r29AC, body.constant(2147483648u));
                           ir_expression *const r29BF = equal(r29BE, body.constant(0u));
                           ir_if *f29BD = new(mem_ctx) ir_if(operand(r29BF).val);
                           exec_list *const f29BD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29BD->then_instructions;

                              body.emit(assign(r29AE, add(r29AE, body.constant(int(1))), 0x01));


                           body.instructions = f29BD_parent_instructions;
                           body.emit(f29BD);

                           /* END IF */

                           body.emit(assign(r29AD, r29AE, 0x01));


                        body.instructions = f29AF_parent_instructions;
                        body.emit(f29AF);

                        /* END IF */

                        body.emit(assign(r29A9, add(r29AD, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r29C1 = lequal(body.constant(int(0)), r29A9);
                        ir_if *f29C0 = new(mem_ctx) ir_if(operand(r29C1).val);
                        exec_list *const f29C0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29C0->then_instructions;

                           body.emit(assign(r29A8, body.constant(0u), 0x01));

                           ir_variable *const r29C2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r29C2, lshift(r29A7, r29A9), 0x01));

                           ir_variable *const r29C3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r29C5 = equal(r29A9, body.constant(int(0)));
                           ir_if *f29C4 = new(mem_ctx) ir_if(operand(r29C5).val);
                           exec_list *const f29C4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29C4->then_instructions;

                              body.emit(assign(r29C3, r29A6, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29C4->else_instructions;

                              ir_expression *const r29C6 = lshift(r29A6, r29A9);
                              ir_expression *const r29C7 = neg(r29A9);
                              ir_expression *const r29C8 = bit_and(r29C7, body.constant(int(31)));
                              ir_expression *const r29C9 = rshift(r29A7, r29C8);
                              body.emit(assign(r29C3, bit_or(r29C6, r29C9), 0x01));


                           body.instructions = f29C4_parent_instructions;
                           body.emit(f29C4);

                           /* END IF */

                           body.emit(assign(r29A6, r29C3, 0x01));

                           body.emit(assign(r29A7, r29C2, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f29C0->else_instructions;

                           ir_variable *const r29CA = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r29CA, body.constant(0u), 0x01));

                           ir_variable *const r29CB = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r29CB, neg(r29A9), 0x01));

                           ir_variable *const r29CC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r29CC);
                           ir_variable *const r29CD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r29CD);
                           ir_variable *const r29CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r29CE);
                           ir_variable *const r29CF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r29D0 = neg(r29CB);
                           body.emit(assign(r29CF, bit_and(r29D0, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r29D2 = equal(r29CB, body.constant(int(0)));
                           ir_if *f29D1 = new(mem_ctx) ir_if(operand(r29D2).val);
                           exec_list *const f29D1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29D1->then_instructions;

                              body.emit(assign(r29CC, r29CA, 0x01));

                              body.emit(assign(r29CD, r29A7, 0x01));

                              body.emit(assign(r29CE, r29A6, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29D1->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r29D4 = less(r29CB, body.constant(int(32)));
                              ir_if *f29D3 = new(mem_ctx) ir_if(operand(r29D4).val);
                              exec_list *const f29D3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29D3->then_instructions;

                                 body.emit(assign(r29CC, lshift(r29A7, r29CF), 0x01));

                                 ir_expression *const r29D5 = lshift(r29A6, r29CF);
                                 ir_expression *const r29D6 = rshift(r29A7, r29CB);
                                 body.emit(assign(r29CD, bit_or(r29D5, r29D6), 0x01));

                                 body.emit(assign(r29CE, rshift(r29A6, r29CB), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f29D3->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r29D8 = equal(r29CB, body.constant(int(32)));
                                 ir_if *f29D7 = new(mem_ctx) ir_if(operand(r29D8).val);
                                 exec_list *const f29D7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f29D7->then_instructions;

                                    body.emit(assign(r29CC, r29A7, 0x01));

                                    body.emit(assign(r29CD, r29A6, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f29D7->else_instructions;

                                    body.emit(assign(r29CA, bit_or(body.constant(0u), r29A7), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r29DA = less(r29CB, body.constant(int(64)));
                                    ir_if *f29D9 = new(mem_ctx) ir_if(operand(r29DA).val);
                                    exec_list *const f29D9_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f29D9->then_instructions;

                                       body.emit(assign(r29CC, lshift(r29A6, r29CF), 0x01));

                                       ir_expression *const r29DB = bit_and(r29CB, body.constant(int(31)));
                                       body.emit(assign(r29CD, rshift(r29A6, r29DB), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f29D9->else_instructions;

                                       ir_variable *const r29DC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r29DE = equal(r29CB, body.constant(int(64)));
                                       ir_if *f29DD = new(mem_ctx) ir_if(operand(r29DE).val);
                                       exec_list *const f29DD_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f29DD->then_instructions;

                                          body.emit(assign(r29DC, r29A6, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f29DD->else_instructions;

                                          ir_expression *const r29DF = nequal(r29A6, body.constant(0u));
                                          ir_expression *const r29E0 = expr(ir_unop_b2i, r29DF);
                                          body.emit(assign(r29DC, expr(ir_unop_i2u, r29E0), 0x01));


                                       body.instructions = f29DD_parent_instructions;
                                       body.emit(f29DD);

                                       /* END IF */

                                       body.emit(assign(r29CC, r29DC, 0x01));

                                       body.emit(assign(r29CD, body.constant(0u), 0x01));


                                    body.instructions = f29D9_parent_instructions;
                                    body.emit(f29D9);

                                    /* END IF */


                                 body.instructions = f29D7_parent_instructions;
                                 body.emit(f29D7);

                                 /* END IF */

                                 body.emit(assign(r29CE, body.constant(0u), 0x01));


                              body.instructions = f29D3_parent_instructions;
                              body.emit(f29D3);

                              /* END IF */

                              ir_expression *const r29E1 = nequal(r29CA, body.constant(0u));
                              ir_expression *const r29E2 = expr(ir_unop_b2i, r29E1);
                              ir_expression *const r29E3 = expr(ir_unop_i2u, r29E2);
                              body.emit(assign(r29CC, bit_or(r29CC, r29E3), 0x01));


                           body.instructions = f29D1_parent_instructions;
                           body.emit(f29D1);

                           /* END IF */

                           body.emit(assign(r29A6, r29CE, 0x01));

                           body.emit(assign(r29A7, r29CD, 0x01));

                           body.emit(assign(r29A8, r29CC, 0x01));


                        body.instructions = f29C0_parent_instructions;
                        body.emit(f29C0);

                        /* END IF */

                        body.emit(assign(r29A5, sub(r29A5, r29A9), 0x01));

                        ir_variable *const r29E4 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r29E4, r29A5, 0x01));

                        ir_variable *const r29E5 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r29E5, r29A6, 0x01));

                        ir_variable *const r29E6 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r29E6, r29A7, 0x01));

                        ir_variable *const r29E7 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r29E7, r29A8, 0x01));

                        ir_variable *const r29E8 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r29E8, body.constant(true), 0x01));

                        ir_variable *const r29E9 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r29EA = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r29EA);
                        ir_expression *const r29EB = expr(ir_unop_u2i, r29A8);
                        body.emit(assign(r29EA, less(r29EB, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r29ED = lequal(body.constant(int(2045)), r29A5);
                        ir_if *f29EC = new(mem_ctx) ir_if(operand(r29ED).val);
                        exec_list *const f29EC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29EC->then_instructions;

                           ir_variable *const r29EE = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r29F0 = less(body.constant(int(2045)), r29A5);
                           ir_if *f29EF = new(mem_ctx) ir_if(operand(r29F0).val);
                           exec_list *const f29EF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29EF->then_instructions;

                              body.emit(assign(r29EE, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29EF->else_instructions;

                              ir_variable *const r29F1 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r29F3 = equal(r29A5, body.constant(int(2045)));
                              ir_if *f29F2 = new(mem_ctx) ir_if(operand(r29F3).val);
                              exec_list *const f29F2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29F2->then_instructions;

                                 ir_expression *const r29F4 = equal(body.constant(2097151u), r29A6);
                                 ir_expression *const r29F5 = equal(body.constant(4294967295u), r29A7);
                                 body.emit(assign(r29F1, logic_and(r29F4, r29F5), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f29F2->else_instructions;

                                 body.emit(assign(r29F1, body.constant(false), 0x01));


                              body.instructions = f29F2_parent_instructions;
                              body.emit(f29F2);

                              /* END IF */

                              body.emit(assign(r29EE, logic_and(r29F1, r29EA), 0x01));


                           body.instructions = f29EF_parent_instructions;
                           body.emit(f29EF);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f29F6 = new(mem_ctx) ir_if(operand(r29EE).val);
                           exec_list *const f29F6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29F6->then_instructions;

                              ir_variable *const r29F7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r29F7);
                              ir_expression *const r29F8 = lshift(r26A0, body.constant(int(31)));
                              body.emit(assign(r29F7, add(r29F8, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r29F7, body.constant(0u), 0x01));

                              body.emit(assign(r29E9, r29F7, 0x03));

                              body.emit(assign(r29E8, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29F6->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r29FA = less(r29A5, body.constant(int(0)));
                              ir_if *f29F9 = new(mem_ctx) ir_if(operand(r29FA).val);
                              exec_list *const f29F9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29F9->then_instructions;

                                 ir_variable *const r29FB = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r29FB, r29A8, 0x01));

                                 ir_variable *const r29FC = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r29FC, neg(r29A5), 0x01));

                                 ir_variable *const r29FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r29FD);
                                 ir_variable *const r29FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r29FE);
                                 ir_variable *const r29FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r29FF);
                                 ir_variable *const r2A00 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2A01 = neg(r29FC);
                                 body.emit(assign(r2A00, bit_and(r2A01, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2A03 = equal(r29FC, body.constant(int(0)));
                                 ir_if *f2A02 = new(mem_ctx) ir_if(operand(r2A03).val);
                                 exec_list *const f2A02_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A02->then_instructions;

                                    body.emit(assign(r29FD, r29A8, 0x01));

                                    body.emit(assign(r29FE, r29A7, 0x01));

                                    body.emit(assign(r29FF, r29A6, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A02->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2A05 = less(r29FC, body.constant(int(32)));
                                    ir_if *f2A04 = new(mem_ctx) ir_if(operand(r2A05).val);
                                    exec_list *const f2A04_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2A04->then_instructions;

                                       body.emit(assign(r29FD, lshift(r29A7, r2A00), 0x01));

                                       ir_expression *const r2A06 = lshift(r29A6, r2A00);
                                       ir_expression *const r2A07 = rshift(r29A7, r29FC);
                                       body.emit(assign(r29FE, bit_or(r2A06, r2A07), 0x01));

                                       body.emit(assign(r29FF, rshift(r29A6, r29FC), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2A04->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2A09 = equal(r29FC, body.constant(int(32)));
                                       ir_if *f2A08 = new(mem_ctx) ir_if(operand(r2A09).val);
                                       exec_list *const f2A08_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2A08->then_instructions;

                                          body.emit(assign(r29FD, r29A7, 0x01));

                                          body.emit(assign(r29FE, r29A6, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2A08->else_instructions;

                                          body.emit(assign(r29FB, bit_or(r29A8, r29A7), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2A0B = less(r29FC, body.constant(int(64)));
                                          ir_if *f2A0A = new(mem_ctx) ir_if(operand(r2A0B).val);
                                          exec_list *const f2A0A_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2A0A->then_instructions;

                                             body.emit(assign(r29FD, lshift(r29A6, r2A00), 0x01));

                                             ir_expression *const r2A0C = bit_and(r29FC, body.constant(int(31)));
                                             body.emit(assign(r29FE, rshift(r29A6, r2A0C), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2A0A->else_instructions;

                                             ir_variable *const r2A0D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2A0F = equal(r29FC, body.constant(int(64)));
                                             ir_if *f2A0E = new(mem_ctx) ir_if(operand(r2A0F).val);
                                             exec_list *const f2A0E_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2A0E->then_instructions;

                                                body.emit(assign(r2A0D, r29A6, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2A0E->else_instructions;

                                                ir_expression *const r2A10 = nequal(r29A6, body.constant(0u));
                                                ir_expression *const r2A11 = expr(ir_unop_b2i, r2A10);
                                                body.emit(assign(r2A0D, expr(ir_unop_i2u, r2A11), 0x01));


                                             body.instructions = f2A0E_parent_instructions;
                                             body.emit(f2A0E);

                                             /* END IF */

                                             body.emit(assign(r29FD, r2A0D, 0x01));

                                             body.emit(assign(r29FE, body.constant(0u), 0x01));


                                          body.instructions = f2A0A_parent_instructions;
                                          body.emit(f2A0A);

                                          /* END IF */


                                       body.instructions = f2A08_parent_instructions;
                                       body.emit(f2A08);

                                       /* END IF */

                                       body.emit(assign(r29FF, body.constant(0u), 0x01));


                                    body.instructions = f2A04_parent_instructions;
                                    body.emit(f2A04);

                                    /* END IF */

                                    ir_expression *const r2A12 = nequal(r29FB, body.constant(0u));
                                    ir_expression *const r2A13 = expr(ir_unop_b2i, r2A12);
                                    ir_expression *const r2A14 = expr(ir_unop_i2u, r2A13);
                                    body.emit(assign(r29FD, bit_or(r29FD, r2A14), 0x01));


                                 body.instructions = f2A02_parent_instructions;
                                 body.emit(f2A02);

                                 /* END IF */

                                 body.emit(assign(r29E5, r29FF, 0x01));

                                 body.emit(assign(r29E6, r29FE, 0x01));

                                 body.emit(assign(r29E7, r29FD, 0x01));

                                 body.emit(assign(r29E4, body.constant(int(0)), 0x01));

                                 body.emit(assign(r29EA, less(r29FD, body.constant(0u)), 0x01));


                              body.instructions = f29F9_parent_instructions;
                              body.emit(f29F9);

                              /* END IF */


                           body.instructions = f29F6_parent_instructions;
                           body.emit(f29F6);

                           /* END IF */


                        body.instructions = f29EC_parent_instructions;
                        body.emit(f29EC);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2A15 = new(mem_ctx) ir_if(operand(r29E8).val);
                        exec_list *const f2A15_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2A15->then_instructions;

                           /* IF CONDITION */
                           ir_if *f2A16 = new(mem_ctx) ir_if(operand(r29EA).val);
                           exec_list *const f2A16_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A16->then_instructions;

                              ir_variable *const r2A17 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r2A17, add(r29E6, body.constant(1u)), 0x01));

                              ir_expression *const r2A18 = less(r2A17, r29E6);
                              ir_expression *const r2A19 = expr(ir_unop_b2i, r2A18);
                              ir_expression *const r2A1A = expr(ir_unop_i2u, r2A19);
                              body.emit(assign(r29E5, add(r29E5, r2A1A), 0x01));

                              ir_expression *const r2A1B = equal(r29E7, body.constant(0u));
                              ir_expression *const r2A1C = expr(ir_unop_b2i, r2A1B);
                              ir_expression *const r2A1D = expr(ir_unop_i2u, r2A1C);
                              ir_expression *const r2A1E = add(r29E7, r2A1D);
                              ir_expression *const r2A1F = bit_and(r2A1E, body.constant(1u));
                              ir_expression *const r2A20 = expr(ir_unop_bit_not, r2A1F);
                              body.emit(assign(r29E6, bit_and(r2A17, r2A20), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A16->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2A22 = bit_or(r29E5, r29E6);
                              ir_expression *const r2A23 = equal(r2A22, body.constant(0u));
                              ir_if *f2A21 = new(mem_ctx) ir_if(operand(r2A23).val);
                              exec_list *const f2A21_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A21->then_instructions;

                                 body.emit(assign(r29E4, body.constant(int(0)), 0x01));


                              body.instructions = f2A21_parent_instructions;
                              body.emit(f2A21);

                              /* END IF */


                           body.instructions = f2A16_parent_instructions;
                           body.emit(f2A16);

                           /* END IF */

                           ir_variable *const r2A24 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2A24);
                           ir_expression *const r2A25 = lshift(r26A0, body.constant(int(31)));
                           ir_expression *const r2A26 = expr(ir_unop_i2u, r29E4);
                           ir_expression *const r2A27 = lshift(r2A26, body.constant(int(20)));
                           ir_expression *const r2A28 = add(r2A25, r2A27);
                           body.emit(assign(r2A24, add(r2A28, r29E5), 0x02));

                           body.emit(assign(r2A24, r29E6, 0x01));

                           body.emit(assign(r29E9, r2A24, 0x03));

                           body.emit(assign(r29E8, body.constant(false), 0x01));


                        body.instructions = f2A15_parent_instructions;
                        body.emit(f2A15);

                        /* END IF */

                        body.emit(assign(r26A1, r29E9, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f299D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2A2A = less(r26A8, r26A6);
                        ir_if *f2A29 = new(mem_ctx) ir_if(operand(r2A2A).val);
                        exec_list *const f2A29_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2A29->then_instructions;

                           ir_variable *const r2A2B = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r2A2C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2A2C, sub(r26A6, r26A8), 0x01));

                           ir_expression *const r2A2D = sub(r26A5, r26A7);
                           ir_expression *const r2A2E = less(r26A6, r26A8);
                           ir_expression *const r2A2F = expr(ir_unop_b2i, r2A2E);
                           ir_expression *const r2A30 = expr(ir_unop_i2u, r2A2F);
                           body.emit(assign(r2A2B, sub(r2A2D, r2A30), 0x01));

                           body.emit(assign(r26A0, bit_xor(r26A0, body.constant(1u)), 0x01));

                           body.emit(assign(r26A9, add(r26A3, body.constant(int(-1))), 0x01));

                           ir_variable *const r2A31 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2A31, add(r26A9, body.constant(int(-10))), 0x01));

                           ir_variable *const r2A32 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2A32, r2A2B, 0x01));

                           ir_variable *const r2A33 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2A33, r2A2C, 0x01));

                           ir_variable *const r2A34 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r2A34);
                           ir_variable *const r2A35 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2A35);
                           /* IF CONDITION */
                           ir_expression *const r2A37 = equal(r2A2B, body.constant(0u));
                           ir_if *f2A36 = new(mem_ctx) ir_if(operand(r2A37).val);
                           exec_list *const f2A36_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A36->then_instructions;

                              body.emit(assign(r2A32, r2A2C, 0x01));

                              body.emit(assign(r2A33, body.constant(0u), 0x01));

                              body.emit(assign(r2A31, add(r2A31, body.constant(int(-32))), 0x01));


                           body.instructions = f2A36_parent_instructions;
                           body.emit(f2A36);

                           /* END IF */

                           ir_variable *const r2A38 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r2A38, r2A32, 0x01));

                           ir_variable *const r2A39 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r2A3A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2A3A);
                           /* IF CONDITION */
                           ir_expression *const r2A3C = equal(r2A32, body.constant(0u));
                           ir_if *f2A3B = new(mem_ctx) ir_if(operand(r2A3C).val);
                           exec_list *const f2A3B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A3B->then_instructions;

                              body.emit(assign(r2A39, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A3B->else_instructions;

                              body.emit(assign(r2A3A, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2A3E = bit_and(r2A32, body.constant(4294901760u));
                              ir_expression *const r2A3F = equal(r2A3E, body.constant(0u));
                              ir_if *f2A3D = new(mem_ctx) ir_if(operand(r2A3F).val);
                              exec_list *const f2A3D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A3D->then_instructions;

                                 body.emit(assign(r2A3A, body.constant(int(16)), 0x01));

                                 body.emit(assign(r2A38, lshift(r2A32, body.constant(int(16))), 0x01));


                              body.instructions = f2A3D_parent_instructions;
                              body.emit(f2A3D);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A41 = bit_and(r2A38, body.constant(4278190080u));
                              ir_expression *const r2A42 = equal(r2A41, body.constant(0u));
                              ir_if *f2A40 = new(mem_ctx) ir_if(operand(r2A42).val);
                              exec_list *const f2A40_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A40->then_instructions;

                                 body.emit(assign(r2A3A, add(r2A3A, body.constant(int(8))), 0x01));

                                 body.emit(assign(r2A38, lshift(r2A38, body.constant(int(8))), 0x01));


                              body.instructions = f2A40_parent_instructions;
                              body.emit(f2A40);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A44 = bit_and(r2A38, body.constant(4026531840u));
                              ir_expression *const r2A45 = equal(r2A44, body.constant(0u));
                              ir_if *f2A43 = new(mem_ctx) ir_if(operand(r2A45).val);
                              exec_list *const f2A43_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A43->then_instructions;

                                 body.emit(assign(r2A3A, add(r2A3A, body.constant(int(4))), 0x01));

                                 body.emit(assign(r2A38, lshift(r2A38, body.constant(int(4))), 0x01));


                              body.instructions = f2A43_parent_instructions;
                              body.emit(f2A43);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A47 = bit_and(r2A38, body.constant(3221225472u));
                              ir_expression *const r2A48 = equal(r2A47, body.constant(0u));
                              ir_if *f2A46 = new(mem_ctx) ir_if(operand(r2A48).val);
                              exec_list *const f2A46_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A46->then_instructions;

                                 body.emit(assign(r2A3A, add(r2A3A, body.constant(int(2))), 0x01));

                                 body.emit(assign(r2A38, lshift(r2A38, body.constant(int(2))), 0x01));


                              body.instructions = f2A46_parent_instructions;
                              body.emit(f2A46);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A4A = bit_and(r2A38, body.constant(2147483648u));
                              ir_expression *const r2A4B = equal(r2A4A, body.constant(0u));
                              ir_if *f2A49 = new(mem_ctx) ir_if(operand(r2A4B).val);
                              exec_list *const f2A49_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A49->then_instructions;

                                 body.emit(assign(r2A3A, add(r2A3A, body.constant(int(1))), 0x01));


                              body.instructions = f2A49_parent_instructions;
                              body.emit(f2A49);

                              /* END IF */

                              body.emit(assign(r2A39, r2A3A, 0x01));


                           body.instructions = f2A3B_parent_instructions;
                           body.emit(f2A3B);

                           /* END IF */

                           body.emit(assign(r2A35, add(r2A39, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2A4D = lequal(body.constant(int(0)), r2A35);
                           ir_if *f2A4C = new(mem_ctx) ir_if(operand(r2A4D).val);
                           exec_list *const f2A4C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A4C->then_instructions;

                              body.emit(assign(r2A34, body.constant(0u), 0x01));

                              ir_variable *const r2A4E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2A4E, lshift(r2A33, r2A35), 0x01));

                              ir_variable *const r2A4F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2A51 = equal(r2A35, body.constant(int(0)));
                              ir_if *f2A50 = new(mem_ctx) ir_if(operand(r2A51).val);
                              exec_list *const f2A50_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A50->then_instructions;

                                 body.emit(assign(r2A4F, r2A32, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A50->else_instructions;

                                 ir_expression *const r2A52 = lshift(r2A32, r2A35);
                                 ir_expression *const r2A53 = neg(r2A35);
                                 ir_expression *const r2A54 = bit_and(r2A53, body.constant(int(31)));
                                 ir_expression *const r2A55 = rshift(r2A33, r2A54);
                                 body.emit(assign(r2A4F, bit_or(r2A52, r2A55), 0x01));


                              body.instructions = f2A50_parent_instructions;
                              body.emit(f2A50);

                              /* END IF */

                              body.emit(assign(r2A32, r2A4F, 0x01));

                              body.emit(assign(r2A33, r2A4E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A4C->else_instructions;

                              ir_variable *const r2A56 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2A56, body.constant(0u), 0x01));

                              ir_variable *const r2A57 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2A57, neg(r2A35), 0x01));

                              ir_variable *const r2A58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2A58);
                              ir_variable *const r2A59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2A59);
                              ir_variable *const r2A5A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2A5A);
                              ir_variable *const r2A5B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2A5C = neg(r2A57);
                              body.emit(assign(r2A5B, bit_and(r2A5C, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2A5E = equal(r2A57, body.constant(int(0)));
                              ir_if *f2A5D = new(mem_ctx) ir_if(operand(r2A5E).val);
                              exec_list *const f2A5D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A5D->then_instructions;

                                 body.emit(assign(r2A58, r2A56, 0x01));

                                 body.emit(assign(r2A59, r2A33, 0x01));

                                 body.emit(assign(r2A5A, r2A32, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A5D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2A60 = less(r2A57, body.constant(int(32)));
                                 ir_if *f2A5F = new(mem_ctx) ir_if(operand(r2A60).val);
                                 exec_list *const f2A5F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A5F->then_instructions;

                                    body.emit(assign(r2A58, lshift(r2A33, r2A5B), 0x01));

                                    ir_expression *const r2A61 = lshift(r2A32, r2A5B);
                                    ir_expression *const r2A62 = rshift(r2A33, r2A57);
                                    body.emit(assign(r2A59, bit_or(r2A61, r2A62), 0x01));

                                    body.emit(assign(r2A5A, rshift(r2A32, r2A57), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A5F->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2A64 = equal(r2A57, body.constant(int(32)));
                                    ir_if *f2A63 = new(mem_ctx) ir_if(operand(r2A64).val);
                                    exec_list *const f2A63_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2A63->then_instructions;

                                       body.emit(assign(r2A58, r2A33, 0x01));

                                       body.emit(assign(r2A59, r2A32, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2A63->else_instructions;

                                       body.emit(assign(r2A56, bit_or(body.constant(0u), r2A33), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2A66 = less(r2A57, body.constant(int(64)));
                                       ir_if *f2A65 = new(mem_ctx) ir_if(operand(r2A66).val);
                                       exec_list *const f2A65_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2A65->then_instructions;

                                          body.emit(assign(r2A58, lshift(r2A32, r2A5B), 0x01));

                                          ir_expression *const r2A67 = bit_and(r2A57, body.constant(int(31)));
                                          body.emit(assign(r2A59, rshift(r2A32, r2A67), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2A65->else_instructions;

                                          ir_variable *const r2A68 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2A6A = equal(r2A57, body.constant(int(64)));
                                          ir_if *f2A69 = new(mem_ctx) ir_if(operand(r2A6A).val);
                                          exec_list *const f2A69_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2A69->then_instructions;

                                             body.emit(assign(r2A68, r2A32, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2A69->else_instructions;

                                             ir_expression *const r2A6B = nequal(r2A32, body.constant(0u));
                                             ir_expression *const r2A6C = expr(ir_unop_b2i, r2A6B);
                                             body.emit(assign(r2A68, expr(ir_unop_i2u, r2A6C), 0x01));


                                          body.instructions = f2A69_parent_instructions;
                                          body.emit(f2A69);

                                          /* END IF */

                                          body.emit(assign(r2A58, r2A68, 0x01));

                                          body.emit(assign(r2A59, body.constant(0u), 0x01));


                                       body.instructions = f2A65_parent_instructions;
                                       body.emit(f2A65);

                                       /* END IF */


                                    body.instructions = f2A63_parent_instructions;
                                    body.emit(f2A63);

                                    /* END IF */

                                    body.emit(assign(r2A5A, body.constant(0u), 0x01));


                                 body.instructions = f2A5F_parent_instructions;
                                 body.emit(f2A5F);

                                 /* END IF */

                                 ir_expression *const r2A6D = nequal(r2A56, body.constant(0u));
                                 ir_expression *const r2A6E = expr(ir_unop_b2i, r2A6D);
                                 ir_expression *const r2A6F = expr(ir_unop_i2u, r2A6E);
                                 body.emit(assign(r2A58, bit_or(r2A58, r2A6F), 0x01));


                              body.instructions = f2A5D_parent_instructions;
                              body.emit(f2A5D);

                              /* END IF */

                              body.emit(assign(r2A32, r2A5A, 0x01));

                              body.emit(assign(r2A33, r2A59, 0x01));

                              body.emit(assign(r2A34, r2A58, 0x01));


                           body.instructions = f2A4C_parent_instructions;
                           body.emit(f2A4C);

                           /* END IF */

                           body.emit(assign(r2A31, sub(r2A31, r2A35), 0x01));

                           ir_variable *const r2A70 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2A70, r2A31, 0x01));

                           ir_variable *const r2A71 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2A71, r2A32, 0x01));

                           ir_variable *const r2A72 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2A72, r2A33, 0x01));

                           ir_variable *const r2A73 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r2A73, r2A34, 0x01));

                           ir_variable *const r2A74 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r2A74, body.constant(true), 0x01));

                           ir_variable *const r2A75 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r2A76 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r2A76);
                           ir_expression *const r2A77 = expr(ir_unop_u2i, r2A34);
                           body.emit(assign(r2A76, less(r2A77, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2A79 = lequal(body.constant(int(2045)), r2A31);
                           ir_if *f2A78 = new(mem_ctx) ir_if(operand(r2A79).val);
                           exec_list *const f2A78_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A78->then_instructions;

                              ir_variable *const r2A7A = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2A7C = less(body.constant(int(2045)), r2A31);
                              ir_if *f2A7B = new(mem_ctx) ir_if(operand(r2A7C).val);
                              exec_list *const f2A7B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A7B->then_instructions;

                                 body.emit(assign(r2A7A, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A7B->else_instructions;

                                 ir_variable *const r2A7D = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2A7F = equal(r2A31, body.constant(int(2045)));
                                 ir_if *f2A7E = new(mem_ctx) ir_if(operand(r2A7F).val);
                                 exec_list *const f2A7E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A7E->then_instructions;

                                    ir_expression *const r2A80 = equal(body.constant(2097151u), r2A32);
                                    ir_expression *const r2A81 = equal(body.constant(4294967295u), r2A33);
                                    body.emit(assign(r2A7D, logic_and(r2A80, r2A81), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A7E->else_instructions;

                                    body.emit(assign(r2A7D, body.constant(false), 0x01));


                                 body.instructions = f2A7E_parent_instructions;
                                 body.emit(f2A7E);

                                 /* END IF */

                                 body.emit(assign(r2A7A, logic_and(r2A7D, r2A76), 0x01));


                              body.instructions = f2A7B_parent_instructions;
                              body.emit(f2A7B);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2A82 = new(mem_ctx) ir_if(operand(r2A7A).val);
                              exec_list *const f2A82_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A82->then_instructions;

                                 ir_variable *const r2A83 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2A83);
                                 ir_expression *const r2A84 = lshift(r26A0, body.constant(int(31)));
                                 body.emit(assign(r2A83, add(r2A84, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r2A83, body.constant(0u), 0x01));

                                 body.emit(assign(r2A75, r2A83, 0x03));

                                 body.emit(assign(r2A74, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A82->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2A86 = less(r2A31, body.constant(int(0)));
                                 ir_if *f2A85 = new(mem_ctx) ir_if(operand(r2A86).val);
                                 exec_list *const f2A85_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A85->then_instructions;

                                    ir_variable *const r2A87 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r2A87, r2A34, 0x01));

                                    ir_variable *const r2A88 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r2A88, neg(r2A31), 0x01));

                                    ir_variable *const r2A89 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r2A89);
                                    ir_variable *const r2A8A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r2A8A);
                                    ir_variable *const r2A8B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2A8B);
                                    ir_variable *const r2A8C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2A8D = neg(r2A88);
                                    body.emit(assign(r2A8C, bit_and(r2A8D, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2A8F = equal(r2A88, body.constant(int(0)));
                                    ir_if *f2A8E = new(mem_ctx) ir_if(operand(r2A8F).val);
                                    exec_list *const f2A8E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2A8E->then_instructions;

                                       body.emit(assign(r2A89, r2A34, 0x01));

                                       body.emit(assign(r2A8A, r2A33, 0x01));

                                       body.emit(assign(r2A8B, r2A32, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2A8E->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2A91 = less(r2A88, body.constant(int(32)));
                                       ir_if *f2A90 = new(mem_ctx) ir_if(operand(r2A91).val);
                                       exec_list *const f2A90_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2A90->then_instructions;

                                          body.emit(assign(r2A89, lshift(r2A33, r2A8C), 0x01));

                                          ir_expression *const r2A92 = lshift(r2A32, r2A8C);
                                          ir_expression *const r2A93 = rshift(r2A33, r2A88);
                                          body.emit(assign(r2A8A, bit_or(r2A92, r2A93), 0x01));

                                          body.emit(assign(r2A8B, rshift(r2A32, r2A88), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2A90->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2A95 = equal(r2A88, body.constant(int(32)));
                                          ir_if *f2A94 = new(mem_ctx) ir_if(operand(r2A95).val);
                                          exec_list *const f2A94_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2A94->then_instructions;

                                             body.emit(assign(r2A89, r2A33, 0x01));

                                             body.emit(assign(r2A8A, r2A32, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2A94->else_instructions;

                                             body.emit(assign(r2A87, bit_or(r2A34, r2A33), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r2A97 = less(r2A88, body.constant(int(64)));
                                             ir_if *f2A96 = new(mem_ctx) ir_if(operand(r2A97).val);
                                             exec_list *const f2A96_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2A96->then_instructions;

                                                body.emit(assign(r2A89, lshift(r2A32, r2A8C), 0x01));

                                                ir_expression *const r2A98 = bit_and(r2A88, body.constant(int(31)));
                                                body.emit(assign(r2A8A, rshift(r2A32, r2A98), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2A96->else_instructions;

                                                ir_variable *const r2A99 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2A9B = equal(r2A88, body.constant(int(64)));
                                                ir_if *f2A9A = new(mem_ctx) ir_if(operand(r2A9B).val);
                                                exec_list *const f2A9A_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2A9A->then_instructions;

                                                   body.emit(assign(r2A99, r2A32, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2A9A->else_instructions;

                                                   ir_expression *const r2A9C = nequal(r2A32, body.constant(0u));
                                                   ir_expression *const r2A9D = expr(ir_unop_b2i, r2A9C);
                                                   body.emit(assign(r2A99, expr(ir_unop_i2u, r2A9D), 0x01));


                                                body.instructions = f2A9A_parent_instructions;
                                                body.emit(f2A9A);

                                                /* END IF */

                                                body.emit(assign(r2A89, r2A99, 0x01));

                                                body.emit(assign(r2A8A, body.constant(0u), 0x01));


                                             body.instructions = f2A96_parent_instructions;
                                             body.emit(f2A96);

                                             /* END IF */


                                          body.instructions = f2A94_parent_instructions;
                                          body.emit(f2A94);

                                          /* END IF */

                                          body.emit(assign(r2A8B, body.constant(0u), 0x01));


                                       body.instructions = f2A90_parent_instructions;
                                       body.emit(f2A90);

                                       /* END IF */

                                       ir_expression *const r2A9E = nequal(r2A87, body.constant(0u));
                                       ir_expression *const r2A9F = expr(ir_unop_b2i, r2A9E);
                                       ir_expression *const r2AA0 = expr(ir_unop_i2u, r2A9F);
                                       body.emit(assign(r2A89, bit_or(r2A89, r2AA0), 0x01));


                                    body.instructions = f2A8E_parent_instructions;
                                    body.emit(f2A8E);

                                    /* END IF */

                                    body.emit(assign(r2A71, r2A8B, 0x01));

                                    body.emit(assign(r2A72, r2A8A, 0x01));

                                    body.emit(assign(r2A73, r2A89, 0x01));

                                    body.emit(assign(r2A70, body.constant(int(0)), 0x01));

                                    body.emit(assign(r2A76, less(r2A89, body.constant(0u)), 0x01));


                                 body.instructions = f2A85_parent_instructions;
                                 body.emit(f2A85);

                                 /* END IF */


                              body.instructions = f2A82_parent_instructions;
                              body.emit(f2A82);

                              /* END IF */


                           body.instructions = f2A78_parent_instructions;
                           body.emit(f2A78);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2AA1 = new(mem_ctx) ir_if(operand(r2A74).val);
                           exec_list *const f2AA1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2AA1->then_instructions;

                              /* IF CONDITION */
                              ir_if *f2AA2 = new(mem_ctx) ir_if(operand(r2A76).val);
                              exec_list *const f2AA2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AA2->then_instructions;

                                 ir_variable *const r2AA3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r2AA3, add(r2A72, body.constant(1u)), 0x01));

                                 ir_expression *const r2AA4 = less(r2AA3, r2A72);
                                 ir_expression *const r2AA5 = expr(ir_unop_b2i, r2AA4);
                                 ir_expression *const r2AA6 = expr(ir_unop_i2u, r2AA5);
                                 body.emit(assign(r2A71, add(r2A71, r2AA6), 0x01));

                                 ir_expression *const r2AA7 = equal(r2A73, body.constant(0u));
                                 ir_expression *const r2AA8 = expr(ir_unop_b2i, r2AA7);
                                 ir_expression *const r2AA9 = expr(ir_unop_i2u, r2AA8);
                                 ir_expression *const r2AAA = add(r2A73, r2AA9);
                                 ir_expression *const r2AAB = bit_and(r2AAA, body.constant(1u));
                                 ir_expression *const r2AAC = expr(ir_unop_bit_not, r2AAB);
                                 body.emit(assign(r2A72, bit_and(r2AA3, r2AAC), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2AA2->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2AAE = bit_or(r2A71, r2A72);
                                 ir_expression *const r2AAF = equal(r2AAE, body.constant(0u));
                                 ir_if *f2AAD = new(mem_ctx) ir_if(operand(r2AAF).val);
                                 exec_list *const f2AAD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AAD->then_instructions;

                                    body.emit(assign(r2A70, body.constant(int(0)), 0x01));


                                 body.instructions = f2AAD_parent_instructions;
                                 body.emit(f2AAD);

                                 /* END IF */


                              body.instructions = f2AA2_parent_instructions;
                              body.emit(f2AA2);

                              /* END IF */

                              ir_variable *const r2AB0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2AB0);
                              ir_expression *const r2AB1 = lshift(r26A0, body.constant(int(31)));
                              ir_expression *const r2AB2 = expr(ir_unop_i2u, r2A70);
                              ir_expression *const r2AB3 = lshift(r2AB2, body.constant(int(20)));
                              ir_expression *const r2AB4 = add(r2AB1, r2AB3);
                              body.emit(assign(r2AB0, add(r2AB4, r2A71), 0x02));

                              body.emit(assign(r2AB0, r2A72, 0x01));

                              body.emit(assign(r2A75, r2AB0, 0x03));

                              body.emit(assign(r2A74, body.constant(false), 0x01));


                           body.instructions = f2AA1_parent_instructions;
                           body.emit(f2AA1);

                           /* END IF */

                           body.emit(assign(r26A1, r2A75, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2A29->else_instructions;

                           ir_variable *const r2AB5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2AB5);
                           body.emit(assign(r2AB5, body.constant(0u), 0x02));

                           body.emit(assign(r2AB5, body.constant(0u), 0x01));

                           body.emit(assign(r26A1, r2AB5, 0x03));


                        body.instructions = f2A29_parent_instructions;
                        body.emit(f2A29);

                        /* END IF */


                     body.instructions = f299D_parent_instructions;
                     body.emit(f299D);

                     /* END IF */


                  body.instructions = f2911_parent_instructions;
                  body.emit(f2911);

                  /* END IF */


               body.instructions = f2885_parent_instructions;
               body.emit(f2885);

               /* END IF */


            body.instructions = f285E_parent_instructions;
            body.emit(f285E);

            /* END IF */


         body.instructions = f278A_parent_instructions;
         body.emit(f278A);

         /* END IF */


      body.instructions = f26BA_parent_instructions;
      body.emit(f26BA);

      /* END IF */

      body.emit(assign(r24F2, r26A1, 0x03));


   body.instructions = f24F5_parent_instructions;
   body.emit(f24F5);

   /* END IF */

   body.emit(ret(r24F2));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmod64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r2AB6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "x", ir_var_function_in);
   sig_parameters.push_tail(r2AB6);
   ir_variable *const r2AB7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "y", ir_var_function_in);
   sig_parameters.push_tail(r2AB7);
   ir_constant *const r2AB8 = ir_constant::zero(mem_ctx, glsl_type::uvec2_type);
   body.emit(ret(r2AB8));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsign64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r2AB9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r2AB9);
   ir_variable *const r2ABA = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r2ABB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "retval", ir_var_auto);
   body.emit(r2ABB);
   /* IF CONDITION */
   ir_expression *const r2ABD = lshift(swizzle_y(r2AB9), body.constant(int(1)));
   ir_expression *const r2ABE = bit_or(r2ABD, swizzle_x(r2AB9));
   ir_expression *const r2ABF = equal(r2ABE, body.constant(0u));
   ir_if *f2ABC = new(mem_ctx) ir_if(operand(r2ABF).val);
   exec_list *const f2ABC_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2ABC->then_instructions;

      body.emit(assign(r2ABA, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2ABC->else_instructions;

      body.emit(assign(r2ABB, body.constant(0u), 0x01));

      ir_expression *const r2AC0 = bit_and(swizzle_y(r2AB9), body.constant(2147483648u));
      body.emit(assign(r2ABB, bit_or(r2AC0, body.constant(1072693248u)), 0x02));

      body.emit(assign(r2ABA, r2ABB, 0x03));


   body.instructions = f2ABC_parent_instructions;
   body.emit(f2ABC);

   /* END IF */

   body.emit(ret(r2ABA));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
