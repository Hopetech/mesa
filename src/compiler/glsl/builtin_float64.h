ir_function_signature *
fabs64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000B);
   body.emit(assign(r000B, bit_and(swizzle_y(r000B), body.constant(2147483647u)), 0x02));

   body.emit(ret(r000B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
is_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000C);
   ir_expression *const r000D = lshift(swizzle_y(r000C), body.constant(int(1)));
   ir_expression *const r000E = lequal(body.constant(4292870144u), r000D);
   ir_expression *const r000F = nequal(swizzle_x(r000C), body.constant(0u));
   ir_expression *const r0010 = bit_and(swizzle_y(r000C), body.constant(1048575u));
   ir_expression *const r0011 = nequal(r0010, body.constant(0u));
   ir_expression *const r0012 = logic_or(r000F, r0011);
   ir_expression *const r0013 = logic_and(r000E, r0012);
   body.emit(ret(r0013));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fneg64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0014 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0014);
   ir_variable *const r0015 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r0017 = lshift(swizzle_y(r0014), body.constant(int(1)));
   ir_expression *const r0018 = lequal(body.constant(4292870144u), r0017);
   ir_expression *const r0019 = nequal(swizzle_x(r0014), body.constant(0u));
   ir_expression *const r001A = bit_and(swizzle_y(r0014), body.constant(1048575u));
   ir_expression *const r001B = nequal(r001A, body.constant(0u));
   ir_expression *const r001C = logic_or(r0019, r001B);
   ir_expression *const r001D = logic_and(r0018, r001C);
   ir_if *f0016 = new(mem_ctx) ir_if(operand(r001D).val);
   exec_list *const f0016_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0016->then_instructions;

      body.emit(assign(r0015, r0014, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0016->else_instructions;

      body.emit(assign(r0014, bit_xor(swizzle_y(r0014), body.constant(2147483648u)), 0x02));

      body.emit(assign(r0015, r0014, 0x03));


   body.instructions = f0016_parent_instructions;
   body.emit(f0016);

   /* END IF */

   body.emit(ret(r0015));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Frac(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r001E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r001E);
   ir_variable *const r001F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r001F);
   body.emit(assign(r001F, bit_and(swizzle_y(r001E), body.constant(1048575u)), 0x02));

   body.emit(assign(r001F, swizzle_x(r001E), 0x01));

   body.emit(ret(r001F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0020 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0020);
   ir_expression *const r0021 = rshift(swizzle_y(r0020), body.constant(int(20)));
   ir_expression *const r0022 = bit_and(r0021, body.constant(2047u));
   ir_expression *const r0023 = expr(ir_unop_u2i, r0022);
   body.emit(ret(r0023));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
feq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0024 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0024);
   ir_variable *const r0025 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0025);
   ir_variable *const r0026 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0027 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0027);
   ir_variable *const r0028 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0028);
   ir_variable *const r0029 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0029);
   body.emit(assign(r0029, bit_and(swizzle_y(r0024), body.constant(1048575u)), 0x02));

   body.emit(assign(r0029, swizzle_x(r0024), 0x01));

   ir_variable *const r002A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r002A);
   body.emit(assign(r002A, bit_and(swizzle_y(r0025), body.constant(1048575u)), 0x02));

   body.emit(assign(r002A, swizzle_x(r0025), 0x01));

   ir_expression *const r002B = rshift(swizzle_y(r0024), body.constant(int(20)));
   ir_expression *const r002C = bit_and(r002B, body.constant(2047u));
   ir_expression *const r002D = expr(ir_unop_u2i, r002C);
   ir_expression *const r002E = equal(r002D, body.constant(int(2047)));
   ir_expression *const r002F = bit_or(swizzle_y(r0029), swizzle_x(r0024));
   ir_expression *const r0030 = nequal(r002F, body.constant(0u));
   body.emit(assign(r0028, logic_and(r002E, r0030), 0x01));

   ir_expression *const r0031 = rshift(swizzle_y(r0025), body.constant(int(20)));
   ir_expression *const r0032 = bit_and(r0031, body.constant(2047u));
   ir_expression *const r0033 = expr(ir_unop_u2i, r0032);
   ir_expression *const r0034 = equal(r0033, body.constant(int(2047)));
   ir_expression *const r0035 = bit_or(swizzle_y(r002A), swizzle_x(r0025));
   ir_expression *const r0036 = nequal(r0035, body.constant(0u));
   body.emit(assign(r0027, logic_and(r0034, r0036), 0x01));

   /* IF CONDITION */
   ir_expression *const r0038 = logic_or(r0028, r0027);
   ir_if *f0037 = new(mem_ctx) ir_if(operand(r0038).val);
   exec_list *const f0037_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0037->then_instructions;

      body.emit(assign(r0026, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0037->else_instructions;

      ir_expression *const r0039 = equal(swizzle_x(r0024), swizzle_x(r0025));
      ir_expression *const r003A = equal(swizzle_y(r0024), swizzle_y(r0025));
      ir_expression *const r003B = equal(swizzle_x(r0024), body.constant(0u));
      ir_expression *const r003C = bit_or(swizzle_y(r0024), swizzle_y(r0025));
      ir_expression *const r003D = lshift(r003C, body.constant(int(1)));
      ir_expression *const r003E = equal(r003D, body.constant(0u));
      ir_expression *const r003F = logic_and(r003B, r003E);
      ir_expression *const r0040 = logic_or(r003A, r003F);
      body.emit(assign(r0026, logic_and(r0039, r0040), 0x01));


   body.instructions = f0037_parent_instructions;
   body.emit(f0037);

   /* END IF */

   body.emit(ret(r0026));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0041 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0041);
   ir_expression *const r0042 = rshift(swizzle_y(r0041), body.constant(int(31)));
   body.emit(ret(r0042));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
le64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0043 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0043);
   ir_variable *const r0044 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0044);
   ir_variable *const r0045 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0045);
   ir_variable *const r0046 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0046);
   ir_expression *const r0047 = less(r0043, r0045);
   ir_expression *const r0048 = equal(r0043, r0045);
   ir_expression *const r0049 = lequal(r0044, r0046);
   ir_expression *const r004A = logic_and(r0048, r0049);
   ir_expression *const r004B = logic_or(r0047, r004A);
   body.emit(ret(r004B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fle64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r004C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r004C);
   ir_variable *const r004D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r004D);
   ir_variable *const r004E = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r004F = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r004F);
   ir_variable *const r0050 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0050);
   ir_variable *const r0051 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0051);
   body.emit(assign(r0051, bit_and(swizzle_y(r004C), body.constant(1048575u)), 0x02));

   body.emit(assign(r0051, swizzle_x(r004C), 0x01));

   ir_variable *const r0052 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0052);
   body.emit(assign(r0052, bit_and(swizzle_y(r004D), body.constant(1048575u)), 0x02));

   body.emit(assign(r0052, swizzle_x(r004D), 0x01));

   ir_expression *const r0053 = rshift(swizzle_y(r004C), body.constant(int(20)));
   ir_expression *const r0054 = bit_and(r0053, body.constant(2047u));
   ir_expression *const r0055 = expr(ir_unop_u2i, r0054);
   ir_expression *const r0056 = equal(r0055, body.constant(int(2047)));
   ir_expression *const r0057 = bit_or(swizzle_y(r0051), swizzle_x(r004C));
   ir_expression *const r0058 = nequal(r0057, body.constant(0u));
   body.emit(assign(r0050, logic_and(r0056, r0058), 0x01));

   ir_expression *const r0059 = rshift(swizzle_y(r004D), body.constant(int(20)));
   ir_expression *const r005A = bit_and(r0059, body.constant(2047u));
   ir_expression *const r005B = expr(ir_unop_u2i, r005A);
   ir_expression *const r005C = equal(r005B, body.constant(int(2047)));
   ir_expression *const r005D = bit_or(swizzle_y(r0052), swizzle_x(r004D));
   ir_expression *const r005E = nequal(r005D, body.constant(0u));
   body.emit(assign(r004F, logic_and(r005C, r005E), 0x01));

   /* IF CONDITION */
   ir_expression *const r0060 = logic_or(r0050, r004F);
   ir_if *f005F = new(mem_ctx) ir_if(operand(r0060).val);
   exec_list *const f005F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f005F->then_instructions;

      body.emit(assign(r004E, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f005F->else_instructions;

      ir_variable *const r0061 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0061, rshift(swizzle_y(r004C), body.constant(int(31))), 0x01));

      ir_variable *const r0062 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0062, rshift(swizzle_y(r004D), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0064 = nequal(r0061, r0062);
      ir_if *f0063 = new(mem_ctx) ir_if(operand(r0064).val);
      exec_list *const f0063_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0063->then_instructions;

         ir_expression *const r0065 = nequal(r0061, body.constant(0u));
         ir_expression *const r0066 = bit_or(swizzle_y(r004C), swizzle_y(r004D));
         ir_expression *const r0067 = lshift(r0066, body.constant(int(1)));
         ir_expression *const r0068 = bit_or(r0067, swizzle_x(r004C));
         ir_expression *const r0069 = bit_or(r0068, swizzle_x(r004D));
         ir_expression *const r006A = equal(r0069, body.constant(0u));
         body.emit(assign(r004E, logic_or(r0065, r006A), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0063->else_instructions;

         ir_variable *const r006B = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r006D = nequal(r0061, body.constant(0u));
         ir_if *f006C = new(mem_ctx) ir_if(operand(r006D).val);
         exec_list *const f006C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f006C->then_instructions;

            ir_expression *const r006E = less(swizzle_y(r004D), swizzle_y(r004C));
            ir_expression *const r006F = equal(swizzle_y(r004D), swizzle_y(r004C));
            ir_expression *const r0070 = lequal(swizzle_x(r004D), swizzle_x(r004C));
            ir_expression *const r0071 = logic_and(r006F, r0070);
            body.emit(assign(r006B, logic_or(r006E, r0071), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f006C->else_instructions;

            ir_expression *const r0072 = less(swizzle_y(r004C), swizzle_y(r004D));
            ir_expression *const r0073 = equal(swizzle_y(r004C), swizzle_y(r004D));
            ir_expression *const r0074 = lequal(swizzle_x(r004C), swizzle_x(r004D));
            ir_expression *const r0075 = logic_and(r0073, r0074);
            body.emit(assign(r006B, logic_or(r0072, r0075), 0x01));


         body.instructions = f006C_parent_instructions;
         body.emit(f006C);

         /* END IF */

         body.emit(assign(r004E, r006B, 0x01));


      body.instructions = f0063_parent_instructions;
      body.emit(f0063);

      /* END IF */


   body.instructions = f005F_parent_instructions;
   body.emit(f005F);

   /* END IF */

   body.emit(ret(r004E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
lt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0076 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0076);
   ir_variable *const r0077 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0077);
   ir_variable *const r0078 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0078);
   ir_variable *const r0079 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0079);
   ir_expression *const r007A = less(r0076, r0078);
   ir_expression *const r007B = equal(r0076, r0078);
   ir_expression *const r007C = less(r0077, r0079);
   ir_expression *const r007D = logic_and(r007B, r007C);
   ir_expression *const r007E = logic_or(r007A, r007D);
   body.emit(ret(r007E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
flt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r007F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r007F);
   ir_variable *const r0080 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0080);
   ir_variable *const r0081 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0082 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0082);
   ir_variable *const r0083 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0083);
   ir_variable *const r0084 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0084);
   body.emit(assign(r0084, bit_and(swizzle_y(r007F), body.constant(1048575u)), 0x02));

   body.emit(assign(r0084, swizzle_x(r007F), 0x01));

   ir_variable *const r0085 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0085);
   body.emit(assign(r0085, bit_and(swizzle_y(r0080), body.constant(1048575u)), 0x02));

   body.emit(assign(r0085, swizzle_x(r0080), 0x01));

   ir_expression *const r0086 = rshift(swizzle_y(r007F), body.constant(int(20)));
   ir_expression *const r0087 = bit_and(r0086, body.constant(2047u));
   ir_expression *const r0088 = expr(ir_unop_u2i, r0087);
   ir_expression *const r0089 = equal(r0088, body.constant(int(2047)));
   ir_expression *const r008A = bit_or(swizzle_y(r0084), swizzle_x(r007F));
   ir_expression *const r008B = nequal(r008A, body.constant(0u));
   body.emit(assign(r0083, logic_and(r0089, r008B), 0x01));

   ir_expression *const r008C = rshift(swizzle_y(r0080), body.constant(int(20)));
   ir_expression *const r008D = bit_and(r008C, body.constant(2047u));
   ir_expression *const r008E = expr(ir_unop_u2i, r008D);
   ir_expression *const r008F = equal(r008E, body.constant(int(2047)));
   ir_expression *const r0090 = bit_or(swizzle_y(r0085), swizzle_x(r0080));
   ir_expression *const r0091 = nequal(r0090, body.constant(0u));
   body.emit(assign(r0082, logic_and(r008F, r0091), 0x01));

   /* IF CONDITION */
   ir_expression *const r0093 = logic_or(r0083, r0082);
   ir_if *f0092 = new(mem_ctx) ir_if(operand(r0093).val);
   exec_list *const f0092_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0092->then_instructions;

      body.emit(assign(r0081, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0092->else_instructions;

      ir_variable *const r0094 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0094, rshift(swizzle_y(r007F), body.constant(int(31))), 0x01));

      ir_variable *const r0095 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0095, rshift(swizzle_y(r0080), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0097 = nequal(r0094, r0095);
      ir_if *f0096 = new(mem_ctx) ir_if(operand(r0097).val);
      exec_list *const f0096_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0096->then_instructions;

         ir_expression *const r0098 = nequal(r0094, body.constant(0u));
         ir_expression *const r0099 = bit_or(swizzle_y(r007F), swizzle_y(r0080));
         ir_expression *const r009A = lshift(r0099, body.constant(int(1)));
         ir_expression *const r009B = bit_or(r009A, swizzle_x(r007F));
         ir_expression *const r009C = bit_or(r009B, swizzle_x(r0080));
         ir_expression *const r009D = nequal(r009C, body.constant(0u));
         body.emit(assign(r0081, logic_and(r0098, r009D), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0096->else_instructions;

         ir_variable *const r009E = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r00A0 = nequal(r0094, body.constant(0u));
         ir_if *f009F = new(mem_ctx) ir_if(operand(r00A0).val);
         exec_list *const f009F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f009F->then_instructions;

            ir_expression *const r00A1 = less(swizzle_y(r0080), swizzle_y(r007F));
            ir_expression *const r00A2 = equal(swizzle_y(r0080), swizzle_y(r007F));
            ir_expression *const r00A3 = less(swizzle_x(r0080), swizzle_x(r007F));
            ir_expression *const r00A4 = logic_and(r00A2, r00A3);
            body.emit(assign(r009E, logic_or(r00A1, r00A4), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f009F->else_instructions;

            ir_expression *const r00A5 = less(swizzle_y(r007F), swizzle_y(r0080));
            ir_expression *const r00A6 = equal(swizzle_y(r007F), swizzle_y(r0080));
            ir_expression *const r00A7 = less(swizzle_x(r007F), swizzle_x(r0080));
            ir_expression *const r00A8 = logic_and(r00A6, r00A7);
            body.emit(assign(r009E, logic_or(r00A5, r00A8), 0x01));


         body.instructions = f009F_parent_instructions;
         body.emit(f009F);

         /* END IF */

         body.emit(assign(r0081, r009E, 0x01));


      body.instructions = f0096_parent_instructions;
      body.emit(f0096);

      /* END IF */


   body.instructions = f0092_parent_instructions;
   body.emit(f0092);

   /* END IF */

   body.emit(ret(r0081));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00A9);
   ir_variable *const r00AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00AA);
   ir_variable *const r00AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00AB);
   ir_variable *const r00AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00AC);
   ir_variable *const r00AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00AD);
   ir_variable *const r00AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00AE);
   ir_variable *const r00AF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r00AF, add(r00AA, r00AC), 0x01));

   body.emit(assign(r00AE, r00AF, 0x01));

   ir_expression *const r00B0 = add(r00A9, r00AB);
   ir_expression *const r00B1 = less(r00AF, r00AA);
   ir_expression *const r00B2 = expr(ir_unop_b2i, r00B1);
   ir_expression *const r00B3 = expr(ir_unop_i2u, r00B2);
   body.emit(assign(r00AD, add(r00B0, r00B3), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00B4);
   ir_variable *const r00B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00B5);
   ir_variable *const r00B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00B6);
   ir_variable *const r00B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00B7);
   ir_variable *const r00B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00B8);
   ir_variable *const r00B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00B9);
   body.emit(assign(r00B9, sub(r00B5, r00B7), 0x01));

   ir_expression *const r00BA = sub(r00B4, r00B6);
   ir_expression *const r00BB = less(r00B5, r00B7);
   ir_expression *const r00BC = expr(ir_unop_b2i, r00BB);
   ir_expression *const r00BD = expr(ir_unop_i2u, r00BC);
   body.emit(assign(r00B8, sub(r00BA, r00BD), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
eq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00BE);
   ir_variable *const r00BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00BF);
   ir_variable *const r00C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00C0);
   ir_variable *const r00C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00C1);
   ir_expression *const r00C2 = equal(r00BE, r00C0);
   ir_expression *const r00C3 = equal(r00BF, r00C1);
   ir_expression *const r00C4 = logic_and(r00C2, r00C3);
   body.emit(ret(r00C4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
float64_is_signaling_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r00C5);
   ir_expression *const r00C6 = rshift(swizzle_y(r00C5), body.constant(int(19)));
   ir_expression *const r00C7 = bit_and(r00C6, body.constant(4095u));
   ir_expression *const r00C8 = equal(r00C7, body.constant(4094u));
   ir_expression *const r00C9 = nequal(swizzle_x(r00C5), body.constant(0u));
   ir_expression *const r00CA = bit_and(swizzle_y(r00C5), body.constant(524287u));
   ir_expression *const r00CB = nequal(r00CA, body.constant(0u));
   ir_expression *const r00CC = logic_or(r00C9, r00CB);
   ir_expression *const r00CD = logic_and(r00C8, r00CC);
   body.emit(ret(r00CD));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00CE);
   ir_variable *const r00CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00CF);
   ir_variable *const r00D0 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00D0);
   ir_variable *const r00D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D1);
   ir_variable *const r00D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D2);
   ir_variable *const r00D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00D3);
   ir_variable *const r00D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00D4);
   ir_variable *const r00D5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r00D6 = neg(r00D0);
   body.emit(assign(r00D5, bit_and(r00D6, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r00D8 = equal(r00D0, body.constant(int(0)));
   ir_if *f00D7 = new(mem_ctx) ir_if(operand(r00D8).val);
   exec_list *const f00D7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f00D7->then_instructions;

      body.emit(assign(r00D3, r00CF, 0x01));

      body.emit(assign(r00D4, r00CE, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f00D7->else_instructions;

      /* IF CONDITION */
      ir_expression *const r00DA = less(r00D0, body.constant(int(32)));
      ir_if *f00D9 = new(mem_ctx) ir_if(operand(r00DA).val);
      exec_list *const f00D9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f00D9->then_instructions;

         ir_expression *const r00DB = lshift(r00CE, r00D5);
         ir_expression *const r00DC = rshift(r00CF, r00D0);
         ir_expression *const r00DD = bit_or(r00DB, r00DC);
         ir_expression *const r00DE = lshift(r00CF, r00D5);
         ir_expression *const r00DF = nequal(r00DE, body.constant(0u));
         ir_expression *const r00E0 = expr(ir_unop_b2i, r00DF);
         ir_expression *const r00E1 = expr(ir_unop_i2u, r00E0);
         body.emit(assign(r00D3, bit_or(r00DD, r00E1), 0x01));

         body.emit(assign(r00D4, rshift(r00CE, r00D0), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f00D9->else_instructions;

         /* IF CONDITION */
         ir_expression *const r00E3 = equal(r00D0, body.constant(int(32)));
         ir_if *f00E2 = new(mem_ctx) ir_if(operand(r00E3).val);
         exec_list *const f00E2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00E2->then_instructions;

            ir_expression *const r00E4 = nequal(r00CF, body.constant(0u));
            ir_expression *const r00E5 = expr(ir_unop_b2i, r00E4);
            ir_expression *const r00E6 = expr(ir_unop_i2u, r00E5);
            body.emit(assign(r00D3, bit_or(r00CE, r00E6), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00E2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r00E8 = less(r00D0, body.constant(int(64)));
            ir_if *f00E7 = new(mem_ctx) ir_if(operand(r00E8).val);
            exec_list *const f00E7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f00E7->then_instructions;

               ir_expression *const r00E9 = bit_and(r00D0, body.constant(int(31)));
               ir_expression *const r00EA = rshift(r00CE, r00E9);
               ir_expression *const r00EB = lshift(r00CE, r00D5);
               ir_expression *const r00EC = bit_or(r00EB, r00CF);
               ir_expression *const r00ED = nequal(r00EC, body.constant(0u));
               ir_expression *const r00EE = expr(ir_unop_b2i, r00ED);
               ir_expression *const r00EF = expr(ir_unop_i2u, r00EE);
               body.emit(assign(r00D3, bit_or(r00EA, r00EF), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f00E7->else_instructions;

               ir_expression *const r00F0 = bit_or(r00CE, r00CF);
               ir_expression *const r00F1 = nequal(r00F0, body.constant(0u));
               ir_expression *const r00F2 = expr(ir_unop_b2i, r00F1);
               body.emit(assign(r00D3, expr(ir_unop_i2u, r00F2), 0x01));


            body.instructions = f00E7_parent_instructions;
            body.emit(f00E7);

            /* END IF */


         body.instructions = f00E2_parent_instructions;
         body.emit(f00E2);

         /* END IF */

         body.emit(assign(r00D4, body.constant(0u), 0x01));


      body.instructions = f00D9_parent_instructions;
      body.emit(f00D9);

      /* END IF */


   body.instructions = f00D7_parent_instructions;
   body.emit(f00D7);

   /* END IF */

   body.emit(assign(r00D2, r00D3, 0x01));

   body.emit(assign(r00D1, r00D4, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64ExtraRightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00F3);
   ir_variable *const r00F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00F4);
   ir_variable *const r00F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r00F5);
   ir_variable *const r00F6 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00F6);
   ir_variable *const r00F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F7);
   ir_variable *const r00F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F8);
   ir_variable *const r00F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F9);
   ir_variable *const r00FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
   body.emit(r00FA);
   ir_variable *const r00FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00FB);
   ir_variable *const r00FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00FC);
   ir_variable *const r00FD = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r00FE = neg(r00F6);
   body.emit(assign(r00FD, bit_and(r00FE, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0100 = equal(r00F6, body.constant(int(0)));
   ir_if *f00FF = new(mem_ctx) ir_if(operand(r0100).val);
   exec_list *const f00FF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f00FF->then_instructions;

      body.emit(assign(r00FA, r00F5, 0x01));

      body.emit(assign(r00FB, r00F4, 0x01));

      body.emit(assign(r00FC, r00F3, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f00FF->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0102 = less(r00F6, body.constant(int(32)));
      ir_if *f0101 = new(mem_ctx) ir_if(operand(r0102).val);
      exec_list *const f0101_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0101->then_instructions;

         body.emit(assign(r00FA, lshift(r00F4, r00FD), 0x01));

         ir_expression *const r0103 = lshift(r00F3, r00FD);
         ir_expression *const r0104 = rshift(r00F4, r00F6);
         body.emit(assign(r00FB, bit_or(r0103, r0104), 0x01));

         body.emit(assign(r00FC, rshift(r00F3, r00F6), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0101->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0106 = equal(r00F6, body.constant(int(32)));
         ir_if *f0105 = new(mem_ctx) ir_if(operand(r0106).val);
         exec_list *const f0105_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0105->then_instructions;

            body.emit(assign(r00FA, r00F4, 0x01));

            body.emit(assign(r00FB, r00F3, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0105->else_instructions;

            body.emit(assign(r00F5, bit_or(r00F5, r00F4), 0x01));

            /* IF CONDITION */
            ir_expression *const r0108 = less(r00F6, body.constant(int(64)));
            ir_if *f0107 = new(mem_ctx) ir_if(operand(r0108).val);
            exec_list *const f0107_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0107->then_instructions;

               body.emit(assign(r00FA, lshift(r00F3, r00FD), 0x01));

               ir_expression *const r0109 = bit_and(r00F6, body.constant(int(31)));
               body.emit(assign(r00FB, rshift(r00F3, r0109), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0107->else_instructions;

               ir_variable *const r010A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r010C = equal(r00F6, body.constant(int(64)));
               ir_if *f010B = new(mem_ctx) ir_if(operand(r010C).val);
               exec_list *const f010B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f010B->then_instructions;

                  body.emit(assign(r010A, r00F3, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f010B->else_instructions;

                  ir_expression *const r010D = nequal(r00F3, body.constant(0u));
                  ir_expression *const r010E = expr(ir_unop_b2i, r010D);
                  body.emit(assign(r010A, expr(ir_unop_i2u, r010E), 0x01));


               body.instructions = f010B_parent_instructions;
               body.emit(f010B);

               /* END IF */

               body.emit(assign(r00FA, r010A, 0x01));

               body.emit(assign(r00FB, body.constant(0u), 0x01));


            body.instructions = f0107_parent_instructions;
            body.emit(f0107);

            /* END IF */


         body.instructions = f0105_parent_instructions;
         body.emit(f0105);

         /* END IF */

         body.emit(assign(r00FC, body.constant(0u), 0x01));


      body.instructions = f0101_parent_instructions;
      body.emit(f0101);

      /* END IF */

      ir_expression *const r010F = nequal(r00F5, body.constant(0u));
      ir_expression *const r0110 = expr(ir_unop_b2i, r010F);
      ir_expression *const r0111 = expr(ir_unop_i2u, r0110);
      body.emit(assign(r00FA, bit_or(r00FA, r0111), 0x01));


   body.instructions = f00FF_parent_instructions;
   body.emit(f00FF);

   /* END IF */

   body.emit(assign(r00F9, r00FA, 0x01));

   body.emit(assign(r00F8, r00FB, 0x01));

   body.emit(assign(r00F7, r00FC, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shortShift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0112 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0112);
   ir_variable *const r0113 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0113);
   ir_variable *const r0114 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r0114);
   ir_variable *const r0115 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0115);
   ir_variable *const r0116 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0116);
   body.emit(assign(r0116, lshift(r0113, r0114), 0x01));

   ir_variable *const r0117 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r0119 = equal(r0114, body.constant(int(0)));
   ir_if *f0118 = new(mem_ctx) ir_if(operand(r0119).val);
   exec_list *const f0118_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0118->then_instructions;

      body.emit(assign(r0117, r0112, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0118->else_instructions;

      ir_expression *const r011A = lshift(r0112, r0114);
      ir_expression *const r011B = neg(r0114);
      ir_expression *const r011C = bit_and(r011B, body.constant(int(31)));
      ir_expression *const r011D = rshift(r0113, r011C);
      body.emit(assign(r0117, bit_or(r011A, r011D), 0x01));


   body.instructions = f0118_parent_instructions;
   body.emit(f0118);

   /* END IF */

   body.emit(assign(r0115, r0117, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r011E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r011E);
   ir_variable *const r011F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r011F);
   ir_variable *const r0120 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0120);
   ir_variable *const r0121 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0121);
   ir_variable *const r0122 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
   body.emit(r0122);
   ir_expression *const r0123 = lshift(r011E, body.constant(int(31)));
   ir_expression *const r0124 = expr(ir_unop_i2u, r011F);
   ir_expression *const r0125 = lshift(r0124, body.constant(int(20)));
   ir_expression *const r0126 = add(r0123, r0125);
   body.emit(assign(r0122, add(r0126, r0120), 0x02));

   body.emit(assign(r0122, r0121, 0x01));

   body.emit(ret(r0122));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0127 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0127);
   ir_variable *const r0128 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0128);
   ir_variable *const r0129 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0129);
   ir_variable *const r012A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r012A);
   ir_variable *const r012B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_function_in);
   sig_parameters.push_tail(r012B);
   ir_variable *const r012C = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r012C, body.constant(true), 0x01));

   ir_variable *const r012D = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r012E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r012E);
   ir_expression *const r012F = expr(ir_unop_u2i, r012B);
   body.emit(assign(r012E, less(r012F, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0131 = lequal(body.constant(int(2045)), r0128);
   ir_if *f0130 = new(mem_ctx) ir_if(operand(r0131).val);
   exec_list *const f0130_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0130->then_instructions;

      ir_variable *const r0132 = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r0134 = less(body.constant(int(2045)), r0128);
      ir_if *f0133 = new(mem_ctx) ir_if(operand(r0134).val);
      exec_list *const f0133_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0133->then_instructions;

         body.emit(assign(r0132, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0133->else_instructions;

         ir_variable *const r0135 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r0137 = equal(r0128, body.constant(int(2045)));
         ir_if *f0136 = new(mem_ctx) ir_if(operand(r0137).val);
         exec_list *const f0136_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0136->then_instructions;

            ir_expression *const r0138 = equal(body.constant(2097151u), r0129);
            ir_expression *const r0139 = equal(body.constant(4294967295u), r012A);
            body.emit(assign(r0135, logic_and(r0138, r0139), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0136->else_instructions;

            body.emit(assign(r0135, body.constant(false), 0x01));


         body.instructions = f0136_parent_instructions;
         body.emit(f0136);

         /* END IF */

         body.emit(assign(r0132, logic_and(r0135, r012E), 0x01));


      body.instructions = f0133_parent_instructions;
      body.emit(f0133);

      /* END IF */

      /* IF CONDITION */
      ir_if *f013A = new(mem_ctx) ir_if(operand(r0132).val);
      exec_list *const f013A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f013A->then_instructions;

         ir_variable *const r013B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r013B);
         ir_expression *const r013C = lshift(r0127, body.constant(int(31)));
         body.emit(assign(r013B, add(r013C, body.constant(2146435072u)), 0x02));

         body.emit(assign(r013B, body.constant(0u), 0x01));

         body.emit(assign(r012D, r013B, 0x03));

         body.emit(assign(r012C, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f013A->else_instructions;

         /* IF CONDITION */
         ir_expression *const r013E = less(r0128, body.constant(int(0)));
         ir_if *f013D = new(mem_ctx) ir_if(operand(r013E).val);
         exec_list *const f013D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f013D->then_instructions;

            ir_variable *const r013F = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r013F, r012B, 0x01));

            ir_variable *const r0140 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r0140, neg(r0128), 0x01));

            ir_variable *const r0141 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0141);
            ir_variable *const r0142 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0142);
            ir_variable *const r0143 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0143);
            ir_variable *const r0144 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0145 = neg(r0140);
            body.emit(assign(r0144, bit_and(r0145, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0147 = equal(r0140, body.constant(int(0)));
            ir_if *f0146 = new(mem_ctx) ir_if(operand(r0147).val);
            exec_list *const f0146_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0146->then_instructions;

               body.emit(assign(r0141, r012B, 0x01));

               body.emit(assign(r0142, r012A, 0x01));

               body.emit(assign(r0143, r0129, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0146->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0149 = less(r0140, body.constant(int(32)));
               ir_if *f0148 = new(mem_ctx) ir_if(operand(r0149).val);
               exec_list *const f0148_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0148->then_instructions;

                  body.emit(assign(r0141, lshift(r012A, r0144), 0x01));

                  ir_expression *const r014A = lshift(r0129, r0144);
                  ir_expression *const r014B = rshift(r012A, r0140);
                  body.emit(assign(r0142, bit_or(r014A, r014B), 0x01));

                  body.emit(assign(r0143, rshift(r0129, r0140), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0148->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r014D = equal(r0140, body.constant(int(32)));
                  ir_if *f014C = new(mem_ctx) ir_if(operand(r014D).val);
                  exec_list *const f014C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f014C->then_instructions;

                     body.emit(assign(r0141, r012A, 0x01));

                     body.emit(assign(r0142, r0129, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f014C->else_instructions;

                     body.emit(assign(r013F, bit_or(r012B, r012A), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r014F = less(r0140, body.constant(int(64)));
                     ir_if *f014E = new(mem_ctx) ir_if(operand(r014F).val);
                     exec_list *const f014E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f014E->then_instructions;

                        body.emit(assign(r0141, lshift(r0129, r0144), 0x01));

                        ir_expression *const r0150 = bit_and(r0140, body.constant(int(31)));
                        body.emit(assign(r0142, rshift(r0129, r0150), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f014E->else_instructions;

                        ir_variable *const r0151 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0153 = equal(r0140, body.constant(int(64)));
                        ir_if *f0152 = new(mem_ctx) ir_if(operand(r0153).val);
                        exec_list *const f0152_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0152->then_instructions;

                           body.emit(assign(r0151, r0129, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0152->else_instructions;

                           ir_expression *const r0154 = nequal(r0129, body.constant(0u));
                           ir_expression *const r0155 = expr(ir_unop_b2i, r0154);
                           body.emit(assign(r0151, expr(ir_unop_i2u, r0155), 0x01));


                        body.instructions = f0152_parent_instructions;
                        body.emit(f0152);

                        /* END IF */

                        body.emit(assign(r0141, r0151, 0x01));

                        body.emit(assign(r0142, body.constant(0u), 0x01));


                     body.instructions = f014E_parent_instructions;
                     body.emit(f014E);

                     /* END IF */


                  body.instructions = f014C_parent_instructions;
                  body.emit(f014C);

                  /* END IF */

                  body.emit(assign(r0143, body.constant(0u), 0x01));


               body.instructions = f0148_parent_instructions;
               body.emit(f0148);

               /* END IF */

               ir_expression *const r0156 = nequal(r013F, body.constant(0u));
               ir_expression *const r0157 = expr(ir_unop_b2i, r0156);
               ir_expression *const r0158 = expr(ir_unop_i2u, r0157);
               body.emit(assign(r0141, bit_or(r0141, r0158), 0x01));


            body.instructions = f0146_parent_instructions;
            body.emit(f0146);

            /* END IF */

            body.emit(assign(r0129, r0143, 0x01));

            body.emit(assign(r012A, r0142, 0x01));

            body.emit(assign(r012B, r0141, 0x01));

            body.emit(assign(r0128, body.constant(int(0)), 0x01));

            body.emit(assign(r012E, less(r0141, body.constant(0u)), 0x01));


         body.instructions = f013D_parent_instructions;
         body.emit(f013D);

         /* END IF */


      body.instructions = f013A_parent_instructions;
      body.emit(f013A);

      /* END IF */


   body.instructions = f0130_parent_instructions;
   body.emit(f0130);

   /* END IF */

   /* IF CONDITION */
   ir_if *f0159 = new(mem_ctx) ir_if(operand(r012C).val);
   exec_list *const f0159_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0159->then_instructions;

      /* IF CONDITION */
      ir_if *f015A = new(mem_ctx) ir_if(operand(r012E).val);
      exec_list *const f015A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f015A->then_instructions;

         ir_variable *const r015B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r015B, add(r012A, body.constant(1u)), 0x01));

         ir_expression *const r015C = less(r015B, r012A);
         ir_expression *const r015D = expr(ir_unop_b2i, r015C);
         ir_expression *const r015E = expr(ir_unop_i2u, r015D);
         body.emit(assign(r0129, add(r0129, r015E), 0x01));

         ir_expression *const r015F = equal(r012B, body.constant(0u));
         ir_expression *const r0160 = expr(ir_unop_b2i, r015F);
         ir_expression *const r0161 = expr(ir_unop_i2u, r0160);
         ir_expression *const r0162 = add(r012B, r0161);
         ir_expression *const r0163 = bit_and(r0162, body.constant(1u));
         ir_expression *const r0164 = expr(ir_unop_bit_not, r0163);
         body.emit(assign(r012A, bit_and(r015B, r0164), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f015A->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0166 = bit_or(r0129, r012A);
         ir_expression *const r0167 = equal(r0166, body.constant(0u));
         ir_if *f0165 = new(mem_ctx) ir_if(operand(r0167).val);
         exec_list *const f0165_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0165->then_instructions;

            body.emit(assign(r0128, body.constant(int(0)), 0x01));


         body.instructions = f0165_parent_instructions;
         body.emit(f0165);

         /* END IF */


      body.instructions = f015A_parent_instructions;
      body.emit(f015A);

      /* END IF */

      ir_variable *const r0168 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r0168);
      ir_expression *const r0169 = lshift(r0127, body.constant(int(31)));
      ir_expression *const r016A = expr(ir_unop_i2u, r0128);
      ir_expression *const r016B = lshift(r016A, body.constant(int(20)));
      ir_expression *const r016C = add(r0169, r016B);
      body.emit(assign(r0168, add(r016C, r0129), 0x02));

      body.emit(assign(r0168, r012A, 0x01));

      body.emit(assign(r012D, r0168, 0x03));

      body.emit(assign(r012C, body.constant(false), 0x01));


   body.instructions = f0159_parent_instructions;
   body.emit(f0159);

   /* END IF */

   body.emit(ret(r012D));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
countLeadingZeros32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r016D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r016D);
   ir_variable *const r016E = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r016F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r016F);
   /* IF CONDITION */
   ir_expression *const r0171 = equal(r016D, body.constant(0u));
   ir_if *f0170 = new(mem_ctx) ir_if(operand(r0171).val);
   exec_list *const f0170_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0170->then_instructions;

      body.emit(assign(r016E, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0170->else_instructions;

      body.emit(assign(r016F, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0173 = bit_and(r016D, body.constant(4294901760u));
      ir_expression *const r0174 = equal(r0173, body.constant(0u));
      ir_if *f0172 = new(mem_ctx) ir_if(operand(r0174).val);
      exec_list *const f0172_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0172->then_instructions;

         body.emit(assign(r016F, body.constant(int(16)), 0x01));

         body.emit(assign(r016D, lshift(r016D, body.constant(int(16))), 0x01));


      body.instructions = f0172_parent_instructions;
      body.emit(f0172);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0176 = bit_and(r016D, body.constant(4278190080u));
      ir_expression *const r0177 = equal(r0176, body.constant(0u));
      ir_if *f0175 = new(mem_ctx) ir_if(operand(r0177).val);
      exec_list *const f0175_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0175->then_instructions;

         body.emit(assign(r016F, add(r016F, body.constant(int(8))), 0x01));

         body.emit(assign(r016D, lshift(r016D, body.constant(int(8))), 0x01));


      body.instructions = f0175_parent_instructions;
      body.emit(f0175);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0179 = bit_and(r016D, body.constant(4026531840u));
      ir_expression *const r017A = equal(r0179, body.constant(0u));
      ir_if *f0178 = new(mem_ctx) ir_if(operand(r017A).val);
      exec_list *const f0178_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0178->then_instructions;

         body.emit(assign(r016F, add(r016F, body.constant(int(4))), 0x01));

         body.emit(assign(r016D, lshift(r016D, body.constant(int(4))), 0x01));


      body.instructions = f0178_parent_instructions;
      body.emit(f0178);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017C = bit_and(r016D, body.constant(3221225472u));
      ir_expression *const r017D = equal(r017C, body.constant(0u));
      ir_if *f017B = new(mem_ctx) ir_if(operand(r017D).val);
      exec_list *const f017B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017B->then_instructions;

         body.emit(assign(r016F, add(r016F, body.constant(int(2))), 0x01));

         body.emit(assign(r016D, lshift(r016D, body.constant(int(2))), 0x01));


      body.instructions = f017B_parent_instructions;
      body.emit(f017B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017F = bit_and(r016D, body.constant(2147483648u));
      ir_expression *const r0180 = equal(r017F, body.constant(0u));
      ir_if *f017E = new(mem_ctx) ir_if(operand(r0180).val);
      exec_list *const f017E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017E->then_instructions;

         body.emit(assign(r016F, add(r016F, body.constant(int(1))), 0x01));


      body.instructions = f017E_parent_instructions;
      body.emit(f017E);

      /* END IF */

      body.emit(assign(r016E, r016F, 0x01));


   body.instructions = f0170_parent_instructions;
   body.emit(f0170);

   /* END IF */

   body.emit(ret(r016E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeRoundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0181 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0181);
   ir_variable *const r0182 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0182);
   ir_variable *const r0183 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0183);
   ir_variable *const r0184 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0184);
   ir_variable *const r0185 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0185);
   ir_variable *const r0186 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0186);
   /* IF CONDITION */
   ir_expression *const r0188 = equal(r0183, body.constant(0u));
   ir_if *f0187 = new(mem_ctx) ir_if(operand(r0188).val);
   exec_list *const f0187_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0187->then_instructions;

      body.emit(assign(r0183, r0184, 0x01));

      body.emit(assign(r0184, body.constant(0u), 0x01));

      body.emit(assign(r0182, add(r0182, body.constant(int(-32))), 0x01));


   body.instructions = f0187_parent_instructions;
   body.emit(f0187);

   /* END IF */

   ir_variable *const r0189 = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r0189, r0183, 0x01));

   ir_variable *const r018A = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r018B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r018B);
   /* IF CONDITION */
   ir_expression *const r018D = equal(r0183, body.constant(0u));
   ir_if *f018C = new(mem_ctx) ir_if(operand(r018D).val);
   exec_list *const f018C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f018C->then_instructions;

      body.emit(assign(r018A, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f018C->else_instructions;

      body.emit(assign(r018B, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r018F = bit_and(r0183, body.constant(4294901760u));
      ir_expression *const r0190 = equal(r018F, body.constant(0u));
      ir_if *f018E = new(mem_ctx) ir_if(operand(r0190).val);
      exec_list *const f018E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f018E->then_instructions;

         body.emit(assign(r018B, body.constant(int(16)), 0x01));

         body.emit(assign(r0189, lshift(r0183, body.constant(int(16))), 0x01));


      body.instructions = f018E_parent_instructions;
      body.emit(f018E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0192 = bit_and(r0189, body.constant(4278190080u));
      ir_expression *const r0193 = equal(r0192, body.constant(0u));
      ir_if *f0191 = new(mem_ctx) ir_if(operand(r0193).val);
      exec_list *const f0191_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0191->then_instructions;

         body.emit(assign(r018B, add(r018B, body.constant(int(8))), 0x01));

         body.emit(assign(r0189, lshift(r0189, body.constant(int(8))), 0x01));


      body.instructions = f0191_parent_instructions;
      body.emit(f0191);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0195 = bit_and(r0189, body.constant(4026531840u));
      ir_expression *const r0196 = equal(r0195, body.constant(0u));
      ir_if *f0194 = new(mem_ctx) ir_if(operand(r0196).val);
      exec_list *const f0194_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0194->then_instructions;

         body.emit(assign(r018B, add(r018B, body.constant(int(4))), 0x01));

         body.emit(assign(r0189, lshift(r0189, body.constant(int(4))), 0x01));


      body.instructions = f0194_parent_instructions;
      body.emit(f0194);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0198 = bit_and(r0189, body.constant(3221225472u));
      ir_expression *const r0199 = equal(r0198, body.constant(0u));
      ir_if *f0197 = new(mem_ctx) ir_if(operand(r0199).val);
      exec_list *const f0197_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0197->then_instructions;

         body.emit(assign(r018B, add(r018B, body.constant(int(2))), 0x01));

         body.emit(assign(r0189, lshift(r0189, body.constant(int(2))), 0x01));


      body.instructions = f0197_parent_instructions;
      body.emit(f0197);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019B = bit_and(r0189, body.constant(2147483648u));
      ir_expression *const r019C = equal(r019B, body.constant(0u));
      ir_if *f019A = new(mem_ctx) ir_if(operand(r019C).val);
      exec_list *const f019A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f019A->then_instructions;

         body.emit(assign(r018B, add(r018B, body.constant(int(1))), 0x01));


      body.instructions = f019A_parent_instructions;
      body.emit(f019A);

      /* END IF */

      body.emit(assign(r018A, r018B, 0x01));


   body.instructions = f018C_parent_instructions;
   body.emit(f018C);

   /* END IF */

   body.emit(assign(r0186, add(r018A, body.constant(int(-11))), 0x01));

   /* IF CONDITION */
   ir_expression *const r019E = lequal(body.constant(int(0)), r0186);
   ir_if *f019D = new(mem_ctx) ir_if(operand(r019E).val);
   exec_list *const f019D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f019D->then_instructions;

      body.emit(assign(r0185, body.constant(0u), 0x01));

      ir_variable *const r019F = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r019F, lshift(r0184, r0186), 0x01));

      ir_variable *const r01A0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r01A2 = equal(r0186, body.constant(int(0)));
      ir_if *f01A1 = new(mem_ctx) ir_if(operand(r01A2).val);
      exec_list *const f01A1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01A1->then_instructions;

         body.emit(assign(r01A0, r0183, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01A1->else_instructions;

         ir_expression *const r01A3 = lshift(r0183, r0186);
         ir_expression *const r01A4 = neg(r0186);
         ir_expression *const r01A5 = bit_and(r01A4, body.constant(int(31)));
         ir_expression *const r01A6 = rshift(r0184, r01A5);
         body.emit(assign(r01A0, bit_or(r01A3, r01A6), 0x01));


      body.instructions = f01A1_parent_instructions;
      body.emit(f01A1);

      /* END IF */

      body.emit(assign(r0183, r01A0, 0x01));

      body.emit(assign(r0184, r019F, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f019D->else_instructions;

      ir_variable *const r01A7 = body.make_temp(glsl_type::uint_type, "a2");
      body.emit(assign(r01A7, body.constant(0u), 0x01));

      ir_variable *const r01A8 = body.make_temp(glsl_type::int_type, "count");
      body.emit(assign(r01A8, neg(r0186), 0x01));

      ir_variable *const r01A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
      body.emit(r01A9);
      ir_variable *const r01AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r01AA);
      ir_variable *const r01AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r01AB);
      ir_variable *const r01AC = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r01AD = neg(r01A8);
      body.emit(assign(r01AC, bit_and(r01AD, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r01AF = equal(r01A8, body.constant(int(0)));
      ir_if *f01AE = new(mem_ctx) ir_if(operand(r01AF).val);
      exec_list *const f01AE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01AE->then_instructions;

         body.emit(assign(r01A9, r01A7, 0x01));

         body.emit(assign(r01AA, r0184, 0x01));

         body.emit(assign(r01AB, r0183, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01AE->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01B1 = less(r01A8, body.constant(int(32)));
         ir_if *f01B0 = new(mem_ctx) ir_if(operand(r01B1).val);
         exec_list *const f01B0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01B0->then_instructions;

            body.emit(assign(r01A9, lshift(r0184, r01AC), 0x01));

            ir_expression *const r01B2 = lshift(r0183, r01AC);
            ir_expression *const r01B3 = rshift(r0184, r01A8);
            body.emit(assign(r01AA, bit_or(r01B2, r01B3), 0x01));

            body.emit(assign(r01AB, rshift(r0183, r01A8), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01B0->else_instructions;

            /* IF CONDITION */
            ir_expression *const r01B5 = equal(r01A8, body.constant(int(32)));
            ir_if *f01B4 = new(mem_ctx) ir_if(operand(r01B5).val);
            exec_list *const f01B4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01B4->then_instructions;

               body.emit(assign(r01A9, r0184, 0x01));

               body.emit(assign(r01AA, r0183, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01B4->else_instructions;

               body.emit(assign(r01A7, bit_or(body.constant(0u), r0184), 0x01));

               /* IF CONDITION */
               ir_expression *const r01B7 = less(r01A8, body.constant(int(64)));
               ir_if *f01B6 = new(mem_ctx) ir_if(operand(r01B7).val);
               exec_list *const f01B6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01B6->then_instructions;

                  body.emit(assign(r01A9, lshift(r0183, r01AC), 0x01));

                  ir_expression *const r01B8 = bit_and(r01A8, body.constant(int(31)));
                  body.emit(assign(r01AA, rshift(r0183, r01B8), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01B6->else_instructions;

                  ir_variable *const r01B9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r01BB = equal(r01A8, body.constant(int(64)));
                  ir_if *f01BA = new(mem_ctx) ir_if(operand(r01BB).val);
                  exec_list *const f01BA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01BA->then_instructions;

                     body.emit(assign(r01B9, r0183, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01BA->else_instructions;

                     ir_expression *const r01BC = nequal(r0183, body.constant(0u));
                     ir_expression *const r01BD = expr(ir_unop_b2i, r01BC);
                     body.emit(assign(r01B9, expr(ir_unop_i2u, r01BD), 0x01));


                  body.instructions = f01BA_parent_instructions;
                  body.emit(f01BA);

                  /* END IF */

                  body.emit(assign(r01A9, r01B9, 0x01));

                  body.emit(assign(r01AA, body.constant(0u), 0x01));


               body.instructions = f01B6_parent_instructions;
               body.emit(f01B6);

               /* END IF */


            body.instructions = f01B4_parent_instructions;
            body.emit(f01B4);

            /* END IF */

            body.emit(assign(r01AB, body.constant(0u), 0x01));


         body.instructions = f01B0_parent_instructions;
         body.emit(f01B0);

         /* END IF */

         ir_expression *const r01BE = nequal(r01A7, body.constant(0u));
         ir_expression *const r01BF = expr(ir_unop_b2i, r01BE);
         ir_expression *const r01C0 = expr(ir_unop_i2u, r01BF);
         body.emit(assign(r01A9, bit_or(r01A9, r01C0), 0x01));


      body.instructions = f01AE_parent_instructions;
      body.emit(f01AE);

      /* END IF */

      body.emit(assign(r0183, r01AB, 0x01));

      body.emit(assign(r0184, r01AA, 0x01));

      body.emit(assign(r0185, r01A9, 0x01));


   body.instructions = f019D_parent_instructions;
   body.emit(f019D);

   /* END IF */

   body.emit(assign(r0182, sub(r0182, r0186), 0x01));

   ir_variable *const r01C1 = body.make_temp(glsl_type::int_type, "zExp");
   body.emit(assign(r01C1, r0182, 0x01));

   ir_variable *const r01C2 = body.make_temp(glsl_type::uint_type, "zFrac0");
   body.emit(assign(r01C2, r0183, 0x01));

   ir_variable *const r01C3 = body.make_temp(glsl_type::uint_type, "zFrac1");
   body.emit(assign(r01C3, r0184, 0x01));

   ir_variable *const r01C4 = body.make_temp(glsl_type::uint_type, "zFrac2");
   body.emit(assign(r01C4, r0185, 0x01));

   ir_variable *const r01C5 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r01C5, body.constant(true), 0x01));

   ir_variable *const r01C6 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r01C7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r01C7);
   ir_expression *const r01C8 = expr(ir_unop_u2i, r0185);
   body.emit(assign(r01C7, less(r01C8, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01CA = lequal(body.constant(int(2045)), r0182);
   ir_if *f01C9 = new(mem_ctx) ir_if(operand(r01CA).val);
   exec_list *const f01C9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01C9->then_instructions;

      ir_variable *const r01CB = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r01CD = less(body.constant(int(2045)), r0182);
      ir_if *f01CC = new(mem_ctx) ir_if(operand(r01CD).val);
      exec_list *const f01CC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01CC->then_instructions;

         body.emit(assign(r01CB, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01CC->else_instructions;

         ir_variable *const r01CE = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r01D0 = equal(r0182, body.constant(int(2045)));
         ir_if *f01CF = new(mem_ctx) ir_if(operand(r01D0).val);
         exec_list *const f01CF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01CF->then_instructions;

            ir_expression *const r01D1 = equal(body.constant(2097151u), r0183);
            ir_expression *const r01D2 = equal(body.constant(4294967295u), r0184);
            body.emit(assign(r01CE, logic_and(r01D1, r01D2), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01CF->else_instructions;

            body.emit(assign(r01CE, body.constant(false), 0x01));


         body.instructions = f01CF_parent_instructions;
         body.emit(f01CF);

         /* END IF */

         body.emit(assign(r01CB, logic_and(r01CE, r01C7), 0x01));


      body.instructions = f01CC_parent_instructions;
      body.emit(f01CC);

      /* END IF */

      /* IF CONDITION */
      ir_if *f01D3 = new(mem_ctx) ir_if(operand(r01CB).val);
      exec_list *const f01D3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01D3->then_instructions;

         ir_variable *const r01D4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r01D4);
         ir_expression *const r01D5 = lshift(r0181, body.constant(int(31)));
         body.emit(assign(r01D4, add(r01D5, body.constant(2146435072u)), 0x02));

         body.emit(assign(r01D4, body.constant(0u), 0x01));

         body.emit(assign(r01C6, r01D4, 0x03));

         body.emit(assign(r01C5, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01D3->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01D7 = less(r0182, body.constant(int(0)));
         ir_if *f01D6 = new(mem_ctx) ir_if(operand(r01D7).val);
         exec_list *const f01D6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D6->then_instructions;

            ir_variable *const r01D8 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r01D8, r0185, 0x01));

            ir_variable *const r01D9 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r01D9, neg(r0182), 0x01));

            ir_variable *const r01DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r01DA);
            ir_variable *const r01DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r01DB);
            ir_variable *const r01DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r01DC);
            ir_variable *const r01DD = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r01DE = neg(r01D9);
            body.emit(assign(r01DD, bit_and(r01DE, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r01E0 = equal(r01D9, body.constant(int(0)));
            ir_if *f01DF = new(mem_ctx) ir_if(operand(r01E0).val);
            exec_list *const f01DF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01DF->then_instructions;

               body.emit(assign(r01DA, r0185, 0x01));

               body.emit(assign(r01DB, r0184, 0x01));

               body.emit(assign(r01DC, r0183, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01DF->else_instructions;

               /* IF CONDITION */
               ir_expression *const r01E2 = less(r01D9, body.constant(int(32)));
               ir_if *f01E1 = new(mem_ctx) ir_if(operand(r01E2).val);
               exec_list *const f01E1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01E1->then_instructions;

                  body.emit(assign(r01DA, lshift(r0184, r01DD), 0x01));

                  ir_expression *const r01E3 = lshift(r0183, r01DD);
                  ir_expression *const r01E4 = rshift(r0184, r01D9);
                  body.emit(assign(r01DB, bit_or(r01E3, r01E4), 0x01));

                  body.emit(assign(r01DC, rshift(r0183, r01D9), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01E1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r01E6 = equal(r01D9, body.constant(int(32)));
                  ir_if *f01E5 = new(mem_ctx) ir_if(operand(r01E6).val);
                  exec_list *const f01E5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01E5->then_instructions;

                     body.emit(assign(r01DA, r0184, 0x01));

                     body.emit(assign(r01DB, r0183, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01E5->else_instructions;

                     body.emit(assign(r01D8, bit_or(r0185, r0184), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r01E8 = less(r01D9, body.constant(int(64)));
                     ir_if *f01E7 = new(mem_ctx) ir_if(operand(r01E8).val);
                     exec_list *const f01E7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f01E7->then_instructions;

                        body.emit(assign(r01DA, lshift(r0183, r01DD), 0x01));

                        ir_expression *const r01E9 = bit_and(r01D9, body.constant(int(31)));
                        body.emit(assign(r01DB, rshift(r0183, r01E9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f01E7->else_instructions;

                        ir_variable *const r01EA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r01EC = equal(r01D9, body.constant(int(64)));
                        ir_if *f01EB = new(mem_ctx) ir_if(operand(r01EC).val);
                        exec_list *const f01EB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f01EB->then_instructions;

                           body.emit(assign(r01EA, r0183, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f01EB->else_instructions;

                           ir_expression *const r01ED = nequal(r0183, body.constant(0u));
                           ir_expression *const r01EE = expr(ir_unop_b2i, r01ED);
                           body.emit(assign(r01EA, expr(ir_unop_i2u, r01EE), 0x01));


                        body.instructions = f01EB_parent_instructions;
                        body.emit(f01EB);

                        /* END IF */

                        body.emit(assign(r01DA, r01EA, 0x01));

                        body.emit(assign(r01DB, body.constant(0u), 0x01));


                     body.instructions = f01E7_parent_instructions;
                     body.emit(f01E7);

                     /* END IF */


                  body.instructions = f01E5_parent_instructions;
                  body.emit(f01E5);

                  /* END IF */

                  body.emit(assign(r01DC, body.constant(0u), 0x01));


               body.instructions = f01E1_parent_instructions;
               body.emit(f01E1);

               /* END IF */

               ir_expression *const r01EF = nequal(r01D8, body.constant(0u));
               ir_expression *const r01F0 = expr(ir_unop_b2i, r01EF);
               ir_expression *const r01F1 = expr(ir_unop_i2u, r01F0);
               body.emit(assign(r01DA, bit_or(r01DA, r01F1), 0x01));


            body.instructions = f01DF_parent_instructions;
            body.emit(f01DF);

            /* END IF */

            body.emit(assign(r01C2, r01DC, 0x01));

            body.emit(assign(r01C3, r01DB, 0x01));

            body.emit(assign(r01C4, r01DA, 0x01));

            body.emit(assign(r01C1, body.constant(int(0)), 0x01));

            body.emit(assign(r01C7, less(r01DA, body.constant(0u)), 0x01));


         body.instructions = f01D6_parent_instructions;
         body.emit(f01D6);

         /* END IF */


      body.instructions = f01D3_parent_instructions;
      body.emit(f01D3);

      /* END IF */


   body.instructions = f01C9_parent_instructions;
   body.emit(f01C9);

   /* END IF */

   /* IF CONDITION */
   ir_if *f01F2 = new(mem_ctx) ir_if(operand(r01C5).val);
   exec_list *const f01F2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01F2->then_instructions;

      /* IF CONDITION */
      ir_if *f01F3 = new(mem_ctx) ir_if(operand(r01C7).val);
      exec_list *const f01F3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01F3->then_instructions;

         ir_variable *const r01F4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r01F4, add(r01C3, body.constant(1u)), 0x01));

         ir_expression *const r01F5 = less(r01F4, r01C3);
         ir_expression *const r01F6 = expr(ir_unop_b2i, r01F5);
         ir_expression *const r01F7 = expr(ir_unop_i2u, r01F6);
         body.emit(assign(r01C2, add(r01C2, r01F7), 0x01));

         ir_expression *const r01F8 = equal(r01C4, body.constant(0u));
         ir_expression *const r01F9 = expr(ir_unop_b2i, r01F8);
         ir_expression *const r01FA = expr(ir_unop_i2u, r01F9);
         ir_expression *const r01FB = add(r01C4, r01FA);
         ir_expression *const r01FC = bit_and(r01FB, body.constant(1u));
         ir_expression *const r01FD = expr(ir_unop_bit_not, r01FC);
         body.emit(assign(r01C3, bit_and(r01F4, r01FD), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01F3->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01FF = bit_or(r01C2, r01C3);
         ir_expression *const r0200 = equal(r01FF, body.constant(0u));
         ir_if *f01FE = new(mem_ctx) ir_if(operand(r0200).val);
         exec_list *const f01FE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01FE->then_instructions;

            body.emit(assign(r01C1, body.constant(int(0)), 0x01));


         body.instructions = f01FE_parent_instructions;
         body.emit(f01FE);

         /* END IF */


      body.instructions = f01F3_parent_instructions;
      body.emit(f01F3);

      /* END IF */

      ir_variable *const r0201 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r0201);
      ir_expression *const r0202 = lshift(r0181, body.constant(int(31)));
      ir_expression *const r0203 = expr(ir_unop_i2u, r01C1);
      ir_expression *const r0204 = lshift(r0203, body.constant(int(20)));
      ir_expression *const r0205 = add(r0202, r0204);
      body.emit(assign(r0201, add(r0205, r01C2), 0x02));

      body.emit(assign(r0201, r01C3, 0x01));

      body.emit(assign(r01C6, r0201, 0x03));

      body.emit(assign(r01C5, body.constant(false), 0x01));


   body.instructions = f01F2_parent_instructions;
   body.emit(f01F2);

   /* END IF */

   body.emit(ret(r01C6));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
propagateFloat64NaN(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0206 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0206);
   ir_variable *const r0207 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0207);
   ir_variable *const r0208 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0209 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r020A = lshift(swizzle_y(r0206), body.constant(int(1)));
   ir_expression *const r020B = lequal(body.constant(4292870144u), r020A);
   ir_expression *const r020C = nequal(swizzle_x(r0206), body.constant(0u));
   ir_expression *const r020D = bit_and(swizzle_y(r0206), body.constant(1048575u));
   ir_expression *const r020E = nequal(r020D, body.constant(0u));
   ir_expression *const r020F = logic_or(r020C, r020E);
   body.emit(assign(r0209, logic_and(r020B, r020F), 0x01));

   ir_variable *const r0210 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
   ir_expression *const r0211 = rshift(swizzle_y(r0206), body.constant(int(19)));
   ir_expression *const r0212 = bit_and(r0211, body.constant(4095u));
   ir_expression *const r0213 = equal(r0212, body.constant(4094u));
   ir_expression *const r0214 = nequal(swizzle_x(r0206), body.constant(0u));
   ir_expression *const r0215 = bit_and(swizzle_y(r0206), body.constant(524287u));
   ir_expression *const r0216 = nequal(r0215, body.constant(0u));
   ir_expression *const r0217 = logic_or(r0214, r0216);
   body.emit(assign(r0210, logic_and(r0213, r0217), 0x01));

   ir_variable *const r0218 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r0219 = lshift(swizzle_y(r0207), body.constant(int(1)));
   ir_expression *const r021A = lequal(body.constant(4292870144u), r0219);
   ir_expression *const r021B = nequal(swizzle_x(r0207), body.constant(0u));
   ir_expression *const r021C = bit_and(swizzle_y(r0207), body.constant(1048575u));
   ir_expression *const r021D = nequal(r021C, body.constant(0u));
   ir_expression *const r021E = logic_or(r021B, r021D);
   body.emit(assign(r0218, logic_and(r021A, r021E), 0x01));

   body.emit(assign(r0206, bit_or(swizzle_y(r0206), body.constant(524288u)), 0x02));

   body.emit(assign(r0207, bit_or(swizzle_y(r0207), body.constant(524288u)), 0x02));

   /* IF CONDITION */
   ir_if *f021F = new(mem_ctx) ir_if(operand(r0209).val);
   exec_list *const f021F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f021F->then_instructions;

      ir_variable *const r0220 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r0222 = logic_and(r0210, r0218);
      ir_if *f0221 = new(mem_ctx) ir_if(operand(r0222).val);
      exec_list *const f0221_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0221->then_instructions;

         body.emit(assign(r0220, r0207, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0221->else_instructions;

         body.emit(assign(r0220, r0206, 0x03));


      body.instructions = f0221_parent_instructions;
      body.emit(f0221);

      /* END IF */

      body.emit(assign(r0208, r0220, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f021F->else_instructions;

      body.emit(assign(r0208, r0207, 0x03));


   body.instructions = f021F_parent_instructions;
   body.emit(f021F);

   /* END IF */

   body.emit(ret(r0208));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
addFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0223 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0223);
   ir_variable *const r0224 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0224);
   ir_variable *const r0225 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0225);
   ir_variable *const r0226 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r0226, body.constant(true), 0x01));

   ir_variable *const r0227 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0228 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r0228);
   ir_variable *const r0229 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r0229);
   ir_variable *const r022A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r022A);
   ir_variable *const r022B = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r022B);
   ir_variable *const r022C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r022C);
   ir_variable *const r022D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r022D);
   body.emit(assign(r022D, body.constant(0u), 0x01));

   body.emit(assign(r022C, body.constant(0u), 0x01));

   ir_variable *const r022E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r022E);
   body.emit(assign(r022E, bit_and(swizzle_y(r0223), body.constant(1048575u)), 0x02));

   body.emit(assign(r022E, swizzle_x(r0223), 0x01));

   body.emit(assign(r022A, r022E, 0x03));

   ir_variable *const r022F = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0230 = rshift(swizzle_y(r0223), body.constant(int(20)));
   ir_expression *const r0231 = bit_and(r0230, body.constant(2047u));
   body.emit(assign(r022F, expr(ir_unop_u2i, r0231), 0x01));

   ir_variable *const r0232 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0232);
   body.emit(assign(r0232, bit_and(swizzle_y(r0224), body.constant(1048575u)), 0x02));

   body.emit(assign(r0232, swizzle_x(r0224), 0x01));

   body.emit(assign(r0229, r0232, 0x03));

   ir_variable *const r0233 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0234 = rshift(swizzle_y(r0224), body.constant(int(20)));
   ir_expression *const r0235 = bit_and(r0234, body.constant(2047u));
   body.emit(assign(r0233, expr(ir_unop_u2i, r0235), 0x01));

   ir_variable *const r0236 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r0236, sub(r022F, r0233), 0x01));

   body.emit(assign(r0228, r0236, 0x01));

   /* IF CONDITION */
   ir_expression *const r0238 = less(body.constant(int(0)), r0236);
   ir_if *f0237 = new(mem_ctx) ir_if(operand(r0238).val);
   exec_list *const f0237_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0237->then_instructions;

      /* IF CONDITION */
      ir_expression *const r023A = equal(r022F, body.constant(int(2047)));
      ir_if *f0239 = new(mem_ctx) ir_if(operand(r023A).val);
      exec_list *const f0239_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0239->then_instructions;

         /* IF CONDITION */
         ir_expression *const r023C = bit_or(swizzle_y(r022E), swizzle_x(r0223));
         ir_expression *const r023D = nequal(r023C, body.constant(0u));
         ir_if *f023B = new(mem_ctx) ir_if(operand(r023D).val);
         exec_list *const f023B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f023B->then_instructions;

            ir_variable *const r023E = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r023E, swizzle_x(r0223), 0x01));

            ir_variable *const r023F = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r023F, swizzle_x(r0224), 0x01));

            ir_variable *const r0240 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0241 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r0242 = rshift(swizzle_y(r0223), body.constant(int(19)));
            ir_expression *const r0243 = bit_and(r0242, body.constant(4095u));
            ir_expression *const r0244 = equal(r0243, body.constant(4094u));
            ir_expression *const r0245 = nequal(swizzle_x(r0223), body.constant(0u));
            ir_expression *const r0246 = bit_and(swizzle_y(r0223), body.constant(524287u));
            ir_expression *const r0247 = nequal(r0246, body.constant(0u));
            ir_expression *const r0248 = logic_or(r0245, r0247);
            body.emit(assign(r0241, logic_and(r0244, r0248), 0x01));

            ir_variable *const r0249 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r024A = lshift(swizzle_y(r0224), body.constant(int(1)));
            ir_expression *const r024B = lequal(body.constant(4292870144u), r024A);
            ir_expression *const r024C = nequal(swizzle_x(r0224), body.constant(0u));
            ir_expression *const r024D = bit_and(swizzle_y(r0224), body.constant(1048575u));
            ir_expression *const r024E = nequal(r024D, body.constant(0u));
            ir_expression *const r024F = logic_or(r024C, r024E);
            body.emit(assign(r0249, logic_and(r024B, r024F), 0x01));

            body.emit(assign(r023E, bit_or(swizzle_y(r0223), body.constant(524288u)), 0x02));

            body.emit(assign(r023F, bit_or(swizzle_y(r0224), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0251 = lshift(swizzle_y(r0223), body.constant(int(1)));
            ir_expression *const r0252 = lequal(body.constant(4292870144u), r0251);
            ir_expression *const r0253 = nequal(swizzle_x(r0223), body.constant(0u));
            ir_expression *const r0254 = bit_and(swizzle_y(r0223), body.constant(1048575u));
            ir_expression *const r0255 = nequal(r0254, body.constant(0u));
            ir_expression *const r0256 = logic_or(r0253, r0255);
            ir_expression *const r0257 = logic_and(r0252, r0256);
            ir_if *f0250 = new(mem_ctx) ir_if(operand(r0257).val);
            exec_list *const f0250_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0250->then_instructions;

               ir_variable *const r0258 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r025A = logic_and(r0241, r0249);
               ir_if *f0259 = new(mem_ctx) ir_if(operand(r025A).val);
               exec_list *const f0259_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0259->then_instructions;

                  body.emit(assign(r0258, r023F, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0259->else_instructions;

                  body.emit(assign(r0258, r023E, 0x03));


               body.instructions = f0259_parent_instructions;
               body.emit(f0259);

               /* END IF */

               body.emit(assign(r0240, r0258, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0250->else_instructions;

               body.emit(assign(r0240, r023F, 0x03));


            body.instructions = f0250_parent_instructions;
            body.emit(f0250);

            /* END IF */

            body.emit(assign(r0227, r0240, 0x03));

            body.emit(assign(r0226, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f023B->else_instructions;

            body.emit(assign(r0227, r0223, 0x03));

            body.emit(assign(r0226, body.constant(false), 0x01));


         body.instructions = f023B_parent_instructions;
         body.emit(f023B);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0239->else_instructions;

         /* IF CONDITION */
         ir_expression *const r025C = equal(r0233, body.constant(int(0)));
         ir_if *f025B = new(mem_ctx) ir_if(operand(r025C).val);
         exec_list *const f025B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f025B->then_instructions;

            body.emit(assign(r0228, add(r0236, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f025B->else_instructions;

            body.emit(assign(r0229, bit_or(swizzle_y(r0232), body.constant(1048576u)), 0x02));


         body.instructions = f025B_parent_instructions;
         body.emit(f025B);

         /* END IF */

         ir_variable *const r025D = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r025D, swizzle_y(r0229), 0x01));

         ir_variable *const r025E = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r025E, swizzle_x(r0229), 0x01));

         ir_variable *const r025F = body.make_temp(glsl_type::uint_type, "a2");
         body.emit(assign(r025F, body.constant(0u), 0x01));

         ir_variable *const r0260 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0260);
         ir_variable *const r0261 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0261);
         ir_variable *const r0262 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0262);
         ir_variable *const r0263 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0264 = neg(r0228);
         body.emit(assign(r0263, bit_and(r0264, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0266 = equal(r0228, body.constant(int(0)));
         ir_if *f0265 = new(mem_ctx) ir_if(operand(r0266).val);
         exec_list *const f0265_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0265->then_instructions;

            body.emit(assign(r0260, r025F, 0x01));

            body.emit(assign(r0261, r025E, 0x01));

            body.emit(assign(r0262, r025D, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0265->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0268 = less(r0228, body.constant(int(32)));
            ir_if *f0267 = new(mem_ctx) ir_if(operand(r0268).val);
            exec_list *const f0267_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0267->then_instructions;

               body.emit(assign(r0260, lshift(swizzle_x(r0232), r0263), 0x01));

               ir_expression *const r0269 = lshift(swizzle_y(r0229), r0263);
               ir_expression *const r026A = rshift(swizzle_x(r0232), r0228);
               body.emit(assign(r0261, bit_or(r0269, r026A), 0x01));

               body.emit(assign(r0262, rshift(swizzle_y(r0229), r0228), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0267->else_instructions;

               /* IF CONDITION */
               ir_expression *const r026C = equal(r0228, body.constant(int(32)));
               ir_if *f026B = new(mem_ctx) ir_if(operand(r026C).val);
               exec_list *const f026B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f026B->then_instructions;

                  body.emit(assign(r0260, r025E, 0x01));

                  body.emit(assign(r0261, r025D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f026B->else_instructions;

                  body.emit(assign(r025F, bit_or(body.constant(0u), swizzle_x(r0232)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r026E = less(r0228, body.constant(int(64)));
                  ir_if *f026D = new(mem_ctx) ir_if(operand(r026E).val);
                  exec_list *const f026D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f026D->then_instructions;

                     body.emit(assign(r0260, lshift(swizzle_y(r0229), r0263), 0x01));

                     ir_expression *const r026F = bit_and(r0228, body.constant(int(31)));
                     body.emit(assign(r0261, rshift(swizzle_y(r0229), r026F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f026D->else_instructions;

                     ir_variable *const r0270 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0272 = equal(r0228, body.constant(int(64)));
                     ir_if *f0271 = new(mem_ctx) ir_if(operand(r0272).val);
                     exec_list *const f0271_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0271->then_instructions;

                        body.emit(assign(r0270, r025D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0271->else_instructions;

                        ir_expression *const r0273 = nequal(swizzle_y(r0229), body.constant(0u));
                        ir_expression *const r0274 = expr(ir_unop_b2i, r0273);
                        body.emit(assign(r0270, expr(ir_unop_i2u, r0274), 0x01));


                     body.instructions = f0271_parent_instructions;
                     body.emit(f0271);

                     /* END IF */

                     body.emit(assign(r0260, r0270, 0x01));

                     body.emit(assign(r0261, body.constant(0u), 0x01));


                  body.instructions = f026D_parent_instructions;
                  body.emit(f026D);

                  /* END IF */


               body.instructions = f026B_parent_instructions;
               body.emit(f026B);

               /* END IF */

               body.emit(assign(r0262, body.constant(0u), 0x01));


            body.instructions = f0267_parent_instructions;
            body.emit(f0267);

            /* END IF */

            ir_expression *const r0275 = nequal(r025F, body.constant(0u));
            ir_expression *const r0276 = expr(ir_unop_b2i, r0275);
            ir_expression *const r0277 = expr(ir_unop_i2u, r0276);
            body.emit(assign(r0260, bit_or(r0260, r0277), 0x01));


         body.instructions = f0265_parent_instructions;
         body.emit(f0265);

         /* END IF */

         body.emit(assign(r0229, r0262, 0x02));

         body.emit(assign(r0229, r0261, 0x01));

         body.emit(assign(r022C, r0260, 0x01));

         body.emit(assign(r022B, r022F, 0x01));


      body.instructions = f0239_parent_instructions;
      body.emit(f0239);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0237->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0279 = less(r0228, body.constant(int(0)));
      ir_if *f0278 = new(mem_ctx) ir_if(operand(r0279).val);
      exec_list *const f0278_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0278->then_instructions;

         /* IF CONDITION */
         ir_expression *const r027B = equal(r0233, body.constant(int(2047)));
         ir_if *f027A = new(mem_ctx) ir_if(operand(r027B).val);
         exec_list *const f027A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f027A->then_instructions;

            /* IF CONDITION */
            ir_expression *const r027D = bit_or(swizzle_y(r0229), swizzle_x(r0229));
            ir_expression *const r027E = nequal(r027D, body.constant(0u));
            ir_if *f027C = new(mem_ctx) ir_if(operand(r027E).val);
            exec_list *const f027C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f027C->then_instructions;

               ir_variable *const r027F = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r027F, swizzle_x(r0223), 0x01));

               ir_variable *const r0280 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0280, swizzle_x(r0224), 0x01));

               ir_variable *const r0281 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0282 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0283 = rshift(swizzle_y(r0223), body.constant(int(19)));
               ir_expression *const r0284 = bit_and(r0283, body.constant(4095u));
               ir_expression *const r0285 = equal(r0284, body.constant(4094u));
               ir_expression *const r0286 = nequal(swizzle_x(r0223), body.constant(0u));
               ir_expression *const r0287 = bit_and(swizzle_y(r0223), body.constant(524287u));
               ir_expression *const r0288 = nequal(r0287, body.constant(0u));
               ir_expression *const r0289 = logic_or(r0286, r0288);
               body.emit(assign(r0282, logic_and(r0285, r0289), 0x01));

               ir_variable *const r028A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r028B = lshift(swizzle_y(r0224), body.constant(int(1)));
               ir_expression *const r028C = lequal(body.constant(4292870144u), r028B);
               ir_expression *const r028D = nequal(swizzle_x(r0224), body.constant(0u));
               ir_expression *const r028E = bit_and(swizzle_y(r0224), body.constant(1048575u));
               ir_expression *const r028F = nequal(r028E, body.constant(0u));
               ir_expression *const r0290 = logic_or(r028D, r028F);
               body.emit(assign(r028A, logic_and(r028C, r0290), 0x01));

               body.emit(assign(r027F, bit_or(swizzle_y(r0223), body.constant(524288u)), 0x02));

               body.emit(assign(r0280, bit_or(swizzle_y(r0224), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0292 = lshift(swizzle_y(r0223), body.constant(int(1)));
               ir_expression *const r0293 = lequal(body.constant(4292870144u), r0292);
               ir_expression *const r0294 = nequal(swizzle_x(r0223), body.constant(0u));
               ir_expression *const r0295 = bit_and(swizzle_y(r0223), body.constant(1048575u));
               ir_expression *const r0296 = nequal(r0295, body.constant(0u));
               ir_expression *const r0297 = logic_or(r0294, r0296);
               ir_expression *const r0298 = logic_and(r0293, r0297);
               ir_if *f0291 = new(mem_ctx) ir_if(operand(r0298).val);
               exec_list *const f0291_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0291->then_instructions;

                  ir_variable *const r0299 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r029B = logic_and(r0282, r028A);
                  ir_if *f029A = new(mem_ctx) ir_if(operand(r029B).val);
                  exec_list *const f029A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f029A->then_instructions;

                     body.emit(assign(r0299, r0280, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f029A->else_instructions;

                     body.emit(assign(r0299, r027F, 0x03));


                  body.instructions = f029A_parent_instructions;
                  body.emit(f029A);

                  /* END IF */

                  body.emit(assign(r0281, r0299, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0291->else_instructions;

                  body.emit(assign(r0281, r0280, 0x03));


               body.instructions = f0291_parent_instructions;
               body.emit(f0291);

               /* END IF */

               body.emit(assign(r0227, r0281, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f027C->else_instructions;

               ir_variable *const r029C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r029C);
               ir_expression *const r029D = lshift(r0225, body.constant(int(31)));
               body.emit(assign(r029C, add(r029D, body.constant(2146435072u)), 0x02));

               body.emit(assign(r029C, body.constant(0u), 0x01));

               body.emit(assign(r0227, r029C, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


            body.instructions = f027C_parent_instructions;
            body.emit(f027C);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f027A->else_instructions;

            /* IF CONDITION */
            ir_expression *const r029F = equal(r022F, body.constant(int(0)));
            ir_if *f029E = new(mem_ctx) ir_if(operand(r029F).val);
            exec_list *const f029E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f029E->then_instructions;

               body.emit(assign(r0228, add(r0228, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f029E->else_instructions;

               body.emit(assign(r022A, bit_or(swizzle_y(r022E), body.constant(1048576u)), 0x02));


            body.instructions = f029E_parent_instructions;
            body.emit(f029E);

            /* END IF */

            ir_variable *const r02A0 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r02A0, swizzle_y(r022A), 0x01));

            ir_variable *const r02A1 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r02A1, swizzle_x(r022A), 0x01));

            ir_variable *const r02A2 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r02A2, body.constant(0u), 0x01));

            ir_variable *const r02A3 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r02A3, neg(r0228), 0x01));

            ir_variable *const r02A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r02A4);
            ir_variable *const r02A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r02A5);
            ir_variable *const r02A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r02A6);
            ir_variable *const r02A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r02A8 = neg(r02A3);
            body.emit(assign(r02A7, bit_and(r02A8, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r02AA = equal(r02A3, body.constant(int(0)));
            ir_if *f02A9 = new(mem_ctx) ir_if(operand(r02AA).val);
            exec_list *const f02A9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02A9->then_instructions;

               body.emit(assign(r02A4, r02A2, 0x01));

               body.emit(assign(r02A5, r02A1, 0x01));

               body.emit(assign(r02A6, r02A0, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02A9->else_instructions;

               /* IF CONDITION */
               ir_expression *const r02AC = less(r02A3, body.constant(int(32)));
               ir_if *f02AB = new(mem_ctx) ir_if(operand(r02AC).val);
               exec_list *const f02AB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02AB->then_instructions;

                  body.emit(assign(r02A4, lshift(swizzle_x(r022E), r02A7), 0x01));

                  ir_expression *const r02AD = lshift(swizzle_y(r022A), r02A7);
                  ir_expression *const r02AE = rshift(swizzle_x(r022E), r02A3);
                  body.emit(assign(r02A5, bit_or(r02AD, r02AE), 0x01));

                  body.emit(assign(r02A6, rshift(swizzle_y(r022A), r02A3), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02AB->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r02B0 = equal(r02A3, body.constant(int(32)));
                  ir_if *f02AF = new(mem_ctx) ir_if(operand(r02B0).val);
                  exec_list *const f02AF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02AF->then_instructions;

                     body.emit(assign(r02A4, r02A1, 0x01));

                     body.emit(assign(r02A5, r02A0, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02AF->else_instructions;

                     body.emit(assign(r02A2, bit_or(body.constant(0u), swizzle_x(r022E)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r02B2 = less(r02A3, body.constant(int(64)));
                     ir_if *f02B1 = new(mem_ctx) ir_if(operand(r02B2).val);
                     exec_list *const f02B1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02B1->then_instructions;

                        body.emit(assign(r02A4, lshift(swizzle_y(r022A), r02A7), 0x01));

                        ir_expression *const r02B3 = bit_and(r02A3, body.constant(int(31)));
                        body.emit(assign(r02A5, rshift(swizzle_y(r022A), r02B3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02B1->else_instructions;

                        ir_variable *const r02B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r02B6 = equal(r02A3, body.constant(int(64)));
                        ir_if *f02B5 = new(mem_ctx) ir_if(operand(r02B6).val);
                        exec_list *const f02B5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f02B5->then_instructions;

                           body.emit(assign(r02B4, r02A0, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f02B5->else_instructions;

                           ir_expression *const r02B7 = nequal(swizzle_y(r022A), body.constant(0u));
                           ir_expression *const r02B8 = expr(ir_unop_b2i, r02B7);
                           body.emit(assign(r02B4, expr(ir_unop_i2u, r02B8), 0x01));


                        body.instructions = f02B5_parent_instructions;
                        body.emit(f02B5);

                        /* END IF */

                        body.emit(assign(r02A4, r02B4, 0x01));

                        body.emit(assign(r02A5, body.constant(0u), 0x01));


                     body.instructions = f02B1_parent_instructions;
                     body.emit(f02B1);

                     /* END IF */


                  body.instructions = f02AF_parent_instructions;
                  body.emit(f02AF);

                  /* END IF */

                  body.emit(assign(r02A6, body.constant(0u), 0x01));


               body.instructions = f02AB_parent_instructions;
               body.emit(f02AB);

               /* END IF */

               ir_expression *const r02B9 = nequal(r02A2, body.constant(0u));
               ir_expression *const r02BA = expr(ir_unop_b2i, r02B9);
               ir_expression *const r02BB = expr(ir_unop_i2u, r02BA);
               body.emit(assign(r02A4, bit_or(r02A4, r02BB), 0x01));


            body.instructions = f02A9_parent_instructions;
            body.emit(f02A9);

            /* END IF */

            body.emit(assign(r022A, r02A6, 0x02));

            body.emit(assign(r022A, r02A5, 0x01));

            body.emit(assign(r022C, r02A4, 0x01));

            body.emit(assign(r022B, r0233, 0x01));


         body.instructions = f027A_parent_instructions;
         body.emit(f027A);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0278->else_instructions;

         /* IF CONDITION */
         ir_expression *const r02BD = equal(r022F, body.constant(int(2047)));
         ir_if *f02BC = new(mem_ctx) ir_if(operand(r02BD).val);
         exec_list *const f02BC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f02BC->then_instructions;

            /* IF CONDITION */
            ir_expression *const r02BF = bit_or(swizzle_y(r022A), swizzle_x(r022A));
            ir_expression *const r02C0 = bit_or(swizzle_y(r0229), swizzle_x(r0229));
            ir_expression *const r02C1 = bit_or(r02BF, r02C0);
            ir_expression *const r02C2 = nequal(r02C1, body.constant(0u));
            ir_if *f02BE = new(mem_ctx) ir_if(operand(r02C2).val);
            exec_list *const f02BE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02BE->then_instructions;

               ir_variable *const r02C3 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r02C3, swizzle_x(r0223), 0x01));

               ir_variable *const r02C4 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r02C4, swizzle_x(r0224), 0x01));

               ir_variable *const r02C5 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02C6 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r02C7 = rshift(swizzle_y(r0223), body.constant(int(19)));
               ir_expression *const r02C8 = bit_and(r02C7, body.constant(4095u));
               ir_expression *const r02C9 = equal(r02C8, body.constant(4094u));
               ir_expression *const r02CA = nequal(swizzle_x(r0223), body.constant(0u));
               ir_expression *const r02CB = bit_and(swizzle_y(r0223), body.constant(524287u));
               ir_expression *const r02CC = nequal(r02CB, body.constant(0u));
               ir_expression *const r02CD = logic_or(r02CA, r02CC);
               body.emit(assign(r02C6, logic_and(r02C9, r02CD), 0x01));

               ir_variable *const r02CE = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r02CF = lshift(swizzle_y(r0224), body.constant(int(1)));
               ir_expression *const r02D0 = lequal(body.constant(4292870144u), r02CF);
               ir_expression *const r02D1 = nequal(swizzle_x(r0224), body.constant(0u));
               ir_expression *const r02D2 = bit_and(swizzle_y(r0224), body.constant(1048575u));
               ir_expression *const r02D3 = nequal(r02D2, body.constant(0u));
               ir_expression *const r02D4 = logic_or(r02D1, r02D3);
               body.emit(assign(r02CE, logic_and(r02D0, r02D4), 0x01));

               body.emit(assign(r02C3, bit_or(swizzle_y(r0223), body.constant(524288u)), 0x02));

               body.emit(assign(r02C4, bit_or(swizzle_y(r0224), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r02D6 = lshift(swizzle_y(r0223), body.constant(int(1)));
               ir_expression *const r02D7 = lequal(body.constant(4292870144u), r02D6);
               ir_expression *const r02D8 = nequal(swizzle_x(r0223), body.constant(0u));
               ir_expression *const r02D9 = bit_and(swizzle_y(r0223), body.constant(1048575u));
               ir_expression *const r02DA = nequal(r02D9, body.constant(0u));
               ir_expression *const r02DB = logic_or(r02D8, r02DA);
               ir_expression *const r02DC = logic_and(r02D7, r02DB);
               ir_if *f02D5 = new(mem_ctx) ir_if(operand(r02DC).val);
               exec_list *const f02D5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02D5->then_instructions;

                  ir_variable *const r02DD = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02DF = logic_and(r02C6, r02CE);
                  ir_if *f02DE = new(mem_ctx) ir_if(operand(r02DF).val);
                  exec_list *const f02DE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02DE->then_instructions;

                     body.emit(assign(r02DD, r02C4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02DE->else_instructions;

                     body.emit(assign(r02DD, r02C3, 0x03));


                  body.instructions = f02DE_parent_instructions;
                  body.emit(f02DE);

                  /* END IF */

                  body.emit(assign(r02C5, r02DD, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02D5->else_instructions;

                  body.emit(assign(r02C5, r02C4, 0x03));


               body.instructions = f02D5_parent_instructions;
               body.emit(f02D5);

               /* END IF */

               body.emit(assign(r0227, r02C5, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02BE->else_instructions;

               body.emit(assign(r0227, r0223, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


            body.instructions = f02BE_parent_instructions;
            body.emit(f02BE);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f02BC->else_instructions;

            ir_variable *const r02E0 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r02E1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r02E1, add(swizzle_x(r022A), swizzle_x(r0229)), 0x01));

            ir_expression *const r02E2 = add(swizzle_y(r022A), swizzle_y(r0229));
            ir_expression *const r02E3 = less(r02E1, swizzle_x(r022A));
            ir_expression *const r02E4 = expr(ir_unop_b2i, r02E3);
            ir_expression *const r02E5 = expr(ir_unop_i2u, r02E4);
            body.emit(assign(r02E0, add(r02E2, r02E5), 0x01));

            body.emit(assign(r022D, r02E0, 0x01));

            /* IF CONDITION */
            ir_expression *const r02E7 = equal(r022F, body.constant(int(0)));
            ir_if *f02E6 = new(mem_ctx) ir_if(operand(r02E7).val);
            exec_list *const f02E6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02E6->then_instructions;

               ir_variable *const r02E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02E8);
               ir_expression *const r02E9 = lshift(r0225, body.constant(int(31)));
               body.emit(assign(r02E8, add(r02E9, r02E0), 0x02));

               body.emit(assign(r02E8, r02E1, 0x01));

               body.emit(assign(r0227, r02E8, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02E6->else_instructions;

               body.emit(assign(r022D, bit_or(r02E0, body.constant(2097152u)), 0x01));

               body.emit(assign(r022B, r022F, 0x01));

               ir_variable *const r02EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r02EA);
               ir_variable *const r02EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r02EB);
               ir_variable *const r02EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r02EC);
               body.emit(assign(r02EA, lshift(r02E1, body.constant(int(31))), 0x01));

               ir_expression *const r02ED = lshift(r022D, body.constant(int(31)));
               ir_expression *const r02EE = rshift(r02E1, body.constant(int(1)));
               body.emit(assign(r02EB, bit_or(r02ED, r02EE), 0x01));

               body.emit(assign(r02EC, rshift(r022D, body.constant(int(1))), 0x01));

               body.emit(assign(r02EA, bit_or(r02EA, body.constant(0u)), 0x01));

               body.emit(assign(r022D, r02EC, 0x01));

               body.emit(assign(r022C, r02EA, 0x01));

               ir_variable *const r02EF = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r02EF, r022F, 0x01));

               ir_variable *const r02F0 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r02F0, r02EC, 0x01));

               ir_variable *const r02F1 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r02F1, r02EB, 0x01));

               ir_variable *const r02F2 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r02F2, r02EA, 0x01));

               ir_variable *const r02F3 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r02F3, body.constant(true), 0x01));

               ir_variable *const r02F4 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02F5 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r02F5);
               ir_expression *const r02F6 = expr(ir_unop_u2i, r02EA);
               body.emit(assign(r02F5, less(r02F6, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r02F8 = lequal(body.constant(int(2045)), r022F);
               ir_if *f02F7 = new(mem_ctx) ir_if(operand(r02F8).val);
               exec_list *const f02F7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02F7->then_instructions;

                  ir_variable *const r02F9 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02FB = less(body.constant(int(2045)), r022F);
                  ir_if *f02FA = new(mem_ctx) ir_if(operand(r02FB).val);
                  exec_list *const f02FA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02FA->then_instructions;

                     body.emit(assign(r02F9, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02FA->else_instructions;

                     ir_variable *const r02FC = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r02FE = equal(r022F, body.constant(int(2045)));
                     ir_if *f02FD = new(mem_ctx) ir_if(operand(r02FE).val);
                     exec_list *const f02FD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02FD->then_instructions;

                        ir_expression *const r02FF = equal(body.constant(2097151u), r02EC);
                        ir_expression *const r0300 = equal(body.constant(4294967295u), r02EB);
                        body.emit(assign(r02FC, logic_and(r02FF, r0300), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02FD->else_instructions;

                        body.emit(assign(r02FC, body.constant(false), 0x01));


                     body.instructions = f02FD_parent_instructions;
                     body.emit(f02FD);

                     /* END IF */

                     body.emit(assign(r02F9, logic_and(r02FC, r02F5), 0x01));


                  body.instructions = f02FA_parent_instructions;
                  body.emit(f02FA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0301 = new(mem_ctx) ir_if(operand(r02F9).val);
                  exec_list *const f0301_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0301->then_instructions;

                     ir_variable *const r0302 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0302);
                     ir_expression *const r0303 = lshift(r0225, body.constant(int(31)));
                     body.emit(assign(r0302, add(r0303, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0302, body.constant(0u), 0x01));

                     body.emit(assign(r02F4, r0302, 0x03));

                     body.emit(assign(r02F3, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0301->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0305 = less(r022F, body.constant(int(0)));
                     ir_if *f0304 = new(mem_ctx) ir_if(operand(r0305).val);
                     exec_list *const f0304_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0304->then_instructions;

                        ir_variable *const r0306 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0306, r02EA, 0x01));

                        ir_variable *const r0307 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0307, neg(r022F), 0x01));

                        ir_variable *const r0308 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0308);
                        ir_variable *const r0309 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0309);
                        ir_variable *const r030A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r030A);
                        ir_variable *const r030B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r030C = neg(r0307);
                        body.emit(assign(r030B, bit_and(r030C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r030E = equal(r0307, body.constant(int(0)));
                        ir_if *f030D = new(mem_ctx) ir_if(operand(r030E).val);
                        exec_list *const f030D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f030D->then_instructions;

                           body.emit(assign(r0308, r02EA, 0x01));

                           body.emit(assign(r0309, r02EB, 0x01));

                           body.emit(assign(r030A, r02EC, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f030D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0310 = less(r0307, body.constant(int(32)));
                           ir_if *f030F = new(mem_ctx) ir_if(operand(r0310).val);
                           exec_list *const f030F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f030F->then_instructions;

                              body.emit(assign(r0308, lshift(r02EB, r030B), 0x01));

                              ir_expression *const r0311 = lshift(r02EC, r030B);
                              ir_expression *const r0312 = rshift(r02EB, r0307);
                              body.emit(assign(r0309, bit_or(r0311, r0312), 0x01));

                              body.emit(assign(r030A, rshift(r02EC, r0307), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f030F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0314 = equal(r0307, body.constant(int(32)));
                              ir_if *f0313 = new(mem_ctx) ir_if(operand(r0314).val);
                              exec_list *const f0313_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0313->then_instructions;

                                 body.emit(assign(r0308, r02EB, 0x01));

                                 body.emit(assign(r0309, r02EC, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0313->else_instructions;

                                 body.emit(assign(r0306, bit_or(r02EA, r02EB), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0316 = less(r0307, body.constant(int(64)));
                                 ir_if *f0315 = new(mem_ctx) ir_if(operand(r0316).val);
                                 exec_list *const f0315_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0315->then_instructions;

                                    body.emit(assign(r0308, lshift(r02EC, r030B), 0x01));

                                    ir_expression *const r0317 = bit_and(r0307, body.constant(int(31)));
                                    body.emit(assign(r0309, rshift(r02EC, r0317), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0315->else_instructions;

                                    ir_variable *const r0318 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r031A = equal(r0307, body.constant(int(64)));
                                    ir_if *f0319 = new(mem_ctx) ir_if(operand(r031A).val);
                                    exec_list *const f0319_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0319->then_instructions;

                                       body.emit(assign(r0318, r02EC, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0319->else_instructions;

                                       ir_expression *const r031B = nequal(r02EC, body.constant(0u));
                                       ir_expression *const r031C = expr(ir_unop_b2i, r031B);
                                       body.emit(assign(r0318, expr(ir_unop_i2u, r031C), 0x01));


                                    body.instructions = f0319_parent_instructions;
                                    body.emit(f0319);

                                    /* END IF */

                                    body.emit(assign(r0308, r0318, 0x01));

                                    body.emit(assign(r0309, body.constant(0u), 0x01));


                                 body.instructions = f0315_parent_instructions;
                                 body.emit(f0315);

                                 /* END IF */


                              body.instructions = f0313_parent_instructions;
                              body.emit(f0313);

                              /* END IF */

                              body.emit(assign(r030A, body.constant(0u), 0x01));


                           body.instructions = f030F_parent_instructions;
                           body.emit(f030F);

                           /* END IF */

                           ir_expression *const r031D = nequal(r0306, body.constant(0u));
                           ir_expression *const r031E = expr(ir_unop_b2i, r031D);
                           ir_expression *const r031F = expr(ir_unop_i2u, r031E);
                           body.emit(assign(r0308, bit_or(r0308, r031F), 0x01));


                        body.instructions = f030D_parent_instructions;
                        body.emit(f030D);

                        /* END IF */

                        body.emit(assign(r02F0, r030A, 0x01));

                        body.emit(assign(r02F1, r0309, 0x01));

                        body.emit(assign(r02F2, r0308, 0x01));

                        body.emit(assign(r02EF, body.constant(int(0)), 0x01));

                        body.emit(assign(r02F5, less(r0308, body.constant(0u)), 0x01));


                     body.instructions = f0304_parent_instructions;
                     body.emit(f0304);

                     /* END IF */


                  body.instructions = f0301_parent_instructions;
                  body.emit(f0301);

                  /* END IF */


               body.instructions = f02F7_parent_instructions;
               body.emit(f02F7);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0320 = new(mem_ctx) ir_if(operand(r02F3).val);
               exec_list *const f0320_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0320->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0321 = new(mem_ctx) ir_if(operand(r02F5).val);
                  exec_list *const f0321_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0321->then_instructions;

                     ir_variable *const r0322 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0322, add(r02F1, body.constant(1u)), 0x01));

                     ir_expression *const r0323 = less(r0322, r02F1);
                     ir_expression *const r0324 = expr(ir_unop_b2i, r0323);
                     ir_expression *const r0325 = expr(ir_unop_i2u, r0324);
                     body.emit(assign(r02F0, add(r02F0, r0325), 0x01));

                     ir_expression *const r0326 = equal(r02F2, body.constant(0u));
                     ir_expression *const r0327 = expr(ir_unop_b2i, r0326);
                     ir_expression *const r0328 = expr(ir_unop_i2u, r0327);
                     ir_expression *const r0329 = add(r02F2, r0328);
                     ir_expression *const r032A = bit_and(r0329, body.constant(1u));
                     ir_expression *const r032B = expr(ir_unop_bit_not, r032A);
                     body.emit(assign(r02F1, bit_and(r0322, r032B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0321->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r032D = bit_or(r02F0, r02F1);
                     ir_expression *const r032E = equal(r032D, body.constant(0u));
                     ir_if *f032C = new(mem_ctx) ir_if(operand(r032E).val);
                     exec_list *const f032C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f032C->then_instructions;

                        body.emit(assign(r02EF, body.constant(int(0)), 0x01));


                     body.instructions = f032C_parent_instructions;
                     body.emit(f032C);

                     /* END IF */


                  body.instructions = f0321_parent_instructions;
                  body.emit(f0321);

                  /* END IF */

                  ir_variable *const r032F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r032F);
                  ir_expression *const r0330 = lshift(r0225, body.constant(int(31)));
                  ir_expression *const r0331 = expr(ir_unop_i2u, r02EF);
                  ir_expression *const r0332 = lshift(r0331, body.constant(int(20)));
                  ir_expression *const r0333 = add(r0330, r0332);
                  body.emit(assign(r032F, add(r0333, r02F0), 0x02));

                  body.emit(assign(r032F, r02F1, 0x01));

                  body.emit(assign(r02F4, r032F, 0x03));

                  body.emit(assign(r02F3, body.constant(false), 0x01));


               body.instructions = f0320_parent_instructions;
               body.emit(f0320);

               /* END IF */

               body.emit(assign(r0227, r02F4, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


            body.instructions = f02E6_parent_instructions;
            body.emit(f02E6);

            /* END IF */


         body.instructions = f02BC_parent_instructions;
         body.emit(f02BC);

         /* END IF */


      body.instructions = f0278_parent_instructions;
      body.emit(f0278);

      /* END IF */


   body.instructions = f0237_parent_instructions;
   body.emit(f0237);

   /* END IF */

   /* IF CONDITION */
   ir_if *f0334 = new(mem_ctx) ir_if(operand(r0226).val);
   exec_list *const f0334_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0334->then_instructions;

      body.emit(assign(r022A, bit_or(swizzle_y(r022A), body.constant(1048576u)), 0x02));

      ir_variable *const r0335 = body.make_temp(glsl_type::uint_type, "z0Ptr");
      ir_variable *const r0336 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r0336, add(swizzle_x(r022A), swizzle_x(r0229)), 0x01));

      ir_expression *const r0337 = add(swizzle_y(r022A), swizzle_y(r0229));
      ir_expression *const r0338 = less(r0336, swizzle_x(r022A));
      ir_expression *const r0339 = expr(ir_unop_b2i, r0338);
      ir_expression *const r033A = expr(ir_unop_i2u, r0339);
      body.emit(assign(r0335, add(r0337, r033A), 0x01));

      body.emit(assign(r022D, r0335, 0x01));

      body.emit(assign(r022B, add(r022B, body.constant(int(-1))), 0x01));

      /* IF CONDITION */
      ir_expression *const r033C = less(r0335, body.constant(2097152u));
      ir_if *f033B = new(mem_ctx) ir_if(operand(r033C).val);
      exec_list *const f033B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f033B->then_instructions;

         ir_variable *const r033D = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r033D, r022B, 0x01));

         ir_variable *const r033E = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r033E, r0335, 0x01));

         ir_variable *const r033F = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r033F, r0336, 0x01));

         ir_variable *const r0340 = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r0340, r022C, 0x01));

         ir_variable *const r0341 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0341, body.constant(true), 0x01));

         ir_variable *const r0342 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0343 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0343);
         ir_expression *const r0344 = expr(ir_unop_u2i, r022C);
         body.emit(assign(r0343, less(r0344, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0346 = lequal(body.constant(int(2045)), r022B);
         ir_if *f0345 = new(mem_ctx) ir_if(operand(r0346).val);
         exec_list *const f0345_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0345->then_instructions;

            ir_variable *const r0347 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0349 = less(body.constant(int(2045)), r022B);
            ir_if *f0348 = new(mem_ctx) ir_if(operand(r0349).val);
            exec_list *const f0348_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0348->then_instructions;

               body.emit(assign(r0347, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0348->else_instructions;

               ir_variable *const r034A = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r034C = equal(r022B, body.constant(int(2045)));
               ir_if *f034B = new(mem_ctx) ir_if(operand(r034C).val);
               exec_list *const f034B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f034B->then_instructions;

                  ir_expression *const r034D = equal(body.constant(2097151u), r0335);
                  ir_expression *const r034E = equal(body.constant(4294967295u), r0336);
                  body.emit(assign(r034A, logic_and(r034D, r034E), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f034B->else_instructions;

                  body.emit(assign(r034A, body.constant(false), 0x01));


               body.instructions = f034B_parent_instructions;
               body.emit(f034B);

               /* END IF */

               body.emit(assign(r0347, logic_and(r034A, r0343), 0x01));


            body.instructions = f0348_parent_instructions;
            body.emit(f0348);

            /* END IF */

            /* IF CONDITION */
            ir_if *f034F = new(mem_ctx) ir_if(operand(r0347).val);
            exec_list *const f034F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f034F->then_instructions;

               ir_variable *const r0350 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0350);
               ir_expression *const r0351 = lshift(r0225, body.constant(int(31)));
               body.emit(assign(r0350, add(r0351, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0350, body.constant(0u), 0x01));

               body.emit(assign(r0342, r0350, 0x03));

               body.emit(assign(r0341, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f034F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0353 = less(r022B, body.constant(int(0)));
               ir_if *f0352 = new(mem_ctx) ir_if(operand(r0353).val);
               exec_list *const f0352_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0352->then_instructions;

                  ir_variable *const r0354 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0354, r022C, 0x01));

                  ir_variable *const r0355 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0355, neg(r022B), 0x01));

                  ir_variable *const r0356 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0356);
                  ir_variable *const r0357 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0357);
                  ir_variable *const r0358 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0358);
                  ir_variable *const r0359 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r035A = neg(r0355);
                  body.emit(assign(r0359, bit_and(r035A, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r035C = equal(r0355, body.constant(int(0)));
                  ir_if *f035B = new(mem_ctx) ir_if(operand(r035C).val);
                  exec_list *const f035B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f035B->then_instructions;

                     body.emit(assign(r0356, r022C, 0x01));

                     body.emit(assign(r0357, r0336, 0x01));

                     body.emit(assign(r0358, r0335, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f035B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r035E = less(r0355, body.constant(int(32)));
                     ir_if *f035D = new(mem_ctx) ir_if(operand(r035E).val);
                     exec_list *const f035D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f035D->then_instructions;

                        body.emit(assign(r0356, lshift(r0336, r0359), 0x01));

                        ir_expression *const r035F = lshift(r0335, r0359);
                        ir_expression *const r0360 = rshift(r0336, r0355);
                        body.emit(assign(r0357, bit_or(r035F, r0360), 0x01));

                        body.emit(assign(r0358, rshift(r0335, r0355), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f035D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0362 = equal(r0355, body.constant(int(32)));
                        ir_if *f0361 = new(mem_ctx) ir_if(operand(r0362).val);
                        exec_list *const f0361_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0361->then_instructions;

                           body.emit(assign(r0356, r0336, 0x01));

                           body.emit(assign(r0357, r0335, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0361->else_instructions;

                           body.emit(assign(r0354, bit_or(r022C, r0336), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0364 = less(r0355, body.constant(int(64)));
                           ir_if *f0363 = new(mem_ctx) ir_if(operand(r0364).val);
                           exec_list *const f0363_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0363->then_instructions;

                              body.emit(assign(r0356, lshift(r0335, r0359), 0x01));

                              ir_expression *const r0365 = bit_and(r0355, body.constant(int(31)));
                              body.emit(assign(r0357, rshift(r0335, r0365), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0363->else_instructions;

                              ir_variable *const r0366 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0368 = equal(r0355, body.constant(int(64)));
                              ir_if *f0367 = new(mem_ctx) ir_if(operand(r0368).val);
                              exec_list *const f0367_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0367->then_instructions;

                                 body.emit(assign(r0366, r0335, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0367->else_instructions;

                                 ir_expression *const r0369 = nequal(r0335, body.constant(0u));
                                 ir_expression *const r036A = expr(ir_unop_b2i, r0369);
                                 body.emit(assign(r0366, expr(ir_unop_i2u, r036A), 0x01));


                              body.instructions = f0367_parent_instructions;
                              body.emit(f0367);

                              /* END IF */

                              body.emit(assign(r0356, r0366, 0x01));

                              body.emit(assign(r0357, body.constant(0u), 0x01));


                           body.instructions = f0363_parent_instructions;
                           body.emit(f0363);

                           /* END IF */


                        body.instructions = f0361_parent_instructions;
                        body.emit(f0361);

                        /* END IF */

                        body.emit(assign(r0358, body.constant(0u), 0x01));


                     body.instructions = f035D_parent_instructions;
                     body.emit(f035D);

                     /* END IF */

                     ir_expression *const r036B = nequal(r0354, body.constant(0u));
                     ir_expression *const r036C = expr(ir_unop_b2i, r036B);
                     ir_expression *const r036D = expr(ir_unop_i2u, r036C);
                     body.emit(assign(r0356, bit_or(r0356, r036D), 0x01));


                  body.instructions = f035B_parent_instructions;
                  body.emit(f035B);

                  /* END IF */

                  body.emit(assign(r033E, r0358, 0x01));

                  body.emit(assign(r033F, r0357, 0x01));

                  body.emit(assign(r0340, r0356, 0x01));

                  body.emit(assign(r033D, body.constant(int(0)), 0x01));

                  body.emit(assign(r0343, less(r0356, body.constant(0u)), 0x01));


               body.instructions = f0352_parent_instructions;
               body.emit(f0352);

               /* END IF */


            body.instructions = f034F_parent_instructions;
            body.emit(f034F);

            /* END IF */


         body.instructions = f0345_parent_instructions;
         body.emit(f0345);

         /* END IF */

         /* IF CONDITION */
         ir_if *f036E = new(mem_ctx) ir_if(operand(r0341).val);
         exec_list *const f036E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f036E->then_instructions;

            /* IF CONDITION */
            ir_if *f036F = new(mem_ctx) ir_if(operand(r0343).val);
            exec_list *const f036F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f036F->then_instructions;

               ir_variable *const r0370 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0370, add(r033F, body.constant(1u)), 0x01));

               ir_expression *const r0371 = less(r0370, r033F);
               ir_expression *const r0372 = expr(ir_unop_b2i, r0371);
               ir_expression *const r0373 = expr(ir_unop_i2u, r0372);
               body.emit(assign(r033E, add(r033E, r0373), 0x01));

               ir_expression *const r0374 = equal(r0340, body.constant(0u));
               ir_expression *const r0375 = expr(ir_unop_b2i, r0374);
               ir_expression *const r0376 = expr(ir_unop_i2u, r0375);
               ir_expression *const r0377 = add(r0340, r0376);
               ir_expression *const r0378 = bit_and(r0377, body.constant(1u));
               ir_expression *const r0379 = expr(ir_unop_bit_not, r0378);
               body.emit(assign(r033F, bit_and(r0370, r0379), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f036F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r037B = bit_or(r033E, r033F);
               ir_expression *const r037C = equal(r037B, body.constant(0u));
               ir_if *f037A = new(mem_ctx) ir_if(operand(r037C).val);
               exec_list *const f037A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f037A->then_instructions;

                  body.emit(assign(r033D, body.constant(int(0)), 0x01));


               body.instructions = f037A_parent_instructions;
               body.emit(f037A);

               /* END IF */


            body.instructions = f036F_parent_instructions;
            body.emit(f036F);

            /* END IF */

            ir_variable *const r037D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r037D);
            ir_expression *const r037E = lshift(r0225, body.constant(int(31)));
            ir_expression *const r037F = expr(ir_unop_i2u, r033D);
            ir_expression *const r0380 = lshift(r037F, body.constant(int(20)));
            ir_expression *const r0381 = add(r037E, r0380);
            body.emit(assign(r037D, add(r0381, r033E), 0x02));

            body.emit(assign(r037D, r033F, 0x01));

            body.emit(assign(r0342, r037D, 0x03));

            body.emit(assign(r0341, body.constant(false), 0x01));


         body.instructions = f036E_parent_instructions;
         body.emit(f036E);

         /* END IF */

         body.emit(assign(r0227, r0342, 0x03));

         body.emit(assign(r0226, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f033B->else_instructions;

         body.emit(assign(r022B, add(r022B, body.constant(int(1))), 0x01));

         ir_variable *const r0382 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0382);
         ir_variable *const r0383 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0383);
         ir_variable *const r0384 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0384);
         body.emit(assign(r0382, lshift(r0336, body.constant(int(31))), 0x01));

         ir_expression *const r0385 = lshift(r0335, body.constant(int(31)));
         ir_expression *const r0386 = rshift(r0336, body.constant(int(1)));
         body.emit(assign(r0383, bit_or(r0385, r0386), 0x01));

         body.emit(assign(r0384, rshift(r0335, body.constant(int(1))), 0x01));

         ir_expression *const r0387 = nequal(r022C, body.constant(0u));
         ir_expression *const r0388 = expr(ir_unop_b2i, r0387);
         ir_expression *const r0389 = expr(ir_unop_i2u, r0388);
         body.emit(assign(r0382, bit_or(r0382, r0389), 0x01));

         body.emit(assign(r022D, r0384, 0x01));

         body.emit(assign(r022C, r0382, 0x01));

         ir_variable *const r038A = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r038A, r022B, 0x01));

         ir_variable *const r038B = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r038B, r0384, 0x01));

         ir_variable *const r038C = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r038C, r0383, 0x01));

         ir_variable *const r038D = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r038D, r0382, 0x01));

         ir_variable *const r038E = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r038E, body.constant(true), 0x01));

         ir_variable *const r038F = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0390 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0390);
         ir_expression *const r0391 = expr(ir_unop_u2i, r0382);
         body.emit(assign(r0390, less(r0391, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0393 = lequal(body.constant(int(2045)), r022B);
         ir_if *f0392 = new(mem_ctx) ir_if(operand(r0393).val);
         exec_list *const f0392_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0392->then_instructions;

            ir_variable *const r0394 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0396 = less(body.constant(int(2045)), r022B);
            ir_if *f0395 = new(mem_ctx) ir_if(operand(r0396).val);
            exec_list *const f0395_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0395->then_instructions;

               body.emit(assign(r0394, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0395->else_instructions;

               ir_variable *const r0397 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r0399 = equal(r022B, body.constant(int(2045)));
               ir_if *f0398 = new(mem_ctx) ir_if(operand(r0399).val);
               exec_list *const f0398_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0398->then_instructions;

                  ir_expression *const r039A = equal(body.constant(2097151u), r0384);
                  ir_expression *const r039B = equal(body.constant(4294967295u), r0383);
                  body.emit(assign(r0397, logic_and(r039A, r039B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0398->else_instructions;

                  body.emit(assign(r0397, body.constant(false), 0x01));


               body.instructions = f0398_parent_instructions;
               body.emit(f0398);

               /* END IF */

               body.emit(assign(r0394, logic_and(r0397, r0390), 0x01));


            body.instructions = f0395_parent_instructions;
            body.emit(f0395);

            /* END IF */

            /* IF CONDITION */
            ir_if *f039C = new(mem_ctx) ir_if(operand(r0394).val);
            exec_list *const f039C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f039C->then_instructions;

               ir_variable *const r039D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r039D);
               ir_expression *const r039E = lshift(r0225, body.constant(int(31)));
               body.emit(assign(r039D, add(r039E, body.constant(2146435072u)), 0x02));

               body.emit(assign(r039D, body.constant(0u), 0x01));

               body.emit(assign(r038F, r039D, 0x03));

               body.emit(assign(r038E, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f039C->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03A0 = less(r022B, body.constant(int(0)));
               ir_if *f039F = new(mem_ctx) ir_if(operand(r03A0).val);
               exec_list *const f039F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f039F->then_instructions;

                  ir_variable *const r03A1 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r03A1, r0382, 0x01));

                  ir_variable *const r03A2 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r03A2, neg(r022B), 0x01));

                  ir_variable *const r03A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r03A3);
                  ir_variable *const r03A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r03A4);
                  ir_variable *const r03A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r03A5);
                  ir_variable *const r03A6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r03A7 = neg(r03A2);
                  body.emit(assign(r03A6, bit_and(r03A7, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r03A9 = equal(r03A2, body.constant(int(0)));
                  ir_if *f03A8 = new(mem_ctx) ir_if(operand(r03A9).val);
                  exec_list *const f03A8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f03A8->then_instructions;

                     body.emit(assign(r03A3, r0382, 0x01));

                     body.emit(assign(r03A4, r0383, 0x01));

                     body.emit(assign(r03A5, r0384, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f03A8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r03AB = less(r03A2, body.constant(int(32)));
                     ir_if *f03AA = new(mem_ctx) ir_if(operand(r03AB).val);
                     exec_list *const f03AA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f03AA->then_instructions;

                        body.emit(assign(r03A3, lshift(r0383, r03A6), 0x01));

                        ir_expression *const r03AC = lshift(r0384, r03A6);
                        ir_expression *const r03AD = rshift(r0383, r03A2);
                        body.emit(assign(r03A4, bit_or(r03AC, r03AD), 0x01));

                        body.emit(assign(r03A5, rshift(r0384, r03A2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f03AA->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r03AF = equal(r03A2, body.constant(int(32)));
                        ir_if *f03AE = new(mem_ctx) ir_if(operand(r03AF).val);
                        exec_list *const f03AE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f03AE->then_instructions;

                           body.emit(assign(r03A3, r0383, 0x01));

                           body.emit(assign(r03A4, r0384, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f03AE->else_instructions;

                           body.emit(assign(r03A1, bit_or(r0382, r0383), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r03B1 = less(r03A2, body.constant(int(64)));
                           ir_if *f03B0 = new(mem_ctx) ir_if(operand(r03B1).val);
                           exec_list *const f03B0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f03B0->then_instructions;

                              body.emit(assign(r03A3, lshift(r0384, r03A6), 0x01));

                              ir_expression *const r03B2 = bit_and(r03A2, body.constant(int(31)));
                              body.emit(assign(r03A4, rshift(r0384, r03B2), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f03B0->else_instructions;

                              ir_variable *const r03B3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r03B5 = equal(r03A2, body.constant(int(64)));
                              ir_if *f03B4 = new(mem_ctx) ir_if(operand(r03B5).val);
                              exec_list *const f03B4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f03B4->then_instructions;

                                 body.emit(assign(r03B3, r0384, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f03B4->else_instructions;

                                 ir_expression *const r03B6 = nequal(r0384, body.constant(0u));
                                 ir_expression *const r03B7 = expr(ir_unop_b2i, r03B6);
                                 body.emit(assign(r03B3, expr(ir_unop_i2u, r03B7), 0x01));


                              body.instructions = f03B4_parent_instructions;
                              body.emit(f03B4);

                              /* END IF */

                              body.emit(assign(r03A3, r03B3, 0x01));

                              body.emit(assign(r03A4, body.constant(0u), 0x01));


                           body.instructions = f03B0_parent_instructions;
                           body.emit(f03B0);

                           /* END IF */


                        body.instructions = f03AE_parent_instructions;
                        body.emit(f03AE);

                        /* END IF */

                        body.emit(assign(r03A5, body.constant(0u), 0x01));


                     body.instructions = f03AA_parent_instructions;
                     body.emit(f03AA);

                     /* END IF */

                     ir_expression *const r03B8 = nequal(r03A1, body.constant(0u));
                     ir_expression *const r03B9 = expr(ir_unop_b2i, r03B8);
                     ir_expression *const r03BA = expr(ir_unop_i2u, r03B9);
                     body.emit(assign(r03A3, bit_or(r03A3, r03BA), 0x01));


                  body.instructions = f03A8_parent_instructions;
                  body.emit(f03A8);

                  /* END IF */

                  body.emit(assign(r038B, r03A5, 0x01));

                  body.emit(assign(r038C, r03A4, 0x01));

                  body.emit(assign(r038D, r03A3, 0x01));

                  body.emit(assign(r038A, body.constant(int(0)), 0x01));

                  body.emit(assign(r0390, less(r03A3, body.constant(0u)), 0x01));


               body.instructions = f039F_parent_instructions;
               body.emit(f039F);

               /* END IF */


            body.instructions = f039C_parent_instructions;
            body.emit(f039C);

            /* END IF */


         body.instructions = f0392_parent_instructions;
         body.emit(f0392);

         /* END IF */

         /* IF CONDITION */
         ir_if *f03BB = new(mem_ctx) ir_if(operand(r038E).val);
         exec_list *const f03BB_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03BB->then_instructions;

            /* IF CONDITION */
            ir_if *f03BC = new(mem_ctx) ir_if(operand(r0390).val);
            exec_list *const f03BC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f03BC->then_instructions;

               ir_variable *const r03BD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r03BD, add(r038C, body.constant(1u)), 0x01));

               ir_expression *const r03BE = less(r03BD, r038C);
               ir_expression *const r03BF = expr(ir_unop_b2i, r03BE);
               ir_expression *const r03C0 = expr(ir_unop_i2u, r03BF);
               body.emit(assign(r038B, add(r038B, r03C0), 0x01));

               ir_expression *const r03C1 = equal(r038D, body.constant(0u));
               ir_expression *const r03C2 = expr(ir_unop_b2i, r03C1);
               ir_expression *const r03C3 = expr(ir_unop_i2u, r03C2);
               ir_expression *const r03C4 = add(r038D, r03C3);
               ir_expression *const r03C5 = bit_and(r03C4, body.constant(1u));
               ir_expression *const r03C6 = expr(ir_unop_bit_not, r03C5);
               body.emit(assign(r038C, bit_and(r03BD, r03C6), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f03BC->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03C8 = bit_or(r038B, r038C);
               ir_expression *const r03C9 = equal(r03C8, body.constant(0u));
               ir_if *f03C7 = new(mem_ctx) ir_if(operand(r03C9).val);
               exec_list *const f03C7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03C7->then_instructions;

                  body.emit(assign(r038A, body.constant(int(0)), 0x01));


               body.instructions = f03C7_parent_instructions;
               body.emit(f03C7);

               /* END IF */


            body.instructions = f03BC_parent_instructions;
            body.emit(f03BC);

            /* END IF */

            ir_variable *const r03CA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r03CA);
            ir_expression *const r03CB = lshift(r0225, body.constant(int(31)));
            ir_expression *const r03CC = expr(ir_unop_i2u, r038A);
            ir_expression *const r03CD = lshift(r03CC, body.constant(int(20)));
            ir_expression *const r03CE = add(r03CB, r03CD);
            body.emit(assign(r03CA, add(r03CE, r038B), 0x02));

            body.emit(assign(r03CA, r038C, 0x01));

            body.emit(assign(r038F, r03CA, 0x03));

            body.emit(assign(r038E, body.constant(false), 0x01));


         body.instructions = f03BB_parent_instructions;
         body.emit(f03BB);

         /* END IF */

         body.emit(assign(r0227, r038F, 0x03));

         body.emit(assign(r0226, body.constant(false), 0x01));


      body.instructions = f033B_parent_instructions;
      body.emit(f033B);

      /* END IF */


   body.instructions = f0334_parent_instructions;
   body.emit(f0334);

   /* END IF */

   body.emit(ret(r0227));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
subFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r03CF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r03CF);
   ir_variable *const r03D0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r03D0);
   ir_variable *const r03D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r03D1);
   ir_variable *const r03D2 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r03D3 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r03D3);
   ir_variable *const r03D4 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r03D4);
   ir_variable *const r03D5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r03D5);
   ir_variable *const r03D6 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r03D6);
   ir_variable *const r03D7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r03D7);
   ir_variable *const r03D8 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r03D8);
   ir_variable *const r03D9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r03D9);
   body.emit(assign(r03D9, bit_and(swizzle_y(r03CF), body.constant(1048575u)), 0x02));

   body.emit(assign(r03D9, swizzle_x(r03CF), 0x01));

   ir_variable *const r03DA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03DB = rshift(swizzle_y(r03CF), body.constant(int(20)));
   ir_expression *const r03DC = bit_and(r03DB, body.constant(2047u));
   body.emit(assign(r03DA, expr(ir_unop_u2i, r03DC), 0x01));

   body.emit(assign(r03D6, r03DA, 0x01));

   ir_variable *const r03DD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r03DD);
   body.emit(assign(r03DD, bit_and(swizzle_y(r03D0), body.constant(1048575u)), 0x02));

   body.emit(assign(r03DD, swizzle_x(r03D0), 0x01));

   ir_variable *const r03DE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03DF = rshift(swizzle_y(r03D0), body.constant(int(20)));
   ir_expression *const r03E0 = bit_and(r03DF, body.constant(2047u));
   body.emit(assign(r03DE, expr(ir_unop_u2i, r03E0), 0x01));

   body.emit(assign(r03D4, r03DE, 0x01));

   body.emit(assign(r03D3, sub(r03DA, r03DE), 0x01));

   ir_variable *const r03E1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E1, lshift(swizzle_x(r03CF), body.constant(int(10))), 0x01));

   ir_variable *const r03E2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03E3 = lshift(swizzle_y(r03D9), body.constant(int(10)));
   ir_expression *const r03E4 = rshift(swizzle_x(r03CF), body.constant(int(22)));
   body.emit(assign(r03E2, bit_or(r03E3, r03E4), 0x01));

   body.emit(assign(r03D7, r03E2, 0x02));

   body.emit(assign(r03D7, r03E1, 0x01));

   ir_variable *const r03E5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E5, lshift(swizzle_x(r03D0), body.constant(int(10))), 0x01));

   ir_variable *const r03E6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03E7 = lshift(swizzle_y(r03DD), body.constant(int(10)));
   ir_expression *const r03E8 = rshift(swizzle_x(r03D0), body.constant(int(22)));
   body.emit(assign(r03E6, bit_or(r03E7, r03E8), 0x01));

   body.emit(assign(r03D5, r03E6, 0x02));

   body.emit(assign(r03D5, r03E5, 0x01));

   /* IF CONDITION */
   ir_expression *const r03EA = less(body.constant(int(0)), r03D3);
   ir_if *f03E9 = new(mem_ctx) ir_if(operand(r03EA).val);
   exec_list *const f03E9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f03E9->then_instructions;

      /* IF CONDITION */
      ir_expression *const r03EC = equal(r03DA, body.constant(int(2047)));
      ir_if *f03EB = new(mem_ctx) ir_if(operand(r03EC).val);
      exec_list *const f03EB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f03EB->then_instructions;

         /* IF CONDITION */
         ir_expression *const r03EE = bit_or(r03E2, r03E1);
         ir_expression *const r03EF = nequal(r03EE, body.constant(0u));
         ir_if *f03ED = new(mem_ctx) ir_if(operand(r03EF).val);
         exec_list *const f03ED_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03ED->then_instructions;

            ir_variable *const r03F0 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r03F0, swizzle_x(r03CF), 0x01));

            ir_variable *const r03F1 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r03F1, swizzle_x(r03D0), 0x01));

            ir_variable *const r03F2 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r03F3 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r03F4 = rshift(swizzle_y(r03CF), body.constant(int(19)));
            ir_expression *const r03F5 = bit_and(r03F4, body.constant(4095u));
            ir_expression *const r03F6 = equal(r03F5, body.constant(4094u));
            ir_expression *const r03F7 = nequal(swizzle_x(r03CF), body.constant(0u));
            ir_expression *const r03F8 = bit_and(swizzle_y(r03CF), body.constant(524287u));
            ir_expression *const r03F9 = nequal(r03F8, body.constant(0u));
            ir_expression *const r03FA = logic_or(r03F7, r03F9);
            body.emit(assign(r03F3, logic_and(r03F6, r03FA), 0x01));

            ir_variable *const r03FB = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r03FC = lshift(swizzle_y(r03D0), body.constant(int(1)));
            ir_expression *const r03FD = lequal(body.constant(4292870144u), r03FC);
            ir_expression *const r03FE = nequal(swizzle_x(r03D0), body.constant(0u));
            ir_expression *const r03FF = bit_and(swizzle_y(r03D0), body.constant(1048575u));
            ir_expression *const r0400 = nequal(r03FF, body.constant(0u));
            ir_expression *const r0401 = logic_or(r03FE, r0400);
            body.emit(assign(r03FB, logic_and(r03FD, r0401), 0x01));

            body.emit(assign(r03F0, bit_or(swizzle_y(r03CF), body.constant(524288u)), 0x02));

            body.emit(assign(r03F1, bit_or(swizzle_y(r03D0), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0403 = lshift(swizzle_y(r03CF), body.constant(int(1)));
            ir_expression *const r0404 = lequal(body.constant(4292870144u), r0403);
            ir_expression *const r0405 = nequal(swizzle_x(r03CF), body.constant(0u));
            ir_expression *const r0406 = bit_and(swizzle_y(r03CF), body.constant(1048575u));
            ir_expression *const r0407 = nequal(r0406, body.constant(0u));
            ir_expression *const r0408 = logic_or(r0405, r0407);
            ir_expression *const r0409 = logic_and(r0404, r0408);
            ir_if *f0402 = new(mem_ctx) ir_if(operand(r0409).val);
            exec_list *const f0402_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0402->then_instructions;

               ir_variable *const r040A = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r040C = logic_and(r03F3, r03FB);
               ir_if *f040B = new(mem_ctx) ir_if(operand(r040C).val);
               exec_list *const f040B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f040B->then_instructions;

                  body.emit(assign(r040A, r03F1, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f040B->else_instructions;

                  body.emit(assign(r040A, r03F0, 0x03));


               body.instructions = f040B_parent_instructions;
               body.emit(f040B);

               /* END IF */

               body.emit(assign(r03F2, r040A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0402->else_instructions;

               body.emit(assign(r03F2, r03F1, 0x03));


            body.instructions = f0402_parent_instructions;
            body.emit(f0402);

            /* END IF */

            body.emit(assign(r03D2, r03F2, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f03ED->else_instructions;

            body.emit(assign(r03D2, r03CF, 0x03));


         body.instructions = f03ED_parent_instructions;
         body.emit(f03ED);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f03EB->else_instructions;

         /* IF CONDITION */
         ir_expression *const r040E = equal(r03DE, body.constant(int(0)));
         ir_if *f040D = new(mem_ctx) ir_if(operand(r040E).val);
         exec_list *const f040D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f040D->then_instructions;

            body.emit(assign(r03D3, add(r03D3, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f040D->else_instructions;

            body.emit(assign(r03D5, bit_or(r03E6, body.constant(1073741824u)), 0x02));


         body.instructions = f040D_parent_instructions;
         body.emit(f040D);

         /* END IF */

         ir_variable *const r040F = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r040F, swizzle_y(r03D5), 0x01));

         ir_variable *const r0410 = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r0410, swizzle_x(r03D5), 0x01));

         ir_variable *const r0411 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0411);
         ir_variable *const r0412 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0412);
         ir_variable *const r0413 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0414 = neg(r03D3);
         body.emit(assign(r0413, bit_and(r0414, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0416 = equal(r03D3, body.constant(int(0)));
         ir_if *f0415 = new(mem_ctx) ir_if(operand(r0416).val);
         exec_list *const f0415_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0415->then_instructions;

            body.emit(assign(r0411, r0410, 0x01));

            body.emit(assign(r0412, r040F, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0415->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0418 = less(r03D3, body.constant(int(32)));
            ir_if *f0417 = new(mem_ctx) ir_if(operand(r0418).val);
            exec_list *const f0417_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0417->then_instructions;

               ir_expression *const r0419 = lshift(swizzle_y(r03D5), r0413);
               ir_expression *const r041A = rshift(r03E5, r03D3);
               ir_expression *const r041B = bit_or(r0419, r041A);
               ir_expression *const r041C = lshift(r03E5, r0413);
               ir_expression *const r041D = nequal(r041C, body.constant(0u));
               ir_expression *const r041E = expr(ir_unop_b2i, r041D);
               ir_expression *const r041F = expr(ir_unop_i2u, r041E);
               body.emit(assign(r0411, bit_or(r041B, r041F), 0x01));

               body.emit(assign(r0412, rshift(swizzle_y(r03D5), r03D3), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0417->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0421 = equal(r03D3, body.constant(int(32)));
               ir_if *f0420 = new(mem_ctx) ir_if(operand(r0421).val);
               exec_list *const f0420_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0420->then_instructions;

                  ir_expression *const r0422 = nequal(r03E5, body.constant(0u));
                  ir_expression *const r0423 = expr(ir_unop_b2i, r0422);
                  ir_expression *const r0424 = expr(ir_unop_i2u, r0423);
                  body.emit(assign(r0411, bit_or(swizzle_y(r03D5), r0424), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0420->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0426 = less(r03D3, body.constant(int(64)));
                  ir_if *f0425 = new(mem_ctx) ir_if(operand(r0426).val);
                  exec_list *const f0425_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0425->then_instructions;

                     ir_expression *const r0427 = bit_and(r03D3, body.constant(int(31)));
                     ir_expression *const r0428 = rshift(swizzle_y(r03D5), r0427);
                     ir_expression *const r0429 = lshift(swizzle_y(r03D5), r0413);
                     ir_expression *const r042A = bit_or(r0429, r03E5);
                     ir_expression *const r042B = nequal(r042A, body.constant(0u));
                     ir_expression *const r042C = expr(ir_unop_b2i, r042B);
                     ir_expression *const r042D = expr(ir_unop_i2u, r042C);
                     body.emit(assign(r0411, bit_or(r0428, r042D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0425->else_instructions;

                     ir_expression *const r042E = bit_or(swizzle_y(r03D5), r03E5);
                     ir_expression *const r042F = nequal(r042E, body.constant(0u));
                     ir_expression *const r0430 = expr(ir_unop_b2i, r042F);
                     body.emit(assign(r0411, expr(ir_unop_i2u, r0430), 0x01));


                  body.instructions = f0425_parent_instructions;
                  body.emit(f0425);

                  /* END IF */


               body.instructions = f0420_parent_instructions;
               body.emit(f0420);

               /* END IF */

               body.emit(assign(r0412, body.constant(0u), 0x01));


            body.instructions = f0417_parent_instructions;
            body.emit(f0417);

            /* END IF */


         body.instructions = f0415_parent_instructions;
         body.emit(f0415);

         /* END IF */

         body.emit(assign(r03D5, r0412, 0x02));

         body.emit(assign(r03D5, r0411, 0x01));

         body.emit(assign(r03D7, bit_or(r03E2, body.constant(1073741824u)), 0x02));

         ir_variable *const r0431 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0432 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r0432, sub(r03E1, r0411), 0x01));

         ir_expression *const r0433 = sub(swizzle_y(r03D7), r0412);
         ir_expression *const r0434 = less(r03E1, r0411);
         ir_expression *const r0435 = expr(ir_unop_b2i, r0434);
         ir_expression *const r0436 = expr(ir_unop_i2u, r0435);
         body.emit(assign(r0431, sub(r0433, r0436), 0x01));

         body.emit(assign(r03D8, add(r03DA, body.constant(int(-1))), 0x01));

         ir_variable *const r0437 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0437, add(r03D8, body.constant(int(-10))), 0x01));

         ir_variable *const r0438 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0438, r0431, 0x01));

         ir_variable *const r0439 = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r0439, r0432, 0x01));

         ir_variable *const r043A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r043A);
         ir_variable *const r043B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r043B);
         /* IF CONDITION */
         ir_expression *const r043D = equal(r0431, body.constant(0u));
         ir_if *f043C = new(mem_ctx) ir_if(operand(r043D).val);
         exec_list *const f043C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f043C->then_instructions;

            body.emit(assign(r0438, r0432, 0x01));

            body.emit(assign(r0439, body.constant(0u), 0x01));

            body.emit(assign(r0437, add(r0437, body.constant(int(-32))), 0x01));


         body.instructions = f043C_parent_instructions;
         body.emit(f043C);

         /* END IF */

         ir_variable *const r043E = body.make_temp(glsl_type::uint_type, "a");
         body.emit(assign(r043E, r0438, 0x01));

         ir_variable *const r043F = body.make_temp(glsl_type::int_type, "return_value");
         ir_variable *const r0440 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r0440);
         /* IF CONDITION */
         ir_expression *const r0442 = equal(r0438, body.constant(0u));
         ir_if *f0441 = new(mem_ctx) ir_if(operand(r0442).val);
         exec_list *const f0441_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0441->then_instructions;

            body.emit(assign(r043F, body.constant(int(32)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0441->else_instructions;

            body.emit(assign(r0440, body.constant(int(0)), 0x01));

            /* IF CONDITION */
            ir_expression *const r0444 = bit_and(r0438, body.constant(4294901760u));
            ir_expression *const r0445 = equal(r0444, body.constant(0u));
            ir_if *f0443 = new(mem_ctx) ir_if(operand(r0445).val);
            exec_list *const f0443_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0443->then_instructions;

               body.emit(assign(r0440, body.constant(int(16)), 0x01));

               body.emit(assign(r043E, lshift(r0438, body.constant(int(16))), 0x01));


            body.instructions = f0443_parent_instructions;
            body.emit(f0443);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0447 = bit_and(r043E, body.constant(4278190080u));
            ir_expression *const r0448 = equal(r0447, body.constant(0u));
            ir_if *f0446 = new(mem_ctx) ir_if(operand(r0448).val);
            exec_list *const f0446_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0446->then_instructions;

               body.emit(assign(r0440, add(r0440, body.constant(int(8))), 0x01));

               body.emit(assign(r043E, lshift(r043E, body.constant(int(8))), 0x01));


            body.instructions = f0446_parent_instructions;
            body.emit(f0446);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044A = bit_and(r043E, body.constant(4026531840u));
            ir_expression *const r044B = equal(r044A, body.constant(0u));
            ir_if *f0449 = new(mem_ctx) ir_if(operand(r044B).val);
            exec_list *const f0449_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0449->then_instructions;

               body.emit(assign(r0440, add(r0440, body.constant(int(4))), 0x01));

               body.emit(assign(r043E, lshift(r043E, body.constant(int(4))), 0x01));


            body.instructions = f0449_parent_instructions;
            body.emit(f0449);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044D = bit_and(r043E, body.constant(3221225472u));
            ir_expression *const r044E = equal(r044D, body.constant(0u));
            ir_if *f044C = new(mem_ctx) ir_if(operand(r044E).val);
            exec_list *const f044C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044C->then_instructions;

               body.emit(assign(r0440, add(r0440, body.constant(int(2))), 0x01));

               body.emit(assign(r043E, lshift(r043E, body.constant(int(2))), 0x01));


            body.instructions = f044C_parent_instructions;
            body.emit(f044C);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0450 = bit_and(r043E, body.constant(2147483648u));
            ir_expression *const r0451 = equal(r0450, body.constant(0u));
            ir_if *f044F = new(mem_ctx) ir_if(operand(r0451).val);
            exec_list *const f044F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044F->then_instructions;

               body.emit(assign(r0440, add(r0440, body.constant(int(1))), 0x01));


            body.instructions = f044F_parent_instructions;
            body.emit(f044F);

            /* END IF */

            body.emit(assign(r043F, r0440, 0x01));


         body.instructions = f0441_parent_instructions;
         body.emit(f0441);

         /* END IF */

         body.emit(assign(r043B, add(r043F, body.constant(int(-11))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0453 = lequal(body.constant(int(0)), r043B);
         ir_if *f0452 = new(mem_ctx) ir_if(operand(r0453).val);
         exec_list *const f0452_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0452->then_instructions;

            body.emit(assign(r043A, body.constant(0u), 0x01));

            ir_variable *const r0454 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0454, lshift(r0439, r043B), 0x01));

            ir_variable *const r0455 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r0457 = equal(r043B, body.constant(int(0)));
            ir_if *f0456 = new(mem_ctx) ir_if(operand(r0457).val);
            exec_list *const f0456_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0456->then_instructions;

               body.emit(assign(r0455, r0438, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0456->else_instructions;

               ir_expression *const r0458 = lshift(r0438, r043B);
               ir_expression *const r0459 = neg(r043B);
               ir_expression *const r045A = bit_and(r0459, body.constant(int(31)));
               ir_expression *const r045B = rshift(r0439, r045A);
               body.emit(assign(r0455, bit_or(r0458, r045B), 0x01));


            body.instructions = f0456_parent_instructions;
            body.emit(f0456);

            /* END IF */

            body.emit(assign(r0438, r0455, 0x01));

            body.emit(assign(r0439, r0454, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0452->else_instructions;

            ir_variable *const r045C = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r045C, body.constant(0u), 0x01));

            ir_variable *const r045D = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r045D, neg(r043B), 0x01));

            ir_variable *const r045E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r045E);
            ir_variable *const r045F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r045F);
            ir_variable *const r0460 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0460);
            ir_variable *const r0461 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0462 = neg(r045D);
            body.emit(assign(r0461, bit_and(r0462, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0464 = equal(r045D, body.constant(int(0)));
            ir_if *f0463 = new(mem_ctx) ir_if(operand(r0464).val);
            exec_list *const f0463_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0463->then_instructions;

               body.emit(assign(r045E, r045C, 0x01));

               body.emit(assign(r045F, r0439, 0x01));

               body.emit(assign(r0460, r0438, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0463->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0466 = less(r045D, body.constant(int(32)));
               ir_if *f0465 = new(mem_ctx) ir_if(operand(r0466).val);
               exec_list *const f0465_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0465->then_instructions;

                  body.emit(assign(r045E, lshift(r0439, r0461), 0x01));

                  ir_expression *const r0467 = lshift(r0438, r0461);
                  ir_expression *const r0468 = rshift(r0439, r045D);
                  body.emit(assign(r045F, bit_or(r0467, r0468), 0x01));

                  body.emit(assign(r0460, rshift(r0438, r045D), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0465->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r046A = equal(r045D, body.constant(int(32)));
                  ir_if *f0469 = new(mem_ctx) ir_if(operand(r046A).val);
                  exec_list *const f0469_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0469->then_instructions;

                     body.emit(assign(r045E, r0439, 0x01));

                     body.emit(assign(r045F, r0438, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0469->else_instructions;

                     body.emit(assign(r045C, bit_or(body.constant(0u), r0439), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r046C = less(r045D, body.constant(int(64)));
                     ir_if *f046B = new(mem_ctx) ir_if(operand(r046C).val);
                     exec_list *const f046B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f046B->then_instructions;

                        body.emit(assign(r045E, lshift(r0438, r0461), 0x01));

                        ir_expression *const r046D = bit_and(r045D, body.constant(int(31)));
                        body.emit(assign(r045F, rshift(r0438, r046D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f046B->else_instructions;

                        ir_variable *const r046E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0470 = equal(r045D, body.constant(int(64)));
                        ir_if *f046F = new(mem_ctx) ir_if(operand(r0470).val);
                        exec_list *const f046F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f046F->then_instructions;

                           body.emit(assign(r046E, r0438, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f046F->else_instructions;

                           ir_expression *const r0471 = nequal(r0438, body.constant(0u));
                           ir_expression *const r0472 = expr(ir_unop_b2i, r0471);
                           body.emit(assign(r046E, expr(ir_unop_i2u, r0472), 0x01));


                        body.instructions = f046F_parent_instructions;
                        body.emit(f046F);

                        /* END IF */

                        body.emit(assign(r045E, r046E, 0x01));

                        body.emit(assign(r045F, body.constant(0u), 0x01));


                     body.instructions = f046B_parent_instructions;
                     body.emit(f046B);

                     /* END IF */


                  body.instructions = f0469_parent_instructions;
                  body.emit(f0469);

                  /* END IF */

                  body.emit(assign(r0460, body.constant(0u), 0x01));


               body.instructions = f0465_parent_instructions;
               body.emit(f0465);

               /* END IF */

               ir_expression *const r0473 = nequal(r045C, body.constant(0u));
               ir_expression *const r0474 = expr(ir_unop_b2i, r0473);
               ir_expression *const r0475 = expr(ir_unop_i2u, r0474);
               body.emit(assign(r045E, bit_or(r045E, r0475), 0x01));


            body.instructions = f0463_parent_instructions;
            body.emit(f0463);

            /* END IF */

            body.emit(assign(r0438, r0460, 0x01));

            body.emit(assign(r0439, r045F, 0x01));

            body.emit(assign(r043A, r045E, 0x01));


         body.instructions = f0452_parent_instructions;
         body.emit(f0452);

         /* END IF */

         body.emit(assign(r0437, sub(r0437, r043B), 0x01));

         ir_variable *const r0476 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0476, r0437, 0x01));

         ir_variable *const r0477 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0477, r0438, 0x01));

         ir_variable *const r0478 = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r0478, r0439, 0x01));

         ir_variable *const r0479 = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r0479, r043A, 0x01));

         ir_variable *const r047A = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r047A, body.constant(true), 0x01));

         ir_variable *const r047B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r047C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r047C);
         ir_expression *const r047D = expr(ir_unop_u2i, r043A);
         body.emit(assign(r047C, less(r047D, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r047F = lequal(body.constant(int(2045)), r0437);
         ir_if *f047E = new(mem_ctx) ir_if(operand(r047F).val);
         exec_list *const f047E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f047E->then_instructions;

            ir_variable *const r0480 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0482 = less(body.constant(int(2045)), r0437);
            ir_if *f0481 = new(mem_ctx) ir_if(operand(r0482).val);
            exec_list *const f0481_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0481->then_instructions;

               body.emit(assign(r0480, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0481->else_instructions;

               ir_variable *const r0483 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r0485 = equal(r0437, body.constant(int(2045)));
               ir_if *f0484 = new(mem_ctx) ir_if(operand(r0485).val);
               exec_list *const f0484_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0484->then_instructions;

                  ir_expression *const r0486 = equal(body.constant(2097151u), r0438);
                  ir_expression *const r0487 = equal(body.constant(4294967295u), r0439);
                  body.emit(assign(r0483, logic_and(r0486, r0487), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0484->else_instructions;

                  body.emit(assign(r0483, body.constant(false), 0x01));


               body.instructions = f0484_parent_instructions;
               body.emit(f0484);

               /* END IF */

               body.emit(assign(r0480, logic_and(r0483, r047C), 0x01));


            body.instructions = f0481_parent_instructions;
            body.emit(f0481);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0488 = new(mem_ctx) ir_if(operand(r0480).val);
            exec_list *const f0488_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0488->then_instructions;

               ir_variable *const r0489 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0489);
               ir_expression *const r048A = lshift(r03D1, body.constant(int(31)));
               body.emit(assign(r0489, add(r048A, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0489, body.constant(0u), 0x01));

               body.emit(assign(r047B, r0489, 0x03));

               body.emit(assign(r047A, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0488->else_instructions;

               /* IF CONDITION */
               ir_expression *const r048C = less(r0437, body.constant(int(0)));
               ir_if *f048B = new(mem_ctx) ir_if(operand(r048C).val);
               exec_list *const f048B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f048B->then_instructions;

                  ir_variable *const r048D = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r048D, r043A, 0x01));

                  ir_variable *const r048E = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r048E, neg(r0437), 0x01));

                  ir_variable *const r048F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r048F);
                  ir_variable *const r0490 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0490);
                  ir_variable *const r0491 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0491);
                  ir_variable *const r0492 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0493 = neg(r048E);
                  body.emit(assign(r0492, bit_and(r0493, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0495 = equal(r048E, body.constant(int(0)));
                  ir_if *f0494 = new(mem_ctx) ir_if(operand(r0495).val);
                  exec_list *const f0494_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0494->then_instructions;

                     body.emit(assign(r048F, r043A, 0x01));

                     body.emit(assign(r0490, r0439, 0x01));

                     body.emit(assign(r0491, r0438, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0494->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0497 = less(r048E, body.constant(int(32)));
                     ir_if *f0496 = new(mem_ctx) ir_if(operand(r0497).val);
                     exec_list *const f0496_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0496->then_instructions;

                        body.emit(assign(r048F, lshift(r0439, r0492), 0x01));

                        ir_expression *const r0498 = lshift(r0438, r0492);
                        ir_expression *const r0499 = rshift(r0439, r048E);
                        body.emit(assign(r0490, bit_or(r0498, r0499), 0x01));

                        body.emit(assign(r0491, rshift(r0438, r048E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0496->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r049B = equal(r048E, body.constant(int(32)));
                        ir_if *f049A = new(mem_ctx) ir_if(operand(r049B).val);
                        exec_list *const f049A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f049A->then_instructions;

                           body.emit(assign(r048F, r0439, 0x01));

                           body.emit(assign(r0490, r0438, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f049A->else_instructions;

                           body.emit(assign(r048D, bit_or(r043A, r0439), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r049D = less(r048E, body.constant(int(64)));
                           ir_if *f049C = new(mem_ctx) ir_if(operand(r049D).val);
                           exec_list *const f049C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f049C->then_instructions;

                              body.emit(assign(r048F, lshift(r0438, r0492), 0x01));

                              ir_expression *const r049E = bit_and(r048E, body.constant(int(31)));
                              body.emit(assign(r0490, rshift(r0438, r049E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f049C->else_instructions;

                              ir_variable *const r049F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r04A1 = equal(r048E, body.constant(int(64)));
                              ir_if *f04A0 = new(mem_ctx) ir_if(operand(r04A1).val);
                              exec_list *const f04A0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f04A0->then_instructions;

                                 body.emit(assign(r049F, r0438, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f04A0->else_instructions;

                                 ir_expression *const r04A2 = nequal(r0438, body.constant(0u));
                                 ir_expression *const r04A3 = expr(ir_unop_b2i, r04A2);
                                 body.emit(assign(r049F, expr(ir_unop_i2u, r04A3), 0x01));


                              body.instructions = f04A0_parent_instructions;
                              body.emit(f04A0);

                              /* END IF */

                              body.emit(assign(r048F, r049F, 0x01));

                              body.emit(assign(r0490, body.constant(0u), 0x01));


                           body.instructions = f049C_parent_instructions;
                           body.emit(f049C);

                           /* END IF */


                        body.instructions = f049A_parent_instructions;
                        body.emit(f049A);

                        /* END IF */

                        body.emit(assign(r0491, body.constant(0u), 0x01));


                     body.instructions = f0496_parent_instructions;
                     body.emit(f0496);

                     /* END IF */

                     ir_expression *const r04A4 = nequal(r048D, body.constant(0u));
                     ir_expression *const r04A5 = expr(ir_unop_b2i, r04A4);
                     ir_expression *const r04A6 = expr(ir_unop_i2u, r04A5);
                     body.emit(assign(r048F, bit_or(r048F, r04A6), 0x01));


                  body.instructions = f0494_parent_instructions;
                  body.emit(f0494);

                  /* END IF */

                  body.emit(assign(r0477, r0491, 0x01));

                  body.emit(assign(r0478, r0490, 0x01));

                  body.emit(assign(r0479, r048F, 0x01));

                  body.emit(assign(r0476, body.constant(int(0)), 0x01));

                  body.emit(assign(r047C, less(r048F, body.constant(0u)), 0x01));


               body.instructions = f048B_parent_instructions;
               body.emit(f048B);

               /* END IF */


            body.instructions = f0488_parent_instructions;
            body.emit(f0488);

            /* END IF */


         body.instructions = f047E_parent_instructions;
         body.emit(f047E);

         /* END IF */

         /* IF CONDITION */
         ir_if *f04A7 = new(mem_ctx) ir_if(operand(r047A).val);
         exec_list *const f04A7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04A7->then_instructions;

            /* IF CONDITION */
            ir_if *f04A8 = new(mem_ctx) ir_if(operand(r047C).val);
            exec_list *const f04A8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04A8->then_instructions;

               ir_variable *const r04A9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r04A9, add(r0478, body.constant(1u)), 0x01));

               ir_expression *const r04AA = less(r04A9, r0478);
               ir_expression *const r04AB = expr(ir_unop_b2i, r04AA);
               ir_expression *const r04AC = expr(ir_unop_i2u, r04AB);
               body.emit(assign(r0477, add(r0477, r04AC), 0x01));

               ir_expression *const r04AD = equal(r0479, body.constant(0u));
               ir_expression *const r04AE = expr(ir_unop_b2i, r04AD);
               ir_expression *const r04AF = expr(ir_unop_i2u, r04AE);
               ir_expression *const r04B0 = add(r0479, r04AF);
               ir_expression *const r04B1 = bit_and(r04B0, body.constant(1u));
               ir_expression *const r04B2 = expr(ir_unop_bit_not, r04B1);
               body.emit(assign(r0478, bit_and(r04A9, r04B2), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04A8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04B4 = bit_or(r0477, r0478);
               ir_expression *const r04B5 = equal(r04B4, body.constant(0u));
               ir_if *f04B3 = new(mem_ctx) ir_if(operand(r04B5).val);
               exec_list *const f04B3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04B3->then_instructions;

                  body.emit(assign(r0476, body.constant(int(0)), 0x01));


               body.instructions = f04B3_parent_instructions;
               body.emit(f04B3);

               /* END IF */


            body.instructions = f04A8_parent_instructions;
            body.emit(f04A8);

            /* END IF */

            ir_variable *const r04B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r04B6);
            ir_expression *const r04B7 = lshift(r03D1, body.constant(int(31)));
            ir_expression *const r04B8 = expr(ir_unop_i2u, r0476);
            ir_expression *const r04B9 = lshift(r04B8, body.constant(int(20)));
            ir_expression *const r04BA = add(r04B7, r04B9);
            body.emit(assign(r04B6, add(r04BA, r0477), 0x02));

            body.emit(assign(r04B6, r0478, 0x01));

            body.emit(assign(r047B, r04B6, 0x03));

            body.emit(assign(r047A, body.constant(false), 0x01));


         body.instructions = f04A7_parent_instructions;
         body.emit(f04A7);

         /* END IF */

         body.emit(assign(r03D2, r047B, 0x03));


      body.instructions = f03EB_parent_instructions;
      body.emit(f03EB);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f03E9->else_instructions;

      /* IF CONDITION */
      ir_expression *const r04BC = less(r03D3, body.constant(int(0)));
      ir_if *f04BB = new(mem_ctx) ir_if(operand(r04BC).val);
      exec_list *const f04BB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f04BB->then_instructions;

         /* IF CONDITION */
         ir_expression *const r04BE = equal(r03DE, body.constant(int(2047)));
         ir_if *f04BD = new(mem_ctx) ir_if(operand(r04BE).val);
         exec_list *const f04BD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04BD->then_instructions;

            /* IF CONDITION */
            ir_expression *const r04C0 = bit_or(swizzle_y(r03D5), swizzle_x(r03D5));
            ir_expression *const r04C1 = nequal(r04C0, body.constant(0u));
            ir_if *f04BF = new(mem_ctx) ir_if(operand(r04C1).val);
            exec_list *const f04BF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04BF->then_instructions;

               ir_variable *const r04C2 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r04C2, swizzle_x(r03CF), 0x01));

               ir_variable *const r04C3 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r04C3, swizzle_x(r03D0), 0x01));

               ir_variable *const r04C4 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r04C5 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r04C6 = rshift(swizzle_y(r03CF), body.constant(int(19)));
               ir_expression *const r04C7 = bit_and(r04C6, body.constant(4095u));
               ir_expression *const r04C8 = equal(r04C7, body.constant(4094u));
               ir_expression *const r04C9 = nequal(swizzle_x(r03CF), body.constant(0u));
               ir_expression *const r04CA = bit_and(swizzle_y(r03CF), body.constant(524287u));
               ir_expression *const r04CB = nequal(r04CA, body.constant(0u));
               ir_expression *const r04CC = logic_or(r04C9, r04CB);
               body.emit(assign(r04C5, logic_and(r04C8, r04CC), 0x01));

               ir_variable *const r04CD = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r04CE = lshift(swizzle_y(r03D0), body.constant(int(1)));
               ir_expression *const r04CF = lequal(body.constant(4292870144u), r04CE);
               ir_expression *const r04D0 = nequal(swizzle_x(r03D0), body.constant(0u));
               ir_expression *const r04D1 = bit_and(swizzle_y(r03D0), body.constant(1048575u));
               ir_expression *const r04D2 = nequal(r04D1, body.constant(0u));
               ir_expression *const r04D3 = logic_or(r04D0, r04D2);
               body.emit(assign(r04CD, logic_and(r04CF, r04D3), 0x01));

               body.emit(assign(r04C2, bit_or(swizzle_y(r03CF), body.constant(524288u)), 0x02));

               body.emit(assign(r04C3, bit_or(swizzle_y(r03D0), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r04D5 = lshift(swizzle_y(r03CF), body.constant(int(1)));
               ir_expression *const r04D6 = lequal(body.constant(4292870144u), r04D5);
               ir_expression *const r04D7 = nequal(swizzle_x(r03CF), body.constant(0u));
               ir_expression *const r04D8 = bit_and(swizzle_y(r03CF), body.constant(1048575u));
               ir_expression *const r04D9 = nequal(r04D8, body.constant(0u));
               ir_expression *const r04DA = logic_or(r04D7, r04D9);
               ir_expression *const r04DB = logic_and(r04D6, r04DA);
               ir_if *f04D4 = new(mem_ctx) ir_if(operand(r04DB).val);
               exec_list *const f04D4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04D4->then_instructions;

                  ir_variable *const r04DC = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r04DE = logic_and(r04C5, r04CD);
                  ir_if *f04DD = new(mem_ctx) ir_if(operand(r04DE).val);
                  exec_list *const f04DD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04DD->then_instructions;

                     body.emit(assign(r04DC, r04C3, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04DD->else_instructions;

                     body.emit(assign(r04DC, r04C2, 0x03));


                  body.instructions = f04DD_parent_instructions;
                  body.emit(f04DD);

                  /* END IF */

                  body.emit(assign(r04C4, r04DC, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04D4->else_instructions;

                  body.emit(assign(r04C4, r04C3, 0x03));


               body.instructions = f04D4_parent_instructions;
               body.emit(f04D4);

               /* END IF */

               body.emit(assign(r03D2, r04C4, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04BF->else_instructions;

               ir_variable *const r04DF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r04DF);
               ir_expression *const r04E0 = bit_xor(r03D1, body.constant(1u));
               ir_expression *const r04E1 = lshift(r04E0, body.constant(int(31)));
               body.emit(assign(r04DF, add(r04E1, body.constant(2146435072u)), 0x02));

               body.emit(assign(r04DF, body.constant(0u), 0x01));

               body.emit(assign(r03D2, r04DF, 0x03));


            body.instructions = f04BF_parent_instructions;
            body.emit(f04BF);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f04BD->else_instructions;

            /* IF CONDITION */
            ir_expression *const r04E3 = equal(r03DA, body.constant(int(0)));
            ir_if *f04E2 = new(mem_ctx) ir_if(operand(r04E3).val);
            exec_list *const f04E2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04E2->then_instructions;

               body.emit(assign(r03D3, add(r03D3, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04E2->else_instructions;

               body.emit(assign(r03D7, bit_or(swizzle_y(r03D7), body.constant(1073741824u)), 0x02));


            body.instructions = f04E2_parent_instructions;
            body.emit(f04E2);

            /* END IF */

            ir_variable *const r04E4 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r04E4, swizzle_y(r03D7), 0x01));

            ir_variable *const r04E5 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r04E5, swizzle_x(r03D7), 0x01));

            ir_variable *const r04E6 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r04E6, neg(r03D3), 0x01));

            ir_variable *const r04E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r04E7);
            ir_variable *const r04E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r04E8);
            ir_variable *const r04E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r04EA = neg(r04E6);
            body.emit(assign(r04E9, bit_and(r04EA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r04EC = equal(r04E6, body.constant(int(0)));
            ir_if *f04EB = new(mem_ctx) ir_if(operand(r04EC).val);
            exec_list *const f04EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04EB->then_instructions;

               body.emit(assign(r04E7, r04E5, 0x01));

               body.emit(assign(r04E8, r04E4, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04EB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04EE = less(r04E6, body.constant(int(32)));
               ir_if *f04ED = new(mem_ctx) ir_if(operand(r04EE).val);
               exec_list *const f04ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04ED->then_instructions;

                  ir_expression *const r04EF = lshift(swizzle_y(r03D7), r04E9);
                  ir_expression *const r04F0 = rshift(r03E1, r04E6);
                  ir_expression *const r04F1 = bit_or(r04EF, r04F0);
                  ir_expression *const r04F2 = lshift(r03E1, r04E9);
                  ir_expression *const r04F3 = nequal(r04F2, body.constant(0u));
                  ir_expression *const r04F4 = expr(ir_unop_b2i, r04F3);
                  ir_expression *const r04F5 = expr(ir_unop_i2u, r04F4);
                  body.emit(assign(r04E7, bit_or(r04F1, r04F5), 0x01));

                  body.emit(assign(r04E8, rshift(swizzle_y(r03D7), r04E6), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04ED->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r04F7 = equal(r04E6, body.constant(int(32)));
                  ir_if *f04F6 = new(mem_ctx) ir_if(operand(r04F7).val);
                  exec_list *const f04F6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04F6->then_instructions;

                     ir_expression *const r04F8 = nequal(r03E1, body.constant(0u));
                     ir_expression *const r04F9 = expr(ir_unop_b2i, r04F8);
                     ir_expression *const r04FA = expr(ir_unop_i2u, r04F9);
                     body.emit(assign(r04E7, bit_or(swizzle_y(r03D7), r04FA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04F6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r04FC = less(r04E6, body.constant(int(64)));
                     ir_if *f04FB = new(mem_ctx) ir_if(operand(r04FC).val);
                     exec_list *const f04FB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f04FB->then_instructions;

                        ir_expression *const r04FD = bit_and(r04E6, body.constant(int(31)));
                        ir_expression *const r04FE = rshift(swizzle_y(r03D7), r04FD);
                        ir_expression *const r04FF = lshift(swizzle_y(r03D7), r04E9);
                        ir_expression *const r0500 = bit_or(r04FF, r03E1);
                        ir_expression *const r0501 = nequal(r0500, body.constant(0u));
                        ir_expression *const r0502 = expr(ir_unop_b2i, r0501);
                        ir_expression *const r0503 = expr(ir_unop_i2u, r0502);
                        body.emit(assign(r04E7, bit_or(r04FE, r0503), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f04FB->else_instructions;

                        ir_expression *const r0504 = bit_or(swizzle_y(r03D7), r03E1);
                        ir_expression *const r0505 = nequal(r0504, body.constant(0u));
                        ir_expression *const r0506 = expr(ir_unop_b2i, r0505);
                        body.emit(assign(r04E7, expr(ir_unop_i2u, r0506), 0x01));


                     body.instructions = f04FB_parent_instructions;
                     body.emit(f04FB);

                     /* END IF */


                  body.instructions = f04F6_parent_instructions;
                  body.emit(f04F6);

                  /* END IF */

                  body.emit(assign(r04E8, body.constant(0u), 0x01));


               body.instructions = f04ED_parent_instructions;
               body.emit(f04ED);

               /* END IF */


            body.instructions = f04EB_parent_instructions;
            body.emit(f04EB);

            /* END IF */

            body.emit(assign(r03D7, r04E8, 0x02));

            body.emit(assign(r03D7, r04E7, 0x01));

            body.emit(assign(r03D5, bit_or(swizzle_y(r03D5), body.constant(1073741824u)), 0x02));

            ir_variable *const r0507 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0508 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0508, sub(swizzle_x(r03D5), r04E7), 0x01));

            ir_expression *const r0509 = sub(swizzle_y(r03D5), r04E8);
            ir_expression *const r050A = less(swizzle_x(r03D5), r04E7);
            ir_expression *const r050B = expr(ir_unop_b2i, r050A);
            ir_expression *const r050C = expr(ir_unop_i2u, r050B);
            body.emit(assign(r0507, sub(r0509, r050C), 0x01));

            body.emit(assign(r03D1, bit_xor(r03D1, body.constant(1u)), 0x01));

            body.emit(assign(r03D8, add(r03DE, body.constant(int(-1))), 0x01));

            ir_variable *const r050D = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r050D, add(r03D8, body.constant(int(-10))), 0x01));

            ir_variable *const r050E = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r050E, r0507, 0x01));

            ir_variable *const r050F = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r050F, r0508, 0x01));

            ir_variable *const r0510 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0510);
            ir_variable *const r0511 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0511);
            /* IF CONDITION */
            ir_expression *const r0513 = equal(r0507, body.constant(0u));
            ir_if *f0512 = new(mem_ctx) ir_if(operand(r0513).val);
            exec_list *const f0512_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0512->then_instructions;

               body.emit(assign(r050E, r0508, 0x01));

               body.emit(assign(r050F, body.constant(0u), 0x01));

               body.emit(assign(r050D, add(r050D, body.constant(int(-32))), 0x01));


            body.instructions = f0512_parent_instructions;
            body.emit(f0512);

            /* END IF */

            ir_variable *const r0514 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0514, r050E, 0x01));

            ir_variable *const r0515 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0516 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0516);
            /* IF CONDITION */
            ir_expression *const r0518 = equal(r050E, body.constant(0u));
            ir_if *f0517 = new(mem_ctx) ir_if(operand(r0518).val);
            exec_list *const f0517_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0517->then_instructions;

               body.emit(assign(r0515, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0517->else_instructions;

               body.emit(assign(r0516, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r051A = bit_and(r050E, body.constant(4294901760u));
               ir_expression *const r051B = equal(r051A, body.constant(0u));
               ir_if *f0519 = new(mem_ctx) ir_if(operand(r051B).val);
               exec_list *const f0519_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0519->then_instructions;

                  body.emit(assign(r0516, body.constant(int(16)), 0x01));

                  body.emit(assign(r0514, lshift(r050E, body.constant(int(16))), 0x01));


               body.instructions = f0519_parent_instructions;
               body.emit(f0519);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r051D = bit_and(r0514, body.constant(4278190080u));
               ir_expression *const r051E = equal(r051D, body.constant(0u));
               ir_if *f051C = new(mem_ctx) ir_if(operand(r051E).val);
               exec_list *const f051C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051C->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(8))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(8))), 0x01));


               body.instructions = f051C_parent_instructions;
               body.emit(f051C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0520 = bit_and(r0514, body.constant(4026531840u));
               ir_expression *const r0521 = equal(r0520, body.constant(0u));
               ir_if *f051F = new(mem_ctx) ir_if(operand(r0521).val);
               exec_list *const f051F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051F->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(4))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(4))), 0x01));


               body.instructions = f051F_parent_instructions;
               body.emit(f051F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0523 = bit_and(r0514, body.constant(3221225472u));
               ir_expression *const r0524 = equal(r0523, body.constant(0u));
               ir_if *f0522 = new(mem_ctx) ir_if(operand(r0524).val);
               exec_list *const f0522_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0522->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(2))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(2))), 0x01));


               body.instructions = f0522_parent_instructions;
               body.emit(f0522);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0526 = bit_and(r0514, body.constant(2147483648u));
               ir_expression *const r0527 = equal(r0526, body.constant(0u));
               ir_if *f0525 = new(mem_ctx) ir_if(operand(r0527).val);
               exec_list *const f0525_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0525->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(1))), 0x01));


               body.instructions = f0525_parent_instructions;
               body.emit(f0525);

               /* END IF */

               body.emit(assign(r0515, r0516, 0x01));


            body.instructions = f0517_parent_instructions;
            body.emit(f0517);

            /* END IF */

            body.emit(assign(r0511, add(r0515, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0529 = lequal(body.constant(int(0)), r0511);
            ir_if *f0528 = new(mem_ctx) ir_if(operand(r0529).val);
            exec_list *const f0528_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0528->then_instructions;

               body.emit(assign(r0510, body.constant(0u), 0x01));

               ir_variable *const r052A = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r052A, lshift(r050F, r0511), 0x01));

               ir_variable *const r052B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r052D = equal(r0511, body.constant(int(0)));
               ir_if *f052C = new(mem_ctx) ir_if(operand(r052D).val);
               exec_list *const f052C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f052C->then_instructions;

                  body.emit(assign(r052B, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f052C->else_instructions;

                  ir_expression *const r052E = lshift(r050E, r0511);
                  ir_expression *const r052F = neg(r0511);
                  ir_expression *const r0530 = bit_and(r052F, body.constant(int(31)));
                  ir_expression *const r0531 = rshift(r050F, r0530);
                  body.emit(assign(r052B, bit_or(r052E, r0531), 0x01));


               body.instructions = f052C_parent_instructions;
               body.emit(f052C);

               /* END IF */

               body.emit(assign(r050E, r052B, 0x01));

               body.emit(assign(r050F, r052A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0528->else_instructions;

               ir_variable *const r0532 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0532, body.constant(0u), 0x01));

               ir_variable *const r0533 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0533, neg(r0511), 0x01));

               ir_variable *const r0534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0534);
               ir_variable *const r0535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0535);
               ir_variable *const r0536 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0536);
               ir_variable *const r0537 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0538 = neg(r0533);
               body.emit(assign(r0537, bit_and(r0538, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r053A = equal(r0533, body.constant(int(0)));
               ir_if *f0539 = new(mem_ctx) ir_if(operand(r053A).val);
               exec_list *const f0539_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0539->then_instructions;

                  body.emit(assign(r0534, r0532, 0x01));

                  body.emit(assign(r0535, r050F, 0x01));

                  body.emit(assign(r0536, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0539->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r053C = less(r0533, body.constant(int(32)));
                  ir_if *f053B = new(mem_ctx) ir_if(operand(r053C).val);
                  exec_list *const f053B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f053B->then_instructions;

                     body.emit(assign(r0534, lshift(r050F, r0537), 0x01));

                     ir_expression *const r053D = lshift(r050E, r0537);
                     ir_expression *const r053E = rshift(r050F, r0533);
                     body.emit(assign(r0535, bit_or(r053D, r053E), 0x01));

                     body.emit(assign(r0536, rshift(r050E, r0533), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f053B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0540 = equal(r0533, body.constant(int(32)));
                     ir_if *f053F = new(mem_ctx) ir_if(operand(r0540).val);
                     exec_list *const f053F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f053F->then_instructions;

                        body.emit(assign(r0534, r050F, 0x01));

                        body.emit(assign(r0535, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f053F->else_instructions;

                        body.emit(assign(r0532, bit_or(body.constant(0u), r050F), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0542 = less(r0533, body.constant(int(64)));
                        ir_if *f0541 = new(mem_ctx) ir_if(operand(r0542).val);
                        exec_list *const f0541_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0541->then_instructions;

                           body.emit(assign(r0534, lshift(r050E, r0537), 0x01));

                           ir_expression *const r0543 = bit_and(r0533, body.constant(int(31)));
                           body.emit(assign(r0535, rshift(r050E, r0543), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0541->else_instructions;

                           ir_variable *const r0544 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0546 = equal(r0533, body.constant(int(64)));
                           ir_if *f0545 = new(mem_ctx) ir_if(operand(r0546).val);
                           exec_list *const f0545_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0545->then_instructions;

                              body.emit(assign(r0544, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0545->else_instructions;

                              ir_expression *const r0547 = nequal(r050E, body.constant(0u));
                              ir_expression *const r0548 = expr(ir_unop_b2i, r0547);
                              body.emit(assign(r0544, expr(ir_unop_i2u, r0548), 0x01));


                           body.instructions = f0545_parent_instructions;
                           body.emit(f0545);

                           /* END IF */

                           body.emit(assign(r0534, r0544, 0x01));

                           body.emit(assign(r0535, body.constant(0u), 0x01));


                        body.instructions = f0541_parent_instructions;
                        body.emit(f0541);

                        /* END IF */


                     body.instructions = f053F_parent_instructions;
                     body.emit(f053F);

                     /* END IF */

                     body.emit(assign(r0536, body.constant(0u), 0x01));


                  body.instructions = f053B_parent_instructions;
                  body.emit(f053B);

                  /* END IF */

                  ir_expression *const r0549 = nequal(r0532, body.constant(0u));
                  ir_expression *const r054A = expr(ir_unop_b2i, r0549);
                  ir_expression *const r054B = expr(ir_unop_i2u, r054A);
                  body.emit(assign(r0534, bit_or(r0534, r054B), 0x01));


               body.instructions = f0539_parent_instructions;
               body.emit(f0539);

               /* END IF */

               body.emit(assign(r050E, r0536, 0x01));

               body.emit(assign(r050F, r0535, 0x01));

               body.emit(assign(r0510, r0534, 0x01));


            body.instructions = f0528_parent_instructions;
            body.emit(f0528);

            /* END IF */

            body.emit(assign(r050D, sub(r050D, r0511), 0x01));

            ir_variable *const r054C = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r054C, r050D, 0x01));

            ir_variable *const r054D = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r054D, r050E, 0x01));

            ir_variable *const r054E = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r054E, r050F, 0x01));

            ir_variable *const r054F = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r054F, r0510, 0x01));

            ir_variable *const r0550 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0550, body.constant(true), 0x01));

            ir_variable *const r0551 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0552 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0552);
            ir_expression *const r0553 = expr(ir_unop_u2i, r0510);
            body.emit(assign(r0552, less(r0553, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0555 = lequal(body.constant(int(2045)), r050D);
            ir_if *f0554 = new(mem_ctx) ir_if(operand(r0555).val);
            exec_list *const f0554_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0554->then_instructions;

               ir_variable *const r0556 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0558 = less(body.constant(int(2045)), r050D);
               ir_if *f0557 = new(mem_ctx) ir_if(operand(r0558).val);
               exec_list *const f0557_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0557->then_instructions;

                  body.emit(assign(r0556, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0557->else_instructions;

                  ir_variable *const r0559 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r055B = equal(r050D, body.constant(int(2045)));
                  ir_if *f055A = new(mem_ctx) ir_if(operand(r055B).val);
                  exec_list *const f055A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f055A->then_instructions;

                     ir_expression *const r055C = equal(body.constant(2097151u), r050E);
                     ir_expression *const r055D = equal(body.constant(4294967295u), r050F);
                     body.emit(assign(r0559, logic_and(r055C, r055D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f055A->else_instructions;

                     body.emit(assign(r0559, body.constant(false), 0x01));


                  body.instructions = f055A_parent_instructions;
                  body.emit(f055A);

                  /* END IF */

                  body.emit(assign(r0556, logic_and(r0559, r0552), 0x01));


               body.instructions = f0557_parent_instructions;
               body.emit(f0557);

               /* END IF */

               /* IF CONDITION */
               ir_if *f055E = new(mem_ctx) ir_if(operand(r0556).val);
               exec_list *const f055E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f055E->then_instructions;

                  ir_variable *const r055F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r055F);
                  ir_expression *const r0560 = lshift(r03D1, body.constant(int(31)));
                  body.emit(assign(r055F, add(r0560, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r055F, body.constant(0u), 0x01));

                  body.emit(assign(r0551, r055F, 0x03));

                  body.emit(assign(r0550, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f055E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0562 = less(r050D, body.constant(int(0)));
                  ir_if *f0561 = new(mem_ctx) ir_if(operand(r0562).val);
                  exec_list *const f0561_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0561->then_instructions;

                     ir_variable *const r0563 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0563, r0510, 0x01));

                     ir_variable *const r0564 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0564, neg(r050D), 0x01));

                     ir_variable *const r0565 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0565);
                     ir_variable *const r0566 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0566);
                     ir_variable *const r0567 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0567);
                     ir_variable *const r0568 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0569 = neg(r0564);
                     body.emit(assign(r0568, bit_and(r0569, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r056B = equal(r0564, body.constant(int(0)));
                     ir_if *f056A = new(mem_ctx) ir_if(operand(r056B).val);
                     exec_list *const f056A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f056A->then_instructions;

                        body.emit(assign(r0565, r0510, 0x01));

                        body.emit(assign(r0566, r050F, 0x01));

                        body.emit(assign(r0567, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f056A->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r056D = less(r0564, body.constant(int(32)));
                        ir_if *f056C = new(mem_ctx) ir_if(operand(r056D).val);
                        exec_list *const f056C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f056C->then_instructions;

                           body.emit(assign(r0565, lshift(r050F, r0568), 0x01));

                           ir_expression *const r056E = lshift(r050E, r0568);
                           ir_expression *const r056F = rshift(r050F, r0564);
                           body.emit(assign(r0566, bit_or(r056E, r056F), 0x01));

                           body.emit(assign(r0567, rshift(r050E, r0564), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f056C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0571 = equal(r0564, body.constant(int(32)));
                           ir_if *f0570 = new(mem_ctx) ir_if(operand(r0571).val);
                           exec_list *const f0570_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0570->then_instructions;

                              body.emit(assign(r0565, r050F, 0x01));

                              body.emit(assign(r0566, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0570->else_instructions;

                              body.emit(assign(r0563, bit_or(r0510, r050F), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0573 = less(r0564, body.constant(int(64)));
                              ir_if *f0572 = new(mem_ctx) ir_if(operand(r0573).val);
                              exec_list *const f0572_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0572->then_instructions;

                                 body.emit(assign(r0565, lshift(r050E, r0568), 0x01));

                                 ir_expression *const r0574 = bit_and(r0564, body.constant(int(31)));
                                 body.emit(assign(r0566, rshift(r050E, r0574), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0572->else_instructions;

                                 ir_variable *const r0575 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0577 = equal(r0564, body.constant(int(64)));
                                 ir_if *f0576 = new(mem_ctx) ir_if(operand(r0577).val);
                                 exec_list *const f0576_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0576->then_instructions;

                                    body.emit(assign(r0575, r050E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0576->else_instructions;

                                    ir_expression *const r0578 = nequal(r050E, body.constant(0u));
                                    ir_expression *const r0579 = expr(ir_unop_b2i, r0578);
                                    body.emit(assign(r0575, expr(ir_unop_i2u, r0579), 0x01));


                                 body.instructions = f0576_parent_instructions;
                                 body.emit(f0576);

                                 /* END IF */

                                 body.emit(assign(r0565, r0575, 0x01));

                                 body.emit(assign(r0566, body.constant(0u), 0x01));


                              body.instructions = f0572_parent_instructions;
                              body.emit(f0572);

                              /* END IF */


                           body.instructions = f0570_parent_instructions;
                           body.emit(f0570);

                           /* END IF */

                           body.emit(assign(r0567, body.constant(0u), 0x01));


                        body.instructions = f056C_parent_instructions;
                        body.emit(f056C);

                        /* END IF */

                        ir_expression *const r057A = nequal(r0563, body.constant(0u));
                        ir_expression *const r057B = expr(ir_unop_b2i, r057A);
                        ir_expression *const r057C = expr(ir_unop_i2u, r057B);
                        body.emit(assign(r0565, bit_or(r0565, r057C), 0x01));


                     body.instructions = f056A_parent_instructions;
                     body.emit(f056A);

                     /* END IF */

                     body.emit(assign(r054D, r0567, 0x01));

                     body.emit(assign(r054E, r0566, 0x01));

                     body.emit(assign(r054F, r0565, 0x01));

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));

                     body.emit(assign(r0552, less(r0565, body.constant(0u)), 0x01));


                  body.instructions = f0561_parent_instructions;
                  body.emit(f0561);

                  /* END IF */


               body.instructions = f055E_parent_instructions;
               body.emit(f055E);

               /* END IF */


            body.instructions = f0554_parent_instructions;
            body.emit(f0554);

            /* END IF */

            /* IF CONDITION */
            ir_if *f057D = new(mem_ctx) ir_if(operand(r0550).val);
            exec_list *const f057D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f057D->then_instructions;

               /* IF CONDITION */
               ir_if *f057E = new(mem_ctx) ir_if(operand(r0552).val);
               exec_list *const f057E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f057E->then_instructions;

                  ir_variable *const r057F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r057F, add(r054E, body.constant(1u)), 0x01));

                  ir_expression *const r0580 = less(r057F, r054E);
                  ir_expression *const r0581 = expr(ir_unop_b2i, r0580);
                  ir_expression *const r0582 = expr(ir_unop_i2u, r0581);
                  body.emit(assign(r054D, add(r054D, r0582), 0x01));

                  ir_expression *const r0583 = equal(r054F, body.constant(0u));
                  ir_expression *const r0584 = expr(ir_unop_b2i, r0583);
                  ir_expression *const r0585 = expr(ir_unop_i2u, r0584);
                  ir_expression *const r0586 = add(r054F, r0585);
                  ir_expression *const r0587 = bit_and(r0586, body.constant(1u));
                  ir_expression *const r0588 = expr(ir_unop_bit_not, r0587);
                  body.emit(assign(r054E, bit_and(r057F, r0588), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f057E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r058A = bit_or(r054D, r054E);
                  ir_expression *const r058B = equal(r058A, body.constant(0u));
                  ir_if *f0589 = new(mem_ctx) ir_if(operand(r058B).val);
                  exec_list *const f0589_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0589->then_instructions;

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));


                  body.instructions = f0589_parent_instructions;
                  body.emit(f0589);

                  /* END IF */


               body.instructions = f057E_parent_instructions;
               body.emit(f057E);

               /* END IF */

               ir_variable *const r058C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r058C);
               ir_expression *const r058D = lshift(r03D1, body.constant(int(31)));
               ir_expression *const r058E = expr(ir_unop_i2u, r054C);
               ir_expression *const r058F = lshift(r058E, body.constant(int(20)));
               ir_expression *const r0590 = add(r058D, r058F);
               body.emit(assign(r058C, add(r0590, r054D), 0x02));

               body.emit(assign(r058C, r054E, 0x01));

               body.emit(assign(r0551, r058C, 0x03));

               body.emit(assign(r0550, body.constant(false), 0x01));


            body.instructions = f057D_parent_instructions;
            body.emit(f057D);

            /* END IF */

            body.emit(assign(r03D2, r0551, 0x03));


         body.instructions = f04BD_parent_instructions;
         body.emit(f04BD);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f04BB->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0592 = equal(r03DA, body.constant(int(2047)));
         ir_if *f0591 = new(mem_ctx) ir_if(operand(r0592).val);
         exec_list *const f0591_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0591->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0594 = bit_or(swizzle_y(r03D7), swizzle_x(r03D7));
            ir_expression *const r0595 = bit_or(swizzle_y(r03D5), swizzle_x(r03D5));
            ir_expression *const r0596 = bit_or(r0594, r0595);
            ir_expression *const r0597 = nequal(r0596, body.constant(0u));
            ir_if *f0593 = new(mem_ctx) ir_if(operand(r0597).val);
            exec_list *const f0593_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0593->then_instructions;

               ir_variable *const r0598 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0598, swizzle_x(r03CF), 0x01));

               ir_variable *const r0599 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0599, swizzle_x(r03D0), 0x01));

               ir_variable *const r059A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r059B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r059C = rshift(swizzle_y(r03CF), body.constant(int(19)));
               ir_expression *const r059D = bit_and(r059C, body.constant(4095u));
               ir_expression *const r059E = equal(r059D, body.constant(4094u));
               ir_expression *const r059F = nequal(swizzle_x(r03CF), body.constant(0u));
               ir_expression *const r05A0 = bit_and(swizzle_y(r03CF), body.constant(524287u));
               ir_expression *const r05A1 = nequal(r05A0, body.constant(0u));
               ir_expression *const r05A2 = logic_or(r059F, r05A1);
               body.emit(assign(r059B, logic_and(r059E, r05A2), 0x01));

               ir_variable *const r05A3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r05A4 = lshift(swizzle_y(r03D0), body.constant(int(1)));
               ir_expression *const r05A5 = lequal(body.constant(4292870144u), r05A4);
               ir_expression *const r05A6 = nequal(swizzle_x(r03D0), body.constant(0u));
               ir_expression *const r05A7 = bit_and(swizzle_y(r03D0), body.constant(1048575u));
               ir_expression *const r05A8 = nequal(r05A7, body.constant(0u));
               ir_expression *const r05A9 = logic_or(r05A6, r05A8);
               body.emit(assign(r05A3, logic_and(r05A5, r05A9), 0x01));

               body.emit(assign(r0598, bit_or(swizzle_y(r03CF), body.constant(524288u)), 0x02));

               body.emit(assign(r0599, bit_or(swizzle_y(r03D0), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r05AB = lshift(swizzle_y(r03CF), body.constant(int(1)));
               ir_expression *const r05AC = lequal(body.constant(4292870144u), r05AB);
               ir_expression *const r05AD = nequal(swizzle_x(r03CF), body.constant(0u));
               ir_expression *const r05AE = bit_and(swizzle_y(r03CF), body.constant(1048575u));
               ir_expression *const r05AF = nequal(r05AE, body.constant(0u));
               ir_expression *const r05B0 = logic_or(r05AD, r05AF);
               ir_expression *const r05B1 = logic_and(r05AC, r05B0);
               ir_if *f05AA = new(mem_ctx) ir_if(operand(r05B1).val);
               exec_list *const f05AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05AA->then_instructions;

                  ir_variable *const r05B2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05B4 = logic_and(r059B, r05A3);
                  ir_if *f05B3 = new(mem_ctx) ir_if(operand(r05B4).val);
                  exec_list *const f05B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05B3->then_instructions;

                     body.emit(assign(r05B2, r0599, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05B3->else_instructions;

                     body.emit(assign(r05B2, r0598, 0x03));


                  body.instructions = f05B3_parent_instructions;
                  body.emit(f05B3);

                  /* END IF */

                  body.emit(assign(r059A, r05B2, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05AA->else_instructions;

                  body.emit(assign(r059A, r0599, 0x03));


               body.instructions = f05AA_parent_instructions;
               body.emit(f05AA);

               /* END IF */

               body.emit(assign(r03D2, r059A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0593->else_instructions;

               ir_constant_data r05B5_data;
               memset(&r05B5_data, 0, sizeof(ir_constant_data));
               r05B5_data.u[0] = 4294967295;
               r05B5_data.u[1] = 4294967295;
               ir_constant *const r05B5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r05B5_data);
               body.emit(assign(r03D2, r05B5, 0x03));


            body.instructions = f0593_parent_instructions;
            body.emit(f0593);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0591->else_instructions;

            /* IF CONDITION */
            ir_expression *const r05B7 = equal(r03DA, body.constant(int(0)));
            ir_if *f05B6 = new(mem_ctx) ir_if(operand(r05B7).val);
            exec_list *const f05B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B6->then_instructions;

               body.emit(assign(r03D6, body.constant(int(1)), 0x01));

               body.emit(assign(r03D4, body.constant(int(1)), 0x01));


            body.instructions = f05B6_parent_instructions;
            body.emit(f05B6);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r05B9 = less(swizzle_y(r03D5), swizzle_y(r03D7));
            ir_if *f05B8 = new(mem_ctx) ir_if(operand(r05B9).val);
            exec_list *const f05B8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B8->then_instructions;

               ir_variable *const r05BA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r05BB = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r05BB, sub(swizzle_x(r03D7), swizzle_x(r03D5)), 0x01));

               ir_expression *const r05BC = sub(swizzle_y(r03D7), swizzle_y(r03D5));
               ir_expression *const r05BD = less(swizzle_x(r03D7), swizzle_x(r03D5));
               ir_expression *const r05BE = expr(ir_unop_b2i, r05BD);
               ir_expression *const r05BF = expr(ir_unop_i2u, r05BE);
               body.emit(assign(r05BA, sub(r05BC, r05BF), 0x01));

               body.emit(assign(r03D8, add(r03D6, body.constant(int(-1))), 0x01));

               ir_variable *const r05C0 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05C0, add(r03D8, body.constant(int(-10))), 0x01));

               ir_variable *const r05C1 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r05C1, r05BA, 0x01));

               ir_variable *const r05C2 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r05C2, r05BB, 0x01));

               ir_variable *const r05C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r05C3);
               ir_variable *const r05C4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C4);
               /* IF CONDITION */
               ir_expression *const r05C6 = equal(r05BA, body.constant(0u));
               ir_if *f05C5 = new(mem_ctx) ir_if(operand(r05C6).val);
               exec_list *const f05C5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05C5->then_instructions;

                  body.emit(assign(r05C1, r05BB, 0x01));

                  body.emit(assign(r05C2, body.constant(0u), 0x01));

                  body.emit(assign(r05C0, add(r05C0, body.constant(int(-32))), 0x01));


               body.instructions = f05C5_parent_instructions;
               body.emit(f05C5);

               /* END IF */

               ir_variable *const r05C7 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r05C7, r05C1, 0x01));

               ir_variable *const r05C8 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r05C9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C9);
               /* IF CONDITION */
               ir_expression *const r05CB = equal(r05C1, body.constant(0u));
               ir_if *f05CA = new(mem_ctx) ir_if(operand(r05CB).val);
               exec_list *const f05CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05CA->then_instructions;

                  body.emit(assign(r05C8, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05CA->else_instructions;

                  body.emit(assign(r05C9, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05CD = bit_and(r05C1, body.constant(4294901760u));
                  ir_expression *const r05CE = equal(r05CD, body.constant(0u));
                  ir_if *f05CC = new(mem_ctx) ir_if(operand(r05CE).val);
                  exec_list *const f05CC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CC->then_instructions;

                     body.emit(assign(r05C9, body.constant(int(16)), 0x01));

                     body.emit(assign(r05C7, lshift(r05C1, body.constant(int(16))), 0x01));


                  body.instructions = f05CC_parent_instructions;
                  body.emit(f05CC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D0 = bit_and(r05C7, body.constant(4278190080u));
                  ir_expression *const r05D1 = equal(r05D0, body.constant(0u));
                  ir_if *f05CF = new(mem_ctx) ir_if(operand(r05D1).val);
                  exec_list *const f05CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CF->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(8))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(8))), 0x01));


                  body.instructions = f05CF_parent_instructions;
                  body.emit(f05CF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D3 = bit_and(r05C7, body.constant(4026531840u));
                  ir_expression *const r05D4 = equal(r05D3, body.constant(0u));
                  ir_if *f05D2 = new(mem_ctx) ir_if(operand(r05D4).val);
                  exec_list *const f05D2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D2->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(4))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(4))), 0x01));


                  body.instructions = f05D2_parent_instructions;
                  body.emit(f05D2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D6 = bit_and(r05C7, body.constant(3221225472u));
                  ir_expression *const r05D7 = equal(r05D6, body.constant(0u));
                  ir_if *f05D5 = new(mem_ctx) ir_if(operand(r05D7).val);
                  exec_list *const f05D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D5->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(2))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(2))), 0x01));


                  body.instructions = f05D5_parent_instructions;
                  body.emit(f05D5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D9 = bit_and(r05C7, body.constant(2147483648u));
                  ir_expression *const r05DA = equal(r05D9, body.constant(0u));
                  ir_if *f05D8 = new(mem_ctx) ir_if(operand(r05DA).val);
                  exec_list *const f05D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D8->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(1))), 0x01));


                  body.instructions = f05D8_parent_instructions;
                  body.emit(f05D8);

                  /* END IF */

                  body.emit(assign(r05C8, r05C9, 0x01));


               body.instructions = f05CA_parent_instructions;
               body.emit(f05CA);

               /* END IF */

               body.emit(assign(r05C4, add(r05C8, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r05DC = lequal(body.constant(int(0)), r05C4);
               ir_if *f05DB = new(mem_ctx) ir_if(operand(r05DC).val);
               exec_list *const f05DB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05DB->then_instructions;

                  body.emit(assign(r05C3, body.constant(0u), 0x01));

                  ir_variable *const r05DD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r05DD, lshift(r05C2, r05C4), 0x01));

                  ir_variable *const r05DE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05E0 = equal(r05C4, body.constant(int(0)));
                  ir_if *f05DF = new(mem_ctx) ir_if(operand(r05E0).val);
                  exec_list *const f05DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05DF->then_instructions;

                     body.emit(assign(r05DE, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05DF->else_instructions;

                     ir_expression *const r05E1 = lshift(r05C1, r05C4);
                     ir_expression *const r05E2 = neg(r05C4);
                     ir_expression *const r05E3 = bit_and(r05E2, body.constant(int(31)));
                     ir_expression *const r05E4 = rshift(r05C2, r05E3);
                     body.emit(assign(r05DE, bit_or(r05E1, r05E4), 0x01));


                  body.instructions = f05DF_parent_instructions;
                  body.emit(f05DF);

                  /* END IF */

                  body.emit(assign(r05C1, r05DE, 0x01));

                  body.emit(assign(r05C2, r05DD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05DB->else_instructions;

                  ir_variable *const r05E5 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r05E5, body.constant(0u), 0x01));

                  ir_variable *const r05E6 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r05E6, neg(r05C4), 0x01));

                  ir_variable *const r05E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r05E7);
                  ir_variable *const r05E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r05E8);
                  ir_variable *const r05E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r05E9);
                  ir_variable *const r05EA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r05EB = neg(r05E6);
                  body.emit(assign(r05EA, bit_and(r05EB, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05ED = equal(r05E6, body.constant(int(0)));
                  ir_if *f05EC = new(mem_ctx) ir_if(operand(r05ED).val);
                  exec_list *const f05EC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05EC->then_instructions;

                     body.emit(assign(r05E7, r05E5, 0x01));

                     body.emit(assign(r05E8, r05C2, 0x01));

                     body.emit(assign(r05E9, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05EC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r05EF = less(r05E6, body.constant(int(32)));
                     ir_if *f05EE = new(mem_ctx) ir_if(operand(r05EF).val);
                     exec_list *const f05EE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f05EE->then_instructions;

                        body.emit(assign(r05E7, lshift(r05C2, r05EA), 0x01));

                        ir_expression *const r05F0 = lshift(r05C1, r05EA);
                        ir_expression *const r05F1 = rshift(r05C2, r05E6);
                        body.emit(assign(r05E8, bit_or(r05F0, r05F1), 0x01));

                        body.emit(assign(r05E9, rshift(r05C1, r05E6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f05EE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r05F3 = equal(r05E6, body.constant(int(32)));
                        ir_if *f05F2 = new(mem_ctx) ir_if(operand(r05F3).val);
                        exec_list *const f05F2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f05F2->then_instructions;

                           body.emit(assign(r05E7, r05C2, 0x01));

                           body.emit(assign(r05E8, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f05F2->else_instructions;

                           body.emit(assign(r05E5, bit_or(body.constant(0u), r05C2), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r05F5 = less(r05E6, body.constant(int(64)));
                           ir_if *f05F4 = new(mem_ctx) ir_if(operand(r05F5).val);
                           exec_list *const f05F4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f05F4->then_instructions;

                              body.emit(assign(r05E7, lshift(r05C1, r05EA), 0x01));

                              ir_expression *const r05F6 = bit_and(r05E6, body.constant(int(31)));
                              body.emit(assign(r05E8, rshift(r05C1, r05F6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f05F4->else_instructions;

                              ir_variable *const r05F7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r05F9 = equal(r05E6, body.constant(int(64)));
                              ir_if *f05F8 = new(mem_ctx) ir_if(operand(r05F9).val);
                              exec_list *const f05F8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f05F8->then_instructions;

                                 body.emit(assign(r05F7, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f05F8->else_instructions;

                                 ir_expression *const r05FA = nequal(r05C1, body.constant(0u));
                                 ir_expression *const r05FB = expr(ir_unop_b2i, r05FA);
                                 body.emit(assign(r05F7, expr(ir_unop_i2u, r05FB), 0x01));


                              body.instructions = f05F8_parent_instructions;
                              body.emit(f05F8);

                              /* END IF */

                              body.emit(assign(r05E7, r05F7, 0x01));

                              body.emit(assign(r05E8, body.constant(0u), 0x01));


                           body.instructions = f05F4_parent_instructions;
                           body.emit(f05F4);

                           /* END IF */


                        body.instructions = f05F2_parent_instructions;
                        body.emit(f05F2);

                        /* END IF */

                        body.emit(assign(r05E9, body.constant(0u), 0x01));


                     body.instructions = f05EE_parent_instructions;
                     body.emit(f05EE);

                     /* END IF */

                     ir_expression *const r05FC = nequal(r05E5, body.constant(0u));
                     ir_expression *const r05FD = expr(ir_unop_b2i, r05FC);
                     ir_expression *const r05FE = expr(ir_unop_i2u, r05FD);
                     body.emit(assign(r05E7, bit_or(r05E7, r05FE), 0x01));


                  body.instructions = f05EC_parent_instructions;
                  body.emit(f05EC);

                  /* END IF */

                  body.emit(assign(r05C1, r05E9, 0x01));

                  body.emit(assign(r05C2, r05E8, 0x01));

                  body.emit(assign(r05C3, r05E7, 0x01));


               body.instructions = f05DB_parent_instructions;
               body.emit(f05DB);

               /* END IF */

               body.emit(assign(r05C0, sub(r05C0, r05C4), 0x01));

               ir_variable *const r05FF = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05FF, r05C0, 0x01));

               ir_variable *const r0600 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0600, r05C1, 0x01));

               ir_variable *const r0601 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0601, r05C2, 0x01));

               ir_variable *const r0602 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0602, r05C3, 0x01));

               ir_variable *const r0603 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0603, body.constant(true), 0x01));

               ir_variable *const r0604 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0605 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0605);
               ir_expression *const r0606 = expr(ir_unop_u2i, r05C3);
               body.emit(assign(r0605, less(r0606, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0608 = lequal(body.constant(int(2045)), r05C0);
               ir_if *f0607 = new(mem_ctx) ir_if(operand(r0608).val);
               exec_list *const f0607_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0607->then_instructions;

                  ir_variable *const r0609 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r060B = less(body.constant(int(2045)), r05C0);
                  ir_if *f060A = new(mem_ctx) ir_if(operand(r060B).val);
                  exec_list *const f060A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f060A->then_instructions;

                     body.emit(assign(r0609, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f060A->else_instructions;

                     ir_variable *const r060C = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r060E = equal(r05C0, body.constant(int(2045)));
                     ir_if *f060D = new(mem_ctx) ir_if(operand(r060E).val);
                     exec_list *const f060D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f060D->then_instructions;

                        ir_expression *const r060F = equal(body.constant(2097151u), r05C1);
                        ir_expression *const r0610 = equal(body.constant(4294967295u), r05C2);
                        body.emit(assign(r060C, logic_and(r060F, r0610), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f060D->else_instructions;

                        body.emit(assign(r060C, body.constant(false), 0x01));


                     body.instructions = f060D_parent_instructions;
                     body.emit(f060D);

                     /* END IF */

                     body.emit(assign(r0609, logic_and(r060C, r0605), 0x01));


                  body.instructions = f060A_parent_instructions;
                  body.emit(f060A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0611 = new(mem_ctx) ir_if(operand(r0609).val);
                  exec_list *const f0611_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0611->then_instructions;

                     ir_variable *const r0612 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0612);
                     ir_expression *const r0613 = lshift(r03D1, body.constant(int(31)));
                     body.emit(assign(r0612, add(r0613, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0612, body.constant(0u), 0x01));

                     body.emit(assign(r0604, r0612, 0x03));

                     body.emit(assign(r0603, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0611->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0615 = less(r05C0, body.constant(int(0)));
                     ir_if *f0614 = new(mem_ctx) ir_if(operand(r0615).val);
                     exec_list *const f0614_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0614->then_instructions;

                        ir_variable *const r0616 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0616, r05C3, 0x01));

                        ir_variable *const r0617 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0617, neg(r05C0), 0x01));

                        ir_variable *const r0618 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0618);
                        ir_variable *const r0619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0619);
                        ir_variable *const r061A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r061A);
                        ir_variable *const r061B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r061C = neg(r0617);
                        body.emit(assign(r061B, bit_and(r061C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r061E = equal(r0617, body.constant(int(0)));
                        ir_if *f061D = new(mem_ctx) ir_if(operand(r061E).val);
                        exec_list *const f061D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f061D->then_instructions;

                           body.emit(assign(r0618, r05C3, 0x01));

                           body.emit(assign(r0619, r05C2, 0x01));

                           body.emit(assign(r061A, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f061D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0620 = less(r0617, body.constant(int(32)));
                           ir_if *f061F = new(mem_ctx) ir_if(operand(r0620).val);
                           exec_list *const f061F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f061F->then_instructions;

                              body.emit(assign(r0618, lshift(r05C2, r061B), 0x01));

                              ir_expression *const r0621 = lshift(r05C1, r061B);
                              ir_expression *const r0622 = rshift(r05C2, r0617);
                              body.emit(assign(r0619, bit_or(r0621, r0622), 0x01));

                              body.emit(assign(r061A, rshift(r05C1, r0617), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f061F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0624 = equal(r0617, body.constant(int(32)));
                              ir_if *f0623 = new(mem_ctx) ir_if(operand(r0624).val);
                              exec_list *const f0623_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0623->then_instructions;

                                 body.emit(assign(r0618, r05C2, 0x01));

                                 body.emit(assign(r0619, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0623->else_instructions;

                                 body.emit(assign(r0616, bit_or(r05C3, r05C2), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0626 = less(r0617, body.constant(int(64)));
                                 ir_if *f0625 = new(mem_ctx) ir_if(operand(r0626).val);
                                 exec_list *const f0625_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0625->then_instructions;

                                    body.emit(assign(r0618, lshift(r05C1, r061B), 0x01));

                                    ir_expression *const r0627 = bit_and(r0617, body.constant(int(31)));
                                    body.emit(assign(r0619, rshift(r05C1, r0627), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0625->else_instructions;

                                    ir_variable *const r0628 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r062A = equal(r0617, body.constant(int(64)));
                                    ir_if *f0629 = new(mem_ctx) ir_if(operand(r062A).val);
                                    exec_list *const f0629_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0629->then_instructions;

                                       body.emit(assign(r0628, r05C1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0629->else_instructions;

                                       ir_expression *const r062B = nequal(r05C1, body.constant(0u));
                                       ir_expression *const r062C = expr(ir_unop_b2i, r062B);
                                       body.emit(assign(r0628, expr(ir_unop_i2u, r062C), 0x01));


                                    body.instructions = f0629_parent_instructions;
                                    body.emit(f0629);

                                    /* END IF */

                                    body.emit(assign(r0618, r0628, 0x01));

                                    body.emit(assign(r0619, body.constant(0u), 0x01));


                                 body.instructions = f0625_parent_instructions;
                                 body.emit(f0625);

                                 /* END IF */


                              body.instructions = f0623_parent_instructions;
                              body.emit(f0623);

                              /* END IF */

                              body.emit(assign(r061A, body.constant(0u), 0x01));


                           body.instructions = f061F_parent_instructions;
                           body.emit(f061F);

                           /* END IF */

                           ir_expression *const r062D = nequal(r0616, body.constant(0u));
                           ir_expression *const r062E = expr(ir_unop_b2i, r062D);
                           ir_expression *const r062F = expr(ir_unop_i2u, r062E);
                           body.emit(assign(r0618, bit_or(r0618, r062F), 0x01));


                        body.instructions = f061D_parent_instructions;
                        body.emit(f061D);

                        /* END IF */

                        body.emit(assign(r0600, r061A, 0x01));

                        body.emit(assign(r0601, r0619, 0x01));

                        body.emit(assign(r0602, r0618, 0x01));

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));

                        body.emit(assign(r0605, less(r0618, body.constant(0u)), 0x01));


                     body.instructions = f0614_parent_instructions;
                     body.emit(f0614);

                     /* END IF */


                  body.instructions = f0611_parent_instructions;
                  body.emit(f0611);

                  /* END IF */


               body.instructions = f0607_parent_instructions;
               body.emit(f0607);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0630 = new(mem_ctx) ir_if(operand(r0603).val);
               exec_list *const f0630_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0630->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0631 = new(mem_ctx) ir_if(operand(r0605).val);
                  exec_list *const f0631_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0631->then_instructions;

                     ir_variable *const r0632 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0632, add(r0601, body.constant(1u)), 0x01));

                     ir_expression *const r0633 = less(r0632, r0601);
                     ir_expression *const r0634 = expr(ir_unop_b2i, r0633);
                     ir_expression *const r0635 = expr(ir_unop_i2u, r0634);
                     body.emit(assign(r0600, add(r0600, r0635), 0x01));

                     ir_expression *const r0636 = equal(r0602, body.constant(0u));
                     ir_expression *const r0637 = expr(ir_unop_b2i, r0636);
                     ir_expression *const r0638 = expr(ir_unop_i2u, r0637);
                     ir_expression *const r0639 = add(r0602, r0638);
                     ir_expression *const r063A = bit_and(r0639, body.constant(1u));
                     ir_expression *const r063B = expr(ir_unop_bit_not, r063A);
                     body.emit(assign(r0601, bit_and(r0632, r063B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0631->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r063D = bit_or(r0600, r0601);
                     ir_expression *const r063E = equal(r063D, body.constant(0u));
                     ir_if *f063C = new(mem_ctx) ir_if(operand(r063E).val);
                     exec_list *const f063C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f063C->then_instructions;

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));


                     body.instructions = f063C_parent_instructions;
                     body.emit(f063C);

                     /* END IF */


                  body.instructions = f0631_parent_instructions;
                  body.emit(f0631);

                  /* END IF */

                  ir_variable *const r063F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r063F);
                  ir_expression *const r0640 = lshift(r03D1, body.constant(int(31)));
                  ir_expression *const r0641 = expr(ir_unop_i2u, r05FF);
                  ir_expression *const r0642 = lshift(r0641, body.constant(int(20)));
                  ir_expression *const r0643 = add(r0640, r0642);
                  body.emit(assign(r063F, add(r0643, r0600), 0x02));

                  body.emit(assign(r063F, r0601, 0x01));

                  body.emit(assign(r0604, r063F, 0x03));

                  body.emit(assign(r0603, body.constant(false), 0x01));


               body.instructions = f0630_parent_instructions;
               body.emit(f0630);

               /* END IF */

               body.emit(assign(r03D2, r0604, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f05B8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0645 = less(swizzle_y(r03D7), swizzle_y(r03D5));
               ir_if *f0644 = new(mem_ctx) ir_if(operand(r0645).val);
               exec_list *const f0644_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0644->then_instructions;

                  ir_variable *const r0646 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0647 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0647, sub(swizzle_x(r03D5), swizzle_x(r03D7)), 0x01));

                  ir_expression *const r0648 = sub(swizzle_y(r03D5), swizzle_y(r03D7));
                  ir_expression *const r0649 = less(swizzle_x(r03D5), swizzle_x(r03D7));
                  ir_expression *const r064A = expr(ir_unop_b2i, r0649);
                  ir_expression *const r064B = expr(ir_unop_i2u, r064A);
                  body.emit(assign(r0646, sub(r0648, r064B), 0x01));

                  body.emit(assign(r03D1, bit_xor(r03D1, body.constant(1u)), 0x01));

                  body.emit(assign(r03D8, add(r03D4, body.constant(int(-1))), 0x01));

                  ir_variable *const r064C = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r064C, add(r03D8, body.constant(int(-10))), 0x01));

                  ir_variable *const r064D = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r064D, r0646, 0x01));

                  ir_variable *const r064E = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r064E, r0647, 0x01));

                  ir_variable *const r064F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r064F);
                  ir_variable *const r0650 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0650);
                  /* IF CONDITION */
                  ir_expression *const r0652 = equal(r0646, body.constant(0u));
                  ir_if *f0651 = new(mem_ctx) ir_if(operand(r0652).val);
                  exec_list *const f0651_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0651->then_instructions;

                     body.emit(assign(r064D, r0647, 0x01));

                     body.emit(assign(r064E, body.constant(0u), 0x01));

                     body.emit(assign(r064C, add(r064C, body.constant(int(-32))), 0x01));


                  body.instructions = f0651_parent_instructions;
                  body.emit(f0651);

                  /* END IF */

                  ir_variable *const r0653 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0653, r064D, 0x01));

                  ir_variable *const r0654 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0655 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0655);
                  /* IF CONDITION */
                  ir_expression *const r0657 = equal(r064D, body.constant(0u));
                  ir_if *f0656 = new(mem_ctx) ir_if(operand(r0657).val);
                  exec_list *const f0656_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0656->then_instructions;

                     body.emit(assign(r0654, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0656->else_instructions;

                     body.emit(assign(r0655, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0659 = bit_and(r064D, body.constant(4294901760u));
                     ir_expression *const r065A = equal(r0659, body.constant(0u));
                     ir_if *f0658 = new(mem_ctx) ir_if(operand(r065A).val);
                     exec_list *const f0658_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0658->then_instructions;

                        body.emit(assign(r0655, body.constant(int(16)), 0x01));

                        body.emit(assign(r0653, lshift(r064D, body.constant(int(16))), 0x01));


                     body.instructions = f0658_parent_instructions;
                     body.emit(f0658);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065C = bit_and(r0653, body.constant(4278190080u));
                     ir_expression *const r065D = equal(r065C, body.constant(0u));
                     ir_if *f065B = new(mem_ctx) ir_if(operand(r065D).val);
                     exec_list *const f065B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065B->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(8))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(8))), 0x01));


                     body.instructions = f065B_parent_instructions;
                     body.emit(f065B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065F = bit_and(r0653, body.constant(4026531840u));
                     ir_expression *const r0660 = equal(r065F, body.constant(0u));
                     ir_if *f065E = new(mem_ctx) ir_if(operand(r0660).val);
                     exec_list *const f065E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065E->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(4))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(4))), 0x01));


                     body.instructions = f065E_parent_instructions;
                     body.emit(f065E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0662 = bit_and(r0653, body.constant(3221225472u));
                     ir_expression *const r0663 = equal(r0662, body.constant(0u));
                     ir_if *f0661 = new(mem_ctx) ir_if(operand(r0663).val);
                     exec_list *const f0661_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0661->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(2))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(2))), 0x01));


                     body.instructions = f0661_parent_instructions;
                     body.emit(f0661);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0665 = bit_and(r0653, body.constant(2147483648u));
                     ir_expression *const r0666 = equal(r0665, body.constant(0u));
                     ir_if *f0664 = new(mem_ctx) ir_if(operand(r0666).val);
                     exec_list *const f0664_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0664->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(1))), 0x01));


                     body.instructions = f0664_parent_instructions;
                     body.emit(f0664);

                     /* END IF */

                     body.emit(assign(r0654, r0655, 0x01));


                  body.instructions = f0656_parent_instructions;
                  body.emit(f0656);

                  /* END IF */

                  body.emit(assign(r0650, add(r0654, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0668 = lequal(body.constant(int(0)), r0650);
                  ir_if *f0667 = new(mem_ctx) ir_if(operand(r0668).val);
                  exec_list *const f0667_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0667->then_instructions;

                     body.emit(assign(r064F, body.constant(0u), 0x01));

                     ir_variable *const r0669 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0669, lshift(r064E, r0650), 0x01));

                     ir_variable *const r066A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r066C = equal(r0650, body.constant(int(0)));
                     ir_if *f066B = new(mem_ctx) ir_if(operand(r066C).val);
                     exec_list *const f066B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f066B->then_instructions;

                        body.emit(assign(r066A, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f066B->else_instructions;

                        ir_expression *const r066D = lshift(r064D, r0650);
                        ir_expression *const r066E = neg(r0650);
                        ir_expression *const r066F = bit_and(r066E, body.constant(int(31)));
                        ir_expression *const r0670 = rshift(r064E, r066F);
                        body.emit(assign(r066A, bit_or(r066D, r0670), 0x01));


                     body.instructions = f066B_parent_instructions;
                     body.emit(f066B);

                     /* END IF */

                     body.emit(assign(r064D, r066A, 0x01));

                     body.emit(assign(r064E, r0669, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0667->else_instructions;

                     ir_variable *const r0671 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0671, body.constant(0u), 0x01));

                     ir_variable *const r0672 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0672, neg(r0650), 0x01));

                     ir_variable *const r0673 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0673);
                     ir_variable *const r0674 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0674);
                     ir_variable *const r0675 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0675);
                     ir_variable *const r0676 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0677 = neg(r0672);
                     body.emit(assign(r0676, bit_and(r0677, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0679 = equal(r0672, body.constant(int(0)));
                     ir_if *f0678 = new(mem_ctx) ir_if(operand(r0679).val);
                     exec_list *const f0678_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0678->then_instructions;

                        body.emit(assign(r0673, r0671, 0x01));

                        body.emit(assign(r0674, r064E, 0x01));

                        body.emit(assign(r0675, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0678->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r067B = less(r0672, body.constant(int(32)));
                        ir_if *f067A = new(mem_ctx) ir_if(operand(r067B).val);
                        exec_list *const f067A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f067A->then_instructions;

                           body.emit(assign(r0673, lshift(r064E, r0676), 0x01));

                           ir_expression *const r067C = lshift(r064D, r0676);
                           ir_expression *const r067D = rshift(r064E, r0672);
                           body.emit(assign(r0674, bit_or(r067C, r067D), 0x01));

                           body.emit(assign(r0675, rshift(r064D, r0672), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f067A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r067F = equal(r0672, body.constant(int(32)));
                           ir_if *f067E = new(mem_ctx) ir_if(operand(r067F).val);
                           exec_list *const f067E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f067E->then_instructions;

                              body.emit(assign(r0673, r064E, 0x01));

                              body.emit(assign(r0674, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f067E->else_instructions;

                              body.emit(assign(r0671, bit_or(body.constant(0u), r064E), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0681 = less(r0672, body.constant(int(64)));
                              ir_if *f0680 = new(mem_ctx) ir_if(operand(r0681).val);
                              exec_list *const f0680_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0680->then_instructions;

                                 body.emit(assign(r0673, lshift(r064D, r0676), 0x01));

                                 ir_expression *const r0682 = bit_and(r0672, body.constant(int(31)));
                                 body.emit(assign(r0674, rshift(r064D, r0682), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0680->else_instructions;

                                 ir_variable *const r0683 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0685 = equal(r0672, body.constant(int(64)));
                                 ir_if *f0684 = new(mem_ctx) ir_if(operand(r0685).val);
                                 exec_list *const f0684_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0684->then_instructions;

                                    body.emit(assign(r0683, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0684->else_instructions;

                                    ir_expression *const r0686 = nequal(r064D, body.constant(0u));
                                    ir_expression *const r0687 = expr(ir_unop_b2i, r0686);
                                    body.emit(assign(r0683, expr(ir_unop_i2u, r0687), 0x01));


                                 body.instructions = f0684_parent_instructions;
                                 body.emit(f0684);

                                 /* END IF */

                                 body.emit(assign(r0673, r0683, 0x01));

                                 body.emit(assign(r0674, body.constant(0u), 0x01));


                              body.instructions = f0680_parent_instructions;
                              body.emit(f0680);

                              /* END IF */


                           body.instructions = f067E_parent_instructions;
                           body.emit(f067E);

                           /* END IF */

                           body.emit(assign(r0675, body.constant(0u), 0x01));


                        body.instructions = f067A_parent_instructions;
                        body.emit(f067A);

                        /* END IF */

                        ir_expression *const r0688 = nequal(r0671, body.constant(0u));
                        ir_expression *const r0689 = expr(ir_unop_b2i, r0688);
                        ir_expression *const r068A = expr(ir_unop_i2u, r0689);
                        body.emit(assign(r0673, bit_or(r0673, r068A), 0x01));


                     body.instructions = f0678_parent_instructions;
                     body.emit(f0678);

                     /* END IF */

                     body.emit(assign(r064D, r0675, 0x01));

                     body.emit(assign(r064E, r0674, 0x01));

                     body.emit(assign(r064F, r0673, 0x01));


                  body.instructions = f0667_parent_instructions;
                  body.emit(f0667);

                  /* END IF */

                  body.emit(assign(r064C, sub(r064C, r0650), 0x01));

                  ir_variable *const r068B = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r068B, r064C, 0x01));

                  ir_variable *const r068C = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r068C, r064D, 0x01));

                  ir_variable *const r068D = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r068D, r064E, 0x01));

                  ir_variable *const r068E = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r068E, r064F, 0x01));

                  ir_variable *const r068F = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r068F, body.constant(true), 0x01));

                  ir_variable *const r0690 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0691 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0691);
                  ir_expression *const r0692 = expr(ir_unop_u2i, r064F);
                  body.emit(assign(r0691, less(r0692, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0694 = lequal(body.constant(int(2045)), r064C);
                  ir_if *f0693 = new(mem_ctx) ir_if(operand(r0694).val);
                  exec_list *const f0693_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0693->then_instructions;

                     ir_variable *const r0695 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0697 = less(body.constant(int(2045)), r064C);
                     ir_if *f0696 = new(mem_ctx) ir_if(operand(r0697).val);
                     exec_list *const f0696_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0696->then_instructions;

                        body.emit(assign(r0695, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0696->else_instructions;

                        ir_variable *const r0698 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r069A = equal(r064C, body.constant(int(2045)));
                        ir_if *f0699 = new(mem_ctx) ir_if(operand(r069A).val);
                        exec_list *const f0699_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0699->then_instructions;

                           ir_expression *const r069B = equal(body.constant(2097151u), r064D);
                           ir_expression *const r069C = equal(body.constant(4294967295u), r064E);
                           body.emit(assign(r0698, logic_and(r069B, r069C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0699->else_instructions;

                           body.emit(assign(r0698, body.constant(false), 0x01));


                        body.instructions = f0699_parent_instructions;
                        body.emit(f0699);

                        /* END IF */

                        body.emit(assign(r0695, logic_and(r0698, r0691), 0x01));


                     body.instructions = f0696_parent_instructions;
                     body.emit(f0696);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f069D = new(mem_ctx) ir_if(operand(r0695).val);
                     exec_list *const f069D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f069D->then_instructions;

                        ir_variable *const r069E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r069E);
                        ir_expression *const r069F = lshift(r03D1, body.constant(int(31)));
                        body.emit(assign(r069E, add(r069F, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r069E, body.constant(0u), 0x01));

                        body.emit(assign(r0690, r069E, 0x03));

                        body.emit(assign(r068F, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f069D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06A1 = less(r064C, body.constant(int(0)));
                        ir_if *f06A0 = new(mem_ctx) ir_if(operand(r06A1).val);
                        exec_list *const f06A0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06A0->then_instructions;

                           ir_variable *const r06A2 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r06A2, r064F, 0x01));

                           ir_variable *const r06A3 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r06A3, neg(r064C), 0x01));

                           ir_variable *const r06A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r06A4);
                           ir_variable *const r06A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r06A5);
                           ir_variable *const r06A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r06A6);
                           ir_variable *const r06A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r06A8 = neg(r06A3);
                           body.emit(assign(r06A7, bit_and(r06A8, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r06AA = equal(r06A3, body.constant(int(0)));
                           ir_if *f06A9 = new(mem_ctx) ir_if(operand(r06AA).val);
                           exec_list *const f06A9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f06A9->then_instructions;

                              body.emit(assign(r06A4, r064F, 0x01));

                              body.emit(assign(r06A5, r064E, 0x01));

                              body.emit(assign(r06A6, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f06A9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r06AC = less(r06A3, body.constant(int(32)));
                              ir_if *f06AB = new(mem_ctx) ir_if(operand(r06AC).val);
                              exec_list *const f06AB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f06AB->then_instructions;

                                 body.emit(assign(r06A4, lshift(r064E, r06A7), 0x01));

                                 ir_expression *const r06AD = lshift(r064D, r06A7);
                                 ir_expression *const r06AE = rshift(r064E, r06A3);
                                 body.emit(assign(r06A5, bit_or(r06AD, r06AE), 0x01));

                                 body.emit(assign(r06A6, rshift(r064D, r06A3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f06AB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r06B0 = equal(r06A3, body.constant(int(32)));
                                 ir_if *f06AF = new(mem_ctx) ir_if(operand(r06B0).val);
                                 exec_list *const f06AF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f06AF->then_instructions;

                                    body.emit(assign(r06A4, r064E, 0x01));

                                    body.emit(assign(r06A5, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f06AF->else_instructions;

                                    body.emit(assign(r06A2, bit_or(r064F, r064E), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r06B2 = less(r06A3, body.constant(int(64)));
                                    ir_if *f06B1 = new(mem_ctx) ir_if(operand(r06B2).val);
                                    exec_list *const f06B1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f06B1->then_instructions;

                                       body.emit(assign(r06A4, lshift(r064D, r06A7), 0x01));

                                       ir_expression *const r06B3 = bit_and(r06A3, body.constant(int(31)));
                                       body.emit(assign(r06A5, rshift(r064D, r06B3), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f06B1->else_instructions;

                                       ir_variable *const r06B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r06B6 = equal(r06A3, body.constant(int(64)));
                                       ir_if *f06B5 = new(mem_ctx) ir_if(operand(r06B6).val);
                                       exec_list *const f06B5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f06B5->then_instructions;

                                          body.emit(assign(r06B4, r064D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f06B5->else_instructions;

                                          ir_expression *const r06B7 = nequal(r064D, body.constant(0u));
                                          ir_expression *const r06B8 = expr(ir_unop_b2i, r06B7);
                                          body.emit(assign(r06B4, expr(ir_unop_i2u, r06B8), 0x01));


                                       body.instructions = f06B5_parent_instructions;
                                       body.emit(f06B5);

                                       /* END IF */

                                       body.emit(assign(r06A4, r06B4, 0x01));

                                       body.emit(assign(r06A5, body.constant(0u), 0x01));


                                    body.instructions = f06B1_parent_instructions;
                                    body.emit(f06B1);

                                    /* END IF */


                                 body.instructions = f06AF_parent_instructions;
                                 body.emit(f06AF);

                                 /* END IF */

                                 body.emit(assign(r06A6, body.constant(0u), 0x01));


                              body.instructions = f06AB_parent_instructions;
                              body.emit(f06AB);

                              /* END IF */

                              ir_expression *const r06B9 = nequal(r06A2, body.constant(0u));
                              ir_expression *const r06BA = expr(ir_unop_b2i, r06B9);
                              ir_expression *const r06BB = expr(ir_unop_i2u, r06BA);
                              body.emit(assign(r06A4, bit_or(r06A4, r06BB), 0x01));


                           body.instructions = f06A9_parent_instructions;
                           body.emit(f06A9);

                           /* END IF */

                           body.emit(assign(r068C, r06A6, 0x01));

                           body.emit(assign(r068D, r06A5, 0x01));

                           body.emit(assign(r068E, r06A4, 0x01));

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));

                           body.emit(assign(r0691, less(r06A4, body.constant(0u)), 0x01));


                        body.instructions = f06A0_parent_instructions;
                        body.emit(f06A0);

                        /* END IF */


                     body.instructions = f069D_parent_instructions;
                     body.emit(f069D);

                     /* END IF */


                  body.instructions = f0693_parent_instructions;
                  body.emit(f0693);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f06BC = new(mem_ctx) ir_if(operand(r068F).val);
                  exec_list *const f06BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06BC->then_instructions;

                     /* IF CONDITION */
                     ir_if *f06BD = new(mem_ctx) ir_if(operand(r0691).val);
                     exec_list *const f06BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06BD->then_instructions;

                        ir_variable *const r06BE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r06BE, add(r068D, body.constant(1u)), 0x01));

                        ir_expression *const r06BF = less(r06BE, r068D);
                        ir_expression *const r06C0 = expr(ir_unop_b2i, r06BF);
                        ir_expression *const r06C1 = expr(ir_unop_i2u, r06C0);
                        body.emit(assign(r068C, add(r068C, r06C1), 0x01));

                        ir_expression *const r06C2 = equal(r068E, body.constant(0u));
                        ir_expression *const r06C3 = expr(ir_unop_b2i, r06C2);
                        ir_expression *const r06C4 = expr(ir_unop_i2u, r06C3);
                        ir_expression *const r06C5 = add(r068E, r06C4);
                        ir_expression *const r06C6 = bit_and(r06C5, body.constant(1u));
                        ir_expression *const r06C7 = expr(ir_unop_bit_not, r06C6);
                        body.emit(assign(r068D, bit_and(r06BE, r06C7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06BD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06C9 = bit_or(r068C, r068D);
                        ir_expression *const r06CA = equal(r06C9, body.constant(0u));
                        ir_if *f06C8 = new(mem_ctx) ir_if(operand(r06CA).val);
                        exec_list *const f06C8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06C8->then_instructions;

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));


                        body.instructions = f06C8_parent_instructions;
                        body.emit(f06C8);

                        /* END IF */


                     body.instructions = f06BD_parent_instructions;
                     body.emit(f06BD);

                     /* END IF */

                     ir_variable *const r06CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r06CB);
                     ir_expression *const r06CC = lshift(r03D1, body.constant(int(31)));
                     ir_expression *const r06CD = expr(ir_unop_i2u, r068B);
                     ir_expression *const r06CE = lshift(r06CD, body.constant(int(20)));
                     ir_expression *const r06CF = add(r06CC, r06CE);
                     body.emit(assign(r06CB, add(r06CF, r068C), 0x02));

                     body.emit(assign(r06CB, r068D, 0x01));

                     body.emit(assign(r0690, r06CB, 0x03));

                     body.emit(assign(r068F, body.constant(false), 0x01));


                  body.instructions = f06BC_parent_instructions;
                  body.emit(f06BC);

                  /* END IF */

                  body.emit(assign(r03D2, r0690, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0644->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r06D1 = less(swizzle_x(r03D5), swizzle_x(r03D7));
                  ir_if *f06D0 = new(mem_ctx) ir_if(operand(r06D1).val);
                  exec_list *const f06D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06D0->then_instructions;

                     ir_variable *const r06D2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r06D3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r06D3, sub(swizzle_x(r03D7), swizzle_x(r03D5)), 0x01));

                     ir_expression *const r06D4 = sub(swizzle_y(r03D7), swizzle_y(r03D5));
                     ir_expression *const r06D5 = less(swizzle_x(r03D7), swizzle_x(r03D5));
                     ir_expression *const r06D6 = expr(ir_unop_b2i, r06D5);
                     ir_expression *const r06D7 = expr(ir_unop_i2u, r06D6);
                     body.emit(assign(r06D2, sub(r06D4, r06D7), 0x01));

                     body.emit(assign(r03D8, add(r03D6, body.constant(int(-1))), 0x01));

                     ir_variable *const r06D8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r06D8, add(r03D8, body.constant(int(-10))), 0x01));

                     ir_variable *const r06D9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r06D9, r06D2, 0x01));

                     ir_variable *const r06DA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r06DA, r06D3, 0x01));

                     ir_variable *const r06DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r06DB);
                     ir_variable *const r06DC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06DC);
                     /* IF CONDITION */
                     ir_expression *const r06DE = equal(r06D2, body.constant(0u));
                     ir_if *f06DD = new(mem_ctx) ir_if(operand(r06DE).val);
                     exec_list *const f06DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06DD->then_instructions;

                        body.emit(assign(r06D9, r06D3, 0x01));

                        body.emit(assign(r06DA, body.constant(0u), 0x01));

                        body.emit(assign(r06D8, add(r06D8, body.constant(int(-32))), 0x01));


                     body.instructions = f06DD_parent_instructions;
                     body.emit(f06DD);

                     /* END IF */

                     ir_variable *const r06DF = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r06DF, r06D9, 0x01));

                     ir_variable *const r06E0 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r06E1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06E1);
                     /* IF CONDITION */
                     ir_expression *const r06E3 = equal(r06D9, body.constant(0u));
                     ir_if *f06E2 = new(mem_ctx) ir_if(operand(r06E3).val);
                     exec_list *const f06E2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06E2->then_instructions;

                        body.emit(assign(r06E0, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06E2->else_instructions;

                        body.emit(assign(r06E1, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r06E5 = bit_and(r06D9, body.constant(4294901760u));
                        ir_expression *const r06E6 = equal(r06E5, body.constant(0u));
                        ir_if *f06E4 = new(mem_ctx) ir_if(operand(r06E6).val);
                        exec_list *const f06E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E4->then_instructions;

                           body.emit(assign(r06E1, body.constant(int(16)), 0x01));

                           body.emit(assign(r06DF, lshift(r06D9, body.constant(int(16))), 0x01));


                        body.instructions = f06E4_parent_instructions;
                        body.emit(f06E4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06E8 = bit_and(r06DF, body.constant(4278190080u));
                        ir_expression *const r06E9 = equal(r06E8, body.constant(0u));
                        ir_if *f06E7 = new(mem_ctx) ir_if(operand(r06E9).val);
                        exec_list *const f06E7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E7->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(8))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(8))), 0x01));


                        body.instructions = f06E7_parent_instructions;
                        body.emit(f06E7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EB = bit_and(r06DF, body.constant(4026531840u));
                        ir_expression *const r06EC = equal(r06EB, body.constant(0u));
                        ir_if *f06EA = new(mem_ctx) ir_if(operand(r06EC).val);
                        exec_list *const f06EA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06EA->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(4))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(4))), 0x01));


                        body.instructions = f06EA_parent_instructions;
                        body.emit(f06EA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EE = bit_and(r06DF, body.constant(3221225472u));
                        ir_expression *const r06EF = equal(r06EE, body.constant(0u));
                        ir_if *f06ED = new(mem_ctx) ir_if(operand(r06EF).val);
                        exec_list *const f06ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06ED->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(2))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(2))), 0x01));


                        body.instructions = f06ED_parent_instructions;
                        body.emit(f06ED);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06F1 = bit_and(r06DF, body.constant(2147483648u));
                        ir_expression *const r06F2 = equal(r06F1, body.constant(0u));
                        ir_if *f06F0 = new(mem_ctx) ir_if(operand(r06F2).val);
                        exec_list *const f06F0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F0->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(1))), 0x01));


                        body.instructions = f06F0_parent_instructions;
                        body.emit(f06F0);

                        /* END IF */

                        body.emit(assign(r06E0, r06E1, 0x01));


                     body.instructions = f06E2_parent_instructions;
                     body.emit(f06E2);

                     /* END IF */

                     body.emit(assign(r06DC, add(r06E0, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r06F4 = lequal(body.constant(int(0)), r06DC);
                     ir_if *f06F3 = new(mem_ctx) ir_if(operand(r06F4).val);
                     exec_list *const f06F3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06F3->then_instructions;

                        body.emit(assign(r06DB, body.constant(0u), 0x01));

                        ir_variable *const r06F5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r06F5, lshift(r06DA, r06DC), 0x01));

                        ir_variable *const r06F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r06F8 = equal(r06DC, body.constant(int(0)));
                        ir_if *f06F7 = new(mem_ctx) ir_if(operand(r06F8).val);
                        exec_list *const f06F7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F7->then_instructions;

                           body.emit(assign(r06F6, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f06F7->else_instructions;

                           ir_expression *const r06F9 = lshift(r06D9, r06DC);
                           ir_expression *const r06FA = neg(r06DC);
                           ir_expression *const r06FB = bit_and(r06FA, body.constant(int(31)));
                           ir_expression *const r06FC = rshift(r06DA, r06FB);
                           body.emit(assign(r06F6, bit_or(r06F9, r06FC), 0x01));


                        body.instructions = f06F7_parent_instructions;
                        body.emit(f06F7);

                        /* END IF */

                        body.emit(assign(r06D9, r06F6, 0x01));

                        body.emit(assign(r06DA, r06F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06F3->else_instructions;

                        ir_variable *const r06FD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r06FD, body.constant(0u), 0x01));

                        ir_variable *const r06FE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r06FE, neg(r06DC), 0x01));

                        ir_variable *const r06FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r06FF);
                        ir_variable *const r0700 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0700);
                        ir_variable *const r0701 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0701);
                        ir_variable *const r0702 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0703 = neg(r06FE);
                        body.emit(assign(r0702, bit_and(r0703, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0705 = equal(r06FE, body.constant(int(0)));
                        ir_if *f0704 = new(mem_ctx) ir_if(operand(r0705).val);
                        exec_list *const f0704_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0704->then_instructions;

                           body.emit(assign(r06FF, r06FD, 0x01));

                           body.emit(assign(r0700, r06DA, 0x01));

                           body.emit(assign(r0701, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0704->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0707 = less(r06FE, body.constant(int(32)));
                           ir_if *f0706 = new(mem_ctx) ir_if(operand(r0707).val);
                           exec_list *const f0706_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0706->then_instructions;

                              body.emit(assign(r06FF, lshift(r06DA, r0702), 0x01));

                              ir_expression *const r0708 = lshift(r06D9, r0702);
                              ir_expression *const r0709 = rshift(r06DA, r06FE);
                              body.emit(assign(r0700, bit_or(r0708, r0709), 0x01));

                              body.emit(assign(r0701, rshift(r06D9, r06FE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0706->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r070B = equal(r06FE, body.constant(int(32)));
                              ir_if *f070A = new(mem_ctx) ir_if(operand(r070B).val);
                              exec_list *const f070A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f070A->then_instructions;

                                 body.emit(assign(r06FF, r06DA, 0x01));

                                 body.emit(assign(r0700, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f070A->else_instructions;

                                 body.emit(assign(r06FD, bit_or(body.constant(0u), r06DA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r070D = less(r06FE, body.constant(int(64)));
                                 ir_if *f070C = new(mem_ctx) ir_if(operand(r070D).val);
                                 exec_list *const f070C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f070C->then_instructions;

                                    body.emit(assign(r06FF, lshift(r06D9, r0702), 0x01));

                                    ir_expression *const r070E = bit_and(r06FE, body.constant(int(31)));
                                    body.emit(assign(r0700, rshift(r06D9, r070E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f070C->else_instructions;

                                    ir_variable *const r070F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0711 = equal(r06FE, body.constant(int(64)));
                                    ir_if *f0710 = new(mem_ctx) ir_if(operand(r0711).val);
                                    exec_list *const f0710_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0710->then_instructions;

                                       body.emit(assign(r070F, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0710->else_instructions;

                                       ir_expression *const r0712 = nequal(r06D9, body.constant(0u));
                                       ir_expression *const r0713 = expr(ir_unop_b2i, r0712);
                                       body.emit(assign(r070F, expr(ir_unop_i2u, r0713), 0x01));


                                    body.instructions = f0710_parent_instructions;
                                    body.emit(f0710);

                                    /* END IF */

                                    body.emit(assign(r06FF, r070F, 0x01));

                                    body.emit(assign(r0700, body.constant(0u), 0x01));


                                 body.instructions = f070C_parent_instructions;
                                 body.emit(f070C);

                                 /* END IF */


                              body.instructions = f070A_parent_instructions;
                              body.emit(f070A);

                              /* END IF */

                              body.emit(assign(r0701, body.constant(0u), 0x01));


                           body.instructions = f0706_parent_instructions;
                           body.emit(f0706);

                           /* END IF */

                           ir_expression *const r0714 = nequal(r06FD, body.constant(0u));
                           ir_expression *const r0715 = expr(ir_unop_b2i, r0714);
                           ir_expression *const r0716 = expr(ir_unop_i2u, r0715);
                           body.emit(assign(r06FF, bit_or(r06FF, r0716), 0x01));


                        body.instructions = f0704_parent_instructions;
                        body.emit(f0704);

                        /* END IF */

                        body.emit(assign(r06D9, r0701, 0x01));

                        body.emit(assign(r06DA, r0700, 0x01));

                        body.emit(assign(r06DB, r06FF, 0x01));


                     body.instructions = f06F3_parent_instructions;
                     body.emit(f06F3);

                     /* END IF */

                     body.emit(assign(r06D8, sub(r06D8, r06DC), 0x01));

                     ir_variable *const r0717 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0717, r06D8, 0x01));

                     ir_variable *const r0718 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0718, r06D9, 0x01));

                     ir_variable *const r0719 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0719, r06DA, 0x01));

                     ir_variable *const r071A = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r071A, r06DB, 0x01));

                     ir_variable *const r071B = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r071B, body.constant(true), 0x01));

                     ir_variable *const r071C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r071D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r071D);
                     ir_expression *const r071E = expr(ir_unop_u2i, r06DB);
                     body.emit(assign(r071D, less(r071E, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0720 = lequal(body.constant(int(2045)), r06D8);
                     ir_if *f071F = new(mem_ctx) ir_if(operand(r0720).val);
                     exec_list *const f071F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f071F->then_instructions;

                        ir_variable *const r0721 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0723 = less(body.constant(int(2045)), r06D8);
                        ir_if *f0722 = new(mem_ctx) ir_if(operand(r0723).val);
                        exec_list *const f0722_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0722->then_instructions;

                           body.emit(assign(r0721, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0722->else_instructions;

                           ir_variable *const r0724 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0726 = equal(r06D8, body.constant(int(2045)));
                           ir_if *f0725 = new(mem_ctx) ir_if(operand(r0726).val);
                           exec_list *const f0725_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0725->then_instructions;

                              ir_expression *const r0727 = equal(body.constant(2097151u), r06D9);
                              ir_expression *const r0728 = equal(body.constant(4294967295u), r06DA);
                              body.emit(assign(r0724, logic_and(r0727, r0728), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0725->else_instructions;

                              body.emit(assign(r0724, body.constant(false), 0x01));


                           body.instructions = f0725_parent_instructions;
                           body.emit(f0725);

                           /* END IF */

                           body.emit(assign(r0721, logic_and(r0724, r071D), 0x01));


                        body.instructions = f0722_parent_instructions;
                        body.emit(f0722);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0729 = new(mem_ctx) ir_if(operand(r0721).val);
                        exec_list *const f0729_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0729->then_instructions;

                           ir_variable *const r072A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r072A);
                           ir_expression *const r072B = lshift(r03D1, body.constant(int(31)));
                           body.emit(assign(r072A, add(r072B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r072A, body.constant(0u), 0x01));

                           body.emit(assign(r071C, r072A, 0x03));

                           body.emit(assign(r071B, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0729->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r072D = less(r06D8, body.constant(int(0)));
                           ir_if *f072C = new(mem_ctx) ir_if(operand(r072D).val);
                           exec_list *const f072C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f072C->then_instructions;

                              ir_variable *const r072E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r072E, r06DB, 0x01));

                              ir_variable *const r072F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r072F, neg(r06D8), 0x01));

                              ir_variable *const r0730 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0730);
                              ir_variable *const r0731 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0731);
                              ir_variable *const r0732 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0732);
                              ir_variable *const r0733 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0734 = neg(r072F);
                              body.emit(assign(r0733, bit_and(r0734, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0736 = equal(r072F, body.constant(int(0)));
                              ir_if *f0735 = new(mem_ctx) ir_if(operand(r0736).val);
                              exec_list *const f0735_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0735->then_instructions;

                                 body.emit(assign(r0730, r06DB, 0x01));

                                 body.emit(assign(r0731, r06DA, 0x01));

                                 body.emit(assign(r0732, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0735->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0738 = less(r072F, body.constant(int(32)));
                                 ir_if *f0737 = new(mem_ctx) ir_if(operand(r0738).val);
                                 exec_list *const f0737_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0737->then_instructions;

                                    body.emit(assign(r0730, lshift(r06DA, r0733), 0x01));

                                    ir_expression *const r0739 = lshift(r06D9, r0733);
                                    ir_expression *const r073A = rshift(r06DA, r072F);
                                    body.emit(assign(r0731, bit_or(r0739, r073A), 0x01));

                                    body.emit(assign(r0732, rshift(r06D9, r072F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0737->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r073C = equal(r072F, body.constant(int(32)));
                                    ir_if *f073B = new(mem_ctx) ir_if(operand(r073C).val);
                                    exec_list *const f073B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f073B->then_instructions;

                                       body.emit(assign(r0730, r06DA, 0x01));

                                       body.emit(assign(r0731, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f073B->else_instructions;

                                       body.emit(assign(r072E, bit_or(r06DB, r06DA), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r073E = less(r072F, body.constant(int(64)));
                                       ir_if *f073D = new(mem_ctx) ir_if(operand(r073E).val);
                                       exec_list *const f073D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f073D->then_instructions;

                                          body.emit(assign(r0730, lshift(r06D9, r0733), 0x01));

                                          ir_expression *const r073F = bit_and(r072F, body.constant(int(31)));
                                          body.emit(assign(r0731, rshift(r06D9, r073F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f073D->else_instructions;

                                          ir_variable *const r0740 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0742 = equal(r072F, body.constant(int(64)));
                                          ir_if *f0741 = new(mem_ctx) ir_if(operand(r0742).val);
                                          exec_list *const f0741_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0741->then_instructions;

                                             body.emit(assign(r0740, r06D9, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0741->else_instructions;

                                             ir_expression *const r0743 = nequal(r06D9, body.constant(0u));
                                             ir_expression *const r0744 = expr(ir_unop_b2i, r0743);
                                             body.emit(assign(r0740, expr(ir_unop_i2u, r0744), 0x01));


                                          body.instructions = f0741_parent_instructions;
                                          body.emit(f0741);

                                          /* END IF */

                                          body.emit(assign(r0730, r0740, 0x01));

                                          body.emit(assign(r0731, body.constant(0u), 0x01));


                                       body.instructions = f073D_parent_instructions;
                                       body.emit(f073D);

                                       /* END IF */


                                    body.instructions = f073B_parent_instructions;
                                    body.emit(f073B);

                                    /* END IF */

                                    body.emit(assign(r0732, body.constant(0u), 0x01));


                                 body.instructions = f0737_parent_instructions;
                                 body.emit(f0737);

                                 /* END IF */

                                 ir_expression *const r0745 = nequal(r072E, body.constant(0u));
                                 ir_expression *const r0746 = expr(ir_unop_b2i, r0745);
                                 ir_expression *const r0747 = expr(ir_unop_i2u, r0746);
                                 body.emit(assign(r0730, bit_or(r0730, r0747), 0x01));


                              body.instructions = f0735_parent_instructions;
                              body.emit(f0735);

                              /* END IF */

                              body.emit(assign(r0718, r0732, 0x01));

                              body.emit(assign(r0719, r0731, 0x01));

                              body.emit(assign(r071A, r0730, 0x01));

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));

                              body.emit(assign(r071D, less(r0730, body.constant(0u)), 0x01));


                           body.instructions = f072C_parent_instructions;
                           body.emit(f072C);

                           /* END IF */


                        body.instructions = f0729_parent_instructions;
                        body.emit(f0729);

                        /* END IF */


                     body.instructions = f071F_parent_instructions;
                     body.emit(f071F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0748 = new(mem_ctx) ir_if(operand(r071B).val);
                     exec_list *const f0748_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0748->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0749 = new(mem_ctx) ir_if(operand(r071D).val);
                        exec_list *const f0749_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0749->then_instructions;

                           ir_variable *const r074A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r074A, add(r0719, body.constant(1u)), 0x01));

                           ir_expression *const r074B = less(r074A, r0719);
                           ir_expression *const r074C = expr(ir_unop_b2i, r074B);
                           ir_expression *const r074D = expr(ir_unop_i2u, r074C);
                           body.emit(assign(r0718, add(r0718, r074D), 0x01));

                           ir_expression *const r074E = equal(r071A, body.constant(0u));
                           ir_expression *const r074F = expr(ir_unop_b2i, r074E);
                           ir_expression *const r0750 = expr(ir_unop_i2u, r074F);
                           ir_expression *const r0751 = add(r071A, r0750);
                           ir_expression *const r0752 = bit_and(r0751, body.constant(1u));
                           ir_expression *const r0753 = expr(ir_unop_bit_not, r0752);
                           body.emit(assign(r0719, bit_and(r074A, r0753), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0749->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0755 = bit_or(r0718, r0719);
                           ir_expression *const r0756 = equal(r0755, body.constant(0u));
                           ir_if *f0754 = new(mem_ctx) ir_if(operand(r0756).val);
                           exec_list *const f0754_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0754->then_instructions;

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));


                           body.instructions = f0754_parent_instructions;
                           body.emit(f0754);

                           /* END IF */


                        body.instructions = f0749_parent_instructions;
                        body.emit(f0749);

                        /* END IF */

                        ir_variable *const r0757 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0757);
                        ir_expression *const r0758 = lshift(r03D1, body.constant(int(31)));
                        ir_expression *const r0759 = expr(ir_unop_i2u, r0717);
                        ir_expression *const r075A = lshift(r0759, body.constant(int(20)));
                        ir_expression *const r075B = add(r0758, r075A);
                        body.emit(assign(r0757, add(r075B, r0718), 0x02));

                        body.emit(assign(r0757, r0719, 0x01));

                        body.emit(assign(r071C, r0757, 0x03));

                        body.emit(assign(r071B, body.constant(false), 0x01));


                     body.instructions = f0748_parent_instructions;
                     body.emit(f0748);

                     /* END IF */

                     body.emit(assign(r03D2, r071C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f06D0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r075D = less(swizzle_x(r03D7), swizzle_x(r03D5));
                     ir_if *f075C = new(mem_ctx) ir_if(operand(r075D).val);
                     exec_list *const f075C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f075C->then_instructions;

                        ir_variable *const r075E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r075F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r075F, sub(swizzle_x(r03D5), swizzle_x(r03D7)), 0x01));

                        ir_expression *const r0760 = sub(swizzle_y(r03D5), swizzle_y(r03D7));
                        ir_expression *const r0761 = less(swizzle_x(r03D5), swizzle_x(r03D7));
                        ir_expression *const r0762 = expr(ir_unop_b2i, r0761);
                        ir_expression *const r0763 = expr(ir_unop_i2u, r0762);
                        body.emit(assign(r075E, sub(r0760, r0763), 0x01));

                        body.emit(assign(r03D1, bit_xor(r03D1, body.constant(1u)), 0x01));

                        body.emit(assign(r03D8, add(r03D4, body.constant(int(-1))), 0x01));

                        ir_variable *const r0764 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0764, add(r03D8, body.constant(int(-10))), 0x01));

                        ir_variable *const r0765 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0765, r075E, 0x01));

                        ir_variable *const r0766 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0766, r075F, 0x01));

                        ir_variable *const r0767 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0767);
                        ir_variable *const r0768 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0768);
                        /* IF CONDITION */
                        ir_expression *const r076A = equal(r075E, body.constant(0u));
                        ir_if *f0769 = new(mem_ctx) ir_if(operand(r076A).val);
                        exec_list *const f0769_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0769->then_instructions;

                           body.emit(assign(r0765, r075F, 0x01));

                           body.emit(assign(r0766, body.constant(0u), 0x01));

                           body.emit(assign(r0764, add(r0764, body.constant(int(-32))), 0x01));


                        body.instructions = f0769_parent_instructions;
                        body.emit(f0769);

                        /* END IF */

                        ir_variable *const r076B = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r076B, r0765, 0x01));

                        ir_variable *const r076C = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r076D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r076D);
                        /* IF CONDITION */
                        ir_expression *const r076F = equal(r0765, body.constant(0u));
                        ir_if *f076E = new(mem_ctx) ir_if(operand(r076F).val);
                        exec_list *const f076E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f076E->then_instructions;

                           body.emit(assign(r076C, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f076E->else_instructions;

                           body.emit(assign(r076D, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0771 = bit_and(r0765, body.constant(4294901760u));
                           ir_expression *const r0772 = equal(r0771, body.constant(0u));
                           ir_if *f0770 = new(mem_ctx) ir_if(operand(r0772).val);
                           exec_list *const f0770_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0770->then_instructions;

                              body.emit(assign(r076D, body.constant(int(16)), 0x01));

                              body.emit(assign(r076B, lshift(r0765, body.constant(int(16))), 0x01));


                           body.instructions = f0770_parent_instructions;
                           body.emit(f0770);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0774 = bit_and(r076B, body.constant(4278190080u));
                           ir_expression *const r0775 = equal(r0774, body.constant(0u));
                           ir_if *f0773 = new(mem_ctx) ir_if(operand(r0775).val);
                           exec_list *const f0773_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0773->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(8))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(8))), 0x01));


                           body.instructions = f0773_parent_instructions;
                           body.emit(f0773);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0777 = bit_and(r076B, body.constant(4026531840u));
                           ir_expression *const r0778 = equal(r0777, body.constant(0u));
                           ir_if *f0776 = new(mem_ctx) ir_if(operand(r0778).val);
                           exec_list *const f0776_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0776->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(4))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(4))), 0x01));


                           body.instructions = f0776_parent_instructions;
                           body.emit(f0776);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077A = bit_and(r076B, body.constant(3221225472u));
                           ir_expression *const r077B = equal(r077A, body.constant(0u));
                           ir_if *f0779 = new(mem_ctx) ir_if(operand(r077B).val);
                           exec_list *const f0779_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0779->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(2))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(2))), 0x01));


                           body.instructions = f0779_parent_instructions;
                           body.emit(f0779);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077D = bit_and(r076B, body.constant(2147483648u));
                           ir_expression *const r077E = equal(r077D, body.constant(0u));
                           ir_if *f077C = new(mem_ctx) ir_if(operand(r077E).val);
                           exec_list *const f077C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f077C->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(1))), 0x01));


                           body.instructions = f077C_parent_instructions;
                           body.emit(f077C);

                           /* END IF */

                           body.emit(assign(r076C, r076D, 0x01));


                        body.instructions = f076E_parent_instructions;
                        body.emit(f076E);

                        /* END IF */

                        body.emit(assign(r0768, add(r076C, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0780 = lequal(body.constant(int(0)), r0768);
                        ir_if *f077F = new(mem_ctx) ir_if(operand(r0780).val);
                        exec_list *const f077F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f077F->then_instructions;

                           body.emit(assign(r0767, body.constant(0u), 0x01));

                           ir_variable *const r0781 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0781, lshift(r0766, r0768), 0x01));

                           ir_variable *const r0782 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0784 = equal(r0768, body.constant(int(0)));
                           ir_if *f0783 = new(mem_ctx) ir_if(operand(r0784).val);
                           exec_list *const f0783_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0783->then_instructions;

                              body.emit(assign(r0782, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0783->else_instructions;

                              ir_expression *const r0785 = lshift(r0765, r0768);
                              ir_expression *const r0786 = neg(r0768);
                              ir_expression *const r0787 = bit_and(r0786, body.constant(int(31)));
                              ir_expression *const r0788 = rshift(r0766, r0787);
                              body.emit(assign(r0782, bit_or(r0785, r0788), 0x01));


                           body.instructions = f0783_parent_instructions;
                           body.emit(f0783);

                           /* END IF */

                           body.emit(assign(r0765, r0782, 0x01));

                           body.emit(assign(r0766, r0781, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f077F->else_instructions;

                           ir_variable *const r0789 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0789, body.constant(0u), 0x01));

                           ir_variable *const r078A = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r078A, neg(r0768), 0x01));

                           ir_variable *const r078B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r078B);
                           ir_variable *const r078C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r078C);
                           ir_variable *const r078D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r078D);
                           ir_variable *const r078E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r078F = neg(r078A);
                           body.emit(assign(r078E, bit_and(r078F, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0791 = equal(r078A, body.constant(int(0)));
                           ir_if *f0790 = new(mem_ctx) ir_if(operand(r0791).val);
                           exec_list *const f0790_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0790->then_instructions;

                              body.emit(assign(r078B, r0789, 0x01));

                              body.emit(assign(r078C, r0766, 0x01));

                              body.emit(assign(r078D, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0790->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0793 = less(r078A, body.constant(int(32)));
                              ir_if *f0792 = new(mem_ctx) ir_if(operand(r0793).val);
                              exec_list *const f0792_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0792->then_instructions;

                                 body.emit(assign(r078B, lshift(r0766, r078E), 0x01));

                                 ir_expression *const r0794 = lshift(r0765, r078E);
                                 ir_expression *const r0795 = rshift(r0766, r078A);
                                 body.emit(assign(r078C, bit_or(r0794, r0795), 0x01));

                                 body.emit(assign(r078D, rshift(r0765, r078A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0792->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0797 = equal(r078A, body.constant(int(32)));
                                 ir_if *f0796 = new(mem_ctx) ir_if(operand(r0797).val);
                                 exec_list *const f0796_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0796->then_instructions;

                                    body.emit(assign(r078B, r0766, 0x01));

                                    body.emit(assign(r078C, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0796->else_instructions;

                                    body.emit(assign(r0789, bit_or(body.constant(0u), r0766), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0799 = less(r078A, body.constant(int(64)));
                                    ir_if *f0798 = new(mem_ctx) ir_if(operand(r0799).val);
                                    exec_list *const f0798_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0798->then_instructions;

                                       body.emit(assign(r078B, lshift(r0765, r078E), 0x01));

                                       ir_expression *const r079A = bit_and(r078A, body.constant(int(31)));
                                       body.emit(assign(r078C, rshift(r0765, r079A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0798->else_instructions;

                                       ir_variable *const r079B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r079D = equal(r078A, body.constant(int(64)));
                                       ir_if *f079C = new(mem_ctx) ir_if(operand(r079D).val);
                                       exec_list *const f079C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f079C->then_instructions;

                                          body.emit(assign(r079B, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f079C->else_instructions;

                                          ir_expression *const r079E = nequal(r0765, body.constant(0u));
                                          ir_expression *const r079F = expr(ir_unop_b2i, r079E);
                                          body.emit(assign(r079B, expr(ir_unop_i2u, r079F), 0x01));


                                       body.instructions = f079C_parent_instructions;
                                       body.emit(f079C);

                                       /* END IF */

                                       body.emit(assign(r078B, r079B, 0x01));

                                       body.emit(assign(r078C, body.constant(0u), 0x01));


                                    body.instructions = f0798_parent_instructions;
                                    body.emit(f0798);

                                    /* END IF */


                                 body.instructions = f0796_parent_instructions;
                                 body.emit(f0796);

                                 /* END IF */

                                 body.emit(assign(r078D, body.constant(0u), 0x01));


                              body.instructions = f0792_parent_instructions;
                              body.emit(f0792);

                              /* END IF */

                              ir_expression *const r07A0 = nequal(r0789, body.constant(0u));
                              ir_expression *const r07A1 = expr(ir_unop_b2i, r07A0);
                              ir_expression *const r07A2 = expr(ir_unop_i2u, r07A1);
                              body.emit(assign(r078B, bit_or(r078B, r07A2), 0x01));


                           body.instructions = f0790_parent_instructions;
                           body.emit(f0790);

                           /* END IF */

                           body.emit(assign(r0765, r078D, 0x01));

                           body.emit(assign(r0766, r078C, 0x01));

                           body.emit(assign(r0767, r078B, 0x01));


                        body.instructions = f077F_parent_instructions;
                        body.emit(f077F);

                        /* END IF */

                        body.emit(assign(r0764, sub(r0764, r0768), 0x01));

                        ir_variable *const r07A3 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r07A3, r0764, 0x01));

                        ir_variable *const r07A4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r07A4, r0765, 0x01));

                        ir_variable *const r07A5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r07A5, r0766, 0x01));

                        ir_variable *const r07A6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r07A6, r0767, 0x01));

                        ir_variable *const r07A7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r07A7, body.constant(true), 0x01));

                        ir_variable *const r07A8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r07A9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r07A9);
                        ir_expression *const r07AA = expr(ir_unop_u2i, r0767);
                        body.emit(assign(r07A9, less(r07AA, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r07AC = lequal(body.constant(int(2045)), r0764);
                        ir_if *f07AB = new(mem_ctx) ir_if(operand(r07AC).val);
                        exec_list *const f07AB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07AB->then_instructions;

                           ir_variable *const r07AD = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r07AF = less(body.constant(int(2045)), r0764);
                           ir_if *f07AE = new(mem_ctx) ir_if(operand(r07AF).val);
                           exec_list *const f07AE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07AE->then_instructions;

                              body.emit(assign(r07AD, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07AE->else_instructions;

                              ir_variable *const r07B0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r07B2 = equal(r0764, body.constant(int(2045)));
                              ir_if *f07B1 = new(mem_ctx) ir_if(operand(r07B2).val);
                              exec_list *const f07B1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B1->then_instructions;

                                 ir_expression *const r07B3 = equal(body.constant(2097151u), r0765);
                                 ir_expression *const r07B4 = equal(body.constant(4294967295u), r0766);
                                 body.emit(assign(r07B0, logic_and(r07B3, r07B4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f07B1->else_instructions;

                                 body.emit(assign(r07B0, body.constant(false), 0x01));


                              body.instructions = f07B1_parent_instructions;
                              body.emit(f07B1);

                              /* END IF */

                              body.emit(assign(r07AD, logic_and(r07B0, r07A9), 0x01));


                           body.instructions = f07AE_parent_instructions;
                           body.emit(f07AE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f07B5 = new(mem_ctx) ir_if(operand(r07AD).val);
                           exec_list *const f07B5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07B5->then_instructions;

                              ir_variable *const r07B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r07B6);
                              ir_expression *const r07B7 = lshift(r03D1, body.constant(int(31)));
                              body.emit(assign(r07B6, add(r07B7, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r07B6, body.constant(0u), 0x01));

                              body.emit(assign(r07A8, r07B6, 0x03));

                              body.emit(assign(r07A7, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07B5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07B9 = less(r0764, body.constant(int(0)));
                              ir_if *f07B8 = new(mem_ctx) ir_if(operand(r07B9).val);
                              exec_list *const f07B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B8->then_instructions;

                                 ir_variable *const r07BA = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r07BA, r0767, 0x01));

                                 ir_variable *const r07BB = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r07BB, neg(r0764), 0x01));

                                 ir_variable *const r07BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r07BC);
                                 ir_variable *const r07BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r07BD);
                                 ir_variable *const r07BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r07BE);
                                 ir_variable *const r07BF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r07C0 = neg(r07BB);
                                 body.emit(assign(r07BF, bit_and(r07C0, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r07C2 = equal(r07BB, body.constant(int(0)));
                                 ir_if *f07C1 = new(mem_ctx) ir_if(operand(r07C2).val);
                                 exec_list *const f07C1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f07C1->then_instructions;

                                    body.emit(assign(r07BC, r0767, 0x01));

                                    body.emit(assign(r07BD, r0766, 0x01));

                                    body.emit(assign(r07BE, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f07C1->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r07C4 = less(r07BB, body.constant(int(32)));
                                    ir_if *f07C3 = new(mem_ctx) ir_if(operand(r07C4).val);
                                    exec_list *const f07C3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f07C3->then_instructions;

                                       body.emit(assign(r07BC, lshift(r0766, r07BF), 0x01));

                                       ir_expression *const r07C5 = lshift(r0765, r07BF);
                                       ir_expression *const r07C6 = rshift(r0766, r07BB);
                                       body.emit(assign(r07BD, bit_or(r07C5, r07C6), 0x01));

                                       body.emit(assign(r07BE, rshift(r0765, r07BB), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f07C3->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r07C8 = equal(r07BB, body.constant(int(32)));
                                       ir_if *f07C7 = new(mem_ctx) ir_if(operand(r07C8).val);
                                       exec_list *const f07C7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f07C7->then_instructions;

                                          body.emit(assign(r07BC, r0766, 0x01));

                                          body.emit(assign(r07BD, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f07C7->else_instructions;

                                          body.emit(assign(r07BA, bit_or(r0767, r0766), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r07CA = less(r07BB, body.constant(int(64)));
                                          ir_if *f07C9 = new(mem_ctx) ir_if(operand(r07CA).val);
                                          exec_list *const f07C9_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f07C9->then_instructions;

                                             body.emit(assign(r07BC, lshift(r0765, r07BF), 0x01));

                                             ir_expression *const r07CB = bit_and(r07BB, body.constant(int(31)));
                                             body.emit(assign(r07BD, rshift(r0765, r07CB), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f07C9->else_instructions;

                                             ir_variable *const r07CC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r07CE = equal(r07BB, body.constant(int(64)));
                                             ir_if *f07CD = new(mem_ctx) ir_if(operand(r07CE).val);
                                             exec_list *const f07CD_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f07CD->then_instructions;

                                                body.emit(assign(r07CC, r0765, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f07CD->else_instructions;

                                                ir_expression *const r07CF = nequal(r0765, body.constant(0u));
                                                ir_expression *const r07D0 = expr(ir_unop_b2i, r07CF);
                                                body.emit(assign(r07CC, expr(ir_unop_i2u, r07D0), 0x01));


                                             body.instructions = f07CD_parent_instructions;
                                             body.emit(f07CD);

                                             /* END IF */

                                             body.emit(assign(r07BC, r07CC, 0x01));

                                             body.emit(assign(r07BD, body.constant(0u), 0x01));


                                          body.instructions = f07C9_parent_instructions;
                                          body.emit(f07C9);

                                          /* END IF */


                                       body.instructions = f07C7_parent_instructions;
                                       body.emit(f07C7);

                                       /* END IF */

                                       body.emit(assign(r07BE, body.constant(0u), 0x01));


                                    body.instructions = f07C3_parent_instructions;
                                    body.emit(f07C3);

                                    /* END IF */

                                    ir_expression *const r07D1 = nequal(r07BA, body.constant(0u));
                                    ir_expression *const r07D2 = expr(ir_unop_b2i, r07D1);
                                    ir_expression *const r07D3 = expr(ir_unop_i2u, r07D2);
                                    body.emit(assign(r07BC, bit_or(r07BC, r07D3), 0x01));


                                 body.instructions = f07C1_parent_instructions;
                                 body.emit(f07C1);

                                 /* END IF */

                                 body.emit(assign(r07A4, r07BE, 0x01));

                                 body.emit(assign(r07A5, r07BD, 0x01));

                                 body.emit(assign(r07A6, r07BC, 0x01));

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));

                                 body.emit(assign(r07A9, less(r07BC, body.constant(0u)), 0x01));


                              body.instructions = f07B8_parent_instructions;
                              body.emit(f07B8);

                              /* END IF */


                           body.instructions = f07B5_parent_instructions;
                           body.emit(f07B5);

                           /* END IF */


                        body.instructions = f07AB_parent_instructions;
                        body.emit(f07AB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f07D4 = new(mem_ctx) ir_if(operand(r07A7).val);
                        exec_list *const f07D4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07D4->then_instructions;

                           /* IF CONDITION */
                           ir_if *f07D5 = new(mem_ctx) ir_if(operand(r07A9).val);
                           exec_list *const f07D5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07D5->then_instructions;

                              ir_variable *const r07D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r07D6, add(r07A5, body.constant(1u)), 0x01));

                              ir_expression *const r07D7 = less(r07D6, r07A5);
                              ir_expression *const r07D8 = expr(ir_unop_b2i, r07D7);
                              ir_expression *const r07D9 = expr(ir_unop_i2u, r07D8);
                              body.emit(assign(r07A4, add(r07A4, r07D9), 0x01));

                              ir_expression *const r07DA = equal(r07A6, body.constant(0u));
                              ir_expression *const r07DB = expr(ir_unop_b2i, r07DA);
                              ir_expression *const r07DC = expr(ir_unop_i2u, r07DB);
                              ir_expression *const r07DD = add(r07A6, r07DC);
                              ir_expression *const r07DE = bit_and(r07DD, body.constant(1u));
                              ir_expression *const r07DF = expr(ir_unop_bit_not, r07DE);
                              body.emit(assign(r07A5, bit_and(r07D6, r07DF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07D5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07E1 = bit_or(r07A4, r07A5);
                              ir_expression *const r07E2 = equal(r07E1, body.constant(0u));
                              ir_if *f07E0 = new(mem_ctx) ir_if(operand(r07E2).val);
                              exec_list *const f07E0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07E0->then_instructions;

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));


                              body.instructions = f07E0_parent_instructions;
                              body.emit(f07E0);

                              /* END IF */


                           body.instructions = f07D5_parent_instructions;
                           body.emit(f07D5);

                           /* END IF */

                           ir_variable *const r07E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r07E3);
                           ir_expression *const r07E4 = lshift(r03D1, body.constant(int(31)));
                           ir_expression *const r07E5 = expr(ir_unop_i2u, r07A3);
                           ir_expression *const r07E6 = lshift(r07E5, body.constant(int(20)));
                           ir_expression *const r07E7 = add(r07E4, r07E6);
                           body.emit(assign(r07E3, add(r07E7, r07A4), 0x02));

                           body.emit(assign(r07E3, r07A5, 0x01));

                           body.emit(assign(r07A8, r07E3, 0x03));

                           body.emit(assign(r07A7, body.constant(false), 0x01));


                        body.instructions = f07D4_parent_instructions;
                        body.emit(f07D4);

                        /* END IF */

                        body.emit(assign(r03D2, r07A8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f075C->else_instructions;

                        ir_variable *const r07E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r07E8);
                        body.emit(assign(r07E8, body.constant(0u), 0x02));

                        body.emit(assign(r07E8, body.constant(0u), 0x01));

                        body.emit(assign(r03D2, r07E8, 0x03));


                     body.instructions = f075C_parent_instructions;
                     body.emit(f075C);

                     /* END IF */


                  body.instructions = f06D0_parent_instructions;
                  body.emit(f06D0);

                  /* END IF */


               body.instructions = f0644_parent_instructions;
               body.emit(f0644);

               /* END IF */


            body.instructions = f05B8_parent_instructions;
            body.emit(f05B8);

            /* END IF */


         body.instructions = f0591_parent_instructions;
         body.emit(f0591);

         /* END IF */


      body.instructions = f04BB_parent_instructions;
      body.emit(f04BB);

      /* END IF */


   body.instructions = f03E9_parent_instructions;
   body.emit(f03E9);

   /* END IF */

   body.emit(ret(r03D2));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fadd64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r07E9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r07E9);
   ir_variable *const r07EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r07EA);
   ir_variable *const r07EB = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r07EC = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07EC, rshift(swizzle_y(r07E9), body.constant(int(31))), 0x01));

   ir_variable *const r07ED = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07ED, rshift(swizzle_y(r07EA), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r07EF = equal(r07EC, r07ED);
   ir_if *f07EE = new(mem_ctx) ir_if(operand(r07EF).val);
   exec_list *const f07EE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f07EE->then_instructions;

      ir_variable *const r07F0 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r07F0, body.constant(true), 0x01));

      ir_variable *const r07F1 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r07F2 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r07F2);
      ir_variable *const r07F3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r07F3);
      ir_variable *const r07F4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r07F4);
      ir_variable *const r07F5 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r07F5);
      ir_variable *const r07F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r07F6);
      ir_variable *const r07F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r07F7);
      body.emit(assign(r07F7, body.constant(0u), 0x01));

      body.emit(assign(r07F6, body.constant(0u), 0x01));

      ir_variable *const r07F8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r07F8);
      body.emit(assign(r07F8, bit_and(swizzle_y(r07E9), body.constant(1048575u)), 0x02));

      body.emit(assign(r07F8, swizzle_x(r07E9), 0x01));

      body.emit(assign(r07F4, r07F8, 0x03));

      ir_variable *const r07F9 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r07FA = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r07FB = bit_and(r07FA, body.constant(2047u));
      body.emit(assign(r07F9, expr(ir_unop_u2i, r07FB), 0x01));

      ir_variable *const r07FC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r07FC);
      body.emit(assign(r07FC, bit_and(swizzle_y(r07EA), body.constant(1048575u)), 0x02));

      body.emit(assign(r07FC, swizzle_x(r07EA), 0x01));

      body.emit(assign(r07F3, r07FC, 0x03));

      ir_variable *const r07FD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r07FE = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r07FF = bit_and(r07FE, body.constant(2047u));
      body.emit(assign(r07FD, expr(ir_unop_u2i, r07FF), 0x01));

      ir_variable *const r0800 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r0800, sub(r07F9, r07FD), 0x01));

      body.emit(assign(r07F2, r0800, 0x01));

      /* IF CONDITION */
      ir_expression *const r0802 = less(body.constant(int(0)), r0800);
      ir_if *f0801 = new(mem_ctx) ir_if(operand(r0802).val);
      exec_list *const f0801_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0801->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0804 = equal(r07F9, body.constant(int(2047)));
         ir_if *f0803 = new(mem_ctx) ir_if(operand(r0804).val);
         exec_list *const f0803_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0803->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0806 = bit_or(swizzle_y(r07F8), swizzle_x(r07E9));
            ir_expression *const r0807 = nequal(r0806, body.constant(0u));
            ir_if *f0805 = new(mem_ctx) ir_if(operand(r0807).val);
            exec_list *const f0805_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0805->then_instructions;

               ir_variable *const r0808 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0808, swizzle_x(r07E9), 0x01));

               ir_variable *const r0809 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0809, swizzle_x(r07EA), 0x01));

               ir_variable *const r080A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r080B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r080C = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r080D = bit_and(r080C, body.constant(4095u));
               ir_expression *const r080E = equal(r080D, body.constant(4094u));
               ir_expression *const r080F = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r0810 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r0811 = nequal(r0810, body.constant(0u));
               ir_expression *const r0812 = logic_or(r080F, r0811);
               body.emit(assign(r080B, logic_and(r080E, r0812), 0x01));

               ir_variable *const r0813 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0814 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r0815 = lequal(body.constant(4292870144u), r0814);
               ir_expression *const r0816 = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r0817 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r0818 = nequal(r0817, body.constant(0u));
               ir_expression *const r0819 = logic_or(r0816, r0818);
               body.emit(assign(r0813, logic_and(r0815, r0819), 0x01));

               body.emit(assign(r0808, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r0809, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r081B = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r081C = lequal(body.constant(4292870144u), r081B);
               ir_expression *const r081D = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r081E = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r081F = nequal(r081E, body.constant(0u));
               ir_expression *const r0820 = logic_or(r081D, r081F);
               ir_expression *const r0821 = logic_and(r081C, r0820);
               ir_if *f081A = new(mem_ctx) ir_if(operand(r0821).val);
               exec_list *const f081A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f081A->then_instructions;

                  ir_variable *const r0822 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0824 = logic_and(r080B, r0813);
                  ir_if *f0823 = new(mem_ctx) ir_if(operand(r0824).val);
                  exec_list *const f0823_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0823->then_instructions;

                     body.emit(assign(r0822, r0809, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0823->else_instructions;

                     body.emit(assign(r0822, r0808, 0x03));


                  body.instructions = f0823_parent_instructions;
                  body.emit(f0823);

                  /* END IF */

                  body.emit(assign(r080A, r0822, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f081A->else_instructions;

                  body.emit(assign(r080A, r0809, 0x03));


               body.instructions = f081A_parent_instructions;
               body.emit(f081A);

               /* END IF */

               body.emit(assign(r07F1, r080A, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0805->else_instructions;

               body.emit(assign(r07F1, r07E9, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


            body.instructions = f0805_parent_instructions;
            body.emit(f0805);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0803->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0826 = equal(r07FD, body.constant(int(0)));
            ir_if *f0825 = new(mem_ctx) ir_if(operand(r0826).val);
            exec_list *const f0825_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0825->then_instructions;

               body.emit(assign(r07F2, add(r0800, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0825->else_instructions;

               body.emit(assign(r07F3, bit_or(swizzle_y(r07FC), body.constant(1048576u)), 0x02));


            body.instructions = f0825_parent_instructions;
            body.emit(f0825);

            /* END IF */

            ir_variable *const r0827 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r0827, swizzle_y(r07F3), 0x01));

            ir_variable *const r0828 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r0828, swizzle_x(r07F3), 0x01));

            ir_variable *const r0829 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r0829, body.constant(0u), 0x01));

            ir_variable *const r082A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r082A);
            ir_variable *const r082B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r082B);
            ir_variable *const r082C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r082C);
            ir_variable *const r082D = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r082E = neg(r07F2);
            body.emit(assign(r082D, bit_and(r082E, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0830 = equal(r07F2, body.constant(int(0)));
            ir_if *f082F = new(mem_ctx) ir_if(operand(r0830).val);
            exec_list *const f082F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f082F->then_instructions;

               body.emit(assign(r082A, r0829, 0x01));

               body.emit(assign(r082B, r0828, 0x01));

               body.emit(assign(r082C, r0827, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f082F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0832 = less(r07F2, body.constant(int(32)));
               ir_if *f0831 = new(mem_ctx) ir_if(operand(r0832).val);
               exec_list *const f0831_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0831->then_instructions;

                  body.emit(assign(r082A, lshift(swizzle_x(r07FC), r082D), 0x01));

                  ir_expression *const r0833 = lshift(swizzle_y(r07F3), r082D);
                  ir_expression *const r0834 = rshift(swizzle_x(r07FC), r07F2);
                  body.emit(assign(r082B, bit_or(r0833, r0834), 0x01));

                  body.emit(assign(r082C, rshift(swizzle_y(r07F3), r07F2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0831->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0836 = equal(r07F2, body.constant(int(32)));
                  ir_if *f0835 = new(mem_ctx) ir_if(operand(r0836).val);
                  exec_list *const f0835_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0835->then_instructions;

                     body.emit(assign(r082A, r0828, 0x01));

                     body.emit(assign(r082B, r0827, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0835->else_instructions;

                     body.emit(assign(r0829, bit_or(body.constant(0u), swizzle_x(r07FC)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0838 = less(r07F2, body.constant(int(64)));
                     ir_if *f0837 = new(mem_ctx) ir_if(operand(r0838).val);
                     exec_list *const f0837_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0837->then_instructions;

                        body.emit(assign(r082A, lshift(swizzle_y(r07F3), r082D), 0x01));

                        ir_expression *const r0839 = bit_and(r07F2, body.constant(int(31)));
                        body.emit(assign(r082B, rshift(swizzle_y(r07F3), r0839), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0837->else_instructions;

                        ir_variable *const r083A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r083C = equal(r07F2, body.constant(int(64)));
                        ir_if *f083B = new(mem_ctx) ir_if(operand(r083C).val);
                        exec_list *const f083B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f083B->then_instructions;

                           body.emit(assign(r083A, r0827, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f083B->else_instructions;

                           ir_expression *const r083D = nequal(swizzle_y(r07F3), body.constant(0u));
                           ir_expression *const r083E = expr(ir_unop_b2i, r083D);
                           body.emit(assign(r083A, expr(ir_unop_i2u, r083E), 0x01));


                        body.instructions = f083B_parent_instructions;
                        body.emit(f083B);

                        /* END IF */

                        body.emit(assign(r082A, r083A, 0x01));

                        body.emit(assign(r082B, body.constant(0u), 0x01));


                     body.instructions = f0837_parent_instructions;
                     body.emit(f0837);

                     /* END IF */


                  body.instructions = f0835_parent_instructions;
                  body.emit(f0835);

                  /* END IF */

                  body.emit(assign(r082C, body.constant(0u), 0x01));


               body.instructions = f0831_parent_instructions;
               body.emit(f0831);

               /* END IF */

               ir_expression *const r083F = nequal(r0829, body.constant(0u));
               ir_expression *const r0840 = expr(ir_unop_b2i, r083F);
               ir_expression *const r0841 = expr(ir_unop_i2u, r0840);
               body.emit(assign(r082A, bit_or(r082A, r0841), 0x01));


            body.instructions = f082F_parent_instructions;
            body.emit(f082F);

            /* END IF */

            body.emit(assign(r07F3, r082C, 0x02));

            body.emit(assign(r07F3, r082B, 0x01));

            body.emit(assign(r07F6, r082A, 0x01));

            body.emit(assign(r07F5, r07F9, 0x01));


         body.instructions = f0803_parent_instructions;
         body.emit(f0803);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0801->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0843 = less(r07F2, body.constant(int(0)));
         ir_if *f0842 = new(mem_ctx) ir_if(operand(r0843).val);
         exec_list *const f0842_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0842->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0845 = equal(r07FD, body.constant(int(2047)));
            ir_if *f0844 = new(mem_ctx) ir_if(operand(r0845).val);
            exec_list *const f0844_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0844->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0847 = bit_or(swizzle_y(r07F3), swizzle_x(r07F3));
               ir_expression *const r0848 = nequal(r0847, body.constant(0u));
               ir_if *f0846 = new(mem_ctx) ir_if(operand(r0848).val);
               exec_list *const f0846_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0846->then_instructions;

                  ir_variable *const r0849 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0849, swizzle_x(r07E9), 0x01));

                  ir_variable *const r084A = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r084A, swizzle_x(r07EA), 0x01));

                  ir_variable *const r084B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r084C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r084D = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r084E = bit_and(r084D, body.constant(4095u));
                  ir_expression *const r084F = equal(r084E, body.constant(4094u));
                  ir_expression *const r0850 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0851 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0852 = nequal(r0851, body.constant(0u));
                  ir_expression *const r0853 = logic_or(r0850, r0852);
                  body.emit(assign(r084C, logic_and(r084F, r0853), 0x01));

                  ir_variable *const r0854 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0855 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0856 = lequal(body.constant(4292870144u), r0855);
                  ir_expression *const r0857 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0858 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0859 = nequal(r0858, body.constant(0u));
                  ir_expression *const r085A = logic_or(r0857, r0859);
                  body.emit(assign(r0854, logic_and(r0856, r085A), 0x01));

                  body.emit(assign(r0849, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r084A, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r085C = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r085D = lequal(body.constant(4292870144u), r085C);
                  ir_expression *const r085E = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r085F = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0860 = nequal(r085F, body.constant(0u));
                  ir_expression *const r0861 = logic_or(r085E, r0860);
                  ir_expression *const r0862 = logic_and(r085D, r0861);
                  ir_if *f085B = new(mem_ctx) ir_if(operand(r0862).val);
                  exec_list *const f085B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f085B->then_instructions;

                     ir_variable *const r0863 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0865 = logic_and(r084C, r0854);
                     ir_if *f0864 = new(mem_ctx) ir_if(operand(r0865).val);
                     exec_list *const f0864_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0864->then_instructions;

                        body.emit(assign(r0863, r084A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0864->else_instructions;

                        body.emit(assign(r0863, r0849, 0x03));


                     body.instructions = f0864_parent_instructions;
                     body.emit(f0864);

                     /* END IF */

                     body.emit(assign(r084B, r0863, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f085B->else_instructions;

                     body.emit(assign(r084B, r084A, 0x03));


                  body.instructions = f085B_parent_instructions;
                  body.emit(f085B);

                  /* END IF */

                  body.emit(assign(r07F1, r084B, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0846->else_instructions;

                  ir_variable *const r0866 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0866);
                  ir_expression *const r0867 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0866, add(r0867, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0866, body.constant(0u), 0x01));

                  body.emit(assign(r07F1, r0866, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0846_parent_instructions;
               body.emit(f0846);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0844->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0869 = equal(r07F9, body.constant(int(0)));
               ir_if *f0868 = new(mem_ctx) ir_if(operand(r0869).val);
               exec_list *const f0868_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0868->then_instructions;

                  body.emit(assign(r07F2, add(r07F2, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0868->else_instructions;

                  body.emit(assign(r07F4, bit_or(swizzle_y(r07F8), body.constant(1048576u)), 0x02));


               body.instructions = f0868_parent_instructions;
               body.emit(f0868);

               /* END IF */

               ir_variable *const r086A = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r086A, swizzle_y(r07F4), 0x01));

               ir_variable *const r086B = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r086B, swizzle_x(r07F4), 0x01));

               ir_variable *const r086C = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r086C, body.constant(0u), 0x01));

               ir_variable *const r086D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r086D, neg(r07F2), 0x01));

               ir_variable *const r086E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r086E);
               ir_variable *const r086F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r086F);
               ir_variable *const r0870 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0870);
               ir_variable *const r0871 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0872 = neg(r086D);
               body.emit(assign(r0871, bit_and(r0872, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0874 = equal(r086D, body.constant(int(0)));
               ir_if *f0873 = new(mem_ctx) ir_if(operand(r0874).val);
               exec_list *const f0873_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0873->then_instructions;

                  body.emit(assign(r086E, r086C, 0x01));

                  body.emit(assign(r086F, r086B, 0x01));

                  body.emit(assign(r0870, r086A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0873->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0876 = less(r086D, body.constant(int(32)));
                  ir_if *f0875 = new(mem_ctx) ir_if(operand(r0876).val);
                  exec_list *const f0875_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0875->then_instructions;

                     body.emit(assign(r086E, lshift(swizzle_x(r07F8), r0871), 0x01));

                     ir_expression *const r0877 = lshift(swizzle_y(r07F4), r0871);
                     ir_expression *const r0878 = rshift(swizzle_x(r07F8), r086D);
                     body.emit(assign(r086F, bit_or(r0877, r0878), 0x01));

                     body.emit(assign(r0870, rshift(swizzle_y(r07F4), r086D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0875->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r087A = equal(r086D, body.constant(int(32)));
                     ir_if *f0879 = new(mem_ctx) ir_if(operand(r087A).val);
                     exec_list *const f0879_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0879->then_instructions;

                        body.emit(assign(r086E, r086B, 0x01));

                        body.emit(assign(r086F, r086A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0879->else_instructions;

                        body.emit(assign(r086C, bit_or(body.constant(0u), swizzle_x(r07F8)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r087C = less(r086D, body.constant(int(64)));
                        ir_if *f087B = new(mem_ctx) ir_if(operand(r087C).val);
                        exec_list *const f087B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f087B->then_instructions;

                           body.emit(assign(r086E, lshift(swizzle_y(r07F4), r0871), 0x01));

                           ir_expression *const r087D = bit_and(r086D, body.constant(int(31)));
                           body.emit(assign(r086F, rshift(swizzle_y(r07F4), r087D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f087B->else_instructions;

                           ir_variable *const r087E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0880 = equal(r086D, body.constant(int(64)));
                           ir_if *f087F = new(mem_ctx) ir_if(operand(r0880).val);
                           exec_list *const f087F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f087F->then_instructions;

                              body.emit(assign(r087E, r086A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f087F->else_instructions;

                              ir_expression *const r0881 = nequal(swizzle_y(r07F4), body.constant(0u));
                              ir_expression *const r0882 = expr(ir_unop_b2i, r0881);
                              body.emit(assign(r087E, expr(ir_unop_i2u, r0882), 0x01));


                           body.instructions = f087F_parent_instructions;
                           body.emit(f087F);

                           /* END IF */

                           body.emit(assign(r086E, r087E, 0x01));

                           body.emit(assign(r086F, body.constant(0u), 0x01));


                        body.instructions = f087B_parent_instructions;
                        body.emit(f087B);

                        /* END IF */


                     body.instructions = f0879_parent_instructions;
                     body.emit(f0879);

                     /* END IF */

                     body.emit(assign(r0870, body.constant(0u), 0x01));


                  body.instructions = f0875_parent_instructions;
                  body.emit(f0875);

                  /* END IF */

                  ir_expression *const r0883 = nequal(r086C, body.constant(0u));
                  ir_expression *const r0884 = expr(ir_unop_b2i, r0883);
                  ir_expression *const r0885 = expr(ir_unop_i2u, r0884);
                  body.emit(assign(r086E, bit_or(r086E, r0885), 0x01));


               body.instructions = f0873_parent_instructions;
               body.emit(f0873);

               /* END IF */

               body.emit(assign(r07F4, r0870, 0x02));

               body.emit(assign(r07F4, r086F, 0x01));

               body.emit(assign(r07F6, r086E, 0x01));

               body.emit(assign(r07F5, r07FD, 0x01));


            body.instructions = f0844_parent_instructions;
            body.emit(f0844);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0842->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0887 = equal(r07F9, body.constant(int(2047)));
            ir_if *f0886 = new(mem_ctx) ir_if(operand(r0887).val);
            exec_list *const f0886_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0886->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0889 = bit_or(swizzle_y(r07F4), swizzle_x(r07F4));
               ir_expression *const r088A = bit_or(swizzle_y(r07F3), swizzle_x(r07F3));
               ir_expression *const r088B = bit_or(r0889, r088A);
               ir_expression *const r088C = nequal(r088B, body.constant(0u));
               ir_if *f0888 = new(mem_ctx) ir_if(operand(r088C).val);
               exec_list *const f0888_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0888->then_instructions;

                  ir_variable *const r088D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r088D, swizzle_x(r07E9), 0x01));

                  ir_variable *const r088E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r088E, swizzle_x(r07EA), 0x01));

                  ir_variable *const r088F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0890 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0891 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0892 = bit_and(r0891, body.constant(4095u));
                  ir_expression *const r0893 = equal(r0892, body.constant(4094u));
                  ir_expression *const r0894 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0895 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0896 = nequal(r0895, body.constant(0u));
                  ir_expression *const r0897 = logic_or(r0894, r0896);
                  body.emit(assign(r0890, logic_and(r0893, r0897), 0x01));

                  ir_variable *const r0898 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0899 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r089A = lequal(body.constant(4292870144u), r0899);
                  ir_expression *const r089B = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r089C = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r089D = nequal(r089C, body.constant(0u));
                  ir_expression *const r089E = logic_or(r089B, r089D);
                  body.emit(assign(r0898, logic_and(r089A, r089E), 0x01));

                  body.emit(assign(r088D, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r088E, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r08A0 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r08A1 = lequal(body.constant(4292870144u), r08A0);
                  ir_expression *const r08A2 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r08A3 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r08A4 = nequal(r08A3, body.constant(0u));
                  ir_expression *const r08A5 = logic_or(r08A2, r08A4);
                  ir_expression *const r08A6 = logic_and(r08A1, r08A5);
                  ir_if *f089F = new(mem_ctx) ir_if(operand(r08A6).val);
                  exec_list *const f089F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f089F->then_instructions;

                     ir_variable *const r08A7 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08A9 = logic_and(r0890, r0898);
                     ir_if *f08A8 = new(mem_ctx) ir_if(operand(r08A9).val);
                     exec_list *const f08A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08A8->then_instructions;

                        body.emit(assign(r08A7, r088E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08A8->else_instructions;

                        body.emit(assign(r08A7, r088D, 0x03));


                     body.instructions = f08A8_parent_instructions;
                     body.emit(f08A8);

                     /* END IF */

                     body.emit(assign(r088F, r08A7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f089F->else_instructions;

                     body.emit(assign(r088F, r088E, 0x03));


                  body.instructions = f089F_parent_instructions;
                  body.emit(f089F);

                  /* END IF */

                  body.emit(assign(r07F1, r088F, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0888->else_instructions;

                  body.emit(assign(r07F1, r07E9, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0888_parent_instructions;
               body.emit(f0888);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0886->else_instructions;

               ir_variable *const r08AA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r08AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r08AB, add(swizzle_x(r07F4), swizzle_x(r07F3)), 0x01));

               ir_expression *const r08AC = add(swizzle_y(r07F4), swizzle_y(r07F3));
               ir_expression *const r08AD = less(r08AB, swizzle_x(r07F4));
               ir_expression *const r08AE = expr(ir_unop_b2i, r08AD);
               ir_expression *const r08AF = expr(ir_unop_i2u, r08AE);
               body.emit(assign(r08AA, add(r08AC, r08AF), 0x01));

               body.emit(assign(r07F7, r08AA, 0x01));

               /* IF CONDITION */
               ir_expression *const r08B1 = equal(r07F9, body.constant(int(0)));
               ir_if *f08B0 = new(mem_ctx) ir_if(operand(r08B1).val);
               exec_list *const f08B0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f08B0->then_instructions;

                  ir_variable *const r08B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r08B2);
                  ir_expression *const r08B3 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r08B2, add(r08B3, r08AA), 0x02));

                  body.emit(assign(r08B2, r08AB, 0x01));

                  body.emit(assign(r07F1, r08B2, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f08B0->else_instructions;

                  body.emit(assign(r07F7, bit_or(r08AA, body.constant(2097152u)), 0x01));

                  body.emit(assign(r07F5, r07F9, 0x01));

                  ir_variable *const r08B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r08B4);
                  ir_variable *const r08B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r08B5);
                  ir_variable *const r08B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r08B6);
                  body.emit(assign(r08B4, lshift(r08AB, body.constant(int(31))), 0x01));

                  ir_expression *const r08B7 = lshift(r07F7, body.constant(int(31)));
                  ir_expression *const r08B8 = rshift(r08AB, body.constant(int(1)));
                  body.emit(assign(r08B5, bit_or(r08B7, r08B8), 0x01));

                  body.emit(assign(r08B6, rshift(r07F7, body.constant(int(1))), 0x01));

                  body.emit(assign(r08B4, bit_or(r08B4, body.constant(0u)), 0x01));

                  body.emit(assign(r07F7, r08B6, 0x01));

                  body.emit(assign(r07F6, r08B4, 0x01));

                  ir_variable *const r08B9 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r08B9, r07F9, 0x01));

                  ir_variable *const r08BA = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r08BA, r08B6, 0x01));

                  ir_variable *const r08BB = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r08BB, r08B5, 0x01));

                  ir_variable *const r08BC = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r08BC, r08B4, 0x01));

                  ir_variable *const r08BD = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r08BD, body.constant(true), 0x01));

                  ir_variable *const r08BE = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r08BF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r08BF);
                  ir_expression *const r08C0 = expr(ir_unop_u2i, r08B4);
                  body.emit(assign(r08BF, less(r08C0, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r08C2 = lequal(body.constant(int(2045)), r07F9);
                  ir_if *f08C1 = new(mem_ctx) ir_if(operand(r08C2).val);
                  exec_list *const f08C1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08C1->then_instructions;

                     ir_variable *const r08C3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08C5 = less(body.constant(int(2045)), r07F9);
                     ir_if *f08C4 = new(mem_ctx) ir_if(operand(r08C5).val);
                     exec_list *const f08C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08C4->then_instructions;

                        body.emit(assign(r08C3, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08C4->else_instructions;

                        ir_variable *const r08C6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r08C8 = equal(r07F9, body.constant(int(2045)));
                        ir_if *f08C7 = new(mem_ctx) ir_if(operand(r08C8).val);
                        exec_list *const f08C7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08C7->then_instructions;

                           ir_expression *const r08C9 = equal(body.constant(2097151u), r08B6);
                           ir_expression *const r08CA = equal(body.constant(4294967295u), r08B5);
                           body.emit(assign(r08C6, logic_and(r08C9, r08CA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f08C7->else_instructions;

                           body.emit(assign(r08C6, body.constant(false), 0x01));


                        body.instructions = f08C7_parent_instructions;
                        body.emit(f08C7);

                        /* END IF */

                        body.emit(assign(r08C3, logic_and(r08C6, r08BF), 0x01));


                     body.instructions = f08C4_parent_instructions;
                     body.emit(f08C4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f08CB = new(mem_ctx) ir_if(operand(r08C3).val);
                     exec_list *const f08CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08CB->then_instructions;

                        ir_variable *const r08CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r08CC);
                        ir_expression *const r08CD = lshift(r07EC, body.constant(int(31)));
                        body.emit(assign(r08CC, add(r08CD, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r08CC, body.constant(0u), 0x01));

                        body.emit(assign(r08BE, r08CC, 0x03));

                        body.emit(assign(r08BD, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08CB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08CF = less(r07F9, body.constant(int(0)));
                        ir_if *f08CE = new(mem_ctx) ir_if(operand(r08CF).val);
                        exec_list *const f08CE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08CE->then_instructions;

                           ir_variable *const r08D0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r08D0, r08B4, 0x01));

                           ir_variable *const r08D1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r08D1, neg(r07F9), 0x01));

                           ir_variable *const r08D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r08D2);
                           ir_variable *const r08D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r08D3);
                           ir_variable *const r08D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r08D4);
                           ir_variable *const r08D5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r08D6 = neg(r08D1);
                           body.emit(assign(r08D5, bit_and(r08D6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r08D8 = equal(r08D1, body.constant(int(0)));
                           ir_if *f08D7 = new(mem_ctx) ir_if(operand(r08D8).val);
                           exec_list *const f08D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f08D7->then_instructions;

                              body.emit(assign(r08D2, r08B4, 0x01));

                              body.emit(assign(r08D3, r08B5, 0x01));

                              body.emit(assign(r08D4, r08B6, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f08D7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r08DA = less(r08D1, body.constant(int(32)));
                              ir_if *f08D9 = new(mem_ctx) ir_if(operand(r08DA).val);
                              exec_list *const f08D9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f08D9->then_instructions;

                                 body.emit(assign(r08D2, lshift(r08B5, r08D5), 0x01));

                                 ir_expression *const r08DB = lshift(r08B6, r08D5);
                                 ir_expression *const r08DC = rshift(r08B5, r08D1);
                                 body.emit(assign(r08D3, bit_or(r08DB, r08DC), 0x01));

                                 body.emit(assign(r08D4, rshift(r08B6, r08D1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f08D9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r08DE = equal(r08D1, body.constant(int(32)));
                                 ir_if *f08DD = new(mem_ctx) ir_if(operand(r08DE).val);
                                 exec_list *const f08DD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f08DD->then_instructions;

                                    body.emit(assign(r08D2, r08B5, 0x01));

                                    body.emit(assign(r08D3, r08B6, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f08DD->else_instructions;

                                    body.emit(assign(r08D0, bit_or(r08B4, r08B5), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r08E0 = less(r08D1, body.constant(int(64)));
                                    ir_if *f08DF = new(mem_ctx) ir_if(operand(r08E0).val);
                                    exec_list *const f08DF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f08DF->then_instructions;

                                       body.emit(assign(r08D2, lshift(r08B6, r08D5), 0x01));

                                       ir_expression *const r08E1 = bit_and(r08D1, body.constant(int(31)));
                                       body.emit(assign(r08D3, rshift(r08B6, r08E1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f08DF->else_instructions;

                                       ir_variable *const r08E2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r08E4 = equal(r08D1, body.constant(int(64)));
                                       ir_if *f08E3 = new(mem_ctx) ir_if(operand(r08E4).val);
                                       exec_list *const f08E3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f08E3->then_instructions;

                                          body.emit(assign(r08E2, r08B6, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f08E3->else_instructions;

                                          ir_expression *const r08E5 = nequal(r08B6, body.constant(0u));
                                          ir_expression *const r08E6 = expr(ir_unop_b2i, r08E5);
                                          body.emit(assign(r08E2, expr(ir_unop_i2u, r08E6), 0x01));


                                       body.instructions = f08E3_parent_instructions;
                                       body.emit(f08E3);

                                       /* END IF */

                                       body.emit(assign(r08D2, r08E2, 0x01));

                                       body.emit(assign(r08D3, body.constant(0u), 0x01));


                                    body.instructions = f08DF_parent_instructions;
                                    body.emit(f08DF);

                                    /* END IF */


                                 body.instructions = f08DD_parent_instructions;
                                 body.emit(f08DD);

                                 /* END IF */

                                 body.emit(assign(r08D4, body.constant(0u), 0x01));


                              body.instructions = f08D9_parent_instructions;
                              body.emit(f08D9);

                              /* END IF */

                              ir_expression *const r08E7 = nequal(r08D0, body.constant(0u));
                              ir_expression *const r08E8 = expr(ir_unop_b2i, r08E7);
                              ir_expression *const r08E9 = expr(ir_unop_i2u, r08E8);
                              body.emit(assign(r08D2, bit_or(r08D2, r08E9), 0x01));


                           body.instructions = f08D7_parent_instructions;
                           body.emit(f08D7);

                           /* END IF */

                           body.emit(assign(r08BA, r08D4, 0x01));

                           body.emit(assign(r08BB, r08D3, 0x01));

                           body.emit(assign(r08BC, r08D2, 0x01));

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));

                           body.emit(assign(r08BF, less(r08D2, body.constant(0u)), 0x01));


                        body.instructions = f08CE_parent_instructions;
                        body.emit(f08CE);

                        /* END IF */


                     body.instructions = f08CB_parent_instructions;
                     body.emit(f08CB);

                     /* END IF */


                  body.instructions = f08C1_parent_instructions;
                  body.emit(f08C1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f08EA = new(mem_ctx) ir_if(operand(r08BD).val);
                  exec_list *const f08EA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08EA->then_instructions;

                     /* IF CONDITION */
                     ir_if *f08EB = new(mem_ctx) ir_if(operand(r08BF).val);
                     exec_list *const f08EB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08EB->then_instructions;

                        ir_variable *const r08EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r08EC, add(r08BB, body.constant(1u)), 0x01));

                        ir_expression *const r08ED = less(r08EC, r08BB);
                        ir_expression *const r08EE = expr(ir_unop_b2i, r08ED);
                        ir_expression *const r08EF = expr(ir_unop_i2u, r08EE);
                        body.emit(assign(r08BA, add(r08BA, r08EF), 0x01));

                        ir_expression *const r08F0 = equal(r08BC, body.constant(0u));
                        ir_expression *const r08F1 = expr(ir_unop_b2i, r08F0);
                        ir_expression *const r08F2 = expr(ir_unop_i2u, r08F1);
                        ir_expression *const r08F3 = add(r08BC, r08F2);
                        ir_expression *const r08F4 = bit_and(r08F3, body.constant(1u));
                        ir_expression *const r08F5 = expr(ir_unop_bit_not, r08F4);
                        body.emit(assign(r08BB, bit_and(r08EC, r08F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08EB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08F7 = bit_or(r08BA, r08BB);
                        ir_expression *const r08F8 = equal(r08F7, body.constant(0u));
                        ir_if *f08F6 = new(mem_ctx) ir_if(operand(r08F8).val);
                        exec_list *const f08F6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08F6->then_instructions;

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));


                        body.instructions = f08F6_parent_instructions;
                        body.emit(f08F6);

                        /* END IF */


                     body.instructions = f08EB_parent_instructions;
                     body.emit(f08EB);

                     /* END IF */

                     ir_variable *const r08F9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r08F9);
                     ir_expression *const r08FA = lshift(r07EC, body.constant(int(31)));
                     ir_expression *const r08FB = expr(ir_unop_i2u, r08B9);
                     ir_expression *const r08FC = lshift(r08FB, body.constant(int(20)));
                     ir_expression *const r08FD = add(r08FA, r08FC);
                     body.emit(assign(r08F9, add(r08FD, r08BA), 0x02));

                     body.emit(assign(r08F9, r08BB, 0x01));

                     body.emit(assign(r08BE, r08F9, 0x03));

                     body.emit(assign(r08BD, body.constant(false), 0x01));


                  body.instructions = f08EA_parent_instructions;
                  body.emit(f08EA);

                  /* END IF */

                  body.emit(assign(r07F1, r08BE, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f08B0_parent_instructions;
               body.emit(f08B0);

               /* END IF */


            body.instructions = f0886_parent_instructions;
            body.emit(f0886);

            /* END IF */


         body.instructions = f0842_parent_instructions;
         body.emit(f0842);

         /* END IF */


      body.instructions = f0801_parent_instructions;
      body.emit(f0801);

      /* END IF */

      /* IF CONDITION */
      ir_if *f08FE = new(mem_ctx) ir_if(operand(r07F0).val);
      exec_list *const f08FE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f08FE->then_instructions;

         body.emit(assign(r07F4, bit_or(swizzle_y(r07F4), body.constant(1048576u)), 0x02));

         ir_variable *const r08FF = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0900 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r0900, add(swizzle_x(r07F4), swizzle_x(r07F3)), 0x01));

         ir_expression *const r0901 = add(swizzle_y(r07F4), swizzle_y(r07F3));
         ir_expression *const r0902 = less(r0900, swizzle_x(r07F4));
         ir_expression *const r0903 = expr(ir_unop_b2i, r0902);
         ir_expression *const r0904 = expr(ir_unop_i2u, r0903);
         body.emit(assign(r08FF, add(r0901, r0904), 0x01));

         body.emit(assign(r07F7, r08FF, 0x01));

         body.emit(assign(r07F5, add(r07F5, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0906 = less(r08FF, body.constant(2097152u));
         ir_if *f0905 = new(mem_ctx) ir_if(operand(r0906).val);
         exec_list *const f0905_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0905->then_instructions;

            ir_variable *const r0907 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0907, r07F5, 0x01));

            ir_variable *const r0908 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0908, r08FF, 0x01));

            ir_variable *const r0909 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0909, r0900, 0x01));

            ir_variable *const r090A = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r090A, r07F6, 0x01));

            ir_variable *const r090B = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r090B, body.constant(true), 0x01));

            ir_variable *const r090C = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r090D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r090D);
            ir_expression *const r090E = expr(ir_unop_u2i, r07F6);
            body.emit(assign(r090D, less(r090E, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0910 = lequal(body.constant(int(2045)), r07F5);
            ir_if *f090F = new(mem_ctx) ir_if(operand(r0910).val);
            exec_list *const f090F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f090F->then_instructions;

               ir_variable *const r0911 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0913 = less(body.constant(int(2045)), r07F5);
               ir_if *f0912 = new(mem_ctx) ir_if(operand(r0913).val);
               exec_list *const f0912_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0912->then_instructions;

                  body.emit(assign(r0911, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0912->else_instructions;

                  ir_variable *const r0914 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0916 = equal(r07F5, body.constant(int(2045)));
                  ir_if *f0915 = new(mem_ctx) ir_if(operand(r0916).val);
                  exec_list *const f0915_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0915->then_instructions;

                     ir_expression *const r0917 = equal(body.constant(2097151u), r08FF);
                     ir_expression *const r0918 = equal(body.constant(4294967295u), r0900);
                     body.emit(assign(r0914, logic_and(r0917, r0918), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0915->else_instructions;

                     body.emit(assign(r0914, body.constant(false), 0x01));


                  body.instructions = f0915_parent_instructions;
                  body.emit(f0915);

                  /* END IF */

                  body.emit(assign(r0911, logic_and(r0914, r090D), 0x01));


               body.instructions = f0912_parent_instructions;
               body.emit(f0912);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0919 = new(mem_ctx) ir_if(operand(r0911).val);
               exec_list *const f0919_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0919->then_instructions;

                  ir_variable *const r091A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r091A);
                  ir_expression *const r091B = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r091A, add(r091B, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r091A, body.constant(0u), 0x01));

                  body.emit(assign(r090C, r091A, 0x03));

                  body.emit(assign(r090B, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0919->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r091D = less(r07F5, body.constant(int(0)));
                  ir_if *f091C = new(mem_ctx) ir_if(operand(r091D).val);
                  exec_list *const f091C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f091C->then_instructions;

                     ir_variable *const r091E = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r091E, r07F6, 0x01));

                     ir_variable *const r091F = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r091F, neg(r07F5), 0x01));

                     ir_variable *const r0920 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0920);
                     ir_variable *const r0921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0921);
                     ir_variable *const r0922 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0922);
                     ir_variable *const r0923 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0924 = neg(r091F);
                     body.emit(assign(r0923, bit_and(r0924, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0926 = equal(r091F, body.constant(int(0)));
                     ir_if *f0925 = new(mem_ctx) ir_if(operand(r0926).val);
                     exec_list *const f0925_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0925->then_instructions;

                        body.emit(assign(r0920, r07F6, 0x01));

                        body.emit(assign(r0921, r0900, 0x01));

                        body.emit(assign(r0922, r08FF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0925->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0928 = less(r091F, body.constant(int(32)));
                        ir_if *f0927 = new(mem_ctx) ir_if(operand(r0928).val);
                        exec_list *const f0927_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0927->then_instructions;

                           body.emit(assign(r0920, lshift(r0900, r0923), 0x01));

                           ir_expression *const r0929 = lshift(r08FF, r0923);
                           ir_expression *const r092A = rshift(r0900, r091F);
                           body.emit(assign(r0921, bit_or(r0929, r092A), 0x01));

                           body.emit(assign(r0922, rshift(r08FF, r091F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0927->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r092C = equal(r091F, body.constant(int(32)));
                           ir_if *f092B = new(mem_ctx) ir_if(operand(r092C).val);
                           exec_list *const f092B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f092B->then_instructions;

                              body.emit(assign(r0920, r0900, 0x01));

                              body.emit(assign(r0921, r08FF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f092B->else_instructions;

                              body.emit(assign(r091E, bit_or(r07F6, r0900), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r092E = less(r091F, body.constant(int(64)));
                              ir_if *f092D = new(mem_ctx) ir_if(operand(r092E).val);
                              exec_list *const f092D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f092D->then_instructions;

                                 body.emit(assign(r0920, lshift(r08FF, r0923), 0x01));

                                 ir_expression *const r092F = bit_and(r091F, body.constant(int(31)));
                                 body.emit(assign(r0921, rshift(r08FF, r092F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f092D->else_instructions;

                                 ir_variable *const r0930 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0932 = equal(r091F, body.constant(int(64)));
                                 ir_if *f0931 = new(mem_ctx) ir_if(operand(r0932).val);
                                 exec_list *const f0931_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0931->then_instructions;

                                    body.emit(assign(r0930, r08FF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0931->else_instructions;

                                    ir_expression *const r0933 = nequal(r08FF, body.constant(0u));
                                    ir_expression *const r0934 = expr(ir_unop_b2i, r0933);
                                    body.emit(assign(r0930, expr(ir_unop_i2u, r0934), 0x01));


                                 body.instructions = f0931_parent_instructions;
                                 body.emit(f0931);

                                 /* END IF */

                                 body.emit(assign(r0920, r0930, 0x01));

                                 body.emit(assign(r0921, body.constant(0u), 0x01));


                              body.instructions = f092D_parent_instructions;
                              body.emit(f092D);

                              /* END IF */


                           body.instructions = f092B_parent_instructions;
                           body.emit(f092B);

                           /* END IF */

                           body.emit(assign(r0922, body.constant(0u), 0x01));


                        body.instructions = f0927_parent_instructions;
                        body.emit(f0927);

                        /* END IF */

                        ir_expression *const r0935 = nequal(r091E, body.constant(0u));
                        ir_expression *const r0936 = expr(ir_unop_b2i, r0935);
                        ir_expression *const r0937 = expr(ir_unop_i2u, r0936);
                        body.emit(assign(r0920, bit_or(r0920, r0937), 0x01));


                     body.instructions = f0925_parent_instructions;
                     body.emit(f0925);

                     /* END IF */

                     body.emit(assign(r0908, r0922, 0x01));

                     body.emit(assign(r0909, r0921, 0x01));

                     body.emit(assign(r090A, r0920, 0x01));

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));

                     body.emit(assign(r090D, less(r0920, body.constant(0u)), 0x01));


                  body.instructions = f091C_parent_instructions;
                  body.emit(f091C);

                  /* END IF */


               body.instructions = f0919_parent_instructions;
               body.emit(f0919);

               /* END IF */


            body.instructions = f090F_parent_instructions;
            body.emit(f090F);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0938 = new(mem_ctx) ir_if(operand(r090B).val);
            exec_list *const f0938_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0938->then_instructions;

               /* IF CONDITION */
               ir_if *f0939 = new(mem_ctx) ir_if(operand(r090D).val);
               exec_list *const f0939_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0939->then_instructions;

                  ir_variable *const r093A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r093A, add(r0909, body.constant(1u)), 0x01));

                  ir_expression *const r093B = less(r093A, r0909);
                  ir_expression *const r093C = expr(ir_unop_b2i, r093B);
                  ir_expression *const r093D = expr(ir_unop_i2u, r093C);
                  body.emit(assign(r0908, add(r0908, r093D), 0x01));

                  ir_expression *const r093E = equal(r090A, body.constant(0u));
                  ir_expression *const r093F = expr(ir_unop_b2i, r093E);
                  ir_expression *const r0940 = expr(ir_unop_i2u, r093F);
                  ir_expression *const r0941 = add(r090A, r0940);
                  ir_expression *const r0942 = bit_and(r0941, body.constant(1u));
                  ir_expression *const r0943 = expr(ir_unop_bit_not, r0942);
                  body.emit(assign(r0909, bit_and(r093A, r0943), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0939->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0945 = bit_or(r0908, r0909);
                  ir_expression *const r0946 = equal(r0945, body.constant(0u));
                  ir_if *f0944 = new(mem_ctx) ir_if(operand(r0946).val);
                  exec_list *const f0944_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0944->then_instructions;

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));


                  body.instructions = f0944_parent_instructions;
                  body.emit(f0944);

                  /* END IF */


               body.instructions = f0939_parent_instructions;
               body.emit(f0939);

               /* END IF */

               ir_variable *const r0947 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0947);
               ir_expression *const r0948 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0949 = expr(ir_unop_i2u, r0907);
               ir_expression *const r094A = lshift(r0949, body.constant(int(20)));
               ir_expression *const r094B = add(r0948, r094A);
               body.emit(assign(r0947, add(r094B, r0908), 0x02));

               body.emit(assign(r0947, r0909, 0x01));

               body.emit(assign(r090C, r0947, 0x03));

               body.emit(assign(r090B, body.constant(false), 0x01));


            body.instructions = f0938_parent_instructions;
            body.emit(f0938);

            /* END IF */

            body.emit(assign(r07F1, r090C, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0905->else_instructions;

            body.emit(assign(r07F5, add(r07F5, body.constant(int(1))), 0x01));

            ir_variable *const r094C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r094C);
            ir_variable *const r094D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r094D);
            ir_variable *const r094E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r094E);
            body.emit(assign(r094C, lshift(r0900, body.constant(int(31))), 0x01));

            ir_expression *const r094F = lshift(r08FF, body.constant(int(31)));
            ir_expression *const r0950 = rshift(r0900, body.constant(int(1)));
            body.emit(assign(r094D, bit_or(r094F, r0950), 0x01));

            body.emit(assign(r094E, rshift(r08FF, body.constant(int(1))), 0x01));

            ir_expression *const r0951 = nequal(r07F6, body.constant(0u));
            ir_expression *const r0952 = expr(ir_unop_b2i, r0951);
            ir_expression *const r0953 = expr(ir_unop_i2u, r0952);
            body.emit(assign(r094C, bit_or(r094C, r0953), 0x01));

            body.emit(assign(r07F7, r094E, 0x01));

            body.emit(assign(r07F6, r094C, 0x01));

            ir_variable *const r0954 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0954, r07F5, 0x01));

            ir_variable *const r0955 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0955, r094E, 0x01));

            ir_variable *const r0956 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0956, r094D, 0x01));

            ir_variable *const r0957 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0957, r094C, 0x01));

            ir_variable *const r0958 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0958, body.constant(true), 0x01));

            ir_variable *const r0959 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r095A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r095A);
            ir_expression *const r095B = expr(ir_unop_u2i, r094C);
            body.emit(assign(r095A, less(r095B, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r095D = lequal(body.constant(int(2045)), r07F5);
            ir_if *f095C = new(mem_ctx) ir_if(operand(r095D).val);
            exec_list *const f095C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f095C->then_instructions;

               ir_variable *const r095E = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0960 = less(body.constant(int(2045)), r07F5);
               ir_if *f095F = new(mem_ctx) ir_if(operand(r0960).val);
               exec_list *const f095F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f095F->then_instructions;

                  body.emit(assign(r095E, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f095F->else_instructions;

                  ir_variable *const r0961 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0963 = equal(r07F5, body.constant(int(2045)));
                  ir_if *f0962 = new(mem_ctx) ir_if(operand(r0963).val);
                  exec_list *const f0962_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0962->then_instructions;

                     ir_expression *const r0964 = equal(body.constant(2097151u), r094E);
                     ir_expression *const r0965 = equal(body.constant(4294967295u), r094D);
                     body.emit(assign(r0961, logic_and(r0964, r0965), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0962->else_instructions;

                     body.emit(assign(r0961, body.constant(false), 0x01));


                  body.instructions = f0962_parent_instructions;
                  body.emit(f0962);

                  /* END IF */

                  body.emit(assign(r095E, logic_and(r0961, r095A), 0x01));


               body.instructions = f095F_parent_instructions;
               body.emit(f095F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0966 = new(mem_ctx) ir_if(operand(r095E).val);
               exec_list *const f0966_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0966->then_instructions;

                  ir_variable *const r0967 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0967);
                  ir_expression *const r0968 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0967, add(r0968, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0967, body.constant(0u), 0x01));

                  body.emit(assign(r0959, r0967, 0x03));

                  body.emit(assign(r0958, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0966->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r096A = less(r07F5, body.constant(int(0)));
                  ir_if *f0969 = new(mem_ctx) ir_if(operand(r096A).val);
                  exec_list *const f0969_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0969->then_instructions;

                     ir_variable *const r096B = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r096B, r094C, 0x01));

                     ir_variable *const r096C = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r096C, neg(r07F5), 0x01));

                     ir_variable *const r096D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r096D);
                     ir_variable *const r096E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r096E);
                     ir_variable *const r096F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r096F);
                     ir_variable *const r0970 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0971 = neg(r096C);
                     body.emit(assign(r0970, bit_and(r0971, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0973 = equal(r096C, body.constant(int(0)));
                     ir_if *f0972 = new(mem_ctx) ir_if(operand(r0973).val);
                     exec_list *const f0972_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0972->then_instructions;

                        body.emit(assign(r096D, r094C, 0x01));

                        body.emit(assign(r096E, r094D, 0x01));

                        body.emit(assign(r096F, r094E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0972->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0975 = less(r096C, body.constant(int(32)));
                        ir_if *f0974 = new(mem_ctx) ir_if(operand(r0975).val);
                        exec_list *const f0974_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0974->then_instructions;

                           body.emit(assign(r096D, lshift(r094D, r0970), 0x01));

                           ir_expression *const r0976 = lshift(r094E, r0970);
                           ir_expression *const r0977 = rshift(r094D, r096C);
                           body.emit(assign(r096E, bit_or(r0976, r0977), 0x01));

                           body.emit(assign(r096F, rshift(r094E, r096C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0974->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0979 = equal(r096C, body.constant(int(32)));
                           ir_if *f0978 = new(mem_ctx) ir_if(operand(r0979).val);
                           exec_list *const f0978_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0978->then_instructions;

                              body.emit(assign(r096D, r094D, 0x01));

                              body.emit(assign(r096E, r094E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0978->else_instructions;

                              body.emit(assign(r096B, bit_or(r094C, r094D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r097B = less(r096C, body.constant(int(64)));
                              ir_if *f097A = new(mem_ctx) ir_if(operand(r097B).val);
                              exec_list *const f097A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f097A->then_instructions;

                                 body.emit(assign(r096D, lshift(r094E, r0970), 0x01));

                                 ir_expression *const r097C = bit_and(r096C, body.constant(int(31)));
                                 body.emit(assign(r096E, rshift(r094E, r097C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f097A->else_instructions;

                                 ir_variable *const r097D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r097F = equal(r096C, body.constant(int(64)));
                                 ir_if *f097E = new(mem_ctx) ir_if(operand(r097F).val);
                                 exec_list *const f097E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f097E->then_instructions;

                                    body.emit(assign(r097D, r094E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f097E->else_instructions;

                                    ir_expression *const r0980 = nequal(r094E, body.constant(0u));
                                    ir_expression *const r0981 = expr(ir_unop_b2i, r0980);
                                    body.emit(assign(r097D, expr(ir_unop_i2u, r0981), 0x01));


                                 body.instructions = f097E_parent_instructions;
                                 body.emit(f097E);

                                 /* END IF */

                                 body.emit(assign(r096D, r097D, 0x01));

                                 body.emit(assign(r096E, body.constant(0u), 0x01));


                              body.instructions = f097A_parent_instructions;
                              body.emit(f097A);

                              /* END IF */


                           body.instructions = f0978_parent_instructions;
                           body.emit(f0978);

                           /* END IF */

                           body.emit(assign(r096F, body.constant(0u), 0x01));


                        body.instructions = f0974_parent_instructions;
                        body.emit(f0974);

                        /* END IF */

                        ir_expression *const r0982 = nequal(r096B, body.constant(0u));
                        ir_expression *const r0983 = expr(ir_unop_b2i, r0982);
                        ir_expression *const r0984 = expr(ir_unop_i2u, r0983);
                        body.emit(assign(r096D, bit_or(r096D, r0984), 0x01));


                     body.instructions = f0972_parent_instructions;
                     body.emit(f0972);

                     /* END IF */

                     body.emit(assign(r0955, r096F, 0x01));

                     body.emit(assign(r0956, r096E, 0x01));

                     body.emit(assign(r0957, r096D, 0x01));

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));

                     body.emit(assign(r095A, less(r096D, body.constant(0u)), 0x01));


                  body.instructions = f0969_parent_instructions;
                  body.emit(f0969);

                  /* END IF */


               body.instructions = f0966_parent_instructions;
               body.emit(f0966);

               /* END IF */


            body.instructions = f095C_parent_instructions;
            body.emit(f095C);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0985 = new(mem_ctx) ir_if(operand(r0958).val);
            exec_list *const f0985_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0985->then_instructions;

               /* IF CONDITION */
               ir_if *f0986 = new(mem_ctx) ir_if(operand(r095A).val);
               exec_list *const f0986_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0986->then_instructions;

                  ir_variable *const r0987 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0987, add(r0956, body.constant(1u)), 0x01));

                  ir_expression *const r0988 = less(r0987, r0956);
                  ir_expression *const r0989 = expr(ir_unop_b2i, r0988);
                  ir_expression *const r098A = expr(ir_unop_i2u, r0989);
                  body.emit(assign(r0955, add(r0955, r098A), 0x01));

                  ir_expression *const r098B = equal(r0957, body.constant(0u));
                  ir_expression *const r098C = expr(ir_unop_b2i, r098B);
                  ir_expression *const r098D = expr(ir_unop_i2u, r098C);
                  ir_expression *const r098E = add(r0957, r098D);
                  ir_expression *const r098F = bit_and(r098E, body.constant(1u));
                  ir_expression *const r0990 = expr(ir_unop_bit_not, r098F);
                  body.emit(assign(r0956, bit_and(r0987, r0990), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0986->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0992 = bit_or(r0955, r0956);
                  ir_expression *const r0993 = equal(r0992, body.constant(0u));
                  ir_if *f0991 = new(mem_ctx) ir_if(operand(r0993).val);
                  exec_list *const f0991_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0991->then_instructions;

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));


                  body.instructions = f0991_parent_instructions;
                  body.emit(f0991);

                  /* END IF */


               body.instructions = f0986_parent_instructions;
               body.emit(f0986);

               /* END IF */

               ir_variable *const r0994 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0994);
               ir_expression *const r0995 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0996 = expr(ir_unop_i2u, r0954);
               ir_expression *const r0997 = lshift(r0996, body.constant(int(20)));
               ir_expression *const r0998 = add(r0995, r0997);
               body.emit(assign(r0994, add(r0998, r0955), 0x02));

               body.emit(assign(r0994, r0956, 0x01));

               body.emit(assign(r0959, r0994, 0x03));

               body.emit(assign(r0958, body.constant(false), 0x01));


            body.instructions = f0985_parent_instructions;
            body.emit(f0985);

            /* END IF */

            body.emit(assign(r07F1, r0959, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


         body.instructions = f0905_parent_instructions;
         body.emit(f0905);

         /* END IF */


      body.instructions = f08FE_parent_instructions;
      body.emit(f08FE);

      /* END IF */

      body.emit(assign(r07EB, r07F1, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f07EE->else_instructions;

      ir_variable *const r0999 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0999, r07EC, 0x01));

      ir_variable *const r099A = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r099B = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r099B);
      ir_variable *const r099C = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r099C);
      ir_variable *const r099D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r099D);
      ir_variable *const r099E = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r099E);
      ir_variable *const r099F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r099F);
      ir_variable *const r09A0 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r09A0);
      ir_variable *const r09A1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r09A1);
      body.emit(assign(r09A1, bit_and(swizzle_y(r07E9), body.constant(1048575u)), 0x02));

      body.emit(assign(r09A1, swizzle_x(r07E9), 0x01));

      ir_variable *const r09A2 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A3 = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r09A4 = bit_and(r09A3, body.constant(2047u));
      body.emit(assign(r09A2, expr(ir_unop_u2i, r09A4), 0x01));

      body.emit(assign(r099E, r09A2, 0x01));

      ir_variable *const r09A5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r09A5);
      body.emit(assign(r09A5, bit_and(swizzle_y(r07EA), body.constant(1048575u)), 0x02));

      body.emit(assign(r09A5, swizzle_x(r07EA), 0x01));

      ir_variable *const r09A6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A7 = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r09A8 = bit_and(r09A7, body.constant(2047u));
      body.emit(assign(r09A6, expr(ir_unop_u2i, r09A8), 0x01));

      body.emit(assign(r099C, r09A6, 0x01));

      body.emit(assign(r099B, sub(r09A2, r09A6), 0x01));

      ir_variable *const r09A9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09A9, lshift(swizzle_x(r07E9), body.constant(int(10))), 0x01));

      ir_variable *const r09AA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09AB = lshift(swizzle_y(r09A1), body.constant(int(10)));
      ir_expression *const r09AC = rshift(swizzle_x(r07E9), body.constant(int(22)));
      body.emit(assign(r09AA, bit_or(r09AB, r09AC), 0x01));

      body.emit(assign(r099F, r09AA, 0x02));

      body.emit(assign(r099F, r09A9, 0x01));

      ir_variable *const r09AD = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09AD, lshift(swizzle_x(r07EA), body.constant(int(10))), 0x01));

      ir_variable *const r09AE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09AF = lshift(swizzle_y(r09A5), body.constant(int(10)));
      ir_expression *const r09B0 = rshift(swizzle_x(r07EA), body.constant(int(22)));
      body.emit(assign(r09AE, bit_or(r09AF, r09B0), 0x01));

      body.emit(assign(r099D, r09AE, 0x02));

      body.emit(assign(r099D, r09AD, 0x01));

      /* IF CONDITION */
      ir_expression *const r09B2 = less(body.constant(int(0)), r099B);
      ir_if *f09B1 = new(mem_ctx) ir_if(operand(r09B2).val);
      exec_list *const f09B1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f09B1->then_instructions;

         /* IF CONDITION */
         ir_expression *const r09B4 = equal(r09A2, body.constant(int(2047)));
         ir_if *f09B3 = new(mem_ctx) ir_if(operand(r09B4).val);
         exec_list *const f09B3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f09B3->then_instructions;

            /* IF CONDITION */
            ir_expression *const r09B6 = bit_or(r09AA, r09A9);
            ir_expression *const r09B7 = nequal(r09B6, body.constant(0u));
            ir_if *f09B5 = new(mem_ctx) ir_if(operand(r09B7).val);
            exec_list *const f09B5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09B5->then_instructions;

               ir_variable *const r09B8 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r09B8, swizzle_x(r07E9), 0x01));

               ir_variable *const r09B9 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r09B9, swizzle_x(r07EA), 0x01));

               ir_variable *const r09BA = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r09BB = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r09BC = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r09BD = bit_and(r09BC, body.constant(4095u));
               ir_expression *const r09BE = equal(r09BD, body.constant(4094u));
               ir_expression *const r09BF = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09C0 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r09C1 = nequal(r09C0, body.constant(0u));
               ir_expression *const r09C2 = logic_or(r09BF, r09C1);
               body.emit(assign(r09BB, logic_and(r09BE, r09C2), 0x01));

               ir_variable *const r09C3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r09C4 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r09C5 = lequal(body.constant(4292870144u), r09C4);
               ir_expression *const r09C6 = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r09C7 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r09C8 = nequal(r09C7, body.constant(0u));
               ir_expression *const r09C9 = logic_or(r09C6, r09C8);
               body.emit(assign(r09C3, logic_and(r09C5, r09C9), 0x01));

               body.emit(assign(r09B8, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r09B9, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r09CB = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r09CC = lequal(body.constant(4292870144u), r09CB);
               ir_expression *const r09CD = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09CE = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r09CF = nequal(r09CE, body.constant(0u));
               ir_expression *const r09D0 = logic_or(r09CD, r09CF);
               ir_expression *const r09D1 = logic_and(r09CC, r09D0);
               ir_if *f09CA = new(mem_ctx) ir_if(operand(r09D1).val);
               exec_list *const f09CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09CA->then_instructions;

                  ir_variable *const r09D2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r09D4 = logic_and(r09BB, r09C3);
                  ir_if *f09D3 = new(mem_ctx) ir_if(operand(r09D4).val);
                  exec_list *const f09D3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09D3->then_instructions;

                     body.emit(assign(r09D2, r09B9, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09D3->else_instructions;

                     body.emit(assign(r09D2, r09B8, 0x03));


                  body.instructions = f09D3_parent_instructions;
                  body.emit(f09D3);

                  /* END IF */

                  body.emit(assign(r09BA, r09D2, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09CA->else_instructions;

                  body.emit(assign(r09BA, r09B9, 0x03));


               body.instructions = f09CA_parent_instructions;
               body.emit(f09CA);

               /* END IF */

               body.emit(assign(r099A, r09BA, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09B5->else_instructions;

               body.emit(assign(r099A, r07E9, 0x03));


            body.instructions = f09B5_parent_instructions;
            body.emit(f09B5);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f09B3->else_instructions;

            /* IF CONDITION */
            ir_expression *const r09D6 = equal(r09A6, body.constant(int(0)));
            ir_if *f09D5 = new(mem_ctx) ir_if(operand(r09D6).val);
            exec_list *const f09D5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09D5->then_instructions;

               body.emit(assign(r099B, add(r099B, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09D5->else_instructions;

               body.emit(assign(r099D, bit_or(r09AE, body.constant(1073741824u)), 0x02));


            body.instructions = f09D5_parent_instructions;
            body.emit(f09D5);

            /* END IF */

            ir_variable *const r09D7 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r09D7, swizzle_y(r099D), 0x01));

            ir_variable *const r09D8 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r09D8, swizzle_x(r099D), 0x01));

            ir_variable *const r09D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r09D9);
            ir_variable *const r09DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r09DA);
            ir_variable *const r09DB = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r09DC = neg(r099B);
            body.emit(assign(r09DB, bit_and(r09DC, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r09DE = equal(r099B, body.constant(int(0)));
            ir_if *f09DD = new(mem_ctx) ir_if(operand(r09DE).val);
            exec_list *const f09DD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09DD->then_instructions;

               body.emit(assign(r09D9, r09D8, 0x01));

               body.emit(assign(r09DA, r09D7, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09DD->else_instructions;

               /* IF CONDITION */
               ir_expression *const r09E0 = less(r099B, body.constant(int(32)));
               ir_if *f09DF = new(mem_ctx) ir_if(operand(r09E0).val);
               exec_list *const f09DF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09DF->then_instructions;

                  ir_expression *const r09E1 = lshift(swizzle_y(r099D), r09DB);
                  ir_expression *const r09E2 = rshift(r09AD, r099B);
                  ir_expression *const r09E3 = bit_or(r09E1, r09E2);
                  ir_expression *const r09E4 = lshift(r09AD, r09DB);
                  ir_expression *const r09E5 = nequal(r09E4, body.constant(0u));
                  ir_expression *const r09E6 = expr(ir_unop_b2i, r09E5);
                  ir_expression *const r09E7 = expr(ir_unop_i2u, r09E6);
                  body.emit(assign(r09D9, bit_or(r09E3, r09E7), 0x01));

                  body.emit(assign(r09DA, rshift(swizzle_y(r099D), r099B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09DF->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r09E9 = equal(r099B, body.constant(int(32)));
                  ir_if *f09E8 = new(mem_ctx) ir_if(operand(r09E9).val);
                  exec_list *const f09E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09E8->then_instructions;

                     ir_expression *const r09EA = nequal(r09AD, body.constant(0u));
                     ir_expression *const r09EB = expr(ir_unop_b2i, r09EA);
                     ir_expression *const r09EC = expr(ir_unop_i2u, r09EB);
                     body.emit(assign(r09D9, bit_or(swizzle_y(r099D), r09EC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09E8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r09EE = less(r099B, body.constant(int(64)));
                     ir_if *f09ED = new(mem_ctx) ir_if(operand(r09EE).val);
                     exec_list *const f09ED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f09ED->then_instructions;

                        ir_expression *const r09EF = bit_and(r099B, body.constant(int(31)));
                        ir_expression *const r09F0 = rshift(swizzle_y(r099D), r09EF);
                        ir_expression *const r09F1 = lshift(swizzle_y(r099D), r09DB);
                        ir_expression *const r09F2 = bit_or(r09F1, r09AD);
                        ir_expression *const r09F3 = nequal(r09F2, body.constant(0u));
                        ir_expression *const r09F4 = expr(ir_unop_b2i, r09F3);
                        ir_expression *const r09F5 = expr(ir_unop_i2u, r09F4);
                        body.emit(assign(r09D9, bit_or(r09F0, r09F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f09ED->else_instructions;

                        ir_expression *const r09F6 = bit_or(swizzle_y(r099D), r09AD);
                        ir_expression *const r09F7 = nequal(r09F6, body.constant(0u));
                        ir_expression *const r09F8 = expr(ir_unop_b2i, r09F7);
                        body.emit(assign(r09D9, expr(ir_unop_i2u, r09F8), 0x01));


                     body.instructions = f09ED_parent_instructions;
                     body.emit(f09ED);

                     /* END IF */


                  body.instructions = f09E8_parent_instructions;
                  body.emit(f09E8);

                  /* END IF */

                  body.emit(assign(r09DA, body.constant(0u), 0x01));


               body.instructions = f09DF_parent_instructions;
               body.emit(f09DF);

               /* END IF */


            body.instructions = f09DD_parent_instructions;
            body.emit(f09DD);

            /* END IF */

            body.emit(assign(r099D, r09DA, 0x02));

            body.emit(assign(r099D, r09D9, 0x01));

            body.emit(assign(r099F, bit_or(r09AA, body.constant(1073741824u)), 0x02));

            ir_variable *const r09F9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r09FA = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r09FA, sub(r09A9, r09D9), 0x01));

            ir_expression *const r09FB = sub(swizzle_y(r099F), r09DA);
            ir_expression *const r09FC = less(r09A9, r09D9);
            ir_expression *const r09FD = expr(ir_unop_b2i, r09FC);
            ir_expression *const r09FE = expr(ir_unop_i2u, r09FD);
            body.emit(assign(r09F9, sub(r09FB, r09FE), 0x01));

            body.emit(assign(r09A0, add(r09A2, body.constant(int(-1))), 0x01));

            ir_variable *const r09FF = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r09FF, add(r09A0, body.constant(int(-10))), 0x01));

            ir_variable *const r0A00 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A00, r09F9, 0x01));

            ir_variable *const r0A01 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A01, r09FA, 0x01));

            ir_variable *const r0A02 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0A02);
            ir_variable *const r0A03 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A03);
            /* IF CONDITION */
            ir_expression *const r0A05 = equal(r09F9, body.constant(0u));
            ir_if *f0A04 = new(mem_ctx) ir_if(operand(r0A05).val);
            exec_list *const f0A04_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A04->then_instructions;

               body.emit(assign(r0A00, r09FA, 0x01));

               body.emit(assign(r0A01, body.constant(0u), 0x01));

               body.emit(assign(r09FF, add(r09FF, body.constant(int(-32))), 0x01));


            body.instructions = f0A04_parent_instructions;
            body.emit(f0A04);

            /* END IF */

            ir_variable *const r0A06 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0A06, r0A00, 0x01));

            ir_variable *const r0A07 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0A08 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A08);
            /* IF CONDITION */
            ir_expression *const r0A0A = equal(r0A00, body.constant(0u));
            ir_if *f0A09 = new(mem_ctx) ir_if(operand(r0A0A).val);
            exec_list *const f0A09_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A09->then_instructions;

               body.emit(assign(r0A07, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A09->else_instructions;

               body.emit(assign(r0A08, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A0C = bit_and(r0A00, body.constant(4294901760u));
               ir_expression *const r0A0D = equal(r0A0C, body.constant(0u));
               ir_if *f0A0B = new(mem_ctx) ir_if(operand(r0A0D).val);
               exec_list *const f0A0B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0B->then_instructions;

                  body.emit(assign(r0A08, body.constant(int(16)), 0x01));

                  body.emit(assign(r0A06, lshift(r0A00, body.constant(int(16))), 0x01));


               body.instructions = f0A0B_parent_instructions;
               body.emit(f0A0B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A0F = bit_and(r0A06, body.constant(4278190080u));
               ir_expression *const r0A10 = equal(r0A0F, body.constant(0u));
               ir_if *f0A0E = new(mem_ctx) ir_if(operand(r0A10).val);
               exec_list *const f0A0E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0E->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(8))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(8))), 0x01));


               body.instructions = f0A0E_parent_instructions;
               body.emit(f0A0E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A12 = bit_and(r0A06, body.constant(4026531840u));
               ir_expression *const r0A13 = equal(r0A12, body.constant(0u));
               ir_if *f0A11 = new(mem_ctx) ir_if(operand(r0A13).val);
               exec_list *const f0A11_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A11->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(4))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(4))), 0x01));


               body.instructions = f0A11_parent_instructions;
               body.emit(f0A11);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A15 = bit_and(r0A06, body.constant(3221225472u));
               ir_expression *const r0A16 = equal(r0A15, body.constant(0u));
               ir_if *f0A14 = new(mem_ctx) ir_if(operand(r0A16).val);
               exec_list *const f0A14_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A14->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(2))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(2))), 0x01));


               body.instructions = f0A14_parent_instructions;
               body.emit(f0A14);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A18 = bit_and(r0A06, body.constant(2147483648u));
               ir_expression *const r0A19 = equal(r0A18, body.constant(0u));
               ir_if *f0A17 = new(mem_ctx) ir_if(operand(r0A19).val);
               exec_list *const f0A17_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A17->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(1))), 0x01));


               body.instructions = f0A17_parent_instructions;
               body.emit(f0A17);

               /* END IF */

               body.emit(assign(r0A07, r0A08, 0x01));


            body.instructions = f0A09_parent_instructions;
            body.emit(f0A09);

            /* END IF */

            body.emit(assign(r0A03, add(r0A07, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A1B = lequal(body.constant(int(0)), r0A03);
            ir_if *f0A1A = new(mem_ctx) ir_if(operand(r0A1B).val);
            exec_list *const f0A1A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A1A->then_instructions;

               body.emit(assign(r0A02, body.constant(0u), 0x01));

               ir_variable *const r0A1C = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0A1C, lshift(r0A01, r0A03), 0x01));

               ir_variable *const r0A1D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0A1F = equal(r0A03, body.constant(int(0)));
               ir_if *f0A1E = new(mem_ctx) ir_if(operand(r0A1F).val);
               exec_list *const f0A1E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A1E->then_instructions;

                  body.emit(assign(r0A1D, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A1E->else_instructions;

                  ir_expression *const r0A20 = lshift(r0A00, r0A03);
                  ir_expression *const r0A21 = neg(r0A03);
                  ir_expression *const r0A22 = bit_and(r0A21, body.constant(int(31)));
                  ir_expression *const r0A23 = rshift(r0A01, r0A22);
                  body.emit(assign(r0A1D, bit_or(r0A20, r0A23), 0x01));


               body.instructions = f0A1E_parent_instructions;
               body.emit(f0A1E);

               /* END IF */

               body.emit(assign(r0A00, r0A1D, 0x01));

               body.emit(assign(r0A01, r0A1C, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A1A->else_instructions;

               ir_variable *const r0A24 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0A24, body.constant(0u), 0x01));

               ir_variable *const r0A25 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0A25, neg(r0A03), 0x01));

               ir_variable *const r0A26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0A26);
               ir_variable *const r0A27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0A27);
               ir_variable *const r0A28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0A28);
               ir_variable *const r0A29 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0A2A = neg(r0A25);
               body.emit(assign(r0A29, bit_and(r0A2A, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A2C = equal(r0A25, body.constant(int(0)));
               ir_if *f0A2B = new(mem_ctx) ir_if(operand(r0A2C).val);
               exec_list *const f0A2B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A2B->then_instructions;

                  body.emit(assign(r0A26, r0A24, 0x01));

                  body.emit(assign(r0A27, r0A01, 0x01));

                  body.emit(assign(r0A28, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A2B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A2E = less(r0A25, body.constant(int(32)));
                  ir_if *f0A2D = new(mem_ctx) ir_if(operand(r0A2E).val);
                  exec_list *const f0A2D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A2D->then_instructions;

                     body.emit(assign(r0A26, lshift(r0A01, r0A29), 0x01));

                     ir_expression *const r0A2F = lshift(r0A00, r0A29);
                     ir_expression *const r0A30 = rshift(r0A01, r0A25);
                     body.emit(assign(r0A27, bit_or(r0A2F, r0A30), 0x01));

                     body.emit(assign(r0A28, rshift(r0A00, r0A25), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A2D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0A32 = equal(r0A25, body.constant(int(32)));
                     ir_if *f0A31 = new(mem_ctx) ir_if(operand(r0A32).val);
                     exec_list *const f0A31_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A31->then_instructions;

                        body.emit(assign(r0A26, r0A01, 0x01));

                        body.emit(assign(r0A27, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A31->else_instructions;

                        body.emit(assign(r0A24, bit_or(body.constant(0u), r0A01), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0A34 = less(r0A25, body.constant(int(64)));
                        ir_if *f0A33 = new(mem_ctx) ir_if(operand(r0A34).val);
                        exec_list *const f0A33_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A33->then_instructions;

                           body.emit(assign(r0A26, lshift(r0A00, r0A29), 0x01));

                           ir_expression *const r0A35 = bit_and(r0A25, body.constant(int(31)));
                           body.emit(assign(r0A27, rshift(r0A00, r0A35), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A33->else_instructions;

                           ir_variable *const r0A36 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0A38 = equal(r0A25, body.constant(int(64)));
                           ir_if *f0A37 = new(mem_ctx) ir_if(operand(r0A38).val);
                           exec_list *const f0A37_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A37->then_instructions;

                              body.emit(assign(r0A36, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A37->else_instructions;

                              ir_expression *const r0A39 = nequal(r0A00, body.constant(0u));
                              ir_expression *const r0A3A = expr(ir_unop_b2i, r0A39);
                              body.emit(assign(r0A36, expr(ir_unop_i2u, r0A3A), 0x01));


                           body.instructions = f0A37_parent_instructions;
                           body.emit(f0A37);

                           /* END IF */

                           body.emit(assign(r0A26, r0A36, 0x01));

                           body.emit(assign(r0A27, body.constant(0u), 0x01));


                        body.instructions = f0A33_parent_instructions;
                        body.emit(f0A33);

                        /* END IF */


                     body.instructions = f0A31_parent_instructions;
                     body.emit(f0A31);

                     /* END IF */

                     body.emit(assign(r0A28, body.constant(0u), 0x01));


                  body.instructions = f0A2D_parent_instructions;
                  body.emit(f0A2D);

                  /* END IF */

                  ir_expression *const r0A3B = nequal(r0A24, body.constant(0u));
                  ir_expression *const r0A3C = expr(ir_unop_b2i, r0A3B);
                  ir_expression *const r0A3D = expr(ir_unop_i2u, r0A3C);
                  body.emit(assign(r0A26, bit_or(r0A26, r0A3D), 0x01));


               body.instructions = f0A2B_parent_instructions;
               body.emit(f0A2B);

               /* END IF */

               body.emit(assign(r0A00, r0A28, 0x01));

               body.emit(assign(r0A01, r0A27, 0x01));

               body.emit(assign(r0A02, r0A26, 0x01));


            body.instructions = f0A1A_parent_instructions;
            body.emit(f0A1A);

            /* END IF */

            body.emit(assign(r09FF, sub(r09FF, r0A03), 0x01));

            ir_variable *const r0A3E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0A3E, r09FF, 0x01));

            ir_variable *const r0A3F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A3F, r0A00, 0x01));

            ir_variable *const r0A40 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A40, r0A01, 0x01));

            ir_variable *const r0A41 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0A41, r0A02, 0x01));

            ir_variable *const r0A42 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0A42, body.constant(true), 0x01));

            ir_variable *const r0A43 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0A44 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0A44);
            ir_expression *const r0A45 = expr(ir_unop_u2i, r0A02);
            body.emit(assign(r0A44, less(r0A45, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A47 = lequal(body.constant(int(2045)), r09FF);
            ir_if *f0A46 = new(mem_ctx) ir_if(operand(r0A47).val);
            exec_list *const f0A46_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A46->then_instructions;

               ir_variable *const r0A48 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0A4A = less(body.constant(int(2045)), r09FF);
               ir_if *f0A49 = new(mem_ctx) ir_if(operand(r0A4A).val);
               exec_list *const f0A49_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A49->then_instructions;

                  body.emit(assign(r0A48, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A49->else_instructions;

                  ir_variable *const r0A4B = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0A4D = equal(r09FF, body.constant(int(2045)));
                  ir_if *f0A4C = new(mem_ctx) ir_if(operand(r0A4D).val);
                  exec_list *const f0A4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A4C->then_instructions;

                     ir_expression *const r0A4E = equal(body.constant(2097151u), r0A00);
                     ir_expression *const r0A4F = equal(body.constant(4294967295u), r0A01);
                     body.emit(assign(r0A4B, logic_and(r0A4E, r0A4F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A4C->else_instructions;

                     body.emit(assign(r0A4B, body.constant(false), 0x01));


                  body.instructions = f0A4C_parent_instructions;
                  body.emit(f0A4C);

                  /* END IF */

                  body.emit(assign(r0A48, logic_and(r0A4B, r0A44), 0x01));


               body.instructions = f0A49_parent_instructions;
               body.emit(f0A49);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0A50 = new(mem_ctx) ir_if(operand(r0A48).val);
               exec_list *const f0A50_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A50->then_instructions;

                  ir_variable *const r0A51 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0A51);
                  ir_expression *const r0A52 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0A51, add(r0A52, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0A51, body.constant(0u), 0x01));

                  body.emit(assign(r0A43, r0A51, 0x03));

                  body.emit(assign(r0A42, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A50->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A54 = less(r09FF, body.constant(int(0)));
                  ir_if *f0A53 = new(mem_ctx) ir_if(operand(r0A54).val);
                  exec_list *const f0A53_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A53->then_instructions;

                     ir_variable *const r0A55 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0A55, r0A02, 0x01));

                     ir_variable *const r0A56 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0A56, neg(r09FF), 0x01));

                     ir_variable *const r0A57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0A57);
                     ir_variable *const r0A58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0A58);
                     ir_variable *const r0A59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0A59);
                     ir_variable *const r0A5A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0A5B = neg(r0A56);
                     body.emit(assign(r0A5A, bit_and(r0A5B, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0A5D = equal(r0A56, body.constant(int(0)));
                     ir_if *f0A5C = new(mem_ctx) ir_if(operand(r0A5D).val);
                     exec_list *const f0A5C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A5C->then_instructions;

                        body.emit(assign(r0A57, r0A02, 0x01));

                        body.emit(assign(r0A58, r0A01, 0x01));

                        body.emit(assign(r0A59, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A5C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0A5F = less(r0A56, body.constant(int(32)));
                        ir_if *f0A5E = new(mem_ctx) ir_if(operand(r0A5F).val);
                        exec_list *const f0A5E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A5E->then_instructions;

                           body.emit(assign(r0A57, lshift(r0A01, r0A5A), 0x01));

                           ir_expression *const r0A60 = lshift(r0A00, r0A5A);
                           ir_expression *const r0A61 = rshift(r0A01, r0A56);
                           body.emit(assign(r0A58, bit_or(r0A60, r0A61), 0x01));

                           body.emit(assign(r0A59, rshift(r0A00, r0A56), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A5E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0A63 = equal(r0A56, body.constant(int(32)));
                           ir_if *f0A62 = new(mem_ctx) ir_if(operand(r0A63).val);
                           exec_list *const f0A62_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A62->then_instructions;

                              body.emit(assign(r0A57, r0A01, 0x01));

                              body.emit(assign(r0A58, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A62->else_instructions;

                              body.emit(assign(r0A55, bit_or(r0A02, r0A01), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0A65 = less(r0A56, body.constant(int(64)));
                              ir_if *f0A64 = new(mem_ctx) ir_if(operand(r0A65).val);
                              exec_list *const f0A64_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0A64->then_instructions;

                                 body.emit(assign(r0A57, lshift(r0A00, r0A5A), 0x01));

                                 ir_expression *const r0A66 = bit_and(r0A56, body.constant(int(31)));
                                 body.emit(assign(r0A58, rshift(r0A00, r0A66), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0A64->else_instructions;

                                 ir_variable *const r0A67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0A69 = equal(r0A56, body.constant(int(64)));
                                 ir_if *f0A68 = new(mem_ctx) ir_if(operand(r0A69).val);
                                 exec_list *const f0A68_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0A68->then_instructions;

                                    body.emit(assign(r0A67, r0A00, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0A68->else_instructions;

                                    ir_expression *const r0A6A = nequal(r0A00, body.constant(0u));
                                    ir_expression *const r0A6B = expr(ir_unop_b2i, r0A6A);
                                    body.emit(assign(r0A67, expr(ir_unop_i2u, r0A6B), 0x01));


                                 body.instructions = f0A68_parent_instructions;
                                 body.emit(f0A68);

                                 /* END IF */

                                 body.emit(assign(r0A57, r0A67, 0x01));

                                 body.emit(assign(r0A58, body.constant(0u), 0x01));


                              body.instructions = f0A64_parent_instructions;
                              body.emit(f0A64);

                              /* END IF */


                           body.instructions = f0A62_parent_instructions;
                           body.emit(f0A62);

                           /* END IF */

                           body.emit(assign(r0A59, body.constant(0u), 0x01));


                        body.instructions = f0A5E_parent_instructions;
                        body.emit(f0A5E);

                        /* END IF */

                        ir_expression *const r0A6C = nequal(r0A55, body.constant(0u));
                        ir_expression *const r0A6D = expr(ir_unop_b2i, r0A6C);
                        ir_expression *const r0A6E = expr(ir_unop_i2u, r0A6D);
                        body.emit(assign(r0A57, bit_or(r0A57, r0A6E), 0x01));


                     body.instructions = f0A5C_parent_instructions;
                     body.emit(f0A5C);

                     /* END IF */

                     body.emit(assign(r0A3F, r0A59, 0x01));

                     body.emit(assign(r0A40, r0A58, 0x01));

                     body.emit(assign(r0A41, r0A57, 0x01));

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));

                     body.emit(assign(r0A44, less(r0A57, body.constant(0u)), 0x01));


                  body.instructions = f0A53_parent_instructions;
                  body.emit(f0A53);

                  /* END IF */


               body.instructions = f0A50_parent_instructions;
               body.emit(f0A50);

               /* END IF */


            body.instructions = f0A46_parent_instructions;
            body.emit(f0A46);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0A6F = new(mem_ctx) ir_if(operand(r0A42).val);
            exec_list *const f0A6F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A6F->then_instructions;

               /* IF CONDITION */
               ir_if *f0A70 = new(mem_ctx) ir_if(operand(r0A44).val);
               exec_list *const f0A70_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A70->then_instructions;

                  ir_variable *const r0A71 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0A71, add(r0A40, body.constant(1u)), 0x01));

                  ir_expression *const r0A72 = less(r0A71, r0A40);
                  ir_expression *const r0A73 = expr(ir_unop_b2i, r0A72);
                  ir_expression *const r0A74 = expr(ir_unop_i2u, r0A73);
                  body.emit(assign(r0A3F, add(r0A3F, r0A74), 0x01));

                  ir_expression *const r0A75 = equal(r0A41, body.constant(0u));
                  ir_expression *const r0A76 = expr(ir_unop_b2i, r0A75);
                  ir_expression *const r0A77 = expr(ir_unop_i2u, r0A76);
                  ir_expression *const r0A78 = add(r0A41, r0A77);
                  ir_expression *const r0A79 = bit_and(r0A78, body.constant(1u));
                  ir_expression *const r0A7A = expr(ir_unop_bit_not, r0A79);
                  body.emit(assign(r0A40, bit_and(r0A71, r0A7A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A70->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A7C = bit_or(r0A3F, r0A40);
                  ir_expression *const r0A7D = equal(r0A7C, body.constant(0u));
                  ir_if *f0A7B = new(mem_ctx) ir_if(operand(r0A7D).val);
                  exec_list *const f0A7B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A7B->then_instructions;

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));


                  body.instructions = f0A7B_parent_instructions;
                  body.emit(f0A7B);

                  /* END IF */


               body.instructions = f0A70_parent_instructions;
               body.emit(f0A70);

               /* END IF */

               ir_variable *const r0A7E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0A7E);
               ir_expression *const r0A7F = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0A80 = expr(ir_unop_i2u, r0A3E);
               ir_expression *const r0A81 = lshift(r0A80, body.constant(int(20)));
               ir_expression *const r0A82 = add(r0A7F, r0A81);
               body.emit(assign(r0A7E, add(r0A82, r0A3F), 0x02));

               body.emit(assign(r0A7E, r0A40, 0x01));

               body.emit(assign(r0A43, r0A7E, 0x03));

               body.emit(assign(r0A42, body.constant(false), 0x01));


            body.instructions = f0A6F_parent_instructions;
            body.emit(f0A6F);

            /* END IF */

            body.emit(assign(r099A, r0A43, 0x03));


         body.instructions = f09B3_parent_instructions;
         body.emit(f09B3);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f09B1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0A84 = less(r099B, body.constant(int(0)));
         ir_if *f0A83 = new(mem_ctx) ir_if(operand(r0A84).val);
         exec_list *const f0A83_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0A83->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0A86 = equal(r09A6, body.constant(int(2047)));
            ir_if *f0A85 = new(mem_ctx) ir_if(operand(r0A86).val);
            exec_list *const f0A85_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A85->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0A88 = bit_or(swizzle_y(r099D), swizzle_x(r099D));
               ir_expression *const r0A89 = nequal(r0A88, body.constant(0u));
               ir_if *f0A87 = new(mem_ctx) ir_if(operand(r0A89).val);
               exec_list *const f0A87_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A87->then_instructions;

                  ir_variable *const r0A8A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0A8A, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0A8B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0A8B, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0A8C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0A8D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0A8E = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0A8F = bit_and(r0A8E, body.constant(4095u));
                  ir_expression *const r0A90 = equal(r0A8F, body.constant(4094u));
                  ir_expression *const r0A91 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0A92 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0A93 = nequal(r0A92, body.constant(0u));
                  ir_expression *const r0A94 = logic_or(r0A91, r0A93);
                  body.emit(assign(r0A8D, logic_and(r0A90, r0A94), 0x01));

                  ir_variable *const r0A95 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0A96 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0A97 = lequal(body.constant(4292870144u), r0A96);
                  ir_expression *const r0A98 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0A99 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0A9A = nequal(r0A99, body.constant(0u));
                  ir_expression *const r0A9B = logic_or(r0A98, r0A9A);
                  body.emit(assign(r0A95, logic_and(r0A97, r0A9B), 0x01));

                  body.emit(assign(r0A8A, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0A8B, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0A9D = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0A9E = lequal(body.constant(4292870144u), r0A9D);
                  ir_expression *const r0A9F = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0AA0 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0AA1 = nequal(r0AA0, body.constant(0u));
                  ir_expression *const r0AA2 = logic_or(r0A9F, r0AA1);
                  ir_expression *const r0AA3 = logic_and(r0A9E, r0AA2);
                  ir_if *f0A9C = new(mem_ctx) ir_if(operand(r0AA3).val);
                  exec_list *const f0A9C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A9C->then_instructions;

                     ir_variable *const r0AA4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0AA6 = logic_and(r0A8D, r0A95);
                     ir_if *f0AA5 = new(mem_ctx) ir_if(operand(r0AA6).val);
                     exec_list *const f0AA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0AA5->then_instructions;

                        body.emit(assign(r0AA4, r0A8B, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0AA5->else_instructions;

                        body.emit(assign(r0AA4, r0A8A, 0x03));


                     body.instructions = f0AA5_parent_instructions;
                     body.emit(f0AA5);

                     /* END IF */

                     body.emit(assign(r0A8C, r0AA4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A9C->else_instructions;

                     body.emit(assign(r0A8C, r0A8B, 0x03));


                  body.instructions = f0A9C_parent_instructions;
                  body.emit(f0A9C);

                  /* END IF */

                  body.emit(assign(r099A, r0A8C, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A87->else_instructions;

                  ir_variable *const r0AA7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0AA7);
                  ir_expression *const r0AA8 = bit_xor(r07EC, body.constant(1u));
                  ir_expression *const r0AA9 = lshift(r0AA8, body.constant(int(31)));
                  body.emit(assign(r0AA7, add(r0AA9, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0AA7, body.constant(0u), 0x01));

                  body.emit(assign(r099A, r0AA7, 0x03));


               body.instructions = f0A87_parent_instructions;
               body.emit(f0A87);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A85->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0AAB = equal(r09A2, body.constant(int(0)));
               ir_if *f0AAA = new(mem_ctx) ir_if(operand(r0AAB).val);
               exec_list *const f0AAA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AAA->then_instructions;

                  body.emit(assign(r099B, add(r099B, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AAA->else_instructions;

                  body.emit(assign(r099F, bit_or(swizzle_y(r099F), body.constant(1073741824u)), 0x02));


               body.instructions = f0AAA_parent_instructions;
               body.emit(f0AAA);

               /* END IF */

               ir_variable *const r0AAC = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r0AAC, swizzle_y(r099F), 0x01));

               ir_variable *const r0AAD = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r0AAD, swizzle_x(r099F), 0x01));

               ir_variable *const r0AAE = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0AAE, neg(r099B), 0x01));

               ir_variable *const r0AAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0AAF);
               ir_variable *const r0AB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0AB0);
               ir_variable *const r0AB1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0AB2 = neg(r0AAE);
               body.emit(assign(r0AB1, bit_and(r0AB2, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AB4 = equal(r0AAE, body.constant(int(0)));
               ir_if *f0AB3 = new(mem_ctx) ir_if(operand(r0AB4).val);
               exec_list *const f0AB3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AB3->then_instructions;

                  body.emit(assign(r0AAF, r0AAD, 0x01));

                  body.emit(assign(r0AB0, r0AAC, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AB3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0AB6 = less(r0AAE, body.constant(int(32)));
                  ir_if *f0AB5 = new(mem_ctx) ir_if(operand(r0AB6).val);
                  exec_list *const f0AB5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AB5->then_instructions;

                     ir_expression *const r0AB7 = lshift(swizzle_y(r099F), r0AB1);
                     ir_expression *const r0AB8 = rshift(r09A9, r0AAE);
                     ir_expression *const r0AB9 = bit_or(r0AB7, r0AB8);
                     ir_expression *const r0ABA = lshift(r09A9, r0AB1);
                     ir_expression *const r0ABB = nequal(r0ABA, body.constant(0u));
                     ir_expression *const r0ABC = expr(ir_unop_b2i, r0ABB);
                     ir_expression *const r0ABD = expr(ir_unop_i2u, r0ABC);
                     body.emit(assign(r0AAF, bit_or(r0AB9, r0ABD), 0x01));

                     body.emit(assign(r0AB0, rshift(swizzle_y(r099F), r0AAE), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AB5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0ABF = equal(r0AAE, body.constant(int(32)));
                     ir_if *f0ABE = new(mem_ctx) ir_if(operand(r0ABF).val);
                     exec_list *const f0ABE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0ABE->then_instructions;

                        ir_expression *const r0AC0 = nequal(r09A9, body.constant(0u));
                        ir_expression *const r0AC1 = expr(ir_unop_b2i, r0AC0);
                        ir_expression *const r0AC2 = expr(ir_unop_i2u, r0AC1);
                        body.emit(assign(r0AAF, bit_or(swizzle_y(r099F), r0AC2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0ABE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0AC4 = less(r0AAE, body.constant(int(64)));
                        ir_if *f0AC3 = new(mem_ctx) ir_if(operand(r0AC4).val);
                        exec_list *const f0AC3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0AC3->then_instructions;

                           ir_expression *const r0AC5 = bit_and(r0AAE, body.constant(int(31)));
                           ir_expression *const r0AC6 = rshift(swizzle_y(r099F), r0AC5);
                           ir_expression *const r0AC7 = lshift(swizzle_y(r099F), r0AB1);
                           ir_expression *const r0AC8 = bit_or(r0AC7, r09A9);
                           ir_expression *const r0AC9 = nequal(r0AC8, body.constant(0u));
                           ir_expression *const r0ACA = expr(ir_unop_b2i, r0AC9);
                           ir_expression *const r0ACB = expr(ir_unop_i2u, r0ACA);
                           body.emit(assign(r0AAF, bit_or(r0AC6, r0ACB), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0AC3->else_instructions;

                           ir_expression *const r0ACC = bit_or(swizzle_y(r099F), r09A9);
                           ir_expression *const r0ACD = nequal(r0ACC, body.constant(0u));
                           ir_expression *const r0ACE = expr(ir_unop_b2i, r0ACD);
                           body.emit(assign(r0AAF, expr(ir_unop_i2u, r0ACE), 0x01));


                        body.instructions = f0AC3_parent_instructions;
                        body.emit(f0AC3);

                        /* END IF */


                     body.instructions = f0ABE_parent_instructions;
                     body.emit(f0ABE);

                     /* END IF */

                     body.emit(assign(r0AB0, body.constant(0u), 0x01));


                  body.instructions = f0AB5_parent_instructions;
                  body.emit(f0AB5);

                  /* END IF */


               body.instructions = f0AB3_parent_instructions;
               body.emit(f0AB3);

               /* END IF */

               body.emit(assign(r099F, r0AB0, 0x02));

               body.emit(assign(r099F, r0AAF, 0x01));

               body.emit(assign(r099D, bit_or(swizzle_y(r099D), body.constant(1073741824u)), 0x02));

               ir_variable *const r0ACF = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0AD0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0AD0, sub(swizzle_x(r099D), r0AAF), 0x01));

               ir_expression *const r0AD1 = sub(swizzle_y(r099D), r0AB0);
               ir_expression *const r0AD2 = less(swizzle_x(r099D), r0AAF);
               ir_expression *const r0AD3 = expr(ir_unop_b2i, r0AD2);
               ir_expression *const r0AD4 = expr(ir_unop_i2u, r0AD3);
               body.emit(assign(r0ACF, sub(r0AD1, r0AD4), 0x01));

               body.emit(assign(r0999, bit_xor(r07EC, body.constant(1u)), 0x01));

               body.emit(assign(r09A0, add(r09A6, body.constant(int(-1))), 0x01));

               ir_variable *const r0AD5 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0AD5, add(r09A0, body.constant(int(-10))), 0x01));

               ir_variable *const r0AD6 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0AD6, r0ACF, 0x01));

               ir_variable *const r0AD7 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0AD7, r0AD0, 0x01));

               ir_variable *const r0AD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0AD8);
               ir_variable *const r0AD9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0AD9);
               /* IF CONDITION */
               ir_expression *const r0ADB = equal(r0ACF, body.constant(0u));
               ir_if *f0ADA = new(mem_ctx) ir_if(operand(r0ADB).val);
               exec_list *const f0ADA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ADA->then_instructions;

                  body.emit(assign(r0AD6, r0AD0, 0x01));

                  body.emit(assign(r0AD7, body.constant(0u), 0x01));

                  body.emit(assign(r0AD5, add(r0AD5, body.constant(int(-32))), 0x01));


               body.instructions = f0ADA_parent_instructions;
               body.emit(f0ADA);

               /* END IF */

               ir_variable *const r0ADC = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0ADC, r0AD6, 0x01));

               ir_variable *const r0ADD = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0ADE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0ADE);
               /* IF CONDITION */
               ir_expression *const r0AE0 = equal(r0AD6, body.constant(0u));
               ir_if *f0ADF = new(mem_ctx) ir_if(operand(r0AE0).val);
               exec_list *const f0ADF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ADF->then_instructions;

                  body.emit(assign(r0ADD, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ADF->else_instructions;

                  body.emit(assign(r0ADE, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0AE2 = bit_and(r0AD6, body.constant(4294901760u));
                  ir_expression *const r0AE3 = equal(r0AE2, body.constant(0u));
                  ir_if *f0AE1 = new(mem_ctx) ir_if(operand(r0AE3).val);
                  exec_list *const f0AE1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE1->then_instructions;

                     body.emit(assign(r0ADE, body.constant(int(16)), 0x01));

                     body.emit(assign(r0ADC, lshift(r0AD6, body.constant(int(16))), 0x01));


                  body.instructions = f0AE1_parent_instructions;
                  body.emit(f0AE1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE5 = bit_and(r0ADC, body.constant(4278190080u));
                  ir_expression *const r0AE6 = equal(r0AE5, body.constant(0u));
                  ir_if *f0AE4 = new(mem_ctx) ir_if(operand(r0AE6).val);
                  exec_list *const f0AE4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE4->then_instructions;

                     body.emit(assign(r0ADE, add(r0ADE, body.constant(int(8))), 0x01));

                     body.emit(assign(r0ADC, lshift(r0ADC, body.constant(int(8))), 0x01));


                  body.instructions = f0AE4_parent_instructions;
                  body.emit(f0AE4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE8 = bit_and(r0ADC, body.constant(4026531840u));
                  ir_expression *const r0AE9 = equal(r0AE8, body.constant(0u));
                  ir_if *f0AE7 = new(mem_ctx) ir_if(operand(r0AE9).val);
                  exec_list *const f0AE7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE7->then_instructions;

                     body.emit(assign(r0ADE, add(r0ADE, body.constant(int(4))), 0x01));

                     body.emit(assign(r0ADC, lshift(r0ADC, body.constant(int(4))), 0x01));


                  body.instructions = f0AE7_parent_instructions;
                  body.emit(f0AE7);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AEB = bit_and(r0ADC, body.constant(3221225472u));
                  ir_expression *const r0AEC = equal(r0AEB, body.constant(0u));
                  ir_if *f0AEA = new(mem_ctx) ir_if(operand(r0AEC).val);
                  exec_list *const f0AEA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AEA->then_instructions;

                     body.emit(assign(r0ADE, add(r0ADE, body.constant(int(2))), 0x01));

                     body.emit(assign(r0ADC, lshift(r0ADC, body.constant(int(2))), 0x01));


                  body.instructions = f0AEA_parent_instructions;
                  body.emit(f0AEA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AEE = bit_and(r0ADC, body.constant(2147483648u));
                  ir_expression *const r0AEF = equal(r0AEE, body.constant(0u));
                  ir_if *f0AED = new(mem_ctx) ir_if(operand(r0AEF).val);
                  exec_list *const f0AED_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AED->then_instructions;

                     body.emit(assign(r0ADE, add(r0ADE, body.constant(int(1))), 0x01));


                  body.instructions = f0AED_parent_instructions;
                  body.emit(f0AED);

                  /* END IF */

                  body.emit(assign(r0ADD, r0ADE, 0x01));


               body.instructions = f0ADF_parent_instructions;
               body.emit(f0ADF);

               /* END IF */

               body.emit(assign(r0AD9, add(r0ADD, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AF1 = lequal(body.constant(int(0)), r0AD9);
               ir_if *f0AF0 = new(mem_ctx) ir_if(operand(r0AF1).val);
               exec_list *const f0AF0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AF0->then_instructions;

                  body.emit(assign(r0AD8, body.constant(0u), 0x01));

                  ir_variable *const r0AF2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0AF2, lshift(r0AD7, r0AD9), 0x01));

                  ir_variable *const r0AF3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0AF5 = equal(r0AD9, body.constant(int(0)));
                  ir_if *f0AF4 = new(mem_ctx) ir_if(operand(r0AF5).val);
                  exec_list *const f0AF4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AF4->then_instructions;

                     body.emit(assign(r0AF3, r0AD6, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AF4->else_instructions;

                     ir_expression *const r0AF6 = lshift(r0AD6, r0AD9);
                     ir_expression *const r0AF7 = neg(r0AD9);
                     ir_expression *const r0AF8 = bit_and(r0AF7, body.constant(int(31)));
                     ir_expression *const r0AF9 = rshift(r0AD7, r0AF8);
                     body.emit(assign(r0AF3, bit_or(r0AF6, r0AF9), 0x01));


                  body.instructions = f0AF4_parent_instructions;
                  body.emit(f0AF4);

                  /* END IF */

                  body.emit(assign(r0AD6, r0AF3, 0x01));

                  body.emit(assign(r0AD7, r0AF2, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AF0->else_instructions;

                  ir_variable *const r0AFA = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0AFA, body.constant(0u), 0x01));

                  ir_variable *const r0AFB = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0AFB, neg(r0AD9), 0x01));

                  ir_variable *const r0AFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0AFC);
                  ir_variable *const r0AFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0AFD);
                  ir_variable *const r0AFE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0AFE);
                  ir_variable *const r0AFF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0B00 = neg(r0AFB);
                  body.emit(assign(r0AFF, bit_and(r0B00, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0B02 = equal(r0AFB, body.constant(int(0)));
                  ir_if *f0B01 = new(mem_ctx) ir_if(operand(r0B02).val);
                  exec_list *const f0B01_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B01->then_instructions;

                     body.emit(assign(r0AFC, r0AFA, 0x01));

                     body.emit(assign(r0AFD, r0AD7, 0x01));

                     body.emit(assign(r0AFE, r0AD6, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B01->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B04 = less(r0AFB, body.constant(int(32)));
                     ir_if *f0B03 = new(mem_ctx) ir_if(operand(r0B04).val);
                     exec_list *const f0B03_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B03->then_instructions;

                        body.emit(assign(r0AFC, lshift(r0AD7, r0AFF), 0x01));

                        ir_expression *const r0B05 = lshift(r0AD6, r0AFF);
                        ir_expression *const r0B06 = rshift(r0AD7, r0AFB);
                        body.emit(assign(r0AFD, bit_or(r0B05, r0B06), 0x01));

                        body.emit(assign(r0AFE, rshift(r0AD6, r0AFB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B03->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0B08 = equal(r0AFB, body.constant(int(32)));
                        ir_if *f0B07 = new(mem_ctx) ir_if(operand(r0B08).val);
                        exec_list *const f0B07_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B07->then_instructions;

                           body.emit(assign(r0AFC, r0AD7, 0x01));

                           body.emit(assign(r0AFD, r0AD6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B07->else_instructions;

                           body.emit(assign(r0AFA, bit_or(body.constant(0u), r0AD7), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0B0A = less(r0AFB, body.constant(int(64)));
                           ir_if *f0B09 = new(mem_ctx) ir_if(operand(r0B0A).val);
                           exec_list *const f0B09_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B09->then_instructions;

                              body.emit(assign(r0AFC, lshift(r0AD6, r0AFF), 0x01));

                              ir_expression *const r0B0B = bit_and(r0AFB, body.constant(int(31)));
                              body.emit(assign(r0AFD, rshift(r0AD6, r0B0B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B09->else_instructions;

                              ir_variable *const r0B0C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0B0E = equal(r0AFB, body.constant(int(64)));
                              ir_if *f0B0D = new(mem_ctx) ir_if(operand(r0B0E).val);
                              exec_list *const f0B0D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B0D->then_instructions;

                                 body.emit(assign(r0B0C, r0AD6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B0D->else_instructions;

                                 ir_expression *const r0B0F = nequal(r0AD6, body.constant(0u));
                                 ir_expression *const r0B10 = expr(ir_unop_b2i, r0B0F);
                                 body.emit(assign(r0B0C, expr(ir_unop_i2u, r0B10), 0x01));


                              body.instructions = f0B0D_parent_instructions;
                              body.emit(f0B0D);

                              /* END IF */

                              body.emit(assign(r0AFC, r0B0C, 0x01));

                              body.emit(assign(r0AFD, body.constant(0u), 0x01));


                           body.instructions = f0B09_parent_instructions;
                           body.emit(f0B09);

                           /* END IF */


                        body.instructions = f0B07_parent_instructions;
                        body.emit(f0B07);

                        /* END IF */

                        body.emit(assign(r0AFE, body.constant(0u), 0x01));


                     body.instructions = f0B03_parent_instructions;
                     body.emit(f0B03);

                     /* END IF */

                     ir_expression *const r0B11 = nequal(r0AFA, body.constant(0u));
                     ir_expression *const r0B12 = expr(ir_unop_b2i, r0B11);
                     ir_expression *const r0B13 = expr(ir_unop_i2u, r0B12);
                     body.emit(assign(r0AFC, bit_or(r0AFC, r0B13), 0x01));


                  body.instructions = f0B01_parent_instructions;
                  body.emit(f0B01);

                  /* END IF */

                  body.emit(assign(r0AD6, r0AFE, 0x01));

                  body.emit(assign(r0AD7, r0AFD, 0x01));

                  body.emit(assign(r0AD8, r0AFC, 0x01));


               body.instructions = f0AF0_parent_instructions;
               body.emit(f0AF0);

               /* END IF */

               body.emit(assign(r0AD5, sub(r0AD5, r0AD9), 0x01));

               ir_variable *const r0B14 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0B14, r0AD5, 0x01));

               ir_variable *const r0B15 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0B15, r0AD6, 0x01));

               ir_variable *const r0B16 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0B16, r0AD7, 0x01));

               ir_variable *const r0B17 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0B17, r0AD8, 0x01));

               ir_variable *const r0B18 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0B18, body.constant(true), 0x01));

               ir_variable *const r0B19 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0B1A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0B1A);
               ir_expression *const r0B1B = expr(ir_unop_u2i, r0AD8);
               body.emit(assign(r0B1A, less(r0B1B, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0B1D = lequal(body.constant(int(2045)), r0AD5);
               ir_if *f0B1C = new(mem_ctx) ir_if(operand(r0B1D).val);
               exec_list *const f0B1C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B1C->then_instructions;

                  ir_variable *const r0B1E = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0B20 = less(body.constant(int(2045)), r0AD5);
                  ir_if *f0B1F = new(mem_ctx) ir_if(operand(r0B20).val);
                  exec_list *const f0B1F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B1F->then_instructions;

                     body.emit(assign(r0B1E, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B1F->else_instructions;

                     ir_variable *const r0B21 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B23 = equal(r0AD5, body.constant(int(2045)));
                     ir_if *f0B22 = new(mem_ctx) ir_if(operand(r0B23).val);
                     exec_list *const f0B22_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B22->then_instructions;

                        ir_expression *const r0B24 = equal(body.constant(2097151u), r0AD6);
                        ir_expression *const r0B25 = equal(body.constant(4294967295u), r0AD7);
                        body.emit(assign(r0B21, logic_and(r0B24, r0B25), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B22->else_instructions;

                        body.emit(assign(r0B21, body.constant(false), 0x01));


                     body.instructions = f0B22_parent_instructions;
                     body.emit(f0B22);

                     /* END IF */

                     body.emit(assign(r0B1E, logic_and(r0B21, r0B1A), 0x01));


                  body.instructions = f0B1F_parent_instructions;
                  body.emit(f0B1F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0B26 = new(mem_ctx) ir_if(operand(r0B1E).val);
                  exec_list *const f0B26_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B26->then_instructions;

                     ir_variable *const r0B27 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0B27);
                     ir_expression *const r0B28 = lshift(r0999, body.constant(int(31)));
                     body.emit(assign(r0B27, add(r0B28, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0B27, body.constant(0u), 0x01));

                     body.emit(assign(r0B19, r0B27, 0x03));

                     body.emit(assign(r0B18, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B26->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B2A = less(r0AD5, body.constant(int(0)));
                     ir_if *f0B29 = new(mem_ctx) ir_if(operand(r0B2A).val);
                     exec_list *const f0B29_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B29->then_instructions;

                        ir_variable *const r0B2B = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0B2B, r0AD8, 0x01));

                        ir_variable *const r0B2C = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0B2C, neg(r0AD5), 0x01));

                        ir_variable *const r0B2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0B2D);
                        ir_variable *const r0B2E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0B2E);
                        ir_variable *const r0B2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0B2F);
                        ir_variable *const r0B30 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0B31 = neg(r0B2C);
                        body.emit(assign(r0B30, bit_and(r0B31, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0B33 = equal(r0B2C, body.constant(int(0)));
                        ir_if *f0B32 = new(mem_ctx) ir_if(operand(r0B33).val);
                        exec_list *const f0B32_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B32->then_instructions;

                           body.emit(assign(r0B2D, r0AD8, 0x01));

                           body.emit(assign(r0B2E, r0AD7, 0x01));

                           body.emit(assign(r0B2F, r0AD6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B32->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0B35 = less(r0B2C, body.constant(int(32)));
                           ir_if *f0B34 = new(mem_ctx) ir_if(operand(r0B35).val);
                           exec_list *const f0B34_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B34->then_instructions;

                              body.emit(assign(r0B2D, lshift(r0AD7, r0B30), 0x01));

                              ir_expression *const r0B36 = lshift(r0AD6, r0B30);
                              ir_expression *const r0B37 = rshift(r0AD7, r0B2C);
                              body.emit(assign(r0B2E, bit_or(r0B36, r0B37), 0x01));

                              body.emit(assign(r0B2F, rshift(r0AD6, r0B2C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B34->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0B39 = equal(r0B2C, body.constant(int(32)));
                              ir_if *f0B38 = new(mem_ctx) ir_if(operand(r0B39).val);
                              exec_list *const f0B38_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B38->then_instructions;

                                 body.emit(assign(r0B2D, r0AD7, 0x01));

                                 body.emit(assign(r0B2E, r0AD6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B38->else_instructions;

                                 body.emit(assign(r0B2B, bit_or(r0AD8, r0AD7), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0B3B = less(r0B2C, body.constant(int(64)));
                                 ir_if *f0B3A = new(mem_ctx) ir_if(operand(r0B3B).val);
                                 exec_list *const f0B3A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0B3A->then_instructions;

                                    body.emit(assign(r0B2D, lshift(r0AD6, r0B30), 0x01));

                                    ir_expression *const r0B3C = bit_and(r0B2C, body.constant(int(31)));
                                    body.emit(assign(r0B2E, rshift(r0AD6, r0B3C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0B3A->else_instructions;

                                    ir_variable *const r0B3D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0B3F = equal(r0B2C, body.constant(int(64)));
                                    ir_if *f0B3E = new(mem_ctx) ir_if(operand(r0B3F).val);
                                    exec_list *const f0B3E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0B3E->then_instructions;

                                       body.emit(assign(r0B3D, r0AD6, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0B3E->else_instructions;

                                       ir_expression *const r0B40 = nequal(r0AD6, body.constant(0u));
                                       ir_expression *const r0B41 = expr(ir_unop_b2i, r0B40);
                                       body.emit(assign(r0B3D, expr(ir_unop_i2u, r0B41), 0x01));


                                    body.instructions = f0B3E_parent_instructions;
                                    body.emit(f0B3E);

                                    /* END IF */

                                    body.emit(assign(r0B2D, r0B3D, 0x01));

                                    body.emit(assign(r0B2E, body.constant(0u), 0x01));


                                 body.instructions = f0B3A_parent_instructions;
                                 body.emit(f0B3A);

                                 /* END IF */


                              body.instructions = f0B38_parent_instructions;
                              body.emit(f0B38);

                              /* END IF */

                              body.emit(assign(r0B2F, body.constant(0u), 0x01));


                           body.instructions = f0B34_parent_instructions;
                           body.emit(f0B34);

                           /* END IF */

                           ir_expression *const r0B42 = nequal(r0B2B, body.constant(0u));
                           ir_expression *const r0B43 = expr(ir_unop_b2i, r0B42);
                           ir_expression *const r0B44 = expr(ir_unop_i2u, r0B43);
                           body.emit(assign(r0B2D, bit_or(r0B2D, r0B44), 0x01));


                        body.instructions = f0B32_parent_instructions;
                        body.emit(f0B32);

                        /* END IF */

                        body.emit(assign(r0B15, r0B2F, 0x01));

                        body.emit(assign(r0B16, r0B2E, 0x01));

                        body.emit(assign(r0B17, r0B2D, 0x01));

                        body.emit(assign(r0B14, body.constant(int(0)), 0x01));

                        body.emit(assign(r0B1A, less(r0B2D, body.constant(0u)), 0x01));


                     body.instructions = f0B29_parent_instructions;
                     body.emit(f0B29);

                     /* END IF */


                  body.instructions = f0B26_parent_instructions;
                  body.emit(f0B26);

                  /* END IF */


               body.instructions = f0B1C_parent_instructions;
               body.emit(f0B1C);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0B45 = new(mem_ctx) ir_if(operand(r0B18).val);
               exec_list *const f0B45_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B45->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0B46 = new(mem_ctx) ir_if(operand(r0B1A).val);
                  exec_list *const f0B46_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B46->then_instructions;

                     ir_variable *const r0B47 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0B47, add(r0B16, body.constant(1u)), 0x01));

                     ir_expression *const r0B48 = less(r0B47, r0B16);
                     ir_expression *const r0B49 = expr(ir_unop_b2i, r0B48);
                     ir_expression *const r0B4A = expr(ir_unop_i2u, r0B49);
                     body.emit(assign(r0B15, add(r0B15, r0B4A), 0x01));

                     ir_expression *const r0B4B = equal(r0B17, body.constant(0u));
                     ir_expression *const r0B4C = expr(ir_unop_b2i, r0B4B);
                     ir_expression *const r0B4D = expr(ir_unop_i2u, r0B4C);
                     ir_expression *const r0B4E = add(r0B17, r0B4D);
                     ir_expression *const r0B4F = bit_and(r0B4E, body.constant(1u));
                     ir_expression *const r0B50 = expr(ir_unop_bit_not, r0B4F);
                     body.emit(assign(r0B16, bit_and(r0B47, r0B50), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B46->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B52 = bit_or(r0B15, r0B16);
                     ir_expression *const r0B53 = equal(r0B52, body.constant(0u));
                     ir_if *f0B51 = new(mem_ctx) ir_if(operand(r0B53).val);
                     exec_list *const f0B51_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B51->then_instructions;

                        body.emit(assign(r0B14, body.constant(int(0)), 0x01));


                     body.instructions = f0B51_parent_instructions;
                     body.emit(f0B51);

                     /* END IF */


                  body.instructions = f0B46_parent_instructions;
                  body.emit(f0B46);

                  /* END IF */

                  ir_variable *const r0B54 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0B54);
                  ir_expression *const r0B55 = lshift(r0999, body.constant(int(31)));
                  ir_expression *const r0B56 = expr(ir_unop_i2u, r0B14);
                  ir_expression *const r0B57 = lshift(r0B56, body.constant(int(20)));
                  ir_expression *const r0B58 = add(r0B55, r0B57);
                  body.emit(assign(r0B54, add(r0B58, r0B15), 0x02));

                  body.emit(assign(r0B54, r0B16, 0x01));

                  body.emit(assign(r0B19, r0B54, 0x03));

                  body.emit(assign(r0B18, body.constant(false), 0x01));


               body.instructions = f0B45_parent_instructions;
               body.emit(f0B45);

               /* END IF */

               body.emit(assign(r099A, r0B19, 0x03));


            body.instructions = f0A85_parent_instructions;
            body.emit(f0A85);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0A83->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0B5A = equal(r09A2, body.constant(int(2047)));
            ir_if *f0B59 = new(mem_ctx) ir_if(operand(r0B5A).val);
            exec_list *const f0B59_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0B59->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0B5C = bit_or(swizzle_y(r099F), swizzle_x(r099F));
               ir_expression *const r0B5D = bit_or(swizzle_y(r099D), swizzle_x(r099D));
               ir_expression *const r0B5E = bit_or(r0B5C, r0B5D);
               ir_expression *const r0B5F = nequal(r0B5E, body.constant(0u));
               ir_if *f0B5B = new(mem_ctx) ir_if(operand(r0B5F).val);
               exec_list *const f0B5B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B5B->then_instructions;

                  ir_variable *const r0B60 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0B60, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0B61 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0B61, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0B62 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0B63 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0B64 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0B65 = bit_and(r0B64, body.constant(4095u));
                  ir_expression *const r0B66 = equal(r0B65, body.constant(4094u));
                  ir_expression *const r0B67 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B68 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0B69 = nequal(r0B68, body.constant(0u));
                  ir_expression *const r0B6A = logic_or(r0B67, r0B69);
                  body.emit(assign(r0B63, logic_and(r0B66, r0B6A), 0x01));

                  ir_variable *const r0B6B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0B6C = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0B6D = lequal(body.constant(4292870144u), r0B6C);
                  ir_expression *const r0B6E = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0B6F = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0B70 = nequal(r0B6F, body.constant(0u));
                  ir_expression *const r0B71 = logic_or(r0B6E, r0B70);
                  body.emit(assign(r0B6B, logic_and(r0B6D, r0B71), 0x01));

                  body.emit(assign(r0B60, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0B61, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0B73 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0B74 = lequal(body.constant(4292870144u), r0B73);
                  ir_expression *const r0B75 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B76 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0B77 = nequal(r0B76, body.constant(0u));
                  ir_expression *const r0B78 = logic_or(r0B75, r0B77);
                  ir_expression *const r0B79 = logic_and(r0B74, r0B78);
                  ir_if *f0B72 = new(mem_ctx) ir_if(operand(r0B79).val);
                  exec_list *const f0B72_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B72->then_instructions;

                     ir_variable *const r0B7A = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B7C = logic_and(r0B63, r0B6B);
                     ir_if *f0B7B = new(mem_ctx) ir_if(operand(r0B7C).val);
                     exec_list *const f0B7B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B7B->then_instructions;

                        body.emit(assign(r0B7A, r0B61, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B7B->else_instructions;

                        body.emit(assign(r0B7A, r0B60, 0x03));


                     body.instructions = f0B7B_parent_instructions;
                     body.emit(f0B7B);

                     /* END IF */

                     body.emit(assign(r0B62, r0B7A, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B72->else_instructions;

                     body.emit(assign(r0B62, r0B61, 0x03));


                  body.instructions = f0B72_parent_instructions;
                  body.emit(f0B72);

                  /* END IF */

                  body.emit(assign(r099A, r0B62, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B5B->else_instructions;

                  ir_constant_data r0B7D_data;
                  memset(&r0B7D_data, 0, sizeof(ir_constant_data));
                  r0B7D_data.u[0] = 4294967295;
                  r0B7D_data.u[1] = 4294967295;
                  ir_constant *const r0B7D = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0B7D_data);
                  body.emit(assign(r099A, r0B7D, 0x03));


               body.instructions = f0B5B_parent_instructions;
               body.emit(f0B5B);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0B59->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0B7F = equal(r09A2, body.constant(int(0)));
               ir_if *f0B7E = new(mem_ctx) ir_if(operand(r0B7F).val);
               exec_list *const f0B7E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B7E->then_instructions;

                  body.emit(assign(r099E, body.constant(int(1)), 0x01));

                  body.emit(assign(r099C, body.constant(int(1)), 0x01));


               body.instructions = f0B7E_parent_instructions;
               body.emit(f0B7E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0B81 = less(swizzle_y(r099D), swizzle_y(r099F));
               ir_if *f0B80 = new(mem_ctx) ir_if(operand(r0B81).val);
               exec_list *const f0B80_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B80->then_instructions;

                  ir_variable *const r0B82 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0B83 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0B83, sub(swizzle_x(r099F), swizzle_x(r099D)), 0x01));

                  ir_expression *const r0B84 = sub(swizzle_y(r099F), swizzle_y(r099D));
                  ir_expression *const r0B85 = less(swizzle_x(r099F), swizzle_x(r099D));
                  ir_expression *const r0B86 = expr(ir_unop_b2i, r0B85);
                  ir_expression *const r0B87 = expr(ir_unop_i2u, r0B86);
                  body.emit(assign(r0B82, sub(r0B84, r0B87), 0x01));

                  body.emit(assign(r09A0, add(r099E, body.constant(int(-1))), 0x01));

                  ir_variable *const r0B88 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0B88, add(r09A0, body.constant(int(-10))), 0x01));

                  ir_variable *const r0B89 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0B89, r0B82, 0x01));

                  ir_variable *const r0B8A = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0B8A, r0B83, 0x01));

                  ir_variable *const r0B8B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0B8B);
                  ir_variable *const r0B8C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B8C);
                  /* IF CONDITION */
                  ir_expression *const r0B8E = equal(r0B82, body.constant(0u));
                  ir_if *f0B8D = new(mem_ctx) ir_if(operand(r0B8E).val);
                  exec_list *const f0B8D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B8D->then_instructions;

                     body.emit(assign(r0B89, r0B83, 0x01));

                     body.emit(assign(r0B8A, body.constant(0u), 0x01));

                     body.emit(assign(r0B88, add(r0B88, body.constant(int(-32))), 0x01));


                  body.instructions = f0B8D_parent_instructions;
                  body.emit(f0B8D);

                  /* END IF */

                  ir_variable *const r0B8F = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0B8F, r0B89, 0x01));

                  ir_variable *const r0B90 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0B91 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B91);
                  /* IF CONDITION */
                  ir_expression *const r0B93 = equal(r0B89, body.constant(0u));
                  ir_if *f0B92 = new(mem_ctx) ir_if(operand(r0B93).val);
                  exec_list *const f0B92_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B92->then_instructions;

                     body.emit(assign(r0B90, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B92->else_instructions;

                     body.emit(assign(r0B91, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0B95 = bit_and(r0B89, body.constant(4294901760u));
                     ir_expression *const r0B96 = equal(r0B95, body.constant(0u));
                     ir_if *f0B94 = new(mem_ctx) ir_if(operand(r0B96).val);
                     exec_list *const f0B94_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B94->then_instructions;

                        body.emit(assign(r0B91, body.constant(int(16)), 0x01));

                        body.emit(assign(r0B8F, lshift(r0B89, body.constant(int(16))), 0x01));


                     body.instructions = f0B94_parent_instructions;
                     body.emit(f0B94);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B98 = bit_and(r0B8F, body.constant(4278190080u));
                     ir_expression *const r0B99 = equal(r0B98, body.constant(0u));
                     ir_if *f0B97 = new(mem_ctx) ir_if(operand(r0B99).val);
                     exec_list *const f0B97_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B97->then_instructions;

                        body.emit(assign(r0B91, add(r0B91, body.constant(int(8))), 0x01));

                        body.emit(assign(r0B8F, lshift(r0B8F, body.constant(int(8))), 0x01));


                     body.instructions = f0B97_parent_instructions;
                     body.emit(f0B97);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9B = bit_and(r0B8F, body.constant(4026531840u));
                     ir_expression *const r0B9C = equal(r0B9B, body.constant(0u));
                     ir_if *f0B9A = new(mem_ctx) ir_if(operand(r0B9C).val);
                     exec_list *const f0B9A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9A->then_instructions;

                        body.emit(assign(r0B91, add(r0B91, body.constant(int(4))), 0x01));

                        body.emit(assign(r0B8F, lshift(r0B8F, body.constant(int(4))), 0x01));


                     body.instructions = f0B9A_parent_instructions;
                     body.emit(f0B9A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9E = bit_and(r0B8F, body.constant(3221225472u));
                     ir_expression *const r0B9F = equal(r0B9E, body.constant(0u));
                     ir_if *f0B9D = new(mem_ctx) ir_if(operand(r0B9F).val);
                     exec_list *const f0B9D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9D->then_instructions;

                        body.emit(assign(r0B91, add(r0B91, body.constant(int(2))), 0x01));

                        body.emit(assign(r0B8F, lshift(r0B8F, body.constant(int(2))), 0x01));


                     body.instructions = f0B9D_parent_instructions;
                     body.emit(f0B9D);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0BA1 = bit_and(r0B8F, body.constant(2147483648u));
                     ir_expression *const r0BA2 = equal(r0BA1, body.constant(0u));
                     ir_if *f0BA0 = new(mem_ctx) ir_if(operand(r0BA2).val);
                     exec_list *const f0BA0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BA0->then_instructions;

                        body.emit(assign(r0B91, add(r0B91, body.constant(int(1))), 0x01));


                     body.instructions = f0BA0_parent_instructions;
                     body.emit(f0BA0);

                     /* END IF */

                     body.emit(assign(r0B90, r0B91, 0x01));


                  body.instructions = f0B92_parent_instructions;
                  body.emit(f0B92);

                  /* END IF */

                  body.emit(assign(r0B8C, add(r0B90, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BA4 = lequal(body.constant(int(0)), r0B8C);
                  ir_if *f0BA3 = new(mem_ctx) ir_if(operand(r0BA4).val);
                  exec_list *const f0BA3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BA3->then_instructions;

                     body.emit(assign(r0B8B, body.constant(0u), 0x01));

                     ir_variable *const r0BA5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0BA5, lshift(r0B8A, r0B8C), 0x01));

                     ir_variable *const r0BA6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BA8 = equal(r0B8C, body.constant(int(0)));
                     ir_if *f0BA7 = new(mem_ctx) ir_if(operand(r0BA8).val);
                     exec_list *const f0BA7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BA7->then_instructions;

                        body.emit(assign(r0BA6, r0B89, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BA7->else_instructions;

                        ir_expression *const r0BA9 = lshift(r0B89, r0B8C);
                        ir_expression *const r0BAA = neg(r0B8C);
                        ir_expression *const r0BAB = bit_and(r0BAA, body.constant(int(31)));
                        ir_expression *const r0BAC = rshift(r0B8A, r0BAB);
                        body.emit(assign(r0BA6, bit_or(r0BA9, r0BAC), 0x01));


                     body.instructions = f0BA7_parent_instructions;
                     body.emit(f0BA7);

                     /* END IF */

                     body.emit(assign(r0B89, r0BA6, 0x01));

                     body.emit(assign(r0B8A, r0BA5, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0BA3->else_instructions;

                     ir_variable *const r0BAD = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0BAD, body.constant(0u), 0x01));

                     ir_variable *const r0BAE = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0BAE, neg(r0B8C), 0x01));

                     ir_variable *const r0BAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0BAF);
                     ir_variable *const r0BB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0BB0);
                     ir_variable *const r0BB1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0BB1);
                     ir_variable *const r0BB2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0BB3 = neg(r0BAE);
                     body.emit(assign(r0BB2, bit_and(r0BB3, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0BB5 = equal(r0BAE, body.constant(int(0)));
                     ir_if *f0BB4 = new(mem_ctx) ir_if(operand(r0BB5).val);
                     exec_list *const f0BB4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BB4->then_instructions;

                        body.emit(assign(r0BAF, r0BAD, 0x01));

                        body.emit(assign(r0BB0, r0B8A, 0x01));

                        body.emit(assign(r0BB1, r0B89, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BB4->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BB7 = less(r0BAE, body.constant(int(32)));
                        ir_if *f0BB6 = new(mem_ctx) ir_if(operand(r0BB7).val);
                        exec_list *const f0BB6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BB6->then_instructions;

                           body.emit(assign(r0BAF, lshift(r0B8A, r0BB2), 0x01));

                           ir_expression *const r0BB8 = lshift(r0B89, r0BB2);
                           ir_expression *const r0BB9 = rshift(r0B8A, r0BAE);
                           body.emit(assign(r0BB0, bit_or(r0BB8, r0BB9), 0x01));

                           body.emit(assign(r0BB1, rshift(r0B89, r0BAE), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BB6->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0BBB = equal(r0BAE, body.constant(int(32)));
                           ir_if *f0BBA = new(mem_ctx) ir_if(operand(r0BBB).val);
                           exec_list *const f0BBA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BBA->then_instructions;

                              body.emit(assign(r0BAF, r0B8A, 0x01));

                              body.emit(assign(r0BB0, r0B89, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BBA->else_instructions;

                              body.emit(assign(r0BAD, bit_or(body.constant(0u), r0B8A), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0BBD = less(r0BAE, body.constant(int(64)));
                              ir_if *f0BBC = new(mem_ctx) ir_if(operand(r0BBD).val);
                              exec_list *const f0BBC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BBC->then_instructions;

                                 body.emit(assign(r0BAF, lshift(r0B89, r0BB2), 0x01));

                                 ir_expression *const r0BBE = bit_and(r0BAE, body.constant(int(31)));
                                 body.emit(assign(r0BB0, rshift(r0B89, r0BBE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BBC->else_instructions;

                                 ir_variable *const r0BBF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0BC1 = equal(r0BAE, body.constant(int(64)));
                                 ir_if *f0BC0 = new(mem_ctx) ir_if(operand(r0BC1).val);
                                 exec_list *const f0BC0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BC0->then_instructions;

                                    body.emit(assign(r0BBF, r0B89, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BC0->else_instructions;

                                    ir_expression *const r0BC2 = nequal(r0B89, body.constant(0u));
                                    ir_expression *const r0BC3 = expr(ir_unop_b2i, r0BC2);
                                    body.emit(assign(r0BBF, expr(ir_unop_i2u, r0BC3), 0x01));


                                 body.instructions = f0BC0_parent_instructions;
                                 body.emit(f0BC0);

                                 /* END IF */

                                 body.emit(assign(r0BAF, r0BBF, 0x01));

                                 body.emit(assign(r0BB0, body.constant(0u), 0x01));


                              body.instructions = f0BBC_parent_instructions;
                              body.emit(f0BBC);

                              /* END IF */


                           body.instructions = f0BBA_parent_instructions;
                           body.emit(f0BBA);

                           /* END IF */

                           body.emit(assign(r0BB1, body.constant(0u), 0x01));


                        body.instructions = f0BB6_parent_instructions;
                        body.emit(f0BB6);

                        /* END IF */

                        ir_expression *const r0BC4 = nequal(r0BAD, body.constant(0u));
                        ir_expression *const r0BC5 = expr(ir_unop_b2i, r0BC4);
                        ir_expression *const r0BC6 = expr(ir_unop_i2u, r0BC5);
                        body.emit(assign(r0BAF, bit_or(r0BAF, r0BC6), 0x01));


                     body.instructions = f0BB4_parent_instructions;
                     body.emit(f0BB4);

                     /* END IF */

                     body.emit(assign(r0B89, r0BB1, 0x01));

                     body.emit(assign(r0B8A, r0BB0, 0x01));

                     body.emit(assign(r0B8B, r0BAF, 0x01));


                  body.instructions = f0BA3_parent_instructions;
                  body.emit(f0BA3);

                  /* END IF */

                  body.emit(assign(r0B88, sub(r0B88, r0B8C), 0x01));

                  ir_variable *const r0BC7 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0BC7, r0B88, 0x01));

                  ir_variable *const r0BC8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0BC8, r0B89, 0x01));

                  ir_variable *const r0BC9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0BC9, r0B8A, 0x01));

                  ir_variable *const r0BCA = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0BCA, r0B8B, 0x01));

                  ir_variable *const r0BCB = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0BCB, body.constant(true), 0x01));

                  ir_variable *const r0BCC = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0BCD = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0BCD);
                  ir_expression *const r0BCE = expr(ir_unop_u2i, r0B8B);
                  body.emit(assign(r0BCD, less(r0BCE, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BD0 = lequal(body.constant(int(2045)), r0B88);
                  ir_if *f0BCF = new(mem_ctx) ir_if(operand(r0BD0).val);
                  exec_list *const f0BCF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BCF->then_instructions;

                     ir_variable *const r0BD1 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BD3 = less(body.constant(int(2045)), r0B88);
                     ir_if *f0BD2 = new(mem_ctx) ir_if(operand(r0BD3).val);
                     exec_list *const f0BD2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD2->then_instructions;

                        body.emit(assign(r0BD1, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD2->else_instructions;

                        ir_variable *const r0BD4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0BD6 = equal(r0B88, body.constant(int(2045)));
                        ir_if *f0BD5 = new(mem_ctx) ir_if(operand(r0BD6).val);
                        exec_list *const f0BD5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BD5->then_instructions;

                           ir_expression *const r0BD7 = equal(body.constant(2097151u), r0B89);
                           ir_expression *const r0BD8 = equal(body.constant(4294967295u), r0B8A);
                           body.emit(assign(r0BD4, logic_and(r0BD7, r0BD8), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BD5->else_instructions;

                           body.emit(assign(r0BD4, body.constant(false), 0x01));


                        body.instructions = f0BD5_parent_instructions;
                        body.emit(f0BD5);

                        /* END IF */

                        body.emit(assign(r0BD1, logic_and(r0BD4, r0BCD), 0x01));


                     body.instructions = f0BD2_parent_instructions;
                     body.emit(f0BD2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0BD9 = new(mem_ctx) ir_if(operand(r0BD1).val);
                     exec_list *const f0BD9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD9->then_instructions;

                        ir_variable *const r0BDA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0BDA);
                        ir_expression *const r0BDB = lshift(r0999, body.constant(int(31)));
                        body.emit(assign(r0BDA, add(r0BDB, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0BDA, body.constant(0u), 0x01));

                        body.emit(assign(r0BCC, r0BDA, 0x03));

                        body.emit(assign(r0BCB, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BDD = less(r0B88, body.constant(int(0)));
                        ir_if *f0BDC = new(mem_ctx) ir_if(operand(r0BDD).val);
                        exec_list *const f0BDC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BDC->then_instructions;

                           ir_variable *const r0BDE = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0BDE, r0B8B, 0x01));

                           ir_variable *const r0BDF = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0BDF, neg(r0B88), 0x01));

                           ir_variable *const r0BE0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0BE0);
                           ir_variable *const r0BE1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0BE1);
                           ir_variable *const r0BE2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0BE2);
                           ir_variable *const r0BE3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0BE4 = neg(r0BDF);
                           body.emit(assign(r0BE3, bit_and(r0BE4, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0BE6 = equal(r0BDF, body.constant(int(0)));
                           ir_if *f0BE5 = new(mem_ctx) ir_if(operand(r0BE6).val);
                           exec_list *const f0BE5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BE5->then_instructions;

                              body.emit(assign(r0BE0, r0B8B, 0x01));

                              body.emit(assign(r0BE1, r0B8A, 0x01));

                              body.emit(assign(r0BE2, r0B89, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BE5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0BE8 = less(r0BDF, body.constant(int(32)));
                              ir_if *f0BE7 = new(mem_ctx) ir_if(operand(r0BE8).val);
                              exec_list *const f0BE7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BE7->then_instructions;

                                 body.emit(assign(r0BE0, lshift(r0B8A, r0BE3), 0x01));

                                 ir_expression *const r0BE9 = lshift(r0B89, r0BE3);
                                 ir_expression *const r0BEA = rshift(r0B8A, r0BDF);
                                 body.emit(assign(r0BE1, bit_or(r0BE9, r0BEA), 0x01));

                                 body.emit(assign(r0BE2, rshift(r0B89, r0BDF), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BE7->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0BEC = equal(r0BDF, body.constant(int(32)));
                                 ir_if *f0BEB = new(mem_ctx) ir_if(operand(r0BEC).val);
                                 exec_list *const f0BEB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BEB->then_instructions;

                                    body.emit(assign(r0BE0, r0B8A, 0x01));

                                    body.emit(assign(r0BE1, r0B89, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BEB->else_instructions;

                                    body.emit(assign(r0BDE, bit_or(r0B8B, r0B8A), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0BEE = less(r0BDF, body.constant(int(64)));
                                    ir_if *f0BED = new(mem_ctx) ir_if(operand(r0BEE).val);
                                    exec_list *const f0BED_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0BED->then_instructions;

                                       body.emit(assign(r0BE0, lshift(r0B89, r0BE3), 0x01));

                                       ir_expression *const r0BEF = bit_and(r0BDF, body.constant(int(31)));
                                       body.emit(assign(r0BE1, rshift(r0B89, r0BEF), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0BED->else_instructions;

                                       ir_variable *const r0BF0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0BF2 = equal(r0BDF, body.constant(int(64)));
                                       ir_if *f0BF1 = new(mem_ctx) ir_if(operand(r0BF2).val);
                                       exec_list *const f0BF1_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0BF1->then_instructions;

                                          body.emit(assign(r0BF0, r0B89, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0BF1->else_instructions;

                                          ir_expression *const r0BF3 = nequal(r0B89, body.constant(0u));
                                          ir_expression *const r0BF4 = expr(ir_unop_b2i, r0BF3);
                                          body.emit(assign(r0BF0, expr(ir_unop_i2u, r0BF4), 0x01));


                                       body.instructions = f0BF1_parent_instructions;
                                       body.emit(f0BF1);

                                       /* END IF */

                                       body.emit(assign(r0BE0, r0BF0, 0x01));

                                       body.emit(assign(r0BE1, body.constant(0u), 0x01));


                                    body.instructions = f0BED_parent_instructions;
                                    body.emit(f0BED);

                                    /* END IF */


                                 body.instructions = f0BEB_parent_instructions;
                                 body.emit(f0BEB);

                                 /* END IF */

                                 body.emit(assign(r0BE2, body.constant(0u), 0x01));


                              body.instructions = f0BE7_parent_instructions;
                              body.emit(f0BE7);

                              /* END IF */

                              ir_expression *const r0BF5 = nequal(r0BDE, body.constant(0u));
                              ir_expression *const r0BF6 = expr(ir_unop_b2i, r0BF5);
                              ir_expression *const r0BF7 = expr(ir_unop_i2u, r0BF6);
                              body.emit(assign(r0BE0, bit_or(r0BE0, r0BF7), 0x01));


                           body.instructions = f0BE5_parent_instructions;
                           body.emit(f0BE5);

                           /* END IF */

                           body.emit(assign(r0BC8, r0BE2, 0x01));

                           body.emit(assign(r0BC9, r0BE1, 0x01));

                           body.emit(assign(r0BCA, r0BE0, 0x01));

                           body.emit(assign(r0BC7, body.constant(int(0)), 0x01));

                           body.emit(assign(r0BCD, less(r0BE0, body.constant(0u)), 0x01));


                        body.instructions = f0BDC_parent_instructions;
                        body.emit(f0BDC);

                        /* END IF */


                     body.instructions = f0BD9_parent_instructions;
                     body.emit(f0BD9);

                     /* END IF */


                  body.instructions = f0BCF_parent_instructions;
                  body.emit(f0BCF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0BF8 = new(mem_ctx) ir_if(operand(r0BCB).val);
                  exec_list *const f0BF8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BF8->then_instructions;

                     /* IF CONDITION */
                     ir_if *f0BF9 = new(mem_ctx) ir_if(operand(r0BCD).val);
                     exec_list *const f0BF9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BF9->then_instructions;

                        ir_variable *const r0BFA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r0BFA, add(r0BC9, body.constant(1u)), 0x01));

                        ir_expression *const r0BFB = less(r0BFA, r0BC9);
                        ir_expression *const r0BFC = expr(ir_unop_b2i, r0BFB);
                        ir_expression *const r0BFD = expr(ir_unop_i2u, r0BFC);
                        body.emit(assign(r0BC8, add(r0BC8, r0BFD), 0x01));

                        ir_expression *const r0BFE = equal(r0BCA, body.constant(0u));
                        ir_expression *const r0BFF = expr(ir_unop_b2i, r0BFE);
                        ir_expression *const r0C00 = expr(ir_unop_i2u, r0BFF);
                        ir_expression *const r0C01 = add(r0BCA, r0C00);
                        ir_expression *const r0C02 = bit_and(r0C01, body.constant(1u));
                        ir_expression *const r0C03 = expr(ir_unop_bit_not, r0C02);
                        body.emit(assign(r0BC9, bit_and(r0BFA, r0C03), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BF9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0C05 = bit_or(r0BC8, r0BC9);
                        ir_expression *const r0C06 = equal(r0C05, body.constant(0u));
                        ir_if *f0C04 = new(mem_ctx) ir_if(operand(r0C06).val);
                        exec_list *const f0C04_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C04->then_instructions;

                           body.emit(assign(r0BC7, body.constant(int(0)), 0x01));


                        body.instructions = f0C04_parent_instructions;
                        body.emit(f0C04);

                        /* END IF */


                     body.instructions = f0BF9_parent_instructions;
                     body.emit(f0BF9);

                     /* END IF */

                     ir_variable *const r0C07 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0C07);
                     ir_expression *const r0C08 = lshift(r0999, body.constant(int(31)));
                     ir_expression *const r0C09 = expr(ir_unop_i2u, r0BC7);
                     ir_expression *const r0C0A = lshift(r0C09, body.constant(int(20)));
                     ir_expression *const r0C0B = add(r0C08, r0C0A);
                     body.emit(assign(r0C07, add(r0C0B, r0BC8), 0x02));

                     body.emit(assign(r0C07, r0BC9, 0x01));

                     body.emit(assign(r0BCC, r0C07, 0x03));

                     body.emit(assign(r0BCB, body.constant(false), 0x01));


                  body.instructions = f0BF8_parent_instructions;
                  body.emit(f0BF8);

                  /* END IF */

                  body.emit(assign(r099A, r0BCC, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B80->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0C0D = less(swizzle_y(r099F), swizzle_y(r099D));
                  ir_if *f0C0C = new(mem_ctx) ir_if(operand(r0C0D).val);
                  exec_list *const f0C0C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0C0C->then_instructions;

                     ir_variable *const r0C0E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r0C0F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0C0F, sub(swizzle_x(r099D), swizzle_x(r099F)), 0x01));

                     ir_expression *const r0C10 = sub(swizzle_y(r099D), swizzle_y(r099F));
                     ir_expression *const r0C11 = less(swizzle_x(r099D), swizzle_x(r099F));
                     ir_expression *const r0C12 = expr(ir_unop_b2i, r0C11);
                     ir_expression *const r0C13 = expr(ir_unop_i2u, r0C12);
                     body.emit(assign(r0C0E, sub(r0C10, r0C13), 0x01));

                     body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                     body.emit(assign(r09A0, add(r099C, body.constant(int(-1))), 0x01));

                     ir_variable *const r0C14 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C14, add(r09A0, body.constant(int(-10))), 0x01));

                     ir_variable *const r0C15 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C15, r0C0E, 0x01));

                     ir_variable *const r0C16 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C16, r0C0F, 0x01));

                     ir_variable *const r0C17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r0C17);
                     ir_variable *const r0C18 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C18);
                     /* IF CONDITION */
                     ir_expression *const r0C1A = equal(r0C0E, body.constant(0u));
                     ir_if *f0C19 = new(mem_ctx) ir_if(operand(r0C1A).val);
                     exec_list *const f0C19_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C19->then_instructions;

                        body.emit(assign(r0C15, r0C0F, 0x01));

                        body.emit(assign(r0C16, body.constant(0u), 0x01));

                        body.emit(assign(r0C14, add(r0C14, body.constant(int(-32))), 0x01));


                     body.instructions = f0C19_parent_instructions;
                     body.emit(f0C19);

                     /* END IF */

                     ir_variable *const r0C1B = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0C1B, r0C15, 0x01));

                     ir_variable *const r0C1C = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0C1D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C1D);
                     /* IF CONDITION */
                     ir_expression *const r0C1F = equal(r0C15, body.constant(0u));
                     ir_if *f0C1E = new(mem_ctx) ir_if(operand(r0C1F).val);
                     exec_list *const f0C1E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C1E->then_instructions;

                        body.emit(assign(r0C1C, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C1E->else_instructions;

                        body.emit(assign(r0C1D, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C21 = bit_and(r0C15, body.constant(4294901760u));
                        ir_expression *const r0C22 = equal(r0C21, body.constant(0u));
                        ir_if *f0C20 = new(mem_ctx) ir_if(operand(r0C22).val);
                        exec_list *const f0C20_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C20->then_instructions;

                           body.emit(assign(r0C1D, body.constant(int(16)), 0x01));

                           body.emit(assign(r0C1B, lshift(r0C15, body.constant(int(16))), 0x01));


                        body.instructions = f0C20_parent_instructions;
                        body.emit(f0C20);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C24 = bit_and(r0C1B, body.constant(4278190080u));
                        ir_expression *const r0C25 = equal(r0C24, body.constant(0u));
                        ir_if *f0C23 = new(mem_ctx) ir_if(operand(r0C25).val);
                        exec_list *const f0C23_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C23->then_instructions;

                           body.emit(assign(r0C1D, add(r0C1D, body.constant(int(8))), 0x01));

                           body.emit(assign(r0C1B, lshift(r0C1B, body.constant(int(8))), 0x01));


                        body.instructions = f0C23_parent_instructions;
                        body.emit(f0C23);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C27 = bit_and(r0C1B, body.constant(4026531840u));
                        ir_expression *const r0C28 = equal(r0C27, body.constant(0u));
                        ir_if *f0C26 = new(mem_ctx) ir_if(operand(r0C28).val);
                        exec_list *const f0C26_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C26->then_instructions;

                           body.emit(assign(r0C1D, add(r0C1D, body.constant(int(4))), 0x01));

                           body.emit(assign(r0C1B, lshift(r0C1B, body.constant(int(4))), 0x01));


                        body.instructions = f0C26_parent_instructions;
                        body.emit(f0C26);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C2A = bit_and(r0C1B, body.constant(3221225472u));
                        ir_expression *const r0C2B = equal(r0C2A, body.constant(0u));
                        ir_if *f0C29 = new(mem_ctx) ir_if(operand(r0C2B).val);
                        exec_list *const f0C29_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C29->then_instructions;

                           body.emit(assign(r0C1D, add(r0C1D, body.constant(int(2))), 0x01));

                           body.emit(assign(r0C1B, lshift(r0C1B, body.constant(int(2))), 0x01));


                        body.instructions = f0C29_parent_instructions;
                        body.emit(f0C29);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C2D = bit_and(r0C1B, body.constant(2147483648u));
                        ir_expression *const r0C2E = equal(r0C2D, body.constant(0u));
                        ir_if *f0C2C = new(mem_ctx) ir_if(operand(r0C2E).val);
                        exec_list *const f0C2C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C2C->then_instructions;

                           body.emit(assign(r0C1D, add(r0C1D, body.constant(int(1))), 0x01));


                        body.instructions = f0C2C_parent_instructions;
                        body.emit(f0C2C);

                        /* END IF */

                        body.emit(assign(r0C1C, r0C1D, 0x01));


                     body.instructions = f0C1E_parent_instructions;
                     body.emit(f0C1E);

                     /* END IF */

                     body.emit(assign(r0C18, add(r0C1C, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C30 = lequal(body.constant(int(0)), r0C18);
                     ir_if *f0C2F = new(mem_ctx) ir_if(operand(r0C30).val);
                     exec_list *const f0C2F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C2F->then_instructions;

                        body.emit(assign(r0C17, body.constant(0u), 0x01));

                        ir_variable *const r0C31 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C31, lshift(r0C16, r0C18), 0x01));

                        ir_variable *const r0C32 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C34 = equal(r0C18, body.constant(int(0)));
                        ir_if *f0C33 = new(mem_ctx) ir_if(operand(r0C34).val);
                        exec_list *const f0C33_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C33->then_instructions;

                           body.emit(assign(r0C32, r0C15, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C33->else_instructions;

                           ir_expression *const r0C35 = lshift(r0C15, r0C18);
                           ir_expression *const r0C36 = neg(r0C18);
                           ir_expression *const r0C37 = bit_and(r0C36, body.constant(int(31)));
                           ir_expression *const r0C38 = rshift(r0C16, r0C37);
                           body.emit(assign(r0C32, bit_or(r0C35, r0C38), 0x01));


                        body.instructions = f0C33_parent_instructions;
                        body.emit(f0C33);

                        /* END IF */

                        body.emit(assign(r0C15, r0C32, 0x01));

                        body.emit(assign(r0C16, r0C31, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C2F->else_instructions;

                        ir_variable *const r0C39 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0C39, body.constant(0u), 0x01));

                        ir_variable *const r0C3A = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0C3A, neg(r0C18), 0x01));

                        ir_variable *const r0C3B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0C3B);
                        ir_variable *const r0C3C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0C3C);
                        ir_variable *const r0C3D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0C3D);
                        ir_variable *const r0C3E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0C3F = neg(r0C3A);
                        body.emit(assign(r0C3E, bit_and(r0C3F, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C41 = equal(r0C3A, body.constant(int(0)));
                        ir_if *f0C40 = new(mem_ctx) ir_if(operand(r0C41).val);
                        exec_list *const f0C40_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C40->then_instructions;

                           body.emit(assign(r0C3B, r0C39, 0x01));

                           body.emit(assign(r0C3C, r0C16, 0x01));

                           body.emit(assign(r0C3D, r0C15, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C40->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C43 = less(r0C3A, body.constant(int(32)));
                           ir_if *f0C42 = new(mem_ctx) ir_if(operand(r0C43).val);
                           exec_list *const f0C42_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C42->then_instructions;

                              body.emit(assign(r0C3B, lshift(r0C16, r0C3E), 0x01));

                              ir_expression *const r0C44 = lshift(r0C15, r0C3E);
                              ir_expression *const r0C45 = rshift(r0C16, r0C3A);
                              body.emit(assign(r0C3C, bit_or(r0C44, r0C45), 0x01));

                              body.emit(assign(r0C3D, rshift(r0C15, r0C3A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C42->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0C47 = equal(r0C3A, body.constant(int(32)));
                              ir_if *f0C46 = new(mem_ctx) ir_if(operand(r0C47).val);
                              exec_list *const f0C46_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C46->then_instructions;

                                 body.emit(assign(r0C3B, r0C16, 0x01));

                                 body.emit(assign(r0C3C, r0C15, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C46->else_instructions;

                                 body.emit(assign(r0C39, bit_or(body.constant(0u), r0C16), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0C49 = less(r0C3A, body.constant(int(64)));
                                 ir_if *f0C48 = new(mem_ctx) ir_if(operand(r0C49).val);
                                 exec_list *const f0C48_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C48->then_instructions;

                                    body.emit(assign(r0C3B, lshift(r0C15, r0C3E), 0x01));

                                    ir_expression *const r0C4A = bit_and(r0C3A, body.constant(int(31)));
                                    body.emit(assign(r0C3C, rshift(r0C15, r0C4A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C48->else_instructions;

                                    ir_variable *const r0C4B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0C4D = equal(r0C3A, body.constant(int(64)));
                                    ir_if *f0C4C = new(mem_ctx) ir_if(operand(r0C4D).val);
                                    exec_list *const f0C4C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C4C->then_instructions;

                                       body.emit(assign(r0C4B, r0C15, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C4C->else_instructions;

                                       ir_expression *const r0C4E = nequal(r0C15, body.constant(0u));
                                       ir_expression *const r0C4F = expr(ir_unop_b2i, r0C4E);
                                       body.emit(assign(r0C4B, expr(ir_unop_i2u, r0C4F), 0x01));


                                    body.instructions = f0C4C_parent_instructions;
                                    body.emit(f0C4C);

                                    /* END IF */

                                    body.emit(assign(r0C3B, r0C4B, 0x01));

                                    body.emit(assign(r0C3C, body.constant(0u), 0x01));


                                 body.instructions = f0C48_parent_instructions;
                                 body.emit(f0C48);

                                 /* END IF */


                              body.instructions = f0C46_parent_instructions;
                              body.emit(f0C46);

                              /* END IF */

                              body.emit(assign(r0C3D, body.constant(0u), 0x01));


                           body.instructions = f0C42_parent_instructions;
                           body.emit(f0C42);

                           /* END IF */

                           ir_expression *const r0C50 = nequal(r0C39, body.constant(0u));
                           ir_expression *const r0C51 = expr(ir_unop_b2i, r0C50);
                           ir_expression *const r0C52 = expr(ir_unop_i2u, r0C51);
                           body.emit(assign(r0C3B, bit_or(r0C3B, r0C52), 0x01));


                        body.instructions = f0C40_parent_instructions;
                        body.emit(f0C40);

                        /* END IF */

                        body.emit(assign(r0C15, r0C3D, 0x01));

                        body.emit(assign(r0C16, r0C3C, 0x01));

                        body.emit(assign(r0C17, r0C3B, 0x01));


                     body.instructions = f0C2F_parent_instructions;
                     body.emit(f0C2F);

                     /* END IF */

                     body.emit(assign(r0C14, sub(r0C14, r0C18), 0x01));

                     ir_variable *const r0C53 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C53, r0C14, 0x01));

                     ir_variable *const r0C54 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C54, r0C15, 0x01));

                     ir_variable *const r0C55 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C55, r0C16, 0x01));

                     ir_variable *const r0C56 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r0C56, r0C17, 0x01));

                     ir_variable *const r0C57 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r0C57, body.constant(true), 0x01));

                     ir_variable *const r0C58 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r0C59 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r0C59);
                     ir_expression *const r0C5A = expr(ir_unop_u2i, r0C17);
                     body.emit(assign(r0C59, less(r0C5A, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C5C = lequal(body.constant(int(2045)), r0C14);
                     ir_if *f0C5B = new(mem_ctx) ir_if(operand(r0C5C).val);
                     exec_list *const f0C5B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C5B->then_instructions;

                        ir_variable *const r0C5D = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C5F = less(body.constant(int(2045)), r0C14);
                        ir_if *f0C5E = new(mem_ctx) ir_if(operand(r0C5F).val);
                        exec_list *const f0C5E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C5E->then_instructions;

                           body.emit(assign(r0C5D, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C5E->else_instructions;

                           ir_variable *const r0C60 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0C62 = equal(r0C14, body.constant(int(2045)));
                           ir_if *f0C61 = new(mem_ctx) ir_if(operand(r0C62).val);
                           exec_list *const f0C61_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C61->then_instructions;

                              ir_expression *const r0C63 = equal(body.constant(2097151u), r0C15);
                              ir_expression *const r0C64 = equal(body.constant(4294967295u), r0C16);
                              body.emit(assign(r0C60, logic_and(r0C63, r0C64), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C61->else_instructions;

                              body.emit(assign(r0C60, body.constant(false), 0x01));


                           body.instructions = f0C61_parent_instructions;
                           body.emit(f0C61);

                           /* END IF */

                           body.emit(assign(r0C5D, logic_and(r0C60, r0C59), 0x01));


                        body.instructions = f0C5E_parent_instructions;
                        body.emit(f0C5E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0C65 = new(mem_ctx) ir_if(operand(r0C5D).val);
                        exec_list *const f0C65_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C65->then_instructions;

                           ir_variable *const r0C66 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0C66);
                           ir_expression *const r0C67 = lshift(r0999, body.constant(int(31)));
                           body.emit(assign(r0C66, add(r0C67, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r0C66, body.constant(0u), 0x01));

                           body.emit(assign(r0C58, r0C66, 0x03));

                           body.emit(assign(r0C57, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C65->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C69 = less(r0C14, body.constant(int(0)));
                           ir_if *f0C68 = new(mem_ctx) ir_if(operand(r0C69).val);
                           exec_list *const f0C68_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C68->then_instructions;

                              ir_variable *const r0C6A = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0C6A, r0C17, 0x01));

                              ir_variable *const r0C6B = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0C6B, neg(r0C14), 0x01));

                              ir_variable *const r0C6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0C6C);
                              ir_variable *const r0C6D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0C6D);
                              ir_variable *const r0C6E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0C6E);
                              ir_variable *const r0C6F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0C70 = neg(r0C6B);
                              body.emit(assign(r0C6F, bit_and(r0C70, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0C72 = equal(r0C6B, body.constant(int(0)));
                              ir_if *f0C71 = new(mem_ctx) ir_if(operand(r0C72).val);
                              exec_list *const f0C71_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C71->then_instructions;

                                 body.emit(assign(r0C6C, r0C17, 0x01));

                                 body.emit(assign(r0C6D, r0C16, 0x01));

                                 body.emit(assign(r0C6E, r0C15, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C71->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0C74 = less(r0C6B, body.constant(int(32)));
                                 ir_if *f0C73 = new(mem_ctx) ir_if(operand(r0C74).val);
                                 exec_list *const f0C73_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C73->then_instructions;

                                    body.emit(assign(r0C6C, lshift(r0C16, r0C6F), 0x01));

                                    ir_expression *const r0C75 = lshift(r0C15, r0C6F);
                                    ir_expression *const r0C76 = rshift(r0C16, r0C6B);
                                    body.emit(assign(r0C6D, bit_or(r0C75, r0C76), 0x01));

                                    body.emit(assign(r0C6E, rshift(r0C15, r0C6B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C73->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0C78 = equal(r0C6B, body.constant(int(32)));
                                    ir_if *f0C77 = new(mem_ctx) ir_if(operand(r0C78).val);
                                    exec_list *const f0C77_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C77->then_instructions;

                                       body.emit(assign(r0C6C, r0C16, 0x01));

                                       body.emit(assign(r0C6D, r0C15, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C77->else_instructions;

                                       body.emit(assign(r0C6A, bit_or(r0C17, r0C16), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0C7A = less(r0C6B, body.constant(int(64)));
                                       ir_if *f0C79 = new(mem_ctx) ir_if(operand(r0C7A).val);
                                       exec_list *const f0C79_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0C79->then_instructions;

                                          body.emit(assign(r0C6C, lshift(r0C15, r0C6F), 0x01));

                                          ir_expression *const r0C7B = bit_and(r0C6B, body.constant(int(31)));
                                          body.emit(assign(r0C6D, rshift(r0C15, r0C7B), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0C79->else_instructions;

                                          ir_variable *const r0C7C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0C7E = equal(r0C6B, body.constant(int(64)));
                                          ir_if *f0C7D = new(mem_ctx) ir_if(operand(r0C7E).val);
                                          exec_list *const f0C7D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0C7D->then_instructions;

                                             body.emit(assign(r0C7C, r0C15, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0C7D->else_instructions;

                                             ir_expression *const r0C7F = nequal(r0C15, body.constant(0u));
                                             ir_expression *const r0C80 = expr(ir_unop_b2i, r0C7F);
                                             body.emit(assign(r0C7C, expr(ir_unop_i2u, r0C80), 0x01));


                                          body.instructions = f0C7D_parent_instructions;
                                          body.emit(f0C7D);

                                          /* END IF */

                                          body.emit(assign(r0C6C, r0C7C, 0x01));

                                          body.emit(assign(r0C6D, body.constant(0u), 0x01));


                                       body.instructions = f0C79_parent_instructions;
                                       body.emit(f0C79);

                                       /* END IF */


                                    body.instructions = f0C77_parent_instructions;
                                    body.emit(f0C77);

                                    /* END IF */

                                    body.emit(assign(r0C6E, body.constant(0u), 0x01));


                                 body.instructions = f0C73_parent_instructions;
                                 body.emit(f0C73);

                                 /* END IF */

                                 ir_expression *const r0C81 = nequal(r0C6A, body.constant(0u));
                                 ir_expression *const r0C82 = expr(ir_unop_b2i, r0C81);
                                 ir_expression *const r0C83 = expr(ir_unop_i2u, r0C82);
                                 body.emit(assign(r0C6C, bit_or(r0C6C, r0C83), 0x01));


                              body.instructions = f0C71_parent_instructions;
                              body.emit(f0C71);

                              /* END IF */

                              body.emit(assign(r0C54, r0C6E, 0x01));

                              body.emit(assign(r0C55, r0C6D, 0x01));

                              body.emit(assign(r0C56, r0C6C, 0x01));

                              body.emit(assign(r0C53, body.constant(int(0)), 0x01));

                              body.emit(assign(r0C59, less(r0C6C, body.constant(0u)), 0x01));


                           body.instructions = f0C68_parent_instructions;
                           body.emit(f0C68);

                           /* END IF */


                        body.instructions = f0C65_parent_instructions;
                        body.emit(f0C65);

                        /* END IF */


                     body.instructions = f0C5B_parent_instructions;
                     body.emit(f0C5B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0C84 = new(mem_ctx) ir_if(operand(r0C57).val);
                     exec_list *const f0C84_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C84->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0C85 = new(mem_ctx) ir_if(operand(r0C59).val);
                        exec_list *const f0C85_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C85->then_instructions;

                           ir_variable *const r0C86 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r0C86, add(r0C55, body.constant(1u)), 0x01));

                           ir_expression *const r0C87 = less(r0C86, r0C55);
                           ir_expression *const r0C88 = expr(ir_unop_b2i, r0C87);
                           ir_expression *const r0C89 = expr(ir_unop_i2u, r0C88);
                           body.emit(assign(r0C54, add(r0C54, r0C89), 0x01));

                           ir_expression *const r0C8A = equal(r0C56, body.constant(0u));
                           ir_expression *const r0C8B = expr(ir_unop_b2i, r0C8A);
                           ir_expression *const r0C8C = expr(ir_unop_i2u, r0C8B);
                           ir_expression *const r0C8D = add(r0C56, r0C8C);
                           ir_expression *const r0C8E = bit_and(r0C8D, body.constant(1u));
                           ir_expression *const r0C8F = expr(ir_unop_bit_not, r0C8E);
                           body.emit(assign(r0C55, bit_and(r0C86, r0C8F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C85->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C91 = bit_or(r0C54, r0C55);
                           ir_expression *const r0C92 = equal(r0C91, body.constant(0u));
                           ir_if *f0C90 = new(mem_ctx) ir_if(operand(r0C92).val);
                           exec_list *const f0C90_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C90->then_instructions;

                              body.emit(assign(r0C53, body.constant(int(0)), 0x01));


                           body.instructions = f0C90_parent_instructions;
                           body.emit(f0C90);

                           /* END IF */


                        body.instructions = f0C85_parent_instructions;
                        body.emit(f0C85);

                        /* END IF */

                        ir_variable *const r0C93 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0C93);
                        ir_expression *const r0C94 = lshift(r0999, body.constant(int(31)));
                        ir_expression *const r0C95 = expr(ir_unop_i2u, r0C53);
                        ir_expression *const r0C96 = lshift(r0C95, body.constant(int(20)));
                        ir_expression *const r0C97 = add(r0C94, r0C96);
                        body.emit(assign(r0C93, add(r0C97, r0C54), 0x02));

                        body.emit(assign(r0C93, r0C55, 0x01));

                        body.emit(assign(r0C58, r0C93, 0x03));

                        body.emit(assign(r0C57, body.constant(false), 0x01));


                     body.instructions = f0C84_parent_instructions;
                     body.emit(f0C84);

                     /* END IF */

                     body.emit(assign(r099A, r0C58, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0C0C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0C99 = less(swizzle_x(r099D), swizzle_x(r099F));
                     ir_if *f0C98 = new(mem_ctx) ir_if(operand(r0C99).val);
                     exec_list *const f0C98_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C98->then_instructions;

                        ir_variable *const r0C9A = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r0C9B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C9B, sub(swizzle_x(r099F), swizzle_x(r099D)), 0x01));

                        ir_expression *const r0C9C = sub(swizzle_y(r099F), swizzle_y(r099D));
                        ir_expression *const r0C9D = less(swizzle_x(r099F), swizzle_x(r099D));
                        ir_expression *const r0C9E = expr(ir_unop_b2i, r0C9D);
                        ir_expression *const r0C9F = expr(ir_unop_i2u, r0C9E);
                        body.emit(assign(r0C9A, sub(r0C9C, r0C9F), 0x01));

                        body.emit(assign(r09A0, add(r099E, body.constant(int(-1))), 0x01));

                        ir_variable *const r0CA0 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0CA0, add(r09A0, body.constant(int(-10))), 0x01));

                        ir_variable *const r0CA1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0CA1, r0C9A, 0x01));

                        ir_variable *const r0CA2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CA2, r0C9B, 0x01));

                        ir_variable *const r0CA3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0CA3);
                        ir_variable *const r0CA4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA4);
                        /* IF CONDITION */
                        ir_expression *const r0CA6 = equal(r0C9A, body.constant(0u));
                        ir_if *f0CA5 = new(mem_ctx) ir_if(operand(r0CA6).val);
                        exec_list *const f0CA5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA5->then_instructions;

                           body.emit(assign(r0CA1, r0C9B, 0x01));

                           body.emit(assign(r0CA2, body.constant(0u), 0x01));

                           body.emit(assign(r0CA0, add(r0CA0, body.constant(int(-32))), 0x01));


                        body.instructions = f0CA5_parent_instructions;
                        body.emit(f0CA5);

                        /* END IF */

                        ir_variable *const r0CA7 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r0CA7, r0CA1, 0x01));

                        ir_variable *const r0CA8 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r0CA9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA9);
                        /* IF CONDITION */
                        ir_expression *const r0CAB = equal(r0CA1, body.constant(0u));
                        ir_if *f0CAA = new(mem_ctx) ir_if(operand(r0CAB).val);
                        exec_list *const f0CAA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CAA->then_instructions;

                           body.emit(assign(r0CA8, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CAA->else_instructions;

                           body.emit(assign(r0CA9, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CAD = bit_and(r0CA1, body.constant(4294901760u));
                           ir_expression *const r0CAE = equal(r0CAD, body.constant(0u));
                           ir_if *f0CAC = new(mem_ctx) ir_if(operand(r0CAE).val);
                           exec_list *const f0CAC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAC->then_instructions;

                              body.emit(assign(r0CA9, body.constant(int(16)), 0x01));

                              body.emit(assign(r0CA7, lshift(r0CA1, body.constant(int(16))), 0x01));


                           body.instructions = f0CAC_parent_instructions;
                           body.emit(f0CAC);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB0 = bit_and(r0CA7, body.constant(4278190080u));
                           ir_expression *const r0CB1 = equal(r0CB0, body.constant(0u));
                           ir_if *f0CAF = new(mem_ctx) ir_if(operand(r0CB1).val);
                           exec_list *const f0CAF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAF->then_instructions;

                              body.emit(assign(r0CA9, add(r0CA9, body.constant(int(8))), 0x01));

                              body.emit(assign(r0CA7, lshift(r0CA7, body.constant(int(8))), 0x01));


                           body.instructions = f0CAF_parent_instructions;
                           body.emit(f0CAF);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB3 = bit_and(r0CA7, body.constant(4026531840u));
                           ir_expression *const r0CB4 = equal(r0CB3, body.constant(0u));
                           ir_if *f0CB2 = new(mem_ctx) ir_if(operand(r0CB4).val);
                           exec_list *const f0CB2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB2->then_instructions;

                              body.emit(assign(r0CA9, add(r0CA9, body.constant(int(4))), 0x01));

                              body.emit(assign(r0CA7, lshift(r0CA7, body.constant(int(4))), 0x01));


                           body.instructions = f0CB2_parent_instructions;
                           body.emit(f0CB2);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB6 = bit_and(r0CA7, body.constant(3221225472u));
                           ir_expression *const r0CB7 = equal(r0CB6, body.constant(0u));
                           ir_if *f0CB5 = new(mem_ctx) ir_if(operand(r0CB7).val);
                           exec_list *const f0CB5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB5->then_instructions;

                              body.emit(assign(r0CA9, add(r0CA9, body.constant(int(2))), 0x01));

                              body.emit(assign(r0CA7, lshift(r0CA7, body.constant(int(2))), 0x01));


                           body.instructions = f0CB5_parent_instructions;
                           body.emit(f0CB5);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB9 = bit_and(r0CA7, body.constant(2147483648u));
                           ir_expression *const r0CBA = equal(r0CB9, body.constant(0u));
                           ir_if *f0CB8 = new(mem_ctx) ir_if(operand(r0CBA).val);
                           exec_list *const f0CB8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB8->then_instructions;

                              body.emit(assign(r0CA9, add(r0CA9, body.constant(int(1))), 0x01));


                           body.instructions = f0CB8_parent_instructions;
                           body.emit(f0CB8);

                           /* END IF */

                           body.emit(assign(r0CA8, r0CA9, 0x01));


                        body.instructions = f0CAA_parent_instructions;
                        body.emit(f0CAA);

                        /* END IF */

                        body.emit(assign(r0CA4, add(r0CA8, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CBC = lequal(body.constant(int(0)), r0CA4);
                        ir_if *f0CBB = new(mem_ctx) ir_if(operand(r0CBC).val);
                        exec_list *const f0CBB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CBB->then_instructions;

                           body.emit(assign(r0CA3, body.constant(0u), 0x01));

                           ir_variable *const r0CBD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0CBD, lshift(r0CA2, r0CA4), 0x01));

                           ir_variable *const r0CBE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CC0 = equal(r0CA4, body.constant(int(0)));
                           ir_if *f0CBF = new(mem_ctx) ir_if(operand(r0CC0).val);
                           exec_list *const f0CBF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CBF->then_instructions;

                              body.emit(assign(r0CBE, r0CA1, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CBF->else_instructions;

                              ir_expression *const r0CC1 = lshift(r0CA1, r0CA4);
                              ir_expression *const r0CC2 = neg(r0CA4);
                              ir_expression *const r0CC3 = bit_and(r0CC2, body.constant(int(31)));
                              ir_expression *const r0CC4 = rshift(r0CA2, r0CC3);
                              body.emit(assign(r0CBE, bit_or(r0CC1, r0CC4), 0x01));


                           body.instructions = f0CBF_parent_instructions;
                           body.emit(f0CBF);

                           /* END IF */

                           body.emit(assign(r0CA1, r0CBE, 0x01));

                           body.emit(assign(r0CA2, r0CBD, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CBB->else_instructions;

                           ir_variable *const r0CC5 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0CC5, body.constant(0u), 0x01));

                           ir_variable *const r0CC6 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0CC6, neg(r0CA4), 0x01));

                           ir_variable *const r0CC7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0CC7);
                           ir_variable *const r0CC8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0CC8);
                           ir_variable *const r0CC9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0CC9);
                           ir_variable *const r0CCA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0CCB = neg(r0CC6);
                           body.emit(assign(r0CCA, bit_and(r0CCB, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CCD = equal(r0CC6, body.constant(int(0)));
                           ir_if *f0CCC = new(mem_ctx) ir_if(operand(r0CCD).val);
                           exec_list *const f0CCC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CCC->then_instructions;

                              body.emit(assign(r0CC7, r0CC5, 0x01));

                              body.emit(assign(r0CC8, r0CA2, 0x01));

                              body.emit(assign(r0CC9, r0CA1, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CCC->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CCF = less(r0CC6, body.constant(int(32)));
                              ir_if *f0CCE = new(mem_ctx) ir_if(operand(r0CCF).val);
                              exec_list *const f0CCE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CCE->then_instructions;

                                 body.emit(assign(r0CC7, lshift(r0CA2, r0CCA), 0x01));

                                 ir_expression *const r0CD0 = lshift(r0CA1, r0CCA);
                                 ir_expression *const r0CD1 = rshift(r0CA2, r0CC6);
                                 body.emit(assign(r0CC8, bit_or(r0CD0, r0CD1), 0x01));

                                 body.emit(assign(r0CC9, rshift(r0CA1, r0CC6), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CCE->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0CD3 = equal(r0CC6, body.constant(int(32)));
                                 ir_if *f0CD2 = new(mem_ctx) ir_if(operand(r0CD3).val);
                                 exec_list *const f0CD2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CD2->then_instructions;

                                    body.emit(assign(r0CC7, r0CA2, 0x01));

                                    body.emit(assign(r0CC8, r0CA1, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CD2->else_instructions;

                                    body.emit(assign(r0CC5, bit_or(body.constant(0u), r0CA2), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0CD5 = less(r0CC6, body.constant(int(64)));
                                    ir_if *f0CD4 = new(mem_ctx) ir_if(operand(r0CD5).val);
                                    exec_list *const f0CD4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CD4->then_instructions;

                                       body.emit(assign(r0CC7, lshift(r0CA1, r0CCA), 0x01));

                                       ir_expression *const r0CD6 = bit_and(r0CC6, body.constant(int(31)));
                                       body.emit(assign(r0CC8, rshift(r0CA1, r0CD6), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CD4->else_instructions;

                                       ir_variable *const r0CD7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0CD9 = equal(r0CC6, body.constant(int(64)));
                                       ir_if *f0CD8 = new(mem_ctx) ir_if(operand(r0CD9).val);
                                       exec_list *const f0CD8_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0CD8->then_instructions;

                                          body.emit(assign(r0CD7, r0CA1, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0CD8->else_instructions;

                                          ir_expression *const r0CDA = nequal(r0CA1, body.constant(0u));
                                          ir_expression *const r0CDB = expr(ir_unop_b2i, r0CDA);
                                          body.emit(assign(r0CD7, expr(ir_unop_i2u, r0CDB), 0x01));


                                       body.instructions = f0CD8_parent_instructions;
                                       body.emit(f0CD8);

                                       /* END IF */

                                       body.emit(assign(r0CC7, r0CD7, 0x01));

                                       body.emit(assign(r0CC8, body.constant(0u), 0x01));


                                    body.instructions = f0CD4_parent_instructions;
                                    body.emit(f0CD4);

                                    /* END IF */


                                 body.instructions = f0CD2_parent_instructions;
                                 body.emit(f0CD2);

                                 /* END IF */

                                 body.emit(assign(r0CC9, body.constant(0u), 0x01));


                              body.instructions = f0CCE_parent_instructions;
                              body.emit(f0CCE);

                              /* END IF */

                              ir_expression *const r0CDC = nequal(r0CC5, body.constant(0u));
                              ir_expression *const r0CDD = expr(ir_unop_b2i, r0CDC);
                              ir_expression *const r0CDE = expr(ir_unop_i2u, r0CDD);
                              body.emit(assign(r0CC7, bit_or(r0CC7, r0CDE), 0x01));


                           body.instructions = f0CCC_parent_instructions;
                           body.emit(f0CCC);

                           /* END IF */

                           body.emit(assign(r0CA1, r0CC9, 0x01));

                           body.emit(assign(r0CA2, r0CC8, 0x01));

                           body.emit(assign(r0CA3, r0CC7, 0x01));


                        body.instructions = f0CBB_parent_instructions;
                        body.emit(f0CBB);

                        /* END IF */

                        body.emit(assign(r0CA0, sub(r0CA0, r0CA4), 0x01));

                        ir_variable *const r0CDF = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0CDF, r0CA0, 0x01));

                        ir_variable *const r0CE0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0CE0, r0CA1, 0x01));

                        ir_variable *const r0CE1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CE1, r0CA2, 0x01));

                        ir_variable *const r0CE2 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r0CE2, r0CA3, 0x01));

                        ir_variable *const r0CE3 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r0CE3, body.constant(true), 0x01));

                        ir_variable *const r0CE4 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r0CE5 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r0CE5);
                        ir_expression *const r0CE6 = expr(ir_unop_u2i, r0CA3);
                        body.emit(assign(r0CE5, less(r0CE6, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CE8 = lequal(body.constant(int(2045)), r0CA0);
                        ir_if *f0CE7 = new(mem_ctx) ir_if(operand(r0CE8).val);
                        exec_list *const f0CE7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CE7->then_instructions;

                           ir_variable *const r0CE9 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CEB = less(body.constant(int(2045)), r0CA0);
                           ir_if *f0CEA = new(mem_ctx) ir_if(operand(r0CEB).val);
                           exec_list *const f0CEA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CEA->then_instructions;

                              body.emit(assign(r0CE9, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CEA->else_instructions;

                              ir_variable *const r0CEC = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0CEE = equal(r0CA0, body.constant(int(2045)));
                              ir_if *f0CED = new(mem_ctx) ir_if(operand(r0CEE).val);
                              exec_list *const f0CED_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CED->then_instructions;

                                 ir_expression *const r0CEF = equal(body.constant(2097151u), r0CA1);
                                 ir_expression *const r0CF0 = equal(body.constant(4294967295u), r0CA2);
                                 body.emit(assign(r0CEC, logic_and(r0CEF, r0CF0), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CED->else_instructions;

                                 body.emit(assign(r0CEC, body.constant(false), 0x01));


                              body.instructions = f0CED_parent_instructions;
                              body.emit(f0CED);

                              /* END IF */

                              body.emit(assign(r0CE9, logic_and(r0CEC, r0CE5), 0x01));


                           body.instructions = f0CEA_parent_instructions;
                           body.emit(f0CEA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0CF1 = new(mem_ctx) ir_if(operand(r0CE9).val);
                           exec_list *const f0CF1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CF1->then_instructions;

                              ir_variable *const r0CF2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0CF2);
                              ir_expression *const r0CF3 = lshift(r0999, body.constant(int(31)));
                              body.emit(assign(r0CF2, add(r0CF3, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r0CF2, body.constant(0u), 0x01));

                              body.emit(assign(r0CE4, r0CF2, 0x03));

                              body.emit(assign(r0CE3, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CF1->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CF5 = less(r0CA0, body.constant(int(0)));
                              ir_if *f0CF4 = new(mem_ctx) ir_if(operand(r0CF5).val);
                              exec_list *const f0CF4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CF4->then_instructions;

                                 ir_variable *const r0CF6 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r0CF6, r0CA3, 0x01));

                                 ir_variable *const r0CF7 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r0CF7, neg(r0CA0), 0x01));

                                 ir_variable *const r0CF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r0CF8);
                                 ir_variable *const r0CF9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r0CF9);
                                 ir_variable *const r0CFA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r0CFA);
                                 ir_variable *const r0CFB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r0CFC = neg(r0CF7);
                                 body.emit(assign(r0CFB, bit_and(r0CFC, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0CFE = equal(r0CF7, body.constant(int(0)));
                                 ir_if *f0CFD = new(mem_ctx) ir_if(operand(r0CFE).val);
                                 exec_list *const f0CFD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CFD->then_instructions;

                                    body.emit(assign(r0CF8, r0CA3, 0x01));

                                    body.emit(assign(r0CF9, r0CA2, 0x01));

                                    body.emit(assign(r0CFA, r0CA1, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CFD->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0D00 = less(r0CF7, body.constant(int(32)));
                                    ir_if *f0CFF = new(mem_ctx) ir_if(operand(r0D00).val);
                                    exec_list *const f0CFF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CFF->then_instructions;

                                       body.emit(assign(r0CF8, lshift(r0CA2, r0CFB), 0x01));

                                       ir_expression *const r0D01 = lshift(r0CA1, r0CFB);
                                       ir_expression *const r0D02 = rshift(r0CA2, r0CF7);
                                       body.emit(assign(r0CF9, bit_or(r0D01, r0D02), 0x01));

                                       body.emit(assign(r0CFA, rshift(r0CA1, r0CF7), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CFF->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D04 = equal(r0CF7, body.constant(int(32)));
                                       ir_if *f0D03 = new(mem_ctx) ir_if(operand(r0D04).val);
                                       exec_list *const f0D03_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D03->then_instructions;

                                          body.emit(assign(r0CF8, r0CA2, 0x01));

                                          body.emit(assign(r0CF9, r0CA1, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D03->else_instructions;

                                          body.emit(assign(r0CF6, bit_or(r0CA3, r0CA2), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r0D06 = less(r0CF7, body.constant(int(64)));
                                          ir_if *f0D05 = new(mem_ctx) ir_if(operand(r0D06).val);
                                          exec_list *const f0D05_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D05->then_instructions;

                                             body.emit(assign(r0CF8, lshift(r0CA1, r0CFB), 0x01));

                                             ir_expression *const r0D07 = bit_and(r0CF7, body.constant(int(31)));
                                             body.emit(assign(r0CF9, rshift(r0CA1, r0D07), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D05->else_instructions;

                                             ir_variable *const r0D08 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r0D0A = equal(r0CF7, body.constant(int(64)));
                                             ir_if *f0D09 = new(mem_ctx) ir_if(operand(r0D0A).val);
                                             exec_list *const f0D09_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D09->then_instructions;

                                                body.emit(assign(r0D08, r0CA1, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D09->else_instructions;

                                                ir_expression *const r0D0B = nequal(r0CA1, body.constant(0u));
                                                ir_expression *const r0D0C = expr(ir_unop_b2i, r0D0B);
                                                body.emit(assign(r0D08, expr(ir_unop_i2u, r0D0C), 0x01));


                                             body.instructions = f0D09_parent_instructions;
                                             body.emit(f0D09);

                                             /* END IF */

                                             body.emit(assign(r0CF8, r0D08, 0x01));

                                             body.emit(assign(r0CF9, body.constant(0u), 0x01));


                                          body.instructions = f0D05_parent_instructions;
                                          body.emit(f0D05);

                                          /* END IF */


                                       body.instructions = f0D03_parent_instructions;
                                       body.emit(f0D03);

                                       /* END IF */

                                       body.emit(assign(r0CFA, body.constant(0u), 0x01));


                                    body.instructions = f0CFF_parent_instructions;
                                    body.emit(f0CFF);

                                    /* END IF */

                                    ir_expression *const r0D0D = nequal(r0CF6, body.constant(0u));
                                    ir_expression *const r0D0E = expr(ir_unop_b2i, r0D0D);
                                    ir_expression *const r0D0F = expr(ir_unop_i2u, r0D0E);
                                    body.emit(assign(r0CF8, bit_or(r0CF8, r0D0F), 0x01));


                                 body.instructions = f0CFD_parent_instructions;
                                 body.emit(f0CFD);

                                 /* END IF */

                                 body.emit(assign(r0CE0, r0CFA, 0x01));

                                 body.emit(assign(r0CE1, r0CF9, 0x01));

                                 body.emit(assign(r0CE2, r0CF8, 0x01));

                                 body.emit(assign(r0CDF, body.constant(int(0)), 0x01));

                                 body.emit(assign(r0CE5, less(r0CF8, body.constant(0u)), 0x01));


                              body.instructions = f0CF4_parent_instructions;
                              body.emit(f0CF4);

                              /* END IF */


                           body.instructions = f0CF1_parent_instructions;
                           body.emit(f0CF1);

                           /* END IF */


                        body.instructions = f0CE7_parent_instructions;
                        body.emit(f0CE7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0D10 = new(mem_ctx) ir_if(operand(r0CE3).val);
                        exec_list *const f0D10_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D10->then_instructions;

                           /* IF CONDITION */
                           ir_if *f0D11 = new(mem_ctx) ir_if(operand(r0CE5).val);
                           exec_list *const f0D11_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D11->then_instructions;

                              ir_variable *const r0D12 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r0D12, add(r0CE1, body.constant(1u)), 0x01));

                              ir_expression *const r0D13 = less(r0D12, r0CE1);
                              ir_expression *const r0D14 = expr(ir_unop_b2i, r0D13);
                              ir_expression *const r0D15 = expr(ir_unop_i2u, r0D14);
                              body.emit(assign(r0CE0, add(r0CE0, r0D15), 0x01));

                              ir_expression *const r0D16 = equal(r0CE2, body.constant(0u));
                              ir_expression *const r0D17 = expr(ir_unop_b2i, r0D16);
                              ir_expression *const r0D18 = expr(ir_unop_i2u, r0D17);
                              ir_expression *const r0D19 = add(r0CE2, r0D18);
                              ir_expression *const r0D1A = bit_and(r0D19, body.constant(1u));
                              ir_expression *const r0D1B = expr(ir_unop_bit_not, r0D1A);
                              body.emit(assign(r0CE1, bit_and(r0D12, r0D1B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D11->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0D1D = bit_or(r0CE0, r0CE1);
                              ir_expression *const r0D1E = equal(r0D1D, body.constant(0u));
                              ir_if *f0D1C = new(mem_ctx) ir_if(operand(r0D1E).val);
                              exec_list *const f0D1C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D1C->then_instructions;

                                 body.emit(assign(r0CDF, body.constant(int(0)), 0x01));


                              body.instructions = f0D1C_parent_instructions;
                              body.emit(f0D1C);

                              /* END IF */


                           body.instructions = f0D11_parent_instructions;
                           body.emit(f0D11);

                           /* END IF */

                           ir_variable *const r0D1F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0D1F);
                           ir_expression *const r0D20 = lshift(r0999, body.constant(int(31)));
                           ir_expression *const r0D21 = expr(ir_unop_i2u, r0CDF);
                           ir_expression *const r0D22 = lshift(r0D21, body.constant(int(20)));
                           ir_expression *const r0D23 = add(r0D20, r0D22);
                           body.emit(assign(r0D1F, add(r0D23, r0CE0), 0x02));

                           body.emit(assign(r0D1F, r0CE1, 0x01));

                           body.emit(assign(r0CE4, r0D1F, 0x03));

                           body.emit(assign(r0CE3, body.constant(false), 0x01));


                        body.instructions = f0D10_parent_instructions;
                        body.emit(f0D10);

                        /* END IF */

                        body.emit(assign(r099A, r0CE4, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C98->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0D25 = less(swizzle_x(r099F), swizzle_x(r099D));
                        ir_if *f0D24 = new(mem_ctx) ir_if(operand(r0D25).val);
                        exec_list *const f0D24_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D24->then_instructions;

                           ir_variable *const r0D26 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r0D27 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0D27, sub(swizzle_x(r099D), swizzle_x(r099F)), 0x01));

                           ir_expression *const r0D28 = sub(swizzle_y(r099D), swizzle_y(r099F));
                           ir_expression *const r0D29 = less(swizzle_x(r099D), swizzle_x(r099F));
                           ir_expression *const r0D2A = expr(ir_unop_b2i, r0D29);
                           ir_expression *const r0D2B = expr(ir_unop_i2u, r0D2A);
                           body.emit(assign(r0D26, sub(r0D28, r0D2B), 0x01));

                           body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                           body.emit(assign(r09A0, add(r099C, body.constant(int(-1))), 0x01));

                           ir_variable *const r0D2C = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D2C, add(r09A0, body.constant(int(-10))), 0x01));

                           ir_variable *const r0D2D = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D2D, r0D26, 0x01));

                           ir_variable *const r0D2E = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D2E, r0D27, 0x01));

                           ir_variable *const r0D2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r0D2F);
                           ir_variable *const r0D30 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D30);
                           /* IF CONDITION */
                           ir_expression *const r0D32 = equal(r0D26, body.constant(0u));
                           ir_if *f0D31 = new(mem_ctx) ir_if(operand(r0D32).val);
                           exec_list *const f0D31_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D31->then_instructions;

                              body.emit(assign(r0D2D, r0D27, 0x01));

                              body.emit(assign(r0D2E, body.constant(0u), 0x01));

                              body.emit(assign(r0D2C, add(r0D2C, body.constant(int(-32))), 0x01));


                           body.instructions = f0D31_parent_instructions;
                           body.emit(f0D31);

                           /* END IF */

                           ir_variable *const r0D33 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r0D33, r0D2D, 0x01));

                           ir_variable *const r0D34 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r0D35 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D35);
                           /* IF CONDITION */
                           ir_expression *const r0D37 = equal(r0D2D, body.constant(0u));
                           ir_if *f0D36 = new(mem_ctx) ir_if(operand(r0D37).val);
                           exec_list *const f0D36_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D36->then_instructions;

                              body.emit(assign(r0D34, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D36->else_instructions;

                              body.emit(assign(r0D35, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D39 = bit_and(r0D2D, body.constant(4294901760u));
                              ir_expression *const r0D3A = equal(r0D39, body.constant(0u));
                              ir_if *f0D38 = new(mem_ctx) ir_if(operand(r0D3A).val);
                              exec_list *const f0D38_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D38->then_instructions;

                                 body.emit(assign(r0D35, body.constant(int(16)), 0x01));

                                 body.emit(assign(r0D33, lshift(r0D2D, body.constant(int(16))), 0x01));


                              body.instructions = f0D38_parent_instructions;
                              body.emit(f0D38);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3C = bit_and(r0D33, body.constant(4278190080u));
                              ir_expression *const r0D3D = equal(r0D3C, body.constant(0u));
                              ir_if *f0D3B = new(mem_ctx) ir_if(operand(r0D3D).val);
                              exec_list *const f0D3B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3B->then_instructions;

                                 body.emit(assign(r0D35, add(r0D35, body.constant(int(8))), 0x01));

                                 body.emit(assign(r0D33, lshift(r0D33, body.constant(int(8))), 0x01));


                              body.instructions = f0D3B_parent_instructions;
                              body.emit(f0D3B);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3F = bit_and(r0D33, body.constant(4026531840u));
                              ir_expression *const r0D40 = equal(r0D3F, body.constant(0u));
                              ir_if *f0D3E = new(mem_ctx) ir_if(operand(r0D40).val);
                              exec_list *const f0D3E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3E->then_instructions;

                                 body.emit(assign(r0D35, add(r0D35, body.constant(int(4))), 0x01));

                                 body.emit(assign(r0D33, lshift(r0D33, body.constant(int(4))), 0x01));


                              body.instructions = f0D3E_parent_instructions;
                              body.emit(f0D3E);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D42 = bit_and(r0D33, body.constant(3221225472u));
                              ir_expression *const r0D43 = equal(r0D42, body.constant(0u));
                              ir_if *f0D41 = new(mem_ctx) ir_if(operand(r0D43).val);
                              exec_list *const f0D41_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D41->then_instructions;

                                 body.emit(assign(r0D35, add(r0D35, body.constant(int(2))), 0x01));

                                 body.emit(assign(r0D33, lshift(r0D33, body.constant(int(2))), 0x01));


                              body.instructions = f0D41_parent_instructions;
                              body.emit(f0D41);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D45 = bit_and(r0D33, body.constant(2147483648u));
                              ir_expression *const r0D46 = equal(r0D45, body.constant(0u));
                              ir_if *f0D44 = new(mem_ctx) ir_if(operand(r0D46).val);
                              exec_list *const f0D44_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D44->then_instructions;

                                 body.emit(assign(r0D35, add(r0D35, body.constant(int(1))), 0x01));


                              body.instructions = f0D44_parent_instructions;
                              body.emit(f0D44);

                              /* END IF */

                              body.emit(assign(r0D34, r0D35, 0x01));


                           body.instructions = f0D36_parent_instructions;
                           body.emit(f0D36);

                           /* END IF */

                           body.emit(assign(r0D30, add(r0D34, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D48 = lequal(body.constant(int(0)), r0D30);
                           ir_if *f0D47 = new(mem_ctx) ir_if(operand(r0D48).val);
                           exec_list *const f0D47_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D47->then_instructions;

                              body.emit(assign(r0D2F, body.constant(0u), 0x01));

                              ir_variable *const r0D49 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r0D49, lshift(r0D2E, r0D30), 0x01));

                              ir_variable *const r0D4A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D4C = equal(r0D30, body.constant(int(0)));
                              ir_if *f0D4B = new(mem_ctx) ir_if(operand(r0D4C).val);
                              exec_list *const f0D4B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D4B->then_instructions;

                                 body.emit(assign(r0D4A, r0D2D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D4B->else_instructions;

                                 ir_expression *const r0D4D = lshift(r0D2D, r0D30);
                                 ir_expression *const r0D4E = neg(r0D30);
                                 ir_expression *const r0D4F = bit_and(r0D4E, body.constant(int(31)));
                                 ir_expression *const r0D50 = rshift(r0D2E, r0D4F);
                                 body.emit(assign(r0D4A, bit_or(r0D4D, r0D50), 0x01));


                              body.instructions = f0D4B_parent_instructions;
                              body.emit(f0D4B);

                              /* END IF */

                              body.emit(assign(r0D2D, r0D4A, 0x01));

                              body.emit(assign(r0D2E, r0D49, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D47->else_instructions;

                              ir_variable *const r0D51 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0D51, body.constant(0u), 0x01));

                              ir_variable *const r0D52 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0D52, neg(r0D30), 0x01));

                              ir_variable *const r0D53 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0D53);
                              ir_variable *const r0D54 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0D54);
                              ir_variable *const r0D55 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0D55);
                              ir_variable *const r0D56 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0D57 = neg(r0D52);
                              body.emit(assign(r0D56, bit_and(r0D57, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D59 = equal(r0D52, body.constant(int(0)));
                              ir_if *f0D58 = new(mem_ctx) ir_if(operand(r0D59).val);
                              exec_list *const f0D58_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D58->then_instructions;

                                 body.emit(assign(r0D53, r0D51, 0x01));

                                 body.emit(assign(r0D54, r0D2E, 0x01));

                                 body.emit(assign(r0D55, r0D2D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D58->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D5B = less(r0D52, body.constant(int(32)));
                                 ir_if *f0D5A = new(mem_ctx) ir_if(operand(r0D5B).val);
                                 exec_list *const f0D5A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D5A->then_instructions;

                                    body.emit(assign(r0D53, lshift(r0D2E, r0D56), 0x01));

                                    ir_expression *const r0D5C = lshift(r0D2D, r0D56);
                                    ir_expression *const r0D5D = rshift(r0D2E, r0D52);
                                    body.emit(assign(r0D54, bit_or(r0D5C, r0D5D), 0x01));

                                    body.emit(assign(r0D55, rshift(r0D2D, r0D52), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D5A->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0D5F = equal(r0D52, body.constant(int(32)));
                                    ir_if *f0D5E = new(mem_ctx) ir_if(operand(r0D5F).val);
                                    exec_list *const f0D5E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D5E->then_instructions;

                                       body.emit(assign(r0D53, r0D2E, 0x01));

                                       body.emit(assign(r0D54, r0D2D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D5E->else_instructions;

                                       body.emit(assign(r0D51, bit_or(body.constant(0u), r0D2E), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0D61 = less(r0D52, body.constant(int(64)));
                                       ir_if *f0D60 = new(mem_ctx) ir_if(operand(r0D61).val);
                                       exec_list *const f0D60_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D60->then_instructions;

                                          body.emit(assign(r0D53, lshift(r0D2D, r0D56), 0x01));

                                          ir_expression *const r0D62 = bit_and(r0D52, body.constant(int(31)));
                                          body.emit(assign(r0D54, rshift(r0D2D, r0D62), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D60->else_instructions;

                                          ir_variable *const r0D63 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0D65 = equal(r0D52, body.constant(int(64)));
                                          ir_if *f0D64 = new(mem_ctx) ir_if(operand(r0D65).val);
                                          exec_list *const f0D64_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D64->then_instructions;

                                             body.emit(assign(r0D63, r0D2D, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D64->else_instructions;

                                             ir_expression *const r0D66 = nequal(r0D2D, body.constant(0u));
                                             ir_expression *const r0D67 = expr(ir_unop_b2i, r0D66);
                                             body.emit(assign(r0D63, expr(ir_unop_i2u, r0D67), 0x01));


                                          body.instructions = f0D64_parent_instructions;
                                          body.emit(f0D64);

                                          /* END IF */

                                          body.emit(assign(r0D53, r0D63, 0x01));

                                          body.emit(assign(r0D54, body.constant(0u), 0x01));


                                       body.instructions = f0D60_parent_instructions;
                                       body.emit(f0D60);

                                       /* END IF */


                                    body.instructions = f0D5E_parent_instructions;
                                    body.emit(f0D5E);

                                    /* END IF */

                                    body.emit(assign(r0D55, body.constant(0u), 0x01));


                                 body.instructions = f0D5A_parent_instructions;
                                 body.emit(f0D5A);

                                 /* END IF */

                                 ir_expression *const r0D68 = nequal(r0D51, body.constant(0u));
                                 ir_expression *const r0D69 = expr(ir_unop_b2i, r0D68);
                                 ir_expression *const r0D6A = expr(ir_unop_i2u, r0D69);
                                 body.emit(assign(r0D53, bit_or(r0D53, r0D6A), 0x01));


                              body.instructions = f0D58_parent_instructions;
                              body.emit(f0D58);

                              /* END IF */

                              body.emit(assign(r0D2D, r0D55, 0x01));

                              body.emit(assign(r0D2E, r0D54, 0x01));

                              body.emit(assign(r0D2F, r0D53, 0x01));


                           body.instructions = f0D47_parent_instructions;
                           body.emit(f0D47);

                           /* END IF */

                           body.emit(assign(r0D2C, sub(r0D2C, r0D30), 0x01));

                           ir_variable *const r0D6B = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D6B, r0D2C, 0x01));

                           ir_variable *const r0D6C = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D6C, r0D2D, 0x01));

                           ir_variable *const r0D6D = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D6D, r0D2E, 0x01));

                           ir_variable *const r0D6E = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r0D6E, r0D2F, 0x01));

                           ir_variable *const r0D6F = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r0D6F, body.constant(true), 0x01));

                           ir_variable *const r0D70 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r0D71 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r0D71);
                           ir_expression *const r0D72 = expr(ir_unop_u2i, r0D2F);
                           body.emit(assign(r0D71, less(r0D72, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D74 = lequal(body.constant(int(2045)), r0D2C);
                           ir_if *f0D73 = new(mem_ctx) ir_if(operand(r0D74).val);
                           exec_list *const f0D73_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D73->then_instructions;

                              ir_variable *const r0D75 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D77 = less(body.constant(int(2045)), r0D2C);
                              ir_if *f0D76 = new(mem_ctx) ir_if(operand(r0D77).val);
                              exec_list *const f0D76_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D76->then_instructions;

                                 body.emit(assign(r0D75, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D76->else_instructions;

                                 ir_variable *const r0D78 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0D7A = equal(r0D2C, body.constant(int(2045)));
                                 ir_if *f0D79 = new(mem_ctx) ir_if(operand(r0D7A).val);
                                 exec_list *const f0D79_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D79->then_instructions;

                                    ir_expression *const r0D7B = equal(body.constant(2097151u), r0D2D);
                                    ir_expression *const r0D7C = equal(body.constant(4294967295u), r0D2E);
                                    body.emit(assign(r0D78, logic_and(r0D7B, r0D7C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D79->else_instructions;

                                    body.emit(assign(r0D78, body.constant(false), 0x01));


                                 body.instructions = f0D79_parent_instructions;
                                 body.emit(f0D79);

                                 /* END IF */

                                 body.emit(assign(r0D75, logic_and(r0D78, r0D71), 0x01));


                              body.instructions = f0D76_parent_instructions;
                              body.emit(f0D76);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f0D7D = new(mem_ctx) ir_if(operand(r0D75).val);
                              exec_list *const f0D7D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D7D->then_instructions;

                                 ir_variable *const r0D7E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r0D7E);
                                 ir_expression *const r0D7F = lshift(r0999, body.constant(int(31)));
                                 body.emit(assign(r0D7E, add(r0D7F, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r0D7E, body.constant(0u), 0x01));

                                 body.emit(assign(r0D70, r0D7E, 0x03));

                                 body.emit(assign(r0D6F, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D7D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D81 = less(r0D2C, body.constant(int(0)));
                                 ir_if *f0D80 = new(mem_ctx) ir_if(operand(r0D81).val);
                                 exec_list *const f0D80_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D80->then_instructions;

                                    ir_variable *const r0D82 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r0D82, r0D2F, 0x01));

                                    ir_variable *const r0D83 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r0D83, neg(r0D2C), 0x01));

                                    ir_variable *const r0D84 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r0D84);
                                    ir_variable *const r0D85 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r0D85);
                                    ir_variable *const r0D86 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r0D86);
                                    ir_variable *const r0D87 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r0D88 = neg(r0D83);
                                    body.emit(assign(r0D87, bit_and(r0D88, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0D8A = equal(r0D83, body.constant(int(0)));
                                    ir_if *f0D89 = new(mem_ctx) ir_if(operand(r0D8A).val);
                                    exec_list *const f0D89_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D89->then_instructions;

                                       body.emit(assign(r0D84, r0D2F, 0x01));

                                       body.emit(assign(r0D85, r0D2E, 0x01));

                                       body.emit(assign(r0D86, r0D2D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D89->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D8C = less(r0D83, body.constant(int(32)));
                                       ir_if *f0D8B = new(mem_ctx) ir_if(operand(r0D8C).val);
                                       exec_list *const f0D8B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D8B->then_instructions;

                                          body.emit(assign(r0D84, lshift(r0D2E, r0D87), 0x01));

                                          ir_expression *const r0D8D = lshift(r0D2D, r0D87);
                                          ir_expression *const r0D8E = rshift(r0D2E, r0D83);
                                          body.emit(assign(r0D85, bit_or(r0D8D, r0D8E), 0x01));

                                          body.emit(assign(r0D86, rshift(r0D2D, r0D83), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D8B->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r0D90 = equal(r0D83, body.constant(int(32)));
                                          ir_if *f0D8F = new(mem_ctx) ir_if(operand(r0D90).val);
                                          exec_list *const f0D8F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D8F->then_instructions;

                                             body.emit(assign(r0D84, r0D2E, 0x01));

                                             body.emit(assign(r0D85, r0D2D, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D8F->else_instructions;

                                             body.emit(assign(r0D82, bit_or(r0D2F, r0D2E), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r0D92 = less(r0D83, body.constant(int(64)));
                                             ir_if *f0D91 = new(mem_ctx) ir_if(operand(r0D92).val);
                                             exec_list *const f0D91_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D91->then_instructions;

                                                body.emit(assign(r0D84, lshift(r0D2D, r0D87), 0x01));

                                                ir_expression *const r0D93 = bit_and(r0D83, body.constant(int(31)));
                                                body.emit(assign(r0D85, rshift(r0D2D, r0D93), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D91->else_instructions;

                                                ir_variable *const r0D94 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r0D96 = equal(r0D83, body.constant(int(64)));
                                                ir_if *f0D95 = new(mem_ctx) ir_if(operand(r0D96).val);
                                                exec_list *const f0D95_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f0D95->then_instructions;

                                                   body.emit(assign(r0D94, r0D2D, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f0D95->else_instructions;

                                                   ir_expression *const r0D97 = nequal(r0D2D, body.constant(0u));
                                                   ir_expression *const r0D98 = expr(ir_unop_b2i, r0D97);
                                                   body.emit(assign(r0D94, expr(ir_unop_i2u, r0D98), 0x01));


                                                body.instructions = f0D95_parent_instructions;
                                                body.emit(f0D95);

                                                /* END IF */

                                                body.emit(assign(r0D84, r0D94, 0x01));

                                                body.emit(assign(r0D85, body.constant(0u), 0x01));


                                             body.instructions = f0D91_parent_instructions;
                                             body.emit(f0D91);

                                             /* END IF */


                                          body.instructions = f0D8F_parent_instructions;
                                          body.emit(f0D8F);

                                          /* END IF */

                                          body.emit(assign(r0D86, body.constant(0u), 0x01));


                                       body.instructions = f0D8B_parent_instructions;
                                       body.emit(f0D8B);

                                       /* END IF */

                                       ir_expression *const r0D99 = nequal(r0D82, body.constant(0u));
                                       ir_expression *const r0D9A = expr(ir_unop_b2i, r0D99);
                                       ir_expression *const r0D9B = expr(ir_unop_i2u, r0D9A);
                                       body.emit(assign(r0D84, bit_or(r0D84, r0D9B), 0x01));


                                    body.instructions = f0D89_parent_instructions;
                                    body.emit(f0D89);

                                    /* END IF */

                                    body.emit(assign(r0D6C, r0D86, 0x01));

                                    body.emit(assign(r0D6D, r0D85, 0x01));

                                    body.emit(assign(r0D6E, r0D84, 0x01));

                                    body.emit(assign(r0D6B, body.constant(int(0)), 0x01));

                                    body.emit(assign(r0D71, less(r0D84, body.constant(0u)), 0x01));


                                 body.instructions = f0D80_parent_instructions;
                                 body.emit(f0D80);

                                 /* END IF */


                              body.instructions = f0D7D_parent_instructions;
                              body.emit(f0D7D);

                              /* END IF */


                           body.instructions = f0D73_parent_instructions;
                           body.emit(f0D73);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0D9C = new(mem_ctx) ir_if(operand(r0D6F).val);
                           exec_list *const f0D9C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D9C->then_instructions;

                              /* IF CONDITION */
                              ir_if *f0D9D = new(mem_ctx) ir_if(operand(r0D71).val);
                              exec_list *const f0D9D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D9D->then_instructions;

                                 ir_variable *const r0D9E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r0D9E, add(r0D6D, body.constant(1u)), 0x01));

                                 ir_expression *const r0D9F = less(r0D9E, r0D6D);
                                 ir_expression *const r0DA0 = expr(ir_unop_b2i, r0D9F);
                                 ir_expression *const r0DA1 = expr(ir_unop_i2u, r0DA0);
                                 body.emit(assign(r0D6C, add(r0D6C, r0DA1), 0x01));

                                 ir_expression *const r0DA2 = equal(r0D6E, body.constant(0u));
                                 ir_expression *const r0DA3 = expr(ir_unop_b2i, r0DA2);
                                 ir_expression *const r0DA4 = expr(ir_unop_i2u, r0DA3);
                                 ir_expression *const r0DA5 = add(r0D6E, r0DA4);
                                 ir_expression *const r0DA6 = bit_and(r0DA5, body.constant(1u));
                                 ir_expression *const r0DA7 = expr(ir_unop_bit_not, r0DA6);
                                 body.emit(assign(r0D6D, bit_and(r0D9E, r0DA7), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D9D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0DA9 = bit_or(r0D6C, r0D6D);
                                 ir_expression *const r0DAA = equal(r0DA9, body.constant(0u));
                                 ir_if *f0DA8 = new(mem_ctx) ir_if(operand(r0DAA).val);
                                 exec_list *const f0DA8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0DA8->then_instructions;

                                    body.emit(assign(r0D6B, body.constant(int(0)), 0x01));


                                 body.instructions = f0DA8_parent_instructions;
                                 body.emit(f0DA8);

                                 /* END IF */


                              body.instructions = f0D9D_parent_instructions;
                              body.emit(f0D9D);

                              /* END IF */

                              ir_variable *const r0DAB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0DAB);
                              ir_expression *const r0DAC = lshift(r0999, body.constant(int(31)));
                              ir_expression *const r0DAD = expr(ir_unop_i2u, r0D6B);
                              ir_expression *const r0DAE = lshift(r0DAD, body.constant(int(20)));
                              ir_expression *const r0DAF = add(r0DAC, r0DAE);
                              body.emit(assign(r0DAB, add(r0DAF, r0D6C), 0x02));

                              body.emit(assign(r0DAB, r0D6D, 0x01));

                              body.emit(assign(r0D70, r0DAB, 0x03));

                              body.emit(assign(r0D6F, body.constant(false), 0x01));


                           body.instructions = f0D9C_parent_instructions;
                           body.emit(f0D9C);

                           /* END IF */

                           body.emit(assign(r099A, r0D70, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0D24->else_instructions;

                           ir_variable *const r0DB0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0DB0);
                           body.emit(assign(r0DB0, body.constant(0u), 0x02));

                           body.emit(assign(r0DB0, body.constant(0u), 0x01));

                           body.emit(assign(r099A, r0DB0, 0x03));


                        body.instructions = f0D24_parent_instructions;
                        body.emit(f0D24);

                        /* END IF */


                     body.instructions = f0C98_parent_instructions;
                     body.emit(f0C98);

                     /* END IF */


                  body.instructions = f0C0C_parent_instructions;
                  body.emit(f0C0C);

                  /* END IF */


               body.instructions = f0B80_parent_instructions;
               body.emit(f0B80);

               /* END IF */


            body.instructions = f0B59_parent_instructions;
            body.emit(f0B59);

            /* END IF */


         body.instructions = f0A83_parent_instructions;
         body.emit(f0A83);

         /* END IF */


      body.instructions = f09B1_parent_instructions;
      body.emit(f09B1);

      /* END IF */

      body.emit(assign(r07EB, r099A, 0x03));


   body.instructions = f07EE_parent_instructions;
   body.emit(f07EE);

   /* END IF */

   body.emit(ret(r07EB));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0DB1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0DB1);
   ir_variable *const r0DB2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0DB2);
   ir_variable *const r0DB3 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0DB4 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r0DB4, rshift(swizzle_y(r0DB1), body.constant(int(31))), 0x01));

   ir_variable *const r0DB5 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r0DB5, rshift(swizzle_y(r0DB2), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0DB7 = equal(r0DB4, r0DB5);
   ir_if *f0DB6 = new(mem_ctx) ir_if(operand(r0DB7).val);
   exec_list *const f0DB6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0DB6->then_instructions;

      ir_variable *const r0DB8 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0DB8, r0DB4, 0x01));

      ir_variable *const r0DB9 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r0DBA = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r0DBA);
      ir_variable *const r0DBB = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r0DBB);
      ir_variable *const r0DBC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r0DBC);
      ir_variable *const r0DBD = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r0DBD);
      ir_variable *const r0DBE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r0DBE);
      ir_variable *const r0DBF = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r0DBF);
      ir_variable *const r0DC0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r0DC0);
      body.emit(assign(r0DC0, bit_and(swizzle_y(r0DB1), body.constant(1048575u)), 0x02));

      body.emit(assign(r0DC0, swizzle_x(r0DB1), 0x01));

      ir_variable *const r0DC1 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0DC2 = rshift(swizzle_y(r0DB1), body.constant(int(20)));
      ir_expression *const r0DC3 = bit_and(r0DC2, body.constant(2047u));
      body.emit(assign(r0DC1, expr(ir_unop_u2i, r0DC3), 0x01));

      body.emit(assign(r0DBD, r0DC1, 0x01));

      ir_variable *const r0DC4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r0DC4);
      body.emit(assign(r0DC4, bit_and(swizzle_y(r0DB2), body.constant(1048575u)), 0x02));

      body.emit(assign(r0DC4, swizzle_x(r0DB2), 0x01));

      ir_variable *const r0DC5 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0DC6 = rshift(swizzle_y(r0DB2), body.constant(int(20)));
      ir_expression *const r0DC7 = bit_and(r0DC6, body.constant(2047u));
      body.emit(assign(r0DC5, expr(ir_unop_u2i, r0DC7), 0x01));

      body.emit(assign(r0DBB, r0DC5, 0x01));

      body.emit(assign(r0DBA, sub(r0DC1, r0DC5), 0x01));

      ir_variable *const r0DC8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0DC8, lshift(swizzle_x(r0DB1), body.constant(int(10))), 0x01));

      ir_variable *const r0DC9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r0DCA = lshift(swizzle_y(r0DC0), body.constant(int(10)));
      ir_expression *const r0DCB = rshift(swizzle_x(r0DB1), body.constant(int(22)));
      body.emit(assign(r0DC9, bit_or(r0DCA, r0DCB), 0x01));

      body.emit(assign(r0DBE, r0DC9, 0x02));

      body.emit(assign(r0DBE, r0DC8, 0x01));

      ir_variable *const r0DCC = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0DCC, lshift(swizzle_x(r0DB2), body.constant(int(10))), 0x01));

      ir_variable *const r0DCD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r0DCE = lshift(swizzle_y(r0DC4), body.constant(int(10)));
      ir_expression *const r0DCF = rshift(swizzle_x(r0DB2), body.constant(int(22)));
      body.emit(assign(r0DCD, bit_or(r0DCE, r0DCF), 0x01));

      body.emit(assign(r0DBC, r0DCD, 0x02));

      body.emit(assign(r0DBC, r0DCC, 0x01));

      /* IF CONDITION */
      ir_expression *const r0DD1 = less(body.constant(int(0)), r0DBA);
      ir_if *f0DD0 = new(mem_ctx) ir_if(operand(r0DD1).val);
      exec_list *const f0DD0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0DD0->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0DD3 = equal(r0DC1, body.constant(int(2047)));
         ir_if *f0DD2 = new(mem_ctx) ir_if(operand(r0DD3).val);
         exec_list *const f0DD2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0DD2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0DD5 = bit_or(r0DC9, r0DC8);
            ir_expression *const r0DD6 = nequal(r0DD5, body.constant(0u));
            ir_if *f0DD4 = new(mem_ctx) ir_if(operand(r0DD6).val);
            exec_list *const f0DD4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DD4->then_instructions;

               ir_variable *const r0DD7 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0DD7, swizzle_x(r0DB1), 0x01));

               ir_variable *const r0DD8 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0DD8, swizzle_x(r0DB2), 0x01));

               ir_variable *const r0DD9 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0DDA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0DDB = rshift(swizzle_y(r0DB1), body.constant(int(19)));
               ir_expression *const r0DDC = bit_and(r0DDB, body.constant(4095u));
               ir_expression *const r0DDD = equal(r0DDC, body.constant(4094u));
               ir_expression *const r0DDE = nequal(swizzle_x(r0DB1), body.constant(0u));
               ir_expression *const r0DDF = bit_and(swizzle_y(r0DB1), body.constant(524287u));
               ir_expression *const r0DE0 = nequal(r0DDF, body.constant(0u));
               ir_expression *const r0DE1 = logic_or(r0DDE, r0DE0);
               body.emit(assign(r0DDA, logic_and(r0DDD, r0DE1), 0x01));

               ir_variable *const r0DE2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0DE3 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
               ir_expression *const r0DE4 = lequal(body.constant(4292870144u), r0DE3);
               ir_expression *const r0DE5 = nequal(swizzle_x(r0DB2), body.constant(0u));
               ir_expression *const r0DE6 = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
               ir_expression *const r0DE7 = nequal(r0DE6, body.constant(0u));
               ir_expression *const r0DE8 = logic_or(r0DE5, r0DE7);
               body.emit(assign(r0DE2, logic_and(r0DE4, r0DE8), 0x01));

               body.emit(assign(r0DD7, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

               body.emit(assign(r0DD8, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0DEA = lshift(swizzle_y(r0DB1), body.constant(int(1)));
               ir_expression *const r0DEB = lequal(body.constant(4292870144u), r0DEA);
               ir_expression *const r0DEC = nequal(swizzle_x(r0DB1), body.constant(0u));
               ir_expression *const r0DED = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
               ir_expression *const r0DEE = nequal(r0DED, body.constant(0u));
               ir_expression *const r0DEF = logic_or(r0DEC, r0DEE);
               ir_expression *const r0DF0 = logic_and(r0DEB, r0DEF);
               ir_if *f0DE9 = new(mem_ctx) ir_if(operand(r0DF0).val);
               exec_list *const f0DE9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0DE9->then_instructions;

                  ir_variable *const r0DF1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0DF3 = logic_and(r0DDA, r0DE2);
                  ir_if *f0DF2 = new(mem_ctx) ir_if(operand(r0DF3).val);
                  exec_list *const f0DF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0DF2->then_instructions;

                     body.emit(assign(r0DF1, r0DD8, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0DF2->else_instructions;

                     body.emit(assign(r0DF1, r0DD7, 0x03));


                  body.instructions = f0DF2_parent_instructions;
                  body.emit(f0DF2);

                  /* END IF */

                  body.emit(assign(r0DD9, r0DF1, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0DE9->else_instructions;

                  body.emit(assign(r0DD9, r0DD8, 0x03));


               body.instructions = f0DE9_parent_instructions;
               body.emit(f0DE9);

               /* END IF */

               body.emit(assign(r0DB9, r0DD9, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DD4->else_instructions;

               body.emit(assign(r0DB9, r0DB1, 0x03));


            body.instructions = f0DD4_parent_instructions;
            body.emit(f0DD4);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0DD2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0DF5 = equal(r0DC5, body.constant(int(0)));
            ir_if *f0DF4 = new(mem_ctx) ir_if(operand(r0DF5).val);
            exec_list *const f0DF4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DF4->then_instructions;

               body.emit(assign(r0DBA, add(r0DBA, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DF4->else_instructions;

               body.emit(assign(r0DBC, bit_or(r0DCD, body.constant(1073741824u)), 0x02));


            body.instructions = f0DF4_parent_instructions;
            body.emit(f0DF4);

            /* END IF */

            ir_variable *const r0DF6 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r0DF6, swizzle_y(r0DBC), 0x01));

            ir_variable *const r0DF7 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r0DF7, swizzle_x(r0DBC), 0x01));

            ir_variable *const r0DF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0DF8);
            ir_variable *const r0DF9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0DF9);
            ir_variable *const r0DFA = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0DFB = neg(r0DBA);
            body.emit(assign(r0DFA, bit_and(r0DFB, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0DFD = equal(r0DBA, body.constant(int(0)));
            ir_if *f0DFC = new(mem_ctx) ir_if(operand(r0DFD).val);
            exec_list *const f0DFC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DFC->then_instructions;

               body.emit(assign(r0DF8, r0DF7, 0x01));

               body.emit(assign(r0DF9, r0DF6, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DFC->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0DFF = less(r0DBA, body.constant(int(32)));
               ir_if *f0DFE = new(mem_ctx) ir_if(operand(r0DFF).val);
               exec_list *const f0DFE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0DFE->then_instructions;

                  ir_expression *const r0E00 = lshift(swizzle_y(r0DBC), r0DFA);
                  ir_expression *const r0E01 = rshift(r0DCC, r0DBA);
                  ir_expression *const r0E02 = bit_or(r0E00, r0E01);
                  ir_expression *const r0E03 = lshift(r0DCC, r0DFA);
                  ir_expression *const r0E04 = nequal(r0E03, body.constant(0u));
                  ir_expression *const r0E05 = expr(ir_unop_b2i, r0E04);
                  ir_expression *const r0E06 = expr(ir_unop_i2u, r0E05);
                  body.emit(assign(r0DF8, bit_or(r0E02, r0E06), 0x01));

                  body.emit(assign(r0DF9, rshift(swizzle_y(r0DBC), r0DBA), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0DFE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E08 = equal(r0DBA, body.constant(int(32)));
                  ir_if *f0E07 = new(mem_ctx) ir_if(operand(r0E08).val);
                  exec_list *const f0E07_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E07->then_instructions;

                     ir_expression *const r0E09 = nequal(r0DCC, body.constant(0u));
                     ir_expression *const r0E0A = expr(ir_unop_b2i, r0E09);
                     ir_expression *const r0E0B = expr(ir_unop_i2u, r0E0A);
                     body.emit(assign(r0DF8, bit_or(swizzle_y(r0DBC), r0E0B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E07->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0E0D = less(r0DBA, body.constant(int(64)));
                     ir_if *f0E0C = new(mem_ctx) ir_if(operand(r0E0D).val);
                     exec_list *const f0E0C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E0C->then_instructions;

                        ir_expression *const r0E0E = bit_and(r0DBA, body.constant(int(31)));
                        ir_expression *const r0E0F = rshift(swizzle_y(r0DBC), r0E0E);
                        ir_expression *const r0E10 = lshift(swizzle_y(r0DBC), r0DFA);
                        ir_expression *const r0E11 = bit_or(r0E10, r0DCC);
                        ir_expression *const r0E12 = nequal(r0E11, body.constant(0u));
                        ir_expression *const r0E13 = expr(ir_unop_b2i, r0E12);
                        ir_expression *const r0E14 = expr(ir_unop_i2u, r0E13);
                        body.emit(assign(r0DF8, bit_or(r0E0F, r0E14), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E0C->else_instructions;

                        ir_expression *const r0E15 = bit_or(swizzle_y(r0DBC), r0DCC);
                        ir_expression *const r0E16 = nequal(r0E15, body.constant(0u));
                        ir_expression *const r0E17 = expr(ir_unop_b2i, r0E16);
                        body.emit(assign(r0DF8, expr(ir_unop_i2u, r0E17), 0x01));


                     body.instructions = f0E0C_parent_instructions;
                     body.emit(f0E0C);

                     /* END IF */


                  body.instructions = f0E07_parent_instructions;
                  body.emit(f0E07);

                  /* END IF */

                  body.emit(assign(r0DF9, body.constant(0u), 0x01));


               body.instructions = f0DFE_parent_instructions;
               body.emit(f0DFE);

               /* END IF */


            body.instructions = f0DFC_parent_instructions;
            body.emit(f0DFC);

            /* END IF */

            body.emit(assign(r0DBC, r0DF9, 0x02));

            body.emit(assign(r0DBC, r0DF8, 0x01));

            body.emit(assign(r0DBE, bit_or(r0DC9, body.constant(1073741824u)), 0x02));

            ir_variable *const r0E18 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0E19 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0E19, sub(r0DC8, r0DF8), 0x01));

            ir_expression *const r0E1A = sub(swizzle_y(r0DBE), r0DF9);
            ir_expression *const r0E1B = less(r0DC8, r0DF8);
            ir_expression *const r0E1C = expr(ir_unop_b2i, r0E1B);
            ir_expression *const r0E1D = expr(ir_unop_i2u, r0E1C);
            body.emit(assign(r0E18, sub(r0E1A, r0E1D), 0x01));

            body.emit(assign(r0DBF, add(r0DC1, body.constant(int(-1))), 0x01));

            ir_variable *const r0E1E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0E1E, add(r0DBF, body.constant(int(-10))), 0x01));

            ir_variable *const r0E1F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0E1F, r0E18, 0x01));

            ir_variable *const r0E20 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0E20, r0E19, 0x01));

            ir_variable *const r0E21 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0E21);
            ir_variable *const r0E22 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0E22);
            /* IF CONDITION */
            ir_expression *const r0E24 = equal(r0E18, body.constant(0u));
            ir_if *f0E23 = new(mem_ctx) ir_if(operand(r0E24).val);
            exec_list *const f0E23_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E23->then_instructions;

               body.emit(assign(r0E1F, r0E19, 0x01));

               body.emit(assign(r0E20, body.constant(0u), 0x01));

               body.emit(assign(r0E1E, add(r0E1E, body.constant(int(-32))), 0x01));


            body.instructions = f0E23_parent_instructions;
            body.emit(f0E23);

            /* END IF */

            ir_variable *const r0E25 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0E25, r0E1F, 0x01));

            ir_variable *const r0E26 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0E27 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0E27);
            /* IF CONDITION */
            ir_expression *const r0E29 = equal(r0E1F, body.constant(0u));
            ir_if *f0E28 = new(mem_ctx) ir_if(operand(r0E29).val);
            exec_list *const f0E28_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E28->then_instructions;

               body.emit(assign(r0E26, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0E28->else_instructions;

               body.emit(assign(r0E27, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0E2B = bit_and(r0E1F, body.constant(4294901760u));
               ir_expression *const r0E2C = equal(r0E2B, body.constant(0u));
               ir_if *f0E2A = new(mem_ctx) ir_if(operand(r0E2C).val);
               exec_list *const f0E2A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E2A->then_instructions;

                  body.emit(assign(r0E27, body.constant(int(16)), 0x01));

                  body.emit(assign(r0E25, lshift(r0E1F, body.constant(int(16))), 0x01));


               body.instructions = f0E2A_parent_instructions;
               body.emit(f0E2A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E2E = bit_and(r0E25, body.constant(4278190080u));
               ir_expression *const r0E2F = equal(r0E2E, body.constant(0u));
               ir_if *f0E2D = new(mem_ctx) ir_if(operand(r0E2F).val);
               exec_list *const f0E2D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E2D->then_instructions;

                  body.emit(assign(r0E27, add(r0E27, body.constant(int(8))), 0x01));

                  body.emit(assign(r0E25, lshift(r0E25, body.constant(int(8))), 0x01));


               body.instructions = f0E2D_parent_instructions;
               body.emit(f0E2D);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E31 = bit_and(r0E25, body.constant(4026531840u));
               ir_expression *const r0E32 = equal(r0E31, body.constant(0u));
               ir_if *f0E30 = new(mem_ctx) ir_if(operand(r0E32).val);
               exec_list *const f0E30_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E30->then_instructions;

                  body.emit(assign(r0E27, add(r0E27, body.constant(int(4))), 0x01));

                  body.emit(assign(r0E25, lshift(r0E25, body.constant(int(4))), 0x01));


               body.instructions = f0E30_parent_instructions;
               body.emit(f0E30);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E34 = bit_and(r0E25, body.constant(3221225472u));
               ir_expression *const r0E35 = equal(r0E34, body.constant(0u));
               ir_if *f0E33 = new(mem_ctx) ir_if(operand(r0E35).val);
               exec_list *const f0E33_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E33->then_instructions;

                  body.emit(assign(r0E27, add(r0E27, body.constant(int(2))), 0x01));

                  body.emit(assign(r0E25, lshift(r0E25, body.constant(int(2))), 0x01));


               body.instructions = f0E33_parent_instructions;
               body.emit(f0E33);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E37 = bit_and(r0E25, body.constant(2147483648u));
               ir_expression *const r0E38 = equal(r0E37, body.constant(0u));
               ir_if *f0E36 = new(mem_ctx) ir_if(operand(r0E38).val);
               exec_list *const f0E36_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E36->then_instructions;

                  body.emit(assign(r0E27, add(r0E27, body.constant(int(1))), 0x01));


               body.instructions = f0E36_parent_instructions;
               body.emit(f0E36);

               /* END IF */

               body.emit(assign(r0E26, r0E27, 0x01));


            body.instructions = f0E28_parent_instructions;
            body.emit(f0E28);

            /* END IF */

            body.emit(assign(r0E22, add(r0E26, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0E3A = lequal(body.constant(int(0)), r0E22);
            ir_if *f0E39 = new(mem_ctx) ir_if(operand(r0E3A).val);
            exec_list *const f0E39_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E39->then_instructions;

               body.emit(assign(r0E21, body.constant(0u), 0x01));

               ir_variable *const r0E3B = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0E3B, lshift(r0E20, r0E22), 0x01));

               ir_variable *const r0E3C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0E3E = equal(r0E22, body.constant(int(0)));
               ir_if *f0E3D = new(mem_ctx) ir_if(operand(r0E3E).val);
               exec_list *const f0E3D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E3D->then_instructions;

                  body.emit(assign(r0E3C, r0E1F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E3D->else_instructions;

                  ir_expression *const r0E3F = lshift(r0E1F, r0E22);
                  ir_expression *const r0E40 = neg(r0E22);
                  ir_expression *const r0E41 = bit_and(r0E40, body.constant(int(31)));
                  ir_expression *const r0E42 = rshift(r0E20, r0E41);
                  body.emit(assign(r0E3C, bit_or(r0E3F, r0E42), 0x01));


               body.instructions = f0E3D_parent_instructions;
               body.emit(f0E3D);

               /* END IF */

               body.emit(assign(r0E1F, r0E3C, 0x01));

               body.emit(assign(r0E20, r0E3B, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0E39->else_instructions;

               ir_variable *const r0E43 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0E43, body.constant(0u), 0x01));

               ir_variable *const r0E44 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0E44, neg(r0E22), 0x01));

               ir_variable *const r0E45 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0E45);
               ir_variable *const r0E46 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0E46);
               ir_variable *const r0E47 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0E47);
               ir_variable *const r0E48 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0E49 = neg(r0E44);
               body.emit(assign(r0E48, bit_and(r0E49, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0E4B = equal(r0E44, body.constant(int(0)));
               ir_if *f0E4A = new(mem_ctx) ir_if(operand(r0E4B).val);
               exec_list *const f0E4A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E4A->then_instructions;

                  body.emit(assign(r0E45, r0E43, 0x01));

                  body.emit(assign(r0E46, r0E20, 0x01));

                  body.emit(assign(r0E47, r0E1F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E4A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E4D = less(r0E44, body.constant(int(32)));
                  ir_if *f0E4C = new(mem_ctx) ir_if(operand(r0E4D).val);
                  exec_list *const f0E4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E4C->then_instructions;

                     body.emit(assign(r0E45, lshift(r0E20, r0E48), 0x01));

                     ir_expression *const r0E4E = lshift(r0E1F, r0E48);
                     ir_expression *const r0E4F = rshift(r0E20, r0E44);
                     body.emit(assign(r0E46, bit_or(r0E4E, r0E4F), 0x01));

                     body.emit(assign(r0E47, rshift(r0E1F, r0E44), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E4C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0E51 = equal(r0E44, body.constant(int(32)));
                     ir_if *f0E50 = new(mem_ctx) ir_if(operand(r0E51).val);
                     exec_list *const f0E50_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E50->then_instructions;

                        body.emit(assign(r0E45, r0E20, 0x01));

                        body.emit(assign(r0E46, r0E1F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E50->else_instructions;

                        body.emit(assign(r0E43, bit_or(body.constant(0u), r0E20), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0E53 = less(r0E44, body.constant(int(64)));
                        ir_if *f0E52 = new(mem_ctx) ir_if(operand(r0E53).val);
                        exec_list *const f0E52_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0E52->then_instructions;

                           body.emit(assign(r0E45, lshift(r0E1F, r0E48), 0x01));

                           ir_expression *const r0E54 = bit_and(r0E44, body.constant(int(31)));
                           body.emit(assign(r0E46, rshift(r0E1F, r0E54), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0E52->else_instructions;

                           ir_variable *const r0E55 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0E57 = equal(r0E44, body.constant(int(64)));
                           ir_if *f0E56 = new(mem_ctx) ir_if(operand(r0E57).val);
                           exec_list *const f0E56_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0E56->then_instructions;

                              body.emit(assign(r0E55, r0E1F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0E56->else_instructions;

                              ir_expression *const r0E58 = nequal(r0E1F, body.constant(0u));
                              ir_expression *const r0E59 = expr(ir_unop_b2i, r0E58);
                              body.emit(assign(r0E55, expr(ir_unop_i2u, r0E59), 0x01));


                           body.instructions = f0E56_parent_instructions;
                           body.emit(f0E56);

                           /* END IF */

                           body.emit(assign(r0E45, r0E55, 0x01));

                           body.emit(assign(r0E46, body.constant(0u), 0x01));


                        body.instructions = f0E52_parent_instructions;
                        body.emit(f0E52);

                        /* END IF */


                     body.instructions = f0E50_parent_instructions;
                     body.emit(f0E50);

                     /* END IF */

                     body.emit(assign(r0E47, body.constant(0u), 0x01));


                  body.instructions = f0E4C_parent_instructions;
                  body.emit(f0E4C);

                  /* END IF */

                  ir_expression *const r0E5A = nequal(r0E43, body.constant(0u));
                  ir_expression *const r0E5B = expr(ir_unop_b2i, r0E5A);
                  ir_expression *const r0E5C = expr(ir_unop_i2u, r0E5B);
                  body.emit(assign(r0E45, bit_or(r0E45, r0E5C), 0x01));


               body.instructions = f0E4A_parent_instructions;
               body.emit(f0E4A);

               /* END IF */

               body.emit(assign(r0E1F, r0E47, 0x01));

               body.emit(assign(r0E20, r0E46, 0x01));

               body.emit(assign(r0E21, r0E45, 0x01));


            body.instructions = f0E39_parent_instructions;
            body.emit(f0E39);

            /* END IF */

            body.emit(assign(r0E1E, sub(r0E1E, r0E22), 0x01));

            ir_variable *const r0E5D = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0E5D, r0E1E, 0x01));

            ir_variable *const r0E5E = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0E5E, r0E1F, 0x01));

            ir_variable *const r0E5F = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0E5F, r0E20, 0x01));

            ir_variable *const r0E60 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0E60, r0E21, 0x01));

            ir_variable *const r0E61 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0E61, body.constant(true), 0x01));

            ir_variable *const r0E62 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0E63 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0E63);
            ir_expression *const r0E64 = expr(ir_unop_u2i, r0E21);
            body.emit(assign(r0E63, less(r0E64, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0E66 = lequal(body.constant(int(2045)), r0E1E);
            ir_if *f0E65 = new(mem_ctx) ir_if(operand(r0E66).val);
            exec_list *const f0E65_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E65->then_instructions;

               ir_variable *const r0E67 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0E69 = less(body.constant(int(2045)), r0E1E);
               ir_if *f0E68 = new(mem_ctx) ir_if(operand(r0E69).val);
               exec_list *const f0E68_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E68->then_instructions;

                  body.emit(assign(r0E67, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E68->else_instructions;

                  ir_variable *const r0E6A = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0E6C = equal(r0E1E, body.constant(int(2045)));
                  ir_if *f0E6B = new(mem_ctx) ir_if(operand(r0E6C).val);
                  exec_list *const f0E6B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E6B->then_instructions;

                     ir_expression *const r0E6D = equal(body.constant(2097151u), r0E1F);
                     ir_expression *const r0E6E = equal(body.constant(4294967295u), r0E20);
                     body.emit(assign(r0E6A, logic_and(r0E6D, r0E6E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E6B->else_instructions;

                     body.emit(assign(r0E6A, body.constant(false), 0x01));


                  body.instructions = f0E6B_parent_instructions;
                  body.emit(f0E6B);

                  /* END IF */

                  body.emit(assign(r0E67, logic_and(r0E6A, r0E63), 0x01));


               body.instructions = f0E68_parent_instructions;
               body.emit(f0E68);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0E6F = new(mem_ctx) ir_if(operand(r0E67).val);
               exec_list *const f0E6F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E6F->then_instructions;

                  ir_variable *const r0E70 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0E70);
                  ir_expression *const r0E71 = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r0E70, add(r0E71, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0E70, body.constant(0u), 0x01));

                  body.emit(assign(r0E62, r0E70, 0x03));

                  body.emit(assign(r0E61, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E6F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E73 = less(r0E1E, body.constant(int(0)));
                  ir_if *f0E72 = new(mem_ctx) ir_if(operand(r0E73).val);
                  exec_list *const f0E72_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E72->then_instructions;

                     ir_variable *const r0E74 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0E74, r0E21, 0x01));

                     ir_variable *const r0E75 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0E75, neg(r0E1E), 0x01));

                     ir_variable *const r0E76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0E76);
                     ir_variable *const r0E77 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0E77);
                     ir_variable *const r0E78 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0E78);
                     ir_variable *const r0E79 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0E7A = neg(r0E75);
                     body.emit(assign(r0E79, bit_and(r0E7A, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0E7C = equal(r0E75, body.constant(int(0)));
                     ir_if *f0E7B = new(mem_ctx) ir_if(operand(r0E7C).val);
                     exec_list *const f0E7B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E7B->then_instructions;

                        body.emit(assign(r0E76, r0E21, 0x01));

                        body.emit(assign(r0E77, r0E20, 0x01));

                        body.emit(assign(r0E78, r0E1F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E7B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0E7E = less(r0E75, body.constant(int(32)));
                        ir_if *f0E7D = new(mem_ctx) ir_if(operand(r0E7E).val);
                        exec_list *const f0E7D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0E7D->then_instructions;

                           body.emit(assign(r0E76, lshift(r0E20, r0E79), 0x01));

                           ir_expression *const r0E7F = lshift(r0E1F, r0E79);
                           ir_expression *const r0E80 = rshift(r0E20, r0E75);
                           body.emit(assign(r0E77, bit_or(r0E7F, r0E80), 0x01));

                           body.emit(assign(r0E78, rshift(r0E1F, r0E75), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0E7D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0E82 = equal(r0E75, body.constant(int(32)));
                           ir_if *f0E81 = new(mem_ctx) ir_if(operand(r0E82).val);
                           exec_list *const f0E81_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0E81->then_instructions;

                              body.emit(assign(r0E76, r0E20, 0x01));

                              body.emit(assign(r0E77, r0E1F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0E81->else_instructions;

                              body.emit(assign(r0E74, bit_or(r0E21, r0E20), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0E84 = less(r0E75, body.constant(int(64)));
                              ir_if *f0E83 = new(mem_ctx) ir_if(operand(r0E84).val);
                              exec_list *const f0E83_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0E83->then_instructions;

                                 body.emit(assign(r0E76, lshift(r0E1F, r0E79), 0x01));

                                 ir_expression *const r0E85 = bit_and(r0E75, body.constant(int(31)));
                                 body.emit(assign(r0E77, rshift(r0E1F, r0E85), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0E83->else_instructions;

                                 ir_variable *const r0E86 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0E88 = equal(r0E75, body.constant(int(64)));
                                 ir_if *f0E87 = new(mem_ctx) ir_if(operand(r0E88).val);
                                 exec_list *const f0E87_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0E87->then_instructions;

                                    body.emit(assign(r0E86, r0E1F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0E87->else_instructions;

                                    ir_expression *const r0E89 = nequal(r0E1F, body.constant(0u));
                                    ir_expression *const r0E8A = expr(ir_unop_b2i, r0E89);
                                    body.emit(assign(r0E86, expr(ir_unop_i2u, r0E8A), 0x01));


                                 body.instructions = f0E87_parent_instructions;
                                 body.emit(f0E87);

                                 /* END IF */

                                 body.emit(assign(r0E76, r0E86, 0x01));

                                 body.emit(assign(r0E77, body.constant(0u), 0x01));


                              body.instructions = f0E83_parent_instructions;
                              body.emit(f0E83);

                              /* END IF */


                           body.instructions = f0E81_parent_instructions;
                           body.emit(f0E81);

                           /* END IF */

                           body.emit(assign(r0E78, body.constant(0u), 0x01));


                        body.instructions = f0E7D_parent_instructions;
                        body.emit(f0E7D);

                        /* END IF */

                        ir_expression *const r0E8B = nequal(r0E74, body.constant(0u));
                        ir_expression *const r0E8C = expr(ir_unop_b2i, r0E8B);
                        ir_expression *const r0E8D = expr(ir_unop_i2u, r0E8C);
                        body.emit(assign(r0E76, bit_or(r0E76, r0E8D), 0x01));


                     body.instructions = f0E7B_parent_instructions;
                     body.emit(f0E7B);

                     /* END IF */

                     body.emit(assign(r0E5E, r0E78, 0x01));

                     body.emit(assign(r0E5F, r0E77, 0x01));

                     body.emit(assign(r0E60, r0E76, 0x01));

                     body.emit(assign(r0E5D, body.constant(int(0)), 0x01));

                     body.emit(assign(r0E63, less(r0E76, body.constant(0u)), 0x01));


                  body.instructions = f0E72_parent_instructions;
                  body.emit(f0E72);

                  /* END IF */


               body.instructions = f0E6F_parent_instructions;
               body.emit(f0E6F);

               /* END IF */


            body.instructions = f0E65_parent_instructions;
            body.emit(f0E65);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0E8E = new(mem_ctx) ir_if(operand(r0E61).val);
            exec_list *const f0E8E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E8E->then_instructions;

               /* IF CONDITION */
               ir_if *f0E8F = new(mem_ctx) ir_if(operand(r0E63).val);
               exec_list *const f0E8F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E8F->then_instructions;

                  ir_variable *const r0E90 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0E90, add(r0E5F, body.constant(1u)), 0x01));

                  ir_expression *const r0E91 = less(r0E90, r0E5F);
                  ir_expression *const r0E92 = expr(ir_unop_b2i, r0E91);
                  ir_expression *const r0E93 = expr(ir_unop_i2u, r0E92);
                  body.emit(assign(r0E5E, add(r0E5E, r0E93), 0x01));

                  ir_expression *const r0E94 = equal(r0E60, body.constant(0u));
                  ir_expression *const r0E95 = expr(ir_unop_b2i, r0E94);
                  ir_expression *const r0E96 = expr(ir_unop_i2u, r0E95);
                  ir_expression *const r0E97 = add(r0E60, r0E96);
                  ir_expression *const r0E98 = bit_and(r0E97, body.constant(1u));
                  ir_expression *const r0E99 = expr(ir_unop_bit_not, r0E98);
                  body.emit(assign(r0E5F, bit_and(r0E90, r0E99), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E8F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E9B = bit_or(r0E5E, r0E5F);
                  ir_expression *const r0E9C = equal(r0E9B, body.constant(0u));
                  ir_if *f0E9A = new(mem_ctx) ir_if(operand(r0E9C).val);
                  exec_list *const f0E9A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E9A->then_instructions;

                     body.emit(assign(r0E5D, body.constant(int(0)), 0x01));


                  body.instructions = f0E9A_parent_instructions;
                  body.emit(f0E9A);

                  /* END IF */


               body.instructions = f0E8F_parent_instructions;
               body.emit(f0E8F);

               /* END IF */

               ir_variable *const r0E9D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0E9D);
               ir_expression *const r0E9E = lshift(r0DB4, body.constant(int(31)));
               ir_expression *const r0E9F = expr(ir_unop_i2u, r0E5D);
               ir_expression *const r0EA0 = lshift(r0E9F, body.constant(int(20)));
               ir_expression *const r0EA1 = add(r0E9E, r0EA0);
               body.emit(assign(r0E9D, add(r0EA1, r0E5E), 0x02));

               body.emit(assign(r0E9D, r0E5F, 0x01));

               body.emit(assign(r0E62, r0E9D, 0x03));

               body.emit(assign(r0E61, body.constant(false), 0x01));


            body.instructions = f0E8E_parent_instructions;
            body.emit(f0E8E);

            /* END IF */

            body.emit(assign(r0DB9, r0E62, 0x03));


         body.instructions = f0DD2_parent_instructions;
         body.emit(f0DD2);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0DD0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0EA3 = less(r0DBA, body.constant(int(0)));
         ir_if *f0EA2 = new(mem_ctx) ir_if(operand(r0EA3).val);
         exec_list *const f0EA2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EA2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0EA5 = equal(r0DC5, body.constant(int(2047)));
            ir_if *f0EA4 = new(mem_ctx) ir_if(operand(r0EA5).val);
            exec_list *const f0EA4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EA4->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0EA7 = bit_or(swizzle_y(r0DBC), swizzle_x(r0DBC));
               ir_expression *const r0EA8 = nequal(r0EA7, body.constant(0u));
               ir_if *f0EA6 = new(mem_ctx) ir_if(operand(r0EA8).val);
               exec_list *const f0EA6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EA6->then_instructions;

                  ir_variable *const r0EA9 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0EA9, swizzle_x(r0DB1), 0x01));

                  ir_variable *const r0EAA = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0EAA, swizzle_x(r0DB2), 0x01));

                  ir_variable *const r0EAB = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0EAC = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0EAD = rshift(swizzle_y(r0DB1), body.constant(int(19)));
                  ir_expression *const r0EAE = bit_and(r0EAD, body.constant(4095u));
                  ir_expression *const r0EAF = equal(r0EAE, body.constant(4094u));
                  ir_expression *const r0EB0 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r0EB1 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
                  ir_expression *const r0EB2 = nequal(r0EB1, body.constant(0u));
                  ir_expression *const r0EB3 = logic_or(r0EB0, r0EB2);
                  body.emit(assign(r0EAC, logic_and(r0EAF, r0EB3), 0x01));

                  ir_variable *const r0EB4 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0EB5 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
                  ir_expression *const r0EB6 = lequal(body.constant(4292870144u), r0EB5);
                  ir_expression *const r0EB7 = nequal(swizzle_x(r0DB2), body.constant(0u));
                  ir_expression *const r0EB8 = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
                  ir_expression *const r0EB9 = nequal(r0EB8, body.constant(0u));
                  ir_expression *const r0EBA = logic_or(r0EB7, r0EB9);
                  body.emit(assign(r0EB4, logic_and(r0EB6, r0EBA), 0x01));

                  body.emit(assign(r0EA9, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

                  body.emit(assign(r0EAA, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0EBC = lshift(swizzle_y(r0DB1), body.constant(int(1)));
                  ir_expression *const r0EBD = lequal(body.constant(4292870144u), r0EBC);
                  ir_expression *const r0EBE = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r0EBF = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
                  ir_expression *const r0EC0 = nequal(r0EBF, body.constant(0u));
                  ir_expression *const r0EC1 = logic_or(r0EBE, r0EC0);
                  ir_expression *const r0EC2 = logic_and(r0EBD, r0EC1);
                  ir_if *f0EBB = new(mem_ctx) ir_if(operand(r0EC2).val);
                  exec_list *const f0EBB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EBB->then_instructions;

                     ir_variable *const r0EC3 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0EC5 = logic_and(r0EAC, r0EB4);
                     ir_if *f0EC4 = new(mem_ctx) ir_if(operand(r0EC5).val);
                     exec_list *const f0EC4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EC4->then_instructions;

                        body.emit(assign(r0EC3, r0EAA, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0EC4->else_instructions;

                        body.emit(assign(r0EC3, r0EA9, 0x03));


                     body.instructions = f0EC4_parent_instructions;
                     body.emit(f0EC4);

                     /* END IF */

                     body.emit(assign(r0EAB, r0EC3, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0EBB->else_instructions;

                     body.emit(assign(r0EAB, r0EAA, 0x03));


                  body.instructions = f0EBB_parent_instructions;
                  body.emit(f0EBB);

                  /* END IF */

                  body.emit(assign(r0DB9, r0EAB, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EA6->else_instructions;

                  ir_variable *const r0EC6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0EC6);
                  ir_expression *const r0EC7 = bit_xor(r0DB4, body.constant(1u));
                  ir_expression *const r0EC8 = lshift(r0EC7, body.constant(int(31)));
                  body.emit(assign(r0EC6, add(r0EC8, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0EC6, body.constant(0u), 0x01));

                  body.emit(assign(r0DB9, r0EC6, 0x03));


               body.instructions = f0EA6_parent_instructions;
               body.emit(f0EA6);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EA4->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0ECA = equal(r0DC1, body.constant(int(0)));
               ir_if *f0EC9 = new(mem_ctx) ir_if(operand(r0ECA).val);
               exec_list *const f0EC9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EC9->then_instructions;

                  body.emit(assign(r0DBA, add(r0DBA, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EC9->else_instructions;

                  body.emit(assign(r0DBE, bit_or(swizzle_y(r0DBE), body.constant(1073741824u)), 0x02));


               body.instructions = f0EC9_parent_instructions;
               body.emit(f0EC9);

               /* END IF */

               ir_variable *const r0ECB = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r0ECB, swizzle_y(r0DBE), 0x01));

               ir_variable *const r0ECC = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r0ECC, swizzle_x(r0DBE), 0x01));

               ir_variable *const r0ECD = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0ECD, neg(r0DBA), 0x01));

               ir_variable *const r0ECE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0ECE);
               ir_variable *const r0ECF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0ECF);
               ir_variable *const r0ED0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0ED1 = neg(r0ECD);
               body.emit(assign(r0ED0, bit_and(r0ED1, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0ED3 = equal(r0ECD, body.constant(int(0)));
               ir_if *f0ED2 = new(mem_ctx) ir_if(operand(r0ED3).val);
               exec_list *const f0ED2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ED2->then_instructions;

                  body.emit(assign(r0ECE, r0ECC, 0x01));

                  body.emit(assign(r0ECF, r0ECB, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ED2->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0ED5 = less(r0ECD, body.constant(int(32)));
                  ir_if *f0ED4 = new(mem_ctx) ir_if(operand(r0ED5).val);
                  exec_list *const f0ED4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0ED4->then_instructions;

                     ir_expression *const r0ED6 = lshift(swizzle_y(r0DBE), r0ED0);
                     ir_expression *const r0ED7 = rshift(r0DC8, r0ECD);
                     ir_expression *const r0ED8 = bit_or(r0ED6, r0ED7);
                     ir_expression *const r0ED9 = lshift(r0DC8, r0ED0);
                     ir_expression *const r0EDA = nequal(r0ED9, body.constant(0u));
                     ir_expression *const r0EDB = expr(ir_unop_b2i, r0EDA);
                     ir_expression *const r0EDC = expr(ir_unop_i2u, r0EDB);
                     body.emit(assign(r0ECE, bit_or(r0ED8, r0EDC), 0x01));

                     body.emit(assign(r0ECF, rshift(swizzle_y(r0DBE), r0ECD), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0ED4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0EDE = equal(r0ECD, body.constant(int(32)));
                     ir_if *f0EDD = new(mem_ctx) ir_if(operand(r0EDE).val);
                     exec_list *const f0EDD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EDD->then_instructions;

                        ir_expression *const r0EDF = nequal(r0DC8, body.constant(0u));
                        ir_expression *const r0EE0 = expr(ir_unop_b2i, r0EDF);
                        ir_expression *const r0EE1 = expr(ir_unop_i2u, r0EE0);
                        body.emit(assign(r0ECE, bit_or(swizzle_y(r0DBE), r0EE1), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0EDD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0EE3 = less(r0ECD, body.constant(int(64)));
                        ir_if *f0EE2 = new(mem_ctx) ir_if(operand(r0EE3).val);
                        exec_list *const f0EE2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0EE2->then_instructions;

                           ir_expression *const r0EE4 = bit_and(r0ECD, body.constant(int(31)));
                           ir_expression *const r0EE5 = rshift(swizzle_y(r0DBE), r0EE4);
                           ir_expression *const r0EE6 = lshift(swizzle_y(r0DBE), r0ED0);
                           ir_expression *const r0EE7 = bit_or(r0EE6, r0DC8);
                           ir_expression *const r0EE8 = nequal(r0EE7, body.constant(0u));
                           ir_expression *const r0EE9 = expr(ir_unop_b2i, r0EE8);
                           ir_expression *const r0EEA = expr(ir_unop_i2u, r0EE9);
                           body.emit(assign(r0ECE, bit_or(r0EE5, r0EEA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0EE2->else_instructions;

                           ir_expression *const r0EEB = bit_or(swizzle_y(r0DBE), r0DC8);
                           ir_expression *const r0EEC = nequal(r0EEB, body.constant(0u));
                           ir_expression *const r0EED = expr(ir_unop_b2i, r0EEC);
                           body.emit(assign(r0ECE, expr(ir_unop_i2u, r0EED), 0x01));


                        body.instructions = f0EE2_parent_instructions;
                        body.emit(f0EE2);

                        /* END IF */


                     body.instructions = f0EDD_parent_instructions;
                     body.emit(f0EDD);

                     /* END IF */

                     body.emit(assign(r0ECF, body.constant(0u), 0x01));


                  body.instructions = f0ED4_parent_instructions;
                  body.emit(f0ED4);

                  /* END IF */


               body.instructions = f0ED2_parent_instructions;
               body.emit(f0ED2);

               /* END IF */

               body.emit(assign(r0DBE, r0ECF, 0x02));

               body.emit(assign(r0DBE, r0ECE, 0x01));

               body.emit(assign(r0DBC, bit_or(swizzle_y(r0DBC), body.constant(1073741824u)), 0x02));

               ir_variable *const r0EEE = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0EEF = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0EEF, sub(swizzle_x(r0DBC), r0ECE), 0x01));

               ir_expression *const r0EF0 = sub(swizzle_y(r0DBC), r0ECF);
               ir_expression *const r0EF1 = less(swizzle_x(r0DBC), r0ECE);
               ir_expression *const r0EF2 = expr(ir_unop_b2i, r0EF1);
               ir_expression *const r0EF3 = expr(ir_unop_i2u, r0EF2);
               body.emit(assign(r0EEE, sub(r0EF0, r0EF3), 0x01));

               body.emit(assign(r0DB8, bit_xor(r0DB4, body.constant(1u)), 0x01));

               body.emit(assign(r0DBF, add(r0DC5, body.constant(int(-1))), 0x01));

               ir_variable *const r0EF4 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0EF4, add(r0DBF, body.constant(int(-10))), 0x01));

               ir_variable *const r0EF5 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0EF5, r0EEE, 0x01));

               ir_variable *const r0EF6 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0EF6, r0EEF, 0x01));

               ir_variable *const r0EF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0EF7);
               ir_variable *const r0EF8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EF8);
               /* IF CONDITION */
               ir_expression *const r0EFA = equal(r0EEE, body.constant(0u));
               ir_if *f0EF9 = new(mem_ctx) ir_if(operand(r0EFA).val);
               exec_list *const f0EF9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EF9->then_instructions;

                  body.emit(assign(r0EF5, r0EEF, 0x01));

                  body.emit(assign(r0EF6, body.constant(0u), 0x01));

                  body.emit(assign(r0EF4, add(r0EF4, body.constant(int(-32))), 0x01));


               body.instructions = f0EF9_parent_instructions;
               body.emit(f0EF9);

               /* END IF */

               ir_variable *const r0EFB = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0EFB, r0EF5, 0x01));

               ir_variable *const r0EFC = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0EFD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EFD);
               /* IF CONDITION */
               ir_expression *const r0EFF = equal(r0EF5, body.constant(0u));
               ir_if *f0EFE = new(mem_ctx) ir_if(operand(r0EFF).val);
               exec_list *const f0EFE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EFE->then_instructions;

                  body.emit(assign(r0EFC, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EFE->else_instructions;

                  body.emit(assign(r0EFD, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0F01 = bit_and(r0EF5, body.constant(4294901760u));
                  ir_expression *const r0F02 = equal(r0F01, body.constant(0u));
                  ir_if *f0F00 = new(mem_ctx) ir_if(operand(r0F02).val);
                  exec_list *const f0F00_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F00->then_instructions;

                     body.emit(assign(r0EFD, body.constant(int(16)), 0x01));

                     body.emit(assign(r0EFB, lshift(r0EF5, body.constant(int(16))), 0x01));


                  body.instructions = f0F00_parent_instructions;
                  body.emit(f0F00);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F04 = bit_and(r0EFB, body.constant(4278190080u));
                  ir_expression *const r0F05 = equal(r0F04, body.constant(0u));
                  ir_if *f0F03 = new(mem_ctx) ir_if(operand(r0F05).val);
                  exec_list *const f0F03_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F03->then_instructions;

                     body.emit(assign(r0EFD, add(r0EFD, body.constant(int(8))), 0x01));

                     body.emit(assign(r0EFB, lshift(r0EFB, body.constant(int(8))), 0x01));


                  body.instructions = f0F03_parent_instructions;
                  body.emit(f0F03);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F07 = bit_and(r0EFB, body.constant(4026531840u));
                  ir_expression *const r0F08 = equal(r0F07, body.constant(0u));
                  ir_if *f0F06 = new(mem_ctx) ir_if(operand(r0F08).val);
                  exec_list *const f0F06_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F06->then_instructions;

                     body.emit(assign(r0EFD, add(r0EFD, body.constant(int(4))), 0x01));

                     body.emit(assign(r0EFB, lshift(r0EFB, body.constant(int(4))), 0x01));


                  body.instructions = f0F06_parent_instructions;
                  body.emit(f0F06);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F0A = bit_and(r0EFB, body.constant(3221225472u));
                  ir_expression *const r0F0B = equal(r0F0A, body.constant(0u));
                  ir_if *f0F09 = new(mem_ctx) ir_if(operand(r0F0B).val);
                  exec_list *const f0F09_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F09->then_instructions;

                     body.emit(assign(r0EFD, add(r0EFD, body.constant(int(2))), 0x01));

                     body.emit(assign(r0EFB, lshift(r0EFB, body.constant(int(2))), 0x01));


                  body.instructions = f0F09_parent_instructions;
                  body.emit(f0F09);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F0D = bit_and(r0EFB, body.constant(2147483648u));
                  ir_expression *const r0F0E = equal(r0F0D, body.constant(0u));
                  ir_if *f0F0C = new(mem_ctx) ir_if(operand(r0F0E).val);
                  exec_list *const f0F0C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F0C->then_instructions;

                     body.emit(assign(r0EFD, add(r0EFD, body.constant(int(1))), 0x01));


                  body.instructions = f0F0C_parent_instructions;
                  body.emit(f0F0C);

                  /* END IF */

                  body.emit(assign(r0EFC, r0EFD, 0x01));


               body.instructions = f0EFE_parent_instructions;
               body.emit(f0EFE);

               /* END IF */

               body.emit(assign(r0EF8, add(r0EFC, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0F10 = lequal(body.constant(int(0)), r0EF8);
               ir_if *f0F0F = new(mem_ctx) ir_if(operand(r0F10).val);
               exec_list *const f0F0F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F0F->then_instructions;

                  body.emit(assign(r0EF7, body.constant(0u), 0x01));

                  ir_variable *const r0F11 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0F11, lshift(r0EF6, r0EF8), 0x01));

                  ir_variable *const r0F12 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F14 = equal(r0EF8, body.constant(int(0)));
                  ir_if *f0F13 = new(mem_ctx) ir_if(operand(r0F14).val);
                  exec_list *const f0F13_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F13->then_instructions;

                     body.emit(assign(r0F12, r0EF5, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F13->else_instructions;

                     ir_expression *const r0F15 = lshift(r0EF5, r0EF8);
                     ir_expression *const r0F16 = neg(r0EF8);
                     ir_expression *const r0F17 = bit_and(r0F16, body.constant(int(31)));
                     ir_expression *const r0F18 = rshift(r0EF6, r0F17);
                     body.emit(assign(r0F12, bit_or(r0F15, r0F18), 0x01));


                  body.instructions = f0F13_parent_instructions;
                  body.emit(f0F13);

                  /* END IF */

                  body.emit(assign(r0EF5, r0F12, 0x01));

                  body.emit(assign(r0EF6, r0F11, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F0F->else_instructions;

                  ir_variable *const r0F19 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0F19, body.constant(0u), 0x01));

                  ir_variable *const r0F1A = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0F1A, neg(r0EF8), 0x01));

                  ir_variable *const r0F1B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0F1B);
                  ir_variable *const r0F1C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0F1C);
                  ir_variable *const r0F1D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0F1D);
                  ir_variable *const r0F1E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0F1F = neg(r0F1A);
                  body.emit(assign(r0F1E, bit_and(r0F1F, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0F21 = equal(r0F1A, body.constant(int(0)));
                  ir_if *f0F20 = new(mem_ctx) ir_if(operand(r0F21).val);
                  exec_list *const f0F20_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F20->then_instructions;

                     body.emit(assign(r0F1B, r0F19, 0x01));

                     body.emit(assign(r0F1C, r0EF6, 0x01));

                     body.emit(assign(r0F1D, r0EF5, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F20->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F23 = less(r0F1A, body.constant(int(32)));
                     ir_if *f0F22 = new(mem_ctx) ir_if(operand(r0F23).val);
                     exec_list *const f0F22_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F22->then_instructions;

                        body.emit(assign(r0F1B, lshift(r0EF6, r0F1E), 0x01));

                        ir_expression *const r0F24 = lshift(r0EF5, r0F1E);
                        ir_expression *const r0F25 = rshift(r0EF6, r0F1A);
                        body.emit(assign(r0F1C, bit_or(r0F24, r0F25), 0x01));

                        body.emit(assign(r0F1D, rshift(r0EF5, r0F1A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F22->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0F27 = equal(r0F1A, body.constant(int(32)));
                        ir_if *f0F26 = new(mem_ctx) ir_if(operand(r0F27).val);
                        exec_list *const f0F26_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F26->then_instructions;

                           body.emit(assign(r0F1B, r0EF6, 0x01));

                           body.emit(assign(r0F1C, r0EF5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0F26->else_instructions;

                           body.emit(assign(r0F19, bit_or(body.constant(0u), r0EF6), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0F29 = less(r0F1A, body.constant(int(64)));
                           ir_if *f0F28 = new(mem_ctx) ir_if(operand(r0F29).val);
                           exec_list *const f0F28_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0F28->then_instructions;

                              body.emit(assign(r0F1B, lshift(r0EF5, r0F1E), 0x01));

                              ir_expression *const r0F2A = bit_and(r0F1A, body.constant(int(31)));
                              body.emit(assign(r0F1C, rshift(r0EF5, r0F2A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0F28->else_instructions;

                              ir_variable *const r0F2B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0F2D = equal(r0F1A, body.constant(int(64)));
                              ir_if *f0F2C = new(mem_ctx) ir_if(operand(r0F2D).val);
                              exec_list *const f0F2C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0F2C->then_instructions;

                                 body.emit(assign(r0F2B, r0EF5, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0F2C->else_instructions;

                                 ir_expression *const r0F2E = nequal(r0EF5, body.constant(0u));
                                 ir_expression *const r0F2F = expr(ir_unop_b2i, r0F2E);
                                 body.emit(assign(r0F2B, expr(ir_unop_i2u, r0F2F), 0x01));


                              body.instructions = f0F2C_parent_instructions;
                              body.emit(f0F2C);

                              /* END IF */

                              body.emit(assign(r0F1B, r0F2B, 0x01));

                              body.emit(assign(r0F1C, body.constant(0u), 0x01));


                           body.instructions = f0F28_parent_instructions;
                           body.emit(f0F28);

                           /* END IF */


                        body.instructions = f0F26_parent_instructions;
                        body.emit(f0F26);

                        /* END IF */

                        body.emit(assign(r0F1D, body.constant(0u), 0x01));


                     body.instructions = f0F22_parent_instructions;
                     body.emit(f0F22);

                     /* END IF */

                     ir_expression *const r0F30 = nequal(r0F19, body.constant(0u));
                     ir_expression *const r0F31 = expr(ir_unop_b2i, r0F30);
                     ir_expression *const r0F32 = expr(ir_unop_i2u, r0F31);
                     body.emit(assign(r0F1B, bit_or(r0F1B, r0F32), 0x01));


                  body.instructions = f0F20_parent_instructions;
                  body.emit(f0F20);

                  /* END IF */

                  body.emit(assign(r0EF5, r0F1D, 0x01));

                  body.emit(assign(r0EF6, r0F1C, 0x01));

                  body.emit(assign(r0EF7, r0F1B, 0x01));


               body.instructions = f0F0F_parent_instructions;
               body.emit(f0F0F);

               /* END IF */

               body.emit(assign(r0EF4, sub(r0EF4, r0EF8), 0x01));

               ir_variable *const r0F33 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0F33, r0EF4, 0x01));

               ir_variable *const r0F34 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0F34, r0EF5, 0x01));

               ir_variable *const r0F35 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0F35, r0EF6, 0x01));

               ir_variable *const r0F36 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0F36, r0EF7, 0x01));

               ir_variable *const r0F37 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0F37, body.constant(true), 0x01));

               ir_variable *const r0F38 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0F39 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0F39);
               ir_expression *const r0F3A = expr(ir_unop_u2i, r0EF7);
               body.emit(assign(r0F39, less(r0F3A, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0F3C = lequal(body.constant(int(2045)), r0EF4);
               ir_if *f0F3B = new(mem_ctx) ir_if(operand(r0F3C).val);
               exec_list *const f0F3B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F3B->then_instructions;

                  ir_variable *const r0F3D = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F3F = less(body.constant(int(2045)), r0EF4);
                  ir_if *f0F3E = new(mem_ctx) ir_if(operand(r0F3F).val);
                  exec_list *const f0F3E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F3E->then_instructions;

                     body.emit(assign(r0F3D, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F3E->else_instructions;

                     ir_variable *const r0F40 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F42 = equal(r0EF4, body.constant(int(2045)));
                     ir_if *f0F41 = new(mem_ctx) ir_if(operand(r0F42).val);
                     exec_list *const f0F41_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F41->then_instructions;

                        ir_expression *const r0F43 = equal(body.constant(2097151u), r0EF5);
                        ir_expression *const r0F44 = equal(body.constant(4294967295u), r0EF6);
                        body.emit(assign(r0F40, logic_and(r0F43, r0F44), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F41->else_instructions;

                        body.emit(assign(r0F40, body.constant(false), 0x01));


                     body.instructions = f0F41_parent_instructions;
                     body.emit(f0F41);

                     /* END IF */

                     body.emit(assign(r0F3D, logic_and(r0F40, r0F39), 0x01));


                  body.instructions = f0F3E_parent_instructions;
                  body.emit(f0F3E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0F45 = new(mem_ctx) ir_if(operand(r0F3D).val);
                  exec_list *const f0F45_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F45->then_instructions;

                     ir_variable *const r0F46 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0F46);
                     ir_expression *const r0F47 = lshift(r0DB8, body.constant(int(31)));
                     body.emit(assign(r0F46, add(r0F47, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0F46, body.constant(0u), 0x01));

                     body.emit(assign(r0F38, r0F46, 0x03));

                     body.emit(assign(r0F37, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F45->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F49 = less(r0EF4, body.constant(int(0)));
                     ir_if *f0F48 = new(mem_ctx) ir_if(operand(r0F49).val);
                     exec_list *const f0F48_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F48->then_instructions;

                        ir_variable *const r0F4A = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0F4A, r0EF7, 0x01));

                        ir_variable *const r0F4B = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0F4B, neg(r0EF4), 0x01));

                        ir_variable *const r0F4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0F4C);
                        ir_variable *const r0F4D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0F4D);
                        ir_variable *const r0F4E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0F4E);
                        ir_variable *const r0F4F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0F50 = neg(r0F4B);
                        body.emit(assign(r0F4F, bit_and(r0F50, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0F52 = equal(r0F4B, body.constant(int(0)));
                        ir_if *f0F51 = new(mem_ctx) ir_if(operand(r0F52).val);
                        exec_list *const f0F51_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F51->then_instructions;

                           body.emit(assign(r0F4C, r0EF7, 0x01));

                           body.emit(assign(r0F4D, r0EF6, 0x01));

                           body.emit(assign(r0F4E, r0EF5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0F51->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0F54 = less(r0F4B, body.constant(int(32)));
                           ir_if *f0F53 = new(mem_ctx) ir_if(operand(r0F54).val);
                           exec_list *const f0F53_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0F53->then_instructions;

                              body.emit(assign(r0F4C, lshift(r0EF6, r0F4F), 0x01));

                              ir_expression *const r0F55 = lshift(r0EF5, r0F4F);
                              ir_expression *const r0F56 = rshift(r0EF6, r0F4B);
                              body.emit(assign(r0F4D, bit_or(r0F55, r0F56), 0x01));

                              body.emit(assign(r0F4E, rshift(r0EF5, r0F4B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0F53->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0F58 = equal(r0F4B, body.constant(int(32)));
                              ir_if *f0F57 = new(mem_ctx) ir_if(operand(r0F58).val);
                              exec_list *const f0F57_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0F57->then_instructions;

                                 body.emit(assign(r0F4C, r0EF6, 0x01));

                                 body.emit(assign(r0F4D, r0EF5, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0F57->else_instructions;

                                 body.emit(assign(r0F4A, bit_or(r0EF7, r0EF6), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0F5A = less(r0F4B, body.constant(int(64)));
                                 ir_if *f0F59 = new(mem_ctx) ir_if(operand(r0F5A).val);
                                 exec_list *const f0F59_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0F59->then_instructions;

                                    body.emit(assign(r0F4C, lshift(r0EF5, r0F4F), 0x01));

                                    ir_expression *const r0F5B = bit_and(r0F4B, body.constant(int(31)));
                                    body.emit(assign(r0F4D, rshift(r0EF5, r0F5B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0F59->else_instructions;

                                    ir_variable *const r0F5C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0F5E = equal(r0F4B, body.constant(int(64)));
                                    ir_if *f0F5D = new(mem_ctx) ir_if(operand(r0F5E).val);
                                    exec_list *const f0F5D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0F5D->then_instructions;

                                       body.emit(assign(r0F5C, r0EF5, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0F5D->else_instructions;

                                       ir_expression *const r0F5F = nequal(r0EF5, body.constant(0u));
                                       ir_expression *const r0F60 = expr(ir_unop_b2i, r0F5F);
                                       body.emit(assign(r0F5C, expr(ir_unop_i2u, r0F60), 0x01));


                                    body.instructions = f0F5D_parent_instructions;
                                    body.emit(f0F5D);

                                    /* END IF */

                                    body.emit(assign(r0F4C, r0F5C, 0x01));

                                    body.emit(assign(r0F4D, body.constant(0u), 0x01));


                                 body.instructions = f0F59_parent_instructions;
                                 body.emit(f0F59);

                                 /* END IF */


                              body.instructions = f0F57_parent_instructions;
                              body.emit(f0F57);

                              /* END IF */

                              body.emit(assign(r0F4E, body.constant(0u), 0x01));


                           body.instructions = f0F53_parent_instructions;
                           body.emit(f0F53);

                           /* END IF */

                           ir_expression *const r0F61 = nequal(r0F4A, body.constant(0u));
                           ir_expression *const r0F62 = expr(ir_unop_b2i, r0F61);
                           ir_expression *const r0F63 = expr(ir_unop_i2u, r0F62);
                           body.emit(assign(r0F4C, bit_or(r0F4C, r0F63), 0x01));


                        body.instructions = f0F51_parent_instructions;
                        body.emit(f0F51);

                        /* END IF */

                        body.emit(assign(r0F34, r0F4E, 0x01));

                        body.emit(assign(r0F35, r0F4D, 0x01));

                        body.emit(assign(r0F36, r0F4C, 0x01));

                        body.emit(assign(r0F33, body.constant(int(0)), 0x01));

                        body.emit(assign(r0F39, less(r0F4C, body.constant(0u)), 0x01));


                     body.instructions = f0F48_parent_instructions;
                     body.emit(f0F48);

                     /* END IF */


                  body.instructions = f0F45_parent_instructions;
                  body.emit(f0F45);

                  /* END IF */


               body.instructions = f0F3B_parent_instructions;
               body.emit(f0F3B);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0F64 = new(mem_ctx) ir_if(operand(r0F37).val);
               exec_list *const f0F64_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F64->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0F65 = new(mem_ctx) ir_if(operand(r0F39).val);
                  exec_list *const f0F65_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F65->then_instructions;

                     ir_variable *const r0F66 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0F66, add(r0F35, body.constant(1u)), 0x01));

                     ir_expression *const r0F67 = less(r0F66, r0F35);
                     ir_expression *const r0F68 = expr(ir_unop_b2i, r0F67);
                     ir_expression *const r0F69 = expr(ir_unop_i2u, r0F68);
                     body.emit(assign(r0F34, add(r0F34, r0F69), 0x01));

                     ir_expression *const r0F6A = equal(r0F36, body.constant(0u));
                     ir_expression *const r0F6B = expr(ir_unop_b2i, r0F6A);
                     ir_expression *const r0F6C = expr(ir_unop_i2u, r0F6B);
                     ir_expression *const r0F6D = add(r0F36, r0F6C);
                     ir_expression *const r0F6E = bit_and(r0F6D, body.constant(1u));
                     ir_expression *const r0F6F = expr(ir_unop_bit_not, r0F6E);
                     body.emit(assign(r0F35, bit_and(r0F66, r0F6F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F65->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F71 = bit_or(r0F34, r0F35);
                     ir_expression *const r0F72 = equal(r0F71, body.constant(0u));
                     ir_if *f0F70 = new(mem_ctx) ir_if(operand(r0F72).val);
                     exec_list *const f0F70_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F70->then_instructions;

                        body.emit(assign(r0F33, body.constant(int(0)), 0x01));


                     body.instructions = f0F70_parent_instructions;
                     body.emit(f0F70);

                     /* END IF */


                  body.instructions = f0F65_parent_instructions;
                  body.emit(f0F65);

                  /* END IF */

                  ir_variable *const r0F73 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0F73);
                  ir_expression *const r0F74 = lshift(r0DB8, body.constant(int(31)));
                  ir_expression *const r0F75 = expr(ir_unop_i2u, r0F33);
                  ir_expression *const r0F76 = lshift(r0F75, body.constant(int(20)));
                  ir_expression *const r0F77 = add(r0F74, r0F76);
                  body.emit(assign(r0F73, add(r0F77, r0F34), 0x02));

                  body.emit(assign(r0F73, r0F35, 0x01));

                  body.emit(assign(r0F38, r0F73, 0x03));

                  body.emit(assign(r0F37, body.constant(false), 0x01));


               body.instructions = f0F64_parent_instructions;
               body.emit(f0F64);

               /* END IF */

               body.emit(assign(r0DB9, r0F38, 0x03));


            body.instructions = f0EA4_parent_instructions;
            body.emit(f0EA4);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0EA2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0F79 = equal(r0DC1, body.constant(int(2047)));
            ir_if *f0F78 = new(mem_ctx) ir_if(operand(r0F79).val);
            exec_list *const f0F78_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0F78->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0F7B = bit_or(swizzle_y(r0DBE), swizzle_x(r0DBE));
               ir_expression *const r0F7C = bit_or(swizzle_y(r0DBC), swizzle_x(r0DBC));
               ir_expression *const r0F7D = bit_or(r0F7B, r0F7C);
               ir_expression *const r0F7E = nequal(r0F7D, body.constant(0u));
               ir_if *f0F7A = new(mem_ctx) ir_if(operand(r0F7E).val);
               exec_list *const f0F7A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F7A->then_instructions;

                  ir_variable *const r0F7F = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0F7F, swizzle_x(r0DB1), 0x01));

                  ir_variable *const r0F80 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0F80, swizzle_x(r0DB2), 0x01));

                  ir_variable *const r0F81 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0F82 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0F83 = rshift(swizzle_y(r0DB1), body.constant(int(19)));
                  ir_expression *const r0F84 = bit_and(r0F83, body.constant(4095u));
                  ir_expression *const r0F85 = equal(r0F84, body.constant(4094u));
                  ir_expression *const r0F86 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r0F87 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
                  ir_expression *const r0F88 = nequal(r0F87, body.constant(0u));
                  ir_expression *const r0F89 = logic_or(r0F86, r0F88);
                  body.emit(assign(r0F82, logic_and(r0F85, r0F89), 0x01));

                  ir_variable *const r0F8A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0F8B = lshift(swizzle_y(r0DB2), body.constant(int(1)));
                  ir_expression *const r0F8C = lequal(body.constant(4292870144u), r0F8B);
                  ir_expression *const r0F8D = nequal(swizzle_x(r0DB2), body.constant(0u));
                  ir_expression *const r0F8E = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
                  ir_expression *const r0F8F = nequal(r0F8E, body.constant(0u));
                  ir_expression *const r0F90 = logic_or(r0F8D, r0F8F);
                  body.emit(assign(r0F8A, logic_and(r0F8C, r0F90), 0x01));

                  body.emit(assign(r0F7F, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

                  body.emit(assign(r0F80, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0F92 = lshift(swizzle_y(r0DB1), body.constant(int(1)));
                  ir_expression *const r0F93 = lequal(body.constant(4292870144u), r0F92);
                  ir_expression *const r0F94 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r0F95 = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
                  ir_expression *const r0F96 = nequal(r0F95, body.constant(0u));
                  ir_expression *const r0F97 = logic_or(r0F94, r0F96);
                  ir_expression *const r0F98 = logic_and(r0F93, r0F97);
                  ir_if *f0F91 = new(mem_ctx) ir_if(operand(r0F98).val);
                  exec_list *const f0F91_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F91->then_instructions;

                     ir_variable *const r0F99 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F9B = logic_and(r0F82, r0F8A);
                     ir_if *f0F9A = new(mem_ctx) ir_if(operand(r0F9B).val);
                     exec_list *const f0F9A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F9A->then_instructions;

                        body.emit(assign(r0F99, r0F80, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F9A->else_instructions;

                        body.emit(assign(r0F99, r0F7F, 0x03));


                     body.instructions = f0F9A_parent_instructions;
                     body.emit(f0F9A);

                     /* END IF */

                     body.emit(assign(r0F81, r0F99, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F91->else_instructions;

                     body.emit(assign(r0F81, r0F80, 0x03));


                  body.instructions = f0F91_parent_instructions;
                  body.emit(f0F91);

                  /* END IF */

                  body.emit(assign(r0DB9, r0F81, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F7A->else_instructions;

                  ir_constant_data r0F9C_data;
                  memset(&r0F9C_data, 0, sizeof(ir_constant_data));
                  r0F9C_data.u[0] = 4294967295;
                  r0F9C_data.u[1] = 4294967295;
                  ir_constant *const r0F9C = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0F9C_data);
                  body.emit(assign(r0DB9, r0F9C, 0x03));


               body.instructions = f0F7A_parent_instructions;
               body.emit(f0F7A);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0F78->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0F9E = equal(r0DC1, body.constant(int(0)));
               ir_if *f0F9D = new(mem_ctx) ir_if(operand(r0F9E).val);
               exec_list *const f0F9D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F9D->then_instructions;

                  body.emit(assign(r0DBD, body.constant(int(1)), 0x01));

                  body.emit(assign(r0DBB, body.constant(int(1)), 0x01));


               body.instructions = f0F9D_parent_instructions;
               body.emit(f0F9D);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0FA0 = less(swizzle_y(r0DBC), swizzle_y(r0DBE));
               ir_if *f0F9F = new(mem_ctx) ir_if(operand(r0FA0).val);
               exec_list *const f0F9F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F9F->then_instructions;

                  ir_variable *const r0FA1 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0FA2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0FA2, sub(swizzle_x(r0DBE), swizzle_x(r0DBC)), 0x01));

                  ir_expression *const r0FA3 = sub(swizzle_y(r0DBE), swizzle_y(r0DBC));
                  ir_expression *const r0FA4 = less(swizzle_x(r0DBE), swizzle_x(r0DBC));
                  ir_expression *const r0FA5 = expr(ir_unop_b2i, r0FA4);
                  ir_expression *const r0FA6 = expr(ir_unop_i2u, r0FA5);
                  body.emit(assign(r0FA1, sub(r0FA3, r0FA6), 0x01));

                  body.emit(assign(r0DBF, add(r0DBD, body.constant(int(-1))), 0x01));

                  ir_variable *const r0FA7 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0FA7, add(r0DBF, body.constant(int(-10))), 0x01));

                  ir_variable *const r0FA8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0FA8, r0FA1, 0x01));

                  ir_variable *const r0FA9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0FA9, r0FA2, 0x01));

                  ir_variable *const r0FAA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0FAA);
                  ir_variable *const r0FAB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0FAB);
                  /* IF CONDITION */
                  ir_expression *const r0FAD = equal(r0FA1, body.constant(0u));
                  ir_if *f0FAC = new(mem_ctx) ir_if(operand(r0FAD).val);
                  exec_list *const f0FAC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FAC->then_instructions;

                     body.emit(assign(r0FA8, r0FA2, 0x01));

                     body.emit(assign(r0FA9, body.constant(0u), 0x01));

                     body.emit(assign(r0FA7, add(r0FA7, body.constant(int(-32))), 0x01));


                  body.instructions = f0FAC_parent_instructions;
                  body.emit(f0FAC);

                  /* END IF */

                  ir_variable *const r0FAE = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0FAE, r0FA8, 0x01));

                  ir_variable *const r0FAF = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0FB0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0FB0);
                  /* IF CONDITION */
                  ir_expression *const r0FB2 = equal(r0FA8, body.constant(0u));
                  ir_if *f0FB1 = new(mem_ctx) ir_if(operand(r0FB2).val);
                  exec_list *const f0FB1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FB1->then_instructions;

                     body.emit(assign(r0FAF, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FB1->else_instructions;

                     body.emit(assign(r0FB0, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0FB4 = bit_and(r0FA8, body.constant(4294901760u));
                     ir_expression *const r0FB5 = equal(r0FB4, body.constant(0u));
                     ir_if *f0FB3 = new(mem_ctx) ir_if(operand(r0FB5).val);
                     exec_list *const f0FB3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB3->then_instructions;

                        body.emit(assign(r0FB0, body.constant(int(16)), 0x01));

                        body.emit(assign(r0FAE, lshift(r0FA8, body.constant(int(16))), 0x01));


                     body.instructions = f0FB3_parent_instructions;
                     body.emit(f0FB3);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FB7 = bit_and(r0FAE, body.constant(4278190080u));
                     ir_expression *const r0FB8 = equal(r0FB7, body.constant(0u));
                     ir_if *f0FB6 = new(mem_ctx) ir_if(operand(r0FB8).val);
                     exec_list *const f0FB6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB6->then_instructions;

                        body.emit(assign(r0FB0, add(r0FB0, body.constant(int(8))), 0x01));

                        body.emit(assign(r0FAE, lshift(r0FAE, body.constant(int(8))), 0x01));


                     body.instructions = f0FB6_parent_instructions;
                     body.emit(f0FB6);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FBA = bit_and(r0FAE, body.constant(4026531840u));
                     ir_expression *const r0FBB = equal(r0FBA, body.constant(0u));
                     ir_if *f0FB9 = new(mem_ctx) ir_if(operand(r0FBB).val);
                     exec_list *const f0FB9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB9->then_instructions;

                        body.emit(assign(r0FB0, add(r0FB0, body.constant(int(4))), 0x01));

                        body.emit(assign(r0FAE, lshift(r0FAE, body.constant(int(4))), 0x01));


                     body.instructions = f0FB9_parent_instructions;
                     body.emit(f0FB9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FBD = bit_and(r0FAE, body.constant(3221225472u));
                     ir_expression *const r0FBE = equal(r0FBD, body.constant(0u));
                     ir_if *f0FBC = new(mem_ctx) ir_if(operand(r0FBE).val);
                     exec_list *const f0FBC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FBC->then_instructions;

                        body.emit(assign(r0FB0, add(r0FB0, body.constant(int(2))), 0x01));

                        body.emit(assign(r0FAE, lshift(r0FAE, body.constant(int(2))), 0x01));


                     body.instructions = f0FBC_parent_instructions;
                     body.emit(f0FBC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FC0 = bit_and(r0FAE, body.constant(2147483648u));
                     ir_expression *const r0FC1 = equal(r0FC0, body.constant(0u));
                     ir_if *f0FBF = new(mem_ctx) ir_if(operand(r0FC1).val);
                     exec_list *const f0FBF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FBF->then_instructions;

                        body.emit(assign(r0FB0, add(r0FB0, body.constant(int(1))), 0x01));


                     body.instructions = f0FBF_parent_instructions;
                     body.emit(f0FBF);

                     /* END IF */

                     body.emit(assign(r0FAF, r0FB0, 0x01));


                  body.instructions = f0FB1_parent_instructions;
                  body.emit(f0FB1);

                  /* END IF */

                  body.emit(assign(r0FAB, add(r0FAF, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0FC3 = lequal(body.constant(int(0)), r0FAB);
                  ir_if *f0FC2 = new(mem_ctx) ir_if(operand(r0FC3).val);
                  exec_list *const f0FC2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FC2->then_instructions;

                     body.emit(assign(r0FAA, body.constant(0u), 0x01));

                     ir_variable *const r0FC4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0FC4, lshift(r0FA9, r0FAB), 0x01));

                     ir_variable *const r0FC5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FC7 = equal(r0FAB, body.constant(int(0)));
                     ir_if *f0FC6 = new(mem_ctx) ir_if(operand(r0FC7).val);
                     exec_list *const f0FC6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FC6->then_instructions;

                        body.emit(assign(r0FC5, r0FA8, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FC6->else_instructions;

                        ir_expression *const r0FC8 = lshift(r0FA8, r0FAB);
                        ir_expression *const r0FC9 = neg(r0FAB);
                        ir_expression *const r0FCA = bit_and(r0FC9, body.constant(int(31)));
                        ir_expression *const r0FCB = rshift(r0FA9, r0FCA);
                        body.emit(assign(r0FC5, bit_or(r0FC8, r0FCB), 0x01));


                     body.instructions = f0FC6_parent_instructions;
                     body.emit(f0FC6);

                     /* END IF */

                     body.emit(assign(r0FA8, r0FC5, 0x01));

                     body.emit(assign(r0FA9, r0FC4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FC2->else_instructions;

                     ir_variable *const r0FCC = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0FCC, body.constant(0u), 0x01));

                     ir_variable *const r0FCD = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0FCD, neg(r0FAB), 0x01));

                     ir_variable *const r0FCE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0FCE);
                     ir_variable *const r0FCF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0FCF);
                     ir_variable *const r0FD0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0FD0);
                     ir_variable *const r0FD1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0FD2 = neg(r0FCD);
                     body.emit(assign(r0FD1, bit_and(r0FD2, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0FD4 = equal(r0FCD, body.constant(int(0)));
                     ir_if *f0FD3 = new(mem_ctx) ir_if(operand(r0FD4).val);
                     exec_list *const f0FD3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FD3->then_instructions;

                        body.emit(assign(r0FCE, r0FCC, 0x01));

                        body.emit(assign(r0FCF, r0FA9, 0x01));

                        body.emit(assign(r0FD0, r0FA8, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FD3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0FD6 = less(r0FCD, body.constant(int(32)));
                        ir_if *f0FD5 = new(mem_ctx) ir_if(operand(r0FD6).val);
                        exec_list *const f0FD5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FD5->then_instructions;

                           body.emit(assign(r0FCE, lshift(r0FA9, r0FD1), 0x01));

                           ir_expression *const r0FD7 = lshift(r0FA8, r0FD1);
                           ir_expression *const r0FD8 = rshift(r0FA9, r0FCD);
                           body.emit(assign(r0FCF, bit_or(r0FD7, r0FD8), 0x01));

                           body.emit(assign(r0FD0, rshift(r0FA8, r0FCD), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FD5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0FDA = equal(r0FCD, body.constant(int(32)));
                           ir_if *f0FD9 = new(mem_ctx) ir_if(operand(r0FDA).val);
                           exec_list *const f0FD9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0FD9->then_instructions;

                              body.emit(assign(r0FCE, r0FA9, 0x01));

                              body.emit(assign(r0FCF, r0FA8, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0FD9->else_instructions;

                              body.emit(assign(r0FCC, bit_or(body.constant(0u), r0FA9), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0FDC = less(r0FCD, body.constant(int(64)));
                              ir_if *f0FDB = new(mem_ctx) ir_if(operand(r0FDC).val);
                              exec_list *const f0FDB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0FDB->then_instructions;

                                 body.emit(assign(r0FCE, lshift(r0FA8, r0FD1), 0x01));

                                 ir_expression *const r0FDD = bit_and(r0FCD, body.constant(int(31)));
                                 body.emit(assign(r0FCF, rshift(r0FA8, r0FDD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0FDB->else_instructions;

                                 ir_variable *const r0FDE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0FE0 = equal(r0FCD, body.constant(int(64)));
                                 ir_if *f0FDF = new(mem_ctx) ir_if(operand(r0FE0).val);
                                 exec_list *const f0FDF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0FDF->then_instructions;

                                    body.emit(assign(r0FDE, r0FA8, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0FDF->else_instructions;

                                    ir_expression *const r0FE1 = nequal(r0FA8, body.constant(0u));
                                    ir_expression *const r0FE2 = expr(ir_unop_b2i, r0FE1);
                                    body.emit(assign(r0FDE, expr(ir_unop_i2u, r0FE2), 0x01));


                                 body.instructions = f0FDF_parent_instructions;
                                 body.emit(f0FDF);

                                 /* END IF */

                                 body.emit(assign(r0FCE, r0FDE, 0x01));

                                 body.emit(assign(r0FCF, body.constant(0u), 0x01));


                              body.instructions = f0FDB_parent_instructions;
                              body.emit(f0FDB);

                              /* END IF */


                           body.instructions = f0FD9_parent_instructions;
                           body.emit(f0FD9);

                           /* END IF */

                           body.emit(assign(r0FD0, body.constant(0u), 0x01));


                        body.instructions = f0FD5_parent_instructions;
                        body.emit(f0FD5);

                        /* END IF */

                        ir_expression *const r0FE3 = nequal(r0FCC, body.constant(0u));
                        ir_expression *const r0FE4 = expr(ir_unop_b2i, r0FE3);
                        ir_expression *const r0FE5 = expr(ir_unop_i2u, r0FE4);
                        body.emit(assign(r0FCE, bit_or(r0FCE, r0FE5), 0x01));


                     body.instructions = f0FD3_parent_instructions;
                     body.emit(f0FD3);

                     /* END IF */

                     body.emit(assign(r0FA8, r0FD0, 0x01));

                     body.emit(assign(r0FA9, r0FCF, 0x01));

                     body.emit(assign(r0FAA, r0FCE, 0x01));


                  body.instructions = f0FC2_parent_instructions;
                  body.emit(f0FC2);

                  /* END IF */

                  body.emit(assign(r0FA7, sub(r0FA7, r0FAB), 0x01));

                  ir_variable *const r0FE6 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0FE6, r0FA7, 0x01));

                  ir_variable *const r0FE7 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0FE7, r0FA8, 0x01));

                  ir_variable *const r0FE8 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0FE8, r0FA9, 0x01));

                  ir_variable *const r0FE9 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0FE9, r0FAA, 0x01));

                  ir_variable *const r0FEA = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0FEA, body.constant(true), 0x01));

                  ir_variable *const r0FEB = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0FEC = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0FEC);
                  ir_expression *const r0FED = expr(ir_unop_u2i, r0FAA);
                  body.emit(assign(r0FEC, less(r0FED, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0FEF = lequal(body.constant(int(2045)), r0FA7);
                  ir_if *f0FEE = new(mem_ctx) ir_if(operand(r0FEF).val);
                  exec_list *const f0FEE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FEE->then_instructions;

                     ir_variable *const r0FF0 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FF2 = less(body.constant(int(2045)), r0FA7);
                     ir_if *f0FF1 = new(mem_ctx) ir_if(operand(r0FF2).val);
                     exec_list *const f0FF1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FF1->then_instructions;

                        body.emit(assign(r0FF0, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FF1->else_instructions;

                        ir_variable *const r0FF3 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0FF5 = equal(r0FA7, body.constant(int(2045)));
                        ir_if *f0FF4 = new(mem_ctx) ir_if(operand(r0FF5).val);
                        exec_list *const f0FF4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FF4->then_instructions;

                           ir_expression *const r0FF6 = equal(body.constant(2097151u), r0FA8);
                           ir_expression *const r0FF7 = equal(body.constant(4294967295u), r0FA9);
                           body.emit(assign(r0FF3, logic_and(r0FF6, r0FF7), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FF4->else_instructions;

                           body.emit(assign(r0FF3, body.constant(false), 0x01));


                        body.instructions = f0FF4_parent_instructions;
                        body.emit(f0FF4);

                        /* END IF */

                        body.emit(assign(r0FF0, logic_and(r0FF3, r0FEC), 0x01));


                     body.instructions = f0FF1_parent_instructions;
                     body.emit(f0FF1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0FF8 = new(mem_ctx) ir_if(operand(r0FF0).val);
                     exec_list *const f0FF8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FF8->then_instructions;

                        ir_variable *const r0FF9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0FF9);
                        ir_expression *const r0FFA = lshift(r0DB8, body.constant(int(31)));
                        body.emit(assign(r0FF9, add(r0FFA, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0FF9, body.constant(0u), 0x01));

                        body.emit(assign(r0FEB, r0FF9, 0x03));

                        body.emit(assign(r0FEA, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FF8->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0FFC = less(r0FA7, body.constant(int(0)));
                        ir_if *f0FFB = new(mem_ctx) ir_if(operand(r0FFC).val);
                        exec_list *const f0FFB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FFB->then_instructions;

                           ir_variable *const r0FFD = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0FFD, r0FAA, 0x01));

                           ir_variable *const r0FFE = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0FFE, neg(r0FA7), 0x01));

                           ir_variable *const r0FFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0FFF);
                           ir_variable *const r1000 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r1000);
                           ir_variable *const r1001 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r1001);
                           ir_variable *const r1002 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r1003 = neg(r0FFE);
                           body.emit(assign(r1002, bit_and(r1003, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1005 = equal(r0FFE, body.constant(int(0)));
                           ir_if *f1004 = new(mem_ctx) ir_if(operand(r1005).val);
                           exec_list *const f1004_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1004->then_instructions;

                              body.emit(assign(r0FFF, r0FAA, 0x01));

                              body.emit(assign(r1000, r0FA9, 0x01));

                              body.emit(assign(r1001, r0FA8, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1004->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1007 = less(r0FFE, body.constant(int(32)));
                              ir_if *f1006 = new(mem_ctx) ir_if(operand(r1007).val);
                              exec_list *const f1006_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1006->then_instructions;

                                 body.emit(assign(r0FFF, lshift(r0FA9, r1002), 0x01));

                                 ir_expression *const r1008 = lshift(r0FA8, r1002);
                                 ir_expression *const r1009 = rshift(r0FA9, r0FFE);
                                 body.emit(assign(r1000, bit_or(r1008, r1009), 0x01));

                                 body.emit(assign(r1001, rshift(r0FA8, r0FFE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1006->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r100B = equal(r0FFE, body.constant(int(32)));
                                 ir_if *f100A = new(mem_ctx) ir_if(operand(r100B).val);
                                 exec_list *const f100A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f100A->then_instructions;

                                    body.emit(assign(r0FFF, r0FA9, 0x01));

                                    body.emit(assign(r1000, r0FA8, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f100A->else_instructions;

                                    body.emit(assign(r0FFD, bit_or(r0FAA, r0FA9), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r100D = less(r0FFE, body.constant(int(64)));
                                    ir_if *f100C = new(mem_ctx) ir_if(operand(r100D).val);
                                    exec_list *const f100C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f100C->then_instructions;

                                       body.emit(assign(r0FFF, lshift(r0FA8, r1002), 0x01));

                                       ir_expression *const r100E = bit_and(r0FFE, body.constant(int(31)));
                                       body.emit(assign(r1000, rshift(r0FA8, r100E), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f100C->else_instructions;

                                       ir_variable *const r100F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r1011 = equal(r0FFE, body.constant(int(64)));
                                       ir_if *f1010 = new(mem_ctx) ir_if(operand(r1011).val);
                                       exec_list *const f1010_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1010->then_instructions;

                                          body.emit(assign(r100F, r0FA8, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1010->else_instructions;

                                          ir_expression *const r1012 = nequal(r0FA8, body.constant(0u));
                                          ir_expression *const r1013 = expr(ir_unop_b2i, r1012);
                                          body.emit(assign(r100F, expr(ir_unop_i2u, r1013), 0x01));


                                       body.instructions = f1010_parent_instructions;
                                       body.emit(f1010);

                                       /* END IF */

                                       body.emit(assign(r0FFF, r100F, 0x01));

                                       body.emit(assign(r1000, body.constant(0u), 0x01));


                                    body.instructions = f100C_parent_instructions;
                                    body.emit(f100C);

                                    /* END IF */


                                 body.instructions = f100A_parent_instructions;
                                 body.emit(f100A);

                                 /* END IF */

                                 body.emit(assign(r1001, body.constant(0u), 0x01));


                              body.instructions = f1006_parent_instructions;
                              body.emit(f1006);

                              /* END IF */

                              ir_expression *const r1014 = nequal(r0FFD, body.constant(0u));
                              ir_expression *const r1015 = expr(ir_unop_b2i, r1014);
                              ir_expression *const r1016 = expr(ir_unop_i2u, r1015);
                              body.emit(assign(r0FFF, bit_or(r0FFF, r1016), 0x01));


                           body.instructions = f1004_parent_instructions;
                           body.emit(f1004);

                           /* END IF */

                           body.emit(assign(r0FE7, r1001, 0x01));

                           body.emit(assign(r0FE8, r1000, 0x01));

                           body.emit(assign(r0FE9, r0FFF, 0x01));

                           body.emit(assign(r0FE6, body.constant(int(0)), 0x01));

                           body.emit(assign(r0FEC, less(r0FFF, body.constant(0u)), 0x01));


                        body.instructions = f0FFB_parent_instructions;
                        body.emit(f0FFB);

                        /* END IF */


                     body.instructions = f0FF8_parent_instructions;
                     body.emit(f0FF8);

                     /* END IF */


                  body.instructions = f0FEE_parent_instructions;
                  body.emit(f0FEE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1017 = new(mem_ctx) ir_if(operand(r0FEA).val);
                  exec_list *const f1017_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1017->then_instructions;

                     /* IF CONDITION */
                     ir_if *f1018 = new(mem_ctx) ir_if(operand(r0FEC).val);
                     exec_list *const f1018_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1018->then_instructions;

                        ir_variable *const r1019 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r1019, add(r0FE8, body.constant(1u)), 0x01));

                        ir_expression *const r101A = less(r1019, r0FE8);
                        ir_expression *const r101B = expr(ir_unop_b2i, r101A);
                        ir_expression *const r101C = expr(ir_unop_i2u, r101B);
                        body.emit(assign(r0FE7, add(r0FE7, r101C), 0x01));

                        ir_expression *const r101D = equal(r0FE9, body.constant(0u));
                        ir_expression *const r101E = expr(ir_unop_b2i, r101D);
                        ir_expression *const r101F = expr(ir_unop_i2u, r101E);
                        ir_expression *const r1020 = add(r0FE9, r101F);
                        ir_expression *const r1021 = bit_and(r1020, body.constant(1u));
                        ir_expression *const r1022 = expr(ir_unop_bit_not, r1021);
                        body.emit(assign(r0FE8, bit_and(r1019, r1022), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1018->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1024 = bit_or(r0FE7, r0FE8);
                        ir_expression *const r1025 = equal(r1024, body.constant(0u));
                        ir_if *f1023 = new(mem_ctx) ir_if(operand(r1025).val);
                        exec_list *const f1023_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1023->then_instructions;

                           body.emit(assign(r0FE6, body.constant(int(0)), 0x01));


                        body.instructions = f1023_parent_instructions;
                        body.emit(f1023);

                        /* END IF */


                     body.instructions = f1018_parent_instructions;
                     body.emit(f1018);

                     /* END IF */

                     ir_variable *const r1026 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1026);
                     ir_expression *const r1027 = lshift(r0DB8, body.constant(int(31)));
                     ir_expression *const r1028 = expr(ir_unop_i2u, r0FE6);
                     ir_expression *const r1029 = lshift(r1028, body.constant(int(20)));
                     ir_expression *const r102A = add(r1027, r1029);
                     body.emit(assign(r1026, add(r102A, r0FE7), 0x02));

                     body.emit(assign(r1026, r0FE8, 0x01));

                     body.emit(assign(r0FEB, r1026, 0x03));

                     body.emit(assign(r0FEA, body.constant(false), 0x01));


                  body.instructions = f1017_parent_instructions;
                  body.emit(f1017);

                  /* END IF */

                  body.emit(assign(r0DB9, r0FEB, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F9F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r102C = less(swizzle_y(r0DBE), swizzle_y(r0DBC));
                  ir_if *f102B = new(mem_ctx) ir_if(operand(r102C).val);
                  exec_list *const f102B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f102B->then_instructions;

                     ir_variable *const r102D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r102E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r102E, sub(swizzle_x(r0DBC), swizzle_x(r0DBE)), 0x01));

                     ir_expression *const r102F = sub(swizzle_y(r0DBC), swizzle_y(r0DBE));
                     ir_expression *const r1030 = less(swizzle_x(r0DBC), swizzle_x(r0DBE));
                     ir_expression *const r1031 = expr(ir_unop_b2i, r1030);
                     ir_expression *const r1032 = expr(ir_unop_i2u, r1031);
                     body.emit(assign(r102D, sub(r102F, r1032), 0x01));

                     body.emit(assign(r0DB8, bit_xor(r0DB8, body.constant(1u)), 0x01));

                     body.emit(assign(r0DBF, add(r0DBB, body.constant(int(-1))), 0x01));

                     ir_variable *const r1033 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1033, add(r0DBF, body.constant(int(-10))), 0x01));

                     ir_variable *const r1034 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1034, r102D, 0x01));

                     ir_variable *const r1035 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1035, r102E, 0x01));

                     ir_variable *const r1036 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r1036);
                     ir_variable *const r1037 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1037);
                     /* IF CONDITION */
                     ir_expression *const r1039 = equal(r102D, body.constant(0u));
                     ir_if *f1038 = new(mem_ctx) ir_if(operand(r1039).val);
                     exec_list *const f1038_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1038->then_instructions;

                        body.emit(assign(r1034, r102E, 0x01));

                        body.emit(assign(r1035, body.constant(0u), 0x01));

                        body.emit(assign(r1033, add(r1033, body.constant(int(-32))), 0x01));


                     body.instructions = f1038_parent_instructions;
                     body.emit(f1038);

                     /* END IF */

                     ir_variable *const r103A = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r103A, r1034, 0x01));

                     ir_variable *const r103B = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r103C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r103C);
                     /* IF CONDITION */
                     ir_expression *const r103E = equal(r1034, body.constant(0u));
                     ir_if *f103D = new(mem_ctx) ir_if(operand(r103E).val);
                     exec_list *const f103D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f103D->then_instructions;

                        body.emit(assign(r103B, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f103D->else_instructions;

                        body.emit(assign(r103C, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1040 = bit_and(r1034, body.constant(4294901760u));
                        ir_expression *const r1041 = equal(r1040, body.constant(0u));
                        ir_if *f103F = new(mem_ctx) ir_if(operand(r1041).val);
                        exec_list *const f103F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f103F->then_instructions;

                           body.emit(assign(r103C, body.constant(int(16)), 0x01));

                           body.emit(assign(r103A, lshift(r1034, body.constant(int(16))), 0x01));


                        body.instructions = f103F_parent_instructions;
                        body.emit(f103F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1043 = bit_and(r103A, body.constant(4278190080u));
                        ir_expression *const r1044 = equal(r1043, body.constant(0u));
                        ir_if *f1042 = new(mem_ctx) ir_if(operand(r1044).val);
                        exec_list *const f1042_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1042->then_instructions;

                           body.emit(assign(r103C, add(r103C, body.constant(int(8))), 0x01));

                           body.emit(assign(r103A, lshift(r103A, body.constant(int(8))), 0x01));


                        body.instructions = f1042_parent_instructions;
                        body.emit(f1042);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1046 = bit_and(r103A, body.constant(4026531840u));
                        ir_expression *const r1047 = equal(r1046, body.constant(0u));
                        ir_if *f1045 = new(mem_ctx) ir_if(operand(r1047).val);
                        exec_list *const f1045_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1045->then_instructions;

                           body.emit(assign(r103C, add(r103C, body.constant(int(4))), 0x01));

                           body.emit(assign(r103A, lshift(r103A, body.constant(int(4))), 0x01));


                        body.instructions = f1045_parent_instructions;
                        body.emit(f1045);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1049 = bit_and(r103A, body.constant(3221225472u));
                        ir_expression *const r104A = equal(r1049, body.constant(0u));
                        ir_if *f1048 = new(mem_ctx) ir_if(operand(r104A).val);
                        exec_list *const f1048_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1048->then_instructions;

                           body.emit(assign(r103C, add(r103C, body.constant(int(2))), 0x01));

                           body.emit(assign(r103A, lshift(r103A, body.constant(int(2))), 0x01));


                        body.instructions = f1048_parent_instructions;
                        body.emit(f1048);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r104C = bit_and(r103A, body.constant(2147483648u));
                        ir_expression *const r104D = equal(r104C, body.constant(0u));
                        ir_if *f104B = new(mem_ctx) ir_if(operand(r104D).val);
                        exec_list *const f104B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f104B->then_instructions;

                           body.emit(assign(r103C, add(r103C, body.constant(int(1))), 0x01));


                        body.instructions = f104B_parent_instructions;
                        body.emit(f104B);

                        /* END IF */

                        body.emit(assign(r103B, r103C, 0x01));


                     body.instructions = f103D_parent_instructions;
                     body.emit(f103D);

                     /* END IF */

                     body.emit(assign(r1037, add(r103B, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r104F = lequal(body.constant(int(0)), r1037);
                     ir_if *f104E = new(mem_ctx) ir_if(operand(r104F).val);
                     exec_list *const f104E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f104E->then_instructions;

                        body.emit(assign(r1036, body.constant(0u), 0x01));

                        ir_variable *const r1050 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1050, lshift(r1035, r1037), 0x01));

                        ir_variable *const r1051 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1053 = equal(r1037, body.constant(int(0)));
                        ir_if *f1052 = new(mem_ctx) ir_if(operand(r1053).val);
                        exec_list *const f1052_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1052->then_instructions;

                           body.emit(assign(r1051, r1034, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1052->else_instructions;

                           ir_expression *const r1054 = lshift(r1034, r1037);
                           ir_expression *const r1055 = neg(r1037);
                           ir_expression *const r1056 = bit_and(r1055, body.constant(int(31)));
                           ir_expression *const r1057 = rshift(r1035, r1056);
                           body.emit(assign(r1051, bit_or(r1054, r1057), 0x01));


                        body.instructions = f1052_parent_instructions;
                        body.emit(f1052);

                        /* END IF */

                        body.emit(assign(r1034, r1051, 0x01));

                        body.emit(assign(r1035, r1050, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f104E->else_instructions;

                        ir_variable *const r1058 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1058, body.constant(0u), 0x01));

                        ir_variable *const r1059 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1059, neg(r1037), 0x01));

                        ir_variable *const r105A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r105A);
                        ir_variable *const r105B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r105B);
                        ir_variable *const r105C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r105C);
                        ir_variable *const r105D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r105E = neg(r1059);
                        body.emit(assign(r105D, bit_and(r105E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1060 = equal(r1059, body.constant(int(0)));
                        ir_if *f105F = new(mem_ctx) ir_if(operand(r1060).val);
                        exec_list *const f105F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f105F->then_instructions;

                           body.emit(assign(r105A, r1058, 0x01));

                           body.emit(assign(r105B, r1035, 0x01));

                           body.emit(assign(r105C, r1034, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f105F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1062 = less(r1059, body.constant(int(32)));
                           ir_if *f1061 = new(mem_ctx) ir_if(operand(r1062).val);
                           exec_list *const f1061_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1061->then_instructions;

                              body.emit(assign(r105A, lshift(r1035, r105D), 0x01));

                              ir_expression *const r1063 = lshift(r1034, r105D);
                              ir_expression *const r1064 = rshift(r1035, r1059);
                              body.emit(assign(r105B, bit_or(r1063, r1064), 0x01));

                              body.emit(assign(r105C, rshift(r1034, r1059), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1061->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1066 = equal(r1059, body.constant(int(32)));
                              ir_if *f1065 = new(mem_ctx) ir_if(operand(r1066).val);
                              exec_list *const f1065_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1065->then_instructions;

                                 body.emit(assign(r105A, r1035, 0x01));

                                 body.emit(assign(r105B, r1034, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1065->else_instructions;

                                 body.emit(assign(r1058, bit_or(body.constant(0u), r1035), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1068 = less(r1059, body.constant(int(64)));
                                 ir_if *f1067 = new(mem_ctx) ir_if(operand(r1068).val);
                                 exec_list *const f1067_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1067->then_instructions;

                                    body.emit(assign(r105A, lshift(r1034, r105D), 0x01));

                                    ir_expression *const r1069 = bit_and(r1059, body.constant(int(31)));
                                    body.emit(assign(r105B, rshift(r1034, r1069), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1067->else_instructions;

                                    ir_variable *const r106A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r106C = equal(r1059, body.constant(int(64)));
                                    ir_if *f106B = new(mem_ctx) ir_if(operand(r106C).val);
                                    exec_list *const f106B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f106B->then_instructions;

                                       body.emit(assign(r106A, r1034, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f106B->else_instructions;

                                       ir_expression *const r106D = nequal(r1034, body.constant(0u));
                                       ir_expression *const r106E = expr(ir_unop_b2i, r106D);
                                       body.emit(assign(r106A, expr(ir_unop_i2u, r106E), 0x01));


                                    body.instructions = f106B_parent_instructions;
                                    body.emit(f106B);

                                    /* END IF */

                                    body.emit(assign(r105A, r106A, 0x01));

                                    body.emit(assign(r105B, body.constant(0u), 0x01));


                                 body.instructions = f1067_parent_instructions;
                                 body.emit(f1067);

                                 /* END IF */


                              body.instructions = f1065_parent_instructions;
                              body.emit(f1065);

                              /* END IF */

                              body.emit(assign(r105C, body.constant(0u), 0x01));


                           body.instructions = f1061_parent_instructions;
                           body.emit(f1061);

                           /* END IF */

                           ir_expression *const r106F = nequal(r1058, body.constant(0u));
                           ir_expression *const r1070 = expr(ir_unop_b2i, r106F);
                           ir_expression *const r1071 = expr(ir_unop_i2u, r1070);
                           body.emit(assign(r105A, bit_or(r105A, r1071), 0x01));


                        body.instructions = f105F_parent_instructions;
                        body.emit(f105F);

                        /* END IF */

                        body.emit(assign(r1034, r105C, 0x01));

                        body.emit(assign(r1035, r105B, 0x01));

                        body.emit(assign(r1036, r105A, 0x01));


                     body.instructions = f104E_parent_instructions;
                     body.emit(f104E);

                     /* END IF */

                     body.emit(assign(r1033, sub(r1033, r1037), 0x01));

                     ir_variable *const r1072 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1072, r1033, 0x01));

                     ir_variable *const r1073 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1073, r1034, 0x01));

                     ir_variable *const r1074 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1074, r1035, 0x01));

                     ir_variable *const r1075 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1075, r1036, 0x01));

                     ir_variable *const r1076 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1076, body.constant(true), 0x01));

                     ir_variable *const r1077 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1078 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1078);
                     ir_expression *const r1079 = expr(ir_unop_u2i, r1036);
                     body.emit(assign(r1078, less(r1079, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r107B = lequal(body.constant(int(2045)), r1033);
                     ir_if *f107A = new(mem_ctx) ir_if(operand(r107B).val);
                     exec_list *const f107A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f107A->then_instructions;

                        ir_variable *const r107C = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r107E = less(body.constant(int(2045)), r1033);
                        ir_if *f107D = new(mem_ctx) ir_if(operand(r107E).val);
                        exec_list *const f107D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f107D->then_instructions;

                           body.emit(assign(r107C, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f107D->else_instructions;

                           ir_variable *const r107F = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1081 = equal(r1033, body.constant(int(2045)));
                           ir_if *f1080 = new(mem_ctx) ir_if(operand(r1081).val);
                           exec_list *const f1080_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1080->then_instructions;

                              ir_expression *const r1082 = equal(body.constant(2097151u), r1034);
                              ir_expression *const r1083 = equal(body.constant(4294967295u), r1035);
                              body.emit(assign(r107F, logic_and(r1082, r1083), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1080->else_instructions;

                              body.emit(assign(r107F, body.constant(false), 0x01));


                           body.instructions = f1080_parent_instructions;
                           body.emit(f1080);

                           /* END IF */

                           body.emit(assign(r107C, logic_and(r107F, r1078), 0x01));


                        body.instructions = f107D_parent_instructions;
                        body.emit(f107D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1084 = new(mem_ctx) ir_if(operand(r107C).val);
                        exec_list *const f1084_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1084->then_instructions;

                           ir_variable *const r1085 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1085);
                           ir_expression *const r1086 = lshift(r0DB8, body.constant(int(31)));
                           body.emit(assign(r1085, add(r1086, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1085, body.constant(0u), 0x01));

                           body.emit(assign(r1077, r1085, 0x03));

                           body.emit(assign(r1076, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1084->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1088 = less(r1033, body.constant(int(0)));
                           ir_if *f1087 = new(mem_ctx) ir_if(operand(r1088).val);
                           exec_list *const f1087_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1087->then_instructions;

                              ir_variable *const r1089 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1089, r1036, 0x01));

                              ir_variable *const r108A = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r108A, neg(r1033), 0x01));

                              ir_variable *const r108B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r108B);
                              ir_variable *const r108C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r108C);
                              ir_variable *const r108D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r108D);
                              ir_variable *const r108E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r108F = neg(r108A);
                              body.emit(assign(r108E, bit_and(r108F, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1091 = equal(r108A, body.constant(int(0)));
                              ir_if *f1090 = new(mem_ctx) ir_if(operand(r1091).val);
                              exec_list *const f1090_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1090->then_instructions;

                                 body.emit(assign(r108B, r1036, 0x01));

                                 body.emit(assign(r108C, r1035, 0x01));

                                 body.emit(assign(r108D, r1034, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1090->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1093 = less(r108A, body.constant(int(32)));
                                 ir_if *f1092 = new(mem_ctx) ir_if(operand(r1093).val);
                                 exec_list *const f1092_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1092->then_instructions;

                                    body.emit(assign(r108B, lshift(r1035, r108E), 0x01));

                                    ir_expression *const r1094 = lshift(r1034, r108E);
                                    ir_expression *const r1095 = rshift(r1035, r108A);
                                    body.emit(assign(r108C, bit_or(r1094, r1095), 0x01));

                                    body.emit(assign(r108D, rshift(r1034, r108A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1092->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1097 = equal(r108A, body.constant(int(32)));
                                    ir_if *f1096 = new(mem_ctx) ir_if(operand(r1097).val);
                                    exec_list *const f1096_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1096->then_instructions;

                                       body.emit(assign(r108B, r1035, 0x01));

                                       body.emit(assign(r108C, r1034, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1096->else_instructions;

                                       body.emit(assign(r1089, bit_or(r1036, r1035), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1099 = less(r108A, body.constant(int(64)));
                                       ir_if *f1098 = new(mem_ctx) ir_if(operand(r1099).val);
                                       exec_list *const f1098_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1098->then_instructions;

                                          body.emit(assign(r108B, lshift(r1034, r108E), 0x01));

                                          ir_expression *const r109A = bit_and(r108A, body.constant(int(31)));
                                          body.emit(assign(r108C, rshift(r1034, r109A), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1098->else_instructions;

                                          ir_variable *const r109B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r109D = equal(r108A, body.constant(int(64)));
                                          ir_if *f109C = new(mem_ctx) ir_if(operand(r109D).val);
                                          exec_list *const f109C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f109C->then_instructions;

                                             body.emit(assign(r109B, r1034, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f109C->else_instructions;

                                             ir_expression *const r109E = nequal(r1034, body.constant(0u));
                                             ir_expression *const r109F = expr(ir_unop_b2i, r109E);
                                             body.emit(assign(r109B, expr(ir_unop_i2u, r109F), 0x01));


                                          body.instructions = f109C_parent_instructions;
                                          body.emit(f109C);

                                          /* END IF */

                                          body.emit(assign(r108B, r109B, 0x01));

                                          body.emit(assign(r108C, body.constant(0u), 0x01));


                                       body.instructions = f1098_parent_instructions;
                                       body.emit(f1098);

                                       /* END IF */


                                    body.instructions = f1096_parent_instructions;
                                    body.emit(f1096);

                                    /* END IF */

                                    body.emit(assign(r108D, body.constant(0u), 0x01));


                                 body.instructions = f1092_parent_instructions;
                                 body.emit(f1092);

                                 /* END IF */

                                 ir_expression *const r10A0 = nequal(r1089, body.constant(0u));
                                 ir_expression *const r10A1 = expr(ir_unop_b2i, r10A0);
                                 ir_expression *const r10A2 = expr(ir_unop_i2u, r10A1);
                                 body.emit(assign(r108B, bit_or(r108B, r10A2), 0x01));


                              body.instructions = f1090_parent_instructions;
                              body.emit(f1090);

                              /* END IF */

                              body.emit(assign(r1073, r108D, 0x01));

                              body.emit(assign(r1074, r108C, 0x01));

                              body.emit(assign(r1075, r108B, 0x01));

                              body.emit(assign(r1072, body.constant(int(0)), 0x01));

                              body.emit(assign(r1078, less(r108B, body.constant(0u)), 0x01));


                           body.instructions = f1087_parent_instructions;
                           body.emit(f1087);

                           /* END IF */


                        body.instructions = f1084_parent_instructions;
                        body.emit(f1084);

                        /* END IF */


                     body.instructions = f107A_parent_instructions;
                     body.emit(f107A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f10A3 = new(mem_ctx) ir_if(operand(r1076).val);
                     exec_list *const f10A3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f10A3->then_instructions;

                        /* IF CONDITION */
                        ir_if *f10A4 = new(mem_ctx) ir_if(operand(r1078).val);
                        exec_list *const f10A4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10A4->then_instructions;

                           ir_variable *const r10A5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r10A5, add(r1074, body.constant(1u)), 0x01));

                           ir_expression *const r10A6 = less(r10A5, r1074);
                           ir_expression *const r10A7 = expr(ir_unop_b2i, r10A6);
                           ir_expression *const r10A8 = expr(ir_unop_i2u, r10A7);
                           body.emit(assign(r1073, add(r1073, r10A8), 0x01));

                           ir_expression *const r10A9 = equal(r1075, body.constant(0u));
                           ir_expression *const r10AA = expr(ir_unop_b2i, r10A9);
                           ir_expression *const r10AB = expr(ir_unop_i2u, r10AA);
                           ir_expression *const r10AC = add(r1075, r10AB);
                           ir_expression *const r10AD = bit_and(r10AC, body.constant(1u));
                           ir_expression *const r10AE = expr(ir_unop_bit_not, r10AD);
                           body.emit(assign(r1074, bit_and(r10A5, r10AE), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10A4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r10B0 = bit_or(r1073, r1074);
                           ir_expression *const r10B1 = equal(r10B0, body.constant(0u));
                           ir_if *f10AF = new(mem_ctx) ir_if(operand(r10B1).val);
                           exec_list *const f10AF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10AF->then_instructions;

                              body.emit(assign(r1072, body.constant(int(0)), 0x01));


                           body.instructions = f10AF_parent_instructions;
                           body.emit(f10AF);

                           /* END IF */


                        body.instructions = f10A4_parent_instructions;
                        body.emit(f10A4);

                        /* END IF */

                        ir_variable *const r10B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r10B2);
                        ir_expression *const r10B3 = lshift(r0DB8, body.constant(int(31)));
                        ir_expression *const r10B4 = expr(ir_unop_i2u, r1072);
                        ir_expression *const r10B5 = lshift(r10B4, body.constant(int(20)));
                        ir_expression *const r10B6 = add(r10B3, r10B5);
                        body.emit(assign(r10B2, add(r10B6, r1073), 0x02));

                        body.emit(assign(r10B2, r1074, 0x01));

                        body.emit(assign(r1077, r10B2, 0x03));

                        body.emit(assign(r1076, body.constant(false), 0x01));


                     body.instructions = f10A3_parent_instructions;
                     body.emit(f10A3);

                     /* END IF */

                     body.emit(assign(r0DB9, r1077, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f102B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r10B8 = less(swizzle_x(r0DBC), swizzle_x(r0DBE));
                     ir_if *f10B7 = new(mem_ctx) ir_if(operand(r10B8).val);
                     exec_list *const f10B7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f10B7->then_instructions;

                        ir_variable *const r10B9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r10BA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r10BA, sub(swizzle_x(r0DBE), swizzle_x(r0DBC)), 0x01));

                        ir_expression *const r10BB = sub(swizzle_y(r0DBE), swizzle_y(r0DBC));
                        ir_expression *const r10BC = less(swizzle_x(r0DBE), swizzle_x(r0DBC));
                        ir_expression *const r10BD = expr(ir_unop_b2i, r10BC);
                        ir_expression *const r10BE = expr(ir_unop_i2u, r10BD);
                        body.emit(assign(r10B9, sub(r10BB, r10BE), 0x01));

                        body.emit(assign(r0DBF, add(r0DBD, body.constant(int(-1))), 0x01));

                        ir_variable *const r10BF = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r10BF, add(r0DBF, body.constant(int(-10))), 0x01));

                        ir_variable *const r10C0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r10C0, r10B9, 0x01));

                        ir_variable *const r10C1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r10C1, r10BA, 0x01));

                        ir_variable *const r10C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r10C2);
                        ir_variable *const r10C3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r10C3);
                        /* IF CONDITION */
                        ir_expression *const r10C5 = equal(r10B9, body.constant(0u));
                        ir_if *f10C4 = new(mem_ctx) ir_if(operand(r10C5).val);
                        exec_list *const f10C4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10C4->then_instructions;

                           body.emit(assign(r10C0, r10BA, 0x01));

                           body.emit(assign(r10C1, body.constant(0u), 0x01));

                           body.emit(assign(r10BF, add(r10BF, body.constant(int(-32))), 0x01));


                        body.instructions = f10C4_parent_instructions;
                        body.emit(f10C4);

                        /* END IF */

                        ir_variable *const r10C6 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r10C6, r10C0, 0x01));

                        ir_variable *const r10C7 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r10C8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r10C8);
                        /* IF CONDITION */
                        ir_expression *const r10CA = equal(r10C0, body.constant(0u));
                        ir_if *f10C9 = new(mem_ctx) ir_if(operand(r10CA).val);
                        exec_list *const f10C9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10C9->then_instructions;

                           body.emit(assign(r10C7, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10C9->else_instructions;

                           body.emit(assign(r10C8, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r10CC = bit_and(r10C0, body.constant(4294901760u));
                           ir_expression *const r10CD = equal(r10CC, body.constant(0u));
                           ir_if *f10CB = new(mem_ctx) ir_if(operand(r10CD).val);
                           exec_list *const f10CB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10CB->then_instructions;

                              body.emit(assign(r10C8, body.constant(int(16)), 0x01));

                              body.emit(assign(r10C6, lshift(r10C0, body.constant(int(16))), 0x01));


                           body.instructions = f10CB_parent_instructions;
                           body.emit(f10CB);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10CF = bit_and(r10C6, body.constant(4278190080u));
                           ir_expression *const r10D0 = equal(r10CF, body.constant(0u));
                           ir_if *f10CE = new(mem_ctx) ir_if(operand(r10D0).val);
                           exec_list *const f10CE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10CE->then_instructions;

                              body.emit(assign(r10C8, add(r10C8, body.constant(int(8))), 0x01));

                              body.emit(assign(r10C6, lshift(r10C6, body.constant(int(8))), 0x01));


                           body.instructions = f10CE_parent_instructions;
                           body.emit(f10CE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D2 = bit_and(r10C6, body.constant(4026531840u));
                           ir_expression *const r10D3 = equal(r10D2, body.constant(0u));
                           ir_if *f10D1 = new(mem_ctx) ir_if(operand(r10D3).val);
                           exec_list *const f10D1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D1->then_instructions;

                              body.emit(assign(r10C8, add(r10C8, body.constant(int(4))), 0x01));

                              body.emit(assign(r10C6, lshift(r10C6, body.constant(int(4))), 0x01));


                           body.instructions = f10D1_parent_instructions;
                           body.emit(f10D1);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D5 = bit_and(r10C6, body.constant(3221225472u));
                           ir_expression *const r10D6 = equal(r10D5, body.constant(0u));
                           ir_if *f10D4 = new(mem_ctx) ir_if(operand(r10D6).val);
                           exec_list *const f10D4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D4->then_instructions;

                              body.emit(assign(r10C8, add(r10C8, body.constant(int(2))), 0x01));

                              body.emit(assign(r10C6, lshift(r10C6, body.constant(int(2))), 0x01));


                           body.instructions = f10D4_parent_instructions;
                           body.emit(f10D4);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D8 = bit_and(r10C6, body.constant(2147483648u));
                           ir_expression *const r10D9 = equal(r10D8, body.constant(0u));
                           ir_if *f10D7 = new(mem_ctx) ir_if(operand(r10D9).val);
                           exec_list *const f10D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D7->then_instructions;

                              body.emit(assign(r10C8, add(r10C8, body.constant(int(1))), 0x01));


                           body.instructions = f10D7_parent_instructions;
                           body.emit(f10D7);

                           /* END IF */

                           body.emit(assign(r10C7, r10C8, 0x01));


                        body.instructions = f10C9_parent_instructions;
                        body.emit(f10C9);

                        /* END IF */

                        body.emit(assign(r10C3, add(r10C7, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r10DB = lequal(body.constant(int(0)), r10C3);
                        ir_if *f10DA = new(mem_ctx) ir_if(operand(r10DB).val);
                        exec_list *const f10DA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10DA->then_instructions;

                           body.emit(assign(r10C2, body.constant(0u), 0x01));

                           ir_variable *const r10DC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r10DC, lshift(r10C1, r10C3), 0x01));

                           ir_variable *const r10DD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r10DF = equal(r10C3, body.constant(int(0)));
                           ir_if *f10DE = new(mem_ctx) ir_if(operand(r10DF).val);
                           exec_list *const f10DE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10DE->then_instructions;

                              body.emit(assign(r10DD, r10C0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f10DE->else_instructions;

                              ir_expression *const r10E0 = lshift(r10C0, r10C3);
                              ir_expression *const r10E1 = neg(r10C3);
                              ir_expression *const r10E2 = bit_and(r10E1, body.constant(int(31)));
                              ir_expression *const r10E3 = rshift(r10C1, r10E2);
                              body.emit(assign(r10DD, bit_or(r10E0, r10E3), 0x01));


                           body.instructions = f10DE_parent_instructions;
                           body.emit(f10DE);

                           /* END IF */

                           body.emit(assign(r10C0, r10DD, 0x01));

                           body.emit(assign(r10C1, r10DC, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10DA->else_instructions;

                           ir_variable *const r10E4 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r10E4, body.constant(0u), 0x01));

                           ir_variable *const r10E5 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r10E5, neg(r10C3), 0x01));

                           ir_variable *const r10E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r10E6);
                           ir_variable *const r10E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r10E7);
                           ir_variable *const r10E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r10E8);
                           ir_variable *const r10E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r10EA = neg(r10E5);
                           body.emit(assign(r10E9, bit_and(r10EA, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r10EC = equal(r10E5, body.constant(int(0)));
                           ir_if *f10EB = new(mem_ctx) ir_if(operand(r10EC).val);
                           exec_list *const f10EB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10EB->then_instructions;

                              body.emit(assign(r10E6, r10E4, 0x01));

                              body.emit(assign(r10E7, r10C1, 0x01));

                              body.emit(assign(r10E8, r10C0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f10EB->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r10EE = less(r10E5, body.constant(int(32)));
                              ir_if *f10ED = new(mem_ctx) ir_if(operand(r10EE).val);
                              exec_list *const f10ED_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f10ED->then_instructions;

                                 body.emit(assign(r10E6, lshift(r10C1, r10E9), 0x01));

                                 ir_expression *const r10EF = lshift(r10C0, r10E9);
                                 ir_expression *const r10F0 = rshift(r10C1, r10E5);
                                 body.emit(assign(r10E7, bit_or(r10EF, r10F0), 0x01));

                                 body.emit(assign(r10E8, rshift(r10C0, r10E5), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f10ED->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r10F2 = equal(r10E5, body.constant(int(32)));
                                 ir_if *f10F1 = new(mem_ctx) ir_if(operand(r10F2).val);
                                 exec_list *const f10F1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f10F1->then_instructions;

                                    body.emit(assign(r10E6, r10C1, 0x01));

                                    body.emit(assign(r10E7, r10C0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f10F1->else_instructions;

                                    body.emit(assign(r10E4, bit_or(body.constant(0u), r10C1), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r10F4 = less(r10E5, body.constant(int(64)));
                                    ir_if *f10F3 = new(mem_ctx) ir_if(operand(r10F4).val);
                                    exec_list *const f10F3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f10F3->then_instructions;

                                       body.emit(assign(r10E6, lshift(r10C0, r10E9), 0x01));

                                       ir_expression *const r10F5 = bit_and(r10E5, body.constant(int(31)));
                                       body.emit(assign(r10E7, rshift(r10C0, r10F5), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f10F3->else_instructions;

                                       ir_variable *const r10F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r10F8 = equal(r10E5, body.constant(int(64)));
                                       ir_if *f10F7 = new(mem_ctx) ir_if(operand(r10F8).val);
                                       exec_list *const f10F7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f10F7->then_instructions;

                                          body.emit(assign(r10F6, r10C0, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f10F7->else_instructions;

                                          ir_expression *const r10F9 = nequal(r10C0, body.constant(0u));
                                          ir_expression *const r10FA = expr(ir_unop_b2i, r10F9);
                                          body.emit(assign(r10F6, expr(ir_unop_i2u, r10FA), 0x01));


                                       body.instructions = f10F7_parent_instructions;
                                       body.emit(f10F7);

                                       /* END IF */

                                       body.emit(assign(r10E6, r10F6, 0x01));

                                       body.emit(assign(r10E7, body.constant(0u), 0x01));


                                    body.instructions = f10F3_parent_instructions;
                                    body.emit(f10F3);

                                    /* END IF */


                                 body.instructions = f10F1_parent_instructions;
                                 body.emit(f10F1);

                                 /* END IF */

                                 body.emit(assign(r10E8, body.constant(0u), 0x01));


                              body.instructions = f10ED_parent_instructions;
                              body.emit(f10ED);

                              /* END IF */

                              ir_expression *const r10FB = nequal(r10E4, body.constant(0u));
                              ir_expression *const r10FC = expr(ir_unop_b2i, r10FB);
                              ir_expression *const r10FD = expr(ir_unop_i2u, r10FC);
                              body.emit(assign(r10E6, bit_or(r10E6, r10FD), 0x01));


                           body.instructions = f10EB_parent_instructions;
                           body.emit(f10EB);

                           /* END IF */

                           body.emit(assign(r10C0, r10E8, 0x01));

                           body.emit(assign(r10C1, r10E7, 0x01));

                           body.emit(assign(r10C2, r10E6, 0x01));


                        body.instructions = f10DA_parent_instructions;
                        body.emit(f10DA);

                        /* END IF */

                        body.emit(assign(r10BF, sub(r10BF, r10C3), 0x01));

                        ir_variable *const r10FE = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r10FE, r10BF, 0x01));

                        ir_variable *const r10FF = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r10FF, r10C0, 0x01));

                        ir_variable *const r1100 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1100, r10C1, 0x01));

                        ir_variable *const r1101 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r1101, r10C2, 0x01));

                        ir_variable *const r1102 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r1102, body.constant(true), 0x01));

                        ir_variable *const r1103 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r1104 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r1104);
                        ir_expression *const r1105 = expr(ir_unop_u2i, r10C2);
                        body.emit(assign(r1104, less(r1105, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1107 = lequal(body.constant(int(2045)), r10BF);
                        ir_if *f1106 = new(mem_ctx) ir_if(operand(r1107).val);
                        exec_list *const f1106_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1106->then_instructions;

                           ir_variable *const r1108 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r110A = less(body.constant(int(2045)), r10BF);
                           ir_if *f1109 = new(mem_ctx) ir_if(operand(r110A).val);
                           exec_list *const f1109_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1109->then_instructions;

                              body.emit(assign(r1108, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1109->else_instructions;

                              ir_variable *const r110B = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r110D = equal(r10BF, body.constant(int(2045)));
                              ir_if *f110C = new(mem_ctx) ir_if(operand(r110D).val);
                              exec_list *const f110C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f110C->then_instructions;

                                 ir_expression *const r110E = equal(body.constant(2097151u), r10C0);
                                 ir_expression *const r110F = equal(body.constant(4294967295u), r10C1);
                                 body.emit(assign(r110B, logic_and(r110E, r110F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f110C->else_instructions;

                                 body.emit(assign(r110B, body.constant(false), 0x01));


                              body.instructions = f110C_parent_instructions;
                              body.emit(f110C);

                              /* END IF */

                              body.emit(assign(r1108, logic_and(r110B, r1104), 0x01));


                           body.instructions = f1109_parent_instructions;
                           body.emit(f1109);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1110 = new(mem_ctx) ir_if(operand(r1108).val);
                           exec_list *const f1110_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1110->then_instructions;

                              ir_variable *const r1111 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1111);
                              ir_expression *const r1112 = lshift(r0DB8, body.constant(int(31)));
                              body.emit(assign(r1111, add(r1112, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r1111, body.constant(0u), 0x01));

                              body.emit(assign(r1103, r1111, 0x03));

                              body.emit(assign(r1102, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1110->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1114 = less(r10BF, body.constant(int(0)));
                              ir_if *f1113 = new(mem_ctx) ir_if(operand(r1114).val);
                              exec_list *const f1113_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1113->then_instructions;

                                 ir_variable *const r1115 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1115, r10C2, 0x01));

                                 ir_variable *const r1116 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1116, neg(r10BF), 0x01));

                                 ir_variable *const r1117 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1117);
                                 ir_variable *const r1118 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1118);
                                 ir_variable *const r1119 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1119);
                                 ir_variable *const r111A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r111B = neg(r1116);
                                 body.emit(assign(r111A, bit_and(r111B, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r111D = equal(r1116, body.constant(int(0)));
                                 ir_if *f111C = new(mem_ctx) ir_if(operand(r111D).val);
                                 exec_list *const f111C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f111C->then_instructions;

                                    body.emit(assign(r1117, r10C2, 0x01));

                                    body.emit(assign(r1118, r10C1, 0x01));

                                    body.emit(assign(r1119, r10C0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f111C->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r111F = less(r1116, body.constant(int(32)));
                                    ir_if *f111E = new(mem_ctx) ir_if(operand(r111F).val);
                                    exec_list *const f111E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f111E->then_instructions;

                                       body.emit(assign(r1117, lshift(r10C1, r111A), 0x01));

                                       ir_expression *const r1120 = lshift(r10C0, r111A);
                                       ir_expression *const r1121 = rshift(r10C1, r1116);
                                       body.emit(assign(r1118, bit_or(r1120, r1121), 0x01));

                                       body.emit(assign(r1119, rshift(r10C0, r1116), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f111E->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1123 = equal(r1116, body.constant(int(32)));
                                       ir_if *f1122 = new(mem_ctx) ir_if(operand(r1123).val);
                                       exec_list *const f1122_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1122->then_instructions;

                                          body.emit(assign(r1117, r10C1, 0x01));

                                          body.emit(assign(r1118, r10C0, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1122->else_instructions;

                                          body.emit(assign(r1115, bit_or(r10C2, r10C1), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1125 = less(r1116, body.constant(int(64)));
                                          ir_if *f1124 = new(mem_ctx) ir_if(operand(r1125).val);
                                          exec_list *const f1124_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1124->then_instructions;

                                             body.emit(assign(r1117, lshift(r10C0, r111A), 0x01));

                                             ir_expression *const r1126 = bit_and(r1116, body.constant(int(31)));
                                             body.emit(assign(r1118, rshift(r10C0, r1126), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1124->else_instructions;

                                             ir_variable *const r1127 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1129 = equal(r1116, body.constant(int(64)));
                                             ir_if *f1128 = new(mem_ctx) ir_if(operand(r1129).val);
                                             exec_list *const f1128_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1128->then_instructions;

                                                body.emit(assign(r1127, r10C0, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1128->else_instructions;

                                                ir_expression *const r112A = nequal(r10C0, body.constant(0u));
                                                ir_expression *const r112B = expr(ir_unop_b2i, r112A);
                                                body.emit(assign(r1127, expr(ir_unop_i2u, r112B), 0x01));


                                             body.instructions = f1128_parent_instructions;
                                             body.emit(f1128);

                                             /* END IF */

                                             body.emit(assign(r1117, r1127, 0x01));

                                             body.emit(assign(r1118, body.constant(0u), 0x01));


                                          body.instructions = f1124_parent_instructions;
                                          body.emit(f1124);

                                          /* END IF */


                                       body.instructions = f1122_parent_instructions;
                                       body.emit(f1122);

                                       /* END IF */

                                       body.emit(assign(r1119, body.constant(0u), 0x01));


                                    body.instructions = f111E_parent_instructions;
                                    body.emit(f111E);

                                    /* END IF */

                                    ir_expression *const r112C = nequal(r1115, body.constant(0u));
                                    ir_expression *const r112D = expr(ir_unop_b2i, r112C);
                                    ir_expression *const r112E = expr(ir_unop_i2u, r112D);
                                    body.emit(assign(r1117, bit_or(r1117, r112E), 0x01));


                                 body.instructions = f111C_parent_instructions;
                                 body.emit(f111C);

                                 /* END IF */

                                 body.emit(assign(r10FF, r1119, 0x01));

                                 body.emit(assign(r1100, r1118, 0x01));

                                 body.emit(assign(r1101, r1117, 0x01));

                                 body.emit(assign(r10FE, body.constant(int(0)), 0x01));

                                 body.emit(assign(r1104, less(r1117, body.constant(0u)), 0x01));


                              body.instructions = f1113_parent_instructions;
                              body.emit(f1113);

                              /* END IF */


                           body.instructions = f1110_parent_instructions;
                           body.emit(f1110);

                           /* END IF */


                        body.instructions = f1106_parent_instructions;
                        body.emit(f1106);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f112F = new(mem_ctx) ir_if(operand(r1102).val);
                        exec_list *const f112F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f112F->then_instructions;

                           /* IF CONDITION */
                           ir_if *f1130 = new(mem_ctx) ir_if(operand(r1104).val);
                           exec_list *const f1130_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1130->then_instructions;

                              ir_variable *const r1131 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r1131, add(r1100, body.constant(1u)), 0x01));

                              ir_expression *const r1132 = less(r1131, r1100);
                              ir_expression *const r1133 = expr(ir_unop_b2i, r1132);
                              ir_expression *const r1134 = expr(ir_unop_i2u, r1133);
                              body.emit(assign(r10FF, add(r10FF, r1134), 0x01));

                              ir_expression *const r1135 = equal(r1101, body.constant(0u));
                              ir_expression *const r1136 = expr(ir_unop_b2i, r1135);
                              ir_expression *const r1137 = expr(ir_unop_i2u, r1136);
                              ir_expression *const r1138 = add(r1101, r1137);
                              ir_expression *const r1139 = bit_and(r1138, body.constant(1u));
                              ir_expression *const r113A = expr(ir_unop_bit_not, r1139);
                              body.emit(assign(r1100, bit_and(r1131, r113A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1130->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r113C = bit_or(r10FF, r1100);
                              ir_expression *const r113D = equal(r113C, body.constant(0u));
                              ir_if *f113B = new(mem_ctx) ir_if(operand(r113D).val);
                              exec_list *const f113B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f113B->then_instructions;

                                 body.emit(assign(r10FE, body.constant(int(0)), 0x01));


                              body.instructions = f113B_parent_instructions;
                              body.emit(f113B);

                              /* END IF */


                           body.instructions = f1130_parent_instructions;
                           body.emit(f1130);

                           /* END IF */

                           ir_variable *const r113E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r113E);
                           ir_expression *const r113F = lshift(r0DB8, body.constant(int(31)));
                           ir_expression *const r1140 = expr(ir_unop_i2u, r10FE);
                           ir_expression *const r1141 = lshift(r1140, body.constant(int(20)));
                           ir_expression *const r1142 = add(r113F, r1141);
                           body.emit(assign(r113E, add(r1142, r10FF), 0x02));

                           body.emit(assign(r113E, r1100, 0x01));

                           body.emit(assign(r1103, r113E, 0x03));

                           body.emit(assign(r1102, body.constant(false), 0x01));


                        body.instructions = f112F_parent_instructions;
                        body.emit(f112F);

                        /* END IF */

                        body.emit(assign(r0DB9, r1103, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f10B7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1144 = less(swizzle_x(r0DBE), swizzle_x(r0DBC));
                        ir_if *f1143 = new(mem_ctx) ir_if(operand(r1144).val);
                        exec_list *const f1143_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1143->then_instructions;

                           ir_variable *const r1145 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r1146 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1146, sub(swizzle_x(r0DBC), swizzle_x(r0DBE)), 0x01));

                           ir_expression *const r1147 = sub(swizzle_y(r0DBC), swizzle_y(r0DBE));
                           ir_expression *const r1148 = less(swizzle_x(r0DBC), swizzle_x(r0DBE));
                           ir_expression *const r1149 = expr(ir_unop_b2i, r1148);
                           ir_expression *const r114A = expr(ir_unop_i2u, r1149);
                           body.emit(assign(r1145, sub(r1147, r114A), 0x01));

                           body.emit(assign(r0DB8, bit_xor(r0DB8, body.constant(1u)), 0x01));

                           body.emit(assign(r0DBF, add(r0DBB, body.constant(int(-1))), 0x01));

                           ir_variable *const r114B = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r114B, add(r0DBF, body.constant(int(-10))), 0x01));

                           ir_variable *const r114C = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r114C, r1145, 0x01));

                           ir_variable *const r114D = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r114D, r1146, 0x01));

                           ir_variable *const r114E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r114E);
                           ir_variable *const r114F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r114F);
                           /* IF CONDITION */
                           ir_expression *const r1151 = equal(r1145, body.constant(0u));
                           ir_if *f1150 = new(mem_ctx) ir_if(operand(r1151).val);
                           exec_list *const f1150_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1150->then_instructions;

                              body.emit(assign(r114C, r1146, 0x01));

                              body.emit(assign(r114D, body.constant(0u), 0x01));

                              body.emit(assign(r114B, add(r114B, body.constant(int(-32))), 0x01));


                           body.instructions = f1150_parent_instructions;
                           body.emit(f1150);

                           /* END IF */

                           ir_variable *const r1152 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r1152, r114C, 0x01));

                           ir_variable *const r1153 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r1154 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1154);
                           /* IF CONDITION */
                           ir_expression *const r1156 = equal(r114C, body.constant(0u));
                           ir_if *f1155 = new(mem_ctx) ir_if(operand(r1156).val);
                           exec_list *const f1155_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1155->then_instructions;

                              body.emit(assign(r1153, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1155->else_instructions;

                              body.emit(assign(r1154, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1158 = bit_and(r114C, body.constant(4294901760u));
                              ir_expression *const r1159 = equal(r1158, body.constant(0u));
                              ir_if *f1157 = new(mem_ctx) ir_if(operand(r1159).val);
                              exec_list *const f1157_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1157->then_instructions;

                                 body.emit(assign(r1154, body.constant(int(16)), 0x01));

                                 body.emit(assign(r1152, lshift(r114C, body.constant(int(16))), 0x01));


                              body.instructions = f1157_parent_instructions;
                              body.emit(f1157);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r115B = bit_and(r1152, body.constant(4278190080u));
                              ir_expression *const r115C = equal(r115B, body.constant(0u));
                              ir_if *f115A = new(mem_ctx) ir_if(operand(r115C).val);
                              exec_list *const f115A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f115A->then_instructions;

                                 body.emit(assign(r1154, add(r1154, body.constant(int(8))), 0x01));

                                 body.emit(assign(r1152, lshift(r1152, body.constant(int(8))), 0x01));


                              body.instructions = f115A_parent_instructions;
                              body.emit(f115A);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r115E = bit_and(r1152, body.constant(4026531840u));
                              ir_expression *const r115F = equal(r115E, body.constant(0u));
                              ir_if *f115D = new(mem_ctx) ir_if(operand(r115F).val);
                              exec_list *const f115D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f115D->then_instructions;

                                 body.emit(assign(r1154, add(r1154, body.constant(int(4))), 0x01));

                                 body.emit(assign(r1152, lshift(r1152, body.constant(int(4))), 0x01));


                              body.instructions = f115D_parent_instructions;
                              body.emit(f115D);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1161 = bit_and(r1152, body.constant(3221225472u));
                              ir_expression *const r1162 = equal(r1161, body.constant(0u));
                              ir_if *f1160 = new(mem_ctx) ir_if(operand(r1162).val);
                              exec_list *const f1160_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1160->then_instructions;

                                 body.emit(assign(r1154, add(r1154, body.constant(int(2))), 0x01));

                                 body.emit(assign(r1152, lshift(r1152, body.constant(int(2))), 0x01));


                              body.instructions = f1160_parent_instructions;
                              body.emit(f1160);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1164 = bit_and(r1152, body.constant(2147483648u));
                              ir_expression *const r1165 = equal(r1164, body.constant(0u));
                              ir_if *f1163 = new(mem_ctx) ir_if(operand(r1165).val);
                              exec_list *const f1163_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1163->then_instructions;

                                 body.emit(assign(r1154, add(r1154, body.constant(int(1))), 0x01));


                              body.instructions = f1163_parent_instructions;
                              body.emit(f1163);

                              /* END IF */

                              body.emit(assign(r1153, r1154, 0x01));


                           body.instructions = f1155_parent_instructions;
                           body.emit(f1155);

                           /* END IF */

                           body.emit(assign(r114F, add(r1153, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1167 = lequal(body.constant(int(0)), r114F);
                           ir_if *f1166 = new(mem_ctx) ir_if(operand(r1167).val);
                           exec_list *const f1166_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1166->then_instructions;

                              body.emit(assign(r114E, body.constant(0u), 0x01));

                              ir_variable *const r1168 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1168, lshift(r114D, r114F), 0x01));

                              ir_variable *const r1169 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r116B = equal(r114F, body.constant(int(0)));
                              ir_if *f116A = new(mem_ctx) ir_if(operand(r116B).val);
                              exec_list *const f116A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f116A->then_instructions;

                                 body.emit(assign(r1169, r114C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f116A->else_instructions;

                                 ir_expression *const r116C = lshift(r114C, r114F);
                                 ir_expression *const r116D = neg(r114F);
                                 ir_expression *const r116E = bit_and(r116D, body.constant(int(31)));
                                 ir_expression *const r116F = rshift(r114D, r116E);
                                 body.emit(assign(r1169, bit_or(r116C, r116F), 0x01));


                              body.instructions = f116A_parent_instructions;
                              body.emit(f116A);

                              /* END IF */

                              body.emit(assign(r114C, r1169, 0x01));

                              body.emit(assign(r114D, r1168, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1166->else_instructions;

                              ir_variable *const r1170 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1170, body.constant(0u), 0x01));

                              ir_variable *const r1171 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1171, neg(r114F), 0x01));

                              ir_variable *const r1172 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1172);
                              ir_variable *const r1173 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1173);
                              ir_variable *const r1174 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1174);
                              ir_variable *const r1175 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1176 = neg(r1171);
                              body.emit(assign(r1175, bit_and(r1176, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1178 = equal(r1171, body.constant(int(0)));
                              ir_if *f1177 = new(mem_ctx) ir_if(operand(r1178).val);
                              exec_list *const f1177_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1177->then_instructions;

                                 body.emit(assign(r1172, r1170, 0x01));

                                 body.emit(assign(r1173, r114D, 0x01));

                                 body.emit(assign(r1174, r114C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1177->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r117A = less(r1171, body.constant(int(32)));
                                 ir_if *f1179 = new(mem_ctx) ir_if(operand(r117A).val);
                                 exec_list *const f1179_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1179->then_instructions;

                                    body.emit(assign(r1172, lshift(r114D, r1175), 0x01));

                                    ir_expression *const r117B = lshift(r114C, r1175);
                                    ir_expression *const r117C = rshift(r114D, r1171);
                                    body.emit(assign(r1173, bit_or(r117B, r117C), 0x01));

                                    body.emit(assign(r1174, rshift(r114C, r1171), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1179->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r117E = equal(r1171, body.constant(int(32)));
                                    ir_if *f117D = new(mem_ctx) ir_if(operand(r117E).val);
                                    exec_list *const f117D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f117D->then_instructions;

                                       body.emit(assign(r1172, r114D, 0x01));

                                       body.emit(assign(r1173, r114C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f117D->else_instructions;

                                       body.emit(assign(r1170, bit_or(body.constant(0u), r114D), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1180 = less(r1171, body.constant(int(64)));
                                       ir_if *f117F = new(mem_ctx) ir_if(operand(r1180).val);
                                       exec_list *const f117F_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f117F->then_instructions;

                                          body.emit(assign(r1172, lshift(r114C, r1175), 0x01));

                                          ir_expression *const r1181 = bit_and(r1171, body.constant(int(31)));
                                          body.emit(assign(r1173, rshift(r114C, r1181), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f117F->else_instructions;

                                          ir_variable *const r1182 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1184 = equal(r1171, body.constant(int(64)));
                                          ir_if *f1183 = new(mem_ctx) ir_if(operand(r1184).val);
                                          exec_list *const f1183_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1183->then_instructions;

                                             body.emit(assign(r1182, r114C, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1183->else_instructions;

                                             ir_expression *const r1185 = nequal(r114C, body.constant(0u));
                                             ir_expression *const r1186 = expr(ir_unop_b2i, r1185);
                                             body.emit(assign(r1182, expr(ir_unop_i2u, r1186), 0x01));


                                          body.instructions = f1183_parent_instructions;
                                          body.emit(f1183);

                                          /* END IF */

                                          body.emit(assign(r1172, r1182, 0x01));

                                          body.emit(assign(r1173, body.constant(0u), 0x01));


                                       body.instructions = f117F_parent_instructions;
                                       body.emit(f117F);

                                       /* END IF */


                                    body.instructions = f117D_parent_instructions;
                                    body.emit(f117D);

                                    /* END IF */

                                    body.emit(assign(r1174, body.constant(0u), 0x01));


                                 body.instructions = f1179_parent_instructions;
                                 body.emit(f1179);

                                 /* END IF */

                                 ir_expression *const r1187 = nequal(r1170, body.constant(0u));
                                 ir_expression *const r1188 = expr(ir_unop_b2i, r1187);
                                 ir_expression *const r1189 = expr(ir_unop_i2u, r1188);
                                 body.emit(assign(r1172, bit_or(r1172, r1189), 0x01));


                              body.instructions = f1177_parent_instructions;
                              body.emit(f1177);

                              /* END IF */

                              body.emit(assign(r114C, r1174, 0x01));

                              body.emit(assign(r114D, r1173, 0x01));

                              body.emit(assign(r114E, r1172, 0x01));


                           body.instructions = f1166_parent_instructions;
                           body.emit(f1166);

                           /* END IF */

                           body.emit(assign(r114B, sub(r114B, r114F), 0x01));

                           ir_variable *const r118A = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r118A, r114B, 0x01));

                           ir_variable *const r118B = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r118B, r114C, 0x01));

                           ir_variable *const r118C = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r118C, r114D, 0x01));

                           ir_variable *const r118D = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r118D, r114E, 0x01));

                           ir_variable *const r118E = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r118E, body.constant(true), 0x01));

                           ir_variable *const r118F = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r1190 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r1190);
                           ir_expression *const r1191 = expr(ir_unop_u2i, r114E);
                           body.emit(assign(r1190, less(r1191, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1193 = lequal(body.constant(int(2045)), r114B);
                           ir_if *f1192 = new(mem_ctx) ir_if(operand(r1193).val);
                           exec_list *const f1192_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1192->then_instructions;

                              ir_variable *const r1194 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1196 = less(body.constant(int(2045)), r114B);
                              ir_if *f1195 = new(mem_ctx) ir_if(operand(r1196).val);
                              exec_list *const f1195_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1195->then_instructions;

                                 body.emit(assign(r1194, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1195->else_instructions;

                                 ir_variable *const r1197 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1199 = equal(r114B, body.constant(int(2045)));
                                 ir_if *f1198 = new(mem_ctx) ir_if(operand(r1199).val);
                                 exec_list *const f1198_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1198->then_instructions;

                                    ir_expression *const r119A = equal(body.constant(2097151u), r114C);
                                    ir_expression *const r119B = equal(body.constant(4294967295u), r114D);
                                    body.emit(assign(r1197, logic_and(r119A, r119B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1198->else_instructions;

                                    body.emit(assign(r1197, body.constant(false), 0x01));


                                 body.instructions = f1198_parent_instructions;
                                 body.emit(f1198);

                                 /* END IF */

                                 body.emit(assign(r1194, logic_and(r1197, r1190), 0x01));


                              body.instructions = f1195_parent_instructions;
                              body.emit(f1195);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f119C = new(mem_ctx) ir_if(operand(r1194).val);
                              exec_list *const f119C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f119C->then_instructions;

                                 ir_variable *const r119D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r119D);
                                 ir_expression *const r119E = lshift(r0DB8, body.constant(int(31)));
                                 body.emit(assign(r119D, add(r119E, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r119D, body.constant(0u), 0x01));

                                 body.emit(assign(r118F, r119D, 0x03));

                                 body.emit(assign(r118E, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f119C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r11A0 = less(r114B, body.constant(int(0)));
                                 ir_if *f119F = new(mem_ctx) ir_if(operand(r11A0).val);
                                 exec_list *const f119F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f119F->then_instructions;

                                    ir_variable *const r11A1 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r11A1, r114E, 0x01));

                                    ir_variable *const r11A2 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r11A2, neg(r114B), 0x01));

                                    ir_variable *const r11A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r11A3);
                                    ir_variable *const r11A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r11A4);
                                    ir_variable *const r11A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r11A5);
                                    ir_variable *const r11A6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r11A7 = neg(r11A2);
                                    body.emit(assign(r11A6, bit_and(r11A7, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r11A9 = equal(r11A2, body.constant(int(0)));
                                    ir_if *f11A8 = new(mem_ctx) ir_if(operand(r11A9).val);
                                    exec_list *const f11A8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f11A8->then_instructions;

                                       body.emit(assign(r11A3, r114E, 0x01));

                                       body.emit(assign(r11A4, r114D, 0x01));

                                       body.emit(assign(r11A5, r114C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f11A8->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r11AB = less(r11A2, body.constant(int(32)));
                                       ir_if *f11AA = new(mem_ctx) ir_if(operand(r11AB).val);
                                       exec_list *const f11AA_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f11AA->then_instructions;

                                          body.emit(assign(r11A3, lshift(r114D, r11A6), 0x01));

                                          ir_expression *const r11AC = lshift(r114C, r11A6);
                                          ir_expression *const r11AD = rshift(r114D, r11A2);
                                          body.emit(assign(r11A4, bit_or(r11AC, r11AD), 0x01));

                                          body.emit(assign(r11A5, rshift(r114C, r11A2), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f11AA->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r11AF = equal(r11A2, body.constant(int(32)));
                                          ir_if *f11AE = new(mem_ctx) ir_if(operand(r11AF).val);
                                          exec_list *const f11AE_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f11AE->then_instructions;

                                             body.emit(assign(r11A3, r114D, 0x01));

                                             body.emit(assign(r11A4, r114C, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f11AE->else_instructions;

                                             body.emit(assign(r11A1, bit_or(r114E, r114D), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r11B1 = less(r11A2, body.constant(int(64)));
                                             ir_if *f11B0 = new(mem_ctx) ir_if(operand(r11B1).val);
                                             exec_list *const f11B0_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f11B0->then_instructions;

                                                body.emit(assign(r11A3, lshift(r114C, r11A6), 0x01));

                                                ir_expression *const r11B2 = bit_and(r11A2, body.constant(int(31)));
                                                body.emit(assign(r11A4, rshift(r114C, r11B2), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f11B0->else_instructions;

                                                ir_variable *const r11B3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r11B5 = equal(r11A2, body.constant(int(64)));
                                                ir_if *f11B4 = new(mem_ctx) ir_if(operand(r11B5).val);
                                                exec_list *const f11B4_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f11B4->then_instructions;

                                                   body.emit(assign(r11B3, r114C, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f11B4->else_instructions;

                                                   ir_expression *const r11B6 = nequal(r114C, body.constant(0u));
                                                   ir_expression *const r11B7 = expr(ir_unop_b2i, r11B6);
                                                   body.emit(assign(r11B3, expr(ir_unop_i2u, r11B7), 0x01));


                                                body.instructions = f11B4_parent_instructions;
                                                body.emit(f11B4);

                                                /* END IF */

                                                body.emit(assign(r11A3, r11B3, 0x01));

                                                body.emit(assign(r11A4, body.constant(0u), 0x01));


                                             body.instructions = f11B0_parent_instructions;
                                             body.emit(f11B0);

                                             /* END IF */


                                          body.instructions = f11AE_parent_instructions;
                                          body.emit(f11AE);

                                          /* END IF */

                                          body.emit(assign(r11A5, body.constant(0u), 0x01));


                                       body.instructions = f11AA_parent_instructions;
                                       body.emit(f11AA);

                                       /* END IF */

                                       ir_expression *const r11B8 = nequal(r11A1, body.constant(0u));
                                       ir_expression *const r11B9 = expr(ir_unop_b2i, r11B8);
                                       ir_expression *const r11BA = expr(ir_unop_i2u, r11B9);
                                       body.emit(assign(r11A3, bit_or(r11A3, r11BA), 0x01));


                                    body.instructions = f11A8_parent_instructions;
                                    body.emit(f11A8);

                                    /* END IF */

                                    body.emit(assign(r118B, r11A5, 0x01));

                                    body.emit(assign(r118C, r11A4, 0x01));

                                    body.emit(assign(r118D, r11A3, 0x01));

                                    body.emit(assign(r118A, body.constant(int(0)), 0x01));

                                    body.emit(assign(r1190, less(r11A3, body.constant(0u)), 0x01));


                                 body.instructions = f119F_parent_instructions;
                                 body.emit(f119F);

                                 /* END IF */


                              body.instructions = f119C_parent_instructions;
                              body.emit(f119C);

                              /* END IF */


                           body.instructions = f1192_parent_instructions;
                           body.emit(f1192);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f11BB = new(mem_ctx) ir_if(operand(r118E).val);
                           exec_list *const f11BB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f11BB->then_instructions;

                              /* IF CONDITION */
                              ir_if *f11BC = new(mem_ctx) ir_if(operand(r1190).val);
                              exec_list *const f11BC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f11BC->then_instructions;

                                 ir_variable *const r11BD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r11BD, add(r118C, body.constant(1u)), 0x01));

                                 ir_expression *const r11BE = less(r11BD, r118C);
                                 ir_expression *const r11BF = expr(ir_unop_b2i, r11BE);
                                 ir_expression *const r11C0 = expr(ir_unop_i2u, r11BF);
                                 body.emit(assign(r118B, add(r118B, r11C0), 0x01));

                                 ir_expression *const r11C1 = equal(r118D, body.constant(0u));
                                 ir_expression *const r11C2 = expr(ir_unop_b2i, r11C1);
                                 ir_expression *const r11C3 = expr(ir_unop_i2u, r11C2);
                                 ir_expression *const r11C4 = add(r118D, r11C3);
                                 ir_expression *const r11C5 = bit_and(r11C4, body.constant(1u));
                                 ir_expression *const r11C6 = expr(ir_unop_bit_not, r11C5);
                                 body.emit(assign(r118C, bit_and(r11BD, r11C6), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f11BC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r11C8 = bit_or(r118B, r118C);
                                 ir_expression *const r11C9 = equal(r11C8, body.constant(0u));
                                 ir_if *f11C7 = new(mem_ctx) ir_if(operand(r11C9).val);
                                 exec_list *const f11C7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f11C7->then_instructions;

                                    body.emit(assign(r118A, body.constant(int(0)), 0x01));


                                 body.instructions = f11C7_parent_instructions;
                                 body.emit(f11C7);

                                 /* END IF */


                              body.instructions = f11BC_parent_instructions;
                              body.emit(f11BC);

                              /* END IF */

                              ir_variable *const r11CA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r11CA);
                              ir_expression *const r11CB = lshift(r0DB8, body.constant(int(31)));
                              ir_expression *const r11CC = expr(ir_unop_i2u, r118A);
                              ir_expression *const r11CD = lshift(r11CC, body.constant(int(20)));
                              ir_expression *const r11CE = add(r11CB, r11CD);
                              body.emit(assign(r11CA, add(r11CE, r118B), 0x02));

                              body.emit(assign(r11CA, r118C, 0x01));

                              body.emit(assign(r118F, r11CA, 0x03));

                              body.emit(assign(r118E, body.constant(false), 0x01));


                           body.instructions = f11BB_parent_instructions;
                           body.emit(f11BB);

                           /* END IF */

                           body.emit(assign(r0DB9, r118F, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1143->else_instructions;

                           ir_variable *const r11CF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r11CF);
                           body.emit(assign(r11CF, body.constant(0u), 0x02));

                           body.emit(assign(r11CF, body.constant(0u), 0x01));

                           body.emit(assign(r0DB9, r11CF, 0x03));


                        body.instructions = f1143_parent_instructions;
                        body.emit(f1143);

                        /* END IF */


                     body.instructions = f10B7_parent_instructions;
                     body.emit(f10B7);

                     /* END IF */


                  body.instructions = f102B_parent_instructions;
                  body.emit(f102B);

                  /* END IF */


               body.instructions = f0F9F_parent_instructions;
               body.emit(f0F9F);

               /* END IF */


            body.instructions = f0F78_parent_instructions;
            body.emit(f0F78);

            /* END IF */


         body.instructions = f0EA2_parent_instructions;
         body.emit(f0EA2);

         /* END IF */


      body.instructions = f0DD0_parent_instructions;
      body.emit(f0DD0);

      /* END IF */

      body.emit(assign(r0DB3, r0DB9, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0DB6->else_instructions;

      ir_variable *const r11D0 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r11D0, body.constant(true), 0x01));

      ir_variable *const r11D1 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r11D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r11D2);
      ir_variable *const r11D3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r11D3);
      ir_variable *const r11D4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r11D4);
      ir_variable *const r11D5 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r11D5);
      ir_variable *const r11D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r11D6);
      ir_variable *const r11D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r11D7);
      body.emit(assign(r11D7, body.constant(0u), 0x01));

      body.emit(assign(r11D6, body.constant(0u), 0x01));

      ir_variable *const r11D8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r11D8);
      body.emit(assign(r11D8, bit_and(swizzle_y(r0DB1), body.constant(1048575u)), 0x02));

      body.emit(assign(r11D8, swizzle_x(r0DB1), 0x01));

      body.emit(assign(r11D4, r11D8, 0x03));

      ir_variable *const r11D9 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r11DA = rshift(swizzle_y(r0DB1), body.constant(int(20)));
      ir_expression *const r11DB = bit_and(r11DA, body.constant(2047u));
      body.emit(assign(r11D9, expr(ir_unop_u2i, r11DB), 0x01));

      ir_variable *const r11DC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r11DC);
      body.emit(assign(r11DC, bit_and(swizzle_y(r0DB2), body.constant(1048575u)), 0x02));

      body.emit(assign(r11DC, swizzle_x(r0DB2), 0x01));

      body.emit(assign(r11D3, r11DC, 0x03));

      ir_variable *const r11DD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r11DE = rshift(swizzle_y(r0DB2), body.constant(int(20)));
      ir_expression *const r11DF = bit_and(r11DE, body.constant(2047u));
      body.emit(assign(r11DD, expr(ir_unop_u2i, r11DF), 0x01));

      ir_variable *const r11E0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r11E0, sub(r11D9, r11DD), 0x01));

      body.emit(assign(r11D2, r11E0, 0x01));

      /* IF CONDITION */
      ir_expression *const r11E2 = less(body.constant(int(0)), r11E0);
      ir_if *f11E1 = new(mem_ctx) ir_if(operand(r11E2).val);
      exec_list *const f11E1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f11E1->then_instructions;

         /* IF CONDITION */
         ir_expression *const r11E4 = equal(r11D9, body.constant(int(2047)));
         ir_if *f11E3 = new(mem_ctx) ir_if(operand(r11E4).val);
         exec_list *const f11E3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11E3->then_instructions;

            /* IF CONDITION */
            ir_expression *const r11E6 = bit_or(swizzle_y(r11D8), swizzle_x(r0DB1));
            ir_expression *const r11E7 = nequal(r11E6, body.constant(0u));
            ir_if *f11E5 = new(mem_ctx) ir_if(operand(r11E7).val);
            exec_list *const f11E5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f11E5->then_instructions;

               ir_variable *const r11E8 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r11E8, swizzle_x(r0DB1), 0x01));

               ir_variable *const r11E9 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r11E9, swizzle_x(r0DB2), 0x01));

               ir_variable *const r11EA = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r11EB = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r11EC = rshift(swizzle_y(r0DB1), body.constant(int(19)));
               ir_expression *const r11ED = bit_and(r11EC, body.constant(4095u));
               ir_expression *const r11EE = equal(r11ED, body.constant(4094u));
               ir_expression *const r11EF = nequal(swizzle_x(r0DB1), body.constant(0u));
               ir_expression *const r11F0 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
               ir_expression *const r11F1 = nequal(r11F0, body.constant(0u));
               ir_expression *const r11F2 = logic_or(r11EF, r11F1);
               body.emit(assign(r11EB, logic_and(r11EE, r11F2), 0x01));

               ir_variable *const r11F3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r11F4 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
               ir_expression *const r11F5 = lequal(body.constant(4292870144u), r11F4);
               ir_expression *const r11F6 = nequal(swizzle_x(r0DB2), body.constant(0u));
               ir_expression *const r11F7 = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
               ir_expression *const r11F8 = nequal(r11F7, body.constant(0u));
               ir_expression *const r11F9 = logic_or(r11F6, r11F8);
               body.emit(assign(r11F3, logic_and(r11F5, r11F9), 0x01));

               body.emit(assign(r11E8, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

               body.emit(assign(r11E9, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r11FB = lshift(swizzle_y(r0DB1), body.constant(int(1)));
               ir_expression *const r11FC = lequal(body.constant(4292870144u), r11FB);
               ir_expression *const r11FD = nequal(swizzle_x(r0DB1), body.constant(0u));
               ir_expression *const r11FE = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
               ir_expression *const r11FF = nequal(r11FE, body.constant(0u));
               ir_expression *const r1200 = logic_or(r11FD, r11FF);
               ir_expression *const r1201 = logic_and(r11FC, r1200);
               ir_if *f11FA = new(mem_ctx) ir_if(operand(r1201).val);
               exec_list *const f11FA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f11FA->then_instructions;

                  ir_variable *const r1202 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1204 = logic_and(r11EB, r11F3);
                  ir_if *f1203 = new(mem_ctx) ir_if(operand(r1204).val);
                  exec_list *const f1203_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1203->then_instructions;

                     body.emit(assign(r1202, r11E9, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1203->else_instructions;

                     body.emit(assign(r1202, r11E8, 0x03));


                  body.instructions = f1203_parent_instructions;
                  body.emit(f1203);

                  /* END IF */

                  body.emit(assign(r11EA, r1202, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f11FA->else_instructions;

                  body.emit(assign(r11EA, r11E9, 0x03));


               body.instructions = f11FA_parent_instructions;
               body.emit(f11FA);

               /* END IF */

               body.emit(assign(r11D1, r11EA, 0x03));

               body.emit(assign(r11D0, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f11E5->else_instructions;

               body.emit(assign(r11D1, r0DB1, 0x03));

               body.emit(assign(r11D0, body.constant(false), 0x01));


            body.instructions = f11E5_parent_instructions;
            body.emit(f11E5);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f11E3->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1206 = equal(r11DD, body.constant(int(0)));
            ir_if *f1205 = new(mem_ctx) ir_if(operand(r1206).val);
            exec_list *const f1205_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1205->then_instructions;

               body.emit(assign(r11D2, add(r11E0, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1205->else_instructions;

               body.emit(assign(r11D3, bit_or(swizzle_y(r11DC), body.constant(1048576u)), 0x02));


            body.instructions = f1205_parent_instructions;
            body.emit(f1205);

            /* END IF */

            ir_variable *const r1207 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r1207, swizzle_y(r11D3), 0x01));

            ir_variable *const r1208 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r1208, swizzle_x(r11D3), 0x01));

            ir_variable *const r1209 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r1209, body.constant(0u), 0x01));

            ir_variable *const r120A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r120A);
            ir_variable *const r120B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r120B);
            ir_variable *const r120C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r120C);
            ir_variable *const r120D = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r120E = neg(r11D2);
            body.emit(assign(r120D, bit_and(r120E, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1210 = equal(r11D2, body.constant(int(0)));
            ir_if *f120F = new(mem_ctx) ir_if(operand(r1210).val);
            exec_list *const f120F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f120F->then_instructions;

               body.emit(assign(r120A, r1209, 0x01));

               body.emit(assign(r120B, r1208, 0x01));

               body.emit(assign(r120C, r1207, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f120F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1212 = less(r11D2, body.constant(int(32)));
               ir_if *f1211 = new(mem_ctx) ir_if(operand(r1212).val);
               exec_list *const f1211_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1211->then_instructions;

                  body.emit(assign(r120A, lshift(swizzle_x(r11DC), r120D), 0x01));

                  ir_expression *const r1213 = lshift(swizzle_y(r11D3), r120D);
                  ir_expression *const r1214 = rshift(swizzle_x(r11DC), r11D2);
                  body.emit(assign(r120B, bit_or(r1213, r1214), 0x01));

                  body.emit(assign(r120C, rshift(swizzle_y(r11D3), r11D2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1211->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1216 = equal(r11D2, body.constant(int(32)));
                  ir_if *f1215 = new(mem_ctx) ir_if(operand(r1216).val);
                  exec_list *const f1215_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1215->then_instructions;

                     body.emit(assign(r120A, r1208, 0x01));

                     body.emit(assign(r120B, r1207, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1215->else_instructions;

                     body.emit(assign(r1209, bit_or(body.constant(0u), swizzle_x(r11DC)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1218 = less(r11D2, body.constant(int(64)));
                     ir_if *f1217 = new(mem_ctx) ir_if(operand(r1218).val);
                     exec_list *const f1217_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1217->then_instructions;

                        body.emit(assign(r120A, lshift(swizzle_y(r11D3), r120D), 0x01));

                        ir_expression *const r1219 = bit_and(r11D2, body.constant(int(31)));
                        body.emit(assign(r120B, rshift(swizzle_y(r11D3), r1219), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1217->else_instructions;

                        ir_variable *const r121A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r121C = equal(r11D2, body.constant(int(64)));
                        ir_if *f121B = new(mem_ctx) ir_if(operand(r121C).val);
                        exec_list *const f121B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f121B->then_instructions;

                           body.emit(assign(r121A, r1207, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f121B->else_instructions;

                           ir_expression *const r121D = nequal(swizzle_y(r11D3), body.constant(0u));
                           ir_expression *const r121E = expr(ir_unop_b2i, r121D);
                           body.emit(assign(r121A, expr(ir_unop_i2u, r121E), 0x01));


                        body.instructions = f121B_parent_instructions;
                        body.emit(f121B);

                        /* END IF */

                        body.emit(assign(r120A, r121A, 0x01));

                        body.emit(assign(r120B, body.constant(0u), 0x01));


                     body.instructions = f1217_parent_instructions;
                     body.emit(f1217);

                     /* END IF */


                  body.instructions = f1215_parent_instructions;
                  body.emit(f1215);

                  /* END IF */

                  body.emit(assign(r120C, body.constant(0u), 0x01));


               body.instructions = f1211_parent_instructions;
               body.emit(f1211);

               /* END IF */

               ir_expression *const r121F = nequal(r1209, body.constant(0u));
               ir_expression *const r1220 = expr(ir_unop_b2i, r121F);
               ir_expression *const r1221 = expr(ir_unop_i2u, r1220);
               body.emit(assign(r120A, bit_or(r120A, r1221), 0x01));


            body.instructions = f120F_parent_instructions;
            body.emit(f120F);

            /* END IF */

            body.emit(assign(r11D3, r120C, 0x02));

            body.emit(assign(r11D3, r120B, 0x01));

            body.emit(assign(r11D6, r120A, 0x01));

            body.emit(assign(r11D5, r11D9, 0x01));


         body.instructions = f11E3_parent_instructions;
         body.emit(f11E3);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f11E1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1223 = less(r11D2, body.constant(int(0)));
         ir_if *f1222 = new(mem_ctx) ir_if(operand(r1223).val);
         exec_list *const f1222_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1222->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1225 = equal(r11DD, body.constant(int(2047)));
            ir_if *f1224 = new(mem_ctx) ir_if(operand(r1225).val);
            exec_list *const f1224_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1224->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1227 = bit_or(swizzle_y(r11D3), swizzle_x(r11D3));
               ir_expression *const r1228 = nequal(r1227, body.constant(0u));
               ir_if *f1226 = new(mem_ctx) ir_if(operand(r1228).val);
               exec_list *const f1226_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1226->then_instructions;

                  ir_variable *const r1229 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1229, swizzle_x(r0DB1), 0x01));

                  ir_variable *const r122A = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r122A, swizzle_x(r0DB2), 0x01));

                  ir_variable *const r122B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r122C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r122D = rshift(swizzle_y(r0DB1), body.constant(int(19)));
                  ir_expression *const r122E = bit_and(r122D, body.constant(4095u));
                  ir_expression *const r122F = equal(r122E, body.constant(4094u));
                  ir_expression *const r1230 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r1231 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
                  ir_expression *const r1232 = nequal(r1231, body.constant(0u));
                  ir_expression *const r1233 = logic_or(r1230, r1232);
                  body.emit(assign(r122C, logic_and(r122F, r1233), 0x01));

                  ir_variable *const r1234 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r1235 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
                  ir_expression *const r1236 = lequal(body.constant(4292870144u), r1235);
                  ir_expression *const r1237 = nequal(swizzle_x(r0DB2), body.constant(0u));
                  ir_expression *const r1238 = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
                  ir_expression *const r1239 = nequal(r1238, body.constant(0u));
                  ir_expression *const r123A = logic_or(r1237, r1239);
                  body.emit(assign(r1234, logic_and(r1236, r123A), 0x01));

                  body.emit(assign(r1229, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

                  body.emit(assign(r122A, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r123C = lshift(swizzle_y(r0DB1), body.constant(int(1)));
                  ir_expression *const r123D = lequal(body.constant(4292870144u), r123C);
                  ir_expression *const r123E = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r123F = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
                  ir_expression *const r1240 = nequal(r123F, body.constant(0u));
                  ir_expression *const r1241 = logic_or(r123E, r1240);
                  ir_expression *const r1242 = logic_and(r123D, r1241);
                  ir_if *f123B = new(mem_ctx) ir_if(operand(r1242).val);
                  exec_list *const f123B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f123B->then_instructions;

                     ir_variable *const r1243 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1245 = logic_and(r122C, r1234);
                     ir_if *f1244 = new(mem_ctx) ir_if(operand(r1245).val);
                     exec_list *const f1244_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1244->then_instructions;

                        body.emit(assign(r1243, r122A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1244->else_instructions;

                        body.emit(assign(r1243, r1229, 0x03));


                     body.instructions = f1244_parent_instructions;
                     body.emit(f1244);

                     /* END IF */

                     body.emit(assign(r122B, r1243, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f123B->else_instructions;

                     body.emit(assign(r122B, r122A, 0x03));


                  body.instructions = f123B_parent_instructions;
                  body.emit(f123B);

                  /* END IF */

                  body.emit(assign(r11D1, r122B, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1226->else_instructions;

                  ir_variable *const r1246 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1246);
                  ir_expression *const r1247 = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r1246, add(r1247, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1246, body.constant(0u), 0x01));

                  body.emit(assign(r11D1, r1246, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


               body.instructions = f1226_parent_instructions;
               body.emit(f1226);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1224->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1249 = equal(r11D9, body.constant(int(0)));
               ir_if *f1248 = new(mem_ctx) ir_if(operand(r1249).val);
               exec_list *const f1248_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1248->then_instructions;

                  body.emit(assign(r11D2, add(r11D2, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1248->else_instructions;

                  body.emit(assign(r11D4, bit_or(swizzle_y(r11D8), body.constant(1048576u)), 0x02));


               body.instructions = f1248_parent_instructions;
               body.emit(f1248);

               /* END IF */

               ir_variable *const r124A = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r124A, swizzle_y(r11D4), 0x01));

               ir_variable *const r124B = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r124B, swizzle_x(r11D4), 0x01));

               ir_variable *const r124C = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r124C, body.constant(0u), 0x01));

               ir_variable *const r124D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r124D, neg(r11D2), 0x01));

               ir_variable *const r124E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r124E);
               ir_variable *const r124F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r124F);
               ir_variable *const r1250 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1250);
               ir_variable *const r1251 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1252 = neg(r124D);
               body.emit(assign(r1251, bit_and(r1252, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1254 = equal(r124D, body.constant(int(0)));
               ir_if *f1253 = new(mem_ctx) ir_if(operand(r1254).val);
               exec_list *const f1253_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1253->then_instructions;

                  body.emit(assign(r124E, r124C, 0x01));

                  body.emit(assign(r124F, r124B, 0x01));

                  body.emit(assign(r1250, r124A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1253->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1256 = less(r124D, body.constant(int(32)));
                  ir_if *f1255 = new(mem_ctx) ir_if(operand(r1256).val);
                  exec_list *const f1255_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1255->then_instructions;

                     body.emit(assign(r124E, lshift(swizzle_x(r11D8), r1251), 0x01));

                     ir_expression *const r1257 = lshift(swizzle_y(r11D4), r1251);
                     ir_expression *const r1258 = rshift(swizzle_x(r11D8), r124D);
                     body.emit(assign(r124F, bit_or(r1257, r1258), 0x01));

                     body.emit(assign(r1250, rshift(swizzle_y(r11D4), r124D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1255->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r125A = equal(r124D, body.constant(int(32)));
                     ir_if *f1259 = new(mem_ctx) ir_if(operand(r125A).val);
                     exec_list *const f1259_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1259->then_instructions;

                        body.emit(assign(r124E, r124B, 0x01));

                        body.emit(assign(r124F, r124A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1259->else_instructions;

                        body.emit(assign(r124C, bit_or(body.constant(0u), swizzle_x(r11D8)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r125C = less(r124D, body.constant(int(64)));
                        ir_if *f125B = new(mem_ctx) ir_if(operand(r125C).val);
                        exec_list *const f125B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f125B->then_instructions;

                           body.emit(assign(r124E, lshift(swizzle_y(r11D4), r1251), 0x01));

                           ir_expression *const r125D = bit_and(r124D, body.constant(int(31)));
                           body.emit(assign(r124F, rshift(swizzle_y(r11D4), r125D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f125B->else_instructions;

                           ir_variable *const r125E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1260 = equal(r124D, body.constant(int(64)));
                           ir_if *f125F = new(mem_ctx) ir_if(operand(r1260).val);
                           exec_list *const f125F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f125F->then_instructions;

                              body.emit(assign(r125E, r124A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f125F->else_instructions;

                              ir_expression *const r1261 = nequal(swizzle_y(r11D4), body.constant(0u));
                              ir_expression *const r1262 = expr(ir_unop_b2i, r1261);
                              body.emit(assign(r125E, expr(ir_unop_i2u, r1262), 0x01));


                           body.instructions = f125F_parent_instructions;
                           body.emit(f125F);

                           /* END IF */

                           body.emit(assign(r124E, r125E, 0x01));

                           body.emit(assign(r124F, body.constant(0u), 0x01));


                        body.instructions = f125B_parent_instructions;
                        body.emit(f125B);

                        /* END IF */


                     body.instructions = f1259_parent_instructions;
                     body.emit(f1259);

                     /* END IF */

                     body.emit(assign(r1250, body.constant(0u), 0x01));


                  body.instructions = f1255_parent_instructions;
                  body.emit(f1255);

                  /* END IF */

                  ir_expression *const r1263 = nequal(r124C, body.constant(0u));
                  ir_expression *const r1264 = expr(ir_unop_b2i, r1263);
                  ir_expression *const r1265 = expr(ir_unop_i2u, r1264);
                  body.emit(assign(r124E, bit_or(r124E, r1265), 0x01));


               body.instructions = f1253_parent_instructions;
               body.emit(f1253);

               /* END IF */

               body.emit(assign(r11D4, r1250, 0x02));

               body.emit(assign(r11D4, r124F, 0x01));

               body.emit(assign(r11D6, r124E, 0x01));

               body.emit(assign(r11D5, r11DD, 0x01));


            body.instructions = f1224_parent_instructions;
            body.emit(f1224);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1222->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1267 = equal(r11D9, body.constant(int(2047)));
            ir_if *f1266 = new(mem_ctx) ir_if(operand(r1267).val);
            exec_list *const f1266_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1266->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1269 = bit_or(swizzle_y(r11D4), swizzle_x(r11D4));
               ir_expression *const r126A = bit_or(swizzle_y(r11D3), swizzle_x(r11D3));
               ir_expression *const r126B = bit_or(r1269, r126A);
               ir_expression *const r126C = nequal(r126B, body.constant(0u));
               ir_if *f1268 = new(mem_ctx) ir_if(operand(r126C).val);
               exec_list *const f1268_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1268->then_instructions;

                  ir_variable *const r126D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r126D, swizzle_x(r0DB1), 0x01));

                  ir_variable *const r126E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r126E, swizzle_x(r0DB2), 0x01));

                  ir_variable *const r126F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r1270 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r1271 = rshift(swizzle_y(r0DB1), body.constant(int(19)));
                  ir_expression *const r1272 = bit_and(r1271, body.constant(4095u));
                  ir_expression *const r1273 = equal(r1272, body.constant(4094u));
                  ir_expression *const r1274 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r1275 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
                  ir_expression *const r1276 = nequal(r1275, body.constant(0u));
                  ir_expression *const r1277 = logic_or(r1274, r1276);
                  body.emit(assign(r1270, logic_and(r1273, r1277), 0x01));

                  ir_variable *const r1278 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r1279 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
                  ir_expression *const r127A = lequal(body.constant(4292870144u), r1279);
                  ir_expression *const r127B = nequal(swizzle_x(r0DB2), body.constant(0u));
                  ir_expression *const r127C = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
                  ir_expression *const r127D = nequal(r127C, body.constant(0u));
                  ir_expression *const r127E = logic_or(r127B, r127D);
                  body.emit(assign(r1278, logic_and(r127A, r127E), 0x01));

                  body.emit(assign(r126D, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

                  body.emit(assign(r126E, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1280 = lshift(swizzle_y(r0DB1), body.constant(int(1)));
                  ir_expression *const r1281 = lequal(body.constant(4292870144u), r1280);
                  ir_expression *const r1282 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r1283 = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
                  ir_expression *const r1284 = nequal(r1283, body.constant(0u));
                  ir_expression *const r1285 = logic_or(r1282, r1284);
                  ir_expression *const r1286 = logic_and(r1281, r1285);
                  ir_if *f127F = new(mem_ctx) ir_if(operand(r1286).val);
                  exec_list *const f127F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f127F->then_instructions;

                     ir_variable *const r1287 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1289 = logic_and(r1270, r1278);
                     ir_if *f1288 = new(mem_ctx) ir_if(operand(r1289).val);
                     exec_list *const f1288_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1288->then_instructions;

                        body.emit(assign(r1287, r126E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1288->else_instructions;

                        body.emit(assign(r1287, r126D, 0x03));


                     body.instructions = f1288_parent_instructions;
                     body.emit(f1288);

                     /* END IF */

                     body.emit(assign(r126F, r1287, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f127F->else_instructions;

                     body.emit(assign(r126F, r126E, 0x03));


                  body.instructions = f127F_parent_instructions;
                  body.emit(f127F);

                  /* END IF */

                  body.emit(assign(r11D1, r126F, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1268->else_instructions;

                  body.emit(assign(r11D1, r0DB1, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


               body.instructions = f1268_parent_instructions;
               body.emit(f1268);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1266->else_instructions;

               ir_variable *const r128A = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r128B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r128B, add(swizzle_x(r11D4), swizzle_x(r11D3)), 0x01));

               ir_expression *const r128C = add(swizzle_y(r11D4), swizzle_y(r11D3));
               ir_expression *const r128D = less(r128B, swizzle_x(r11D4));
               ir_expression *const r128E = expr(ir_unop_b2i, r128D);
               ir_expression *const r128F = expr(ir_unop_i2u, r128E);
               body.emit(assign(r128A, add(r128C, r128F), 0x01));

               body.emit(assign(r11D7, r128A, 0x01));

               /* IF CONDITION */
               ir_expression *const r1291 = equal(r11D9, body.constant(int(0)));
               ir_if *f1290 = new(mem_ctx) ir_if(operand(r1291).val);
               exec_list *const f1290_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1290->then_instructions;

                  ir_variable *const r1292 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1292);
                  ir_expression *const r1293 = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r1292, add(r1293, r128A), 0x02));

                  body.emit(assign(r1292, r128B, 0x01));

                  body.emit(assign(r11D1, r1292, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1290->else_instructions;

                  body.emit(assign(r11D7, bit_or(r128A, body.constant(2097152u)), 0x01));

                  body.emit(assign(r11D5, r11D9, 0x01));

                  ir_variable *const r1294 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1294);
                  ir_variable *const r1295 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1295);
                  ir_variable *const r1296 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1296);
                  body.emit(assign(r1294, lshift(r128B, body.constant(int(31))), 0x01));

                  ir_expression *const r1297 = lshift(r11D7, body.constant(int(31)));
                  ir_expression *const r1298 = rshift(r128B, body.constant(int(1)));
                  body.emit(assign(r1295, bit_or(r1297, r1298), 0x01));

                  body.emit(assign(r1296, rshift(r11D7, body.constant(int(1))), 0x01));

                  body.emit(assign(r1294, bit_or(r1294, body.constant(0u)), 0x01));

                  body.emit(assign(r11D7, r1296, 0x01));

                  body.emit(assign(r11D6, r1294, 0x01));

                  ir_variable *const r1299 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r1299, r11D9, 0x01));

                  ir_variable *const r129A = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r129A, r1296, 0x01));

                  ir_variable *const r129B = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r129B, r1295, 0x01));

                  ir_variable *const r129C = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r129C, r1294, 0x01));

                  ir_variable *const r129D = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r129D, body.constant(true), 0x01));

                  ir_variable *const r129E = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r129F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r129F);
                  ir_expression *const r12A0 = expr(ir_unop_u2i, r1294);
                  body.emit(assign(r129F, less(r12A0, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r12A2 = lequal(body.constant(int(2045)), r11D9);
                  ir_if *f12A1 = new(mem_ctx) ir_if(operand(r12A2).val);
                  exec_list *const f12A1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12A1->then_instructions;

                     ir_variable *const r12A3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r12A5 = less(body.constant(int(2045)), r11D9);
                     ir_if *f12A4 = new(mem_ctx) ir_if(operand(r12A5).val);
                     exec_list *const f12A4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12A4->then_instructions;

                        body.emit(assign(r12A3, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12A4->else_instructions;

                        ir_variable *const r12A6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r12A8 = equal(r11D9, body.constant(int(2045)));
                        ir_if *f12A7 = new(mem_ctx) ir_if(operand(r12A8).val);
                        exec_list *const f12A7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12A7->then_instructions;

                           ir_expression *const r12A9 = equal(body.constant(2097151u), r1296);
                           ir_expression *const r12AA = equal(body.constant(4294967295u), r1295);
                           body.emit(assign(r12A6, logic_and(r12A9, r12AA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f12A7->else_instructions;

                           body.emit(assign(r12A6, body.constant(false), 0x01));


                        body.instructions = f12A7_parent_instructions;
                        body.emit(f12A7);

                        /* END IF */

                        body.emit(assign(r12A3, logic_and(r12A6, r129F), 0x01));


                     body.instructions = f12A4_parent_instructions;
                     body.emit(f12A4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f12AB = new(mem_ctx) ir_if(operand(r12A3).val);
                     exec_list *const f12AB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12AB->then_instructions;

                        ir_variable *const r12AC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r12AC);
                        ir_expression *const r12AD = lshift(r0DB4, body.constant(int(31)));
                        body.emit(assign(r12AC, add(r12AD, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r12AC, body.constant(0u), 0x01));

                        body.emit(assign(r129E, r12AC, 0x03));

                        body.emit(assign(r129D, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12AB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r12AF = less(r11D9, body.constant(int(0)));
                        ir_if *f12AE = new(mem_ctx) ir_if(operand(r12AF).val);
                        exec_list *const f12AE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12AE->then_instructions;

                           ir_variable *const r12B0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r12B0, r1294, 0x01));

                           ir_variable *const r12B1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r12B1, neg(r11D9), 0x01));

                           ir_variable *const r12B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r12B2);
                           ir_variable *const r12B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r12B3);
                           ir_variable *const r12B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r12B4);
                           ir_variable *const r12B5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r12B6 = neg(r12B1);
                           body.emit(assign(r12B5, bit_and(r12B6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r12B8 = equal(r12B1, body.constant(int(0)));
                           ir_if *f12B7 = new(mem_ctx) ir_if(operand(r12B8).val);
                           exec_list *const f12B7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f12B7->then_instructions;

                              body.emit(assign(r12B2, r1294, 0x01));

                              body.emit(assign(r12B3, r1295, 0x01));

                              body.emit(assign(r12B4, r1296, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f12B7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r12BA = less(r12B1, body.constant(int(32)));
                              ir_if *f12B9 = new(mem_ctx) ir_if(operand(r12BA).val);
                              exec_list *const f12B9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f12B9->then_instructions;

                                 body.emit(assign(r12B2, lshift(r1295, r12B5), 0x01));

                                 ir_expression *const r12BB = lshift(r1296, r12B5);
                                 ir_expression *const r12BC = rshift(r1295, r12B1);
                                 body.emit(assign(r12B3, bit_or(r12BB, r12BC), 0x01));

                                 body.emit(assign(r12B4, rshift(r1296, r12B1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f12B9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r12BE = equal(r12B1, body.constant(int(32)));
                                 ir_if *f12BD = new(mem_ctx) ir_if(operand(r12BE).val);
                                 exec_list *const f12BD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f12BD->then_instructions;

                                    body.emit(assign(r12B2, r1295, 0x01));

                                    body.emit(assign(r12B3, r1296, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f12BD->else_instructions;

                                    body.emit(assign(r12B0, bit_or(r1294, r1295), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r12C0 = less(r12B1, body.constant(int(64)));
                                    ir_if *f12BF = new(mem_ctx) ir_if(operand(r12C0).val);
                                    exec_list *const f12BF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f12BF->then_instructions;

                                       body.emit(assign(r12B2, lshift(r1296, r12B5), 0x01));

                                       ir_expression *const r12C1 = bit_and(r12B1, body.constant(int(31)));
                                       body.emit(assign(r12B3, rshift(r1296, r12C1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f12BF->else_instructions;

                                       ir_variable *const r12C2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r12C4 = equal(r12B1, body.constant(int(64)));
                                       ir_if *f12C3 = new(mem_ctx) ir_if(operand(r12C4).val);
                                       exec_list *const f12C3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f12C3->then_instructions;

                                          body.emit(assign(r12C2, r1296, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f12C3->else_instructions;

                                          ir_expression *const r12C5 = nequal(r1296, body.constant(0u));
                                          ir_expression *const r12C6 = expr(ir_unop_b2i, r12C5);
                                          body.emit(assign(r12C2, expr(ir_unop_i2u, r12C6), 0x01));


                                       body.instructions = f12C3_parent_instructions;
                                       body.emit(f12C3);

                                       /* END IF */

                                       body.emit(assign(r12B2, r12C2, 0x01));

                                       body.emit(assign(r12B3, body.constant(0u), 0x01));


                                    body.instructions = f12BF_parent_instructions;
                                    body.emit(f12BF);

                                    /* END IF */


                                 body.instructions = f12BD_parent_instructions;
                                 body.emit(f12BD);

                                 /* END IF */

                                 body.emit(assign(r12B4, body.constant(0u), 0x01));


                              body.instructions = f12B9_parent_instructions;
                              body.emit(f12B9);

                              /* END IF */

                              ir_expression *const r12C7 = nequal(r12B0, body.constant(0u));
                              ir_expression *const r12C8 = expr(ir_unop_b2i, r12C7);
                              ir_expression *const r12C9 = expr(ir_unop_i2u, r12C8);
                              body.emit(assign(r12B2, bit_or(r12B2, r12C9), 0x01));


                           body.instructions = f12B7_parent_instructions;
                           body.emit(f12B7);

                           /* END IF */

                           body.emit(assign(r129A, r12B4, 0x01));

                           body.emit(assign(r129B, r12B3, 0x01));

                           body.emit(assign(r129C, r12B2, 0x01));

                           body.emit(assign(r1299, body.constant(int(0)), 0x01));

                           body.emit(assign(r129F, less(r12B2, body.constant(0u)), 0x01));


                        body.instructions = f12AE_parent_instructions;
                        body.emit(f12AE);

                        /* END IF */


                     body.instructions = f12AB_parent_instructions;
                     body.emit(f12AB);

                     /* END IF */


                  body.instructions = f12A1_parent_instructions;
                  body.emit(f12A1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f12CA = new(mem_ctx) ir_if(operand(r129D).val);
                  exec_list *const f12CA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12CA->then_instructions;

                     /* IF CONDITION */
                     ir_if *f12CB = new(mem_ctx) ir_if(operand(r129F).val);
                     exec_list *const f12CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12CB->then_instructions;

                        ir_variable *const r12CC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r12CC, add(r129B, body.constant(1u)), 0x01));

                        ir_expression *const r12CD = less(r12CC, r129B);
                        ir_expression *const r12CE = expr(ir_unop_b2i, r12CD);
                        ir_expression *const r12CF = expr(ir_unop_i2u, r12CE);
                        body.emit(assign(r129A, add(r129A, r12CF), 0x01));

                        ir_expression *const r12D0 = equal(r129C, body.constant(0u));
                        ir_expression *const r12D1 = expr(ir_unop_b2i, r12D0);
                        ir_expression *const r12D2 = expr(ir_unop_i2u, r12D1);
                        ir_expression *const r12D3 = add(r129C, r12D2);
                        ir_expression *const r12D4 = bit_and(r12D3, body.constant(1u));
                        ir_expression *const r12D5 = expr(ir_unop_bit_not, r12D4);
                        body.emit(assign(r129B, bit_and(r12CC, r12D5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12CB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r12D7 = bit_or(r129A, r129B);
                        ir_expression *const r12D8 = equal(r12D7, body.constant(0u));
                        ir_if *f12D6 = new(mem_ctx) ir_if(operand(r12D8).val);
                        exec_list *const f12D6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12D6->then_instructions;

                           body.emit(assign(r1299, body.constant(int(0)), 0x01));


                        body.instructions = f12D6_parent_instructions;
                        body.emit(f12D6);

                        /* END IF */


                     body.instructions = f12CB_parent_instructions;
                     body.emit(f12CB);

                     /* END IF */

                     ir_variable *const r12D9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r12D9);
                     ir_expression *const r12DA = lshift(r0DB4, body.constant(int(31)));
                     ir_expression *const r12DB = expr(ir_unop_i2u, r1299);
                     ir_expression *const r12DC = lshift(r12DB, body.constant(int(20)));
                     ir_expression *const r12DD = add(r12DA, r12DC);
                     body.emit(assign(r12D9, add(r12DD, r129A), 0x02));

                     body.emit(assign(r12D9, r129B, 0x01));

                     body.emit(assign(r129E, r12D9, 0x03));

                     body.emit(assign(r129D, body.constant(false), 0x01));


                  body.instructions = f12CA_parent_instructions;
                  body.emit(f12CA);

                  /* END IF */

                  body.emit(assign(r11D1, r129E, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


               body.instructions = f1290_parent_instructions;
               body.emit(f1290);

               /* END IF */


            body.instructions = f1266_parent_instructions;
            body.emit(f1266);

            /* END IF */


         body.instructions = f1222_parent_instructions;
         body.emit(f1222);

         /* END IF */


      body.instructions = f11E1_parent_instructions;
      body.emit(f11E1);

      /* END IF */

      /* IF CONDITION */
      ir_if *f12DE = new(mem_ctx) ir_if(operand(r11D0).val);
      exec_list *const f12DE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f12DE->then_instructions;

         body.emit(assign(r11D4, bit_or(swizzle_y(r11D4), body.constant(1048576u)), 0x02));

         ir_variable *const r12DF = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r12E0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r12E0, add(swizzle_x(r11D4), swizzle_x(r11D3)), 0x01));

         ir_expression *const r12E1 = add(swizzle_y(r11D4), swizzle_y(r11D3));
         ir_expression *const r12E2 = less(r12E0, swizzle_x(r11D4));
         ir_expression *const r12E3 = expr(ir_unop_b2i, r12E2);
         ir_expression *const r12E4 = expr(ir_unop_i2u, r12E3);
         body.emit(assign(r12DF, add(r12E1, r12E4), 0x01));

         body.emit(assign(r11D7, r12DF, 0x01));

         body.emit(assign(r11D5, add(r11D5, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r12E6 = less(r12DF, body.constant(2097152u));
         ir_if *f12E5 = new(mem_ctx) ir_if(operand(r12E6).val);
         exec_list *const f12E5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f12E5->then_instructions;

            ir_variable *const r12E7 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r12E7, r11D5, 0x01));

            ir_variable *const r12E8 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r12E8, r12DF, 0x01));

            ir_variable *const r12E9 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r12E9, r12E0, 0x01));

            ir_variable *const r12EA = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r12EA, r11D6, 0x01));

            ir_variable *const r12EB = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r12EB, body.constant(true), 0x01));

            ir_variable *const r12EC = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r12ED = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r12ED);
            ir_expression *const r12EE = expr(ir_unop_u2i, r11D6);
            body.emit(assign(r12ED, less(r12EE, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r12F0 = lequal(body.constant(int(2045)), r11D5);
            ir_if *f12EF = new(mem_ctx) ir_if(operand(r12F0).val);
            exec_list *const f12EF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f12EF->then_instructions;

               ir_variable *const r12F1 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r12F3 = less(body.constant(int(2045)), r11D5);
               ir_if *f12F2 = new(mem_ctx) ir_if(operand(r12F3).val);
               exec_list *const f12F2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12F2->then_instructions;

                  body.emit(assign(r12F1, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f12F2->else_instructions;

                  ir_variable *const r12F4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r12F6 = equal(r11D5, body.constant(int(2045)));
                  ir_if *f12F5 = new(mem_ctx) ir_if(operand(r12F6).val);
                  exec_list *const f12F5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12F5->then_instructions;

                     ir_expression *const r12F7 = equal(body.constant(2097151u), r12DF);
                     ir_expression *const r12F8 = equal(body.constant(4294967295u), r12E0);
                     body.emit(assign(r12F4, logic_and(r12F7, r12F8), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f12F5->else_instructions;

                     body.emit(assign(r12F4, body.constant(false), 0x01));


                  body.instructions = f12F5_parent_instructions;
                  body.emit(f12F5);

                  /* END IF */

                  body.emit(assign(r12F1, logic_and(r12F4, r12ED), 0x01));


               body.instructions = f12F2_parent_instructions;
               body.emit(f12F2);

               /* END IF */

               /* IF CONDITION */
               ir_if *f12F9 = new(mem_ctx) ir_if(operand(r12F1).val);
               exec_list *const f12F9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12F9->then_instructions;

                  ir_variable *const r12FA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r12FA);
                  ir_expression *const r12FB = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r12FA, add(r12FB, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r12FA, body.constant(0u), 0x01));

                  body.emit(assign(r12EC, r12FA, 0x03));

                  body.emit(assign(r12EB, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f12F9->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r12FD = less(r11D5, body.constant(int(0)));
                  ir_if *f12FC = new(mem_ctx) ir_if(operand(r12FD).val);
                  exec_list *const f12FC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12FC->then_instructions;

                     ir_variable *const r12FE = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r12FE, r11D6, 0x01));

                     ir_variable *const r12FF = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r12FF, neg(r11D5), 0x01));

                     ir_variable *const r1300 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r1300);
                     ir_variable *const r1301 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r1301);
                     ir_variable *const r1302 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r1302);
                     ir_variable *const r1303 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r1304 = neg(r12FF);
                     body.emit(assign(r1303, bit_and(r1304, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1306 = equal(r12FF, body.constant(int(0)));
                     ir_if *f1305 = new(mem_ctx) ir_if(operand(r1306).val);
                     exec_list *const f1305_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1305->then_instructions;

                        body.emit(assign(r1300, r11D6, 0x01));

                        body.emit(assign(r1301, r12E0, 0x01));

                        body.emit(assign(r1302, r12DF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1305->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1308 = less(r12FF, body.constant(int(32)));
                        ir_if *f1307 = new(mem_ctx) ir_if(operand(r1308).val);
                        exec_list *const f1307_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1307->then_instructions;

                           body.emit(assign(r1300, lshift(r12E0, r1303), 0x01));

                           ir_expression *const r1309 = lshift(r12DF, r1303);
                           ir_expression *const r130A = rshift(r12E0, r12FF);
                           body.emit(assign(r1301, bit_or(r1309, r130A), 0x01));

                           body.emit(assign(r1302, rshift(r12DF, r12FF), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1307->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r130C = equal(r12FF, body.constant(int(32)));
                           ir_if *f130B = new(mem_ctx) ir_if(operand(r130C).val);
                           exec_list *const f130B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f130B->then_instructions;

                              body.emit(assign(r1300, r12E0, 0x01));

                              body.emit(assign(r1301, r12DF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f130B->else_instructions;

                              body.emit(assign(r12FE, bit_or(r11D6, r12E0), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r130E = less(r12FF, body.constant(int(64)));
                              ir_if *f130D = new(mem_ctx) ir_if(operand(r130E).val);
                              exec_list *const f130D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f130D->then_instructions;

                                 body.emit(assign(r1300, lshift(r12DF, r1303), 0x01));

                                 ir_expression *const r130F = bit_and(r12FF, body.constant(int(31)));
                                 body.emit(assign(r1301, rshift(r12DF, r130F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f130D->else_instructions;

                                 ir_variable *const r1310 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1312 = equal(r12FF, body.constant(int(64)));
                                 ir_if *f1311 = new(mem_ctx) ir_if(operand(r1312).val);
                                 exec_list *const f1311_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1311->then_instructions;

                                    body.emit(assign(r1310, r12DF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1311->else_instructions;

                                    ir_expression *const r1313 = nequal(r12DF, body.constant(0u));
                                    ir_expression *const r1314 = expr(ir_unop_b2i, r1313);
                                    body.emit(assign(r1310, expr(ir_unop_i2u, r1314), 0x01));


                                 body.instructions = f1311_parent_instructions;
                                 body.emit(f1311);

                                 /* END IF */

                                 body.emit(assign(r1300, r1310, 0x01));

                                 body.emit(assign(r1301, body.constant(0u), 0x01));


                              body.instructions = f130D_parent_instructions;
                              body.emit(f130D);

                              /* END IF */


                           body.instructions = f130B_parent_instructions;
                           body.emit(f130B);

                           /* END IF */

                           body.emit(assign(r1302, body.constant(0u), 0x01));


                        body.instructions = f1307_parent_instructions;
                        body.emit(f1307);

                        /* END IF */

                        ir_expression *const r1315 = nequal(r12FE, body.constant(0u));
                        ir_expression *const r1316 = expr(ir_unop_b2i, r1315);
                        ir_expression *const r1317 = expr(ir_unop_i2u, r1316);
                        body.emit(assign(r1300, bit_or(r1300, r1317), 0x01));


                     body.instructions = f1305_parent_instructions;
                     body.emit(f1305);

                     /* END IF */

                     body.emit(assign(r12E8, r1302, 0x01));

                     body.emit(assign(r12E9, r1301, 0x01));

                     body.emit(assign(r12EA, r1300, 0x01));

                     body.emit(assign(r12E7, body.constant(int(0)), 0x01));

                     body.emit(assign(r12ED, less(r1300, body.constant(0u)), 0x01));


                  body.instructions = f12FC_parent_instructions;
                  body.emit(f12FC);

                  /* END IF */


               body.instructions = f12F9_parent_instructions;
               body.emit(f12F9);

               /* END IF */


            body.instructions = f12EF_parent_instructions;
            body.emit(f12EF);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1318 = new(mem_ctx) ir_if(operand(r12EB).val);
            exec_list *const f1318_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1318->then_instructions;

               /* IF CONDITION */
               ir_if *f1319 = new(mem_ctx) ir_if(operand(r12ED).val);
               exec_list *const f1319_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1319->then_instructions;

                  ir_variable *const r131A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r131A, add(r12E9, body.constant(1u)), 0x01));

                  ir_expression *const r131B = less(r131A, r12E9);
                  ir_expression *const r131C = expr(ir_unop_b2i, r131B);
                  ir_expression *const r131D = expr(ir_unop_i2u, r131C);
                  body.emit(assign(r12E8, add(r12E8, r131D), 0x01));

                  ir_expression *const r131E = equal(r12EA, body.constant(0u));
                  ir_expression *const r131F = expr(ir_unop_b2i, r131E);
                  ir_expression *const r1320 = expr(ir_unop_i2u, r131F);
                  ir_expression *const r1321 = add(r12EA, r1320);
                  ir_expression *const r1322 = bit_and(r1321, body.constant(1u));
                  ir_expression *const r1323 = expr(ir_unop_bit_not, r1322);
                  body.emit(assign(r12E9, bit_and(r131A, r1323), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1319->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1325 = bit_or(r12E8, r12E9);
                  ir_expression *const r1326 = equal(r1325, body.constant(0u));
                  ir_if *f1324 = new(mem_ctx) ir_if(operand(r1326).val);
                  exec_list *const f1324_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1324->then_instructions;

                     body.emit(assign(r12E7, body.constant(int(0)), 0x01));


                  body.instructions = f1324_parent_instructions;
                  body.emit(f1324);

                  /* END IF */


               body.instructions = f1319_parent_instructions;
               body.emit(f1319);

               /* END IF */

               ir_variable *const r1327 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1327);
               ir_expression *const r1328 = lshift(r0DB4, body.constant(int(31)));
               ir_expression *const r1329 = expr(ir_unop_i2u, r12E7);
               ir_expression *const r132A = lshift(r1329, body.constant(int(20)));
               ir_expression *const r132B = add(r1328, r132A);
               body.emit(assign(r1327, add(r132B, r12E8), 0x02));

               body.emit(assign(r1327, r12E9, 0x01));

               body.emit(assign(r12EC, r1327, 0x03));

               body.emit(assign(r12EB, body.constant(false), 0x01));


            body.instructions = f1318_parent_instructions;
            body.emit(f1318);

            /* END IF */

            body.emit(assign(r11D1, r12EC, 0x03));

            body.emit(assign(r11D0, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f12E5->else_instructions;

            body.emit(assign(r11D5, add(r11D5, body.constant(int(1))), 0x01));

            ir_variable *const r132C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r132C);
            ir_variable *const r132D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r132D);
            ir_variable *const r132E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r132E);
            body.emit(assign(r132C, lshift(r12E0, body.constant(int(31))), 0x01));

            ir_expression *const r132F = lshift(r12DF, body.constant(int(31)));
            ir_expression *const r1330 = rshift(r12E0, body.constant(int(1)));
            body.emit(assign(r132D, bit_or(r132F, r1330), 0x01));

            body.emit(assign(r132E, rshift(r12DF, body.constant(int(1))), 0x01));

            ir_expression *const r1331 = nequal(r11D6, body.constant(0u));
            ir_expression *const r1332 = expr(ir_unop_b2i, r1331);
            ir_expression *const r1333 = expr(ir_unop_i2u, r1332);
            body.emit(assign(r132C, bit_or(r132C, r1333), 0x01));

            body.emit(assign(r11D7, r132E, 0x01));

            body.emit(assign(r11D6, r132C, 0x01));

            ir_variable *const r1334 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r1334, r11D5, 0x01));

            ir_variable *const r1335 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r1335, r132E, 0x01));

            ir_variable *const r1336 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r1336, r132D, 0x01));

            ir_variable *const r1337 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r1337, r132C, 0x01));

            ir_variable *const r1338 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r1338, body.constant(true), 0x01));

            ir_variable *const r1339 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r133A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r133A);
            ir_expression *const r133B = expr(ir_unop_u2i, r132C);
            body.emit(assign(r133A, less(r133B, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r133D = lequal(body.constant(int(2045)), r11D5);
            ir_if *f133C = new(mem_ctx) ir_if(operand(r133D).val);
            exec_list *const f133C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f133C->then_instructions;

               ir_variable *const r133E = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r1340 = less(body.constant(int(2045)), r11D5);
               ir_if *f133F = new(mem_ctx) ir_if(operand(r1340).val);
               exec_list *const f133F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f133F->then_instructions;

                  body.emit(assign(r133E, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f133F->else_instructions;

                  ir_variable *const r1341 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1343 = equal(r11D5, body.constant(int(2045)));
                  ir_if *f1342 = new(mem_ctx) ir_if(operand(r1343).val);
                  exec_list *const f1342_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1342->then_instructions;

                     ir_expression *const r1344 = equal(body.constant(2097151u), r132E);
                     ir_expression *const r1345 = equal(body.constant(4294967295u), r132D);
                     body.emit(assign(r1341, logic_and(r1344, r1345), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1342->else_instructions;

                     body.emit(assign(r1341, body.constant(false), 0x01));


                  body.instructions = f1342_parent_instructions;
                  body.emit(f1342);

                  /* END IF */

                  body.emit(assign(r133E, logic_and(r1341, r133A), 0x01));


               body.instructions = f133F_parent_instructions;
               body.emit(f133F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1346 = new(mem_ctx) ir_if(operand(r133E).val);
               exec_list *const f1346_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1346->then_instructions;

                  ir_variable *const r1347 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1347);
                  ir_expression *const r1348 = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r1347, add(r1348, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1347, body.constant(0u), 0x01));

                  body.emit(assign(r1339, r1347, 0x03));

                  body.emit(assign(r1338, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1346->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r134A = less(r11D5, body.constant(int(0)));
                  ir_if *f1349 = new(mem_ctx) ir_if(operand(r134A).val);
                  exec_list *const f1349_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1349->then_instructions;

                     ir_variable *const r134B = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r134B, r132C, 0x01));

                     ir_variable *const r134C = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r134C, neg(r11D5), 0x01));

                     ir_variable *const r134D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r134D);
                     ir_variable *const r134E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r134E);
                     ir_variable *const r134F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r134F);
                     ir_variable *const r1350 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r1351 = neg(r134C);
                     body.emit(assign(r1350, bit_and(r1351, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1353 = equal(r134C, body.constant(int(0)));
                     ir_if *f1352 = new(mem_ctx) ir_if(operand(r1353).val);
                     exec_list *const f1352_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1352->then_instructions;

                        body.emit(assign(r134D, r132C, 0x01));

                        body.emit(assign(r134E, r132D, 0x01));

                        body.emit(assign(r134F, r132E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1352->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1355 = less(r134C, body.constant(int(32)));
                        ir_if *f1354 = new(mem_ctx) ir_if(operand(r1355).val);
                        exec_list *const f1354_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1354->then_instructions;

                           body.emit(assign(r134D, lshift(r132D, r1350), 0x01));

                           ir_expression *const r1356 = lshift(r132E, r1350);
                           ir_expression *const r1357 = rshift(r132D, r134C);
                           body.emit(assign(r134E, bit_or(r1356, r1357), 0x01));

                           body.emit(assign(r134F, rshift(r132E, r134C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1354->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1359 = equal(r134C, body.constant(int(32)));
                           ir_if *f1358 = new(mem_ctx) ir_if(operand(r1359).val);
                           exec_list *const f1358_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1358->then_instructions;

                              body.emit(assign(r134D, r132D, 0x01));

                              body.emit(assign(r134E, r132E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1358->else_instructions;

                              body.emit(assign(r134B, bit_or(r132C, r132D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r135B = less(r134C, body.constant(int(64)));
                              ir_if *f135A = new(mem_ctx) ir_if(operand(r135B).val);
                              exec_list *const f135A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f135A->then_instructions;

                                 body.emit(assign(r134D, lshift(r132E, r1350), 0x01));

                                 ir_expression *const r135C = bit_and(r134C, body.constant(int(31)));
                                 body.emit(assign(r134E, rshift(r132E, r135C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f135A->else_instructions;

                                 ir_variable *const r135D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r135F = equal(r134C, body.constant(int(64)));
                                 ir_if *f135E = new(mem_ctx) ir_if(operand(r135F).val);
                                 exec_list *const f135E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f135E->then_instructions;

                                    body.emit(assign(r135D, r132E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f135E->else_instructions;

                                    ir_expression *const r1360 = nequal(r132E, body.constant(0u));
                                    ir_expression *const r1361 = expr(ir_unop_b2i, r1360);
                                    body.emit(assign(r135D, expr(ir_unop_i2u, r1361), 0x01));


                                 body.instructions = f135E_parent_instructions;
                                 body.emit(f135E);

                                 /* END IF */

                                 body.emit(assign(r134D, r135D, 0x01));

                                 body.emit(assign(r134E, body.constant(0u), 0x01));


                              body.instructions = f135A_parent_instructions;
                              body.emit(f135A);

                              /* END IF */


                           body.instructions = f1358_parent_instructions;
                           body.emit(f1358);

                           /* END IF */

                           body.emit(assign(r134F, body.constant(0u), 0x01));


                        body.instructions = f1354_parent_instructions;
                        body.emit(f1354);

                        /* END IF */

                        ir_expression *const r1362 = nequal(r134B, body.constant(0u));
                        ir_expression *const r1363 = expr(ir_unop_b2i, r1362);
                        ir_expression *const r1364 = expr(ir_unop_i2u, r1363);
                        body.emit(assign(r134D, bit_or(r134D, r1364), 0x01));


                     body.instructions = f1352_parent_instructions;
                     body.emit(f1352);

                     /* END IF */

                     body.emit(assign(r1335, r134F, 0x01));

                     body.emit(assign(r1336, r134E, 0x01));

                     body.emit(assign(r1337, r134D, 0x01));

                     body.emit(assign(r1334, body.constant(int(0)), 0x01));

                     body.emit(assign(r133A, less(r134D, body.constant(0u)), 0x01));


                  body.instructions = f1349_parent_instructions;
                  body.emit(f1349);

                  /* END IF */


               body.instructions = f1346_parent_instructions;
               body.emit(f1346);

               /* END IF */


            body.instructions = f133C_parent_instructions;
            body.emit(f133C);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1365 = new(mem_ctx) ir_if(operand(r1338).val);
            exec_list *const f1365_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1365->then_instructions;

               /* IF CONDITION */
               ir_if *f1366 = new(mem_ctx) ir_if(operand(r133A).val);
               exec_list *const f1366_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1366->then_instructions;

                  ir_variable *const r1367 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1367, add(r1336, body.constant(1u)), 0x01));

                  ir_expression *const r1368 = less(r1367, r1336);
                  ir_expression *const r1369 = expr(ir_unop_b2i, r1368);
                  ir_expression *const r136A = expr(ir_unop_i2u, r1369);
                  body.emit(assign(r1335, add(r1335, r136A), 0x01));

                  ir_expression *const r136B = equal(r1337, body.constant(0u));
                  ir_expression *const r136C = expr(ir_unop_b2i, r136B);
                  ir_expression *const r136D = expr(ir_unop_i2u, r136C);
                  ir_expression *const r136E = add(r1337, r136D);
                  ir_expression *const r136F = bit_and(r136E, body.constant(1u));
                  ir_expression *const r1370 = expr(ir_unop_bit_not, r136F);
                  body.emit(assign(r1336, bit_and(r1367, r1370), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1366->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1372 = bit_or(r1335, r1336);
                  ir_expression *const r1373 = equal(r1372, body.constant(0u));
                  ir_if *f1371 = new(mem_ctx) ir_if(operand(r1373).val);
                  exec_list *const f1371_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1371->then_instructions;

                     body.emit(assign(r1334, body.constant(int(0)), 0x01));


                  body.instructions = f1371_parent_instructions;
                  body.emit(f1371);

                  /* END IF */


               body.instructions = f1366_parent_instructions;
               body.emit(f1366);

               /* END IF */

               ir_variable *const r1374 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1374);
               ir_expression *const r1375 = lshift(r0DB4, body.constant(int(31)));
               ir_expression *const r1376 = expr(ir_unop_i2u, r1334);
               ir_expression *const r1377 = lshift(r1376, body.constant(int(20)));
               ir_expression *const r1378 = add(r1375, r1377);
               body.emit(assign(r1374, add(r1378, r1335), 0x02));

               body.emit(assign(r1374, r1336, 0x01));

               body.emit(assign(r1339, r1374, 0x03));

               body.emit(assign(r1338, body.constant(false), 0x01));


            body.instructions = f1365_parent_instructions;
            body.emit(f1365);

            /* END IF */

            body.emit(assign(r11D1, r1339, 0x03));

            body.emit(assign(r11D0, body.constant(false), 0x01));


         body.instructions = f12E5_parent_instructions;
         body.emit(f12E5);

         /* END IF */


      body.instructions = f12DE_parent_instructions;
      body.emit(f12DE);

      /* END IF */

      body.emit(assign(r0DB3, r11D1, 0x03));


   body.instructions = f0DB6_parent_instructions;
   body.emit(f0DB6);

   /* END IF */

   body.emit(ret(r0DB3));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul32To64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1379 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1379);
   ir_variable *const r137A = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r137A);
   ir_variable *const r137B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r137B);
   ir_variable *const r137C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r137C);
   ir_variable *const r137D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r137D);
   ir_variable *const r137E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r137E);
   ir_variable *const r137F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r137F);
   ir_variable *const r1380 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1380, bit_and(r1379, body.constant(65535u)), 0x01));

   ir_variable *const r1381 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1381, rshift(r1379, body.constant(int(16))), 0x01));

   ir_variable *const r1382 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1382, bit_and(r137A, body.constant(65535u)), 0x01));

   ir_variable *const r1383 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1383, rshift(r137A, body.constant(int(16))), 0x01));

   ir_variable *const r1384 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1384, mul(r1381, r1382), 0x01));

   ir_expression *const r1385 = mul(r1380, r1383);
   body.emit(assign(r137E, add(r1385, r1384), 0x01));

   ir_expression *const r1386 = mul(r1381, r1383);
   ir_expression *const r1387 = less(r137E, r1384);
   ir_expression *const r1388 = expr(ir_unop_b2i, r1387);
   ir_expression *const r1389 = expr(ir_unop_i2u, r1388);
   ir_expression *const r138A = lshift(r1389, body.constant(int(16)));
   ir_expression *const r138B = rshift(r137E, body.constant(int(16)));
   ir_expression *const r138C = add(r138A, r138B);
   body.emit(assign(r137D, add(r1386, r138C), 0x01));

   body.emit(assign(r137E, lshift(r137E, body.constant(int(16))), 0x01));

   ir_expression *const r138D = mul(r1380, r1382);
   body.emit(assign(r137F, add(r138D, r137E), 0x01));

   ir_expression *const r138E = less(r137F, r137E);
   ir_expression *const r138F = expr(ir_unop_b2i, r138E);
   ir_expression *const r1390 = expr(ir_unop_i2u, r138F);
   body.emit(assign(r137D, add(r137D, r1390), 0x01));

   body.emit(assign(r137C, r137F, 0x01));

   body.emit(assign(r137B, r137D, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64To128(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1391 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1391);
   ir_variable *const r1392 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1392);
   ir_variable *const r1393 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r1393);
   ir_variable *const r1394 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1394);
   ir_variable *const r1395 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1395);
   ir_variable *const r1396 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1396);
   ir_variable *const r1397 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1397);
   ir_variable *const r1398 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z3Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1398);
   ir_variable *const r1399 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1399);
   ir_variable *const r139A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r139A);
   ir_variable *const r139B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r139B);
   ir_variable *const r139C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139C, bit_and(r1392, body.constant(65535u)), 0x01));

   ir_variable *const r139D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139D, rshift(r1392, body.constant(int(16))), 0x01));

   ir_variable *const r139E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139E, bit_and(r1394, body.constant(65535u)), 0x01));

   ir_variable *const r139F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139F, rshift(r1394, body.constant(int(16))), 0x01));

   ir_variable *const r13A0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13A0, mul(r139D, r139E), 0x01));

   ir_expression *const r13A1 = mul(r139C, r139F);
   body.emit(assign(r139A, add(r13A1, r13A0), 0x01));

   ir_expression *const r13A2 = mul(r139D, r139F);
   ir_expression *const r13A3 = less(r139A, r13A0);
   ir_expression *const r13A4 = expr(ir_unop_b2i, r13A3);
   ir_expression *const r13A5 = expr(ir_unop_i2u, r13A4);
   ir_expression *const r13A6 = lshift(r13A5, body.constant(int(16)));
   ir_expression *const r13A7 = rshift(r139A, body.constant(int(16)));
   ir_expression *const r13A8 = add(r13A6, r13A7);
   body.emit(assign(r1399, add(r13A2, r13A8), 0x01));

   body.emit(assign(r139A, lshift(r139A, body.constant(int(16))), 0x01));

   ir_expression *const r13A9 = mul(r139C, r139E);
   body.emit(assign(r139B, add(r13A9, r139A), 0x01));

   ir_expression *const r13AA = less(r139B, r139A);
   ir_expression *const r13AB = expr(ir_unop_b2i, r13AA);
   ir_expression *const r13AC = expr(ir_unop_i2u, r13AB);
   body.emit(assign(r1399, add(r1399, r13AC), 0x01));

   ir_variable *const r13AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13AD);
   ir_variable *const r13AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13AE);
   ir_variable *const r13AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13AF);
   ir_variable *const r13B0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B0, bit_and(r1392, body.constant(65535u)), 0x01));

   ir_variable *const r13B1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B1, rshift(r1392, body.constant(int(16))), 0x01));

   ir_variable *const r13B2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B2, bit_and(r1393, body.constant(65535u)), 0x01));

   ir_variable *const r13B3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B3, rshift(r1393, body.constant(int(16))), 0x01));

   ir_variable *const r13B4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B4, mul(r13B1, r13B2), 0x01));

   ir_expression *const r13B5 = mul(r13B0, r13B3);
   body.emit(assign(r13AE, add(r13B5, r13B4), 0x01));

   ir_expression *const r13B6 = mul(r13B1, r13B3);
   ir_expression *const r13B7 = less(r13AE, r13B4);
   ir_expression *const r13B8 = expr(ir_unop_b2i, r13B7);
   ir_expression *const r13B9 = expr(ir_unop_i2u, r13B8);
   ir_expression *const r13BA = lshift(r13B9, body.constant(int(16)));
   ir_expression *const r13BB = rshift(r13AE, body.constant(int(16)));
   ir_expression *const r13BC = add(r13BA, r13BB);
   body.emit(assign(r13AD, add(r13B6, r13BC), 0x01));

   body.emit(assign(r13AE, lshift(r13AE, body.constant(int(16))), 0x01));

   ir_expression *const r13BD = mul(r13B0, r13B2);
   body.emit(assign(r13AF, add(r13BD, r13AE), 0x01));

   ir_expression *const r13BE = less(r13AF, r13AE);
   ir_expression *const r13BF = expr(ir_unop_b2i, r13BE);
   ir_expression *const r13C0 = expr(ir_unop_i2u, r13BF);
   body.emit(assign(r13AD, add(r13AD, r13C0), 0x01));

   ir_variable *const r13C1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C1, add(r13AF, r1399), 0x01));

   ir_variable *const r13C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13C2);
   ir_variable *const r13C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13C3);
   ir_variable *const r13C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13C4);
   ir_variable *const r13C5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C5, bit_and(r1391, body.constant(65535u)), 0x01));

   ir_variable *const r13C6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C6, rshift(r1391, body.constant(int(16))), 0x01));

   ir_variable *const r13C7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C7, bit_and(r1393, body.constant(65535u)), 0x01));

   ir_variable *const r13C8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C8, rshift(r1393, body.constant(int(16))), 0x01));

   ir_variable *const r13C9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C9, mul(r13C6, r13C7), 0x01));

   ir_expression *const r13CA = mul(r13C5, r13C8);
   body.emit(assign(r13C3, add(r13CA, r13C9), 0x01));

   ir_expression *const r13CB = mul(r13C6, r13C8);
   ir_expression *const r13CC = less(r13C3, r13C9);
   ir_expression *const r13CD = expr(ir_unop_b2i, r13CC);
   ir_expression *const r13CE = expr(ir_unop_i2u, r13CD);
   ir_expression *const r13CF = lshift(r13CE, body.constant(int(16)));
   ir_expression *const r13D0 = rshift(r13C3, body.constant(int(16)));
   ir_expression *const r13D1 = add(r13CF, r13D0);
   body.emit(assign(r13C2, add(r13CB, r13D1), 0x01));

   body.emit(assign(r13C3, lshift(r13C3, body.constant(int(16))), 0x01));

   ir_expression *const r13D2 = mul(r13C5, r13C7);
   body.emit(assign(r13C4, add(r13D2, r13C3), 0x01));

   ir_expression *const r13D3 = less(r13C4, r13C3);
   ir_expression *const r13D4 = expr(ir_unop_b2i, r13D3);
   ir_expression *const r13D5 = expr(ir_unop_i2u, r13D4);
   body.emit(assign(r13C2, add(r13C2, r13D5), 0x01));

   ir_variable *const r13D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r13D7 = less(r13C1, r13AF);
   ir_expression *const r13D8 = expr(ir_unop_b2i, r13D7);
   ir_expression *const r13D9 = expr(ir_unop_i2u, r13D8);
   ir_expression *const r13DA = add(r13AD, r13D9);
   body.emit(assign(r13D6, add(r13C4, r13DA), 0x01));

   ir_variable *const r13DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13DB);
   ir_variable *const r13DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13DC);
   ir_variable *const r13DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13DD);
   ir_variable *const r13DE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DE, bit_and(r1391, body.constant(65535u)), 0x01));

   ir_variable *const r13DF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DF, rshift(r1391, body.constant(int(16))), 0x01));

   ir_variable *const r13E0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13E0, bit_and(r1394, body.constant(65535u)), 0x01));

   ir_variable *const r13E1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13E1, rshift(r1394, body.constant(int(16))), 0x01));

   ir_variable *const r13E2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13E2, mul(r13DF, r13E0), 0x01));

   ir_expression *const r13E3 = mul(r13DE, r13E1);
   body.emit(assign(r13DC, add(r13E3, r13E2), 0x01));

   ir_expression *const r13E4 = mul(r13DF, r13E1);
   ir_expression *const r13E5 = less(r13DC, r13E2);
   ir_expression *const r13E6 = expr(ir_unop_b2i, r13E5);
   ir_expression *const r13E7 = expr(ir_unop_i2u, r13E6);
   ir_expression *const r13E8 = lshift(r13E7, body.constant(int(16)));
   ir_expression *const r13E9 = rshift(r13DC, body.constant(int(16)));
   ir_expression *const r13EA = add(r13E8, r13E9);
   body.emit(assign(r13DB, add(r13E4, r13EA), 0x01));

   body.emit(assign(r13DC, lshift(r13DC, body.constant(int(16))), 0x01));

   ir_expression *const r13EB = mul(r13DE, r13E0);
   body.emit(assign(r13DD, add(r13EB, r13DC), 0x01));

   ir_expression *const r13EC = less(r13DD, r13DC);
   ir_expression *const r13ED = expr(ir_unop_b2i, r13EC);
   ir_expression *const r13EE = expr(ir_unop_i2u, r13ED);
   body.emit(assign(r13DB, add(r13DB, r13EE), 0x01));

   ir_variable *const r13EF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13EF, add(r13DD, r13C1), 0x01));

   ir_variable *const r13F0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r13F1 = less(r13EF, r13DD);
   ir_expression *const r13F2 = expr(ir_unop_b2i, r13F1);
   ir_expression *const r13F3 = expr(ir_unop_i2u, r13F2);
   ir_expression *const r13F4 = add(r13DB, r13F3);
   body.emit(assign(r13F0, add(r13D6, r13F4), 0x01));

   body.emit(assign(r1398, r139B, 0x01));

   body.emit(assign(r1397, r13EF, 0x01));

   body.emit(assign(r1396, r13F0, 0x01));

   ir_expression *const r13F5 = less(r13D6, r13C4);
   ir_expression *const r13F6 = expr(ir_unop_b2i, r13F5);
   ir_expression *const r13F7 = expr(ir_unop_i2u, r13F6);
   ir_expression *const r13F8 = add(r13C2, r13F7);
   ir_expression *const r13F9 = less(r13F0, r13D6);
   ir_expression *const r13FA = expr(ir_unop_b2i, r13F9);
   ir_expression *const r13FB = expr(ir_unop_i2u, r13FA);
   body.emit(assign(r1395, add(r13F8, r13FB), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat64Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r13FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac0", ir_var_function_in);
   sig_parameters.push_tail(r13FC);
   ir_variable *const r13FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac1", ir_var_function_in);
   sig_parameters.push_tail(r13FD);
   ir_variable *const r13FE = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r13FE);
   ir_variable *const r13FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r13FF);
   ir_variable *const r1400 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1400);
   ir_variable *const r1401 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r1401);
   /* IF CONDITION */
   ir_expression *const r1403 = equal(r13FC, body.constant(0u));
   ir_if *f1402 = new(mem_ctx) ir_if(operand(r1403).val);
   exec_list *const f1402_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1402->then_instructions;

      ir_variable *const r1404 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1404, r13FD, 0x01));

      ir_variable *const r1405 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1406 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1406);
      /* IF CONDITION */
      ir_expression *const r1408 = equal(r13FD, body.constant(0u));
      ir_if *f1407 = new(mem_ctx) ir_if(operand(r1408).val);
      exec_list *const f1407_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1407->then_instructions;

         body.emit(assign(r1405, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1407->else_instructions;

         body.emit(assign(r1406, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r140A = bit_and(r13FD, body.constant(4294901760u));
         ir_expression *const r140B = equal(r140A, body.constant(0u));
         ir_if *f1409 = new(mem_ctx) ir_if(operand(r140B).val);
         exec_list *const f1409_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1409->then_instructions;

            body.emit(assign(r1406, body.constant(int(16)), 0x01));

            body.emit(assign(r1404, lshift(r13FD, body.constant(int(16))), 0x01));


         body.instructions = f1409_parent_instructions;
         body.emit(f1409);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r140D = bit_and(r1404, body.constant(4278190080u));
         ir_expression *const r140E = equal(r140D, body.constant(0u));
         ir_if *f140C = new(mem_ctx) ir_if(operand(r140E).val);
         exec_list *const f140C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f140C->then_instructions;

            body.emit(assign(r1406, add(r1406, body.constant(int(8))), 0x01));

            body.emit(assign(r1404, lshift(r1404, body.constant(int(8))), 0x01));


         body.instructions = f140C_parent_instructions;
         body.emit(f140C);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1410 = bit_and(r1404, body.constant(4026531840u));
         ir_expression *const r1411 = equal(r1410, body.constant(0u));
         ir_if *f140F = new(mem_ctx) ir_if(operand(r1411).val);
         exec_list *const f140F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f140F->then_instructions;

            body.emit(assign(r1406, add(r1406, body.constant(int(4))), 0x01));

            body.emit(assign(r1404, lshift(r1404, body.constant(int(4))), 0x01));


         body.instructions = f140F_parent_instructions;
         body.emit(f140F);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1413 = bit_and(r1404, body.constant(3221225472u));
         ir_expression *const r1414 = equal(r1413, body.constant(0u));
         ir_if *f1412 = new(mem_ctx) ir_if(operand(r1414).val);
         exec_list *const f1412_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1412->then_instructions;

            body.emit(assign(r1406, add(r1406, body.constant(int(2))), 0x01));

            body.emit(assign(r1404, lshift(r1404, body.constant(int(2))), 0x01));


         body.instructions = f1412_parent_instructions;
         body.emit(f1412);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1416 = bit_and(r1404, body.constant(2147483648u));
         ir_expression *const r1417 = equal(r1416, body.constant(0u));
         ir_if *f1415 = new(mem_ctx) ir_if(operand(r1417).val);
         exec_list *const f1415_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1415->then_instructions;

            body.emit(assign(r1406, add(r1406, body.constant(int(1))), 0x01));


         body.instructions = f1415_parent_instructions;
         body.emit(f1415);

         /* END IF */

         body.emit(assign(r1405, r1406, 0x01));


      body.instructions = f1407_parent_instructions;
      body.emit(f1407);

      /* END IF */

      body.emit(assign(r1401, add(r1405, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1419 = less(r1401, body.constant(int(0)));
      ir_if *f1418 = new(mem_ctx) ir_if(operand(r1419).val);
      exec_list *const f1418_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1418->then_instructions;

         ir_expression *const r141A = neg(r1401);
         body.emit(assign(r13FF, rshift(r13FD, r141A), 0x01));

         ir_expression *const r141B = bit_and(r1401, body.constant(int(31)));
         body.emit(assign(r1400, lshift(r13FD, r141B), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1418->else_instructions;

         body.emit(assign(r13FF, lshift(r13FD, r1401), 0x01));

         body.emit(assign(r1400, body.constant(0u), 0x01));


      body.instructions = f1418_parent_instructions;
      body.emit(f1418);

      /* END IF */

      body.emit(assign(r13FE, sub(body.constant(int(-31)), r1401), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1402->else_instructions;

      ir_variable *const r141C = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r141C, r13FC, 0x01));

      ir_variable *const r141D = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r141E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r141E);
      /* IF CONDITION */
      ir_expression *const r1420 = equal(r13FC, body.constant(0u));
      ir_if *f141F = new(mem_ctx) ir_if(operand(r1420).val);
      exec_list *const f141F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f141F->then_instructions;

         body.emit(assign(r141D, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f141F->else_instructions;

         body.emit(assign(r141E, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1422 = bit_and(r13FC, body.constant(4294901760u));
         ir_expression *const r1423 = equal(r1422, body.constant(0u));
         ir_if *f1421 = new(mem_ctx) ir_if(operand(r1423).val);
         exec_list *const f1421_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1421->then_instructions;

            body.emit(assign(r141E, body.constant(int(16)), 0x01));

            body.emit(assign(r141C, lshift(r13FC, body.constant(int(16))), 0x01));


         body.instructions = f1421_parent_instructions;
         body.emit(f1421);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1425 = bit_and(r141C, body.constant(4278190080u));
         ir_expression *const r1426 = equal(r1425, body.constant(0u));
         ir_if *f1424 = new(mem_ctx) ir_if(operand(r1426).val);
         exec_list *const f1424_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1424->then_instructions;

            body.emit(assign(r141E, add(r141E, body.constant(int(8))), 0x01));

            body.emit(assign(r141C, lshift(r141C, body.constant(int(8))), 0x01));


         body.instructions = f1424_parent_instructions;
         body.emit(f1424);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1428 = bit_and(r141C, body.constant(4026531840u));
         ir_expression *const r1429 = equal(r1428, body.constant(0u));
         ir_if *f1427 = new(mem_ctx) ir_if(operand(r1429).val);
         exec_list *const f1427_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1427->then_instructions;

            body.emit(assign(r141E, add(r141E, body.constant(int(4))), 0x01));

            body.emit(assign(r141C, lshift(r141C, body.constant(int(4))), 0x01));


         body.instructions = f1427_parent_instructions;
         body.emit(f1427);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r142B = bit_and(r141C, body.constant(3221225472u));
         ir_expression *const r142C = equal(r142B, body.constant(0u));
         ir_if *f142A = new(mem_ctx) ir_if(operand(r142C).val);
         exec_list *const f142A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f142A->then_instructions;

            body.emit(assign(r141E, add(r141E, body.constant(int(2))), 0x01));

            body.emit(assign(r141C, lshift(r141C, body.constant(int(2))), 0x01));


         body.instructions = f142A_parent_instructions;
         body.emit(f142A);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r142E = bit_and(r141C, body.constant(2147483648u));
         ir_expression *const r142F = equal(r142E, body.constant(0u));
         ir_if *f142D = new(mem_ctx) ir_if(operand(r142F).val);
         exec_list *const f142D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f142D->then_instructions;

            body.emit(assign(r141E, add(r141E, body.constant(int(1))), 0x01));


         body.instructions = f142D_parent_instructions;
         body.emit(f142D);

         /* END IF */

         body.emit(assign(r141D, r141E, 0x01));


      body.instructions = f141F_parent_instructions;
      body.emit(f141F);

      /* END IF */

      body.emit(assign(r1401, add(r141D, body.constant(int(-11))), 0x01));

      ir_variable *const r1430 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r1430, lshift(r13FD, r1401), 0x01));

      ir_variable *const r1431 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1433 = equal(r1401, body.constant(int(0)));
      ir_if *f1432 = new(mem_ctx) ir_if(operand(r1433).val);
      exec_list *const f1432_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1432->then_instructions;

         body.emit(assign(r1431, r13FC, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1432->else_instructions;

         ir_expression *const r1434 = lshift(r13FC, r1401);
         ir_expression *const r1435 = neg(r1401);
         ir_expression *const r1436 = bit_and(r1435, body.constant(int(31)));
         ir_expression *const r1437 = rshift(r13FD, r1436);
         body.emit(assign(r1431, bit_or(r1434, r1437), 0x01));


      body.instructions = f1432_parent_instructions;
      body.emit(f1432);

      /* END IF */

      body.emit(assign(r13FF, r1431, 0x01));

      body.emit(assign(r1400, r1430, 0x01));

      body.emit(assign(r13FE, sub(body.constant(int(1)), r1401), 0x01));


   body.instructions = f1402_parent_instructions;
   body.emit(f1402);

   /* END IF */

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmul64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1438 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1438);
   ir_variable *const r1439 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1439);
   ir_variable *const r143A = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r143A, body.constant(true), 0x01));

   ir_variable *const r143B = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r143C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r143C);
   ir_variable *const r143D = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r143D);
   ir_variable *const r143E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r143E);
   ir_variable *const r143F = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r143F);
   ir_variable *const r1440 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r1440);
   ir_variable *const r1441 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r1441);
   ir_variable *const r1442 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r1442);
   ir_variable *const r1443 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1443);
   ir_variable *const r1444 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1444);
   body.emit(assign(r1444, body.constant(0u), 0x01));

   body.emit(assign(r1443, body.constant(0u), 0x01));

   body.emit(assign(r1442, body.constant(0u), 0x01));

   ir_variable *const r1445 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1445);
   body.emit(assign(r1445, bit_and(swizzle_y(r1438), body.constant(1048575u)), 0x02));

   body.emit(assign(r1445, swizzle_x(r1438), 0x01));

   body.emit(assign(r1440, r1445, 0x03));

   ir_variable *const r1446 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1447 = rshift(swizzle_y(r1438), body.constant(int(20)));
   ir_expression *const r1448 = bit_and(r1447, body.constant(2047u));
   body.emit(assign(r1446, expr(ir_unop_u2i, r1448), 0x01));

   body.emit(assign(r143F, r1446, 0x01));

   ir_variable *const r1449 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1449);
   body.emit(assign(r1449, bit_and(swizzle_y(r1439), body.constant(1048575u)), 0x02));

   body.emit(assign(r1449, swizzle_x(r1439), 0x01));

   body.emit(assign(r143E, r1449, 0x03));

   ir_variable *const r144A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r144B = rshift(swizzle_y(r1439), body.constant(int(20)));
   ir_expression *const r144C = bit_and(r144B, body.constant(2047u));
   body.emit(assign(r144A, expr(ir_unop_u2i, r144C), 0x01));

   body.emit(assign(r143D, r144A, 0x01));

   ir_expression *const r144D = rshift(swizzle_y(r1438), body.constant(int(31)));
   ir_expression *const r144E = rshift(swizzle_y(r1439), body.constant(int(31)));
   body.emit(assign(r143C, bit_xor(r144D, r144E), 0x01));

   /* IF CONDITION */
   ir_expression *const r1450 = equal(r1446, body.constant(int(2047)));
   ir_if *f144F = new(mem_ctx) ir_if(operand(r1450).val);
   exec_list *const f144F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f144F->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1452 = bit_or(swizzle_y(r1445), swizzle_x(r1438));
      ir_expression *const r1453 = nequal(r1452, body.constant(0u));
      ir_expression *const r1454 = equal(r144A, body.constant(int(2047)));
      ir_expression *const r1455 = bit_or(swizzle_y(r1449), swizzle_x(r1439));
      ir_expression *const r1456 = nequal(r1455, body.constant(0u));
      ir_expression *const r1457 = logic_and(r1454, r1456);
      ir_expression *const r1458 = logic_or(r1453, r1457);
      ir_if *f1451 = new(mem_ctx) ir_if(operand(r1458).val);
      exec_list *const f1451_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1451->then_instructions;

         ir_variable *const r1459 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r1459, swizzle_x(r1438), 0x01));

         ir_variable *const r145A = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r145A, swizzle_x(r1439), 0x01));

         ir_variable *const r145B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r145C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r145D = rshift(swizzle_y(r1438), body.constant(int(19)));
         ir_expression *const r145E = bit_and(r145D, body.constant(4095u));
         ir_expression *const r145F = equal(r145E, body.constant(4094u));
         ir_expression *const r1460 = nequal(swizzle_x(r1438), body.constant(0u));
         ir_expression *const r1461 = bit_and(swizzle_y(r1438), body.constant(524287u));
         ir_expression *const r1462 = nequal(r1461, body.constant(0u));
         ir_expression *const r1463 = logic_or(r1460, r1462);
         body.emit(assign(r145C, logic_and(r145F, r1463), 0x01));

         ir_variable *const r1464 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r1465 = lshift(swizzle_y(r1439), body.constant(int(1)));
         ir_expression *const r1466 = lequal(body.constant(4292870144u), r1465);
         ir_expression *const r1467 = nequal(swizzle_x(r1439), body.constant(0u));
         ir_expression *const r1468 = bit_and(swizzle_y(r1439), body.constant(1048575u));
         ir_expression *const r1469 = nequal(r1468, body.constant(0u));
         ir_expression *const r146A = logic_or(r1467, r1469);
         body.emit(assign(r1464, logic_and(r1466, r146A), 0x01));

         body.emit(assign(r1459, bit_or(swizzle_y(r1438), body.constant(524288u)), 0x02));

         body.emit(assign(r145A, bit_or(swizzle_y(r1439), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r146C = lshift(swizzle_y(r1438), body.constant(int(1)));
         ir_expression *const r146D = lequal(body.constant(4292870144u), r146C);
         ir_expression *const r146E = nequal(swizzle_x(r1438), body.constant(0u));
         ir_expression *const r146F = bit_and(swizzle_y(r1438), body.constant(1048575u));
         ir_expression *const r1470 = nequal(r146F, body.constant(0u));
         ir_expression *const r1471 = logic_or(r146E, r1470);
         ir_expression *const r1472 = logic_and(r146D, r1471);
         ir_if *f146B = new(mem_ctx) ir_if(operand(r1472).val);
         exec_list *const f146B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f146B->then_instructions;

            ir_variable *const r1473 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1475 = logic_and(r145C, r1464);
            ir_if *f1474 = new(mem_ctx) ir_if(operand(r1475).val);
            exec_list *const f1474_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1474->then_instructions;

               body.emit(assign(r1473, r145A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1474->else_instructions;

               body.emit(assign(r1473, r1459, 0x03));


            body.instructions = f1474_parent_instructions;
            body.emit(f1474);

            /* END IF */

            body.emit(assign(r145B, r1473, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f146B->else_instructions;

            body.emit(assign(r145B, r145A, 0x03));


         body.instructions = f146B_parent_instructions;
         body.emit(f146B);

         /* END IF */

         body.emit(assign(r143B, r145B, 0x03));

         body.emit(assign(r143A, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1451->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1477 = expr(ir_unop_i2u, r144A);
         ir_expression *const r1478 = bit_or(r1477, swizzle_y(r1449));
         ir_expression *const r1479 = bit_or(r1478, swizzle_x(r1439));
         ir_expression *const r147A = equal(r1479, body.constant(0u));
         ir_if *f1476 = new(mem_ctx) ir_if(operand(r147A).val);
         exec_list *const f1476_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1476->then_instructions;

            ir_constant_data r147B_data;
            memset(&r147B_data, 0, sizeof(ir_constant_data));
            r147B_data.u[0] = 4294967295;
            r147B_data.u[1] = 4294967295;
            ir_constant *const r147B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r147B_data);
            body.emit(assign(r143B, r147B, 0x03));

            body.emit(assign(r143A, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1476->else_instructions;

            ir_variable *const r147C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r147C);
            ir_expression *const r147D = lshift(r143C, body.constant(int(31)));
            body.emit(assign(r147C, add(r147D, body.constant(2146435072u)), 0x02));

            body.emit(assign(r147C, body.constant(0u), 0x01));

            body.emit(assign(r143B, r147C, 0x03));

            body.emit(assign(r143A, body.constant(false), 0x01));


         body.instructions = f1476_parent_instructions;
         body.emit(f1476);

         /* END IF */


      body.instructions = f1451_parent_instructions;
      body.emit(f1451);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f144F->else_instructions;

      /* IF CONDITION */
      ir_expression *const r147F = equal(r144A, body.constant(int(2047)));
      ir_if *f147E = new(mem_ctx) ir_if(operand(r147F).val);
      exec_list *const f147E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f147E->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1481 = bit_or(swizzle_y(r1449), swizzle_x(r1439));
         ir_expression *const r1482 = nequal(r1481, body.constant(0u));
         ir_if *f1480 = new(mem_ctx) ir_if(operand(r1482).val);
         exec_list *const f1480_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1480->then_instructions;

            ir_variable *const r1483 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r1483, swizzle_x(r1438), 0x01));

            ir_variable *const r1484 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r1484, swizzle_x(r1439), 0x01));

            ir_variable *const r1485 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r1486 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r1487 = rshift(swizzle_y(r1438), body.constant(int(19)));
            ir_expression *const r1488 = bit_and(r1487, body.constant(4095u));
            ir_expression *const r1489 = equal(r1488, body.constant(4094u));
            ir_expression *const r148A = nequal(swizzle_x(r1438), body.constant(0u));
            ir_expression *const r148B = bit_and(swizzle_y(r1438), body.constant(524287u));
            ir_expression *const r148C = nequal(r148B, body.constant(0u));
            ir_expression *const r148D = logic_or(r148A, r148C);
            body.emit(assign(r1486, logic_and(r1489, r148D), 0x01));

            ir_variable *const r148E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r148F = lshift(swizzle_y(r1439), body.constant(int(1)));
            ir_expression *const r1490 = lequal(body.constant(4292870144u), r148F);
            ir_expression *const r1491 = nequal(swizzle_x(r1439), body.constant(0u));
            ir_expression *const r1492 = bit_and(swizzle_y(r1439), body.constant(1048575u));
            ir_expression *const r1493 = nequal(r1492, body.constant(0u));
            ir_expression *const r1494 = logic_or(r1491, r1493);
            body.emit(assign(r148E, logic_and(r1490, r1494), 0x01));

            body.emit(assign(r1483, bit_or(swizzle_y(r1438), body.constant(524288u)), 0x02));

            body.emit(assign(r1484, bit_or(swizzle_y(r1439), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r1496 = lshift(swizzle_y(r1438), body.constant(int(1)));
            ir_expression *const r1497 = lequal(body.constant(4292870144u), r1496);
            ir_expression *const r1498 = nequal(swizzle_x(r1438), body.constant(0u));
            ir_expression *const r1499 = bit_and(swizzle_y(r1438), body.constant(1048575u));
            ir_expression *const r149A = nequal(r1499, body.constant(0u));
            ir_expression *const r149B = logic_or(r1498, r149A);
            ir_expression *const r149C = logic_and(r1497, r149B);
            ir_if *f1495 = new(mem_ctx) ir_if(operand(r149C).val);
            exec_list *const f1495_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1495->then_instructions;

               ir_variable *const r149D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r149F = logic_and(r1486, r148E);
               ir_if *f149E = new(mem_ctx) ir_if(operand(r149F).val);
               exec_list *const f149E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f149E->then_instructions;

                  body.emit(assign(r149D, r1484, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f149E->else_instructions;

                  body.emit(assign(r149D, r1483, 0x03));


               body.instructions = f149E_parent_instructions;
               body.emit(f149E);

               /* END IF */

               body.emit(assign(r1485, r149D, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1495->else_instructions;

               body.emit(assign(r1485, r1484, 0x03));


            body.instructions = f1495_parent_instructions;
            body.emit(f1495);

            /* END IF */

            body.emit(assign(r143B, r1485, 0x03));

            body.emit(assign(r143A, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1480->else_instructions;

            /* IF CONDITION */
            ir_expression *const r14A1 = expr(ir_unop_i2u, r1446);
            ir_expression *const r14A2 = bit_or(r14A1, swizzle_y(r1445));
            ir_expression *const r14A3 = bit_or(r14A2, swizzle_x(r1438));
            ir_expression *const r14A4 = equal(r14A3, body.constant(0u));
            ir_if *f14A0 = new(mem_ctx) ir_if(operand(r14A4).val);
            exec_list *const f14A0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14A0->then_instructions;

               ir_constant_data r14A5_data;
               memset(&r14A5_data, 0, sizeof(ir_constant_data));
               r14A5_data.u[0] = 4294967295;
               r14A5_data.u[1] = 4294967295;
               ir_constant *const r14A5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r14A5_data);
               body.emit(assign(r143B, r14A5, 0x03));

               body.emit(assign(r143A, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f14A0->else_instructions;

               ir_variable *const r14A6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r14A6);
               ir_expression *const r14A7 = lshift(r143C, body.constant(int(31)));
               body.emit(assign(r14A6, add(r14A7, body.constant(2146435072u)), 0x02));

               body.emit(assign(r14A6, body.constant(0u), 0x01));

               body.emit(assign(r143B, r14A6, 0x03));

               body.emit(assign(r143A, body.constant(false), 0x01));


            body.instructions = f14A0_parent_instructions;
            body.emit(f14A0);

            /* END IF */


         body.instructions = f1480_parent_instructions;
         body.emit(f1480);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f147E->else_instructions;

         /* IF CONDITION */
         ir_expression *const r14A9 = equal(r1446, body.constant(int(0)));
         ir_if *f14A8 = new(mem_ctx) ir_if(operand(r14A9).val);
         exec_list *const f14A8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f14A8->then_instructions;

            /* IF CONDITION */
            ir_expression *const r14AB = bit_or(swizzle_y(r1445), swizzle_x(r1438));
            ir_expression *const r14AC = equal(r14AB, body.constant(0u));
            ir_if *f14AA = new(mem_ctx) ir_if(operand(r14AC).val);
            exec_list *const f14AA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14AA->then_instructions;

               ir_variable *const r14AD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r14AD);
               body.emit(assign(r14AD, lshift(r143C, body.constant(int(31))), 0x02));

               body.emit(assign(r14AD, body.constant(0u), 0x01));

               body.emit(assign(r143B, r14AD, 0x03));

               body.emit(assign(r143A, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f14AA->else_instructions;

               ir_variable *const r14AE = body.make_temp(glsl_type::uint_type, "aFrac0");
               body.emit(assign(r14AE, swizzle_y(r1445), 0x01));

               ir_variable *const r14AF = body.make_temp(glsl_type::uint_type, "aFrac1");
               body.emit(assign(r14AF, swizzle_x(r1445), 0x01));

               ir_variable *const r14B0 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r14B0, r1446, 0x01));

               ir_variable *const r14B1 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r14B1, swizzle_y(r1445), 0x01));

               ir_variable *const r14B2 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r14B2, swizzle_x(r1445), 0x01));

               ir_variable *const r14B3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r14B3);
               /* IF CONDITION */
               ir_expression *const r14B5 = equal(swizzle_y(r1445), body.constant(0u));
               ir_if *f14B4 = new(mem_ctx) ir_if(operand(r14B5).val);
               exec_list *const f14B4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14B4->then_instructions;

                  ir_variable *const r14B6 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r14B6, r14AF, 0x01));

                  ir_variable *const r14B7 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r14B8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14B8);
                  /* IF CONDITION */
                  ir_expression *const r14BA = equal(swizzle_x(r1438), body.constant(0u));
                  ir_if *f14B9 = new(mem_ctx) ir_if(operand(r14BA).val);
                  exec_list *const f14B9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14B9->then_instructions;

                     body.emit(assign(r14B7, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14B9->else_instructions;

                     body.emit(assign(r14B8, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r14BC = bit_and(swizzle_x(r1438), body.constant(4294901760u));
                     ir_expression *const r14BD = equal(r14BC, body.constant(0u));
                     ir_if *f14BB = new(mem_ctx) ir_if(operand(r14BD).val);
                     exec_list *const f14BB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14BB->then_instructions;

                        body.emit(assign(r14B8, body.constant(int(16)), 0x01));

                        body.emit(assign(r14B6, lshift(swizzle_x(r1438), body.constant(int(16))), 0x01));


                     body.instructions = f14BB_parent_instructions;
                     body.emit(f14BB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14BF = bit_and(r14B6, body.constant(4278190080u));
                     ir_expression *const r14C0 = equal(r14BF, body.constant(0u));
                     ir_if *f14BE = new(mem_ctx) ir_if(operand(r14C0).val);
                     exec_list *const f14BE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14BE->then_instructions;

                        body.emit(assign(r14B8, add(r14B8, body.constant(int(8))), 0x01));

                        body.emit(assign(r14B6, lshift(r14B6, body.constant(int(8))), 0x01));


                     body.instructions = f14BE_parent_instructions;
                     body.emit(f14BE);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C2 = bit_and(r14B6, body.constant(4026531840u));
                     ir_expression *const r14C3 = equal(r14C2, body.constant(0u));
                     ir_if *f14C1 = new(mem_ctx) ir_if(operand(r14C3).val);
                     exec_list *const f14C1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C1->then_instructions;

                        body.emit(assign(r14B8, add(r14B8, body.constant(int(4))), 0x01));

                        body.emit(assign(r14B6, lshift(r14B6, body.constant(int(4))), 0x01));


                     body.instructions = f14C1_parent_instructions;
                     body.emit(f14C1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C5 = bit_and(r14B6, body.constant(3221225472u));
                     ir_expression *const r14C6 = equal(r14C5, body.constant(0u));
                     ir_if *f14C4 = new(mem_ctx) ir_if(operand(r14C6).val);
                     exec_list *const f14C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C4->then_instructions;

                        body.emit(assign(r14B8, add(r14B8, body.constant(int(2))), 0x01));

                        body.emit(assign(r14B6, lshift(r14B6, body.constant(int(2))), 0x01));


                     body.instructions = f14C4_parent_instructions;
                     body.emit(f14C4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C8 = bit_and(r14B6, body.constant(2147483648u));
                     ir_expression *const r14C9 = equal(r14C8, body.constant(0u));
                     ir_if *f14C7 = new(mem_ctx) ir_if(operand(r14C9).val);
                     exec_list *const f14C7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C7->then_instructions;

                        body.emit(assign(r14B8, add(r14B8, body.constant(int(1))), 0x01));


                     body.instructions = f14C7_parent_instructions;
                     body.emit(f14C7);

                     /* END IF */

                     body.emit(assign(r14B7, r14B8, 0x01));


                  body.instructions = f14B9_parent_instructions;
                  body.emit(f14B9);

                  /* END IF */

                  body.emit(assign(r14B3, add(r14B7, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r14CB = less(r14B3, body.constant(int(0)));
                  ir_if *f14CA = new(mem_ctx) ir_if(operand(r14CB).val);
                  exec_list *const f14CA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14CA->then_instructions;

                     ir_expression *const r14CC = neg(r14B3);
                     body.emit(assign(r14B1, rshift(swizzle_x(r1438), r14CC), 0x01));

                     ir_expression *const r14CD = bit_and(r14B3, body.constant(int(31)));
                     body.emit(assign(r14B2, lshift(swizzle_x(r1438), r14CD), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14CA->else_instructions;

                     body.emit(assign(r14B1, lshift(swizzle_x(r1438), r14B3), 0x01));

                     body.emit(assign(r14B2, body.constant(0u), 0x01));


                  body.instructions = f14CA_parent_instructions;
                  body.emit(f14CA);

                  /* END IF */

                  body.emit(assign(r14B0, sub(body.constant(int(-31)), r14B3), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14B4->else_instructions;

                  ir_variable *const r14CE = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r14CE, r14AE, 0x01));

                  ir_variable *const r14CF = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r14D0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14D0);
                  /* IF CONDITION */
                  ir_expression *const r14D2 = equal(swizzle_y(r1445), body.constant(0u));
                  ir_if *f14D1 = new(mem_ctx) ir_if(operand(r14D2).val);
                  exec_list *const f14D1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14D1->then_instructions;

                     body.emit(assign(r14CF, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14D1->else_instructions;

                     body.emit(assign(r14D0, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r14D4 = bit_and(swizzle_y(r1445), body.constant(4294901760u));
                     ir_expression *const r14D5 = equal(r14D4, body.constant(0u));
                     ir_if *f14D3 = new(mem_ctx) ir_if(operand(r14D5).val);
                     exec_list *const f14D3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D3->then_instructions;

                        body.emit(assign(r14D0, body.constant(int(16)), 0x01));

                        body.emit(assign(r14CE, lshift(swizzle_y(r1445), body.constant(int(16))), 0x01));


                     body.instructions = f14D3_parent_instructions;
                     body.emit(f14D3);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14D7 = bit_and(r14CE, body.constant(4278190080u));
                     ir_expression *const r14D8 = equal(r14D7, body.constant(0u));
                     ir_if *f14D6 = new(mem_ctx) ir_if(operand(r14D8).val);
                     exec_list *const f14D6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D6->then_instructions;

                        body.emit(assign(r14D0, add(r14D0, body.constant(int(8))), 0x01));

                        body.emit(assign(r14CE, lshift(r14CE, body.constant(int(8))), 0x01));


                     body.instructions = f14D6_parent_instructions;
                     body.emit(f14D6);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14DA = bit_and(r14CE, body.constant(4026531840u));
                     ir_expression *const r14DB = equal(r14DA, body.constant(0u));
                     ir_if *f14D9 = new(mem_ctx) ir_if(operand(r14DB).val);
                     exec_list *const f14D9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D9->then_instructions;

                        body.emit(assign(r14D0, add(r14D0, body.constant(int(4))), 0x01));

                        body.emit(assign(r14CE, lshift(r14CE, body.constant(int(4))), 0x01));


                     body.instructions = f14D9_parent_instructions;
                     body.emit(f14D9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14DD = bit_and(r14CE, body.constant(3221225472u));
                     ir_expression *const r14DE = equal(r14DD, body.constant(0u));
                     ir_if *f14DC = new(mem_ctx) ir_if(operand(r14DE).val);
                     exec_list *const f14DC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14DC->then_instructions;

                        body.emit(assign(r14D0, add(r14D0, body.constant(int(2))), 0x01));

                        body.emit(assign(r14CE, lshift(r14CE, body.constant(int(2))), 0x01));


                     body.instructions = f14DC_parent_instructions;
                     body.emit(f14DC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14E0 = bit_and(r14CE, body.constant(2147483648u));
                     ir_expression *const r14E1 = equal(r14E0, body.constant(0u));
                     ir_if *f14DF = new(mem_ctx) ir_if(operand(r14E1).val);
                     exec_list *const f14DF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14DF->then_instructions;

                        body.emit(assign(r14D0, add(r14D0, body.constant(int(1))), 0x01));


                     body.instructions = f14DF_parent_instructions;
                     body.emit(f14DF);

                     /* END IF */

                     body.emit(assign(r14CF, r14D0, 0x01));


                  body.instructions = f14D1_parent_instructions;
                  body.emit(f14D1);

                  /* END IF */

                  body.emit(assign(r14B3, add(r14CF, body.constant(int(-11))), 0x01));

                  ir_variable *const r14E2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r14E2, lshift(swizzle_x(r1438), r14B3), 0x01));

                  ir_variable *const r14E3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r14E5 = equal(r14B3, body.constant(int(0)));
                  ir_if *f14E4 = new(mem_ctx) ir_if(operand(r14E5).val);
                  exec_list *const f14E4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14E4->then_instructions;

                     body.emit(assign(r14E3, r14AE, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14E4->else_instructions;

                     ir_expression *const r14E6 = lshift(swizzle_y(r1445), r14B3);
                     ir_expression *const r14E7 = neg(r14B3);
                     ir_expression *const r14E8 = bit_and(r14E7, body.constant(int(31)));
                     ir_expression *const r14E9 = rshift(swizzle_x(r1438), r14E8);
                     body.emit(assign(r14E3, bit_or(r14E6, r14E9), 0x01));


                  body.instructions = f14E4_parent_instructions;
                  body.emit(f14E4);

                  /* END IF */

                  body.emit(assign(r14B1, r14E3, 0x01));

                  body.emit(assign(r14B2, r14E2, 0x01));

                  body.emit(assign(r14B0, sub(body.constant(int(1)), r14B3), 0x01));


               body.instructions = f14B4_parent_instructions;
               body.emit(f14B4);

               /* END IF */

               body.emit(assign(r143F, r14B0, 0x01));

               body.emit(assign(r1440, r14B1, 0x02));

               body.emit(assign(r1440, r14B2, 0x01));


            body.instructions = f14AA_parent_instructions;
            body.emit(f14AA);

            /* END IF */


         body.instructions = f14A8_parent_instructions;
         body.emit(f14A8);

         /* END IF */

         /* IF CONDITION */
         ir_if *f14EA = new(mem_ctx) ir_if(operand(r143A).val);
         exec_list *const f14EA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f14EA->then_instructions;

            /* IF CONDITION */
            ir_expression *const r14EC = equal(r144A, body.constant(int(0)));
            ir_if *f14EB = new(mem_ctx) ir_if(operand(r14EC).val);
            exec_list *const f14EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14EB->then_instructions;

               /* IF CONDITION */
               ir_expression *const r14EE = bit_or(swizzle_y(r1449), swizzle_x(r1439));
               ir_expression *const r14EF = equal(r14EE, body.constant(0u));
               ir_if *f14ED = new(mem_ctx) ir_if(operand(r14EF).val);
               exec_list *const f14ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14ED->then_instructions;

                  ir_variable *const r14F0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r14F0);
                  body.emit(assign(r14F0, lshift(r143C, body.constant(int(31))), 0x02));

                  body.emit(assign(r14F0, body.constant(0u), 0x01));

                  body.emit(assign(r143B, r14F0, 0x03));

                  body.emit(assign(r143A, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14ED->else_instructions;

                  ir_variable *const r14F1 = body.make_temp(glsl_type::uint_type, "aFrac0");
                  body.emit(assign(r14F1, swizzle_y(r1449), 0x01));

                  ir_variable *const r14F2 = body.make_temp(glsl_type::uint_type, "aFrac1");
                  body.emit(assign(r14F2, swizzle_x(r1449), 0x01));

                  ir_variable *const r14F3 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r14F3, r144A, 0x01));

                  ir_variable *const r14F4 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r14F4, swizzle_y(r1449), 0x01));

                  ir_variable *const r14F5 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r14F5, swizzle_x(r1449), 0x01));

                  ir_variable *const r14F6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14F6);
                  /* IF CONDITION */
                  ir_expression *const r14F8 = equal(swizzle_y(r1449), body.constant(0u));
                  ir_if *f14F7 = new(mem_ctx) ir_if(operand(r14F8).val);
                  exec_list *const f14F7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14F7->then_instructions;

                     ir_variable *const r14F9 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r14F9, r14F2, 0x01));

                     ir_variable *const r14FA = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r14FB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r14FB);
                     /* IF CONDITION */
                     ir_expression *const r14FD = equal(swizzle_x(r1439), body.constant(0u));
                     ir_if *f14FC = new(mem_ctx) ir_if(operand(r14FD).val);
                     exec_list *const f14FC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14FC->then_instructions;

                        body.emit(assign(r14FA, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f14FC->else_instructions;

                        body.emit(assign(r14FB, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r14FF = bit_and(swizzle_x(r1439), body.constant(4294901760u));
                        ir_expression *const r1500 = equal(r14FF, body.constant(0u));
                        ir_if *f14FE = new(mem_ctx) ir_if(operand(r1500).val);
                        exec_list *const f14FE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f14FE->then_instructions;

                           body.emit(assign(r14FB, body.constant(int(16)), 0x01));

                           body.emit(assign(r14F9, lshift(swizzle_x(r1439), body.constant(int(16))), 0x01));


                        body.instructions = f14FE_parent_instructions;
                        body.emit(f14FE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1502 = bit_and(r14F9, body.constant(4278190080u));
                        ir_expression *const r1503 = equal(r1502, body.constant(0u));
                        ir_if *f1501 = new(mem_ctx) ir_if(operand(r1503).val);
                        exec_list *const f1501_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1501->then_instructions;

                           body.emit(assign(r14FB, add(r14FB, body.constant(int(8))), 0x01));

                           body.emit(assign(r14F9, lshift(r14F9, body.constant(int(8))), 0x01));


                        body.instructions = f1501_parent_instructions;
                        body.emit(f1501);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1505 = bit_and(r14F9, body.constant(4026531840u));
                        ir_expression *const r1506 = equal(r1505, body.constant(0u));
                        ir_if *f1504 = new(mem_ctx) ir_if(operand(r1506).val);
                        exec_list *const f1504_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1504->then_instructions;

                           body.emit(assign(r14FB, add(r14FB, body.constant(int(4))), 0x01));

                           body.emit(assign(r14F9, lshift(r14F9, body.constant(int(4))), 0x01));


                        body.instructions = f1504_parent_instructions;
                        body.emit(f1504);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1508 = bit_and(r14F9, body.constant(3221225472u));
                        ir_expression *const r1509 = equal(r1508, body.constant(0u));
                        ir_if *f1507 = new(mem_ctx) ir_if(operand(r1509).val);
                        exec_list *const f1507_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1507->then_instructions;

                           body.emit(assign(r14FB, add(r14FB, body.constant(int(2))), 0x01));

                           body.emit(assign(r14F9, lshift(r14F9, body.constant(int(2))), 0x01));


                        body.instructions = f1507_parent_instructions;
                        body.emit(f1507);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r150B = bit_and(r14F9, body.constant(2147483648u));
                        ir_expression *const r150C = equal(r150B, body.constant(0u));
                        ir_if *f150A = new(mem_ctx) ir_if(operand(r150C).val);
                        exec_list *const f150A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f150A->then_instructions;

                           body.emit(assign(r14FB, add(r14FB, body.constant(int(1))), 0x01));


                        body.instructions = f150A_parent_instructions;
                        body.emit(f150A);

                        /* END IF */

                        body.emit(assign(r14FA, r14FB, 0x01));


                     body.instructions = f14FC_parent_instructions;
                     body.emit(f14FC);

                     /* END IF */

                     body.emit(assign(r14F6, add(r14FA, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r150E = less(r14F6, body.constant(int(0)));
                     ir_if *f150D = new(mem_ctx) ir_if(operand(r150E).val);
                     exec_list *const f150D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f150D->then_instructions;

                        ir_expression *const r150F = neg(r14F6);
                        body.emit(assign(r14F4, rshift(swizzle_x(r1439), r150F), 0x01));

                        ir_expression *const r1510 = bit_and(r14F6, body.constant(int(31)));
                        body.emit(assign(r14F5, lshift(swizzle_x(r1439), r1510), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f150D->else_instructions;

                        body.emit(assign(r14F4, lshift(swizzle_x(r1439), r14F6), 0x01));

                        body.emit(assign(r14F5, body.constant(0u), 0x01));


                     body.instructions = f150D_parent_instructions;
                     body.emit(f150D);

                     /* END IF */

                     body.emit(assign(r14F3, sub(body.constant(int(-31)), r14F6), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14F7->else_instructions;

                     ir_variable *const r1511 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1511, r14F1, 0x01));

                     ir_variable *const r1512 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1513 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1513);
                     /* IF CONDITION */
                     ir_expression *const r1515 = equal(swizzle_y(r1449), body.constant(0u));
                     ir_if *f1514 = new(mem_ctx) ir_if(operand(r1515).val);
                     exec_list *const f1514_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1514->then_instructions;

                        body.emit(assign(r1512, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1514->else_instructions;

                        body.emit(assign(r1513, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1517 = bit_and(swizzle_y(r1449), body.constant(4294901760u));
                        ir_expression *const r1518 = equal(r1517, body.constant(0u));
                        ir_if *f1516 = new(mem_ctx) ir_if(operand(r1518).val);
                        exec_list *const f1516_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1516->then_instructions;

                           body.emit(assign(r1513, body.constant(int(16)), 0x01));

                           body.emit(assign(r1511, lshift(swizzle_y(r1449), body.constant(int(16))), 0x01));


                        body.instructions = f1516_parent_instructions;
                        body.emit(f1516);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r151A = bit_and(r1511, body.constant(4278190080u));
                        ir_expression *const r151B = equal(r151A, body.constant(0u));
                        ir_if *f1519 = new(mem_ctx) ir_if(operand(r151B).val);
                        exec_list *const f1519_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1519->then_instructions;

                           body.emit(assign(r1513, add(r1513, body.constant(int(8))), 0x01));

                           body.emit(assign(r1511, lshift(r1511, body.constant(int(8))), 0x01));


                        body.instructions = f1519_parent_instructions;
                        body.emit(f1519);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r151D = bit_and(r1511, body.constant(4026531840u));
                        ir_expression *const r151E = equal(r151D, body.constant(0u));
                        ir_if *f151C = new(mem_ctx) ir_if(operand(r151E).val);
                        exec_list *const f151C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f151C->then_instructions;

                           body.emit(assign(r1513, add(r1513, body.constant(int(4))), 0x01));

                           body.emit(assign(r1511, lshift(r1511, body.constant(int(4))), 0x01));


                        body.instructions = f151C_parent_instructions;
                        body.emit(f151C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1520 = bit_and(r1511, body.constant(3221225472u));
                        ir_expression *const r1521 = equal(r1520, body.constant(0u));
                        ir_if *f151F = new(mem_ctx) ir_if(operand(r1521).val);
                        exec_list *const f151F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f151F->then_instructions;

                           body.emit(assign(r1513, add(r1513, body.constant(int(2))), 0x01));

                           body.emit(assign(r1511, lshift(r1511, body.constant(int(2))), 0x01));


                        body.instructions = f151F_parent_instructions;
                        body.emit(f151F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1523 = bit_and(r1511, body.constant(2147483648u));
                        ir_expression *const r1524 = equal(r1523, body.constant(0u));
                        ir_if *f1522 = new(mem_ctx) ir_if(operand(r1524).val);
                        exec_list *const f1522_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1522->then_instructions;

                           body.emit(assign(r1513, add(r1513, body.constant(int(1))), 0x01));


                        body.instructions = f1522_parent_instructions;
                        body.emit(f1522);

                        /* END IF */

                        body.emit(assign(r1512, r1513, 0x01));


                     body.instructions = f1514_parent_instructions;
                     body.emit(f1514);

                     /* END IF */

                     body.emit(assign(r14F6, add(r1512, body.constant(int(-11))), 0x01));

                     ir_variable *const r1525 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1525, lshift(swizzle_x(r1439), r14F6), 0x01));

                     ir_variable *const r1526 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1528 = equal(r14F6, body.constant(int(0)));
                     ir_if *f1527 = new(mem_ctx) ir_if(operand(r1528).val);
                     exec_list *const f1527_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1527->then_instructions;

                        body.emit(assign(r1526, r14F1, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1527->else_instructions;

                        ir_expression *const r1529 = lshift(swizzle_y(r1449), r14F6);
                        ir_expression *const r152A = neg(r14F6);
                        ir_expression *const r152B = bit_and(r152A, body.constant(int(31)));
                        ir_expression *const r152C = rshift(swizzle_x(r1439), r152B);
                        body.emit(assign(r1526, bit_or(r1529, r152C), 0x01));


                     body.instructions = f1527_parent_instructions;
                     body.emit(f1527);

                     /* END IF */

                     body.emit(assign(r14F4, r1526, 0x01));

                     body.emit(assign(r14F5, r1525, 0x01));

                     body.emit(assign(r14F3, sub(body.constant(int(1)), r14F6), 0x01));


                  body.instructions = f14F7_parent_instructions;
                  body.emit(f14F7);

                  /* END IF */

                  body.emit(assign(r143D, r14F3, 0x01));

                  body.emit(assign(r143E, r14F4, 0x02));

                  body.emit(assign(r143E, r14F5, 0x01));


               body.instructions = f14ED_parent_instructions;
               body.emit(f14ED);

               /* END IF */


            body.instructions = f14EB_parent_instructions;
            body.emit(f14EB);

            /* END IF */

            /* IF CONDITION */
            ir_if *f152D = new(mem_ctx) ir_if(operand(r143A).val);
            exec_list *const f152D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f152D->then_instructions;

               ir_expression *const r152E = add(r143F, r143D);
               body.emit(assign(r1441, add(r152E, body.constant(int(-1024))), 0x01));

               body.emit(assign(r1440, bit_or(swizzle_y(r1440), body.constant(1048576u)), 0x02));

               ir_variable *const r152F = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r152F, lshift(swizzle_x(r143E), body.constant(int(12))), 0x01));

               ir_variable *const r1530 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r1531 = lshift(swizzle_y(r143E), body.constant(int(12)));
               ir_expression *const r1532 = rshift(swizzle_x(r143E), body.constant(int(20)));
               body.emit(assign(r1530, bit_or(r1531, r1532), 0x01));

               body.emit(assign(r143E, r1530, 0x02));

               body.emit(assign(r143E, r152F, 0x01));

               ir_variable *const r1533 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1533);
               ir_variable *const r1534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1534);
               ir_variable *const r1535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1535);
               ir_variable *const r1536 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1536, bit_and(swizzle_x(r1440), body.constant(65535u)), 0x01));

               ir_variable *const r1537 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1537, rshift(swizzle_x(r1440), body.constant(int(16))), 0x01));

               ir_variable *const r1538 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1538, bit_and(r152F, body.constant(65535u)), 0x01));

               ir_variable *const r1539 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1539, rshift(r152F, body.constant(int(16))), 0x01));

               ir_variable *const r153A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r153A, mul(r1537, r1538), 0x01));

               ir_expression *const r153B = mul(r1536, r1539);
               body.emit(assign(r1534, add(r153B, r153A), 0x01));

               ir_expression *const r153C = mul(r1537, r1539);
               ir_expression *const r153D = less(r1534, r153A);
               ir_expression *const r153E = expr(ir_unop_b2i, r153D);
               ir_expression *const r153F = expr(ir_unop_i2u, r153E);
               ir_expression *const r1540 = lshift(r153F, body.constant(int(16)));
               ir_expression *const r1541 = rshift(r1534, body.constant(int(16)));
               ir_expression *const r1542 = add(r1540, r1541);
               body.emit(assign(r1533, add(r153C, r1542), 0x01));

               body.emit(assign(r1534, lshift(r1534, body.constant(int(16))), 0x01));

               ir_expression *const r1543 = mul(r1536, r1538);
               body.emit(assign(r1535, add(r1543, r1534), 0x01));

               ir_expression *const r1544 = less(r1535, r1534);
               ir_expression *const r1545 = expr(ir_unop_b2i, r1544);
               ir_expression *const r1546 = expr(ir_unop_i2u, r1545);
               body.emit(assign(r1533, add(r1533, r1546), 0x01));

               ir_variable *const r1547 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1547);
               ir_variable *const r1548 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1548);
               ir_variable *const r1549 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1549);
               ir_variable *const r154A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154A, bit_and(swizzle_x(r1440), body.constant(65535u)), 0x01));

               ir_variable *const r154B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154B, rshift(swizzle_x(r1440), body.constant(int(16))), 0x01));

               ir_variable *const r154C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154C, bit_and(r1530, body.constant(65535u)), 0x01));

               ir_variable *const r154D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154D, rshift(r1530, body.constant(int(16))), 0x01));

               ir_variable *const r154E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154E, mul(r154B, r154C), 0x01));

               ir_expression *const r154F = mul(r154A, r154D);
               body.emit(assign(r1548, add(r154F, r154E), 0x01));

               ir_expression *const r1550 = mul(r154B, r154D);
               ir_expression *const r1551 = less(r1548, r154E);
               ir_expression *const r1552 = expr(ir_unop_b2i, r1551);
               ir_expression *const r1553 = expr(ir_unop_i2u, r1552);
               ir_expression *const r1554 = lshift(r1553, body.constant(int(16)));
               ir_expression *const r1555 = rshift(r1548, body.constant(int(16)));
               ir_expression *const r1556 = add(r1554, r1555);
               body.emit(assign(r1547, add(r1550, r1556), 0x01));

               body.emit(assign(r1548, lshift(r1548, body.constant(int(16))), 0x01));

               ir_expression *const r1557 = mul(r154A, r154C);
               body.emit(assign(r1549, add(r1557, r1548), 0x01));

               ir_expression *const r1558 = less(r1549, r1548);
               ir_expression *const r1559 = expr(ir_unop_b2i, r1558);
               ir_expression *const r155A = expr(ir_unop_i2u, r1559);
               body.emit(assign(r1547, add(r1547, r155A), 0x01));

               ir_variable *const r155B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155B, add(r1549, r1533), 0x01));

               ir_variable *const r155C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r155C);
               ir_variable *const r155D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r155D);
               ir_variable *const r155E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r155E);
               ir_variable *const r155F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155F, bit_and(swizzle_y(r1440), body.constant(65535u)), 0x01));

               ir_variable *const r1560 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1560, rshift(swizzle_y(r1440), body.constant(int(16))), 0x01));

               ir_variable *const r1561 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1561, bit_and(r1530, body.constant(65535u)), 0x01));

               ir_variable *const r1562 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1562, rshift(r1530, body.constant(int(16))), 0x01));

               ir_variable *const r1563 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1563, mul(r1560, r1561), 0x01));

               ir_expression *const r1564 = mul(r155F, r1562);
               body.emit(assign(r155D, add(r1564, r1563), 0x01));

               ir_expression *const r1565 = mul(r1560, r1562);
               ir_expression *const r1566 = less(r155D, r1563);
               ir_expression *const r1567 = expr(ir_unop_b2i, r1566);
               ir_expression *const r1568 = expr(ir_unop_i2u, r1567);
               ir_expression *const r1569 = lshift(r1568, body.constant(int(16)));
               ir_expression *const r156A = rshift(r155D, body.constant(int(16)));
               ir_expression *const r156B = add(r1569, r156A);
               body.emit(assign(r155C, add(r1565, r156B), 0x01));

               body.emit(assign(r155D, lshift(r155D, body.constant(int(16))), 0x01));

               ir_expression *const r156C = mul(r155F, r1561);
               body.emit(assign(r155E, add(r156C, r155D), 0x01));

               ir_expression *const r156D = less(r155E, r155D);
               ir_expression *const r156E = expr(ir_unop_b2i, r156D);
               ir_expression *const r156F = expr(ir_unop_i2u, r156E);
               body.emit(assign(r155C, add(r155C, r156F), 0x01));

               ir_variable *const r1570 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1571 = less(r155B, r1549);
               ir_expression *const r1572 = expr(ir_unop_b2i, r1571);
               ir_expression *const r1573 = expr(ir_unop_i2u, r1572);
               ir_expression *const r1574 = add(r1547, r1573);
               body.emit(assign(r1570, add(r155E, r1574), 0x01));

               ir_variable *const r1575 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1575);
               ir_variable *const r1576 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1576);
               ir_variable *const r1577 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1577);
               ir_variable *const r1578 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1578, bit_and(swizzle_y(r1440), body.constant(65535u)), 0x01));

               ir_variable *const r1579 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1579, rshift(swizzle_y(r1440), body.constant(int(16))), 0x01));

               ir_variable *const r157A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r157A, bit_and(r152F, body.constant(65535u)), 0x01));

               ir_variable *const r157B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r157B, rshift(r152F, body.constant(int(16))), 0x01));

               ir_variable *const r157C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r157C, mul(r1579, r157A), 0x01));

               ir_expression *const r157D = mul(r1578, r157B);
               body.emit(assign(r1576, add(r157D, r157C), 0x01));

               ir_expression *const r157E = mul(r1579, r157B);
               ir_expression *const r157F = less(r1576, r157C);
               ir_expression *const r1580 = expr(ir_unop_b2i, r157F);
               ir_expression *const r1581 = expr(ir_unop_i2u, r1580);
               ir_expression *const r1582 = lshift(r1581, body.constant(int(16)));
               ir_expression *const r1583 = rshift(r1576, body.constant(int(16)));
               ir_expression *const r1584 = add(r1582, r1583);
               body.emit(assign(r1575, add(r157E, r1584), 0x01));

               body.emit(assign(r1576, lshift(r1576, body.constant(int(16))), 0x01));

               ir_expression *const r1585 = mul(r1578, r157A);
               body.emit(assign(r1577, add(r1585, r1576), 0x01));

               ir_expression *const r1586 = less(r1577, r1576);
               ir_expression *const r1587 = expr(ir_unop_b2i, r1586);
               ir_expression *const r1588 = expr(ir_unop_i2u, r1587);
               body.emit(assign(r1575, add(r1575, r1588), 0x01));

               ir_variable *const r1589 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1589, add(r1577, r155B), 0x01));

               ir_variable *const r158A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r158B = less(r1589, r1577);
               ir_expression *const r158C = expr(ir_unop_b2i, r158B);
               ir_expression *const r158D = expr(ir_unop_i2u, r158C);
               ir_expression *const r158E = add(r1575, r158D);
               body.emit(assign(r158A, add(r1570, r158E), 0x01));

               ir_variable *const r158F = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1590 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1590, add(r158A, swizzle_x(r1440)), 0x01));

               ir_expression *const r1591 = less(r1570, r155E);
               ir_expression *const r1592 = expr(ir_unop_b2i, r1591);
               ir_expression *const r1593 = expr(ir_unop_i2u, r1592);
               ir_expression *const r1594 = add(r155C, r1593);
               ir_expression *const r1595 = less(r158A, r1570);
               ir_expression *const r1596 = expr(ir_unop_b2i, r1595);
               ir_expression *const r1597 = expr(ir_unop_i2u, r1596);
               ir_expression *const r1598 = add(r1594, r1597);
               ir_expression *const r1599 = add(r1598, swizzle_y(r1440));
               ir_expression *const r159A = less(r1590, r158A);
               ir_expression *const r159B = expr(ir_unop_b2i, r159A);
               ir_expression *const r159C = expr(ir_unop_i2u, r159B);
               body.emit(assign(r158F, add(r1599, r159C), 0x01));

               body.emit(assign(r1444, r158F, 0x01));

               body.emit(assign(r1443, r1590, 0x01));

               ir_expression *const r159D = nequal(r1535, body.constant(0u));
               ir_expression *const r159E = expr(ir_unop_b2i, r159D);
               ir_expression *const r159F = expr(ir_unop_i2u, r159E);
               body.emit(assign(r1442, bit_or(r1589, r159F), 0x01));

               /* IF CONDITION */
               ir_expression *const r15A1 = lequal(body.constant(2097152u), r158F);
               ir_if *f15A0 = new(mem_ctx) ir_if(operand(r15A1).val);
               exec_list *const f15A0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15A0->then_instructions;

                  ir_variable *const r15A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r15A2);
                  body.emit(assign(r15A2, lshift(r1590, body.constant(int(31))), 0x01));

                  ir_expression *const r15A3 = nequal(r1442, body.constant(0u));
                  ir_expression *const r15A4 = expr(ir_unop_b2i, r15A3);
                  ir_expression *const r15A5 = expr(ir_unop_i2u, r15A4);
                  body.emit(assign(r15A2, bit_or(r15A2, r15A5), 0x01));

                  body.emit(assign(r1444, rshift(r158F, body.constant(int(1))), 0x01));

                  ir_expression *const r15A6 = lshift(r158F, body.constant(int(31)));
                  ir_expression *const r15A7 = rshift(r1590, body.constant(int(1)));
                  body.emit(assign(r1443, bit_or(r15A6, r15A7), 0x01));

                  body.emit(assign(r1442, r15A2, 0x01));

                  body.emit(assign(r1441, add(r1441, body.constant(int(1))), 0x01));


               body.instructions = f15A0_parent_instructions;
               body.emit(f15A0);

               /* END IF */

               ir_variable *const r15A8 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r15A8, r1441, 0x01));

               ir_variable *const r15A9 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r15A9, r1444, 0x01));

               ir_variable *const r15AA = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r15AA, r1443, 0x01));

               ir_variable *const r15AB = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r15AB, r1442, 0x01));

               ir_variable *const r15AC = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r15AC, body.constant(true), 0x01));

               ir_variable *const r15AD = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r15AE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r15AE);
               ir_expression *const r15AF = expr(ir_unop_u2i, r1442);
               body.emit(assign(r15AE, less(r15AF, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r15B1 = lequal(body.constant(int(2045)), r1441);
               ir_if *f15B0 = new(mem_ctx) ir_if(operand(r15B1).val);
               exec_list *const f15B0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15B0->then_instructions;

                  ir_variable *const r15B2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r15B4 = less(body.constant(int(2045)), r1441);
                  ir_if *f15B3 = new(mem_ctx) ir_if(operand(r15B4).val);
                  exec_list *const f15B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15B3->then_instructions;

                     body.emit(assign(r15B2, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15B3->else_instructions;

                     ir_variable *const r15B5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r15B7 = equal(r1441, body.constant(int(2045)));
                     ir_if *f15B6 = new(mem_ctx) ir_if(operand(r15B7).val);
                     exec_list *const f15B6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15B6->then_instructions;

                        ir_expression *const r15B8 = equal(body.constant(2097151u), r1444);
                        ir_expression *const r15B9 = equal(body.constant(4294967295u), r1443);
                        body.emit(assign(r15B5, logic_and(r15B8, r15B9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f15B6->else_instructions;

                        body.emit(assign(r15B5, body.constant(false), 0x01));


                     body.instructions = f15B6_parent_instructions;
                     body.emit(f15B6);

                     /* END IF */

                     body.emit(assign(r15B2, logic_and(r15B5, r15AE), 0x01));


                  body.instructions = f15B3_parent_instructions;
                  body.emit(f15B3);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f15BA = new(mem_ctx) ir_if(operand(r15B2).val);
                  exec_list *const f15BA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15BA->then_instructions;

                     ir_variable *const r15BB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r15BB);
                     ir_expression *const r15BC = lshift(r143C, body.constant(int(31)));
                     body.emit(assign(r15BB, add(r15BC, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r15BB, body.constant(0u), 0x01));

                     body.emit(assign(r15AD, r15BB, 0x03));

                     body.emit(assign(r15AC, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15BA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15BE = less(r1441, body.constant(int(0)));
                     ir_if *f15BD = new(mem_ctx) ir_if(operand(r15BE).val);
                     exec_list *const f15BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15BD->then_instructions;

                        ir_variable *const r15BF = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r15BF, r1442, 0x01));

                        ir_variable *const r15C0 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r15C0, neg(r1441), 0x01));

                        ir_variable *const r15C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r15C1);
                        ir_variable *const r15C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r15C2);
                        ir_variable *const r15C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r15C3);
                        ir_variable *const r15C4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r15C5 = neg(r15C0);
                        body.emit(assign(r15C4, bit_and(r15C5, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r15C7 = equal(r15C0, body.constant(int(0)));
                        ir_if *f15C6 = new(mem_ctx) ir_if(operand(r15C7).val);
                        exec_list *const f15C6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f15C6->then_instructions;

                           body.emit(assign(r15C1, r1442, 0x01));

                           body.emit(assign(r15C2, r1443, 0x01));

                           body.emit(assign(r15C3, r1444, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f15C6->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r15C9 = less(r15C0, body.constant(int(32)));
                           ir_if *f15C8 = new(mem_ctx) ir_if(operand(r15C9).val);
                           exec_list *const f15C8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f15C8->then_instructions;

                              body.emit(assign(r15C1, lshift(r1443, r15C4), 0x01));

                              ir_expression *const r15CA = lshift(r1444, r15C4);
                              ir_expression *const r15CB = rshift(r1443, r15C0);
                              body.emit(assign(r15C2, bit_or(r15CA, r15CB), 0x01));

                              body.emit(assign(r15C3, rshift(r1444, r15C0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f15C8->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r15CD = equal(r15C0, body.constant(int(32)));
                              ir_if *f15CC = new(mem_ctx) ir_if(operand(r15CD).val);
                              exec_list *const f15CC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f15CC->then_instructions;

                                 body.emit(assign(r15C1, r1443, 0x01));

                                 body.emit(assign(r15C2, r1444, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f15CC->else_instructions;

                                 body.emit(assign(r15BF, bit_or(r1442, r1443), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r15CF = less(r15C0, body.constant(int(64)));
                                 ir_if *f15CE = new(mem_ctx) ir_if(operand(r15CF).val);
                                 exec_list *const f15CE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f15CE->then_instructions;

                                    body.emit(assign(r15C1, lshift(r1444, r15C4), 0x01));

                                    ir_expression *const r15D0 = bit_and(r15C0, body.constant(int(31)));
                                    body.emit(assign(r15C2, rshift(r1444, r15D0), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f15CE->else_instructions;

                                    ir_variable *const r15D1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r15D3 = equal(r15C0, body.constant(int(64)));
                                    ir_if *f15D2 = new(mem_ctx) ir_if(operand(r15D3).val);
                                    exec_list *const f15D2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f15D2->then_instructions;

                                       body.emit(assign(r15D1, r1444, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f15D2->else_instructions;

                                       ir_expression *const r15D4 = nequal(r1444, body.constant(0u));
                                       ir_expression *const r15D5 = expr(ir_unop_b2i, r15D4);
                                       body.emit(assign(r15D1, expr(ir_unop_i2u, r15D5), 0x01));


                                    body.instructions = f15D2_parent_instructions;
                                    body.emit(f15D2);

                                    /* END IF */

                                    body.emit(assign(r15C1, r15D1, 0x01));

                                    body.emit(assign(r15C2, body.constant(0u), 0x01));


                                 body.instructions = f15CE_parent_instructions;
                                 body.emit(f15CE);

                                 /* END IF */


                              body.instructions = f15CC_parent_instructions;
                              body.emit(f15CC);

                              /* END IF */

                              body.emit(assign(r15C3, body.constant(0u), 0x01));


                           body.instructions = f15C8_parent_instructions;
                           body.emit(f15C8);

                           /* END IF */

                           ir_expression *const r15D6 = nequal(r15BF, body.constant(0u));
                           ir_expression *const r15D7 = expr(ir_unop_b2i, r15D6);
                           ir_expression *const r15D8 = expr(ir_unop_i2u, r15D7);
                           body.emit(assign(r15C1, bit_or(r15C1, r15D8), 0x01));


                        body.instructions = f15C6_parent_instructions;
                        body.emit(f15C6);

                        /* END IF */

                        body.emit(assign(r15A9, r15C3, 0x01));

                        body.emit(assign(r15AA, r15C2, 0x01));

                        body.emit(assign(r15AB, r15C1, 0x01));

                        body.emit(assign(r15A8, body.constant(int(0)), 0x01));

                        body.emit(assign(r15AE, less(r15C1, body.constant(0u)), 0x01));


                     body.instructions = f15BD_parent_instructions;
                     body.emit(f15BD);

                     /* END IF */


                  body.instructions = f15BA_parent_instructions;
                  body.emit(f15BA);

                  /* END IF */


               body.instructions = f15B0_parent_instructions;
               body.emit(f15B0);

               /* END IF */

               /* IF CONDITION */
               ir_if *f15D9 = new(mem_ctx) ir_if(operand(r15AC).val);
               exec_list *const f15D9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15D9->then_instructions;

                  /* IF CONDITION */
                  ir_if *f15DA = new(mem_ctx) ir_if(operand(r15AE).val);
                  exec_list *const f15DA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15DA->then_instructions;

                     ir_variable *const r15DB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r15DB, add(r15AA, body.constant(1u)), 0x01));

                     ir_expression *const r15DC = less(r15DB, r15AA);
                     ir_expression *const r15DD = expr(ir_unop_b2i, r15DC);
                     ir_expression *const r15DE = expr(ir_unop_i2u, r15DD);
                     body.emit(assign(r15A9, add(r15A9, r15DE), 0x01));

                     ir_expression *const r15DF = equal(r15AB, body.constant(0u));
                     ir_expression *const r15E0 = expr(ir_unop_b2i, r15DF);
                     ir_expression *const r15E1 = expr(ir_unop_i2u, r15E0);
                     ir_expression *const r15E2 = add(r15AB, r15E1);
                     ir_expression *const r15E3 = bit_and(r15E2, body.constant(1u));
                     ir_expression *const r15E4 = expr(ir_unop_bit_not, r15E3);
                     body.emit(assign(r15AA, bit_and(r15DB, r15E4), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15DA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15E6 = bit_or(r15A9, r15AA);
                     ir_expression *const r15E7 = equal(r15E6, body.constant(0u));
                     ir_if *f15E5 = new(mem_ctx) ir_if(operand(r15E7).val);
                     exec_list *const f15E5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15E5->then_instructions;

                        body.emit(assign(r15A8, body.constant(int(0)), 0x01));


                     body.instructions = f15E5_parent_instructions;
                     body.emit(f15E5);

                     /* END IF */


                  body.instructions = f15DA_parent_instructions;
                  body.emit(f15DA);

                  /* END IF */

                  ir_variable *const r15E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r15E8);
                  ir_expression *const r15E9 = lshift(r143C, body.constant(int(31)));
                  ir_expression *const r15EA = expr(ir_unop_i2u, r15A8);
                  ir_expression *const r15EB = lshift(r15EA, body.constant(int(20)));
                  ir_expression *const r15EC = add(r15E9, r15EB);
                  body.emit(assign(r15E8, add(r15EC, r15A9), 0x02));

                  body.emit(assign(r15E8, r15AA, 0x01));

                  body.emit(assign(r15AD, r15E8, 0x03));

                  body.emit(assign(r15AC, body.constant(false), 0x01));


               body.instructions = f15D9_parent_instructions;
               body.emit(f15D9);

               /* END IF */

               body.emit(assign(r143B, r15AD, 0x03));

               body.emit(assign(r143A, body.constant(false), 0x01));


            body.instructions = f152D_parent_instructions;
            body.emit(f152D);

            /* END IF */


         body.instructions = f14EA_parent_instructions;
         body.emit(f14EA);

         /* END IF */


      body.instructions = f147E_parent_instructions;
      body.emit(f147E);

      /* END IF */


   body.instructions = f144F_parent_instructions;
   body.emit(f144F);

   /* END IF */

   body.emit(ret(r143B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r15ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r15ED);
   ir_variable *const r15EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r15EE);
   ir_variable *const r15EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r15EF);
   ir_variable *const r15F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r15F0);
   ir_variable *const r15F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r15F1);
   ir_variable *const r15F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r15F2);
   ir_variable *const r15F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F3);
   ir_variable *const r15F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F4);
   ir_variable *const r15F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F5);
   ir_variable *const r15F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r15F6);
   ir_variable *const r15F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r15F7);
   ir_variable *const r15F8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r15F8, add(r15EF, r15F2), 0x01));

   ir_variable *const r15F9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r15FA = less(r15F8, r15EF);
   ir_expression *const r15FB = expr(ir_unop_b2i, r15FA);
   body.emit(assign(r15F9, expr(ir_unop_i2u, r15FB), 0x01));

   ir_variable *const r15FC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r15FC, add(r15EE, r15F1), 0x01));

   body.emit(assign(r15F7, add(r15FC, r15F9), 0x01));

   ir_expression *const r15FD = add(r15ED, r15F0);
   ir_expression *const r15FE = less(r15F7, r15F9);
   ir_expression *const r15FF = expr(ir_unop_b2i, r15FE);
   ir_expression *const r1600 = expr(ir_unop_i2u, r15FF);
   body.emit(assign(r15F6, add(r15FD, r1600), 0x01));

   ir_expression *const r1601 = less(r15FC, r15EE);
   ir_expression *const r1602 = expr(ir_unop_b2i, r1601);
   ir_expression *const r1603 = expr(ir_unop_i2u, r1602);
   body.emit(assign(r15F6, add(r15F6, r1603), 0x01));

   body.emit(assign(r15F5, r15F8, 0x01));

   body.emit(assign(r15F4, r15F7, 0x01));

   body.emit(assign(r15F3, r15F6, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1604 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1604);
   ir_variable *const r1605 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1605);
   ir_variable *const r1606 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r1606);
   ir_variable *const r1607 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r1607);
   ir_variable *const r1608 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1608);
   ir_variable *const r1609 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r1609);
   ir_variable *const r160A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r160A);
   ir_variable *const r160B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r160B);
   ir_variable *const r160C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r160C);
   ir_variable *const r160D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r160D);
   ir_variable *const r160E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r160F = less(r1606, r1609);
   ir_expression *const r1610 = expr(ir_unop_b2i, r160F);
   body.emit(assign(r160E, expr(ir_unop_i2u, r1610), 0x01));

   ir_variable *const r1611 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1611, sub(r1605, r1608), 0x01));

   ir_expression *const r1612 = sub(r1604, r1607);
   ir_expression *const r1613 = less(r1611, r160E);
   ir_expression *const r1614 = expr(ir_unop_b2i, r1613);
   ir_expression *const r1615 = expr(ir_unop_i2u, r1614);
   body.emit(assign(r160D, sub(r1612, r1615), 0x01));

   ir_expression *const r1616 = less(r1605, r1608);
   ir_expression *const r1617 = expr(ir_unop_b2i, r1616);
   ir_expression *const r1618 = expr(ir_unop_i2u, r1617);
   body.emit(assign(r160D, sub(r160D, r1618), 0x01));

   body.emit(assign(r160C, sub(r1606, r1609), 0x01));

   body.emit(assign(r160B, sub(r1611, r160E), 0x01));

   body.emit(assign(r160A, r160D, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Right(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1619);
   ir_variable *const r161A = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r161A);
   ir_variable *const r161B = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r161B);
   ir_variable *const r161C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r161C);
   ir_variable *const r161D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r161D);
   ir_variable *const r161E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r161E);
   ir_variable *const r161F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r161F);
   ir_variable *const r1620 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1621 = neg(r161B);
   body.emit(assign(r1620, bit_and(r1621, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1623 = equal(r161B, body.constant(int(0)));
   ir_if *f1622 = new(mem_ctx) ir_if(operand(r1623).val);
   exec_list *const f1622_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1622->then_instructions;

      body.emit(assign(r161E, r161A, 0x01));

      body.emit(assign(r161F, r1619, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1622->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1625 = less(r161B, body.constant(int(32)));
      ir_if *f1624 = new(mem_ctx) ir_if(operand(r1625).val);
      exec_list *const f1624_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1624->then_instructions;

         ir_expression *const r1626 = lshift(r1619, r1620);
         ir_expression *const r1627 = rshift(r161A, r161B);
         body.emit(assign(r161E, bit_or(r1626, r1627), 0x01));

         body.emit(assign(r161F, rshift(r1619, r161B), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1624->else_instructions;

         ir_variable *const r1628 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r162A = less(r161B, body.constant(int(64)));
         ir_if *f1629 = new(mem_ctx) ir_if(operand(r162A).val);
         exec_list *const f1629_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1629->then_instructions;

            ir_expression *const r162B = bit_and(r161B, body.constant(int(31)));
            body.emit(assign(r1628, rshift(r1619, r162B), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1629->else_instructions;

            body.emit(assign(r1628, body.constant(0u), 0x01));


         body.instructions = f1629_parent_instructions;
         body.emit(f1629);

         /* END IF */

         body.emit(assign(r161E, r1628, 0x01));

         body.emit(assign(r161F, body.constant(0u), 0x01));


      body.instructions = f1624_parent_instructions;
      body.emit(f1624);

      /* END IF */


   body.instructions = f1622_parent_instructions;
   body.emit(f1622);

   /* END IF */

   body.emit(assign(r161D, r161E, 0x01));

   body.emit(assign(r161C, r161F, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateDiv64To32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r162C = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r162C);
   ir_variable *const r162D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r162D);
   ir_variable *const r162E = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r162E);
   ir_variable *const r162F = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1630 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r1630);
   ir_variable *const r1631 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r1631);
   ir_variable *const r1632 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r1632);
   ir_variable *const r1633 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
   body.emit(r1633);
   body.emit(assign(r1632, body.constant(0u), 0x01));

   body.emit(assign(r1631, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1635 = lequal(r162E, r162C);
   ir_if *f1634 = new(mem_ctx) ir_if(operand(r1635).val);
   exec_list *const f1634_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1634->then_instructions;

      body.emit(assign(r162F, body.constant(4294967295u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1634->else_instructions;

      body.emit(assign(r1633, rshift(r162E, body.constant(int(16))), 0x01));

      ir_variable *const r1636 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1638 = lshift(r1633, body.constant(int(16)));
      ir_expression *const r1639 = lequal(r1638, r162C);
      ir_if *f1637 = new(mem_ctx) ir_if(operand(r1639).val);
      exec_list *const f1637_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1637->then_instructions;

         body.emit(assign(r1636, body.constant(4294901760u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1637->else_instructions;

         ir_expression *const r163A = expr(ir_binop_div, r162C, r1633);
         body.emit(assign(r1636, lshift(r163A, body.constant(int(16))), 0x01));


      body.instructions = f1637_parent_instructions;
      body.emit(f1637);

      /* END IF */

      body.emit(assign(r1630, r1636, 0x01));

      ir_variable *const r163B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r163B);
      ir_variable *const r163C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
      body.emit(r163C);
      ir_variable *const r163D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r163D);
      ir_variable *const r163E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163E, bit_and(r162E, body.constant(65535u)), 0x01));

      ir_variable *const r163F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163F, rshift(r162E, body.constant(int(16))), 0x01));

      ir_variable *const r1640 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1640, bit_and(r1636, body.constant(65535u)), 0x01));

      ir_variable *const r1641 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1641, rshift(r1636, body.constant(int(16))), 0x01));

      ir_variable *const r1642 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1642, mul(r163F, r1640), 0x01));

      ir_expression *const r1643 = mul(r163E, r1641);
      body.emit(assign(r163C, add(r1643, r1642), 0x01));

      ir_expression *const r1644 = mul(r163F, r1641);
      ir_expression *const r1645 = less(r163C, r1642);
      ir_expression *const r1646 = expr(ir_unop_b2i, r1645);
      ir_expression *const r1647 = expr(ir_unop_i2u, r1646);
      ir_expression *const r1648 = lshift(r1647, body.constant(int(16)));
      ir_expression *const r1649 = rshift(r163C, body.constant(int(16)));
      ir_expression *const r164A = add(r1648, r1649);
      body.emit(assign(r163B, add(r1644, r164A), 0x01));

      body.emit(assign(r163C, lshift(r163C, body.constant(int(16))), 0x01));

      ir_expression *const r164B = mul(r163E, r1640);
      body.emit(assign(r163D, add(r164B, r163C), 0x01));

      ir_expression *const r164C = less(r163D, r163C);
      ir_expression *const r164D = expr(ir_unop_b2i, r164C);
      ir_expression *const r164E = expr(ir_unop_i2u, r164D);
      body.emit(assign(r163B, add(r163B, r164E), 0x01));

      ir_expression *const r164F = sub(r162C, r163B);
      ir_expression *const r1650 = less(r162D, r163D);
      ir_expression *const r1651 = expr(ir_unop_b2i, r1650);
      ir_expression *const r1652 = expr(ir_unop_i2u, r1651);
      body.emit(assign(r1632, sub(r164F, r1652), 0x01));

      body.emit(assign(r1631, sub(r162D, r163D), 0x01));

      /* LOOP BEGIN */
      ir_loop *f1653 = new(mem_ctx) ir_loop();
      exec_list *const f1653_parent_instructions = body.instructions;

         body.instructions = &f1653->body_instructions;

         /* IF CONDITION */
         ir_expression *const r1655 = expr(ir_unop_u2i, r1632);
         ir_expression *const r1656 = gequal(r1655, body.constant(int(0)));
         ir_if *f1654 = new(mem_ctx) ir_if(operand(r1656).val);
         exec_list *const f1654_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1654->then_instructions;

            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


         body.instructions = f1654_parent_instructions;
         body.emit(f1654);

         /* END IF */

         body.emit(assign(r1630, add(r1630, body.constant(4294901760u)), 0x01));

         ir_variable *const r1657 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         ir_expression *const r1658 = lshift(r162E, body.constant(int(16)));
         body.emit(assign(r1657, add(r1631, r1658), 0x01));

         ir_expression *const r1659 = add(r1632, r1633);
         ir_expression *const r165A = less(r1657, r1631);
         ir_expression *const r165B = expr(ir_unop_b2i, r165A);
         ir_expression *const r165C = expr(ir_unop_i2u, r165B);
         body.emit(assign(r1632, add(r1659, r165C), 0x01));

         body.emit(assign(r1631, r1657, 0x01));

      /* LOOP END */

      body.instructions = f1653_parent_instructions;
      body.emit(f1653);

      ir_expression *const r165D = lshift(r1632, body.constant(int(16)));
      ir_expression *const r165E = rshift(r1631, body.constant(int(16)));
      body.emit(assign(r1632, bit_or(r165D, r165E), 0x01));

      ir_variable *const r165F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1661 = lshift(r1633, body.constant(int(16)));
      ir_expression *const r1662 = lequal(r1661, r1632);
      ir_if *f1660 = new(mem_ctx) ir_if(operand(r1662).val);
      exec_list *const f1660_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1660->then_instructions;

         body.emit(assign(r165F, body.constant(65535u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1660->else_instructions;

         body.emit(assign(r165F, expr(ir_binop_div, r1632, r1633), 0x01));


      body.instructions = f1660_parent_instructions;
      body.emit(f1660);

      /* END IF */

      body.emit(assign(r1630, bit_or(r1630, r165F), 0x01));

      body.emit(assign(r162F, r1630, 0x01));


   body.instructions = f1634_parent_instructions;
   body.emit(f1634);

   /* END IF */

   body.emit(ret(r162F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64By32To96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1663 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1663);
   ir_variable *const r1664 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1664);
   ir_variable *const r1665 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1665);
   ir_variable *const r1666 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1666);
   ir_variable *const r1667 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1667);
   ir_variable *const r1668 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1668);
   ir_variable *const r1669 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1669);
   ir_variable *const r166A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r166A);
   ir_variable *const r166B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r166B);
   ir_variable *const r166C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166C, bit_and(r1664, body.constant(65535u)), 0x01));

   ir_variable *const r166D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166D, rshift(r1664, body.constant(int(16))), 0x01));

   ir_variable *const r166E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166E, bit_and(r1665, body.constant(65535u)), 0x01));

   ir_variable *const r166F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166F, rshift(r1665, body.constant(int(16))), 0x01));

   ir_variable *const r1670 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1670, mul(r166D, r166E), 0x01));

   ir_expression *const r1671 = mul(r166C, r166F);
   body.emit(assign(r166A, add(r1671, r1670), 0x01));

   ir_expression *const r1672 = mul(r166D, r166F);
   ir_expression *const r1673 = less(r166A, r1670);
   ir_expression *const r1674 = expr(ir_unop_b2i, r1673);
   ir_expression *const r1675 = expr(ir_unop_i2u, r1674);
   ir_expression *const r1676 = lshift(r1675, body.constant(int(16)));
   ir_expression *const r1677 = rshift(r166A, body.constant(int(16)));
   ir_expression *const r1678 = add(r1676, r1677);
   body.emit(assign(r1669, add(r1672, r1678), 0x01));

   body.emit(assign(r166A, lshift(r166A, body.constant(int(16))), 0x01));

   ir_expression *const r1679 = mul(r166C, r166E);
   body.emit(assign(r166B, add(r1679, r166A), 0x01));

   ir_expression *const r167A = less(r166B, r166A);
   ir_expression *const r167B = expr(ir_unop_b2i, r167A);
   ir_expression *const r167C = expr(ir_unop_i2u, r167B);
   body.emit(assign(r1669, add(r1669, r167C), 0x01));

   ir_variable *const r167D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r167D);
   ir_variable *const r167E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r167E);
   ir_variable *const r167F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r167F);
   ir_variable *const r1680 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1680, bit_and(r1663, body.constant(65535u)), 0x01));

   ir_variable *const r1681 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1681, rshift(r1663, body.constant(int(16))), 0x01));

   ir_variable *const r1682 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1682, bit_and(r1665, body.constant(65535u)), 0x01));

   ir_variable *const r1683 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1683, rshift(r1665, body.constant(int(16))), 0x01));

   ir_variable *const r1684 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1684, mul(r1681, r1682), 0x01));

   ir_expression *const r1685 = mul(r1680, r1683);
   body.emit(assign(r167E, add(r1685, r1684), 0x01));

   ir_expression *const r1686 = mul(r1681, r1683);
   ir_expression *const r1687 = less(r167E, r1684);
   ir_expression *const r1688 = expr(ir_unop_b2i, r1687);
   ir_expression *const r1689 = expr(ir_unop_i2u, r1688);
   ir_expression *const r168A = lshift(r1689, body.constant(int(16)));
   ir_expression *const r168B = rshift(r167E, body.constant(int(16)));
   ir_expression *const r168C = add(r168A, r168B);
   body.emit(assign(r167D, add(r1686, r168C), 0x01));

   body.emit(assign(r167E, lshift(r167E, body.constant(int(16))), 0x01));

   ir_expression *const r168D = mul(r1680, r1682);
   body.emit(assign(r167F, add(r168D, r167E), 0x01));

   ir_expression *const r168E = less(r167F, r167E);
   ir_expression *const r168F = expr(ir_unop_b2i, r168E);
   ir_expression *const r1690 = expr(ir_unop_i2u, r168F);
   body.emit(assign(r167D, add(r167D, r1690), 0x01));

   ir_variable *const r1691 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1691, add(r167F, r1669), 0x01));

   body.emit(assign(r1668, r166B, 0x01));

   body.emit(assign(r1667, r1691, 0x01));

   ir_expression *const r1692 = less(r1691, r167F);
   ir_expression *const r1693 = expr(ir_unop_b2i, r1692);
   ir_expression *const r1694 = expr(ir_unop_i2u, r1693);
   body.emit(assign(r1666, add(r167D, r1694), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fdiv64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1695 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1695);
   ir_variable *const r1696 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1696);
   ir_variable *const r1697 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1697, body.constant(true), 0x01));

   ir_variable *const r1698 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1699 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1699);
   ir_variable *const r169A = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r169A);
   ir_variable *const r169B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r169B);
   ir_variable *const r169C = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r169C);
   ir_variable *const r169D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r169D);
   ir_variable *const r169E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r169E);
   ir_variable *const r169F = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r169F);
   ir_variable *const r16A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r16A0);
   ir_variable *const r16A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r16A1);
   ir_variable *const r16A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r16A2);
   ir_variable *const r16A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r16A3);
   ir_variable *const r16A4 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r16A4);
   body.emit(assign(r16A3, body.constant(0u), 0x01));

   body.emit(assign(r16A2, body.constant(0u), 0x01));

   body.emit(assign(r16A1, body.constant(0u), 0x01));

   body.emit(assign(r16A0, body.constant(0u), 0x01));

   body.emit(assign(r169F, body.constant(0u), 0x01));

   body.emit(assign(r169E, body.constant(0u), 0x01));

   ir_variable *const r16A5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r16A5);
   body.emit(assign(r16A5, bit_and(swizzle_y(r1695), body.constant(1048575u)), 0x02));

   body.emit(assign(r16A5, swizzle_x(r1695), 0x01));

   body.emit(assign(r169D, r16A5, 0x03));

   ir_variable *const r16A6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r16A7 = rshift(swizzle_y(r1695), body.constant(int(20)));
   ir_expression *const r16A8 = bit_and(r16A7, body.constant(2047u));
   body.emit(assign(r16A6, expr(ir_unop_u2i, r16A8), 0x01));

   body.emit(assign(r169C, r16A6, 0x01));

   ir_variable *const r16A9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r16A9);
   body.emit(assign(r16A9, bit_and(swizzle_y(r1696), body.constant(1048575u)), 0x02));

   body.emit(assign(r16A9, swizzle_x(r1696), 0x01));

   body.emit(assign(r169B, r16A9, 0x03));

   ir_variable *const r16AA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r16AB = rshift(swizzle_y(r1696), body.constant(int(20)));
   ir_expression *const r16AC = bit_and(r16AB, body.constant(2047u));
   body.emit(assign(r16AA, expr(ir_unop_u2i, r16AC), 0x01));

   body.emit(assign(r169A, r16AA, 0x01));

   ir_expression *const r16AD = rshift(swizzle_y(r1695), body.constant(int(31)));
   ir_expression *const r16AE = rshift(swizzle_y(r1696), body.constant(int(31)));
   body.emit(assign(r1699, bit_xor(r16AD, r16AE), 0x01));

   /* IF CONDITION */
   ir_expression *const r16B0 = equal(r16A6, body.constant(int(2047)));
   ir_if *f16AF = new(mem_ctx) ir_if(operand(r16B0).val);
   exec_list *const f16AF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f16AF->then_instructions;

      /* IF CONDITION */
      ir_expression *const r16B2 = bit_or(swizzle_y(r16A5), swizzle_x(r1695));
      ir_expression *const r16B3 = nequal(r16B2, body.constant(0u));
      ir_if *f16B1 = new(mem_ctx) ir_if(operand(r16B3).val);
      exec_list *const f16B1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16B1->then_instructions;

         ir_variable *const r16B4 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r16B4, swizzle_x(r1695), 0x01));

         ir_variable *const r16B5 = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r16B5, swizzle_x(r1696), 0x01));

         ir_variable *const r16B6 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r16B7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r16B8 = rshift(swizzle_y(r1695), body.constant(int(19)));
         ir_expression *const r16B9 = bit_and(r16B8, body.constant(4095u));
         ir_expression *const r16BA = equal(r16B9, body.constant(4094u));
         ir_expression *const r16BB = nequal(swizzle_x(r1695), body.constant(0u));
         ir_expression *const r16BC = bit_and(swizzle_y(r1695), body.constant(524287u));
         ir_expression *const r16BD = nequal(r16BC, body.constant(0u));
         ir_expression *const r16BE = logic_or(r16BB, r16BD);
         body.emit(assign(r16B7, logic_and(r16BA, r16BE), 0x01));

         ir_variable *const r16BF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r16C0 = lshift(swizzle_y(r1696), body.constant(int(1)));
         ir_expression *const r16C1 = lequal(body.constant(4292870144u), r16C0);
         ir_expression *const r16C2 = nequal(swizzle_x(r1696), body.constant(0u));
         ir_expression *const r16C3 = bit_and(swizzle_y(r1696), body.constant(1048575u));
         ir_expression *const r16C4 = nequal(r16C3, body.constant(0u));
         ir_expression *const r16C5 = logic_or(r16C2, r16C4);
         body.emit(assign(r16BF, logic_and(r16C1, r16C5), 0x01));

         body.emit(assign(r16B4, bit_or(swizzle_y(r1695), body.constant(524288u)), 0x02));

         body.emit(assign(r16B5, bit_or(swizzle_y(r1696), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r16C7 = lshift(swizzle_y(r1695), body.constant(int(1)));
         ir_expression *const r16C8 = lequal(body.constant(4292870144u), r16C7);
         ir_expression *const r16C9 = nequal(swizzle_x(r1695), body.constant(0u));
         ir_expression *const r16CA = bit_and(swizzle_y(r1695), body.constant(1048575u));
         ir_expression *const r16CB = nequal(r16CA, body.constant(0u));
         ir_expression *const r16CC = logic_or(r16C9, r16CB);
         ir_expression *const r16CD = logic_and(r16C8, r16CC);
         ir_if *f16C6 = new(mem_ctx) ir_if(operand(r16CD).val);
         exec_list *const f16C6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16C6->then_instructions;

            ir_variable *const r16CE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r16D0 = logic_and(r16B7, r16BF);
            ir_if *f16CF = new(mem_ctx) ir_if(operand(r16D0).val);
            exec_list *const f16CF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16CF->then_instructions;

               body.emit(assign(r16CE, r16B5, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16CF->else_instructions;

               body.emit(assign(r16CE, r16B4, 0x03));


            body.instructions = f16CF_parent_instructions;
            body.emit(f16CF);

            /* END IF */

            body.emit(assign(r16B6, r16CE, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16C6->else_instructions;

            body.emit(assign(r16B6, r16B5, 0x03));


         body.instructions = f16C6_parent_instructions;
         body.emit(f16C6);

         /* END IF */

         body.emit(assign(r1698, r16B6, 0x03));

         body.emit(assign(r1697, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16B1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r16D2 = equal(r16AA, body.constant(int(2047)));
         ir_if *f16D1 = new(mem_ctx) ir_if(operand(r16D2).val);
         exec_list *const f16D1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16D1->then_instructions;

            /* IF CONDITION */
            ir_expression *const r16D4 = bit_or(swizzle_y(r16A9), swizzle_x(r1696));
            ir_expression *const r16D5 = nequal(r16D4, body.constant(0u));
            ir_if *f16D3 = new(mem_ctx) ir_if(operand(r16D5).val);
            exec_list *const f16D3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16D3->then_instructions;

               ir_variable *const r16D6 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r16D6, swizzle_x(r1695), 0x01));

               ir_variable *const r16D7 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r16D7, swizzle_x(r1696), 0x01));

               ir_variable *const r16D8 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r16D9 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r16DA = rshift(swizzle_y(r1695), body.constant(int(19)));
               ir_expression *const r16DB = bit_and(r16DA, body.constant(4095u));
               ir_expression *const r16DC = equal(r16DB, body.constant(4094u));
               ir_expression *const r16DD = nequal(swizzle_x(r1695), body.constant(0u));
               ir_expression *const r16DE = bit_and(swizzle_y(r1695), body.constant(524287u));
               ir_expression *const r16DF = nequal(r16DE, body.constant(0u));
               ir_expression *const r16E0 = logic_or(r16DD, r16DF);
               body.emit(assign(r16D9, logic_and(r16DC, r16E0), 0x01));

               ir_variable *const r16E1 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r16E2 = lshift(swizzle_y(r1696), body.constant(int(1)));
               ir_expression *const r16E3 = lequal(body.constant(4292870144u), r16E2);
               ir_expression *const r16E4 = nequal(swizzle_x(r1696), body.constant(0u));
               ir_expression *const r16E5 = bit_and(swizzle_y(r1696), body.constant(1048575u));
               ir_expression *const r16E6 = nequal(r16E5, body.constant(0u));
               ir_expression *const r16E7 = logic_or(r16E4, r16E6);
               body.emit(assign(r16E1, logic_and(r16E3, r16E7), 0x01));

               body.emit(assign(r16D6, bit_or(swizzle_y(r1695), body.constant(524288u)), 0x02));

               body.emit(assign(r16D7, bit_or(swizzle_y(r1696), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r16E9 = lshift(swizzle_y(r1695), body.constant(int(1)));
               ir_expression *const r16EA = lequal(body.constant(4292870144u), r16E9);
               ir_expression *const r16EB = nequal(swizzle_x(r1695), body.constant(0u));
               ir_expression *const r16EC = bit_and(swizzle_y(r1695), body.constant(1048575u));
               ir_expression *const r16ED = nequal(r16EC, body.constant(0u));
               ir_expression *const r16EE = logic_or(r16EB, r16ED);
               ir_expression *const r16EF = logic_and(r16EA, r16EE);
               ir_if *f16E8 = new(mem_ctx) ir_if(operand(r16EF).val);
               exec_list *const f16E8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f16E8->then_instructions;

                  ir_variable *const r16F0 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r16F2 = logic_and(r16D9, r16E1);
                  ir_if *f16F1 = new(mem_ctx) ir_if(operand(r16F2).val);
                  exec_list *const f16F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f16F1->then_instructions;

                     body.emit(assign(r16F0, r16D7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f16F1->else_instructions;

                     body.emit(assign(r16F0, r16D6, 0x03));


                  body.instructions = f16F1_parent_instructions;
                  body.emit(f16F1);

                  /* END IF */

                  body.emit(assign(r16D8, r16F0, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f16E8->else_instructions;

                  body.emit(assign(r16D8, r16D7, 0x03));


               body.instructions = f16E8_parent_instructions;
               body.emit(f16E8);

               /* END IF */

               body.emit(assign(r1698, r16D8, 0x03));

               body.emit(assign(r1697, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16D3->else_instructions;

               ir_constant_data r16F3_data;
               memset(&r16F3_data, 0, sizeof(ir_constant_data));
               r16F3_data.u[0] = 4294967295;
               r16F3_data.u[1] = 4294967295;
               ir_constant *const r16F3 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r16F3_data);
               body.emit(assign(r1698, r16F3, 0x03));

               body.emit(assign(r1697, body.constant(false), 0x01));


            body.instructions = f16D3_parent_instructions;
            body.emit(f16D3);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16D1->else_instructions;

            ir_variable *const r16F4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r16F4);
            ir_expression *const r16F5 = lshift(r1699, body.constant(int(31)));
            body.emit(assign(r16F4, add(r16F5, body.constant(2146435072u)), 0x02));

            body.emit(assign(r16F4, body.constant(0u), 0x01));

            body.emit(assign(r1698, r16F4, 0x03));

            body.emit(assign(r1697, body.constant(false), 0x01));


         body.instructions = f16D1_parent_instructions;
         body.emit(f16D1);

         /* END IF */


      body.instructions = f16B1_parent_instructions;
      body.emit(f16B1);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f16AF->else_instructions;

      /* IF CONDITION */
      ir_expression *const r16F7 = equal(r16AA, body.constant(int(2047)));
      ir_if *f16F6 = new(mem_ctx) ir_if(operand(r16F7).val);
      exec_list *const f16F6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16F6->then_instructions;

         /* IF CONDITION */
         ir_expression *const r16F9 = bit_or(swizzle_y(r16A9), swizzle_x(r1696));
         ir_expression *const r16FA = nequal(r16F9, body.constant(0u));
         ir_if *f16F8 = new(mem_ctx) ir_if(operand(r16FA).val);
         exec_list *const f16F8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16F8->then_instructions;

            ir_variable *const r16FB = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r16FB, swizzle_x(r1695), 0x01));

            ir_variable *const r16FC = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r16FC, swizzle_x(r1696), 0x01));

            ir_variable *const r16FD = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r16FE = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r16FF = rshift(swizzle_y(r1695), body.constant(int(19)));
            ir_expression *const r1700 = bit_and(r16FF, body.constant(4095u));
            ir_expression *const r1701 = equal(r1700, body.constant(4094u));
            ir_expression *const r1702 = nequal(swizzle_x(r1695), body.constant(0u));
            ir_expression *const r1703 = bit_and(swizzle_y(r1695), body.constant(524287u));
            ir_expression *const r1704 = nequal(r1703, body.constant(0u));
            ir_expression *const r1705 = logic_or(r1702, r1704);
            body.emit(assign(r16FE, logic_and(r1701, r1705), 0x01));

            ir_variable *const r1706 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r1707 = lshift(swizzle_y(r1696), body.constant(int(1)));
            ir_expression *const r1708 = lequal(body.constant(4292870144u), r1707);
            ir_expression *const r1709 = nequal(swizzle_x(r1696), body.constant(0u));
            ir_expression *const r170A = bit_and(swizzle_y(r1696), body.constant(1048575u));
            ir_expression *const r170B = nequal(r170A, body.constant(0u));
            ir_expression *const r170C = logic_or(r1709, r170B);
            body.emit(assign(r1706, logic_and(r1708, r170C), 0x01));

            body.emit(assign(r16FB, bit_or(swizzle_y(r1695), body.constant(524288u)), 0x02));

            body.emit(assign(r16FC, bit_or(swizzle_y(r1696), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r170E = lshift(swizzle_y(r1695), body.constant(int(1)));
            ir_expression *const r170F = lequal(body.constant(4292870144u), r170E);
            ir_expression *const r1710 = nequal(swizzle_x(r1695), body.constant(0u));
            ir_expression *const r1711 = bit_and(swizzle_y(r1695), body.constant(1048575u));
            ir_expression *const r1712 = nequal(r1711, body.constant(0u));
            ir_expression *const r1713 = logic_or(r1710, r1712);
            ir_expression *const r1714 = logic_and(r170F, r1713);
            ir_if *f170D = new(mem_ctx) ir_if(operand(r1714).val);
            exec_list *const f170D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f170D->then_instructions;

               ir_variable *const r1715 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1717 = logic_and(r16FE, r1706);
               ir_if *f1716 = new(mem_ctx) ir_if(operand(r1717).val);
               exec_list *const f1716_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1716->then_instructions;

                  body.emit(assign(r1715, r16FC, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1716->else_instructions;

                  body.emit(assign(r1715, r16FB, 0x03));


               body.instructions = f1716_parent_instructions;
               body.emit(f1716);

               /* END IF */

               body.emit(assign(r16FD, r1715, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f170D->else_instructions;

               body.emit(assign(r16FD, r16FC, 0x03));


            body.instructions = f170D_parent_instructions;
            body.emit(f170D);

            /* END IF */

            body.emit(assign(r1698, r16FD, 0x03));

            body.emit(assign(r1697, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16F8->else_instructions;

            ir_variable *const r1718 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1718);
            body.emit(assign(r1718, lshift(r1699, body.constant(int(31))), 0x02));

            body.emit(assign(r1718, body.constant(0u), 0x01));

            body.emit(assign(r1698, r1718, 0x03));

            body.emit(assign(r1697, body.constant(false), 0x01));


         body.instructions = f16F8_parent_instructions;
         body.emit(f16F8);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16F6->else_instructions;

         /* IF CONDITION */
         ir_expression *const r171A = equal(r16AA, body.constant(int(0)));
         ir_if *f1719 = new(mem_ctx) ir_if(operand(r171A).val);
         exec_list *const f1719_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1719->then_instructions;

            /* IF CONDITION */
            ir_expression *const r171C = bit_or(swizzle_y(r16A9), swizzle_x(r1696));
            ir_expression *const r171D = equal(r171C, body.constant(0u));
            ir_if *f171B = new(mem_ctx) ir_if(operand(r171D).val);
            exec_list *const f171B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f171B->then_instructions;

               /* IF CONDITION */
               ir_expression *const r171F = expr(ir_unop_i2u, r16A6);
               ir_expression *const r1720 = bit_or(r171F, swizzle_y(r16A5));
               ir_expression *const r1721 = bit_or(r1720, swizzle_x(r1695));
               ir_expression *const r1722 = equal(r1721, body.constant(0u));
               ir_if *f171E = new(mem_ctx) ir_if(operand(r1722).val);
               exec_list *const f171E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f171E->then_instructions;

                  ir_constant_data r1723_data;
                  memset(&r1723_data, 0, sizeof(ir_constant_data));
                  r1723_data.u[0] = 4294967295;
                  r1723_data.u[1] = 4294967295;
                  ir_constant *const r1723 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1723_data);
                  body.emit(assign(r1698, r1723, 0x03));

                  body.emit(assign(r1697, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f171E->else_instructions;

                  ir_variable *const r1724 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1724);
                  ir_expression *const r1725 = lshift(r1699, body.constant(int(31)));
                  body.emit(assign(r1724, add(r1725, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1724, body.constant(0u), 0x01));

                  body.emit(assign(r1698, r1724, 0x03));

                  body.emit(assign(r1697, body.constant(false), 0x01));


               body.instructions = f171E_parent_instructions;
               body.emit(f171E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f171B->else_instructions;

               ir_variable *const r1726 = body.make_temp(glsl_type::uint_type, "aFrac0");
               body.emit(assign(r1726, swizzle_y(r16A9), 0x01));

               ir_variable *const r1727 = body.make_temp(glsl_type::uint_type, "aFrac1");
               body.emit(assign(r1727, swizzle_x(r16A9), 0x01));

               ir_variable *const r1728 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r1728, r16AA, 0x01));

               ir_variable *const r1729 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r1729, swizzle_y(r16A9), 0x01));

               ir_variable *const r172A = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r172A, swizzle_x(r16A9), 0x01));

               ir_variable *const r172B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r172B);
               /* IF CONDITION */
               ir_expression *const r172D = equal(swizzle_y(r16A9), body.constant(0u));
               ir_if *f172C = new(mem_ctx) ir_if(operand(r172D).val);
               exec_list *const f172C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f172C->then_instructions;

                  ir_variable *const r172E = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r172E, r1727, 0x01));

                  ir_variable *const r172F = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1730 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1730);
                  /* IF CONDITION */
                  ir_expression *const r1732 = equal(swizzle_x(r1696), body.constant(0u));
                  ir_if *f1731 = new(mem_ctx) ir_if(operand(r1732).val);
                  exec_list *const f1731_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1731->then_instructions;

                     body.emit(assign(r172F, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1731->else_instructions;

                     body.emit(assign(r1730, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1734 = bit_and(swizzle_x(r1696), body.constant(4294901760u));
                     ir_expression *const r1735 = equal(r1734, body.constant(0u));
                     ir_if *f1733 = new(mem_ctx) ir_if(operand(r1735).val);
                     exec_list *const f1733_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1733->then_instructions;

                        body.emit(assign(r1730, body.constant(int(16)), 0x01));

                        body.emit(assign(r172E, lshift(swizzle_x(r1696), body.constant(int(16))), 0x01));


                     body.instructions = f1733_parent_instructions;
                     body.emit(f1733);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1737 = bit_and(r172E, body.constant(4278190080u));
                     ir_expression *const r1738 = equal(r1737, body.constant(0u));
                     ir_if *f1736 = new(mem_ctx) ir_if(operand(r1738).val);
                     exec_list *const f1736_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1736->then_instructions;

                        body.emit(assign(r1730, add(r1730, body.constant(int(8))), 0x01));

                        body.emit(assign(r172E, lshift(r172E, body.constant(int(8))), 0x01));


                     body.instructions = f1736_parent_instructions;
                     body.emit(f1736);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r173A = bit_and(r172E, body.constant(4026531840u));
                     ir_expression *const r173B = equal(r173A, body.constant(0u));
                     ir_if *f1739 = new(mem_ctx) ir_if(operand(r173B).val);
                     exec_list *const f1739_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1739->then_instructions;

                        body.emit(assign(r1730, add(r1730, body.constant(int(4))), 0x01));

                        body.emit(assign(r172E, lshift(r172E, body.constant(int(4))), 0x01));


                     body.instructions = f1739_parent_instructions;
                     body.emit(f1739);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r173D = bit_and(r172E, body.constant(3221225472u));
                     ir_expression *const r173E = equal(r173D, body.constant(0u));
                     ir_if *f173C = new(mem_ctx) ir_if(operand(r173E).val);
                     exec_list *const f173C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f173C->then_instructions;

                        body.emit(assign(r1730, add(r1730, body.constant(int(2))), 0x01));

                        body.emit(assign(r172E, lshift(r172E, body.constant(int(2))), 0x01));


                     body.instructions = f173C_parent_instructions;
                     body.emit(f173C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1740 = bit_and(r172E, body.constant(2147483648u));
                     ir_expression *const r1741 = equal(r1740, body.constant(0u));
                     ir_if *f173F = new(mem_ctx) ir_if(operand(r1741).val);
                     exec_list *const f173F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f173F->then_instructions;

                        body.emit(assign(r1730, add(r1730, body.constant(int(1))), 0x01));


                     body.instructions = f173F_parent_instructions;
                     body.emit(f173F);

                     /* END IF */

                     body.emit(assign(r172F, r1730, 0x01));


                  body.instructions = f1731_parent_instructions;
                  body.emit(f1731);

                  /* END IF */

                  body.emit(assign(r172B, add(r172F, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1743 = less(r172B, body.constant(int(0)));
                  ir_if *f1742 = new(mem_ctx) ir_if(operand(r1743).val);
                  exec_list *const f1742_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1742->then_instructions;

                     ir_expression *const r1744 = neg(r172B);
                     body.emit(assign(r1729, rshift(swizzle_x(r1696), r1744), 0x01));

                     ir_expression *const r1745 = bit_and(r172B, body.constant(int(31)));
                     body.emit(assign(r172A, lshift(swizzle_x(r1696), r1745), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1742->else_instructions;

                     body.emit(assign(r1729, lshift(swizzle_x(r1696), r172B), 0x01));

                     body.emit(assign(r172A, body.constant(0u), 0x01));


                  body.instructions = f1742_parent_instructions;
                  body.emit(f1742);

                  /* END IF */

                  body.emit(assign(r1728, sub(body.constant(int(-31)), r172B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f172C->else_instructions;

                  ir_variable *const r1746 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r1746, r1726, 0x01));

                  ir_variable *const r1747 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1748 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1748);
                  /* IF CONDITION */
                  ir_expression *const r174A = equal(swizzle_y(r16A9), body.constant(0u));
                  ir_if *f1749 = new(mem_ctx) ir_if(operand(r174A).val);
                  exec_list *const f1749_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1749->then_instructions;

                     body.emit(assign(r1747, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1749->else_instructions;

                     body.emit(assign(r1748, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r174C = bit_and(swizzle_y(r16A9), body.constant(4294901760u));
                     ir_expression *const r174D = equal(r174C, body.constant(0u));
                     ir_if *f174B = new(mem_ctx) ir_if(operand(r174D).val);
                     exec_list *const f174B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f174B->then_instructions;

                        body.emit(assign(r1748, body.constant(int(16)), 0x01));

                        body.emit(assign(r1746, lshift(swizzle_y(r16A9), body.constant(int(16))), 0x01));


                     body.instructions = f174B_parent_instructions;
                     body.emit(f174B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r174F = bit_and(r1746, body.constant(4278190080u));
                     ir_expression *const r1750 = equal(r174F, body.constant(0u));
                     ir_if *f174E = new(mem_ctx) ir_if(operand(r1750).val);
                     exec_list *const f174E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f174E->then_instructions;

                        body.emit(assign(r1748, add(r1748, body.constant(int(8))), 0x01));

                        body.emit(assign(r1746, lshift(r1746, body.constant(int(8))), 0x01));


                     body.instructions = f174E_parent_instructions;
                     body.emit(f174E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1752 = bit_and(r1746, body.constant(4026531840u));
                     ir_expression *const r1753 = equal(r1752, body.constant(0u));
                     ir_if *f1751 = new(mem_ctx) ir_if(operand(r1753).val);
                     exec_list *const f1751_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1751->then_instructions;

                        body.emit(assign(r1748, add(r1748, body.constant(int(4))), 0x01));

                        body.emit(assign(r1746, lshift(r1746, body.constant(int(4))), 0x01));


                     body.instructions = f1751_parent_instructions;
                     body.emit(f1751);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1755 = bit_and(r1746, body.constant(3221225472u));
                     ir_expression *const r1756 = equal(r1755, body.constant(0u));
                     ir_if *f1754 = new(mem_ctx) ir_if(operand(r1756).val);
                     exec_list *const f1754_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1754->then_instructions;

                        body.emit(assign(r1748, add(r1748, body.constant(int(2))), 0x01));

                        body.emit(assign(r1746, lshift(r1746, body.constant(int(2))), 0x01));


                     body.instructions = f1754_parent_instructions;
                     body.emit(f1754);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1758 = bit_and(r1746, body.constant(2147483648u));
                     ir_expression *const r1759 = equal(r1758, body.constant(0u));
                     ir_if *f1757 = new(mem_ctx) ir_if(operand(r1759).val);
                     exec_list *const f1757_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1757->then_instructions;

                        body.emit(assign(r1748, add(r1748, body.constant(int(1))), 0x01));


                     body.instructions = f1757_parent_instructions;
                     body.emit(f1757);

                     /* END IF */

                     body.emit(assign(r1747, r1748, 0x01));


                  body.instructions = f1749_parent_instructions;
                  body.emit(f1749);

                  /* END IF */

                  body.emit(assign(r172B, add(r1747, body.constant(int(-11))), 0x01));

                  ir_variable *const r175A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r175A, lshift(swizzle_x(r1696), r172B), 0x01));

                  ir_variable *const r175B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r175D = equal(r172B, body.constant(int(0)));
                  ir_if *f175C = new(mem_ctx) ir_if(operand(r175D).val);
                  exec_list *const f175C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f175C->then_instructions;

                     body.emit(assign(r175B, r1726, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f175C->else_instructions;

                     ir_expression *const r175E = lshift(swizzle_y(r16A9), r172B);
                     ir_expression *const r175F = neg(r172B);
                     ir_expression *const r1760 = bit_and(r175F, body.constant(int(31)));
                     ir_expression *const r1761 = rshift(swizzle_x(r1696), r1760);
                     body.emit(assign(r175B, bit_or(r175E, r1761), 0x01));


                  body.instructions = f175C_parent_instructions;
                  body.emit(f175C);

                  /* END IF */

                  body.emit(assign(r1729, r175B, 0x01));

                  body.emit(assign(r172A, r175A, 0x01));

                  body.emit(assign(r1728, sub(body.constant(int(1)), r172B), 0x01));


               body.instructions = f172C_parent_instructions;
               body.emit(f172C);

               /* END IF */

               body.emit(assign(r169A, r1728, 0x01));

               body.emit(assign(r169B, r1729, 0x02));

               body.emit(assign(r169B, r172A, 0x01));


            body.instructions = f171B_parent_instructions;
            body.emit(f171B);

            /* END IF */


         body.instructions = f1719_parent_instructions;
         body.emit(f1719);

         /* END IF */

         /* IF CONDITION */
         ir_if *f1762 = new(mem_ctx) ir_if(operand(r1697).val);
         exec_list *const f1762_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1762->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1764 = equal(r16A6, body.constant(int(0)));
            ir_if *f1763 = new(mem_ctx) ir_if(operand(r1764).val);
            exec_list *const f1763_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1763->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1766 = bit_or(swizzle_y(r16A5), swizzle_x(r1695));
               ir_expression *const r1767 = equal(r1766, body.constant(0u));
               ir_if *f1765 = new(mem_ctx) ir_if(operand(r1767).val);
               exec_list *const f1765_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1765->then_instructions;

                  ir_variable *const r1768 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1768);
                  body.emit(assign(r1768, lshift(r1699, body.constant(int(31))), 0x02));

                  body.emit(assign(r1768, body.constant(0u), 0x01));

                  body.emit(assign(r1698, r1768, 0x03));

                  body.emit(assign(r1697, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1765->else_instructions;

                  ir_variable *const r1769 = body.make_temp(glsl_type::uint_type, "aFrac0");
                  body.emit(assign(r1769, swizzle_y(r16A5), 0x01));

                  ir_variable *const r176A = body.make_temp(glsl_type::uint_type, "aFrac1");
                  body.emit(assign(r176A, swizzle_x(r16A5), 0x01));

                  ir_variable *const r176B = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r176B, r16A6, 0x01));

                  ir_variable *const r176C = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r176C, swizzle_y(r16A5), 0x01));

                  ir_variable *const r176D = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r176D, swizzle_x(r16A5), 0x01));

                  ir_variable *const r176E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r176E);
                  /* IF CONDITION */
                  ir_expression *const r1770 = equal(swizzle_y(r16A5), body.constant(0u));
                  ir_if *f176F = new(mem_ctx) ir_if(operand(r1770).val);
                  exec_list *const f176F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f176F->then_instructions;

                     ir_variable *const r1771 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1771, r176A, 0x01));

                     ir_variable *const r1772 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1773 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1773);
                     /* IF CONDITION */
                     ir_expression *const r1775 = equal(swizzle_x(r1695), body.constant(0u));
                     ir_if *f1774 = new(mem_ctx) ir_if(operand(r1775).val);
                     exec_list *const f1774_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1774->then_instructions;

                        body.emit(assign(r1772, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1774->else_instructions;

                        body.emit(assign(r1773, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1777 = bit_and(swizzle_x(r1695), body.constant(4294901760u));
                        ir_expression *const r1778 = equal(r1777, body.constant(0u));
                        ir_if *f1776 = new(mem_ctx) ir_if(operand(r1778).val);
                        exec_list *const f1776_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1776->then_instructions;

                           body.emit(assign(r1773, body.constant(int(16)), 0x01));

                           body.emit(assign(r1771, lshift(swizzle_x(r1695), body.constant(int(16))), 0x01));


                        body.instructions = f1776_parent_instructions;
                        body.emit(f1776);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r177A = bit_and(r1771, body.constant(4278190080u));
                        ir_expression *const r177B = equal(r177A, body.constant(0u));
                        ir_if *f1779 = new(mem_ctx) ir_if(operand(r177B).val);
                        exec_list *const f1779_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1779->then_instructions;

                           body.emit(assign(r1773, add(r1773, body.constant(int(8))), 0x01));

                           body.emit(assign(r1771, lshift(r1771, body.constant(int(8))), 0x01));


                        body.instructions = f1779_parent_instructions;
                        body.emit(f1779);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r177D = bit_and(r1771, body.constant(4026531840u));
                        ir_expression *const r177E = equal(r177D, body.constant(0u));
                        ir_if *f177C = new(mem_ctx) ir_if(operand(r177E).val);
                        exec_list *const f177C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f177C->then_instructions;

                           body.emit(assign(r1773, add(r1773, body.constant(int(4))), 0x01));

                           body.emit(assign(r1771, lshift(r1771, body.constant(int(4))), 0x01));


                        body.instructions = f177C_parent_instructions;
                        body.emit(f177C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1780 = bit_and(r1771, body.constant(3221225472u));
                        ir_expression *const r1781 = equal(r1780, body.constant(0u));
                        ir_if *f177F = new(mem_ctx) ir_if(operand(r1781).val);
                        exec_list *const f177F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f177F->then_instructions;

                           body.emit(assign(r1773, add(r1773, body.constant(int(2))), 0x01));

                           body.emit(assign(r1771, lshift(r1771, body.constant(int(2))), 0x01));


                        body.instructions = f177F_parent_instructions;
                        body.emit(f177F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1783 = bit_and(r1771, body.constant(2147483648u));
                        ir_expression *const r1784 = equal(r1783, body.constant(0u));
                        ir_if *f1782 = new(mem_ctx) ir_if(operand(r1784).val);
                        exec_list *const f1782_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1782->then_instructions;

                           body.emit(assign(r1773, add(r1773, body.constant(int(1))), 0x01));


                        body.instructions = f1782_parent_instructions;
                        body.emit(f1782);

                        /* END IF */

                        body.emit(assign(r1772, r1773, 0x01));


                     body.instructions = f1774_parent_instructions;
                     body.emit(f1774);

                     /* END IF */

                     body.emit(assign(r176E, add(r1772, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1786 = less(r176E, body.constant(int(0)));
                     ir_if *f1785 = new(mem_ctx) ir_if(operand(r1786).val);
                     exec_list *const f1785_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1785->then_instructions;

                        ir_expression *const r1787 = neg(r176E);
                        body.emit(assign(r176C, rshift(swizzle_x(r1695), r1787), 0x01));

                        ir_expression *const r1788 = bit_and(r176E, body.constant(int(31)));
                        body.emit(assign(r176D, lshift(swizzle_x(r1695), r1788), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1785->else_instructions;

                        body.emit(assign(r176C, lshift(swizzle_x(r1695), r176E), 0x01));

                        body.emit(assign(r176D, body.constant(0u), 0x01));


                     body.instructions = f1785_parent_instructions;
                     body.emit(f1785);

                     /* END IF */

                     body.emit(assign(r176B, sub(body.constant(int(-31)), r176E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f176F->else_instructions;

                     ir_variable *const r1789 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1789, r1769, 0x01));

                     ir_variable *const r178A = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r178B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r178B);
                     /* IF CONDITION */
                     ir_expression *const r178D = equal(swizzle_y(r16A5), body.constant(0u));
                     ir_if *f178C = new(mem_ctx) ir_if(operand(r178D).val);
                     exec_list *const f178C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f178C->then_instructions;

                        body.emit(assign(r178A, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f178C->else_instructions;

                        body.emit(assign(r178B, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r178F = bit_and(swizzle_y(r16A5), body.constant(4294901760u));
                        ir_expression *const r1790 = equal(r178F, body.constant(0u));
                        ir_if *f178E = new(mem_ctx) ir_if(operand(r1790).val);
                        exec_list *const f178E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f178E->then_instructions;

                           body.emit(assign(r178B, body.constant(int(16)), 0x01));

                           body.emit(assign(r1789, lshift(swizzle_y(r16A5), body.constant(int(16))), 0x01));


                        body.instructions = f178E_parent_instructions;
                        body.emit(f178E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1792 = bit_and(r1789, body.constant(4278190080u));
                        ir_expression *const r1793 = equal(r1792, body.constant(0u));
                        ir_if *f1791 = new(mem_ctx) ir_if(operand(r1793).val);
                        exec_list *const f1791_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1791->then_instructions;

                           body.emit(assign(r178B, add(r178B, body.constant(int(8))), 0x01));

                           body.emit(assign(r1789, lshift(r1789, body.constant(int(8))), 0x01));


                        body.instructions = f1791_parent_instructions;
                        body.emit(f1791);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1795 = bit_and(r1789, body.constant(4026531840u));
                        ir_expression *const r1796 = equal(r1795, body.constant(0u));
                        ir_if *f1794 = new(mem_ctx) ir_if(operand(r1796).val);
                        exec_list *const f1794_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1794->then_instructions;

                           body.emit(assign(r178B, add(r178B, body.constant(int(4))), 0x01));

                           body.emit(assign(r1789, lshift(r1789, body.constant(int(4))), 0x01));


                        body.instructions = f1794_parent_instructions;
                        body.emit(f1794);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1798 = bit_and(r1789, body.constant(3221225472u));
                        ir_expression *const r1799 = equal(r1798, body.constant(0u));
                        ir_if *f1797 = new(mem_ctx) ir_if(operand(r1799).val);
                        exec_list *const f1797_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1797->then_instructions;

                           body.emit(assign(r178B, add(r178B, body.constant(int(2))), 0x01));

                           body.emit(assign(r1789, lshift(r1789, body.constant(int(2))), 0x01));


                        body.instructions = f1797_parent_instructions;
                        body.emit(f1797);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r179B = bit_and(r1789, body.constant(2147483648u));
                        ir_expression *const r179C = equal(r179B, body.constant(0u));
                        ir_if *f179A = new(mem_ctx) ir_if(operand(r179C).val);
                        exec_list *const f179A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f179A->then_instructions;

                           body.emit(assign(r178B, add(r178B, body.constant(int(1))), 0x01));


                        body.instructions = f179A_parent_instructions;
                        body.emit(f179A);

                        /* END IF */

                        body.emit(assign(r178A, r178B, 0x01));


                     body.instructions = f178C_parent_instructions;
                     body.emit(f178C);

                     /* END IF */

                     body.emit(assign(r176E, add(r178A, body.constant(int(-11))), 0x01));

                     ir_variable *const r179D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r179D, lshift(swizzle_x(r1695), r176E), 0x01));

                     ir_variable *const r179E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r17A0 = equal(r176E, body.constant(int(0)));
                     ir_if *f179F = new(mem_ctx) ir_if(operand(r17A0).val);
                     exec_list *const f179F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f179F->then_instructions;

                        body.emit(assign(r179E, r1769, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f179F->else_instructions;

                        ir_expression *const r17A1 = lshift(swizzle_y(r16A5), r176E);
                        ir_expression *const r17A2 = neg(r176E);
                        ir_expression *const r17A3 = bit_and(r17A2, body.constant(int(31)));
                        ir_expression *const r17A4 = rshift(swizzle_x(r1695), r17A3);
                        body.emit(assign(r179E, bit_or(r17A1, r17A4), 0x01));


                     body.instructions = f179F_parent_instructions;
                     body.emit(f179F);

                     /* END IF */

                     body.emit(assign(r176C, r179E, 0x01));

                     body.emit(assign(r176D, r179D, 0x01));

                     body.emit(assign(r176B, sub(body.constant(int(1)), r176E), 0x01));


                  body.instructions = f176F_parent_instructions;
                  body.emit(f176F);

                  /* END IF */

                  body.emit(assign(r169C, r176B, 0x01));

                  body.emit(assign(r169D, r176C, 0x02));

                  body.emit(assign(r169D, r176D, 0x01));


               body.instructions = f1765_parent_instructions;
               body.emit(f1765);

               /* END IF */


            body.instructions = f1763_parent_instructions;
            body.emit(f1763);

            /* END IF */

            /* IF CONDITION */
            ir_if *f17A5 = new(mem_ctx) ir_if(operand(r1697).val);
            exec_list *const f17A5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f17A5->then_instructions;

               ir_expression *const r17A6 = sub(r169C, r169A);
               body.emit(assign(r16A4, add(r17A6, body.constant(int(1021))), 0x01));

               ir_variable *const r17A7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r17A7, lshift(swizzle_x(r169D), body.constant(int(11))), 0x01));

               ir_variable *const r17A8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r17A9 = bit_or(swizzle_y(r169D), body.constant(1048576u));
               ir_expression *const r17AA = lshift(r17A9, body.constant(int(11)));
               ir_expression *const r17AB = rshift(swizzle_x(r169D), body.constant(int(21)));
               body.emit(assign(r17A8, bit_or(r17AA, r17AB), 0x01));

               body.emit(assign(r169D, r17A8, 0x02));

               body.emit(assign(r169D, r17A7, 0x01));

               ir_variable *const r17AC = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r17AC, lshift(swizzle_x(r169B), body.constant(int(11))), 0x01));

               ir_variable *const r17AD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r17AE = bit_or(swizzle_y(r169B), body.constant(1048576u));
               ir_expression *const r17AF = lshift(r17AE, body.constant(int(11)));
               ir_expression *const r17B0 = rshift(swizzle_x(r169B), body.constant(int(21)));
               body.emit(assign(r17AD, bit_or(r17AF, r17B0), 0x01));

               body.emit(assign(r169B, r17AD, 0x02));

               body.emit(assign(r169B, r17AC, 0x01));

               /* IF CONDITION */
               ir_expression *const r17B2 = less(r17AD, r17A8);
               ir_expression *const r17B3 = equal(r17AD, r17A8);
               ir_expression *const r17B4 = lequal(r17AC, r17A7);
               ir_expression *const r17B5 = logic_and(r17B3, r17B4);
               ir_expression *const r17B6 = logic_or(r17B2, r17B5);
               ir_if *f17B1 = new(mem_ctx) ir_if(operand(r17B6).val);
               exec_list *const f17B1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f17B1->then_instructions;

                  body.emit(assign(r169D, rshift(r17A8, body.constant(int(1))), 0x02));

                  ir_expression *const r17B7 = lshift(r17A8, body.constant(int(31)));
                  ir_expression *const r17B8 = rshift(r17A7, body.constant(int(1)));
                  body.emit(assign(r169D, bit_or(r17B7, r17B8), 0x01));

                  body.emit(assign(r16A4, add(r16A4, body.constant(int(1))), 0x01));


               body.instructions = f17B1_parent_instructions;
               body.emit(f17B1);

               /* END IF */

               ir_variable *const r17B9 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r17BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r17BA);
               ir_variable *const r17BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r17BB);
               ir_variable *const r17BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r17BC);
               ir_variable *const r17BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r17BD);
               body.emit(assign(r17BC, body.constant(0u), 0x01));

               body.emit(assign(r17BB, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r17BF = lequal(r17AD, swizzle_y(r169D));
               ir_if *f17BE = new(mem_ctx) ir_if(operand(r17BF).val);
               exec_list *const f17BE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f17BE->then_instructions;

                  body.emit(assign(r17B9, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f17BE->else_instructions;

                  body.emit(assign(r17BD, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r17C0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r17C2 = lshift(r17BD, body.constant(int(16)));
                  ir_expression *const r17C3 = lequal(r17C2, swizzle_y(r169D));
                  ir_if *f17C1 = new(mem_ctx) ir_if(operand(r17C3).val);
                  exec_list *const f17C1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17C1->then_instructions;

                     body.emit(assign(r17C0, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17C1->else_instructions;

                     ir_expression *const r17C4 = expr(ir_binop_div, swizzle_y(r169D), r17BD);
                     body.emit(assign(r17C0, lshift(r17C4, body.constant(int(16))), 0x01));


                  body.instructions = f17C1_parent_instructions;
                  body.emit(f17C1);

                  /* END IF */

                  body.emit(assign(r17BA, r17C0, 0x01));

                  ir_variable *const r17C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r17C5);
                  ir_variable *const r17C6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r17C6);
                  ir_variable *const r17C7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r17C7);
                  ir_variable *const r17C8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C8, bit_and(r17AD, body.constant(65535u)), 0x01));

                  ir_variable *const r17C9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C9, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r17CA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17CA, bit_and(r17C0, body.constant(65535u)), 0x01));

                  ir_variable *const r17CB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17CB, rshift(r17C0, body.constant(int(16))), 0x01));

                  ir_variable *const r17CC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17CC, mul(r17C9, r17CA), 0x01));

                  ir_expression *const r17CD = mul(r17C8, r17CB);
                  body.emit(assign(r17C6, add(r17CD, r17CC), 0x01));

                  ir_expression *const r17CE = mul(r17C9, r17CB);
                  ir_expression *const r17CF = less(r17C6, r17CC);
                  ir_expression *const r17D0 = expr(ir_unop_b2i, r17CF);
                  ir_expression *const r17D1 = expr(ir_unop_i2u, r17D0);
                  ir_expression *const r17D2 = lshift(r17D1, body.constant(int(16)));
                  ir_expression *const r17D3 = rshift(r17C6, body.constant(int(16)));
                  ir_expression *const r17D4 = add(r17D2, r17D3);
                  body.emit(assign(r17C5, add(r17CE, r17D4), 0x01));

                  body.emit(assign(r17C6, lshift(r17C6, body.constant(int(16))), 0x01));

                  ir_expression *const r17D5 = mul(r17C8, r17CA);
                  body.emit(assign(r17C7, add(r17D5, r17C6), 0x01));

                  ir_expression *const r17D6 = less(r17C7, r17C6);
                  ir_expression *const r17D7 = expr(ir_unop_b2i, r17D6);
                  ir_expression *const r17D8 = expr(ir_unop_i2u, r17D7);
                  body.emit(assign(r17C5, add(r17C5, r17D8), 0x01));

                  ir_expression *const r17D9 = sub(swizzle_y(r169D), r17C5);
                  ir_expression *const r17DA = less(swizzle_x(r169D), r17C7);
                  ir_expression *const r17DB = expr(ir_unop_b2i, r17DA);
                  ir_expression *const r17DC = expr(ir_unop_i2u, r17DB);
                  body.emit(assign(r17BC, sub(r17D9, r17DC), 0x01));

                  body.emit(assign(r17BB, sub(swizzle_x(r169D), r17C7), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f17DD = new(mem_ctx) ir_loop();
                  exec_list *const f17DD_parent_instructions = body.instructions;

                     body.instructions = &f17DD->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r17DF = expr(ir_unop_u2i, r17BC);
                     ir_expression *const r17E0 = gequal(r17DF, body.constant(int(0)));
                     ir_if *f17DE = new(mem_ctx) ir_if(operand(r17E0).val);
                     exec_list *const f17DE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17DE->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f17DE_parent_instructions;
                     body.emit(f17DE);

                     /* END IF */

                     body.emit(assign(r17BA, add(r17BA, body.constant(4294901760u)), 0x01));

                     ir_variable *const r17E1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r17E2 = lshift(r17AD, body.constant(int(16)));
                     body.emit(assign(r17E1, add(r17BB, r17E2), 0x01));

                     ir_expression *const r17E3 = add(r17BC, r17BD);
                     ir_expression *const r17E4 = less(r17E1, r17BB);
                     ir_expression *const r17E5 = expr(ir_unop_b2i, r17E4);
                     ir_expression *const r17E6 = expr(ir_unop_i2u, r17E5);
                     body.emit(assign(r17BC, add(r17E3, r17E6), 0x01));

                     body.emit(assign(r17BB, r17E1, 0x01));

                  /* LOOP END */

                  body.instructions = f17DD_parent_instructions;
                  body.emit(f17DD);

                  ir_expression *const r17E7 = lshift(r17BC, body.constant(int(16)));
                  ir_expression *const r17E8 = rshift(r17BB, body.constant(int(16)));
                  body.emit(assign(r17BC, bit_or(r17E7, r17E8), 0x01));

                  ir_variable *const r17E9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r17EB = lshift(r17BD, body.constant(int(16)));
                  ir_expression *const r17EC = lequal(r17EB, r17BC);
                  ir_if *f17EA = new(mem_ctx) ir_if(operand(r17EC).val);
                  exec_list *const f17EA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17EA->then_instructions;

                     body.emit(assign(r17E9, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17EA->else_instructions;

                     body.emit(assign(r17E9, expr(ir_binop_div, r17BC, r17BD), 0x01));


                  body.instructions = f17EA_parent_instructions;
                  body.emit(f17EA);

                  /* END IF */

                  body.emit(assign(r17BA, bit_or(r17BA, r17E9), 0x01));

                  body.emit(assign(r17B9, r17BA, 0x01));


               body.instructions = f17BE_parent_instructions;
               body.emit(f17BE);

               /* END IF */

               body.emit(assign(r16A3, r17B9, 0x01));

               ir_variable *const r17ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r17ED);
               ir_variable *const r17EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r17EE);
               ir_variable *const r17EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r17EF);
               ir_variable *const r17F0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F0, bit_and(r17AC, body.constant(65535u)), 0x01));

               ir_variable *const r17F1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F1, rshift(r17AC, body.constant(int(16))), 0x01));

               ir_variable *const r17F2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F2, bit_and(r17B9, body.constant(65535u)), 0x01));

               ir_variable *const r17F3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F3, rshift(r17B9, body.constant(int(16))), 0x01));

               ir_variable *const r17F4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F4, mul(r17F1, r17F2), 0x01));

               ir_expression *const r17F5 = mul(r17F0, r17F3);
               body.emit(assign(r17EE, add(r17F5, r17F4), 0x01));

               ir_expression *const r17F6 = mul(r17F1, r17F3);
               ir_expression *const r17F7 = less(r17EE, r17F4);
               ir_expression *const r17F8 = expr(ir_unop_b2i, r17F7);
               ir_expression *const r17F9 = expr(ir_unop_i2u, r17F8);
               ir_expression *const r17FA = lshift(r17F9, body.constant(int(16)));
               ir_expression *const r17FB = rshift(r17EE, body.constant(int(16)));
               ir_expression *const r17FC = add(r17FA, r17FB);
               body.emit(assign(r17ED, add(r17F6, r17FC), 0x01));

               body.emit(assign(r17EE, lshift(r17EE, body.constant(int(16))), 0x01));

               ir_expression *const r17FD = mul(r17F0, r17F2);
               body.emit(assign(r17EF, add(r17FD, r17EE), 0x01));

               ir_expression *const r17FE = less(r17EF, r17EE);
               ir_expression *const r17FF = expr(ir_unop_b2i, r17FE);
               ir_expression *const r1800 = expr(ir_unop_i2u, r17FF);
               body.emit(assign(r17ED, add(r17ED, r1800), 0x01));

               ir_variable *const r1801 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1801);
               ir_variable *const r1802 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1802);
               ir_variable *const r1803 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1803);
               ir_variable *const r1804 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1804, bit_and(r17AD, body.constant(65535u)), 0x01));

               ir_variable *const r1805 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1805, rshift(r17AD, body.constant(int(16))), 0x01));

               ir_variable *const r1806 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1806, bit_and(r17B9, body.constant(65535u)), 0x01));

               ir_variable *const r1807 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1807, rshift(r17B9, body.constant(int(16))), 0x01));

               ir_variable *const r1808 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1808, mul(r1805, r1806), 0x01));

               ir_expression *const r1809 = mul(r1804, r1807);
               body.emit(assign(r1802, add(r1809, r1808), 0x01));

               ir_expression *const r180A = mul(r1805, r1807);
               ir_expression *const r180B = less(r1802, r1808);
               ir_expression *const r180C = expr(ir_unop_b2i, r180B);
               ir_expression *const r180D = expr(ir_unop_i2u, r180C);
               ir_expression *const r180E = lshift(r180D, body.constant(int(16)));
               ir_expression *const r180F = rshift(r1802, body.constant(int(16)));
               ir_expression *const r1810 = add(r180E, r180F);
               body.emit(assign(r1801, add(r180A, r1810), 0x01));

               body.emit(assign(r1802, lshift(r1802, body.constant(int(16))), 0x01));

               ir_expression *const r1811 = mul(r1804, r1806);
               body.emit(assign(r1803, add(r1811, r1802), 0x01));

               ir_expression *const r1812 = less(r1803, r1802);
               ir_expression *const r1813 = expr(ir_unop_b2i, r1812);
               ir_expression *const r1814 = expr(ir_unop_i2u, r1813);
               body.emit(assign(r1801, add(r1801, r1814), 0x01));

               ir_variable *const r1815 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1815, add(r1803, r17ED), 0x01));

               ir_variable *const r1816 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1816);
               ir_variable *const r1817 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1818 = less(body.constant(0u), r17EF);
               ir_expression *const r1819 = expr(ir_unop_b2i, r1818);
               body.emit(assign(r1817, expr(ir_unop_i2u, r1819), 0x01));

               ir_variable *const r181A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r181A, sub(swizzle_x(r169D), r1815), 0x01));

               ir_expression *const r181B = less(r1815, r1803);
               ir_expression *const r181C = expr(ir_unop_b2i, r181B);
               ir_expression *const r181D = expr(ir_unop_i2u, r181C);
               ir_expression *const r181E = add(r1801, r181D);
               ir_expression *const r181F = sub(swizzle_y(r169D), r181E);
               ir_expression *const r1820 = less(r181A, r1817);
               ir_expression *const r1821 = expr(ir_unop_b2i, r1820);
               ir_expression *const r1822 = expr(ir_unop_i2u, r1821);
               body.emit(assign(r1816, sub(r181F, r1822), 0x01));

               ir_expression *const r1823 = less(swizzle_x(r169D), r1815);
               ir_expression *const r1824 = expr(ir_unop_b2i, r1823);
               ir_expression *const r1825 = expr(ir_unop_i2u, r1824);
               body.emit(assign(r1816, sub(r1816, r1825), 0x01));

               body.emit(assign(r16A1, r1816, 0x01));

               body.emit(assign(r16A0, sub(r181A, r1817), 0x01));

               body.emit(assign(r169F, neg(r17EF), 0x01));

               /* LOOP BEGIN */
               ir_loop *f1826 = new(mem_ctx) ir_loop();
               exec_list *const f1826_parent_instructions = body.instructions;

                  body.instructions = &f1826->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1828 = expr(ir_unop_u2i, r16A1);
                  ir_expression *const r1829 = gequal(r1828, body.constant(int(0)));
                  ir_if *f1827 = new(mem_ctx) ir_if(operand(r1829).val);
                  exec_list *const f1827_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1827->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f1827_parent_instructions;
                  body.emit(f1827);

                  /* END IF */

                  body.emit(assign(r16A3, add(r16A3, body.constant(4294967295u)), 0x01));

                  ir_variable *const r182A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r182A);
                  ir_variable *const r182B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r182B);
                  ir_variable *const r182C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r182C, add(r169F, r17AC), 0x01));

                  ir_variable *const r182D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r182E = less(r182C, r169F);
                  ir_expression *const r182F = expr(ir_unop_b2i, r182E);
                  body.emit(assign(r182D, expr(ir_unop_i2u, r182F), 0x01));

                  ir_variable *const r1830 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1830, add(r16A0, r17AD), 0x01));

                  body.emit(assign(r182B, add(r1830, r182D), 0x01));

                  ir_expression *const r1831 = less(r182B, r182D);
                  ir_expression *const r1832 = expr(ir_unop_b2i, r1831);
                  ir_expression *const r1833 = expr(ir_unop_i2u, r1832);
                  body.emit(assign(r182A, add(r16A1, r1833), 0x01));

                  ir_expression *const r1834 = less(r1830, r16A0);
                  ir_expression *const r1835 = expr(ir_unop_b2i, r1834);
                  ir_expression *const r1836 = expr(ir_unop_i2u, r1835);
                  body.emit(assign(r182A, add(r182A, r1836), 0x01));

                  body.emit(assign(r16A1, r182A, 0x01));

                  body.emit(assign(r16A0, r182B, 0x01));

                  body.emit(assign(r169F, r182C, 0x01));

               /* LOOP END */

               body.instructions = f1826_parent_instructions;
               body.emit(f1826);

               ir_variable *const r1837 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r1838 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r1838);
               ir_variable *const r1839 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r1839);
               ir_variable *const r183A = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r183A);
               ir_variable *const r183B = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r183B);
               body.emit(assign(r183A, body.constant(0u), 0x01));

               body.emit(assign(r1839, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r183D = lequal(r17AD, r16A0);
               ir_if *f183C = new(mem_ctx) ir_if(operand(r183D).val);
               exec_list *const f183C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f183C->then_instructions;

                  body.emit(assign(r1837, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f183C->else_instructions;

                  body.emit(assign(r183B, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r183E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1840 = lshift(r183B, body.constant(int(16)));
                  ir_expression *const r1841 = lequal(r1840, r16A0);
                  ir_if *f183F = new(mem_ctx) ir_if(operand(r1841).val);
                  exec_list *const f183F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f183F->then_instructions;

                     body.emit(assign(r183E, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f183F->else_instructions;

                     ir_expression *const r1842 = expr(ir_binop_div, r16A0, r183B);
                     body.emit(assign(r183E, lshift(r1842, body.constant(int(16))), 0x01));


                  body.instructions = f183F_parent_instructions;
                  body.emit(f183F);

                  /* END IF */

                  body.emit(assign(r1838, r183E, 0x01));

                  ir_variable *const r1843 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1843);
                  ir_variable *const r1844 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r1844);
                  ir_variable *const r1845 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1845);
                  ir_variable *const r1846 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1846, bit_and(r17AD, body.constant(65535u)), 0x01));

                  ir_variable *const r1847 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1847, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r1848 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1848, bit_and(r183E, body.constant(65535u)), 0x01));

                  ir_variable *const r1849 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1849, rshift(r183E, body.constant(int(16))), 0x01));

                  ir_variable *const r184A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r184A, mul(r1847, r1848), 0x01));

                  ir_expression *const r184B = mul(r1846, r1849);
                  body.emit(assign(r1844, add(r184B, r184A), 0x01));

                  ir_expression *const r184C = mul(r1847, r1849);
                  ir_expression *const r184D = less(r1844, r184A);
                  ir_expression *const r184E = expr(ir_unop_b2i, r184D);
                  ir_expression *const r184F = expr(ir_unop_i2u, r184E);
                  ir_expression *const r1850 = lshift(r184F, body.constant(int(16)));
                  ir_expression *const r1851 = rshift(r1844, body.constant(int(16)));
                  ir_expression *const r1852 = add(r1850, r1851);
                  body.emit(assign(r1843, add(r184C, r1852), 0x01));

                  body.emit(assign(r1844, lshift(r1844, body.constant(int(16))), 0x01));

                  ir_expression *const r1853 = mul(r1846, r1848);
                  body.emit(assign(r1845, add(r1853, r1844), 0x01));

                  ir_expression *const r1854 = less(r1845, r1844);
                  ir_expression *const r1855 = expr(ir_unop_b2i, r1854);
                  ir_expression *const r1856 = expr(ir_unop_i2u, r1855);
                  body.emit(assign(r1843, add(r1843, r1856), 0x01));

                  ir_expression *const r1857 = sub(r16A0, r1843);
                  ir_expression *const r1858 = less(r169F, r1845);
                  ir_expression *const r1859 = expr(ir_unop_b2i, r1858);
                  ir_expression *const r185A = expr(ir_unop_i2u, r1859);
                  body.emit(assign(r183A, sub(r1857, r185A), 0x01));

                  body.emit(assign(r1839, sub(r169F, r1845), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f185B = new(mem_ctx) ir_loop();
                  exec_list *const f185B_parent_instructions = body.instructions;

                     body.instructions = &f185B->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r185D = expr(ir_unop_u2i, r183A);
                     ir_expression *const r185E = gequal(r185D, body.constant(int(0)));
                     ir_if *f185C = new(mem_ctx) ir_if(operand(r185E).val);
                     exec_list *const f185C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f185C->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f185C_parent_instructions;
                     body.emit(f185C);

                     /* END IF */

                     body.emit(assign(r1838, add(r1838, body.constant(4294901760u)), 0x01));

                     ir_variable *const r185F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r1860 = lshift(r17AD, body.constant(int(16)));
                     body.emit(assign(r185F, add(r1839, r1860), 0x01));

                     ir_expression *const r1861 = add(r183A, r183B);
                     ir_expression *const r1862 = less(r185F, r1839);
                     ir_expression *const r1863 = expr(ir_unop_b2i, r1862);
                     ir_expression *const r1864 = expr(ir_unop_i2u, r1863);
                     body.emit(assign(r183A, add(r1861, r1864), 0x01));

                     body.emit(assign(r1839, r185F, 0x01));

                  /* LOOP END */

                  body.instructions = f185B_parent_instructions;
                  body.emit(f185B);

                  ir_expression *const r1865 = lshift(r183A, body.constant(int(16)));
                  ir_expression *const r1866 = rshift(r1839, body.constant(int(16)));
                  body.emit(assign(r183A, bit_or(r1865, r1866), 0x01));

                  ir_variable *const r1867 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1869 = lshift(r183B, body.constant(int(16)));
                  ir_expression *const r186A = lequal(r1869, r183A);
                  ir_if *f1868 = new(mem_ctx) ir_if(operand(r186A).val);
                  exec_list *const f1868_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1868->then_instructions;

                     body.emit(assign(r1867, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1868->else_instructions;

                     body.emit(assign(r1867, expr(ir_binop_div, r183A, r183B), 0x01));


                  body.instructions = f1868_parent_instructions;
                  body.emit(f1868);

                  /* END IF */

                  body.emit(assign(r1838, bit_or(r1838, r1867), 0x01));

                  body.emit(assign(r1837, r1838, 0x01));


               body.instructions = f183C_parent_instructions;
               body.emit(f183C);

               /* END IF */

               body.emit(assign(r16A2, r1837, 0x01));

               /* IF CONDITION */
               ir_expression *const r186C = bit_and(r1837, body.constant(1023u));
               ir_expression *const r186D = lequal(r186C, body.constant(4u));
               ir_if *f186B = new(mem_ctx) ir_if(operand(r186D).val);
               exec_list *const f186B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f186B->then_instructions;

                  ir_variable *const r186E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r186E);
                  ir_variable *const r186F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r186F);
                  ir_variable *const r1870 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1870);
                  ir_variable *const r1871 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1871, bit_and(r17AC, body.constant(65535u)), 0x01));

                  ir_variable *const r1872 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1872, rshift(r17AC, body.constant(int(16))), 0x01));

                  ir_variable *const r1873 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1873, bit_and(r1837, body.constant(65535u)), 0x01));

                  ir_variable *const r1874 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1874, rshift(r1837, body.constant(int(16))), 0x01));

                  ir_variable *const r1875 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1875, mul(r1872, r1873), 0x01));

                  ir_expression *const r1876 = mul(r1871, r1874);
                  body.emit(assign(r186F, add(r1876, r1875), 0x01));

                  ir_expression *const r1877 = mul(r1872, r1874);
                  ir_expression *const r1878 = less(r186F, r1875);
                  ir_expression *const r1879 = expr(ir_unop_b2i, r1878);
                  ir_expression *const r187A = expr(ir_unop_i2u, r1879);
                  ir_expression *const r187B = lshift(r187A, body.constant(int(16)));
                  ir_expression *const r187C = rshift(r186F, body.constant(int(16)));
                  ir_expression *const r187D = add(r187B, r187C);
                  body.emit(assign(r186E, add(r1877, r187D), 0x01));

                  body.emit(assign(r186F, lshift(r186F, body.constant(int(16))), 0x01));

                  ir_expression *const r187E = mul(r1871, r1873);
                  body.emit(assign(r1870, add(r187E, r186F), 0x01));

                  ir_expression *const r187F = less(r1870, r186F);
                  ir_expression *const r1880 = expr(ir_unop_b2i, r187F);
                  ir_expression *const r1881 = expr(ir_unop_i2u, r1880);
                  body.emit(assign(r186E, add(r186E, r1881), 0x01));

                  ir_variable *const r1882 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1882);
                  ir_variable *const r1883 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r1883);
                  ir_variable *const r1884 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1884);
                  ir_variable *const r1885 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1885, bit_and(r17AD, body.constant(65535u)), 0x01));

                  ir_variable *const r1886 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1886, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r1887 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1887, bit_and(r1837, body.constant(65535u)), 0x01));

                  ir_variable *const r1888 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1888, rshift(r1837, body.constant(int(16))), 0x01));

                  ir_variable *const r1889 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1889, mul(r1886, r1887), 0x01));

                  ir_expression *const r188A = mul(r1885, r1888);
                  body.emit(assign(r1883, add(r188A, r1889), 0x01));

                  ir_expression *const r188B = mul(r1886, r1888);
                  ir_expression *const r188C = less(r1883, r1889);
                  ir_expression *const r188D = expr(ir_unop_b2i, r188C);
                  ir_expression *const r188E = expr(ir_unop_i2u, r188D);
                  ir_expression *const r188F = lshift(r188E, body.constant(int(16)));
                  ir_expression *const r1890 = rshift(r1883, body.constant(int(16)));
                  ir_expression *const r1891 = add(r188F, r1890);
                  body.emit(assign(r1882, add(r188B, r1891), 0x01));

                  body.emit(assign(r1883, lshift(r1883, body.constant(int(16))), 0x01));

                  ir_expression *const r1892 = mul(r1885, r1887);
                  body.emit(assign(r1884, add(r1892, r1883), 0x01));

                  ir_expression *const r1893 = less(r1884, r1883);
                  ir_expression *const r1894 = expr(ir_unop_b2i, r1893);
                  ir_expression *const r1895 = expr(ir_unop_i2u, r1894);
                  body.emit(assign(r1882, add(r1882, r1895), 0x01));

                  ir_variable *const r1896 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1896, add(r1884, r186E), 0x01));

                  ir_variable *const r1897 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1897);
                  ir_variable *const r1898 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r1899 = less(body.constant(0u), r1870);
                  ir_expression *const r189A = expr(ir_unop_b2i, r1899);
                  body.emit(assign(r1898, expr(ir_unop_i2u, r189A), 0x01));

                  ir_variable *const r189B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r189B, sub(r169F, r1896), 0x01));

                  ir_expression *const r189C = less(r1896, r1884);
                  ir_expression *const r189D = expr(ir_unop_b2i, r189C);
                  ir_expression *const r189E = expr(ir_unop_i2u, r189D);
                  ir_expression *const r189F = add(r1882, r189E);
                  ir_expression *const r18A0 = sub(r16A0, r189F);
                  ir_expression *const r18A1 = less(r189B, r1898);
                  ir_expression *const r18A2 = expr(ir_unop_b2i, r18A1);
                  ir_expression *const r18A3 = expr(ir_unop_i2u, r18A2);
                  body.emit(assign(r1897, sub(r18A0, r18A3), 0x01));

                  ir_expression *const r18A4 = less(r169F, r1896);
                  ir_expression *const r18A5 = expr(ir_unop_b2i, r18A4);
                  ir_expression *const r18A6 = expr(ir_unop_i2u, r18A5);
                  body.emit(assign(r1897, sub(r1897, r18A6), 0x01));

                  body.emit(assign(r16A0, r1897, 0x01));

                  body.emit(assign(r169F, sub(r189B, r1898), 0x01));

                  body.emit(assign(r169E, neg(r1870), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f18A7 = new(mem_ctx) ir_loop();
                  exec_list *const f18A7_parent_instructions = body.instructions;

                     body.instructions = &f18A7->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18A9 = expr(ir_unop_u2i, r16A0);
                     ir_expression *const r18AA = gequal(r18A9, body.constant(int(0)));
                     ir_if *f18A8 = new(mem_ctx) ir_if(operand(r18AA).val);
                     exec_list *const f18A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18A8->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f18A8_parent_instructions;
                     body.emit(f18A8);

                     /* END IF */

                     body.emit(assign(r16A2, add(r16A2, body.constant(4294967295u)), 0x01));

                     ir_variable *const r18AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r18AB);
                     ir_variable *const r18AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r18AC);
                     ir_variable *const r18AD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18AD, add(r169E, r17AC), 0x01));

                     ir_variable *const r18AE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r18AF = less(r18AD, r169E);
                     ir_expression *const r18B0 = expr(ir_unop_b2i, r18AF);
                     body.emit(assign(r18AE, expr(ir_unop_i2u, r18B0), 0x01));

                     ir_variable *const r18B1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18B1, add(r169F, r17AD), 0x01));

                     body.emit(assign(r18AC, add(r18B1, r18AE), 0x01));

                     ir_expression *const r18B2 = less(r18AC, r18AE);
                     ir_expression *const r18B3 = expr(ir_unop_b2i, r18B2);
                     ir_expression *const r18B4 = expr(ir_unop_i2u, r18B3);
                     body.emit(assign(r18AB, add(r16A0, r18B4), 0x01));

                     ir_expression *const r18B5 = less(r18B1, r169F);
                     ir_expression *const r18B6 = expr(ir_unop_b2i, r18B5);
                     ir_expression *const r18B7 = expr(ir_unop_i2u, r18B6);
                     body.emit(assign(r18AB, add(r18AB, r18B7), 0x01));

                     body.emit(assign(r16A0, r18AB, 0x01));

                     body.emit(assign(r169F, r18AC, 0x01));

                     body.emit(assign(r169E, r18AD, 0x01));

                  /* LOOP END */

                  body.instructions = f18A7_parent_instructions;
                  body.emit(f18A7);

                  ir_expression *const r18B8 = bit_or(r16A0, r169F);
                  ir_expression *const r18B9 = bit_or(r18B8, r169E);
                  ir_expression *const r18BA = nequal(r18B9, body.constant(0u));
                  ir_expression *const r18BB = expr(ir_unop_b2i, r18BA);
                  ir_expression *const r18BC = expr(ir_unop_i2u, r18BB);
                  body.emit(assign(r16A2, bit_or(r16A2, r18BC), 0x01));


               body.instructions = f186B_parent_instructions;
               body.emit(f186B);

               /* END IF */

               ir_variable *const r18BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r18BD);
               ir_variable *const r18BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r18BE);
               ir_variable *const r18BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r18BF);
               body.emit(assign(r18BD, lshift(r16A2, body.constant(int(21))), 0x01));

               ir_expression *const r18C0 = lshift(r16A3, body.constant(int(21)));
               ir_expression *const r18C1 = rshift(r16A2, body.constant(int(11)));
               body.emit(assign(r18BE, bit_or(r18C0, r18C1), 0x01));

               body.emit(assign(r18BF, rshift(r16A3, body.constant(int(11))), 0x01));

               body.emit(assign(r18BD, bit_or(r18BD, body.constant(0u)), 0x01));

               body.emit(assign(r16A3, r18BF, 0x01));

               body.emit(assign(r16A2, r18BE, 0x01));

               ir_variable *const r18C2 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r18C2, r16A4, 0x01));

               ir_variable *const r18C3 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r18C3, r18BF, 0x01));

               ir_variable *const r18C4 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r18C4, r18BE, 0x01));

               ir_variable *const r18C5 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r18C5, r18BD, 0x01));

               ir_variable *const r18C6 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r18C6, body.constant(true), 0x01));

               ir_variable *const r18C7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r18C8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r18C8);
               ir_expression *const r18C9 = expr(ir_unop_u2i, r18BD);
               body.emit(assign(r18C8, less(r18C9, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r18CB = lequal(body.constant(int(2045)), r16A4);
               ir_if *f18CA = new(mem_ctx) ir_if(operand(r18CB).val);
               exec_list *const f18CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18CA->then_instructions;

                  ir_variable *const r18CC = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r18CE = less(body.constant(int(2045)), r16A4);
                  ir_if *f18CD = new(mem_ctx) ir_if(operand(r18CE).val);
                  exec_list *const f18CD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18CD->then_instructions;

                     body.emit(assign(r18CC, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18CD->else_instructions;

                     ir_variable *const r18CF = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r18D1 = equal(r16A4, body.constant(int(2045)));
                     ir_if *f18D0 = new(mem_ctx) ir_if(operand(r18D1).val);
                     exec_list *const f18D0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18D0->then_instructions;

                        ir_expression *const r18D2 = equal(body.constant(2097151u), r18BF);
                        ir_expression *const r18D3 = equal(body.constant(4294967295u), r18BE);
                        body.emit(assign(r18CF, logic_and(r18D2, r18D3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f18D0->else_instructions;

                        body.emit(assign(r18CF, body.constant(false), 0x01));


                     body.instructions = f18D0_parent_instructions;
                     body.emit(f18D0);

                     /* END IF */

                     body.emit(assign(r18CC, logic_and(r18CF, r18C8), 0x01));


                  body.instructions = f18CD_parent_instructions;
                  body.emit(f18CD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f18D4 = new(mem_ctx) ir_if(operand(r18CC).val);
                  exec_list *const f18D4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18D4->then_instructions;

                     ir_variable *const r18D5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r18D5);
                     ir_expression *const r18D6 = lshift(r1699, body.constant(int(31)));
                     body.emit(assign(r18D5, add(r18D6, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r18D5, body.constant(0u), 0x01));

                     body.emit(assign(r18C7, r18D5, 0x03));

                     body.emit(assign(r18C6, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18D4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18D8 = less(r16A4, body.constant(int(0)));
                     ir_if *f18D7 = new(mem_ctx) ir_if(operand(r18D8).val);
                     exec_list *const f18D7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18D7->then_instructions;

                        ir_variable *const r18D9 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r18D9, r18BD, 0x01));

                        ir_variable *const r18DA = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r18DA, neg(r16A4), 0x01));

                        ir_variable *const r18DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r18DB);
                        ir_variable *const r18DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r18DC);
                        ir_variable *const r18DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r18DD);
                        ir_variable *const r18DE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r18DF = neg(r18DA);
                        body.emit(assign(r18DE, bit_and(r18DF, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r18E1 = equal(r18DA, body.constant(int(0)));
                        ir_if *f18E0 = new(mem_ctx) ir_if(operand(r18E1).val);
                        exec_list *const f18E0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f18E0->then_instructions;

                           body.emit(assign(r18DB, r18BD, 0x01));

                           body.emit(assign(r18DC, r18BE, 0x01));

                           body.emit(assign(r18DD, r18BF, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f18E0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r18E3 = less(r18DA, body.constant(int(32)));
                           ir_if *f18E2 = new(mem_ctx) ir_if(operand(r18E3).val);
                           exec_list *const f18E2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f18E2->then_instructions;

                              body.emit(assign(r18DB, lshift(r18BE, r18DE), 0x01));

                              ir_expression *const r18E4 = lshift(r18BF, r18DE);
                              ir_expression *const r18E5 = rshift(r18BE, r18DA);
                              body.emit(assign(r18DC, bit_or(r18E4, r18E5), 0x01));

                              body.emit(assign(r18DD, rshift(r18BF, r18DA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f18E2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r18E7 = equal(r18DA, body.constant(int(32)));
                              ir_if *f18E6 = new(mem_ctx) ir_if(operand(r18E7).val);
                              exec_list *const f18E6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18E6->then_instructions;

                                 body.emit(assign(r18DB, r18BE, 0x01));

                                 body.emit(assign(r18DC, r18BF, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f18E6->else_instructions;

                                 body.emit(assign(r18D9, bit_or(r18BD, r18BE), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r18E9 = less(r18DA, body.constant(int(64)));
                                 ir_if *f18E8 = new(mem_ctx) ir_if(operand(r18E9).val);
                                 exec_list *const f18E8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f18E8->then_instructions;

                                    body.emit(assign(r18DB, lshift(r18BF, r18DE), 0x01));

                                    ir_expression *const r18EA = bit_and(r18DA, body.constant(int(31)));
                                    body.emit(assign(r18DC, rshift(r18BF, r18EA), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f18E8->else_instructions;

                                    ir_variable *const r18EB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r18ED = equal(r18DA, body.constant(int(64)));
                                    ir_if *f18EC = new(mem_ctx) ir_if(operand(r18ED).val);
                                    exec_list *const f18EC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f18EC->then_instructions;

                                       body.emit(assign(r18EB, r18BF, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f18EC->else_instructions;

                                       ir_expression *const r18EE = nequal(r18BF, body.constant(0u));
                                       ir_expression *const r18EF = expr(ir_unop_b2i, r18EE);
                                       body.emit(assign(r18EB, expr(ir_unop_i2u, r18EF), 0x01));


                                    body.instructions = f18EC_parent_instructions;
                                    body.emit(f18EC);

                                    /* END IF */

                                    body.emit(assign(r18DB, r18EB, 0x01));

                                    body.emit(assign(r18DC, body.constant(0u), 0x01));


                                 body.instructions = f18E8_parent_instructions;
                                 body.emit(f18E8);

                                 /* END IF */


                              body.instructions = f18E6_parent_instructions;
                              body.emit(f18E6);

                              /* END IF */

                              body.emit(assign(r18DD, body.constant(0u), 0x01));


                           body.instructions = f18E2_parent_instructions;
                           body.emit(f18E2);

                           /* END IF */

                           ir_expression *const r18F0 = nequal(r18D9, body.constant(0u));
                           ir_expression *const r18F1 = expr(ir_unop_b2i, r18F0);
                           ir_expression *const r18F2 = expr(ir_unop_i2u, r18F1);
                           body.emit(assign(r18DB, bit_or(r18DB, r18F2), 0x01));


                        body.instructions = f18E0_parent_instructions;
                        body.emit(f18E0);

                        /* END IF */

                        body.emit(assign(r18C3, r18DD, 0x01));

                        body.emit(assign(r18C4, r18DC, 0x01));

                        body.emit(assign(r18C5, r18DB, 0x01));

                        body.emit(assign(r18C2, body.constant(int(0)), 0x01));

                        body.emit(assign(r18C8, less(r18DB, body.constant(0u)), 0x01));


                     body.instructions = f18D7_parent_instructions;
                     body.emit(f18D7);

                     /* END IF */


                  body.instructions = f18D4_parent_instructions;
                  body.emit(f18D4);

                  /* END IF */


               body.instructions = f18CA_parent_instructions;
               body.emit(f18CA);

               /* END IF */

               /* IF CONDITION */
               ir_if *f18F3 = new(mem_ctx) ir_if(operand(r18C6).val);
               exec_list *const f18F3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18F3->then_instructions;

                  /* IF CONDITION */
                  ir_if *f18F4 = new(mem_ctx) ir_if(operand(r18C8).val);
                  exec_list *const f18F4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18F4->then_instructions;

                     ir_variable *const r18F5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18F5, add(r18C4, body.constant(1u)), 0x01));

                     ir_expression *const r18F6 = less(r18F5, r18C4);
                     ir_expression *const r18F7 = expr(ir_unop_b2i, r18F6);
                     ir_expression *const r18F8 = expr(ir_unop_i2u, r18F7);
                     body.emit(assign(r18C3, add(r18C3, r18F8), 0x01));

                     ir_expression *const r18F9 = equal(r18C5, body.constant(0u));
                     ir_expression *const r18FA = expr(ir_unop_b2i, r18F9);
                     ir_expression *const r18FB = expr(ir_unop_i2u, r18FA);
                     ir_expression *const r18FC = add(r18C5, r18FB);
                     ir_expression *const r18FD = bit_and(r18FC, body.constant(1u));
                     ir_expression *const r18FE = expr(ir_unop_bit_not, r18FD);
                     body.emit(assign(r18C4, bit_and(r18F5, r18FE), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18F4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1900 = bit_or(r18C3, r18C4);
                     ir_expression *const r1901 = equal(r1900, body.constant(0u));
                     ir_if *f18FF = new(mem_ctx) ir_if(operand(r1901).val);
                     exec_list *const f18FF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18FF->then_instructions;

                        body.emit(assign(r18C2, body.constant(int(0)), 0x01));


                     body.instructions = f18FF_parent_instructions;
                     body.emit(f18FF);

                     /* END IF */


                  body.instructions = f18F4_parent_instructions;
                  body.emit(f18F4);

                  /* END IF */

                  ir_variable *const r1902 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1902);
                  ir_expression *const r1903 = lshift(r1699, body.constant(int(31)));
                  ir_expression *const r1904 = expr(ir_unop_i2u, r18C2);
                  ir_expression *const r1905 = lshift(r1904, body.constant(int(20)));
                  ir_expression *const r1906 = add(r1903, r1905);
                  body.emit(assign(r1902, add(r1906, r18C3), 0x02));

                  body.emit(assign(r1902, r18C4, 0x01));

                  body.emit(assign(r18C7, r1902, 0x03));

                  body.emit(assign(r18C6, body.constant(false), 0x01));


               body.instructions = f18F3_parent_instructions;
               body.emit(f18F3);

               /* END IF */

               body.emit(assign(r1698, r18C7, 0x03));

               body.emit(assign(r1697, body.constant(false), 0x01));


            body.instructions = f17A5_parent_instructions;
            body.emit(f17A5);

            /* END IF */


         body.instructions = f1762_parent_instructions;
         body.emit(f1762);

         /* END IF */


      body.instructions = f16F6_parent_instructions;
      body.emit(f16F6);

      /* END IF */


   body.instructions = f16AF_parent_instructions;
   body.emit(f16AF);

   /* END IF */

   body.emit(ret(r1698));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat32Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1907 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_function_in);
   sig_parameters.push_tail(r1907);
   ir_variable *const r1908 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1908);
   ir_variable *const r1909 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFracPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1909);
   ir_variable *const r190A = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r190A, r1907, 0x01));

   ir_variable *const r190B = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r190C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r190C);
   /* IF CONDITION */
   ir_expression *const r190E = equal(r1907, body.constant(0u));
   ir_if *f190D = new(mem_ctx) ir_if(operand(r190E).val);
   exec_list *const f190D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f190D->then_instructions;

      body.emit(assign(r190B, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f190D->else_instructions;

      body.emit(assign(r190C, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r1910 = bit_and(r1907, body.constant(4294901760u));
      ir_expression *const r1911 = equal(r1910, body.constant(0u));
      ir_if *f190F = new(mem_ctx) ir_if(operand(r1911).val);
      exec_list *const f190F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f190F->then_instructions;

         body.emit(assign(r190C, body.constant(int(16)), 0x01));

         body.emit(assign(r190A, lshift(r1907, body.constant(int(16))), 0x01));


      body.instructions = f190F_parent_instructions;
      body.emit(f190F);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1913 = bit_and(r190A, body.constant(4278190080u));
      ir_expression *const r1914 = equal(r1913, body.constant(0u));
      ir_if *f1912 = new(mem_ctx) ir_if(operand(r1914).val);
      exec_list *const f1912_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1912->then_instructions;

         body.emit(assign(r190C, add(r190C, body.constant(int(8))), 0x01));

         body.emit(assign(r190A, lshift(r190A, body.constant(int(8))), 0x01));


      body.instructions = f1912_parent_instructions;
      body.emit(f1912);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1916 = bit_and(r190A, body.constant(4026531840u));
      ir_expression *const r1917 = equal(r1916, body.constant(0u));
      ir_if *f1915 = new(mem_ctx) ir_if(operand(r1917).val);
      exec_list *const f1915_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1915->then_instructions;

         body.emit(assign(r190C, add(r190C, body.constant(int(4))), 0x01));

         body.emit(assign(r190A, lshift(r190A, body.constant(int(4))), 0x01));


      body.instructions = f1915_parent_instructions;
      body.emit(f1915);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1919 = bit_and(r190A, body.constant(3221225472u));
      ir_expression *const r191A = equal(r1919, body.constant(0u));
      ir_if *f1918 = new(mem_ctx) ir_if(operand(r191A).val);
      exec_list *const f1918_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1918->then_instructions;

         body.emit(assign(r190C, add(r190C, body.constant(int(2))), 0x01));

         body.emit(assign(r190A, lshift(r190A, body.constant(int(2))), 0x01));


      body.instructions = f1918_parent_instructions;
      body.emit(f1918);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r191C = bit_and(r190A, body.constant(2147483648u));
      ir_expression *const r191D = equal(r191C, body.constant(0u));
      ir_if *f191B = new(mem_ctx) ir_if(operand(r191D).val);
      exec_list *const f191B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f191B->then_instructions;

         body.emit(assign(r190C, add(r190C, body.constant(int(1))), 0x01));


      body.instructions = f191B_parent_instructions;
      body.emit(f191B);

      /* END IF */

      body.emit(assign(r190B, r190C, 0x01));


   body.instructions = f190D_parent_instructions;
   body.emit(f190D);

   /* END IF */

   ir_variable *const r191E = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r191E, add(r190B, body.constant(int(-8))), 0x01));

   body.emit(assign(r1909, lshift(r1907, r191E), 0x01));

   body.emit(assign(r1908, sub(body.constant(int(1)), r191E), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Frac(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r191F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r191F);
   ir_expression *const r1920 = bit_and(r191F, body.constant(8388607u));
   body.emit(ret(r1920));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1921);
   ir_expression *const r1922 = rshift(r1921, body.constant(int(23)));
   ir_expression *const r1923 = bit_and(r1922, body.constant(255u));
   ir_expression *const r1924 = expr(ir_unop_u2i, r1923);
   body.emit(ret(r1924));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1925 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1925);
   ir_expression *const r1926 = rshift(r1925, body.constant(int(31)));
   body.emit(ret(r1926));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp32_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1927 = new(mem_ctx) ir_variable(glsl_type::float_type, "f", ir_var_function_in);
   sig_parameters.push_tail(r1927);
   ir_variable *const r1928 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1928, body.constant(true), 0x01));

   ir_variable *const r1929 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r192A = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r192A);
   ir_variable *const r192B = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r192B);
   ir_variable *const r192C = body.make_temp(glsl_type::uint_type, "floatBitsToUint_retval");
   body.emit(assign(r192C, expr(ir_unop_bitcast_f2u, r1927), 0x01));

   ir_variable *const r192D = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r192D, bit_and(r192C, body.constant(8388607u)), 0x01));

   body.emit(assign(r192B, r192D, 0x01));

   ir_variable *const r192E = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r192F = rshift(r192C, body.constant(int(23)));
   ir_expression *const r1930 = bit_and(r192F, body.constant(255u));
   body.emit(assign(r192E, expr(ir_unop_u2i, r1930), 0x01));

   body.emit(assign(r192A, r192E, 0x01));

   ir_variable *const r1931 = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r1931, rshift(r192C, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1933 = equal(r192E, body.constant(int(255)));
   ir_if *f1932 = new(mem_ctx) ir_if(operand(r1933).val);
   exec_list *const f1932_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1932->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1935 = nequal(r192D, body.constant(0u));
      ir_if *f1934 = new(mem_ctx) ir_if(operand(r1935).val);
      exec_list *const f1934_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1934->then_instructions;

         ir_variable *const r1936 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "nan", ir_var_auto);
         body.emit(r1936);
         body.emit(assign(r1936, body.constant(0u), 0x01));

         body.emit(assign(r1936, lshift(r192C, body.constant(int(9))), 0x02));

         ir_variable *const r1937 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1937);
         body.emit(assign(r1937, rshift(swizzle_y(r1936), body.constant(int(12))), 0x01));

         ir_expression *const r1938 = lshift(swizzle_y(r1936), body.constant(int(20)));
         body.emit(assign(r1936, bit_or(r1938, body.constant(0u)), 0x01));

         ir_expression *const r1939 = lshift(r1931, body.constant(int(31)));
         ir_expression *const r193A = bit_or(r1939, body.constant(2146959360u));
         body.emit(assign(r1936, bit_or(r1937, r193A), 0x02));

         body.emit(assign(r1929, r1936, 0x03));

         body.emit(assign(r1928, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1934->else_instructions;

         ir_variable *const r193B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r193B);
         ir_expression *const r193C = lshift(r1931, body.constant(int(31)));
         body.emit(assign(r193B, add(r193C, body.constant(2146435072u)), 0x02));

         body.emit(assign(r193B, body.constant(0u), 0x01));

         body.emit(assign(r1929, r193B, 0x03));

         body.emit(assign(r1928, body.constant(false), 0x01));


      body.instructions = f1934_parent_instructions;
      body.emit(f1934);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1932->else_instructions;

      /* IF CONDITION */
      ir_expression *const r193E = equal(r192E, body.constant(int(0)));
      ir_if *f193D = new(mem_ctx) ir_if(operand(r193E).val);
      exec_list *const f193D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f193D->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1940 = equal(r192D, body.constant(0u));
         ir_if *f193F = new(mem_ctx) ir_if(operand(r1940).val);
         exec_list *const f193F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f193F->then_instructions;

            ir_variable *const r1941 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1941);
            body.emit(assign(r1941, lshift(r1931, body.constant(int(31))), 0x02));

            body.emit(assign(r1941, body.constant(0u), 0x01));

            body.emit(assign(r1929, r1941, 0x03));

            body.emit(assign(r1928, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f193F->else_instructions;

            ir_variable *const r1942 = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r1942, r192E, 0x01));

            ir_variable *const r1943 = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r1943, r192D, 0x01));

            ir_variable *const r1944 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r1944, r192D, 0x01));

            ir_variable *const r1945 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r1946 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r1946);
            /* IF CONDITION */
            ir_expression *const r1948 = equal(r192D, body.constant(0u));
            ir_if *f1947 = new(mem_ctx) ir_if(operand(r1948).val);
            exec_list *const f1947_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1947->then_instructions;

               body.emit(assign(r1945, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1947->else_instructions;

               body.emit(assign(r1946, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r194A = bit_and(r192D, body.constant(4294901760u));
               ir_expression *const r194B = equal(r194A, body.constant(0u));
               ir_if *f1949 = new(mem_ctx) ir_if(operand(r194B).val);
               exec_list *const f1949_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1949->then_instructions;

                  body.emit(assign(r1946, body.constant(int(16)), 0x01));

                  body.emit(assign(r1944, lshift(r192D, body.constant(int(16))), 0x01));


               body.instructions = f1949_parent_instructions;
               body.emit(f1949);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r194D = bit_and(r1944, body.constant(4278190080u));
               ir_expression *const r194E = equal(r194D, body.constant(0u));
               ir_if *f194C = new(mem_ctx) ir_if(operand(r194E).val);
               exec_list *const f194C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f194C->then_instructions;

                  body.emit(assign(r1946, add(r1946, body.constant(int(8))), 0x01));

                  body.emit(assign(r1944, lshift(r1944, body.constant(int(8))), 0x01));


               body.instructions = f194C_parent_instructions;
               body.emit(f194C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1950 = bit_and(r1944, body.constant(4026531840u));
               ir_expression *const r1951 = equal(r1950, body.constant(0u));
               ir_if *f194F = new(mem_ctx) ir_if(operand(r1951).val);
               exec_list *const f194F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f194F->then_instructions;

                  body.emit(assign(r1946, add(r1946, body.constant(int(4))), 0x01));

                  body.emit(assign(r1944, lshift(r1944, body.constant(int(4))), 0x01));


               body.instructions = f194F_parent_instructions;
               body.emit(f194F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1953 = bit_and(r1944, body.constant(3221225472u));
               ir_expression *const r1954 = equal(r1953, body.constant(0u));
               ir_if *f1952 = new(mem_ctx) ir_if(operand(r1954).val);
               exec_list *const f1952_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1952->then_instructions;

                  body.emit(assign(r1946, add(r1946, body.constant(int(2))), 0x01));

                  body.emit(assign(r1944, lshift(r1944, body.constant(int(2))), 0x01));


               body.instructions = f1952_parent_instructions;
               body.emit(f1952);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1956 = bit_and(r1944, body.constant(2147483648u));
               ir_expression *const r1957 = equal(r1956, body.constant(0u));
               ir_if *f1955 = new(mem_ctx) ir_if(operand(r1957).val);
               exec_list *const f1955_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1955->then_instructions;

                  body.emit(assign(r1946, add(r1946, body.constant(int(1))), 0x01));


               body.instructions = f1955_parent_instructions;
               body.emit(f1955);

               /* END IF */

               body.emit(assign(r1945, r1946, 0x01));


            body.instructions = f1947_parent_instructions;
            body.emit(f1947);

            /* END IF */

            ir_variable *const r1958 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r1958, add(r1945, body.constant(int(-8))), 0x01));

            body.emit(assign(r1943, lshift(r192D, r1958), 0x01));

            body.emit(assign(r1942, sub(body.constant(int(1)), r1958), 0x01));

            body.emit(assign(r192B, r1943, 0x01));

            body.emit(assign(r192A, add(r1942, body.constant(int(-1))), 0x01));


         body.instructions = f193F_parent_instructions;
         body.emit(f193F);

         /* END IF */


      body.instructions = f193D_parent_instructions;
      body.emit(f193D);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1959 = new(mem_ctx) ir_if(operand(r1928).val);
      exec_list *const f1959_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1959->then_instructions;

         ir_variable *const r195A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r195A);
         ir_expression *const r195B = lshift(r1931, body.constant(int(31)));
         ir_expression *const r195C = add(r192A, body.constant(int(896)));
         ir_expression *const r195D = expr(ir_unop_i2u, r195C);
         ir_expression *const r195E = lshift(r195D, body.constant(int(20)));
         ir_expression *const r195F = add(r195B, r195E);
         ir_expression *const r1960 = rshift(r192B, body.constant(int(3)));
         body.emit(assign(r195A, add(r195F, r1960), 0x02));

         ir_expression *const r1961 = lshift(r192B, body.constant(int(29)));
         body.emit(assign(r195A, bit_or(r1961, body.constant(0u)), 0x01));

         body.emit(assign(r1929, r195A, 0x03));

         body.emit(assign(r1928, body.constant(false), 0x01));


      body.instructions = f1959_parent_instructions;
      body.emit(f1959);

      /* END IF */


   body.instructions = f1932_parent_instructions;
   body.emit(f1932);

   /* END IF */

   body.emit(ret(r1929));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1962 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r1962);
   ir_variable *const r1963 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r1963);
   ir_variable *const r1964 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r1964);
   ir_expression *const r1965 = lshift(r1962, body.constant(int(31)));
   ir_expression *const r1966 = expr(ir_unop_i2u, r1963);
   ir_expression *const r1967 = lshift(r1966, body.constant(int(23)));
   ir_expression *const r1968 = add(r1965, r1967);
   ir_expression *const r1969 = add(r1968, r1964);
   body.emit(ret(r1969));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift32RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r196A = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r196A);
   ir_variable *const r196B = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r196B);
   ir_variable *const r196C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zPtr", ir_var_function_inout);
   sig_parameters.push_tail(r196C);
   ir_variable *const r196D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r196D);
   /* IF CONDITION */
   ir_expression *const r196F = equal(r196B, body.constant(int(0)));
   ir_if *f196E = new(mem_ctx) ir_if(operand(r196F).val);
   exec_list *const f196E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f196E->then_instructions;

      body.emit(assign(r196D, r196A, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f196E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1971 = less(r196B, body.constant(int(32)));
      ir_if *f1970 = new(mem_ctx) ir_if(operand(r1971).val);
      exec_list *const f1970_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1970->then_instructions;

         ir_expression *const r1972 = rshift(r196A, r196B);
         ir_expression *const r1973 = neg(r196B);
         ir_expression *const r1974 = bit_and(r1973, body.constant(int(31)));
         ir_expression *const r1975 = lshift(r196A, r1974);
         ir_expression *const r1976 = nequal(r1975, body.constant(0u));
         ir_expression *const r1977 = expr(ir_unop_b2i, r1976);
         ir_expression *const r1978 = expr(ir_unop_i2u, r1977);
         body.emit(assign(r196D, bit_or(r1972, r1978), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1970->else_instructions;

         ir_expression *const r1979 = nequal(r196A, body.constant(0u));
         ir_expression *const r197A = expr(ir_unop_b2i, r1979);
         body.emit(assign(r196D, expr(ir_unop_i2u, r197A), 0x01));


      body.instructions = f1970_parent_instructions;
      body.emit(f1970);

      /* END IF */


   body.instructions = f196E_parent_instructions;
   body.emit(f196E);

   /* END IF */

   body.emit(assign(r196C, r196D, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r197B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r197B);
   ir_variable *const r197C = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r197C);
   ir_variable *const r197D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r197D);
   ir_variable *const r197E = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r197E, body.constant(true), 0x01));

   ir_variable *const r197F = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1980 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
   body.emit(r1980);
   ir_expression *const r1981 = expr(ir_unop_u2i, r197D);
   body.emit(assign(r1980, bit_and(r1981, body.constant(int(127))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1983 = expr(ir_unop_i2u, r197C);
   ir_expression *const r1984 = lequal(body.constant(253u), r1983);
   ir_if *f1982 = new(mem_ctx) ir_if(operand(r1984).val);
   exec_list *const f1982_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1982->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1986 = less(body.constant(int(253)), r197C);
      ir_expression *const r1987 = equal(r197C, body.constant(int(253)));
      ir_expression *const r1988 = add(r197D, body.constant(64u));
      ir_expression *const r1989 = expr(ir_unop_u2i, r1988);
      ir_expression *const r198A = less(r1989, body.constant(int(0)));
      ir_expression *const r198B = logic_and(r1987, r198A);
      ir_expression *const r198C = logic_or(r1986, r198B);
      ir_if *f1985 = new(mem_ctx) ir_if(operand(r198C).val);
      exec_list *const f1985_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1985->then_instructions;

         ir_expression *const r198D = lshift(r197B, body.constant(int(31)));
         body.emit(assign(r197F, add(r198D, body.constant(2139095040u)), 0x01));

         body.emit(assign(r197E, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1985->else_instructions;

         /* IF CONDITION */
         ir_expression *const r198F = less(r197C, body.constant(int(0)));
         ir_if *f198E = new(mem_ctx) ir_if(operand(r198F).val);
         exec_list *const f198E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f198E->then_instructions;

            ir_variable *const r1990 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r1990, neg(r197C), 0x01));

            ir_variable *const r1991 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
            body.emit(r1991);
            /* IF CONDITION */
            ir_expression *const r1993 = equal(r1990, body.constant(int(0)));
            ir_if *f1992 = new(mem_ctx) ir_if(operand(r1993).val);
            exec_list *const f1992_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1992->then_instructions;

               body.emit(assign(r1991, r197D, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1992->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1995 = less(r1990, body.constant(int(32)));
               ir_if *f1994 = new(mem_ctx) ir_if(operand(r1995).val);
               exec_list *const f1994_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1994->then_instructions;

                  ir_expression *const r1996 = rshift(r197D, r1990);
                  ir_expression *const r1997 = neg(r1990);
                  ir_expression *const r1998 = bit_and(r1997, body.constant(int(31)));
                  ir_expression *const r1999 = lshift(r197D, r1998);
                  ir_expression *const r199A = nequal(r1999, body.constant(0u));
                  ir_expression *const r199B = expr(ir_unop_b2i, r199A);
                  ir_expression *const r199C = expr(ir_unop_i2u, r199B);
                  body.emit(assign(r1991, bit_or(r1996, r199C), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1994->else_instructions;

                  ir_expression *const r199D = nequal(r197D, body.constant(0u));
                  ir_expression *const r199E = expr(ir_unop_b2i, r199D);
                  body.emit(assign(r1991, expr(ir_unop_i2u, r199E), 0x01));


               body.instructions = f1994_parent_instructions;
               body.emit(f1994);

               /* END IF */


            body.instructions = f1992_parent_instructions;
            body.emit(f1992);

            /* END IF */

            body.emit(assign(r197D, r1991, 0x01));

            body.emit(assign(r197C, body.constant(int(0)), 0x01));

            ir_expression *const r199F = expr(ir_unop_u2i, r1991);
            body.emit(assign(r1980, bit_and(r199F, body.constant(int(127))), 0x01));


         body.instructions = f198E_parent_instructions;
         body.emit(f198E);

         /* END IF */


      body.instructions = f1985_parent_instructions;
      body.emit(f1985);

      /* END IF */


   body.instructions = f1982_parent_instructions;
   body.emit(f1982);

   /* END IF */

   /* IF CONDITION */
   ir_if *f19A0 = new(mem_ctx) ir_if(operand(r197E).val);
   exec_list *const f19A0_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f19A0->then_instructions;

      ir_expression *const r19A1 = add(r197D, body.constant(64u));
      body.emit(assign(r197D, rshift(r19A1, body.constant(int(7))), 0x01));

      ir_expression *const r19A2 = bit_xor(r1980, body.constant(int(64)));
      ir_expression *const r19A3 = equal(r19A2, body.constant(int(0)));
      ir_expression *const r19A4 = expr(ir_unop_b2i, r19A3);
      ir_expression *const r19A5 = expr(ir_unop_i2u, r19A4);
      ir_expression *const r19A6 = bit_and(r19A5, body.constant(1u));
      ir_expression *const r19A7 = expr(ir_unop_bit_not, r19A6);
      body.emit(assign(r197D, bit_and(r197D, r19A7), 0x01));

      /* IF CONDITION */
      ir_expression *const r19A9 = equal(r197D, body.constant(0u));
      ir_if *f19A8 = new(mem_ctx) ir_if(operand(r19A9).val);
      exec_list *const f19A8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19A8->then_instructions;

         body.emit(assign(r197C, body.constant(int(0)), 0x01));


      body.instructions = f19A8_parent_instructions;
      body.emit(f19A8);

      /* END IF */

      ir_expression *const r19AA = lshift(r197B, body.constant(int(31)));
      ir_expression *const r19AB = expr(ir_unop_i2u, r197C);
      ir_expression *const r19AC = lshift(r19AB, body.constant(int(23)));
      ir_expression *const r19AD = add(r19AA, r19AC);
      body.emit(assign(r197F, add(r19AD, r197D), 0x01));

      body.emit(assign(r197E, body.constant(false), 0x01));


   body.instructions = f19A0_parent_instructions;
   body.emit(f19A0);

   /* END IF */

   body.emit(ret(r197F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_fp32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r19AE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r19AE);
   ir_variable *const r19AF = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r19B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r19B0);
   body.emit(assign(r19B0, body.constant(0u), 0x01));

   ir_variable *const r19B1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r19B1);
   body.emit(assign(r19B1, bit_and(swizzle_y(r19AE), body.constant(1048575u)), 0x02));

   body.emit(assign(r19B1, swizzle_x(r19AE), 0x01));

   ir_variable *const r19B2 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r19B3 = rshift(swizzle_y(r19AE), body.constant(int(20)));
   ir_expression *const r19B4 = bit_and(r19B3, body.constant(2047u));
   body.emit(assign(r19B2, expr(ir_unop_u2i, r19B4), 0x01));

   ir_variable *const r19B5 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r19B5, rshift(swizzle_y(r19AE), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r19B7 = equal(r19B2, body.constant(int(2047)));
   ir_if *f19B6 = new(mem_ctx) ir_if(operand(r19B7).val);
   exec_list *const f19B6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f19B6->then_instructions;

      /* IF CONDITION */
      ir_expression *const r19B9 = bit_or(swizzle_y(r19B1), swizzle_x(r19AE));
      ir_expression *const r19BA = nequal(r19B9, body.constant(0u));
      ir_if *f19B8 = new(mem_ctx) ir_if(operand(r19BA).val);
      exec_list *const f19B8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19B8->then_instructions;

         ir_variable *const r19BB = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r19BB, lshift(swizzle_x(r19AE), body.constant(int(12))), 0x01));

         ir_variable *const r19BC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r19BD = lshift(swizzle_y(r19AE), body.constant(int(12)));
         ir_expression *const r19BE = rshift(swizzle_x(r19AE), body.constant(int(20)));
         body.emit(assign(r19BC, bit_or(r19BD, r19BE), 0x01));

         body.emit(assign(r19AE, r19BC, 0x02));

         body.emit(assign(r19AE, r19BB, 0x01));

         ir_expression *const r19BF = lshift(r19B5, body.constant(int(31)));
         ir_expression *const r19C0 = bit_or(r19BF, body.constant(2143289344u));
         ir_expression *const r19C1 = rshift(r19BC, body.constant(int(9)));
         ir_expression *const r19C2 = bit_or(r19C0, r19C1);
         body.emit(assign(r19AF, expr(ir_unop_bitcast_u2f, r19C2), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f19B8->else_instructions;

         ir_expression *const r19C3 = lshift(r19B5, body.constant(int(31)));
         ir_expression *const r19C4 = add(r19C3, body.constant(2139095040u));
         body.emit(assign(r19AF, expr(ir_unop_bitcast_u2f, r19C4), 0x01));


      body.instructions = f19B8_parent_instructions;
      body.emit(f19B8);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f19B6->else_instructions;

      ir_variable *const r19C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r19C5);
      ir_variable *const r19C6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r19C6);
      ir_expression *const r19C7 = lshift(swizzle_y(r19B1), body.constant(int(10)));
      ir_expression *const r19C8 = rshift(swizzle_x(r19B1), body.constant(int(22)));
      ir_expression *const r19C9 = bit_or(r19C7, r19C8);
      ir_expression *const r19CA = lshift(swizzle_x(r19B1), body.constant(int(10)));
      ir_expression *const r19CB = nequal(r19CA, body.constant(0u));
      ir_expression *const r19CC = expr(ir_unop_b2i, r19CB);
      ir_expression *const r19CD = expr(ir_unop_i2u, r19CC);
      body.emit(assign(r19C5, bit_or(r19C9, r19CD), 0x01));

      body.emit(assign(r19C6, rshift(swizzle_y(r19B1), body.constant(int(22))), 0x01));

      body.emit(assign(r19B0, r19C5, 0x01));

      /* IF CONDITION */
      ir_expression *const r19CF = nequal(r19B2, body.constant(int(0)));
      ir_if *f19CE = new(mem_ctx) ir_if(operand(r19CF).val);
      exec_list *const f19CE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19CE->then_instructions;

         body.emit(assign(r19B0, bit_or(r19C5, body.constant(1073741824u)), 0x01));


      body.instructions = f19CE_parent_instructions;
      body.emit(f19CE);

      /* END IF */

      ir_variable *const r19D0 = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r19D0, add(r19B2, body.constant(int(-897))), 0x01));

      ir_variable *const r19D1 = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r19D1, r19B0, 0x01));

      ir_variable *const r19D2 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r19D2, body.constant(true), 0x01));

      ir_variable *const r19D3 = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r19D4 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
      body.emit(r19D4);
      ir_expression *const r19D5 = expr(ir_unop_u2i, r19B0);
      body.emit(assign(r19D4, bit_and(r19D5, body.constant(int(127))), 0x01));

      /* IF CONDITION */
      ir_expression *const r19D7 = expr(ir_unop_i2u, r19D0);
      ir_expression *const r19D8 = lequal(body.constant(253u), r19D7);
      ir_if *f19D6 = new(mem_ctx) ir_if(operand(r19D8).val);
      exec_list *const f19D6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19D6->then_instructions;

         /* IF CONDITION */
         ir_expression *const r19DA = less(body.constant(int(253)), r19D0);
         ir_expression *const r19DB = equal(r19D0, body.constant(int(253)));
         ir_expression *const r19DC = add(r19B0, body.constant(64u));
         ir_expression *const r19DD = expr(ir_unop_u2i, r19DC);
         ir_expression *const r19DE = less(r19DD, body.constant(int(0)));
         ir_expression *const r19DF = logic_and(r19DB, r19DE);
         ir_expression *const r19E0 = logic_or(r19DA, r19DF);
         ir_if *f19D9 = new(mem_ctx) ir_if(operand(r19E0).val);
         exec_list *const f19D9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19D9->then_instructions;

            ir_expression *const r19E1 = lshift(r19B5, body.constant(int(31)));
            body.emit(assign(r19D3, add(r19E1, body.constant(2139095040u)), 0x01));

            body.emit(assign(r19D2, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f19D9->else_instructions;

            /* IF CONDITION */
            ir_expression *const r19E3 = less(r19D0, body.constant(int(0)));
            ir_if *f19E2 = new(mem_ctx) ir_if(operand(r19E3).val);
            exec_list *const f19E2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f19E2->then_instructions;

               ir_variable *const r19E4 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r19E4, neg(r19D0), 0x01));

               ir_variable *const r19E5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r19E5);
               /* IF CONDITION */
               ir_expression *const r19E7 = equal(r19E4, body.constant(int(0)));
               ir_if *f19E6 = new(mem_ctx) ir_if(operand(r19E7).val);
               exec_list *const f19E6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f19E6->then_instructions;

                  body.emit(assign(r19E5, r19B0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f19E6->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r19E9 = less(r19E4, body.constant(int(32)));
                  ir_if *f19E8 = new(mem_ctx) ir_if(operand(r19E9).val);
                  exec_list *const f19E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f19E8->then_instructions;

                     ir_expression *const r19EA = rshift(r19B0, r19E4);
                     ir_expression *const r19EB = neg(r19E4);
                     ir_expression *const r19EC = bit_and(r19EB, body.constant(int(31)));
                     ir_expression *const r19ED = lshift(r19B0, r19EC);
                     ir_expression *const r19EE = nequal(r19ED, body.constant(0u));
                     ir_expression *const r19EF = expr(ir_unop_b2i, r19EE);
                     ir_expression *const r19F0 = expr(ir_unop_i2u, r19EF);
                     body.emit(assign(r19E5, bit_or(r19EA, r19F0), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f19E8->else_instructions;

                     ir_expression *const r19F1 = nequal(r19B0, body.constant(0u));
                     ir_expression *const r19F2 = expr(ir_unop_b2i, r19F1);
                     body.emit(assign(r19E5, expr(ir_unop_i2u, r19F2), 0x01));


                  body.instructions = f19E8_parent_instructions;
                  body.emit(f19E8);

                  /* END IF */


               body.instructions = f19E6_parent_instructions;
               body.emit(f19E6);

               /* END IF */

               body.emit(assign(r19D1, r19E5, 0x01));

               body.emit(assign(r19D0, body.constant(int(0)), 0x01));

               ir_expression *const r19F3 = expr(ir_unop_u2i, r19E5);
               body.emit(assign(r19D4, bit_and(r19F3, body.constant(int(127))), 0x01));


            body.instructions = f19E2_parent_instructions;
            body.emit(f19E2);

            /* END IF */


         body.instructions = f19D9_parent_instructions;
         body.emit(f19D9);

         /* END IF */


      body.instructions = f19D6_parent_instructions;
      body.emit(f19D6);

      /* END IF */

      /* IF CONDITION */
      ir_if *f19F4 = new(mem_ctx) ir_if(operand(r19D2).val);
      exec_list *const f19F4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19F4->then_instructions;

         ir_expression *const r19F5 = add(r19D1, body.constant(64u));
         body.emit(assign(r19D1, rshift(r19F5, body.constant(int(7))), 0x01));

         ir_expression *const r19F6 = bit_xor(r19D4, body.constant(int(64)));
         ir_expression *const r19F7 = equal(r19F6, body.constant(int(0)));
         ir_expression *const r19F8 = expr(ir_unop_b2i, r19F7);
         ir_expression *const r19F9 = expr(ir_unop_i2u, r19F8);
         ir_expression *const r19FA = bit_and(r19F9, body.constant(1u));
         ir_expression *const r19FB = expr(ir_unop_bit_not, r19FA);
         body.emit(assign(r19D1, bit_and(r19D1, r19FB), 0x01));

         /* IF CONDITION */
         ir_expression *const r19FD = equal(r19D1, body.constant(0u));
         ir_if *f19FC = new(mem_ctx) ir_if(operand(r19FD).val);
         exec_list *const f19FC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19FC->then_instructions;

            body.emit(assign(r19D0, body.constant(int(0)), 0x01));


         body.instructions = f19FC_parent_instructions;
         body.emit(f19FC);

         /* END IF */

         ir_expression *const r19FE = lshift(r19B5, body.constant(int(31)));
         ir_expression *const r19FF = expr(ir_unop_i2u, r19D0);
         ir_expression *const r1A00 = lshift(r19FF, body.constant(int(23)));
         ir_expression *const r1A01 = add(r19FE, r1A00);
         body.emit(assign(r19D3, add(r1A01, r19D1), 0x01));

         body.emit(assign(r19D2, body.constant(false), 0x01));


      body.instructions = f19F4_parent_instructions;
      body.emit(f19F4);

      /* END IF */

      body.emit(assign(r19AF, expr(ir_unop_bitcast_u2f, r19D3), 0x01));


   body.instructions = f19B6_parent_instructions;
   body.emit(f19B6);

   /* END IF */

   body.emit(ret(r19AF));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_int(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A02 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A02);
   ir_variable *const r1A03 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1A03, body.constant(true), 0x01));

   ir_variable *const r1A04 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r1A05 = new(mem_ctx) ir_variable(glsl_type::uint_type, "absZ", ir_var_auto);
   body.emit(r1A05);
   ir_variable *const r1A06 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aSign", ir_var_auto);
   body.emit(r1A06);
   ir_variable *const r1A07 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r1A07);
   ir_variable *const r1A08 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1A08);
   body.emit(assign(r1A08, bit_and(swizzle_y(r1A02), body.constant(1048575u)), 0x02));

   body.emit(assign(r1A08, swizzle_x(r1A02), 0x01));

   body.emit(assign(r1A07, r1A08, 0x03));

   ir_variable *const r1A09 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1A0A = rshift(swizzle_y(r1A02), body.constant(int(20)));
   ir_expression *const r1A0B = bit_and(r1A0A, body.constant(2047u));
   body.emit(assign(r1A09, expr(ir_unop_u2i, r1A0B), 0x01));

   body.emit(assign(r1A06, rshift(swizzle_y(r1A02), body.constant(int(31))), 0x01));

   body.emit(assign(r1A05, body.constant(0u), 0x01));

   ir_variable *const r1A0C = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r1A0C, add(r1A09, body.constant(int(-1043))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A0E = lequal(body.constant(int(0)), r1A0C);
   ir_if *f1A0D = new(mem_ctx) ir_if(operand(r1A0E).val);
   exec_list *const f1A0D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A0D->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1A10 = less(body.constant(int(1054)), r1A09);
      ir_if *f1A0F = new(mem_ctx) ir_if(operand(r1A10).val);
      exec_list *const f1A0F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A0F->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1A12 = equal(r1A09, body.constant(int(2047)));
         ir_expression *const r1A13 = bit_or(swizzle_y(r1A08), swizzle_x(r1A02));
         ir_expression *const r1A14 = expr(ir_unop_u2i, r1A13);
         ir_expression *const r1A15 = expr(ir_unop_i2b, r1A14);
         ir_expression *const r1A16 = logic_and(r1A12, r1A15);
         ir_if *f1A11 = new(mem_ctx) ir_if(operand(r1A16).val);
         exec_list *const f1A11_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A11->then_instructions;

            body.emit(assign(r1A06, body.constant(0u), 0x01));


         body.instructions = f1A11_parent_instructions;
         body.emit(f1A11);

         /* END IF */

         ir_variable *const r1A17 = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A19 = expr(ir_unop_u2i, r1A06);
         ir_expression *const r1A1A = expr(ir_unop_i2b, r1A19);
         ir_if *f1A18 = new(mem_ctx) ir_if(operand(r1A1A).val);
         exec_list *const f1A18_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A18->then_instructions;

            body.emit(assign(r1A17, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A18->else_instructions;

            body.emit(assign(r1A17, body.constant(int(2147483647)), 0x01));


         body.instructions = f1A18_parent_instructions;
         body.emit(f1A18);

         /* END IF */

         body.emit(assign(r1A04, r1A17, 0x01));

         body.emit(assign(r1A03, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A0F->else_instructions;

         ir_variable *const r1A1B = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r1A1B, bit_or(swizzle_y(r1A08), body.constant(1048576u)), 0x01));

         ir_variable *const r1A1C = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1A1C, lshift(swizzle_x(r1A02), r1A0C), 0x01));

         ir_variable *const r1A1D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A1F = equal(r1A0C, body.constant(int(0)));
         ir_if *f1A1E = new(mem_ctx) ir_if(operand(r1A1F).val);
         exec_list *const f1A1E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A1E->then_instructions;

            body.emit(assign(r1A1D, r1A1B, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A1E->else_instructions;

            ir_expression *const r1A20 = lshift(r1A1B, r1A0C);
            ir_expression *const r1A21 = neg(r1A0C);
            ir_expression *const r1A22 = bit_and(r1A21, body.constant(int(31)));
            ir_expression *const r1A23 = rshift(swizzle_x(r1A02), r1A22);
            body.emit(assign(r1A1D, bit_or(r1A20, r1A23), 0x01));


         body.instructions = f1A1E_parent_instructions;
         body.emit(f1A1E);

         /* END IF */

         body.emit(assign(r1A05, r1A1D, 0x01));


      body.instructions = f1A0F_parent_instructions;
      body.emit(f1A0F);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A0D->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1A25 = less(r1A09, body.constant(int(1023)));
      ir_if *f1A24 = new(mem_ctx) ir_if(operand(r1A25).val);
      exec_list *const f1A24_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A24->then_instructions;

         body.emit(assign(r1A04, body.constant(int(0)), 0x01));

         body.emit(assign(r1A03, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A24->else_instructions;

         body.emit(assign(r1A07, bit_or(swizzle_y(r1A08), body.constant(1048576u)), 0x02));

         ir_expression *const r1A26 = neg(r1A0C);
         body.emit(assign(r1A05, rshift(swizzle_y(r1A07), r1A26), 0x01));


      body.instructions = f1A24_parent_instructions;
      body.emit(f1A24);

      /* END IF */


   body.instructions = f1A0D_parent_instructions;
   body.emit(f1A0D);

   /* END IF */

   /* IF CONDITION */
   ir_if *f1A27 = new(mem_ctx) ir_if(operand(r1A03).val);
   exec_list *const f1A27_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A27->then_instructions;

      ir_variable *const r1A28 = body.make_temp(glsl_type::int_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1A2A = nequal(r1A06, body.constant(0u));
      ir_if *f1A29 = new(mem_ctx) ir_if(operand(r1A2A).val);
      exec_list *const f1A29_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A29->then_instructions;

         ir_expression *const r1A2B = expr(ir_unop_u2i, r1A05);
         body.emit(assign(r1A28, neg(r1A2B), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A29->else_instructions;

         body.emit(assign(r1A28, expr(ir_unop_u2i, r1A05), 0x01));


      body.instructions = f1A29_parent_instructions;
      body.emit(f1A29);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1A2D = less(r1A28, body.constant(int(0)));
      ir_expression *const r1A2E = expr(ir_unop_b2i, r1A2D);
      ir_expression *const r1A2F = expr(ir_unop_i2u, r1A2E);
      ir_expression *const r1A30 = bit_xor(r1A06, r1A2F);
      ir_expression *const r1A31 = expr(ir_unop_u2i, r1A30);
      ir_expression *const r1A32 = expr(ir_unop_i2b, r1A31);
      ir_expression *const r1A33 = expr(ir_unop_i2b, r1A28);
      ir_expression *const r1A34 = logic_and(r1A32, r1A33);
      ir_if *f1A2C = new(mem_ctx) ir_if(operand(r1A34).val);
      exec_list *const f1A2C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A2C->then_instructions;

         ir_variable *const r1A35 = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A37 = expr(ir_unop_u2i, r1A06);
         ir_expression *const r1A38 = expr(ir_unop_i2b, r1A37);
         ir_if *f1A36 = new(mem_ctx) ir_if(operand(r1A38).val);
         exec_list *const f1A36_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A36->then_instructions;

            body.emit(assign(r1A35, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A36->else_instructions;

            body.emit(assign(r1A35, body.constant(int(2147483647)), 0x01));


         body.instructions = f1A36_parent_instructions;
         body.emit(f1A36);

         /* END IF */

         body.emit(assign(r1A04, r1A35, 0x01));

         body.emit(assign(r1A03, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A2C->else_instructions;

         body.emit(assign(r1A04, r1A28, 0x01));

         body.emit(assign(r1A03, body.constant(false), 0x01));


      body.instructions = f1A2C_parent_instructions;
      body.emit(f1A2C);

      /* END IF */


   body.instructions = f1A27_parent_instructions;
   body.emit(f1A27);

   /* END IF */

   body.emit(ret(r1A04));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
int_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A39 = new(mem_ctx) ir_variable(glsl_type::int_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A39);
   ir_variable *const r1A3A = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1A3B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1A3B);
   ir_variable *const r1A3C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1A3C);
   ir_variable *const r1A3D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1A3D);
   body.emit(assign(r1A3D, body.constant(0u), 0x01));

   body.emit(assign(r1A3C, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A3F = equal(r1A39, body.constant(int(0)));
   ir_if *f1A3E = new(mem_ctx) ir_if(operand(r1A3F).val);
   exec_list *const f1A3E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A3E->then_instructions;

      ir_variable *const r1A40 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1A40);
      body.emit(assign(r1A40, body.constant(0u), 0x02));

      body.emit(assign(r1A40, body.constant(0u), 0x01));

      body.emit(assign(r1A3A, r1A40, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A3E->else_instructions;

      ir_expression *const r1A41 = less(r1A39, body.constant(int(0)));
      ir_expression *const r1A42 = expr(ir_unop_b2i, r1A41);
      body.emit(assign(r1A3B, expr(ir_unop_i2u, r1A42), 0x01));

      ir_variable *const r1A43 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1A45 = less(r1A39, body.constant(int(0)));
      ir_if *f1A44 = new(mem_ctx) ir_if(operand(r1A45).val);
      exec_list *const f1A44_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A44->then_instructions;

         ir_expression *const r1A46 = neg(r1A39);
         body.emit(assign(r1A43, expr(ir_unop_i2u, r1A46), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A44->else_instructions;

         body.emit(assign(r1A43, expr(ir_unop_i2u, r1A39), 0x01));


      body.instructions = f1A44_parent_instructions;
      body.emit(f1A44);

      /* END IF */

      ir_variable *const r1A47 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1A47, r1A43, 0x01));

      ir_variable *const r1A48 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1A49 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1A49);
      /* IF CONDITION */
      ir_expression *const r1A4B = equal(r1A43, body.constant(0u));
      ir_if *f1A4A = new(mem_ctx) ir_if(operand(r1A4B).val);
      exec_list *const f1A4A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A4A->then_instructions;

         body.emit(assign(r1A48, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A4A->else_instructions;

         body.emit(assign(r1A49, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1A4D = bit_and(r1A43, body.constant(4294901760u));
         ir_expression *const r1A4E = equal(r1A4D, body.constant(0u));
         ir_if *f1A4C = new(mem_ctx) ir_if(operand(r1A4E).val);
         exec_list *const f1A4C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A4C->then_instructions;

            body.emit(assign(r1A49, body.constant(int(16)), 0x01));

            body.emit(assign(r1A47, lshift(r1A43, body.constant(int(16))), 0x01));


         body.instructions = f1A4C_parent_instructions;
         body.emit(f1A4C);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A50 = bit_and(r1A47, body.constant(4278190080u));
         ir_expression *const r1A51 = equal(r1A50, body.constant(0u));
         ir_if *f1A4F = new(mem_ctx) ir_if(operand(r1A51).val);
         exec_list *const f1A4F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A4F->then_instructions;

            body.emit(assign(r1A49, add(r1A49, body.constant(int(8))), 0x01));

            body.emit(assign(r1A47, lshift(r1A47, body.constant(int(8))), 0x01));


         body.instructions = f1A4F_parent_instructions;
         body.emit(f1A4F);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A53 = bit_and(r1A47, body.constant(4026531840u));
         ir_expression *const r1A54 = equal(r1A53, body.constant(0u));
         ir_if *f1A52 = new(mem_ctx) ir_if(operand(r1A54).val);
         exec_list *const f1A52_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A52->then_instructions;

            body.emit(assign(r1A49, add(r1A49, body.constant(int(4))), 0x01));

            body.emit(assign(r1A47, lshift(r1A47, body.constant(int(4))), 0x01));


         body.instructions = f1A52_parent_instructions;
         body.emit(f1A52);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A56 = bit_and(r1A47, body.constant(3221225472u));
         ir_expression *const r1A57 = equal(r1A56, body.constant(0u));
         ir_if *f1A55 = new(mem_ctx) ir_if(operand(r1A57).val);
         exec_list *const f1A55_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A55->then_instructions;

            body.emit(assign(r1A49, add(r1A49, body.constant(int(2))), 0x01));

            body.emit(assign(r1A47, lshift(r1A47, body.constant(int(2))), 0x01));


         body.instructions = f1A55_parent_instructions;
         body.emit(f1A55);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A59 = bit_and(r1A47, body.constant(2147483648u));
         ir_expression *const r1A5A = equal(r1A59, body.constant(0u));
         ir_if *f1A58 = new(mem_ctx) ir_if(operand(r1A5A).val);
         exec_list *const f1A58_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A58->then_instructions;

            body.emit(assign(r1A49, add(r1A49, body.constant(int(1))), 0x01));


         body.instructions = f1A58_parent_instructions;
         body.emit(f1A58);

         /* END IF */

         body.emit(assign(r1A48, r1A49, 0x01));


      body.instructions = f1A4A_parent_instructions;
      body.emit(f1A4A);

      /* END IF */

      ir_variable *const r1A5B = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r1A5B, add(r1A48, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1A5D = lequal(body.constant(int(0)), r1A5B);
      ir_if *f1A5C = new(mem_ctx) ir_if(operand(r1A5D).val);
      exec_list *const f1A5C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A5C->then_instructions;

         body.emit(assign(r1A3D, lshift(r1A43, r1A5B), 0x01));

         body.emit(assign(r1A3C, body.constant(0u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A5C->else_instructions;

         ir_variable *const r1A5E = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r1A5E, body.constant(0u), 0x01));

         ir_variable *const r1A5F = body.make_temp(glsl_type::int_type, "count");
         body.emit(assign(r1A5F, neg(r1A5B), 0x01));

         ir_variable *const r1A60 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r1A60);
         ir_variable *const r1A61 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1A61);
         ir_variable *const r1A62 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r1A63 = neg(r1A5F);
         body.emit(assign(r1A62, bit_and(r1A63, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r1A65 = equal(r1A5F, body.constant(int(0)));
         ir_if *f1A64 = new(mem_ctx) ir_if(operand(r1A65).val);
         exec_list *const f1A64_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A64->then_instructions;

            body.emit(assign(r1A60, body.constant(0u), 0x01));

            body.emit(assign(r1A61, r1A43, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A64->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1A67 = less(r1A5F, body.constant(int(32)));
            ir_if *f1A66 = new(mem_ctx) ir_if(operand(r1A67).val);
            exec_list *const f1A66_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1A66->then_instructions;

               ir_expression *const r1A68 = lshift(r1A43, r1A62);
               body.emit(assign(r1A60, bit_or(r1A68, body.constant(0u)), 0x01));

               body.emit(assign(r1A61, rshift(r1A43, r1A5F), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1A66->else_instructions;

               ir_variable *const r1A69 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1A6B = less(r1A5F, body.constant(int(64)));
               ir_if *f1A6A = new(mem_ctx) ir_if(operand(r1A6B).val);
               exec_list *const f1A6A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1A6A->then_instructions;

                  ir_expression *const r1A6C = bit_and(r1A5F, body.constant(int(31)));
                  body.emit(assign(r1A69, rshift(r1A43, r1A6C), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1A6A->else_instructions;

                  body.emit(assign(r1A69, body.constant(0u), 0x01));


               body.instructions = f1A6A_parent_instructions;
               body.emit(f1A6A);

               /* END IF */

               body.emit(assign(r1A60, r1A69, 0x01));

               body.emit(assign(r1A61, body.constant(0u), 0x01));


            body.instructions = f1A66_parent_instructions;
            body.emit(f1A66);

            /* END IF */


         body.instructions = f1A64_parent_instructions;
         body.emit(f1A64);

         /* END IF */

         body.emit(assign(r1A3D, r1A61, 0x01));

         body.emit(assign(r1A3C, r1A60, 0x01));


      body.instructions = f1A5C_parent_instructions;
      body.emit(f1A5C);

      /* END IF */

      ir_variable *const r1A6D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1A6D);
      ir_expression *const r1A6E = lshift(r1A3B, body.constant(int(31)));
      ir_expression *const r1A6F = sub(body.constant(int(1042)), r1A5B);
      ir_expression *const r1A70 = expr(ir_unop_i2u, r1A6F);
      ir_expression *const r1A71 = lshift(r1A70, body.constant(int(20)));
      ir_expression *const r1A72 = add(r1A6E, r1A71);
      body.emit(assign(r1A6D, add(r1A72, r1A3D), 0x02));

      body.emit(assign(r1A6D, r1A3C, 0x01));

      body.emit(assign(r1A3A, r1A6D, 0x03));


   body.instructions = f1A3E_parent_instructions;
   body.emit(f1A3E);

   /* END IF */

   body.emit(ret(r1A3A));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fgt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A73 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A73);
   ir_variable *const r1A74 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1A74);
   ir_variable *const r1A75 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r1A76 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r1A76);
   ir_variable *const r1A77 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r1A77);
   ir_variable *const r1A78 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1A78);
   body.emit(assign(r1A78, bit_and(swizzle_y(r1A74), body.constant(1048575u)), 0x02));

   body.emit(assign(r1A78, swizzle_x(r1A74), 0x01));

   ir_variable *const r1A79 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1A79);
   body.emit(assign(r1A79, bit_and(swizzle_y(r1A73), body.constant(1048575u)), 0x02));

   body.emit(assign(r1A79, swizzle_x(r1A73), 0x01));

   ir_expression *const r1A7A = rshift(swizzle_y(r1A74), body.constant(int(20)));
   ir_expression *const r1A7B = bit_and(r1A7A, body.constant(2047u));
   ir_expression *const r1A7C = expr(ir_unop_u2i, r1A7B);
   ir_expression *const r1A7D = equal(r1A7C, body.constant(int(2047)));
   ir_expression *const r1A7E = bit_or(swizzle_y(r1A78), swizzle_x(r1A74));
   ir_expression *const r1A7F = nequal(r1A7E, body.constant(0u));
   body.emit(assign(r1A77, logic_and(r1A7D, r1A7F), 0x01));

   ir_expression *const r1A80 = rshift(swizzle_y(r1A73), body.constant(int(20)));
   ir_expression *const r1A81 = bit_and(r1A80, body.constant(2047u));
   ir_expression *const r1A82 = expr(ir_unop_u2i, r1A81);
   ir_expression *const r1A83 = equal(r1A82, body.constant(int(2047)));
   ir_expression *const r1A84 = bit_or(swizzle_y(r1A79), swizzle_x(r1A73));
   ir_expression *const r1A85 = nequal(r1A84, body.constant(0u));
   body.emit(assign(r1A76, logic_and(r1A83, r1A85), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A87 = logic_or(r1A77, r1A76);
   ir_if *f1A86 = new(mem_ctx) ir_if(operand(r1A87).val);
   exec_list *const f1A86_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A86->then_instructions;

      body.emit(assign(r1A75, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A86->else_instructions;

      ir_variable *const r1A88 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1A88, rshift(swizzle_y(r1A74), body.constant(int(31))), 0x01));

      ir_variable *const r1A89 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1A89, rshift(swizzle_y(r1A73), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1A8B = nequal(r1A88, r1A89);
      ir_if *f1A8A = new(mem_ctx) ir_if(operand(r1A8B).val);
      exec_list *const f1A8A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A8A->then_instructions;

         ir_expression *const r1A8C = nequal(r1A88, body.constant(0u));
         ir_expression *const r1A8D = bit_or(swizzle_y(r1A74), swizzle_y(r1A73));
         ir_expression *const r1A8E = lshift(r1A8D, body.constant(int(1)));
         ir_expression *const r1A8F = bit_or(r1A8E, swizzle_x(r1A74));
         ir_expression *const r1A90 = bit_or(r1A8F, swizzle_x(r1A73));
         ir_expression *const r1A91 = nequal(r1A90, body.constant(0u));
         body.emit(assign(r1A75, logic_and(r1A8C, r1A91), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A8A->else_instructions;

         ir_variable *const r1A92 = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A94 = nequal(r1A88, body.constant(0u));
         ir_if *f1A93 = new(mem_ctx) ir_if(operand(r1A94).val);
         exec_list *const f1A93_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A93->then_instructions;

            ir_expression *const r1A95 = less(swizzle_y(r1A73), swizzle_y(r1A74));
            ir_expression *const r1A96 = equal(swizzle_y(r1A73), swizzle_y(r1A74));
            ir_expression *const r1A97 = less(swizzle_x(r1A73), swizzle_x(r1A74));
            ir_expression *const r1A98 = logic_and(r1A96, r1A97);
            body.emit(assign(r1A92, logic_or(r1A95, r1A98), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A93->else_instructions;

            ir_expression *const r1A99 = less(swizzle_y(r1A74), swizzle_y(r1A73));
            ir_expression *const r1A9A = equal(swizzle_y(r1A74), swizzle_y(r1A73));
            ir_expression *const r1A9B = less(swizzle_x(r1A74), swizzle_x(r1A73));
            ir_expression *const r1A9C = logic_and(r1A9A, r1A9B);
            body.emit(assign(r1A92, logic_or(r1A99, r1A9C), 0x01));


         body.instructions = f1A93_parent_instructions;
         body.emit(f1A93);

         /* END IF */

         body.emit(assign(r1A75, r1A92, 0x01));


      body.instructions = f1A8A_parent_instructions;
      body.emit(f1A8A);

      /* END IF */


   body.instructions = f1A86_parent_instructions;
   body.emit(f1A86);

   /* END IF */

   body.emit(ret(r1A75));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtOddAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A9D = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r1A9D);
   ir_variable *const r1A9E = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r1A9E);
   body.emit(assign(r1A9E, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1AA0 = equal(r1A9D, body.constant(int(0)));
   ir_if *f1A9F = new(mem_ctx) ir_if(operand(r1AA0).val);
   exec_list *const f1A9F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A9F->then_instructions;

      body.emit(assign(r1A9E, body.constant(4u), 0x01));


   body.instructions = f1A9F_parent_instructions;
   body.emit(f1A9F);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA2 = equal(r1A9D, body.constant(int(1)));
   ir_if *f1AA1 = new(mem_ctx) ir_if(operand(r1AA2).val);
   exec_list *const f1AA1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA1->then_instructions;

      body.emit(assign(r1A9E, body.constant(34u), 0x01));


   body.instructions = f1AA1_parent_instructions;
   body.emit(f1AA1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA4 = equal(r1A9D, body.constant(int(2)));
   ir_if *f1AA3 = new(mem_ctx) ir_if(operand(r1AA4).val);
   exec_list *const f1AA3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA3->then_instructions;

      body.emit(assign(r1A9E, body.constant(93u), 0x01));


   body.instructions = f1AA3_parent_instructions;
   body.emit(f1AA3);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA6 = equal(r1A9D, body.constant(int(3)));
   ir_if *f1AA5 = new(mem_ctx) ir_if(operand(r1AA6).val);
   exec_list *const f1AA5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA5->then_instructions;

      body.emit(assign(r1A9E, body.constant(177u), 0x01));


   body.instructions = f1AA5_parent_instructions;
   body.emit(f1AA5);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA8 = equal(r1A9D, body.constant(int(4)));
   ir_if *f1AA7 = new(mem_ctx) ir_if(operand(r1AA8).val);
   exec_list *const f1AA7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA7->then_instructions;

      body.emit(assign(r1A9E, body.constant(285u), 0x01));


   body.instructions = f1AA7_parent_instructions;
   body.emit(f1AA7);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AAA = equal(r1A9D, body.constant(int(5)));
   ir_if *f1AA9 = new(mem_ctx) ir_if(operand(r1AAA).val);
   exec_list *const f1AA9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA9->then_instructions;

      body.emit(assign(r1A9E, body.constant(415u), 0x01));


   body.instructions = f1AA9_parent_instructions;
   body.emit(f1AA9);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AAC = equal(r1A9D, body.constant(int(6)));
   ir_if *f1AAB = new(mem_ctx) ir_if(operand(r1AAC).val);
   exec_list *const f1AAB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AAB->then_instructions;

      body.emit(assign(r1A9E, body.constant(566u), 0x01));


   body.instructions = f1AAB_parent_instructions;
   body.emit(f1AAB);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AAE = equal(r1A9D, body.constant(int(7)));
   ir_if *f1AAD = new(mem_ctx) ir_if(operand(r1AAE).val);
   exec_list *const f1AAD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AAD->then_instructions;

      body.emit(assign(r1A9E, body.constant(736u), 0x01));


   body.instructions = f1AAD_parent_instructions;
   body.emit(f1AAD);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB0 = equal(r1A9D, body.constant(int(8)));
   ir_if *f1AAF = new(mem_ctx) ir_if(operand(r1AB0).val);
   exec_list *const f1AAF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AAF->then_instructions;

      body.emit(assign(r1A9E, body.constant(924u), 0x01));


   body.instructions = f1AAF_parent_instructions;
   body.emit(f1AAF);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB2 = equal(r1A9D, body.constant(int(9)));
   ir_if *f1AB1 = new(mem_ctx) ir_if(operand(r1AB2).val);
   exec_list *const f1AB1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB1->then_instructions;

      body.emit(assign(r1A9E, body.constant(1128u), 0x01));


   body.instructions = f1AB1_parent_instructions;
   body.emit(f1AB1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB4 = equal(r1A9D, body.constant(int(10)));
   ir_if *f1AB3 = new(mem_ctx) ir_if(operand(r1AB4).val);
   exec_list *const f1AB3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB3->then_instructions;

      body.emit(assign(r1A9E, body.constant(1349u), 0x01));


   body.instructions = f1AB3_parent_instructions;
   body.emit(f1AB3);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB6 = equal(r1A9D, body.constant(int(11)));
   ir_if *f1AB5 = new(mem_ctx) ir_if(operand(r1AB6).val);
   exec_list *const f1AB5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB5->then_instructions;

      body.emit(assign(r1A9E, body.constant(1585u), 0x01));


   body.instructions = f1AB5_parent_instructions;
   body.emit(f1AB5);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB8 = equal(r1A9D, body.constant(int(12)));
   ir_if *f1AB7 = new(mem_ctx) ir_if(operand(r1AB8).val);
   exec_list *const f1AB7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB7->then_instructions;

      body.emit(assign(r1A9E, body.constant(1835u), 0x01));


   body.instructions = f1AB7_parent_instructions;
   body.emit(f1AB7);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ABA = equal(r1A9D, body.constant(int(13)));
   ir_if *f1AB9 = new(mem_ctx) ir_if(operand(r1ABA).val);
   exec_list *const f1AB9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB9->then_instructions;

      body.emit(assign(r1A9E, body.constant(2098u), 0x01));


   body.instructions = f1AB9_parent_instructions;
   body.emit(f1AB9);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ABC = equal(r1A9D, body.constant(int(14)));
   ir_if *f1ABB = new(mem_ctx) ir_if(operand(r1ABC).val);
   exec_list *const f1ABB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ABB->then_instructions;

      body.emit(assign(r1A9E, body.constant(2374u), 0x01));


   body.instructions = f1ABB_parent_instructions;
   body.emit(f1ABB);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ABE = equal(r1A9D, body.constant(int(15)));
   ir_if *f1ABD = new(mem_ctx) ir_if(operand(r1ABE).val);
   exec_list *const f1ABD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ABD->then_instructions;

      body.emit(assign(r1A9E, body.constant(2663u), 0x01));


   body.instructions = f1ABD_parent_instructions;
   body.emit(f1ABD);

   /* END IF */

   body.emit(ret(r1A9E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtEvenAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1ABF = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r1ABF);
   ir_variable *const r1AC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r1AC0);
   body.emit(assign(r1AC0, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1AC2 = equal(r1ABF, body.constant(int(0)));
   ir_if *f1AC1 = new(mem_ctx) ir_if(operand(r1AC2).val);
   exec_list *const f1AC1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC1->then_instructions;

      body.emit(assign(r1AC0, body.constant(2605u), 0x01));


   body.instructions = f1AC1_parent_instructions;
   body.emit(f1AC1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AC4 = equal(r1ABF, body.constant(int(1)));
   ir_if *f1AC3 = new(mem_ctx) ir_if(operand(r1AC4).val);
   exec_list *const f1AC3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC3->then_instructions;

      body.emit(assign(r1AC0, body.constant(2223u), 0x01));


   body.instructions = f1AC3_parent_instructions;
   body.emit(f1AC3);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AC6 = equal(r1ABF, body.constant(int(2)));
   ir_if *f1AC5 = new(mem_ctx) ir_if(operand(r1AC6).val);
   exec_list *const f1AC5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC5->then_instructions;

      body.emit(assign(r1AC0, body.constant(1882u), 0x01));


   body.instructions = f1AC5_parent_instructions;
   body.emit(f1AC5);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AC8 = equal(r1ABF, body.constant(int(3)));
   ir_if *f1AC7 = new(mem_ctx) ir_if(operand(r1AC8).val);
   exec_list *const f1AC7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC7->then_instructions;

      body.emit(assign(r1AC0, body.constant(1577u), 0x01));


   body.instructions = f1AC7_parent_instructions;
   body.emit(f1AC7);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ACA = equal(r1ABF, body.constant(int(4)));
   ir_if *f1AC9 = new(mem_ctx) ir_if(operand(r1ACA).val);
   exec_list *const f1AC9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC9->then_instructions;

      body.emit(assign(r1AC0, body.constant(1306u), 0x01));


   body.instructions = f1AC9_parent_instructions;
   body.emit(f1AC9);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ACC = equal(r1ABF, body.constant(int(5)));
   ir_if *f1ACB = new(mem_ctx) ir_if(operand(r1ACC).val);
   exec_list *const f1ACB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ACB->then_instructions;

      body.emit(assign(r1AC0, body.constant(1065u), 0x01));


   body.instructions = f1ACB_parent_instructions;
   body.emit(f1ACB);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ACE = equal(r1ABF, body.constant(int(6)));
   ir_if *f1ACD = new(mem_ctx) ir_if(operand(r1ACE).val);
   exec_list *const f1ACD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ACD->then_instructions;

      body.emit(assign(r1AC0, body.constant(854u), 0x01));


   body.instructions = f1ACD_parent_instructions;
   body.emit(f1ACD);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AD0 = equal(r1ABF, body.constant(int(7)));
   ir_if *f1ACF = new(mem_ctx) ir_if(operand(r1AD0).val);
   exec_list *const f1ACF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ACF->then_instructions;

      body.emit(assign(r1AC0, body.constant(670u), 0x01));


   body.instructions = f1ACF_parent_instructions;
   body.emit(f1ACF);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AD2 = equal(r1ABF, body.constant(int(8)));
   ir_if *f1AD1 = new(mem_ctx) ir_if(operand(r1AD2).val);
   exec_list *const f1AD1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD1->then_instructions;

      body.emit(assign(r1AC0, body.constant(512u), 0x01));


   body.instructions = f1AD1_parent_instructions;
   body.emit(f1AD1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AD4 = equal(r1ABF, body.constant(int(9)));
   ir_if *f1AD3 = new(mem_ctx) ir_if(operand(r1AD4).val);
   exec_list *const f1AD3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD3->then_instructions;

      body.emit(assign(r1AC0, body.constant(377u), 0x01));


   body.instructions = f1AD3_parent_instructions;
   body.emit(f1AD3);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AD6 = equal(r1ABF, body.constant(int(10)));
   ir_if *f1AD5 = new(mem_ctx) ir_if(operand(r1AD6).val);
   exec_list *const f1AD5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD5->then_instructions;

      body.emit(assign(r1AC0, body.constant(265u), 0x01));


   body.instructions = f1AD5_parent_instructions;
   body.emit(f1AD5);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AD8 = equal(r1ABF, body.constant(int(11)));
   ir_if *f1AD7 = new(mem_ctx) ir_if(operand(r1AD8).val);
   exec_list *const f1AD7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD7->then_instructions;

      body.emit(assign(r1AC0, body.constant(175u), 0x01));


   body.instructions = f1AD7_parent_instructions;
   body.emit(f1AD7);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ADA = equal(r1ABF, body.constant(int(12)));
   ir_if *f1AD9 = new(mem_ctx) ir_if(operand(r1ADA).val);
   exec_list *const f1AD9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD9->then_instructions;

      body.emit(assign(r1AC0, body.constant(104u), 0x01));


   body.instructions = f1AD9_parent_instructions;
   body.emit(f1AD9);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ADC = equal(r1ABF, body.constant(int(13)));
   ir_if *f1ADB = new(mem_ctx) ir_if(operand(r1ADC).val);
   exec_list *const f1ADB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ADB->then_instructions;

      body.emit(assign(r1AC0, body.constant(52u), 0x01));


   body.instructions = f1ADB_parent_instructions;
   body.emit(f1ADB);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ADE = equal(r1ABF, body.constant(int(14)));
   ir_if *f1ADD = new(mem_ctx) ir_if(operand(r1ADE).val);
   exec_list *const f1ADD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ADD->then_instructions;

      body.emit(assign(r1AC0, body.constant(18u), 0x01));


   body.instructions = f1ADD_parent_instructions;
   body.emit(f1ADD);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AE0 = equal(r1ABF, body.constant(int(15)));
   ir_if *f1ADF = new(mem_ctx) ir_if(operand(r1AE0).val);
   exec_list *const f1ADF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ADF->then_instructions;

      body.emit(assign(r1AC0, body.constant(2u), 0x01));


   body.instructions = f1ADF_parent_instructions;
   body.emit(f1ADF);

   /* END IF */

   body.emit(ret(r1AC0));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateSqrt32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1AE1 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_function_in);
   sig_parameters.push_tail(r1AE1);
   ir_variable *const r1AE2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1AE2);
   ir_variable *const r1AE3 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1AE3, body.constant(true), 0x01));

   ir_variable *const r1AE4 = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1AE5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r1AE5);
   ir_variable *const r1AE6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1AE7 = rshift(r1AE2, body.constant(int(27)));
   ir_expression *const r1AE8 = bit_and(r1AE7, body.constant(15u));
   body.emit(assign(r1AE6, expr(ir_unop_u2i, r1AE8), 0x01));

   /* IF CONDITION */
   ir_expression *const r1AEA = bit_and(r1AE1, body.constant(int(1)));
   ir_expression *const r1AEB = nequal(r1AEA, body.constant(int(0)));
   ir_if *f1AE9 = new(mem_ctx) ir_if(operand(r1AEB).val);
   exec_list *const f1AE9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AE9->then_instructions;

      ir_variable *const r1AEC = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r1AEC);
      body.emit(assign(r1AEC, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1AEE = equal(r1AE6, body.constant(int(0)));
      ir_if *f1AED = new(mem_ctx) ir_if(operand(r1AEE).val);
      exec_list *const f1AED_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AED->then_instructions;

         body.emit(assign(r1AEC, body.constant(4u), 0x01));


      body.instructions = f1AED_parent_instructions;
      body.emit(f1AED);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF0 = equal(r1AE6, body.constant(int(1)));
      ir_if *f1AEF = new(mem_ctx) ir_if(operand(r1AF0).val);
      exec_list *const f1AEF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AEF->then_instructions;

         body.emit(assign(r1AEC, body.constant(34u), 0x01));


      body.instructions = f1AEF_parent_instructions;
      body.emit(f1AEF);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF2 = equal(r1AE6, body.constant(int(2)));
      ir_if *f1AF1 = new(mem_ctx) ir_if(operand(r1AF2).val);
      exec_list *const f1AF1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF1->then_instructions;

         body.emit(assign(r1AEC, body.constant(93u), 0x01));


      body.instructions = f1AF1_parent_instructions;
      body.emit(f1AF1);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF4 = equal(r1AE6, body.constant(int(3)));
      ir_if *f1AF3 = new(mem_ctx) ir_if(operand(r1AF4).val);
      exec_list *const f1AF3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF3->then_instructions;

         body.emit(assign(r1AEC, body.constant(177u), 0x01));


      body.instructions = f1AF3_parent_instructions;
      body.emit(f1AF3);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF6 = equal(r1AE6, body.constant(int(4)));
      ir_if *f1AF5 = new(mem_ctx) ir_if(operand(r1AF6).val);
      exec_list *const f1AF5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF5->then_instructions;

         body.emit(assign(r1AEC, body.constant(285u), 0x01));


      body.instructions = f1AF5_parent_instructions;
      body.emit(f1AF5);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF8 = equal(r1AE6, body.constant(int(5)));
      ir_if *f1AF7 = new(mem_ctx) ir_if(operand(r1AF8).val);
      exec_list *const f1AF7_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF7->then_instructions;

         body.emit(assign(r1AEC, body.constant(415u), 0x01));


      body.instructions = f1AF7_parent_instructions;
      body.emit(f1AF7);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AFA = equal(r1AE6, body.constant(int(6)));
      ir_if *f1AF9 = new(mem_ctx) ir_if(operand(r1AFA).val);
      exec_list *const f1AF9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF9->then_instructions;

         body.emit(assign(r1AEC, body.constant(566u), 0x01));


      body.instructions = f1AF9_parent_instructions;
      body.emit(f1AF9);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AFC = equal(r1AE6, body.constant(int(7)));
      ir_if *f1AFB = new(mem_ctx) ir_if(operand(r1AFC).val);
      exec_list *const f1AFB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFB->then_instructions;

         body.emit(assign(r1AEC, body.constant(736u), 0x01));


      body.instructions = f1AFB_parent_instructions;
      body.emit(f1AFB);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AFE = equal(r1AE6, body.constant(int(8)));
      ir_if *f1AFD = new(mem_ctx) ir_if(operand(r1AFE).val);
      exec_list *const f1AFD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFD->then_instructions;

         body.emit(assign(r1AEC, body.constant(924u), 0x01));


      body.instructions = f1AFD_parent_instructions;
      body.emit(f1AFD);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B00 = equal(r1AE6, body.constant(int(9)));
      ir_if *f1AFF = new(mem_ctx) ir_if(operand(r1B00).val);
      exec_list *const f1AFF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFF->then_instructions;

         body.emit(assign(r1AEC, body.constant(1128u), 0x01));


      body.instructions = f1AFF_parent_instructions;
      body.emit(f1AFF);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B02 = equal(r1AE6, body.constant(int(10)));
      ir_if *f1B01 = new(mem_ctx) ir_if(operand(r1B02).val);
      exec_list *const f1B01_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B01->then_instructions;

         body.emit(assign(r1AEC, body.constant(1349u), 0x01));


      body.instructions = f1B01_parent_instructions;
      body.emit(f1B01);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B04 = equal(r1AE6, body.constant(int(11)));
      ir_if *f1B03 = new(mem_ctx) ir_if(operand(r1B04).val);
      exec_list *const f1B03_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B03->then_instructions;

         body.emit(assign(r1AEC, body.constant(1585u), 0x01));


      body.instructions = f1B03_parent_instructions;
      body.emit(f1B03);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B06 = equal(r1AE6, body.constant(int(12)));
      ir_if *f1B05 = new(mem_ctx) ir_if(operand(r1B06).val);
      exec_list *const f1B05_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B05->then_instructions;

         body.emit(assign(r1AEC, body.constant(1835u), 0x01));


      body.instructions = f1B05_parent_instructions;
      body.emit(f1B05);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B08 = equal(r1AE6, body.constant(int(13)));
      ir_if *f1B07 = new(mem_ctx) ir_if(operand(r1B08).val);
      exec_list *const f1B07_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B07->then_instructions;

         body.emit(assign(r1AEC, body.constant(2098u), 0x01));


      body.instructions = f1B07_parent_instructions;
      body.emit(f1B07);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B0A = equal(r1AE6, body.constant(int(14)));
      ir_if *f1B09 = new(mem_ctx) ir_if(operand(r1B0A).val);
      exec_list *const f1B09_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B09->then_instructions;

         body.emit(assign(r1AEC, body.constant(2374u), 0x01));


      body.instructions = f1B09_parent_instructions;
      body.emit(f1B09);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B0C = equal(r1AE6, body.constant(int(15)));
      ir_if *f1B0B = new(mem_ctx) ir_if(operand(r1B0C).val);
      exec_list *const f1B0B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B0B->then_instructions;

         body.emit(assign(r1AEC, body.constant(2663u), 0x01));


      body.instructions = f1B0B_parent_instructions;
      body.emit(f1B0B);

      /* END IF */

      ir_expression *const r1B0D = rshift(r1AE2, body.constant(int(17)));
      ir_expression *const r1B0E = add(body.constant(16384u), r1B0D);
      body.emit(assign(r1AE5, sub(r1B0E, r1AEC), 0x01));

      ir_expression *const r1B0F = expr(ir_binop_div, r1AE2, r1AE5);
      ir_expression *const r1B10 = lshift(r1B0F, body.constant(int(14)));
      ir_expression *const r1B11 = lshift(r1AE5, body.constant(int(15)));
      body.emit(assign(r1AE5, add(r1B10, r1B11), 0x01));

      body.emit(assign(r1AE2, rshift(r1AE2, body.constant(int(1))), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1AE9->else_instructions;

      ir_variable *const r1B12 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r1B12);
      body.emit(assign(r1B12, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1B14 = equal(r1AE6, body.constant(int(0)));
      ir_if *f1B13 = new(mem_ctx) ir_if(operand(r1B14).val);
      exec_list *const f1B13_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B13->then_instructions;

         body.emit(assign(r1B12, body.constant(2605u), 0x01));


      body.instructions = f1B13_parent_instructions;
      body.emit(f1B13);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B16 = equal(r1AE6, body.constant(int(1)));
      ir_if *f1B15 = new(mem_ctx) ir_if(operand(r1B16).val);
      exec_list *const f1B15_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B15->then_instructions;

         body.emit(assign(r1B12, body.constant(2223u), 0x01));


      body.instructions = f1B15_parent_instructions;
      body.emit(f1B15);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B18 = equal(r1AE6, body.constant(int(2)));
      ir_if *f1B17 = new(mem_ctx) ir_if(operand(r1B18).val);
      exec_list *const f1B17_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B17->then_instructions;

         body.emit(assign(r1B12, body.constant(1882u), 0x01));


      body.instructions = f1B17_parent_instructions;
      body.emit(f1B17);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B1A = equal(r1AE6, body.constant(int(3)));
      ir_if *f1B19 = new(mem_ctx) ir_if(operand(r1B1A).val);
      exec_list *const f1B19_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B19->then_instructions;

         body.emit(assign(r1B12, body.constant(1577u), 0x01));


      body.instructions = f1B19_parent_instructions;
      body.emit(f1B19);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B1C = equal(r1AE6, body.constant(int(4)));
      ir_if *f1B1B = new(mem_ctx) ir_if(operand(r1B1C).val);
      exec_list *const f1B1B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B1B->then_instructions;

         body.emit(assign(r1B12, body.constant(1306u), 0x01));


      body.instructions = f1B1B_parent_instructions;
      body.emit(f1B1B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B1E = equal(r1AE6, body.constant(int(5)));
      ir_if *f1B1D = new(mem_ctx) ir_if(operand(r1B1E).val);
      exec_list *const f1B1D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B1D->then_instructions;

         body.emit(assign(r1B12, body.constant(1065u), 0x01));


      body.instructions = f1B1D_parent_instructions;
      body.emit(f1B1D);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B20 = equal(r1AE6, body.constant(int(6)));
      ir_if *f1B1F = new(mem_ctx) ir_if(operand(r1B20).val);
      exec_list *const f1B1F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B1F->then_instructions;

         body.emit(assign(r1B12, body.constant(854u), 0x01));


      body.instructions = f1B1F_parent_instructions;
      body.emit(f1B1F);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B22 = equal(r1AE6, body.constant(int(7)));
      ir_if *f1B21 = new(mem_ctx) ir_if(operand(r1B22).val);
      exec_list *const f1B21_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B21->then_instructions;

         body.emit(assign(r1B12, body.constant(670u), 0x01));


      body.instructions = f1B21_parent_instructions;
      body.emit(f1B21);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B24 = equal(r1AE6, body.constant(int(8)));
      ir_if *f1B23 = new(mem_ctx) ir_if(operand(r1B24).val);
      exec_list *const f1B23_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B23->then_instructions;

         body.emit(assign(r1B12, body.constant(512u), 0x01));


      body.instructions = f1B23_parent_instructions;
      body.emit(f1B23);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B26 = equal(r1AE6, body.constant(int(9)));
      ir_if *f1B25 = new(mem_ctx) ir_if(operand(r1B26).val);
      exec_list *const f1B25_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B25->then_instructions;

         body.emit(assign(r1B12, body.constant(377u), 0x01));


      body.instructions = f1B25_parent_instructions;
      body.emit(f1B25);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B28 = equal(r1AE6, body.constant(int(10)));
      ir_if *f1B27 = new(mem_ctx) ir_if(operand(r1B28).val);
      exec_list *const f1B27_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B27->then_instructions;

         body.emit(assign(r1B12, body.constant(265u), 0x01));


      body.instructions = f1B27_parent_instructions;
      body.emit(f1B27);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B2A = equal(r1AE6, body.constant(int(11)));
      ir_if *f1B29 = new(mem_ctx) ir_if(operand(r1B2A).val);
      exec_list *const f1B29_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B29->then_instructions;

         body.emit(assign(r1B12, body.constant(175u), 0x01));


      body.instructions = f1B29_parent_instructions;
      body.emit(f1B29);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B2C = equal(r1AE6, body.constant(int(12)));
      ir_if *f1B2B = new(mem_ctx) ir_if(operand(r1B2C).val);
      exec_list *const f1B2B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B2B->then_instructions;

         body.emit(assign(r1B12, body.constant(104u), 0x01));


      body.instructions = f1B2B_parent_instructions;
      body.emit(f1B2B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B2E = equal(r1AE6, body.constant(int(13)));
      ir_if *f1B2D = new(mem_ctx) ir_if(operand(r1B2E).val);
      exec_list *const f1B2D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B2D->then_instructions;

         body.emit(assign(r1B12, body.constant(52u), 0x01));


      body.instructions = f1B2D_parent_instructions;
      body.emit(f1B2D);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B30 = equal(r1AE6, body.constant(int(14)));
      ir_if *f1B2F = new(mem_ctx) ir_if(operand(r1B30).val);
      exec_list *const f1B2F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B2F->then_instructions;

         body.emit(assign(r1B12, body.constant(18u), 0x01));


      body.instructions = f1B2F_parent_instructions;
      body.emit(f1B2F);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B32 = equal(r1AE6, body.constant(int(15)));
      ir_if *f1B31 = new(mem_ctx) ir_if(operand(r1B32).val);
      exec_list *const f1B31_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B31->then_instructions;

         body.emit(assign(r1B12, body.constant(2u), 0x01));


      body.instructions = f1B31_parent_instructions;
      body.emit(f1B31);

      /* END IF */

      ir_expression *const r1B33 = rshift(r1AE2, body.constant(int(17)));
      ir_expression *const r1B34 = add(body.constant(32768u), r1B33);
      body.emit(assign(r1AE5, sub(r1B34, r1B12), 0x01));

      ir_expression *const r1B35 = expr(ir_binop_div, r1AE2, r1AE5);
      body.emit(assign(r1AE5, add(r1B35, r1AE5), 0x01));

      ir_variable *const r1B36 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1B38 = lequal(body.constant(131072u), r1AE5);
      ir_if *f1B37 = new(mem_ctx) ir_if(operand(r1B38).val);
      exec_list *const f1B37_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B37->then_instructions;

         body.emit(assign(r1B36, body.constant(4294934528u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B37->else_instructions;

         body.emit(assign(r1B36, lshift(r1AE5, body.constant(int(15))), 0x01));


      body.instructions = f1B37_parent_instructions;
      body.emit(f1B37);

      /* END IF */

      body.emit(assign(r1AE5, r1B36, 0x01));

      /* IF CONDITION */
      ir_expression *const r1B3A = lequal(r1B36, r1AE2);
      ir_if *f1B39 = new(mem_ctx) ir_if(operand(r1B3A).val);
      exec_list *const f1B39_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B39->then_instructions;

         ir_expression *const r1B3B = expr(ir_unop_u2i, r1AE2);
         ir_expression *const r1B3C = rshift(r1B3B, body.constant(int(1)));
         body.emit(assign(r1AE4, expr(ir_unop_i2u, r1B3C), 0x01));

         body.emit(assign(r1AE3, body.constant(false), 0x01));


      body.instructions = f1B39_parent_instructions;
      body.emit(f1B39);

      /* END IF */


   body.instructions = f1AE9_parent_instructions;
   body.emit(f1AE9);

   /* END IF */

   /* IF CONDITION */
   ir_if *f1B3D = new(mem_ctx) ir_if(operand(r1AE3).val);
   exec_list *const f1B3D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1B3D->then_instructions;

      ir_variable *const r1B3E = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r1B3F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
      body.emit(r1B3F);
      ir_variable *const r1B40 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
      body.emit(r1B40);
      ir_variable *const r1B41 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
      body.emit(r1B41);
      ir_variable *const r1B42 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
      body.emit(r1B42);
      body.emit(assign(r1B41, body.constant(0u), 0x01));

      body.emit(assign(r1B40, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1B44 = lequal(r1AE5, r1AE2);
      ir_if *f1B43 = new(mem_ctx) ir_if(operand(r1B44).val);
      exec_list *const f1B43_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B43->then_instructions;

         body.emit(assign(r1B3E, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B43->else_instructions;

         body.emit(assign(r1B42, rshift(r1AE5, body.constant(int(16))), 0x01));

         ir_variable *const r1B45 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1B47 = lshift(r1B42, body.constant(int(16)));
         ir_expression *const r1B48 = lequal(r1B47, r1AE2);
         ir_if *f1B46 = new(mem_ctx) ir_if(operand(r1B48).val);
         exec_list *const f1B46_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B46->then_instructions;

            body.emit(assign(r1B45, body.constant(4294901760u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B46->else_instructions;

            ir_expression *const r1B49 = expr(ir_binop_div, r1AE2, r1B42);
            body.emit(assign(r1B45, lshift(r1B49, body.constant(int(16))), 0x01));


         body.instructions = f1B46_parent_instructions;
         body.emit(f1B46);

         /* END IF */

         body.emit(assign(r1B3F, r1B45, 0x01));

         ir_variable *const r1B4A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1B4A);
         ir_variable *const r1B4B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
         body.emit(r1B4B);
         ir_variable *const r1B4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r1B4C);
         ir_variable *const r1B4D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B4D, bit_and(r1AE5, body.constant(65535u)), 0x01));

         ir_variable *const r1B4E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B4E, rshift(r1AE5, body.constant(int(16))), 0x01));

         ir_variable *const r1B4F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B4F, bit_and(r1B45, body.constant(65535u)), 0x01));

         ir_variable *const r1B50 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B50, rshift(r1B45, body.constant(int(16))), 0x01));

         ir_variable *const r1B51 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B51, mul(r1B4E, r1B4F), 0x01));

         ir_expression *const r1B52 = mul(r1B4D, r1B50);
         body.emit(assign(r1B4B, add(r1B52, r1B51), 0x01));

         ir_expression *const r1B53 = mul(r1B4E, r1B50);
         ir_expression *const r1B54 = less(r1B4B, r1B51);
         ir_expression *const r1B55 = expr(ir_unop_b2i, r1B54);
         ir_expression *const r1B56 = expr(ir_unop_i2u, r1B55);
         ir_expression *const r1B57 = lshift(r1B56, body.constant(int(16)));
         ir_expression *const r1B58 = rshift(r1B4B, body.constant(int(16)));
         ir_expression *const r1B59 = add(r1B57, r1B58);
         body.emit(assign(r1B4A, add(r1B53, r1B59), 0x01));

         body.emit(assign(r1B4B, lshift(r1B4B, body.constant(int(16))), 0x01));

         ir_expression *const r1B5A = mul(r1B4D, r1B4F);
         body.emit(assign(r1B4C, add(r1B5A, r1B4B), 0x01));

         ir_expression *const r1B5B = less(r1B4C, r1B4B);
         ir_expression *const r1B5C = expr(ir_unop_b2i, r1B5B);
         ir_expression *const r1B5D = expr(ir_unop_i2u, r1B5C);
         body.emit(assign(r1B4A, add(r1B4A, r1B5D), 0x01));

         ir_expression *const r1B5E = sub(r1AE2, r1B4A);
         ir_expression *const r1B5F = less(body.constant(0u), r1B4C);
         ir_expression *const r1B60 = expr(ir_unop_b2i, r1B5F);
         ir_expression *const r1B61 = expr(ir_unop_i2u, r1B60);
         body.emit(assign(r1B41, sub(r1B5E, r1B61), 0x01));

         body.emit(assign(r1B40, neg(r1B4C), 0x01));

         /* LOOP BEGIN */
         ir_loop *f1B62 = new(mem_ctx) ir_loop();
         exec_list *const f1B62_parent_instructions = body.instructions;

            body.instructions = &f1B62->body_instructions;

            /* IF CONDITION */
            ir_expression *const r1B64 = expr(ir_unop_u2i, r1B41);
            ir_expression *const r1B65 = gequal(r1B64, body.constant(int(0)));
            ir_if *f1B63 = new(mem_ctx) ir_if(operand(r1B65).val);
            exec_list *const f1B63_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1B63->then_instructions;

               body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


            body.instructions = f1B63_parent_instructions;
            body.emit(f1B63);

            /* END IF */

            body.emit(assign(r1B3F, add(r1B3F, body.constant(4294901760u)), 0x01));

            ir_variable *const r1B66 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            ir_expression *const r1B67 = lshift(r1AE5, body.constant(int(16)));
            body.emit(assign(r1B66, add(r1B40, r1B67), 0x01));

            ir_expression *const r1B68 = add(r1B41, r1B42);
            ir_expression *const r1B69 = less(r1B66, r1B40);
            ir_expression *const r1B6A = expr(ir_unop_b2i, r1B69);
            ir_expression *const r1B6B = expr(ir_unop_i2u, r1B6A);
            body.emit(assign(r1B41, add(r1B68, r1B6B), 0x01));

            body.emit(assign(r1B40, r1B66, 0x01));

         /* LOOP END */

         body.instructions = f1B62_parent_instructions;
         body.emit(f1B62);

         ir_expression *const r1B6C = lshift(r1B41, body.constant(int(16)));
         ir_expression *const r1B6D = rshift(r1B40, body.constant(int(16)));
         body.emit(assign(r1B41, bit_or(r1B6C, r1B6D), 0x01));

         ir_variable *const r1B6E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1B70 = lshift(r1B42, body.constant(int(16)));
         ir_expression *const r1B71 = lequal(r1B70, r1B41);
         ir_if *f1B6F = new(mem_ctx) ir_if(operand(r1B71).val);
         exec_list *const f1B6F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B6F->then_instructions;

            body.emit(assign(r1B6E, body.constant(65535u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B6F->else_instructions;

            body.emit(assign(r1B6E, expr(ir_binop_div, r1B41, r1B42), 0x01));


         body.instructions = f1B6F_parent_instructions;
         body.emit(f1B6F);

         /* END IF */

         body.emit(assign(r1B3F, bit_or(r1B3F, r1B6E), 0x01));

         body.emit(assign(r1B3E, r1B3F, 0x01));


      body.instructions = f1B43_parent_instructions;
      body.emit(f1B43);

      /* END IF */

      ir_expression *const r1B72 = rshift(r1B3E, body.constant(int(1)));
      ir_expression *const r1B73 = rshift(r1AE5, body.constant(int(1)));
      body.emit(assign(r1AE4, add(r1B72, r1B73), 0x01));

      body.emit(assign(r1AE3, body.constant(false), 0x01));


   body.instructions = f1B3D_parent_instructions;
   body.emit(f1B3D);

   /* END IF */

   body.emit(ret(r1AE4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsqrt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1B74 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1B74);
   ir_variable *const r1B75 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1B75, body.constant(true), 0x01));

   ir_variable *const r1B76 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1B77 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r1B77);
   ir_variable *const r1B78 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r1B78);
   ir_variable *const r1B79 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r1B79);
   ir_variable *const r1B7A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "default_nan", ir_var_auto);
   body.emit(r1B7A);
   ir_variable *const r1B7B = new(mem_ctx) ir_variable(glsl_type::uint_type, "term3", ir_var_auto);
   body.emit(r1B7B);
   ir_variable *const r1B7C = new(mem_ctx) ir_variable(glsl_type::uint_type, "term2", ir_var_auto);
   body.emit(r1B7C);
   ir_variable *const r1B7D = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r1B7D);
   ir_variable *const r1B7E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r1B7E);
   ir_variable *const r1B7F = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r1B7F);
   ir_variable *const r1B80 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r1B80);
   ir_variable *const r1B81 = new(mem_ctx) ir_variable(glsl_type::uint_type, "doubleZFrac0", ir_var_auto);
   body.emit(r1B81);
   ir_variable *const r1B82 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1B82);
   ir_variable *const r1B83 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1B83);
   body.emit(assign(r1B83, body.constant(0u), 0x01));

   body.emit(assign(r1B82, body.constant(0u), 0x01));

   body.emit(assign(r1B81, body.constant(0u), 0x01));

   body.emit(assign(r1B80, body.constant(0u), 0x01));

   body.emit(assign(r1B7F, body.constant(0u), 0x01));

   body.emit(assign(r1B7E, body.constant(0u), 0x01));

   body.emit(assign(r1B7D, body.constant(0u), 0x01));

   body.emit(assign(r1B7C, body.constant(0u), 0x01));

   body.emit(assign(r1B7B, body.constant(0u), 0x01));

   body.emit(assign(r1B7A, body.constant(4294967295u), 0x02));

   body.emit(assign(r1B7A, body.constant(4294967295u), 0x01));

   ir_variable *const r1B84 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1B84);
   body.emit(assign(r1B84, bit_and(swizzle_y(r1B74), body.constant(1048575u)), 0x02));

   body.emit(assign(r1B84, swizzle_x(r1B74), 0x01));

   body.emit(assign(r1B79, r1B84, 0x03));

   ir_variable *const r1B85 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1B86 = rshift(swizzle_y(r1B74), body.constant(int(20)));
   ir_expression *const r1B87 = bit_and(r1B86, body.constant(2047u));
   body.emit(assign(r1B85, expr(ir_unop_u2i, r1B87), 0x01));

   body.emit(assign(r1B78, r1B85, 0x01));

   ir_variable *const r1B88 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r1B88, rshift(swizzle_y(r1B74), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1B8A = equal(r1B85, body.constant(int(2047)));
   ir_if *f1B89 = new(mem_ctx) ir_if(operand(r1B8A).val);
   exec_list *const f1B89_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1B89->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1B8C = bit_or(swizzle_y(r1B84), swizzle_x(r1B74));
      ir_expression *const r1B8D = nequal(r1B8C, body.constant(0u));
      ir_if *f1B8B = new(mem_ctx) ir_if(operand(r1B8D).val);
      exec_list *const f1B8B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B8B->then_instructions;

         ir_variable *const r1B8E = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r1B8E, swizzle_x(r1B74), 0x01));

         ir_variable *const r1B8F = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r1B8F, swizzle_x(r1B74), 0x01));

         ir_variable *const r1B90 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r1B91 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r1B92 = rshift(swizzle_y(r1B74), body.constant(int(19)));
         ir_expression *const r1B93 = bit_and(r1B92, body.constant(4095u));
         ir_expression *const r1B94 = equal(r1B93, body.constant(4094u));
         ir_expression *const r1B95 = nequal(swizzle_x(r1B74), body.constant(0u));
         ir_expression *const r1B96 = bit_and(swizzle_y(r1B74), body.constant(524287u));
         ir_expression *const r1B97 = nequal(r1B96, body.constant(0u));
         ir_expression *const r1B98 = logic_or(r1B95, r1B97);
         body.emit(assign(r1B91, logic_and(r1B94, r1B98), 0x01));

         ir_variable *const r1B99 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r1B9A = lshift(swizzle_y(r1B74), body.constant(int(1)));
         ir_expression *const r1B9B = lequal(body.constant(4292870144u), r1B9A);
         ir_expression *const r1B9C = nequal(swizzle_x(r1B74), body.constant(0u));
         ir_expression *const r1B9D = bit_and(swizzle_y(r1B74), body.constant(1048575u));
         ir_expression *const r1B9E = nequal(r1B9D, body.constant(0u));
         ir_expression *const r1B9F = logic_or(r1B9C, r1B9E);
         body.emit(assign(r1B99, logic_and(r1B9B, r1B9F), 0x01));

         body.emit(assign(r1B8E, bit_or(swizzle_y(r1B74), body.constant(524288u)), 0x02));

         body.emit(assign(r1B8F, bit_or(swizzle_y(r1B74), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r1BA1 = lshift(swizzle_y(r1B74), body.constant(int(1)));
         ir_expression *const r1BA2 = lequal(body.constant(4292870144u), r1BA1);
         ir_expression *const r1BA3 = nequal(swizzle_x(r1B74), body.constant(0u));
         ir_expression *const r1BA4 = bit_and(swizzle_y(r1B74), body.constant(1048575u));
         ir_expression *const r1BA5 = nequal(r1BA4, body.constant(0u));
         ir_expression *const r1BA6 = logic_or(r1BA3, r1BA5);
         ir_expression *const r1BA7 = logic_and(r1BA2, r1BA6);
         ir_if *f1BA0 = new(mem_ctx) ir_if(operand(r1BA7).val);
         exec_list *const f1BA0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BA0->then_instructions;

            ir_variable *const r1BA8 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1BAA = logic_and(r1B91, r1B99);
            ir_if *f1BA9 = new(mem_ctx) ir_if(operand(r1BAA).val);
            exec_list *const f1BA9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1BA9->then_instructions;

               body.emit(assign(r1BA8, r1B8F, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1BA9->else_instructions;

               body.emit(assign(r1BA8, r1B8E, 0x03));


            body.instructions = f1BA9_parent_instructions;
            body.emit(f1BA9);

            /* END IF */

            body.emit(assign(r1B90, r1BA8, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1BA0->else_instructions;

            body.emit(assign(r1B90, r1B8F, 0x03));


         body.instructions = f1BA0_parent_instructions;
         body.emit(f1BA0);

         /* END IF */

         body.emit(assign(r1B76, r1B90, 0x03));

         body.emit(assign(r1B75, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B8B->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1BAC = equal(r1B88, body.constant(0u));
         ir_if *f1BAB = new(mem_ctx) ir_if(operand(r1BAC).val);
         exec_list *const f1BAB_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BAB->then_instructions;

            body.emit(assign(r1B76, r1B74, 0x03));

            body.emit(assign(r1B75, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1BAB->else_instructions;

            body.emit(assign(r1B76, r1B7A, 0x03));

            body.emit(assign(r1B75, body.constant(false), 0x01));


         body.instructions = f1BAB_parent_instructions;
         body.emit(f1BAB);

         /* END IF */


      body.instructions = f1B8B_parent_instructions;
      body.emit(f1B8B);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1B89->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1BAE = nequal(r1B88, body.constant(0u));
      ir_if *f1BAD = new(mem_ctx) ir_if(operand(r1BAE).val);
      exec_list *const f1BAD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BAD->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1BB0 = expr(ir_unop_i2u, r1B85);
         ir_expression *const r1BB1 = bit_or(r1BB0, swizzle_y(r1B84));
         ir_expression *const r1BB2 = bit_or(r1BB1, swizzle_x(r1B74));
         ir_expression *const r1BB3 = equal(r1BB2, body.constant(0u));
         ir_if *f1BAF = new(mem_ctx) ir_if(operand(r1BB3).val);
         exec_list *const f1BAF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BAF->then_instructions;

            body.emit(assign(r1B76, r1B74, 0x03));

            body.emit(assign(r1B75, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1BAF->else_instructions;

            body.emit(assign(r1B76, r1B7A, 0x03));

            body.emit(assign(r1B75, body.constant(false), 0x01));


         body.instructions = f1BAF_parent_instructions;
         body.emit(f1BAF);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1BAD->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1BB5 = equal(r1B85, body.constant(int(0)));
         ir_if *f1BB4 = new(mem_ctx) ir_if(operand(r1BB5).val);
         exec_list *const f1BB4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BB4->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1BB7 = bit_or(swizzle_y(r1B84), swizzle_x(r1B74));
            ir_expression *const r1BB8 = equal(r1BB7, body.constant(0u));
            ir_if *f1BB6 = new(mem_ctx) ir_if(operand(r1BB8).val);
            exec_list *const f1BB6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1BB6->then_instructions;

               ir_variable *const r1BB9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1BB9);
               body.emit(assign(r1BB9, body.constant(0u), 0x02));

               body.emit(assign(r1BB9, body.constant(0u), 0x01));

               body.emit(assign(r1B76, r1BB9, 0x03));

               body.emit(assign(r1B75, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1BB6->else_instructions;

               ir_variable *const r1BBA = body.make_temp(glsl_type::uint_type, "aFrac0");
               body.emit(assign(r1BBA, swizzle_y(r1B84), 0x01));

               ir_variable *const r1BBB = body.make_temp(glsl_type::uint_type, "aFrac1");
               body.emit(assign(r1BBB, swizzle_x(r1B84), 0x01));

               ir_variable *const r1BBC = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r1BBC, r1B85, 0x01));

               ir_variable *const r1BBD = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r1BBD, swizzle_y(r1B84), 0x01));

               ir_variable *const r1BBE = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r1BBE, swizzle_x(r1B84), 0x01));

               ir_variable *const r1BBF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1BBF);
               /* IF CONDITION */
               ir_expression *const r1BC1 = equal(swizzle_y(r1B84), body.constant(0u));
               ir_if *f1BC0 = new(mem_ctx) ir_if(operand(r1BC1).val);
               exec_list *const f1BC0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BC0->then_instructions;

                  ir_variable *const r1BC2 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r1BC2, r1BBB, 0x01));

                  ir_variable *const r1BC3 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1BC4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1BC4);
                  /* IF CONDITION */
                  ir_expression *const r1BC6 = equal(swizzle_x(r1B74), body.constant(0u));
                  ir_if *f1BC5 = new(mem_ctx) ir_if(operand(r1BC6).val);
                  exec_list *const f1BC5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BC5->then_instructions;

                     body.emit(assign(r1BC3, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1BC5->else_instructions;

                     body.emit(assign(r1BC4, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1BC8 = bit_and(swizzle_x(r1B74), body.constant(4294901760u));
                     ir_expression *const r1BC9 = equal(r1BC8, body.constant(0u));
                     ir_if *f1BC7 = new(mem_ctx) ir_if(operand(r1BC9).val);
                     exec_list *const f1BC7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BC7->then_instructions;

                        body.emit(assign(r1BC4, body.constant(int(16)), 0x01));

                        body.emit(assign(r1BC2, lshift(swizzle_x(r1B74), body.constant(int(16))), 0x01));


                     body.instructions = f1BC7_parent_instructions;
                     body.emit(f1BC7);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BCB = bit_and(r1BC2, body.constant(4278190080u));
                     ir_expression *const r1BCC = equal(r1BCB, body.constant(0u));
                     ir_if *f1BCA = new(mem_ctx) ir_if(operand(r1BCC).val);
                     exec_list *const f1BCA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BCA->then_instructions;

                        body.emit(assign(r1BC4, add(r1BC4, body.constant(int(8))), 0x01));

                        body.emit(assign(r1BC2, lshift(r1BC2, body.constant(int(8))), 0x01));


                     body.instructions = f1BCA_parent_instructions;
                     body.emit(f1BCA);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BCE = bit_and(r1BC2, body.constant(4026531840u));
                     ir_expression *const r1BCF = equal(r1BCE, body.constant(0u));
                     ir_if *f1BCD = new(mem_ctx) ir_if(operand(r1BCF).val);
                     exec_list *const f1BCD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BCD->then_instructions;

                        body.emit(assign(r1BC4, add(r1BC4, body.constant(int(4))), 0x01));

                        body.emit(assign(r1BC2, lshift(r1BC2, body.constant(int(4))), 0x01));


                     body.instructions = f1BCD_parent_instructions;
                     body.emit(f1BCD);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BD1 = bit_and(r1BC2, body.constant(3221225472u));
                     ir_expression *const r1BD2 = equal(r1BD1, body.constant(0u));
                     ir_if *f1BD0 = new(mem_ctx) ir_if(operand(r1BD2).val);
                     exec_list *const f1BD0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BD0->then_instructions;

                        body.emit(assign(r1BC4, add(r1BC4, body.constant(int(2))), 0x01));

                        body.emit(assign(r1BC2, lshift(r1BC2, body.constant(int(2))), 0x01));


                     body.instructions = f1BD0_parent_instructions;
                     body.emit(f1BD0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BD4 = bit_and(r1BC2, body.constant(2147483648u));
                     ir_expression *const r1BD5 = equal(r1BD4, body.constant(0u));
                     ir_if *f1BD3 = new(mem_ctx) ir_if(operand(r1BD5).val);
                     exec_list *const f1BD3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BD3->then_instructions;

                        body.emit(assign(r1BC4, add(r1BC4, body.constant(int(1))), 0x01));


                     body.instructions = f1BD3_parent_instructions;
                     body.emit(f1BD3);

                     /* END IF */

                     body.emit(assign(r1BC3, r1BC4, 0x01));


                  body.instructions = f1BC5_parent_instructions;
                  body.emit(f1BC5);

                  /* END IF */

                  body.emit(assign(r1BBF, add(r1BC3, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1BD7 = less(r1BBF, body.constant(int(0)));
                  ir_if *f1BD6 = new(mem_ctx) ir_if(operand(r1BD7).val);
                  exec_list *const f1BD6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BD6->then_instructions;

                     ir_expression *const r1BD8 = neg(r1BBF);
                     body.emit(assign(r1BBD, rshift(swizzle_x(r1B74), r1BD8), 0x01));

                     ir_expression *const r1BD9 = bit_and(r1BBF, body.constant(int(31)));
                     body.emit(assign(r1BBE, lshift(swizzle_x(r1B74), r1BD9), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1BD6->else_instructions;

                     body.emit(assign(r1BBD, lshift(swizzle_x(r1B74), r1BBF), 0x01));

                     body.emit(assign(r1BBE, body.constant(0u), 0x01));


                  body.instructions = f1BD6_parent_instructions;
                  body.emit(f1BD6);

                  /* END IF */

                  body.emit(assign(r1BBC, sub(body.constant(int(-31)), r1BBF), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1BC0->else_instructions;

                  ir_variable *const r1BDA = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r1BDA, r1BBA, 0x01));

                  ir_variable *const r1BDB = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1BDC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1BDC);
                  /* IF CONDITION */
                  ir_expression *const r1BDE = equal(swizzle_y(r1B84), body.constant(0u));
                  ir_if *f1BDD = new(mem_ctx) ir_if(operand(r1BDE).val);
                  exec_list *const f1BDD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BDD->then_instructions;

                     body.emit(assign(r1BDB, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1BDD->else_instructions;

                     body.emit(assign(r1BDC, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1BE0 = bit_and(swizzle_y(r1B84), body.constant(4294901760u));
                     ir_expression *const r1BE1 = equal(r1BE0, body.constant(0u));
                     ir_if *f1BDF = new(mem_ctx) ir_if(operand(r1BE1).val);
                     exec_list *const f1BDF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BDF->then_instructions;

                        body.emit(assign(r1BDC, body.constant(int(16)), 0x01));

                        body.emit(assign(r1BDA, lshift(swizzle_y(r1B84), body.constant(int(16))), 0x01));


                     body.instructions = f1BDF_parent_instructions;
                     body.emit(f1BDF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BE3 = bit_and(r1BDA, body.constant(4278190080u));
                     ir_expression *const r1BE4 = equal(r1BE3, body.constant(0u));
                     ir_if *f1BE2 = new(mem_ctx) ir_if(operand(r1BE4).val);
                     exec_list *const f1BE2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BE2->then_instructions;

                        body.emit(assign(r1BDC, add(r1BDC, body.constant(int(8))), 0x01));

                        body.emit(assign(r1BDA, lshift(r1BDA, body.constant(int(8))), 0x01));


                     body.instructions = f1BE2_parent_instructions;
                     body.emit(f1BE2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BE6 = bit_and(r1BDA, body.constant(4026531840u));
                     ir_expression *const r1BE7 = equal(r1BE6, body.constant(0u));
                     ir_if *f1BE5 = new(mem_ctx) ir_if(operand(r1BE7).val);
                     exec_list *const f1BE5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BE5->then_instructions;

                        body.emit(assign(r1BDC, add(r1BDC, body.constant(int(4))), 0x01));

                        body.emit(assign(r1BDA, lshift(r1BDA, body.constant(int(4))), 0x01));


                     body.instructions = f1BE5_parent_instructions;
                     body.emit(f1BE5);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BE9 = bit_and(r1BDA, body.constant(3221225472u));
                     ir_expression *const r1BEA = equal(r1BE9, body.constant(0u));
                     ir_if *f1BE8 = new(mem_ctx) ir_if(operand(r1BEA).val);
                     exec_list *const f1BE8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BE8->then_instructions;

                        body.emit(assign(r1BDC, add(r1BDC, body.constant(int(2))), 0x01));

                        body.emit(assign(r1BDA, lshift(r1BDA, body.constant(int(2))), 0x01));


                     body.instructions = f1BE8_parent_instructions;
                     body.emit(f1BE8);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BEC = bit_and(r1BDA, body.constant(2147483648u));
                     ir_expression *const r1BED = equal(r1BEC, body.constant(0u));
                     ir_if *f1BEB = new(mem_ctx) ir_if(operand(r1BED).val);
                     exec_list *const f1BEB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BEB->then_instructions;

                        body.emit(assign(r1BDC, add(r1BDC, body.constant(int(1))), 0x01));


                     body.instructions = f1BEB_parent_instructions;
                     body.emit(f1BEB);

                     /* END IF */

                     body.emit(assign(r1BDB, r1BDC, 0x01));


                  body.instructions = f1BDD_parent_instructions;
                  body.emit(f1BDD);

                  /* END IF */

                  body.emit(assign(r1BBF, add(r1BDB, body.constant(int(-11))), 0x01));

                  ir_variable *const r1BEE = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1BEE, lshift(swizzle_x(r1B74), r1BBF), 0x01));

                  ir_variable *const r1BEF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1BF1 = equal(r1BBF, body.constant(int(0)));
                  ir_if *f1BF0 = new(mem_ctx) ir_if(operand(r1BF1).val);
                  exec_list *const f1BF0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BF0->then_instructions;

                     body.emit(assign(r1BEF, r1BBA, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1BF0->else_instructions;

                     ir_expression *const r1BF2 = lshift(swizzle_y(r1B84), r1BBF);
                     ir_expression *const r1BF3 = neg(r1BBF);
                     ir_expression *const r1BF4 = bit_and(r1BF3, body.constant(int(31)));
                     ir_expression *const r1BF5 = rshift(swizzle_x(r1B74), r1BF4);
                     body.emit(assign(r1BEF, bit_or(r1BF2, r1BF5), 0x01));


                  body.instructions = f1BF0_parent_instructions;
                  body.emit(f1BF0);

                  /* END IF */

                  body.emit(assign(r1BBD, r1BEF, 0x01));

                  body.emit(assign(r1BBE, r1BEE, 0x01));

                  body.emit(assign(r1BBC, sub(body.constant(int(1)), r1BBF), 0x01));


               body.instructions = f1BC0_parent_instructions;
               body.emit(f1BC0);

               /* END IF */

               body.emit(assign(r1B78, r1BBC, 0x01));

               body.emit(assign(r1B79, r1BBD, 0x02));

               body.emit(assign(r1B79, r1BBE, 0x01));


            body.instructions = f1BB6_parent_instructions;
            body.emit(f1BB6);

            /* END IF */


         body.instructions = f1BB4_parent_instructions;
         body.emit(f1BB4);

         /* END IF */

         /* IF CONDITION */
         ir_if *f1BF6 = new(mem_ctx) ir_if(operand(r1B75).val);
         exec_list *const f1BF6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BF6->then_instructions;

            ir_expression *const r1BF7 = add(r1B78, body.constant(int(-1023)));
            ir_expression *const r1BF8 = rshift(r1BF7, body.constant(int(1)));
            body.emit(assign(r1B77, add(r1BF8, body.constant(int(1022))), 0x01));

            body.emit(assign(r1B79, bit_or(swizzle_y(r1B79), body.constant(1048576u)), 0x02));

            ir_variable *const r1BF9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r1BF9, lshift(swizzle_x(r1B79), body.constant(int(11))), 0x01));

            ir_variable *const r1BFA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            ir_expression *const r1BFB = lshift(swizzle_y(r1B79), body.constant(int(11)));
            ir_expression *const r1BFC = rshift(swizzle_x(r1B79), body.constant(int(21)));
            body.emit(assign(r1BFA, bit_or(r1BFB, r1BFC), 0x01));

            ir_variable *const r1BFD = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r1BFD, r1BFA, 0x01));

            ir_variable *const r1BFE = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r1BFE, body.constant(true), 0x01));

            ir_variable *const r1BFF = body.make_temp(glsl_type::uint_type, "return_value");
            ir_variable *const r1C00 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
            body.emit(r1C00);
            ir_variable *const r1C01 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r1C02 = rshift(r1BFA, body.constant(int(27)));
            ir_expression *const r1C03 = bit_and(r1C02, body.constant(15u));
            body.emit(assign(r1C01, expr(ir_unop_u2i, r1C03), 0x01));

            /* IF CONDITION */
            ir_expression *const r1C05 = bit_and(r1B78, body.constant(int(1)));
            ir_expression *const r1C06 = nequal(r1C05, body.constant(int(0)));
            ir_if *f1C04 = new(mem_ctx) ir_if(operand(r1C06).val);
            exec_list *const f1C04_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C04->then_instructions;

               ir_variable *const r1C07 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
               body.emit(r1C07);
               body.emit(assign(r1C07, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r1C09 = equal(r1C01, body.constant(int(0)));
               ir_if *f1C08 = new(mem_ctx) ir_if(operand(r1C09).val);
               exec_list *const f1C08_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C08->then_instructions;

                  body.emit(assign(r1C07, body.constant(4u), 0x01));


               body.instructions = f1C08_parent_instructions;
               body.emit(f1C08);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C0B = equal(r1C01, body.constant(int(1)));
               ir_if *f1C0A = new(mem_ctx) ir_if(operand(r1C0B).val);
               exec_list *const f1C0A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C0A->then_instructions;

                  body.emit(assign(r1C07, body.constant(34u), 0x01));


               body.instructions = f1C0A_parent_instructions;
               body.emit(f1C0A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C0D = equal(r1C01, body.constant(int(2)));
               ir_if *f1C0C = new(mem_ctx) ir_if(operand(r1C0D).val);
               exec_list *const f1C0C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C0C->then_instructions;

                  body.emit(assign(r1C07, body.constant(93u), 0x01));


               body.instructions = f1C0C_parent_instructions;
               body.emit(f1C0C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C0F = equal(r1C01, body.constant(int(3)));
               ir_if *f1C0E = new(mem_ctx) ir_if(operand(r1C0F).val);
               exec_list *const f1C0E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C0E->then_instructions;

                  body.emit(assign(r1C07, body.constant(177u), 0x01));


               body.instructions = f1C0E_parent_instructions;
               body.emit(f1C0E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C11 = equal(r1C01, body.constant(int(4)));
               ir_if *f1C10 = new(mem_ctx) ir_if(operand(r1C11).val);
               exec_list *const f1C10_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C10->then_instructions;

                  body.emit(assign(r1C07, body.constant(285u), 0x01));


               body.instructions = f1C10_parent_instructions;
               body.emit(f1C10);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C13 = equal(r1C01, body.constant(int(5)));
               ir_if *f1C12 = new(mem_ctx) ir_if(operand(r1C13).val);
               exec_list *const f1C12_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C12->then_instructions;

                  body.emit(assign(r1C07, body.constant(415u), 0x01));


               body.instructions = f1C12_parent_instructions;
               body.emit(f1C12);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C15 = equal(r1C01, body.constant(int(6)));
               ir_if *f1C14 = new(mem_ctx) ir_if(operand(r1C15).val);
               exec_list *const f1C14_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C14->then_instructions;

                  body.emit(assign(r1C07, body.constant(566u), 0x01));


               body.instructions = f1C14_parent_instructions;
               body.emit(f1C14);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C17 = equal(r1C01, body.constant(int(7)));
               ir_if *f1C16 = new(mem_ctx) ir_if(operand(r1C17).val);
               exec_list *const f1C16_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C16->then_instructions;

                  body.emit(assign(r1C07, body.constant(736u), 0x01));


               body.instructions = f1C16_parent_instructions;
               body.emit(f1C16);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C19 = equal(r1C01, body.constant(int(8)));
               ir_if *f1C18 = new(mem_ctx) ir_if(operand(r1C19).val);
               exec_list *const f1C18_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C18->then_instructions;

                  body.emit(assign(r1C07, body.constant(924u), 0x01));


               body.instructions = f1C18_parent_instructions;
               body.emit(f1C18);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C1B = equal(r1C01, body.constant(int(9)));
               ir_if *f1C1A = new(mem_ctx) ir_if(operand(r1C1B).val);
               exec_list *const f1C1A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C1A->then_instructions;

                  body.emit(assign(r1C07, body.constant(1128u), 0x01));


               body.instructions = f1C1A_parent_instructions;
               body.emit(f1C1A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C1D = equal(r1C01, body.constant(int(10)));
               ir_if *f1C1C = new(mem_ctx) ir_if(operand(r1C1D).val);
               exec_list *const f1C1C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C1C->then_instructions;

                  body.emit(assign(r1C07, body.constant(1349u), 0x01));


               body.instructions = f1C1C_parent_instructions;
               body.emit(f1C1C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C1F = equal(r1C01, body.constant(int(11)));
               ir_if *f1C1E = new(mem_ctx) ir_if(operand(r1C1F).val);
               exec_list *const f1C1E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C1E->then_instructions;

                  body.emit(assign(r1C07, body.constant(1585u), 0x01));


               body.instructions = f1C1E_parent_instructions;
               body.emit(f1C1E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C21 = equal(r1C01, body.constant(int(12)));
               ir_if *f1C20 = new(mem_ctx) ir_if(operand(r1C21).val);
               exec_list *const f1C20_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C20->then_instructions;

                  body.emit(assign(r1C07, body.constant(1835u), 0x01));


               body.instructions = f1C20_parent_instructions;
               body.emit(f1C20);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C23 = equal(r1C01, body.constant(int(13)));
               ir_if *f1C22 = new(mem_ctx) ir_if(operand(r1C23).val);
               exec_list *const f1C22_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C22->then_instructions;

                  body.emit(assign(r1C07, body.constant(2098u), 0x01));


               body.instructions = f1C22_parent_instructions;
               body.emit(f1C22);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C25 = equal(r1C01, body.constant(int(14)));
               ir_if *f1C24 = new(mem_ctx) ir_if(operand(r1C25).val);
               exec_list *const f1C24_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C24->then_instructions;

                  body.emit(assign(r1C07, body.constant(2374u), 0x01));


               body.instructions = f1C24_parent_instructions;
               body.emit(f1C24);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C27 = equal(r1C01, body.constant(int(15)));
               ir_if *f1C26 = new(mem_ctx) ir_if(operand(r1C27).val);
               exec_list *const f1C26_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C26->then_instructions;

                  body.emit(assign(r1C07, body.constant(2663u), 0x01));


               body.instructions = f1C26_parent_instructions;
               body.emit(f1C26);

               /* END IF */

               ir_expression *const r1C28 = rshift(r1BFA, body.constant(int(17)));
               ir_expression *const r1C29 = add(body.constant(16384u), r1C28);
               body.emit(assign(r1C00, sub(r1C29, r1C07), 0x01));

               ir_expression *const r1C2A = expr(ir_binop_div, r1BFA, r1C00);
               ir_expression *const r1C2B = lshift(r1C2A, body.constant(int(14)));
               ir_expression *const r1C2C = lshift(r1C00, body.constant(int(15)));
               body.emit(assign(r1C00, add(r1C2B, r1C2C), 0x01));

               body.emit(assign(r1BFD, rshift(r1BFA, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C04->else_instructions;

               ir_variable *const r1C2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
               body.emit(r1C2D);
               body.emit(assign(r1C2D, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r1C2F = equal(r1C01, body.constant(int(0)));
               ir_if *f1C2E = new(mem_ctx) ir_if(operand(r1C2F).val);
               exec_list *const f1C2E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C2E->then_instructions;

                  body.emit(assign(r1C2D, body.constant(2605u), 0x01));


               body.instructions = f1C2E_parent_instructions;
               body.emit(f1C2E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C31 = equal(r1C01, body.constant(int(1)));
               ir_if *f1C30 = new(mem_ctx) ir_if(operand(r1C31).val);
               exec_list *const f1C30_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C30->then_instructions;

                  body.emit(assign(r1C2D, body.constant(2223u), 0x01));


               body.instructions = f1C30_parent_instructions;
               body.emit(f1C30);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C33 = equal(r1C01, body.constant(int(2)));
               ir_if *f1C32 = new(mem_ctx) ir_if(operand(r1C33).val);
               exec_list *const f1C32_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C32->then_instructions;

                  body.emit(assign(r1C2D, body.constant(1882u), 0x01));


               body.instructions = f1C32_parent_instructions;
               body.emit(f1C32);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C35 = equal(r1C01, body.constant(int(3)));
               ir_if *f1C34 = new(mem_ctx) ir_if(operand(r1C35).val);
               exec_list *const f1C34_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C34->then_instructions;

                  body.emit(assign(r1C2D, body.constant(1577u), 0x01));


               body.instructions = f1C34_parent_instructions;
               body.emit(f1C34);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C37 = equal(r1C01, body.constant(int(4)));
               ir_if *f1C36 = new(mem_ctx) ir_if(operand(r1C37).val);
               exec_list *const f1C36_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C36->then_instructions;

                  body.emit(assign(r1C2D, body.constant(1306u), 0x01));


               body.instructions = f1C36_parent_instructions;
               body.emit(f1C36);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C39 = equal(r1C01, body.constant(int(5)));
               ir_if *f1C38 = new(mem_ctx) ir_if(operand(r1C39).val);
               exec_list *const f1C38_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C38->then_instructions;

                  body.emit(assign(r1C2D, body.constant(1065u), 0x01));


               body.instructions = f1C38_parent_instructions;
               body.emit(f1C38);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C3B = equal(r1C01, body.constant(int(6)));
               ir_if *f1C3A = new(mem_ctx) ir_if(operand(r1C3B).val);
               exec_list *const f1C3A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C3A->then_instructions;

                  body.emit(assign(r1C2D, body.constant(854u), 0x01));


               body.instructions = f1C3A_parent_instructions;
               body.emit(f1C3A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C3D = equal(r1C01, body.constant(int(7)));
               ir_if *f1C3C = new(mem_ctx) ir_if(operand(r1C3D).val);
               exec_list *const f1C3C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C3C->then_instructions;

                  body.emit(assign(r1C2D, body.constant(670u), 0x01));


               body.instructions = f1C3C_parent_instructions;
               body.emit(f1C3C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C3F = equal(r1C01, body.constant(int(8)));
               ir_if *f1C3E = new(mem_ctx) ir_if(operand(r1C3F).val);
               exec_list *const f1C3E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C3E->then_instructions;

                  body.emit(assign(r1C2D, body.constant(512u), 0x01));


               body.instructions = f1C3E_parent_instructions;
               body.emit(f1C3E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C41 = equal(r1C01, body.constant(int(9)));
               ir_if *f1C40 = new(mem_ctx) ir_if(operand(r1C41).val);
               exec_list *const f1C40_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C40->then_instructions;

                  body.emit(assign(r1C2D, body.constant(377u), 0x01));


               body.instructions = f1C40_parent_instructions;
               body.emit(f1C40);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C43 = equal(r1C01, body.constant(int(10)));
               ir_if *f1C42 = new(mem_ctx) ir_if(operand(r1C43).val);
               exec_list *const f1C42_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C42->then_instructions;

                  body.emit(assign(r1C2D, body.constant(265u), 0x01));


               body.instructions = f1C42_parent_instructions;
               body.emit(f1C42);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C45 = equal(r1C01, body.constant(int(11)));
               ir_if *f1C44 = new(mem_ctx) ir_if(operand(r1C45).val);
               exec_list *const f1C44_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C44->then_instructions;

                  body.emit(assign(r1C2D, body.constant(175u), 0x01));


               body.instructions = f1C44_parent_instructions;
               body.emit(f1C44);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C47 = equal(r1C01, body.constant(int(12)));
               ir_if *f1C46 = new(mem_ctx) ir_if(operand(r1C47).val);
               exec_list *const f1C46_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C46->then_instructions;

                  body.emit(assign(r1C2D, body.constant(104u), 0x01));


               body.instructions = f1C46_parent_instructions;
               body.emit(f1C46);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C49 = equal(r1C01, body.constant(int(13)));
               ir_if *f1C48 = new(mem_ctx) ir_if(operand(r1C49).val);
               exec_list *const f1C48_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C48->then_instructions;

                  body.emit(assign(r1C2D, body.constant(52u), 0x01));


               body.instructions = f1C48_parent_instructions;
               body.emit(f1C48);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C4B = equal(r1C01, body.constant(int(14)));
               ir_if *f1C4A = new(mem_ctx) ir_if(operand(r1C4B).val);
               exec_list *const f1C4A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C4A->then_instructions;

                  body.emit(assign(r1C2D, body.constant(18u), 0x01));


               body.instructions = f1C4A_parent_instructions;
               body.emit(f1C4A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C4D = equal(r1C01, body.constant(int(15)));
               ir_if *f1C4C = new(mem_ctx) ir_if(operand(r1C4D).val);
               exec_list *const f1C4C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C4C->then_instructions;

                  body.emit(assign(r1C2D, body.constant(2u), 0x01));


               body.instructions = f1C4C_parent_instructions;
               body.emit(f1C4C);

               /* END IF */

               ir_expression *const r1C4E = rshift(r1BFD, body.constant(int(17)));
               ir_expression *const r1C4F = add(body.constant(32768u), r1C4E);
               body.emit(assign(r1C00, sub(r1C4F, r1C2D), 0x01));

               ir_expression *const r1C50 = expr(ir_binop_div, r1BFD, r1C00);
               body.emit(assign(r1C00, add(r1C50, r1C00), 0x01));

               ir_variable *const r1C51 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1C53 = lequal(body.constant(131072u), r1C00);
               ir_if *f1C52 = new(mem_ctx) ir_if(operand(r1C53).val);
               exec_list *const f1C52_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C52->then_instructions;

                  body.emit(assign(r1C51, body.constant(4294934528u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C52->else_instructions;

                  body.emit(assign(r1C51, lshift(r1C00, body.constant(int(15))), 0x01));


               body.instructions = f1C52_parent_instructions;
               body.emit(f1C52);

               /* END IF */

               body.emit(assign(r1C00, r1C51, 0x01));

               /* IF CONDITION */
               ir_expression *const r1C55 = lequal(r1C51, r1BFD);
               ir_if *f1C54 = new(mem_ctx) ir_if(operand(r1C55).val);
               exec_list *const f1C54_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C54->then_instructions;

                  ir_expression *const r1C56 = expr(ir_unop_u2i, r1BFD);
                  ir_expression *const r1C57 = rshift(r1C56, body.constant(int(1)));
                  body.emit(assign(r1BFF, expr(ir_unop_i2u, r1C57), 0x01));

                  body.emit(assign(r1BFE, body.constant(false), 0x01));


               body.instructions = f1C54_parent_instructions;
               body.emit(f1C54);

               /* END IF */


            body.instructions = f1C04_parent_instructions;
            body.emit(f1C04);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1C58 = new(mem_ctx) ir_if(operand(r1BFE).val);
            exec_list *const f1C58_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C58->then_instructions;

               ir_variable *const r1C59 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r1C5A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r1C5A);
               ir_variable *const r1C5B = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r1C5B);
               ir_variable *const r1C5C = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r1C5C);
               ir_variable *const r1C5D = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r1C5D);
               body.emit(assign(r1C5C, body.constant(0u), 0x01));

               body.emit(assign(r1C5B, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r1C5F = lequal(r1C00, r1BFD);
               ir_if *f1C5E = new(mem_ctx) ir_if(operand(r1C5F).val);
               exec_list *const f1C5E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C5E->then_instructions;

                  body.emit(assign(r1C59, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C5E->else_instructions;

                  body.emit(assign(r1C5D, rshift(r1C00, body.constant(int(16))), 0x01));

                  ir_variable *const r1C60 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1C62 = lshift(r1C5D, body.constant(int(16)));
                  ir_expression *const r1C63 = lequal(r1C62, r1BFD);
                  ir_if *f1C61 = new(mem_ctx) ir_if(operand(r1C63).val);
                  exec_list *const f1C61_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C61->then_instructions;

                     body.emit(assign(r1C60, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1C61->else_instructions;

                     ir_expression *const r1C64 = expr(ir_binop_div, r1BFD, r1C5D);
                     body.emit(assign(r1C60, lshift(r1C64, body.constant(int(16))), 0x01));


                  body.instructions = f1C61_parent_instructions;
                  body.emit(f1C61);

                  /* END IF */

                  body.emit(assign(r1C5A, r1C60, 0x01));

                  ir_variable *const r1C65 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1C65);
                  ir_variable *const r1C66 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r1C66);
                  ir_variable *const r1C67 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1C67);
                  ir_variable *const r1C68 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1C68, bit_and(r1C00, body.constant(65535u)), 0x01));

                  ir_variable *const r1C69 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1C69, rshift(r1C00, body.constant(int(16))), 0x01));

                  ir_variable *const r1C6A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1C6A, bit_and(r1C60, body.constant(65535u)), 0x01));

                  ir_variable *const r1C6B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1C6B, rshift(r1C60, body.constant(int(16))), 0x01));

                  ir_variable *const r1C6C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1C6C, mul(r1C69, r1C6A), 0x01));

                  ir_expression *const r1C6D = mul(r1C68, r1C6B);
                  body.emit(assign(r1C66, add(r1C6D, r1C6C), 0x01));

                  ir_expression *const r1C6E = mul(r1C69, r1C6B);
                  ir_expression *const r1C6F = less(r1C66, r1C6C);
                  ir_expression *const r1C70 = expr(ir_unop_b2i, r1C6F);
                  ir_expression *const r1C71 = expr(ir_unop_i2u, r1C70);
                  ir_expression *const r1C72 = lshift(r1C71, body.constant(int(16)));
                  ir_expression *const r1C73 = rshift(r1C66, body.constant(int(16)));
                  ir_expression *const r1C74 = add(r1C72, r1C73);
                  body.emit(assign(r1C65, add(r1C6E, r1C74), 0x01));

                  body.emit(assign(r1C66, lshift(r1C66, body.constant(int(16))), 0x01));

                  ir_expression *const r1C75 = mul(r1C68, r1C6A);
                  body.emit(assign(r1C67, add(r1C75, r1C66), 0x01));

                  ir_expression *const r1C76 = less(r1C67, r1C66);
                  ir_expression *const r1C77 = expr(ir_unop_b2i, r1C76);
                  ir_expression *const r1C78 = expr(ir_unop_i2u, r1C77);
                  body.emit(assign(r1C65, add(r1C65, r1C78), 0x01));

                  ir_expression *const r1C79 = sub(r1BFD, r1C65);
                  ir_expression *const r1C7A = less(body.constant(0u), r1C67);
                  ir_expression *const r1C7B = expr(ir_unop_b2i, r1C7A);
                  ir_expression *const r1C7C = expr(ir_unop_i2u, r1C7B);
                  body.emit(assign(r1C5C, sub(r1C79, r1C7C), 0x01));

                  body.emit(assign(r1C5B, neg(r1C67), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f1C7D = new(mem_ctx) ir_loop();
                  exec_list *const f1C7D_parent_instructions = body.instructions;

                     body.instructions = &f1C7D->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1C7F = expr(ir_unop_u2i, r1C5C);
                     ir_expression *const r1C80 = gequal(r1C7F, body.constant(int(0)));
                     ir_if *f1C7E = new(mem_ctx) ir_if(operand(r1C80).val);
                     exec_list *const f1C7E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1C7E->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f1C7E_parent_instructions;
                     body.emit(f1C7E);

                     /* END IF */

                     body.emit(assign(r1C5A, add(r1C5A, body.constant(4294901760u)), 0x01));

                     ir_variable *const r1C81 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r1C82 = lshift(r1C00, body.constant(int(16)));
                     body.emit(assign(r1C81, add(r1C5B, r1C82), 0x01));

                     ir_expression *const r1C83 = add(r1C5C, r1C5D);
                     ir_expression *const r1C84 = less(r1C81, r1C5B);
                     ir_expression *const r1C85 = expr(ir_unop_b2i, r1C84);
                     ir_expression *const r1C86 = expr(ir_unop_i2u, r1C85);
                     body.emit(assign(r1C5C, add(r1C83, r1C86), 0x01));

                     body.emit(assign(r1C5B, r1C81, 0x01));

                  /* LOOP END */

                  body.instructions = f1C7D_parent_instructions;
                  body.emit(f1C7D);

                  ir_expression *const r1C87 = lshift(r1C5C, body.constant(int(16)));
                  ir_expression *const r1C88 = rshift(r1C5B, body.constant(int(16)));
                  body.emit(assign(r1C5C, bit_or(r1C87, r1C88), 0x01));

                  ir_variable *const r1C89 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1C8B = lshift(r1C5D, body.constant(int(16)));
                  ir_expression *const r1C8C = lequal(r1C8B, r1C5C);
                  ir_if *f1C8A = new(mem_ctx) ir_if(operand(r1C8C).val);
                  exec_list *const f1C8A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C8A->then_instructions;

                     body.emit(assign(r1C89, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1C8A->else_instructions;

                     body.emit(assign(r1C89, expr(ir_binop_div, r1C5C, r1C5D), 0x01));


                  body.instructions = f1C8A_parent_instructions;
                  body.emit(f1C8A);

                  /* END IF */

                  body.emit(assign(r1C5A, bit_or(r1C5A, r1C89), 0x01));

                  body.emit(assign(r1C59, r1C5A, 0x01));


               body.instructions = f1C5E_parent_instructions;
               body.emit(f1C5E);

               /* END IF */

               ir_expression *const r1C8D = rshift(r1C59, body.constant(int(1)));
               ir_expression *const r1C8E = rshift(r1C00, body.constant(int(1)));
               body.emit(assign(r1BFF, add(r1C8D, r1C8E), 0x01));

               body.emit(assign(r1BFE, body.constant(false), 0x01));


            body.instructions = f1C58_parent_instructions;
            body.emit(f1C58);

            /* END IF */

            ir_expression *const r1C8F = rshift(r1BFF, body.constant(int(1)));
            body.emit(assign(r1B83, add(r1C8F, body.constant(1u)), 0x01));

            /* IF CONDITION */
            ir_expression *const r1C91 = equal(r1B83, body.constant(0u));
            ir_if *f1C90 = new(mem_ctx) ir_if(operand(r1C91).val);
            exec_list *const f1C90_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C90->then_instructions;

               body.emit(assign(r1B83, body.constant(2147483647u), 0x01));


            body.instructions = f1C90_parent_instructions;
            body.emit(f1C90);

            /* END IF */

            body.emit(assign(r1B81, add(r1B83, r1B83), 0x01));

            ir_variable *const r1C92 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r1C92, swizzle_y(r1B79), 0x01));

            ir_variable *const r1C93 = body.make_temp(glsl_type::int_type, "count");
            ir_expression *const r1C94 = bit_and(r1B78, body.constant(int(1)));
            body.emit(assign(r1C93, sub(body.constant(int(9)), r1C94), 0x01));

            ir_variable *const r1C95 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r1C95, lshift(swizzle_x(r1B79), r1C93), 0x01));

            ir_variable *const r1C96 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1C98 = equal(r1C93, body.constant(int(0)));
            ir_if *f1C97 = new(mem_ctx) ir_if(operand(r1C98).val);
            exec_list *const f1C97_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C97->then_instructions;

               body.emit(assign(r1C96, r1C92, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C97->else_instructions;

               ir_expression *const r1C99 = lshift(swizzle_y(r1B79), r1C93);
               ir_expression *const r1C9A = neg(r1C93);
               ir_expression *const r1C9B = bit_and(r1C9A, body.constant(int(31)));
               ir_expression *const r1C9C = rshift(swizzle_x(r1B79), r1C9B);
               body.emit(assign(r1C96, bit_or(r1C99, r1C9C), 0x01));


            body.instructions = f1C97_parent_instructions;
            body.emit(f1C97);

            /* END IF */

            body.emit(assign(r1B79, r1C96, 0x02));

            body.emit(assign(r1B79, r1C95, 0x01));

            ir_variable *const r1C9D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1C9D);
            ir_variable *const r1C9E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
            body.emit(r1C9E);
            ir_variable *const r1C9F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1C9F);
            ir_variable *const r1CA0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r1CA0, bit_and(r1B83, body.constant(65535u)), 0x01));

            ir_variable *const r1CA1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r1CA1, rshift(r1B83, body.constant(int(16))), 0x01));

            ir_variable *const r1CA2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r1CA2, bit_and(r1B83, body.constant(65535u)), 0x01));

            ir_variable *const r1CA3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r1CA3, rshift(r1B83, body.constant(int(16))), 0x01));

            ir_variable *const r1CA4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r1CA4, mul(r1CA1, r1CA2), 0x01));

            ir_expression *const r1CA5 = mul(r1CA0, r1CA3);
            body.emit(assign(r1C9E, add(r1CA5, r1CA4), 0x01));

            ir_expression *const r1CA6 = mul(r1CA1, r1CA3);
            ir_expression *const r1CA7 = less(r1C9E, r1CA4);
            ir_expression *const r1CA8 = expr(ir_unop_b2i, r1CA7);
            ir_expression *const r1CA9 = expr(ir_unop_i2u, r1CA8);
            ir_expression *const r1CAA = lshift(r1CA9, body.constant(int(16)));
            ir_expression *const r1CAB = rshift(r1C9E, body.constant(int(16)));
            ir_expression *const r1CAC = add(r1CAA, r1CAB);
            body.emit(assign(r1C9D, add(r1CA6, r1CAC), 0x01));

            body.emit(assign(r1C9E, lshift(r1C9E, body.constant(int(16))), 0x01));

            ir_expression *const r1CAD = mul(r1CA0, r1CA2);
            body.emit(assign(r1C9F, add(r1CAD, r1C9E), 0x01));

            ir_expression *const r1CAE = less(r1C9F, r1C9E);
            ir_expression *const r1CAF = expr(ir_unop_b2i, r1CAE);
            ir_expression *const r1CB0 = expr(ir_unop_i2u, r1CAF);
            body.emit(assign(r1C9D, add(r1C9D, r1CB0), 0x01));

            ir_expression *const r1CB1 = sub(r1C96, r1C9D);
            ir_expression *const r1CB2 = less(r1C95, r1C9F);
            ir_expression *const r1CB3 = expr(ir_unop_b2i, r1CB2);
            ir_expression *const r1CB4 = expr(ir_unop_i2u, r1CB3);
            body.emit(assign(r1B80, sub(r1CB1, r1CB4), 0x01));

            body.emit(assign(r1B7F, sub(r1C95, r1C9F), 0x01));

            /* LOOP BEGIN */
            ir_loop *f1CB5 = new(mem_ctx) ir_loop();
            exec_list *const f1CB5_parent_instructions = body.instructions;

               body.instructions = &f1CB5->body_instructions;

               /* IF CONDITION */
               ir_expression *const r1CB7 = expr(ir_unop_u2i, r1B80);
               ir_expression *const r1CB8 = gequal(r1CB7, body.constant(int(0)));
               ir_if *f1CB6 = new(mem_ctx) ir_if(operand(r1CB8).val);
               exec_list *const f1CB6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CB6->then_instructions;

                  body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


               body.instructions = f1CB6_parent_instructions;
               body.emit(f1CB6);

               /* END IF */

               body.emit(assign(r1B83, add(r1B83, body.constant(4294967295u)), 0x01));

               body.emit(assign(r1B81, add(r1B81, body.constant(4294967294u)), 0x01));

               ir_variable *const r1CB9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1CBA = bit_or(r1B81, body.constant(1u));
               body.emit(assign(r1CB9, add(r1B7F, r1CBA), 0x01));

               ir_expression *const r1CBB = less(r1CB9, r1B7F);
               ir_expression *const r1CBC = expr(ir_unop_b2i, r1CBB);
               ir_expression *const r1CBD = expr(ir_unop_i2u, r1CBC);
               body.emit(assign(r1B80, add(r1B80, r1CBD), 0x01));

               body.emit(assign(r1B7F, r1CB9, 0x01));

            /* LOOP END */

            body.instructions = f1CB5_parent_instructions;
            body.emit(f1CB5);

            ir_variable *const r1CBE = body.make_temp(glsl_type::uint_type, "return_value");
            ir_variable *const r1CBF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
            body.emit(r1CBF);
            ir_variable *const r1CC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
            body.emit(r1CC0);
            ir_variable *const r1CC1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
            body.emit(r1CC1);
            ir_variable *const r1CC2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
            body.emit(r1CC2);
            body.emit(assign(r1CC1, body.constant(0u), 0x01));

            body.emit(assign(r1CC0, body.constant(0u), 0x01));

            /* IF CONDITION */
            ir_expression *const r1CC4 = lequal(r1B81, r1B7F);
            ir_if *f1CC3 = new(mem_ctx) ir_if(operand(r1CC4).val);
            exec_list *const f1CC3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1CC3->then_instructions;

               body.emit(assign(r1CBE, body.constant(4294967295u), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1CC3->else_instructions;

               body.emit(assign(r1CC2, rshift(r1B81, body.constant(int(16))), 0x01));

               ir_variable *const r1CC5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1CC7 = lshift(r1CC2, body.constant(int(16)));
               ir_expression *const r1CC8 = lequal(r1CC7, r1B7F);
               ir_if *f1CC6 = new(mem_ctx) ir_if(operand(r1CC8).val);
               exec_list *const f1CC6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CC6->then_instructions;

                  body.emit(assign(r1CC5, body.constant(4294901760u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CC6->else_instructions;

                  ir_expression *const r1CC9 = expr(ir_binop_div, r1B7F, r1CC2);
                  body.emit(assign(r1CC5, lshift(r1CC9, body.constant(int(16))), 0x01));


               body.instructions = f1CC6_parent_instructions;
               body.emit(f1CC6);

               /* END IF */

               body.emit(assign(r1CBF, r1CC5, 0x01));

               ir_variable *const r1CCA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1CCA);
               ir_variable *const r1CCB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1CCB);
               ir_variable *const r1CCC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1CCC);
               ir_variable *const r1CCD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CCD, bit_and(r1B81, body.constant(65535u)), 0x01));

               ir_variable *const r1CCE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CCE, rshift(r1B81, body.constant(int(16))), 0x01));

               ir_variable *const r1CCF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CCF, bit_and(r1CC5, body.constant(65535u)), 0x01));

               ir_variable *const r1CD0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CD0, rshift(r1CC5, body.constant(int(16))), 0x01));

               ir_variable *const r1CD1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CD1, mul(r1CCE, r1CCF), 0x01));

               ir_expression *const r1CD2 = mul(r1CCD, r1CD0);
               body.emit(assign(r1CCB, add(r1CD2, r1CD1), 0x01));

               ir_expression *const r1CD3 = mul(r1CCE, r1CD0);
               ir_expression *const r1CD4 = less(r1CCB, r1CD1);
               ir_expression *const r1CD5 = expr(ir_unop_b2i, r1CD4);
               ir_expression *const r1CD6 = expr(ir_unop_i2u, r1CD5);
               ir_expression *const r1CD7 = lshift(r1CD6, body.constant(int(16)));
               ir_expression *const r1CD8 = rshift(r1CCB, body.constant(int(16)));
               ir_expression *const r1CD9 = add(r1CD7, r1CD8);
               body.emit(assign(r1CCA, add(r1CD3, r1CD9), 0x01));

               body.emit(assign(r1CCB, lshift(r1CCB, body.constant(int(16))), 0x01));

               ir_expression *const r1CDA = mul(r1CCD, r1CCF);
               body.emit(assign(r1CCC, add(r1CDA, r1CCB), 0x01));

               ir_expression *const r1CDB = less(r1CCC, r1CCB);
               ir_expression *const r1CDC = expr(ir_unop_b2i, r1CDB);
               ir_expression *const r1CDD = expr(ir_unop_i2u, r1CDC);
               body.emit(assign(r1CCA, add(r1CCA, r1CDD), 0x01));

               ir_expression *const r1CDE = sub(r1B7F, r1CCA);
               ir_expression *const r1CDF = less(body.constant(0u), r1CCC);
               ir_expression *const r1CE0 = expr(ir_unop_b2i, r1CDF);
               ir_expression *const r1CE1 = expr(ir_unop_i2u, r1CE0);
               body.emit(assign(r1CC1, sub(r1CDE, r1CE1), 0x01));

               body.emit(assign(r1CC0, neg(r1CCC), 0x01));

               /* LOOP BEGIN */
               ir_loop *f1CE2 = new(mem_ctx) ir_loop();
               exec_list *const f1CE2_parent_instructions = body.instructions;

                  body.instructions = &f1CE2->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1CE4 = expr(ir_unop_u2i, r1CC1);
                  ir_expression *const r1CE5 = gequal(r1CE4, body.constant(int(0)));
                  ir_if *f1CE3 = new(mem_ctx) ir_if(operand(r1CE5).val);
                  exec_list *const f1CE3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CE3->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f1CE3_parent_instructions;
                  body.emit(f1CE3);

                  /* END IF */

                  body.emit(assign(r1CBF, add(r1CBF, body.constant(4294901760u)), 0x01));

                  ir_variable *const r1CE6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r1CE7 = lshift(r1B81, body.constant(int(16)));
                  body.emit(assign(r1CE6, add(r1CC0, r1CE7), 0x01));

                  ir_expression *const r1CE8 = add(r1CC1, r1CC2);
                  ir_expression *const r1CE9 = less(r1CE6, r1CC0);
                  ir_expression *const r1CEA = expr(ir_unop_b2i, r1CE9);
                  ir_expression *const r1CEB = expr(ir_unop_i2u, r1CEA);
                  body.emit(assign(r1CC1, add(r1CE8, r1CEB), 0x01));

                  body.emit(assign(r1CC0, r1CE6, 0x01));

               /* LOOP END */

               body.instructions = f1CE2_parent_instructions;
               body.emit(f1CE2);

               ir_expression *const r1CEC = lshift(r1CC1, body.constant(int(16)));
               ir_expression *const r1CED = rshift(r1CC0, body.constant(int(16)));
               body.emit(assign(r1CC1, bit_or(r1CEC, r1CED), 0x01));

               ir_variable *const r1CEE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1CF0 = lshift(r1CC2, body.constant(int(16)));
               ir_expression *const r1CF1 = lequal(r1CF0, r1CC1);
               ir_if *f1CEF = new(mem_ctx) ir_if(operand(r1CF1).val);
               exec_list *const f1CEF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CEF->then_instructions;

                  body.emit(assign(r1CEE, body.constant(65535u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CEF->else_instructions;

                  body.emit(assign(r1CEE, expr(ir_binop_div, r1CC1, r1CC2), 0x01));


               body.instructions = f1CEF_parent_instructions;
               body.emit(f1CEF);

               /* END IF */

               body.emit(assign(r1CBF, bit_or(r1CBF, r1CEE), 0x01));

               body.emit(assign(r1CBE, r1CBF, 0x01));


            body.instructions = f1CC3_parent_instructions;
            body.emit(f1CC3);

            /* END IF */

            body.emit(assign(r1B82, r1CBE, 0x01));

            /* IF CONDITION */
            ir_expression *const r1CF3 = bit_and(r1CBE, body.constant(511u));
            ir_expression *const r1CF4 = lequal(r1CF3, body.constant(5u));
            ir_if *f1CF2 = new(mem_ctx) ir_if(operand(r1CF4).val);
            exec_list *const f1CF2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1CF2->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1CF6 = equal(r1CBE, body.constant(0u));
               ir_if *f1CF5 = new(mem_ctx) ir_if(operand(r1CF6).val);
               exec_list *const f1CF5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CF5->then_instructions;

                  body.emit(assign(r1B82, body.constant(1u), 0x01));


               body.instructions = f1CF5_parent_instructions;
               body.emit(f1CF5);

               /* END IF */

               ir_variable *const r1CF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1CF7);
               ir_variable *const r1CF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1CF8);
               ir_variable *const r1CF9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1CF9);
               ir_variable *const r1CFA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CFA, bit_and(r1B81, body.constant(65535u)), 0x01));

               ir_variable *const r1CFB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CFB, rshift(r1B81, body.constant(int(16))), 0x01));

               ir_variable *const r1CFC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CFC, bit_and(r1B82, body.constant(65535u)), 0x01));

               ir_variable *const r1CFD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CFD, rshift(r1B82, body.constant(int(16))), 0x01));

               ir_variable *const r1CFE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CFE, mul(r1CFB, r1CFC), 0x01));

               ir_expression *const r1CFF = mul(r1CFA, r1CFD);
               body.emit(assign(r1CF8, add(r1CFF, r1CFE), 0x01));

               ir_expression *const r1D00 = mul(r1CFB, r1CFD);
               ir_expression *const r1D01 = less(r1CF8, r1CFE);
               ir_expression *const r1D02 = expr(ir_unop_b2i, r1D01);
               ir_expression *const r1D03 = expr(ir_unop_i2u, r1D02);
               ir_expression *const r1D04 = lshift(r1D03, body.constant(int(16)));
               ir_expression *const r1D05 = rshift(r1CF8, body.constant(int(16)));
               ir_expression *const r1D06 = add(r1D04, r1D05);
               body.emit(assign(r1CF7, add(r1D00, r1D06), 0x01));

               body.emit(assign(r1CF8, lshift(r1CF8, body.constant(int(16))), 0x01));

               ir_expression *const r1D07 = mul(r1CFA, r1CFC);
               body.emit(assign(r1CF9, add(r1D07, r1CF8), 0x01));

               ir_expression *const r1D08 = less(r1CF9, r1CF8);
               ir_expression *const r1D09 = expr(ir_unop_b2i, r1D08);
               ir_expression *const r1D0A = expr(ir_unop_i2u, r1D09);
               body.emit(assign(r1CF7, add(r1CF7, r1D0A), 0x01));

               ir_variable *const r1D0B = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1D0B, neg(r1CF9), 0x01));

               ir_variable *const r1D0C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1D0C);
               ir_variable *const r1D0D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1D0D);
               ir_variable *const r1D0E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1D0E);
               ir_variable *const r1D0F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D0F, bit_and(r1B82, body.constant(65535u)), 0x01));

               ir_variable *const r1D10 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D10, rshift(r1B82, body.constant(int(16))), 0x01));

               ir_variable *const r1D11 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D11, bit_and(r1B82, body.constant(65535u)), 0x01));

               ir_variable *const r1D12 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D12, rshift(r1B82, body.constant(int(16))), 0x01));

               ir_variable *const r1D13 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D13, mul(r1D10, r1D11), 0x01));

               ir_expression *const r1D14 = mul(r1D0F, r1D12);
               body.emit(assign(r1D0D, add(r1D14, r1D13), 0x01));

               ir_expression *const r1D15 = mul(r1D10, r1D12);
               ir_expression *const r1D16 = less(r1D0D, r1D13);
               ir_expression *const r1D17 = expr(ir_unop_b2i, r1D16);
               ir_expression *const r1D18 = expr(ir_unop_i2u, r1D17);
               ir_expression *const r1D19 = lshift(r1D18, body.constant(int(16)));
               ir_expression *const r1D1A = rshift(r1D0D, body.constant(int(16)));
               ir_expression *const r1D1B = add(r1D19, r1D1A);
               body.emit(assign(r1D0C, add(r1D15, r1D1B), 0x01));

               body.emit(assign(r1D0D, lshift(r1D0D, body.constant(int(16))), 0x01));

               ir_expression *const r1D1C = mul(r1D0F, r1D11);
               body.emit(assign(r1D0E, add(r1D1C, r1D0D), 0x01));

               ir_expression *const r1D1D = less(r1D0E, r1D0D);
               ir_expression *const r1D1E = expr(ir_unop_b2i, r1D1D);
               ir_expression *const r1D1F = expr(ir_unop_i2u, r1D1E);
               body.emit(assign(r1D0C, add(r1D0C, r1D1F), 0x01));

               body.emit(assign(r1B7C, r1D0C, 0x01));

               body.emit(assign(r1B7B, r1D0E, 0x01));

               ir_variable *const r1D20 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1D20);
               ir_variable *const r1D21 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1D22 = less(body.constant(0u), r1D0E);
               ir_expression *const r1D23 = expr(ir_unop_b2i, r1D22);
               body.emit(assign(r1D21, expr(ir_unop_i2u, r1D23), 0x01));

               ir_variable *const r1D24 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D24, sub(r1D0B, r1D0C), 0x01));

               ir_expression *const r1D25 = sub(r1B7F, r1CF7);
               ir_expression *const r1D26 = less(body.constant(0u), r1CF9);
               ir_expression *const r1D27 = expr(ir_unop_b2i, r1D26);
               ir_expression *const r1D28 = expr(ir_unop_i2u, r1D27);
               ir_expression *const r1D29 = sub(r1D25, r1D28);
               ir_expression *const r1D2A = less(r1D24, r1D21);
               ir_expression *const r1D2B = expr(ir_unop_b2i, r1D2A);
               ir_expression *const r1D2C = expr(ir_unop_i2u, r1D2B);
               body.emit(assign(r1D20, sub(r1D29, r1D2C), 0x01));

               ir_expression *const r1D2D = less(r1D0B, r1D0C);
               ir_expression *const r1D2E = expr(ir_unop_b2i, r1D2D);
               ir_expression *const r1D2F = expr(ir_unop_i2u, r1D2E);
               body.emit(assign(r1D20, sub(r1D20, r1D2F), 0x01));

               body.emit(assign(r1B7F, r1D20, 0x01));

               body.emit(assign(r1B7E, sub(r1D24, r1D21), 0x01));

               body.emit(assign(r1B7D, neg(r1D0E), 0x01));

               /* LOOP BEGIN */
               ir_loop *f1D30 = new(mem_ctx) ir_loop();
               exec_list *const f1D30_parent_instructions = body.instructions;

                  body.instructions = &f1D30->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1D32 = expr(ir_unop_u2i, r1B7F);
                  ir_expression *const r1D33 = gequal(r1D32, body.constant(int(0)));
                  ir_if *f1D31 = new(mem_ctx) ir_if(operand(r1D33).val);
                  exec_list *const f1D31_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D31->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f1D31_parent_instructions;
                  body.emit(f1D31);

                  /* END IF */

                  body.emit(assign(r1B82, add(r1B82, body.constant(4294967295u)), 0x01));

                  ir_expression *const r1D34 = lshift(r1B82, body.constant(int(1)));
                  body.emit(assign(r1B7B, bit_or(r1D34, body.constant(1u)), 0x01));

                  ir_expression *const r1D35 = rshift(r1B82, body.constant(int(31)));
                  ir_expression *const r1D36 = bit_or(body.constant(0u), r1D35);
                  body.emit(assign(r1B7C, bit_or(r1D36, r1B81), 0x01));

                  ir_variable *const r1D37 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1D37);
                  ir_variable *const r1D38 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1D38);
                  ir_variable *const r1D39 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1D39, add(r1B7D, r1B7B), 0x01));

                  ir_variable *const r1D3A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r1D3B = less(r1D39, r1B7D);
                  ir_expression *const r1D3C = expr(ir_unop_b2i, r1D3B);
                  body.emit(assign(r1D3A, expr(ir_unop_i2u, r1D3C), 0x01));

                  ir_variable *const r1D3D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1D3D, add(r1B7E, r1B7C), 0x01));

                  body.emit(assign(r1D38, add(r1D3D, r1D3A), 0x01));

                  ir_expression *const r1D3E = less(r1D38, r1D3A);
                  ir_expression *const r1D3F = expr(ir_unop_b2i, r1D3E);
                  ir_expression *const r1D40 = expr(ir_unop_i2u, r1D3F);
                  body.emit(assign(r1D37, add(r1B7F, r1D40), 0x01));

                  ir_expression *const r1D41 = less(r1D3D, r1B7E);
                  ir_expression *const r1D42 = expr(ir_unop_b2i, r1D41);
                  ir_expression *const r1D43 = expr(ir_unop_i2u, r1D42);
                  body.emit(assign(r1D37, add(r1D37, r1D43), 0x01));

                  body.emit(assign(r1B7F, r1D37, 0x01));

                  body.emit(assign(r1B7E, r1D38, 0x01));

                  body.emit(assign(r1B7D, r1D39, 0x01));

               /* LOOP END */

               body.instructions = f1D30_parent_instructions;
               body.emit(f1D30);

               ir_expression *const r1D44 = bit_or(r1B7F, r1B7E);
               ir_expression *const r1D45 = bit_or(r1D44, r1B7D);
               ir_expression *const r1D46 = nequal(r1D45, body.constant(0u));
               ir_expression *const r1D47 = expr(ir_unop_b2i, r1D46);
               ir_expression *const r1D48 = expr(ir_unop_i2u, r1D47);
               body.emit(assign(r1B82, bit_or(r1B82, r1D48), 0x01));


            body.instructions = f1CF2_parent_instructions;
            body.emit(f1CF2);

            /* END IF */

            ir_variable *const r1D49 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r1D49);
            ir_variable *const r1D4A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1D4A);
            ir_variable *const r1D4B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1D4B);
            body.emit(assign(r1D49, lshift(r1B82, body.constant(int(22))), 0x01));

            ir_expression *const r1D4C = lshift(r1B83, body.constant(int(22)));
            ir_expression *const r1D4D = rshift(r1B82, body.constant(int(10)));
            body.emit(assign(r1D4A, bit_or(r1D4C, r1D4D), 0x01));

            body.emit(assign(r1D4B, rshift(r1B83, body.constant(int(10))), 0x01));

            body.emit(assign(r1D49, bit_or(r1D49, body.constant(0u)), 0x01));

            body.emit(assign(r1B83, r1D4B, 0x01));

            body.emit(assign(r1B82, r1D4A, 0x01));

            ir_variable *const r1D4E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r1D4E, r1B77, 0x01));

            ir_variable *const r1D4F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r1D4F, r1D4B, 0x01));

            ir_variable *const r1D50 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r1D50, r1D4A, 0x01));

            ir_variable *const r1D51 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r1D51, r1D49, 0x01));

            ir_variable *const r1D52 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r1D52, body.constant(true), 0x01));

            ir_variable *const r1D53 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r1D54 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r1D54);
            ir_expression *const r1D55 = expr(ir_unop_u2i, r1D49);
            body.emit(assign(r1D54, less(r1D55, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1D57 = lequal(body.constant(int(2045)), r1B77);
            ir_if *f1D56 = new(mem_ctx) ir_if(operand(r1D57).val);
            exec_list *const f1D56_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1D56->then_instructions;

               ir_variable *const r1D58 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r1D5A = less(body.constant(int(2045)), r1B77);
               ir_if *f1D59 = new(mem_ctx) ir_if(operand(r1D5A).val);
               exec_list *const f1D59_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D59->then_instructions;

                  body.emit(assign(r1D58, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D59->else_instructions;

                  ir_variable *const r1D5B = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1D5D = equal(r1B77, body.constant(int(2045)));
                  ir_if *f1D5C = new(mem_ctx) ir_if(operand(r1D5D).val);
                  exec_list *const f1D5C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D5C->then_instructions;

                     ir_expression *const r1D5E = equal(body.constant(2097151u), r1D4B);
                     ir_expression *const r1D5F = equal(body.constant(4294967295u), r1D4A);
                     body.emit(assign(r1D5B, logic_and(r1D5E, r1D5F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D5C->else_instructions;

                     body.emit(assign(r1D5B, body.constant(false), 0x01));


                  body.instructions = f1D5C_parent_instructions;
                  body.emit(f1D5C);

                  /* END IF */

                  body.emit(assign(r1D58, logic_and(r1D5B, r1D54), 0x01));


               body.instructions = f1D59_parent_instructions;
               body.emit(f1D59);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1D60 = new(mem_ctx) ir_if(operand(r1D58).val);
               exec_list *const f1D60_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D60->then_instructions;

                  ir_variable *const r1D61 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1D61);
                  body.emit(assign(r1D61, body.constant(2146435072u), 0x02));

                  body.emit(assign(r1D61, body.constant(0u), 0x01));

                  body.emit(assign(r1D53, r1D61, 0x03));

                  body.emit(assign(r1D52, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D60->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1D63 = less(r1B77, body.constant(int(0)));
                  ir_if *f1D62 = new(mem_ctx) ir_if(operand(r1D63).val);
                  exec_list *const f1D62_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D62->then_instructions;

                     ir_variable *const r1D64 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r1D64, r1D49, 0x01));

                     ir_variable *const r1D65 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r1D65, neg(r1B77), 0x01));

                     ir_variable *const r1D66 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r1D66);
                     ir_variable *const r1D67 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r1D67);
                     ir_variable *const r1D68 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r1D68);
                     ir_variable *const r1D69 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r1D6A = neg(r1D65);
                     body.emit(assign(r1D69, bit_and(r1D6A, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1D6C = equal(r1D65, body.constant(int(0)));
                     ir_if *f1D6B = new(mem_ctx) ir_if(operand(r1D6C).val);
                     exec_list *const f1D6B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D6B->then_instructions;

                        body.emit(assign(r1D66, r1D49, 0x01));

                        body.emit(assign(r1D67, r1D4A, 0x01));

                        body.emit(assign(r1D68, r1D4B, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D6B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1D6E = less(r1D65, body.constant(int(32)));
                        ir_if *f1D6D = new(mem_ctx) ir_if(operand(r1D6E).val);
                        exec_list *const f1D6D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D6D->then_instructions;

                           body.emit(assign(r1D66, lshift(r1D4A, r1D69), 0x01));

                           ir_expression *const r1D6F = lshift(r1D4B, r1D69);
                           ir_expression *const r1D70 = rshift(r1D4A, r1D65);
                           body.emit(assign(r1D67, bit_or(r1D6F, r1D70), 0x01));

                           body.emit(assign(r1D68, rshift(r1D4B, r1D65), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D6D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1D72 = equal(r1D65, body.constant(int(32)));
                           ir_if *f1D71 = new(mem_ctx) ir_if(operand(r1D72).val);
                           exec_list *const f1D71_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D71->then_instructions;

                              body.emit(assign(r1D66, r1D4A, 0x01));

                              body.emit(assign(r1D67, r1D4B, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1D71->else_instructions;

                              body.emit(assign(r1D64, bit_or(r1D49, r1D4A), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1D74 = less(r1D65, body.constant(int(64)));
                              ir_if *f1D73 = new(mem_ctx) ir_if(operand(r1D74).val);
                              exec_list *const f1D73_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1D73->then_instructions;

                                 body.emit(assign(r1D66, lshift(r1D4B, r1D69), 0x01));

                                 ir_expression *const r1D75 = bit_and(r1D65, body.constant(int(31)));
                                 body.emit(assign(r1D67, rshift(r1D4B, r1D75), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1D73->else_instructions;

                                 ir_variable *const r1D76 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1D78 = equal(r1D65, body.constant(int(64)));
                                 ir_if *f1D77 = new(mem_ctx) ir_if(operand(r1D78).val);
                                 exec_list *const f1D77_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1D77->then_instructions;

                                    body.emit(assign(r1D76, r1D4B, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1D77->else_instructions;

                                    ir_expression *const r1D79 = nequal(r1D4B, body.constant(0u));
                                    ir_expression *const r1D7A = expr(ir_unop_b2i, r1D79);
                                    body.emit(assign(r1D76, expr(ir_unop_i2u, r1D7A), 0x01));


                                 body.instructions = f1D77_parent_instructions;
                                 body.emit(f1D77);

                                 /* END IF */

                                 body.emit(assign(r1D66, r1D76, 0x01));

                                 body.emit(assign(r1D67, body.constant(0u), 0x01));


                              body.instructions = f1D73_parent_instructions;
                              body.emit(f1D73);

                              /* END IF */


                           body.instructions = f1D71_parent_instructions;
                           body.emit(f1D71);

                           /* END IF */

                           body.emit(assign(r1D68, body.constant(0u), 0x01));


                        body.instructions = f1D6D_parent_instructions;
                        body.emit(f1D6D);

                        /* END IF */

                        ir_expression *const r1D7B = nequal(r1D64, body.constant(0u));
                        ir_expression *const r1D7C = expr(ir_unop_b2i, r1D7B);
                        ir_expression *const r1D7D = expr(ir_unop_i2u, r1D7C);
                        body.emit(assign(r1D66, bit_or(r1D66, r1D7D), 0x01));


                     body.instructions = f1D6B_parent_instructions;
                     body.emit(f1D6B);

                     /* END IF */

                     body.emit(assign(r1D4F, r1D68, 0x01));

                     body.emit(assign(r1D50, r1D67, 0x01));

                     body.emit(assign(r1D51, r1D66, 0x01));

                     body.emit(assign(r1D4E, body.constant(int(0)), 0x01));

                     body.emit(assign(r1D54, less(r1D66, body.constant(0u)), 0x01));


                  body.instructions = f1D62_parent_instructions;
                  body.emit(f1D62);

                  /* END IF */


               body.instructions = f1D60_parent_instructions;
               body.emit(f1D60);

               /* END IF */


            body.instructions = f1D56_parent_instructions;
            body.emit(f1D56);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1D7E = new(mem_ctx) ir_if(operand(r1D52).val);
            exec_list *const f1D7E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1D7E->then_instructions;

               /* IF CONDITION */
               ir_if *f1D7F = new(mem_ctx) ir_if(operand(r1D54).val);
               exec_list *const f1D7F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D7F->then_instructions;

                  ir_variable *const r1D80 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1D80, add(r1D50, body.constant(1u)), 0x01));

                  ir_expression *const r1D81 = less(r1D80, r1D50);
                  ir_expression *const r1D82 = expr(ir_unop_b2i, r1D81);
                  ir_expression *const r1D83 = expr(ir_unop_i2u, r1D82);
                  body.emit(assign(r1D4F, add(r1D4F, r1D83), 0x01));

                  ir_expression *const r1D84 = equal(r1D51, body.constant(0u));
                  ir_expression *const r1D85 = expr(ir_unop_b2i, r1D84);
                  ir_expression *const r1D86 = expr(ir_unop_i2u, r1D85);
                  ir_expression *const r1D87 = add(r1D51, r1D86);
                  ir_expression *const r1D88 = bit_and(r1D87, body.constant(1u));
                  ir_expression *const r1D89 = expr(ir_unop_bit_not, r1D88);
                  body.emit(assign(r1D50, bit_and(r1D80, r1D89), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D7F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1D8B = bit_or(r1D4F, r1D50);
                  ir_expression *const r1D8C = equal(r1D8B, body.constant(0u));
                  ir_if *f1D8A = new(mem_ctx) ir_if(operand(r1D8C).val);
                  exec_list *const f1D8A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D8A->then_instructions;

                     body.emit(assign(r1D4E, body.constant(int(0)), 0x01));


                  body.instructions = f1D8A_parent_instructions;
                  body.emit(f1D8A);

                  /* END IF */


               body.instructions = f1D7F_parent_instructions;
               body.emit(f1D7F);

               /* END IF */

               ir_variable *const r1D8D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1D8D);
               ir_expression *const r1D8E = expr(ir_unop_i2u, r1D4E);
               ir_expression *const r1D8F = lshift(r1D8E, body.constant(int(20)));
               body.emit(assign(r1D8D, add(r1D8F, r1D4F), 0x02));

               body.emit(assign(r1D8D, r1D50, 0x01));

               body.emit(assign(r1D53, r1D8D, 0x03));

               body.emit(assign(r1D52, body.constant(false), 0x01));


            body.instructions = f1D7E_parent_instructions;
            body.emit(f1D7E);

            /* END IF */

            body.emit(assign(r1B76, r1D53, 0x03));

            body.emit(assign(r1B75, body.constant(false), 0x01));


         body.instructions = f1BF6_parent_instructions;
         body.emit(f1BF6);

         /* END IF */


      body.instructions = f1BAD_parent_instructions;
      body.emit(f1BAD);

      /* END IF */


   body.instructions = f1B89_parent_instructions;
   body.emit(f1B89);

   /* END IF */

   body.emit(ret(r1B76));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1D90 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1D90);
   ir_variable *const r1D91 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1D91);
   ir_variable *const r1D92 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1D92);
   ir_variable *const r1D93 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1D93);
   ir_variable *const r1D94 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1D94);
   ir_variable *const r1D95 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1D95);
   ir_variable *const r1D96 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1D96);
   ir_variable *const r1D97 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1D98 = neg(r1D92);
   body.emit(assign(r1D97, bit_and(r1D98, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1D9A = equal(r1D92, body.constant(int(0)));
   ir_if *f1D99 = new(mem_ctx) ir_if(operand(r1D9A).val);
   exec_list *const f1D99_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1D99->then_instructions;

      body.emit(assign(r1D96, r1D90, 0x01));

      body.emit(assign(r1D95, r1D91, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1D99->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1D9C = less(r1D92, body.constant(int(32)));
      ir_if *f1D9B = new(mem_ctx) ir_if(operand(r1D9C).val);
      exec_list *const f1D9B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1D9B->then_instructions;

         ir_expression *const r1D9D = lshift(r1D90, r1D92);
         ir_expression *const r1D9E = rshift(r1D91, r1D97);
         body.emit(assign(r1D96, bit_or(r1D9D, r1D9E), 0x01));

         body.emit(assign(r1D95, lshift(r1D91, r1D92), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1D9B->else_instructions;

         ir_variable *const r1D9F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1DA1 = less(r1D92, body.constant(int(64)));
         ir_if *f1DA0 = new(mem_ctx) ir_if(operand(r1DA1).val);
         exec_list *const f1DA0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DA0->then_instructions;

            ir_expression *const r1DA2 = add(r1D92, body.constant(int(-32)));
            body.emit(assign(r1D9F, lshift(r1D91, r1DA2), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1DA0->else_instructions;

            body.emit(assign(r1D9F, body.constant(0u), 0x01));


         body.instructions = f1DA0_parent_instructions;
         body.emit(f1DA0);

         /* END IF */

         body.emit(assign(r1D96, r1D9F, 0x01));

         body.emit(assign(r1D95, body.constant(0u), 0x01));


      body.instructions = f1D9B_parent_instructions;
      body.emit(f1D9B);

      /* END IF */


   body.instructions = f1D99_parent_instructions;
   body.emit(f1D99);

   /* END IF */

   body.emit(assign(r1D93, r1D96, 0x01));

   body.emit(assign(r1D94, r1D95, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
uint_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1DA3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1DA3);
   ir_variable *const r1DA4 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r1DA6 = equal(r1DA3, body.constant(0u));
   ir_if *f1DA5 = new(mem_ctx) ir_if(operand(r1DA6).val);
   exec_list *const f1DA5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1DA5->then_instructions;

      body.emit(assign(r1DA4, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1DA5->else_instructions;

      ir_variable *const r1DA7 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1DA7, r1DA3, 0x01));

      ir_variable *const r1DA8 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1DA9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1DA9);
      /* IF CONDITION */
      ir_expression *const r1DAB = equal(r1DA3, body.constant(0u));
      ir_if *f1DAA = new(mem_ctx) ir_if(operand(r1DAB).val);
      exec_list *const f1DAA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1DAA->then_instructions;

         body.emit(assign(r1DA8, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1DAA->else_instructions;

         body.emit(assign(r1DA9, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1DAD = bit_and(r1DA3, body.constant(4294901760u));
         ir_expression *const r1DAE = equal(r1DAD, body.constant(0u));
         ir_if *f1DAC = new(mem_ctx) ir_if(operand(r1DAE).val);
         exec_list *const f1DAC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DAC->then_instructions;

            body.emit(assign(r1DA9, body.constant(int(16)), 0x01));

            body.emit(assign(r1DA7, lshift(r1DA3, body.constant(int(16))), 0x01));


         body.instructions = f1DAC_parent_instructions;
         body.emit(f1DAC);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1DB0 = bit_and(r1DA7, body.constant(4278190080u));
         ir_expression *const r1DB1 = equal(r1DB0, body.constant(0u));
         ir_if *f1DAF = new(mem_ctx) ir_if(operand(r1DB1).val);
         exec_list *const f1DAF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DAF->then_instructions;

            body.emit(assign(r1DA9, add(r1DA9, body.constant(int(8))), 0x01));

            body.emit(assign(r1DA7, lshift(r1DA7, body.constant(int(8))), 0x01));


         body.instructions = f1DAF_parent_instructions;
         body.emit(f1DAF);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1DB3 = bit_and(r1DA7, body.constant(4026531840u));
         ir_expression *const r1DB4 = equal(r1DB3, body.constant(0u));
         ir_if *f1DB2 = new(mem_ctx) ir_if(operand(r1DB4).val);
         exec_list *const f1DB2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DB2->then_instructions;

            body.emit(assign(r1DA9, add(r1DA9, body.constant(int(4))), 0x01));

            body.emit(assign(r1DA7, lshift(r1DA7, body.constant(int(4))), 0x01));


         body.instructions = f1DB2_parent_instructions;
         body.emit(f1DB2);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1DB6 = bit_and(r1DA7, body.constant(3221225472u));
         ir_expression *const r1DB7 = equal(r1DB6, body.constant(0u));
         ir_if *f1DB5 = new(mem_ctx) ir_if(operand(r1DB7).val);
         exec_list *const f1DB5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DB5->then_instructions;

            body.emit(assign(r1DA9, add(r1DA9, body.constant(int(2))), 0x01));

            body.emit(assign(r1DA7, lshift(r1DA7, body.constant(int(2))), 0x01));


         body.instructions = f1DB5_parent_instructions;
         body.emit(f1DB5);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1DB9 = bit_and(r1DA7, body.constant(2147483648u));
         ir_expression *const r1DBA = equal(r1DB9, body.constant(0u));
         ir_if *f1DB8 = new(mem_ctx) ir_if(operand(r1DBA).val);
         exec_list *const f1DB8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DB8->then_instructions;

            body.emit(assign(r1DA9, add(r1DA9, body.constant(int(1))), 0x01));


         body.instructions = f1DB8_parent_instructions;
         body.emit(f1DB8);

         /* END IF */

         body.emit(assign(r1DA8, r1DA9, 0x01));


      body.instructions = f1DAA_parent_instructions;
      body.emit(f1DAA);

      /* END IF */

      ir_variable *const r1DBB = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r1DBB, add(r1DA8, body.constant(int(21))), 0x01));

      ir_variable *const r1DBC = body.make_temp(glsl_type::uint_type, "a0");
      body.emit(assign(r1DBC, body.constant(0u), 0x01));

      ir_variable *const r1DBD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1DBD);
      ir_variable *const r1DBE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1DBE);
      ir_variable *const r1DBF = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r1DC0 = neg(r1DBB);
      body.emit(assign(r1DBF, bit_and(r1DC0, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1DC2 = equal(r1DBB, body.constant(int(0)));
      ir_if *f1DC1 = new(mem_ctx) ir_if(operand(r1DC2).val);
      exec_list *const f1DC1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1DC1->then_instructions;

         body.emit(assign(r1DBE, body.constant(0u), 0x01));

         body.emit(assign(r1DBD, r1DA3, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1DC1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1DC4 = less(r1DBB, body.constant(int(32)));
         ir_if *f1DC3 = new(mem_ctx) ir_if(operand(r1DC4).val);
         exec_list *const f1DC3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DC3->then_instructions;

            ir_expression *const r1DC5 = rshift(r1DA3, r1DBF);
            body.emit(assign(r1DBE, bit_or(body.constant(0u), r1DC5), 0x01));

            body.emit(assign(r1DBD, lshift(r1DA3, r1DBB), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1DC3->else_instructions;

            ir_variable *const r1DC6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1DC8 = less(r1DBB, body.constant(int(64)));
            ir_if *f1DC7 = new(mem_ctx) ir_if(operand(r1DC8).val);
            exec_list *const f1DC7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1DC7->then_instructions;

               ir_expression *const r1DC9 = add(r1DBB, body.constant(int(-32)));
               body.emit(assign(r1DC6, lshift(r1DA3, r1DC9), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1DC7->else_instructions;

               body.emit(assign(r1DC6, body.constant(0u), 0x01));


            body.instructions = f1DC7_parent_instructions;
            body.emit(f1DC7);

            /* END IF */

            body.emit(assign(r1DBE, r1DC6, 0x01));

            body.emit(assign(r1DBD, body.constant(0u), 0x01));


         body.instructions = f1DC3_parent_instructions;
         body.emit(f1DC3);

         /* END IF */


      body.instructions = f1DC1_parent_instructions;
      body.emit(f1DC1);

      /* END IF */

      ir_variable *const r1DCA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1DCA);
      ir_expression *const r1DCB = sub(body.constant(int(1074)), r1DBB);
      ir_expression *const r1DCC = expr(ir_unop_i2u, r1DCB);
      ir_expression *const r1DCD = lshift(r1DCC, body.constant(int(20)));
      body.emit(assign(r1DCA, add(r1DCD, r1DBE), 0x02));

      body.emit(assign(r1DCA, r1DBD, 0x01));

      body.emit(assign(r1DA4, r1DCA, 0x03));


   body.instructions = f1DA5_parent_instructions;
   body.emit(f1DA5);

   /* END IF */

   body.emit(ret(r1DA4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_uint(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1DCE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1DCE);
   ir_variable *const r1DCF = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1DD0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r1DD0);
   ir_variable *const r1DD1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1DD1);
   body.emit(assign(r1DD1, bit_and(swizzle_y(r1DCE), body.constant(1048575u)), 0x02));

   body.emit(assign(r1DD1, swizzle_x(r1DCE), 0x01));

   body.emit(assign(r1DD0, r1DD1, 0x03));

   ir_variable *const r1DD2 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1DD3 = rshift(swizzle_y(r1DCE), body.constant(int(20)));
   ir_expression *const r1DD4 = bit_and(r1DD3, body.constant(2047u));
   body.emit(assign(r1DD2, expr(ir_unop_u2i, r1DD4), 0x01));

   ir_variable *const r1DD5 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r1DD5, rshift(swizzle_y(r1DCE), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1DD7 = nequal(r1DD5, body.constant(0u));
   ir_if *f1DD6 = new(mem_ctx) ir_if(operand(r1DD7).val);
   exec_list *const f1DD6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1DD6->then_instructions;

      body.emit(assign(r1DCF, body.constant(0u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1DD6->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1DD9 = equal(r1DD2, body.constant(int(2047)));
      ir_expression *const r1DDA = bit_or(swizzle_y(r1DD1), swizzle_x(r1DCE));
      ir_expression *const r1DDB = nequal(r1DDA, body.constant(0u));
      ir_expression *const r1DDC = logic_and(r1DD9, r1DDB);
      ir_if *f1DD8 = new(mem_ctx) ir_if(operand(r1DDC).val);
      exec_list *const f1DD8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1DD8->then_instructions;

         body.emit(assign(r1DCF, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1DD8->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1DDE = nequal(r1DD2, body.constant(int(0)));
         ir_if *f1DDD = new(mem_ctx) ir_if(operand(r1DDE).val);
         exec_list *const f1DDD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DDD->then_instructions;

            body.emit(assign(r1DD0, bit_or(swizzle_y(r1DD1), body.constant(1048576u)), 0x02));


         body.instructions = f1DDD_parent_instructions;
         body.emit(f1DDD);

         /* END IF */

         ir_variable *const r1DDF = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1DDF, sub(body.constant(int(1063)), r1DD2), 0x01));

         /* IF CONDITION */
         ir_expression *const r1DE1 = less(body.constant(int(0)), r1DDF);
         ir_if *f1DE0 = new(mem_ctx) ir_if(operand(r1DE1).val);
         exec_list *const f1DE0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DE0->then_instructions;

            ir_variable *const r1DE2 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r1DE2, swizzle_y(r1DD0), 0x01));

            ir_variable *const r1DE3 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r1DE3, swizzle_x(r1DD0), 0x01));

            ir_variable *const r1DE4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1DE4);
            ir_variable *const r1DE5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1DE5);
            ir_variable *const r1DE6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r1DE7 = neg(r1DDF);
            body.emit(assign(r1DE6, bit_and(r1DE7, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1DE9 = equal(r1DDF, body.constant(int(0)));
            ir_if *f1DE8 = new(mem_ctx) ir_if(operand(r1DE9).val);
            exec_list *const f1DE8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1DE8->then_instructions;

               body.emit(assign(r1DE4, r1DE3, 0x01));

               body.emit(assign(r1DE5, r1DE2, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1DE8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1DEB = less(r1DDF, body.constant(int(32)));
               ir_if *f1DEA = new(mem_ctx) ir_if(operand(r1DEB).val);
               exec_list *const f1DEA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DEA->then_instructions;

                  ir_expression *const r1DEC = lshift(swizzle_y(r1DD0), r1DE6);
                  ir_expression *const r1DED = rshift(swizzle_x(r1DD1), r1DDF);
                  ir_expression *const r1DEE = bit_or(r1DEC, r1DED);
                  ir_expression *const r1DEF = lshift(swizzle_x(r1DD1), r1DE6);
                  ir_expression *const r1DF0 = nequal(r1DEF, body.constant(0u));
                  ir_expression *const r1DF1 = expr(ir_unop_b2i, r1DF0);
                  ir_expression *const r1DF2 = expr(ir_unop_i2u, r1DF1);
                  body.emit(assign(r1DE4, bit_or(r1DEE, r1DF2), 0x01));

                  body.emit(assign(r1DE5, rshift(swizzle_y(r1DD0), r1DDF), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1DEA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1DF4 = equal(r1DDF, body.constant(int(32)));
                  ir_if *f1DF3 = new(mem_ctx) ir_if(operand(r1DF4).val);
                  exec_list *const f1DF3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DF3->then_instructions;

                     ir_expression *const r1DF5 = nequal(swizzle_x(r1DD1), body.constant(0u));
                     ir_expression *const r1DF6 = expr(ir_unop_b2i, r1DF5);
                     ir_expression *const r1DF7 = expr(ir_unop_i2u, r1DF6);
                     body.emit(assign(r1DE4, bit_or(swizzle_y(r1DD0), r1DF7), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DF3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1DF9 = less(r1DDF, body.constant(int(64)));
                     ir_if *f1DF8 = new(mem_ctx) ir_if(operand(r1DF9).val);
                     exec_list *const f1DF8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1DF8->then_instructions;

                        ir_expression *const r1DFA = bit_and(r1DDF, body.constant(int(31)));
                        ir_expression *const r1DFB = rshift(swizzle_y(r1DD0), r1DFA);
                        ir_expression *const r1DFC = lshift(swizzle_y(r1DD0), r1DE6);
                        ir_expression *const r1DFD = bit_or(r1DFC, swizzle_x(r1DD1));
                        ir_expression *const r1DFE = nequal(r1DFD, body.constant(0u));
                        ir_expression *const r1DFF = expr(ir_unop_b2i, r1DFE);
                        ir_expression *const r1E00 = expr(ir_unop_i2u, r1DFF);
                        body.emit(assign(r1DE4, bit_or(r1DFB, r1E00), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1DF8->else_instructions;

                        ir_expression *const r1E01 = bit_or(swizzle_y(r1DD0), swizzle_x(r1DD1));
                        ir_expression *const r1E02 = nequal(r1E01, body.constant(0u));
                        ir_expression *const r1E03 = expr(ir_unop_b2i, r1E02);
                        body.emit(assign(r1DE4, expr(ir_unop_i2u, r1E03), 0x01));


                     body.instructions = f1DF8_parent_instructions;
                     body.emit(f1DF8);

                     /* END IF */


                  body.instructions = f1DF3_parent_instructions;
                  body.emit(f1DF3);

                  /* END IF */

                  body.emit(assign(r1DE5, body.constant(0u), 0x01));


               body.instructions = f1DEA_parent_instructions;
               body.emit(f1DEA);

               /* END IF */


            body.instructions = f1DE8_parent_instructions;
            body.emit(f1DE8);

            /* END IF */

            body.emit(assign(r1DD0, r1DE5, 0x02));

            body.emit(assign(r1DD0, r1DE4, 0x01));


         body.instructions = f1DE0_parent_instructions;
         body.emit(f1DE0);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1E05 = bit_and(swizzle_y(r1DD0), body.constant(4294963200u));
         ir_expression *const r1E06 = nequal(r1E05, body.constant(0u));
         ir_if *f1E04 = new(mem_ctx) ir_if(operand(r1E06).val);
         exec_list *const f1E04_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1E04->then_instructions;

            ir_variable *const r1E07 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1E09 = nequal(r1DD5, body.constant(0u));
            ir_if *f1E08 = new(mem_ctx) ir_if(operand(r1E09).val);
            exec_list *const f1E08_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1E08->then_instructions;

               body.emit(assign(r1E07, body.constant(0u), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1E08->else_instructions;

               body.emit(assign(r1E07, body.constant(4294967295u), 0x01));


            body.instructions = f1E08_parent_instructions;
            body.emit(f1E08);

            /* END IF */

            body.emit(assign(r1DCF, r1E07, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1E04->else_instructions;

            ir_variable *const r1E0A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1E0A);
            ir_variable *const r1E0B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1E0B);
            ir_expression *const r1E0C = lshift(swizzle_y(r1DD0), body.constant(int(20)));
            ir_expression *const r1E0D = rshift(swizzle_x(r1DD0), body.constant(int(12)));
            body.emit(assign(r1E0A, bit_or(r1E0C, r1E0D), 0x01));

            body.emit(assign(r1E0B, rshift(swizzle_y(r1DD0), body.constant(int(12))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1E0F = nequal(r1DD5, body.constant(0u));
            ir_expression *const r1E10 = nequal(r1E0A, body.constant(0u));
            ir_expression *const r1E11 = logic_and(r1E0F, r1E10);
            ir_if *f1E0E = new(mem_ctx) ir_if(operand(r1E11).val);
            exec_list *const f1E0E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1E0E->then_instructions;

               ir_variable *const r1E12 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1E14 = nequal(r1DD5, body.constant(0u));
               ir_if *f1E13 = new(mem_ctx) ir_if(operand(r1E14).val);
               exec_list *const f1E13_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E13->then_instructions;

                  body.emit(assign(r1E12, body.constant(0u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1E13->else_instructions;

                  body.emit(assign(r1E12, body.constant(4294967295u), 0x01));


               body.instructions = f1E13_parent_instructions;
               body.emit(f1E13);

               /* END IF */

               body.emit(assign(r1DCF, r1E12, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1E0E->else_instructions;

               body.emit(assign(r1DCF, r1E0A, 0x01));


            body.instructions = f1E0E_parent_instructions;
            body.emit(f1E0E);

            /* END IF */


         body.instructions = f1E04_parent_instructions;
         body.emit(f1E04);

         /* END IF */


      body.instructions = f1DD8_parent_instructions;
      body.emit(f1DD8);

      /* END IF */


   body.instructions = f1DD6_parent_instructions;
   body.emit(f1DD6);

   /* END IF */

   body.emit(ret(r1DCF));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ftrunc64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1E15 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1E15);
   ir_variable *const r1E16 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1E17 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1E18 = rshift(swizzle_y(r1E15), body.constant(int(20)));
   ir_expression *const r1E19 = bit_and(r1E18, body.constant(2047u));
   ir_expression *const r1E1A = expr(ir_unop_u2i, r1E19);
   body.emit(assign(r1E17, add(r1E1A, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1E1C = less(r1E17, body.constant(int(0)));
   ir_if *f1E1B = new(mem_ctx) ir_if(operand(r1E1C).val);
   exec_list *const f1E1B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1E1B->then_instructions;

      body.emit(assign(r1E16, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1E1B->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1E1E = greater(r1E17, body.constant(int(52)));
      ir_if *f1E1D = new(mem_ctx) ir_if(operand(r1E1E).val);
      exec_list *const f1E1D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1E1D->then_instructions;

         body.emit(assign(r1E16, r1E15, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1E1D->else_instructions;

         ir_variable *const r1E1F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1E1F);
         ir_variable *const r1E20 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1E20, sub(body.constant(int(52)), r1E17), 0x01));

         ir_variable *const r1E21 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1E23 = gequal(r1E20, body.constant(int(32)));
         ir_if *f1E22 = new(mem_ctx) ir_if(operand(r1E23).val);
         exec_list *const f1E22_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1E22->then_instructions;

            body.emit(assign(r1E21, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1E22->else_instructions;

            body.emit(assign(r1E21, lshift(body.constant(4294967295u), r1E20), 0x01));


         body.instructions = f1E22_parent_instructions;
         body.emit(f1E22);

         /* END IF */

         ir_variable *const r1E24 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1E26 = less(r1E20, body.constant(int(33)));
         ir_if *f1E25 = new(mem_ctx) ir_if(operand(r1E26).val);
         exec_list *const f1E25_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1E25->then_instructions;

            body.emit(assign(r1E24, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1E25->else_instructions;

            ir_expression *const r1E27 = add(r1E20, body.constant(int(-32)));
            body.emit(assign(r1E24, lshift(body.constant(4294967295u), r1E27), 0x01));


         body.instructions = f1E25_parent_instructions;
         body.emit(f1E25);

         /* END IF */

         body.emit(assign(r1E1F, bit_and(r1E21, swizzle_x(r1E15)), 0x01));

         body.emit(assign(r1E1F, bit_and(r1E24, swizzle_y(r1E15)), 0x02));

         body.emit(assign(r1E16, r1E1F, 0x03));


      body.instructions = f1E1D_parent_instructions;
      body.emit(f1E1D);

      /* END IF */


   body.instructions = f1E1B_parent_instructions;
   body.emit(f1E1B);

   /* END IF */

   body.emit(ret(r1E16));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffloor64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1E28 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1E28);
   ir_variable *const r1E29 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1E2A = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1E2B = rshift(swizzle_y(r1E28), body.constant(int(20)));
   ir_expression *const r1E2C = bit_and(r1E2B, body.constant(2047u));
   ir_expression *const r1E2D = expr(ir_unop_u2i, r1E2C);
   body.emit(assign(r1E2A, add(r1E2D, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1E2F = less(r1E2A, body.constant(int(0)));
   ir_if *f1E2E = new(mem_ctx) ir_if(operand(r1E2F).val);
   exec_list *const f1E2E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1E2E->then_instructions;

      body.emit(assign(r1E29, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1E2E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1E31 = greater(r1E2A, body.constant(int(52)));
      ir_if *f1E30 = new(mem_ctx) ir_if(operand(r1E31).val);
      exec_list *const f1E30_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1E30->then_instructions;

         body.emit(assign(r1E29, r1E28, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1E30->else_instructions;

         ir_variable *const r1E32 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1E32);
         ir_variable *const r1E33 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1E33, sub(body.constant(int(52)), r1E2A), 0x01));

         ir_variable *const r1E34 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1E36 = gequal(r1E33, body.constant(int(32)));
         ir_if *f1E35 = new(mem_ctx) ir_if(operand(r1E36).val);
         exec_list *const f1E35_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1E35->then_instructions;

            body.emit(assign(r1E34, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1E35->else_instructions;

            body.emit(assign(r1E34, lshift(body.constant(4294967295u), r1E33), 0x01));


         body.instructions = f1E35_parent_instructions;
         body.emit(f1E35);

         /* END IF */

         ir_variable *const r1E37 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1E39 = less(r1E33, body.constant(int(33)));
         ir_if *f1E38 = new(mem_ctx) ir_if(operand(r1E39).val);
         exec_list *const f1E38_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1E38->then_instructions;

            body.emit(assign(r1E37, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1E38->else_instructions;

            ir_expression *const r1E3A = add(r1E33, body.constant(int(-32)));
            body.emit(assign(r1E37, lshift(body.constant(4294967295u), r1E3A), 0x01));


         body.instructions = f1E38_parent_instructions;
         body.emit(f1E38);

         /* END IF */

         body.emit(assign(r1E32, bit_and(r1E34, swizzle_x(r1E28)), 0x01));

         body.emit(assign(r1E32, bit_and(r1E37, swizzle_y(r1E28)), 0x02));

         body.emit(assign(r1E29, r1E32, 0x03));


      body.instructions = f1E30_parent_instructions;
      body.emit(f1E30);

      /* END IF */


   body.instructions = f1E2E_parent_instructions;
   body.emit(f1E2E);

   /* END IF */

   ir_variable *const r1E3B = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r1E3C = rshift(swizzle_y(r1E28), body.constant(int(31)));
   ir_expression *const r1E3D = expr(ir_unop_u2i, r1E3C);
   body.emit(assign(r1E3B, expr(ir_unop_i2b, r1E3D), 0x01));

   ir_variable *const r1E3E = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r1E40 = expr(ir_unop_logic_not, r1E3B);
   ir_if *f1E3F = new(mem_ctx) ir_if(operand(r1E40).val);
   exec_list *const f1E3F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1E3F->then_instructions;

      body.emit(assign(r1E3E, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1E3F->else_instructions;

      ir_variable *const r1E41 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r1E42 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r1E42);
      ir_variable *const r1E43 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r1E43);
      ir_variable *const r1E44 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r1E44);
      body.emit(assign(r1E44, bit_and(swizzle_y(r1E28), body.constant(1048575u)), 0x02));

      body.emit(assign(r1E44, swizzle_x(r1E28), 0x01));

      ir_variable *const r1E45 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r1E45);
      body.emit(assign(r1E45, bit_and(swizzle_y(r1E29), body.constant(1048575u)), 0x02));

      body.emit(assign(r1E45, swizzle_x(r1E29), 0x01));

      ir_expression *const r1E46 = rshift(swizzle_y(r1E28), body.constant(int(20)));
      ir_expression *const r1E47 = bit_and(r1E46, body.constant(2047u));
      ir_expression *const r1E48 = expr(ir_unop_u2i, r1E47);
      ir_expression *const r1E49 = equal(r1E48, body.constant(int(2047)));
      ir_expression *const r1E4A = bit_or(swizzle_y(r1E44), swizzle_x(r1E28));
      ir_expression *const r1E4B = nequal(r1E4A, body.constant(0u));
      body.emit(assign(r1E43, logic_and(r1E49, r1E4B), 0x01));

      ir_expression *const r1E4C = rshift(swizzle_y(r1E29), body.constant(int(20)));
      ir_expression *const r1E4D = bit_and(r1E4C, body.constant(2047u));
      ir_expression *const r1E4E = expr(ir_unop_u2i, r1E4D);
      ir_expression *const r1E4F = equal(r1E4E, body.constant(int(2047)));
      ir_expression *const r1E50 = bit_or(swizzle_y(r1E45), swizzle_x(r1E29));
      ir_expression *const r1E51 = nequal(r1E50, body.constant(0u));
      body.emit(assign(r1E42, logic_and(r1E4F, r1E51), 0x01));

      /* IF CONDITION */
      ir_expression *const r1E53 = logic_or(r1E43, r1E42);
      ir_if *f1E52 = new(mem_ctx) ir_if(operand(r1E53).val);
      exec_list *const f1E52_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1E52->then_instructions;

         body.emit(assign(r1E41, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1E52->else_instructions;

         ir_expression *const r1E54 = equal(swizzle_x(r1E28), swizzle_x(r1E29));
         ir_expression *const r1E55 = equal(swizzle_y(r1E28), swizzle_y(r1E29));
         ir_expression *const r1E56 = equal(swizzle_x(r1E28), body.constant(0u));
         ir_expression *const r1E57 = bit_or(swizzle_y(r1E28), swizzle_y(r1E29));
         ir_expression *const r1E58 = lshift(r1E57, body.constant(int(1)));
         ir_expression *const r1E59 = equal(r1E58, body.constant(0u));
         ir_expression *const r1E5A = logic_and(r1E56, r1E59);
         ir_expression *const r1E5B = logic_or(r1E55, r1E5A);
         body.emit(assign(r1E41, logic_and(r1E54, r1E5B), 0x01));


      body.instructions = f1E52_parent_instructions;
      body.emit(f1E52);

      /* END IF */

      body.emit(assign(r1E3E, r1E41, 0x01));


   body.instructions = f1E3F_parent_instructions;
   body.emit(f1E3F);

   /* END IF */

   ir_variable *const r1E5C = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f1E5D = new(mem_ctx) ir_if(operand(r1E3E).val);
   exec_list *const f1E5D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1E5D->then_instructions;

      body.emit(assign(r1E5C, r1E29, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1E5D->else_instructions;

      ir_variable *const r1E5E = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r1E5F = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1E5F, rshift(swizzle_y(r1E29), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1E61 = equal(r1E5F, body.constant(0u));
      ir_if *f1E60 = new(mem_ctx) ir_if(operand(r1E61).val);
      exec_list *const f1E60_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1E60->then_instructions;

         ir_variable *const r1E62 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r1E62, r1E5F, 0x01));

         ir_variable *const r1E63 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r1E64 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r1E64);
         ir_variable *const r1E65 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r1E65);
         ir_variable *const r1E66 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r1E66);
         ir_variable *const r1E67 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r1E67);
         ir_variable *const r1E68 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r1E68);
         ir_variable *const r1E69 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r1E69);
         ir_variable *const r1E6A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r1E6A);
         body.emit(assign(r1E6A, bit_and(swizzle_y(r1E29), body.constant(1048575u)), 0x02));

         body.emit(assign(r1E6A, swizzle_x(r1E29), 0x01));

         ir_variable *const r1E6B = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r1E6C = rshift(swizzle_y(r1E29), body.constant(int(20)));
         ir_expression *const r1E6D = bit_and(r1E6C, body.constant(2047u));
         body.emit(assign(r1E6B, expr(ir_unop_u2i, r1E6D), 0x01));

         body.emit(assign(r1E67, r1E6B, 0x01));

         ir_variable *const r1E6E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r1E6E);
         body.emit(assign(r1E6E, body.constant(0u), 0x02));

         body.emit(assign(r1E6E, body.constant(0u), 0x01));

         body.emit(assign(r1E65, body.constant(int(1023)), 0x01));

         body.emit(assign(r1E64, add(r1E6B, body.constant(int(-1023))), 0x01));

         ir_variable *const r1E6F = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1E6F, lshift(swizzle_x(r1E29), body.constant(int(10))), 0x01));

         ir_variable *const r1E70 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r1E71 = lshift(swizzle_y(r1E6A), body.constant(int(10)));
         ir_expression *const r1E72 = rshift(swizzle_x(r1E29), body.constant(int(22)));
         body.emit(assign(r1E70, bit_or(r1E71, r1E72), 0x01));

         body.emit(assign(r1E68, r1E70, 0x02));

         body.emit(assign(r1E68, r1E6F, 0x01));

         ir_variable *const r1E73 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r1E73, body.constant(0u), 0x01));

         body.emit(assign(r1E66, r1E73, 0x02));

         body.emit(assign(r1E66, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r1E75 = less(body.constant(int(0)), r1E64);
         ir_if *f1E74 = new(mem_ctx) ir_if(operand(r1E75).val);
         exec_list *const f1E74_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1E74->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1E77 = equal(r1E6B, body.constant(int(2047)));
            ir_if *f1E76 = new(mem_ctx) ir_if(operand(r1E77).val);
            exec_list *const f1E76_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1E76->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1E79 = bit_or(r1E70, r1E6F);
               ir_expression *const r1E7A = nequal(r1E79, body.constant(0u));
               ir_if *f1E78 = new(mem_ctx) ir_if(operand(r1E7A).val);
               exec_list *const f1E78_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E78->then_instructions;

                  ir_variable *const r1E7B = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1E7B, swizzle_x(r1E29), 0x01));

                  ir_variable *const r1E7C = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1E7C, body.constant(0u), 0x01));

                  ir_variable *const r1E7D = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r1E7B, bit_or(swizzle_y(r1E29), body.constant(524288u)), 0x02));

                  body.emit(assign(r1E7C, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1E7F = lshift(swizzle_y(r1E29), body.constant(int(1)));
                  ir_expression *const r1E80 = lequal(body.constant(4292870144u), r1E7F);
                  ir_expression *const r1E81 = nequal(swizzle_x(r1E29), body.constant(0u));
                  ir_expression *const r1E82 = bit_and(swizzle_y(r1E29), body.constant(1048575u));
                  ir_expression *const r1E83 = nequal(r1E82, body.constant(0u));
                  ir_expression *const r1E84 = logic_or(r1E81, r1E83);
                  ir_expression *const r1E85 = logic_and(r1E80, r1E84);
                  ir_if *f1E7E = new(mem_ctx) ir_if(operand(r1E85).val);
                  exec_list *const f1E7E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E7E->then_instructions;

                     body.emit(assign(r1E7D, r1E7B, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E7E->else_instructions;

                     body.emit(assign(r1E7D, r1E7C, 0x03));


                  body.instructions = f1E7E_parent_instructions;
                  body.emit(f1E7E);

                  /* END IF */

                  body.emit(assign(r1E63, r1E7D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1E78->else_instructions;

                  body.emit(assign(r1E63, r1E29, 0x03));


               body.instructions = f1E78_parent_instructions;
               body.emit(f1E78);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1E76->else_instructions;

               body.emit(assign(r1E66, body.constant(1073741824u), 0x02));

               ir_variable *const r1E86 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r1E86, body.constant(1073741824u), 0x01));

               ir_variable *const r1E87 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r1E87, body.constant(0u), 0x01));

               ir_variable *const r1E88 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1E88);
               ir_variable *const r1E89 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1E89);
               ir_variable *const r1E8A = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1E8B = neg(r1E64);
               body.emit(assign(r1E8A, bit_and(r1E8B, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1E8D = equal(r1E64, body.constant(int(0)));
               ir_if *f1E8C = new(mem_ctx) ir_if(operand(r1E8D).val);
               exec_list *const f1E8C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E8C->then_instructions;

                  body.emit(assign(r1E88, r1E87, 0x01));

                  body.emit(assign(r1E89, r1E86, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1E8C->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1E8F = less(r1E64, body.constant(int(32)));
                  ir_if *f1E8E = new(mem_ctx) ir_if(operand(r1E8F).val);
                  exec_list *const f1E8E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E8E->then_instructions;

                     ir_expression *const r1E90 = lshift(body.constant(1073741824u), r1E8A);
                     ir_expression *const r1E91 = bit_or(r1E90, body.constant(0u));
                     body.emit(assign(r1E88, bit_or(r1E91, body.constant(0u)), 0x01));

                     body.emit(assign(r1E89, rshift(body.constant(1073741824u), r1E64), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E8E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1E93 = equal(r1E64, body.constant(int(32)));
                     ir_if *f1E92 = new(mem_ctx) ir_if(operand(r1E93).val);
                     exec_list *const f1E92_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E92->then_instructions;

                        body.emit(assign(r1E88, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E92->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1E95 = less(r1E64, body.constant(int(64)));
                        ir_if *f1E94 = new(mem_ctx) ir_if(operand(r1E95).val);
                        exec_list *const f1E94_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E94->then_instructions;

                           ir_expression *const r1E96 = bit_and(r1E64, body.constant(int(31)));
                           ir_expression *const r1E97 = rshift(body.constant(1073741824u), r1E96);
                           ir_expression *const r1E98 = lshift(body.constant(1073741824u), r1E8A);
                           ir_expression *const r1E99 = bit_or(r1E98, body.constant(0u));
                           ir_expression *const r1E9A = nequal(r1E99, body.constant(0u));
                           ir_expression *const r1E9B = expr(ir_unop_b2i, r1E9A);
                           ir_expression *const r1E9C = expr(ir_unop_i2u, r1E9B);
                           body.emit(assign(r1E88, bit_or(r1E97, r1E9C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E94->else_instructions;

                           body.emit(assign(r1E88, body.constant(1u), 0x01));


                        body.instructions = f1E94_parent_instructions;
                        body.emit(f1E94);

                        /* END IF */


                     body.instructions = f1E92_parent_instructions;
                     body.emit(f1E92);

                     /* END IF */

                     body.emit(assign(r1E89, body.constant(0u), 0x01));


                  body.instructions = f1E8E_parent_instructions;
                  body.emit(f1E8E);

                  /* END IF */


               body.instructions = f1E8C_parent_instructions;
               body.emit(f1E8C);

               /* END IF */

               body.emit(assign(r1E66, r1E89, 0x02));

               body.emit(assign(r1E66, r1E88, 0x01));

               body.emit(assign(r1E68, bit_or(r1E70, body.constant(1073741824u)), 0x02));

               ir_variable *const r1E9D = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1E9E = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1E9E, sub(r1E6F, r1E88), 0x01));

               ir_expression *const r1E9F = sub(swizzle_y(r1E68), r1E89);
               ir_expression *const r1EA0 = less(r1E6F, r1E88);
               ir_expression *const r1EA1 = expr(ir_unop_b2i, r1EA0);
               ir_expression *const r1EA2 = expr(ir_unop_i2u, r1EA1);
               body.emit(assign(r1E9D, sub(r1E9F, r1EA2), 0x01));

               body.emit(assign(r1E69, add(r1E6B, body.constant(int(-1))), 0x01));

               ir_variable *const r1EA3 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1EA3, add(r1E69, body.constant(int(-10))), 0x01));

               ir_variable *const r1EA4 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1EA4, r1E9D, 0x01));

               ir_variable *const r1EA5 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1EA5, r1E9E, 0x01));

               ir_variable *const r1EA6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1EA6);
               ir_variable *const r1EA7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1EA7);
               /* IF CONDITION */
               ir_expression *const r1EA9 = equal(r1E9D, body.constant(0u));
               ir_if *f1EA8 = new(mem_ctx) ir_if(operand(r1EA9).val);
               exec_list *const f1EA8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1EA8->then_instructions;

                  body.emit(assign(r1EA4, r1E9E, 0x01));

                  body.emit(assign(r1EA5, body.constant(0u), 0x01));

                  body.emit(assign(r1EA3, add(r1EA3, body.constant(int(-32))), 0x01));


               body.instructions = f1EA8_parent_instructions;
               body.emit(f1EA8);

               /* END IF */

               ir_variable *const r1EAA = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1EAA, r1EA4, 0x01));

               ir_variable *const r1EAB = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1EAC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1EAC);
               /* IF CONDITION */
               ir_expression *const r1EAE = equal(r1EA4, body.constant(0u));
               ir_if *f1EAD = new(mem_ctx) ir_if(operand(r1EAE).val);
               exec_list *const f1EAD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1EAD->then_instructions;

                  body.emit(assign(r1EAB, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1EAD->else_instructions;

                  body.emit(assign(r1EAC, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1EB0 = bit_and(r1EA4, body.constant(4294901760u));
                  ir_expression *const r1EB1 = equal(r1EB0, body.constant(0u));
                  ir_if *f1EAF = new(mem_ctx) ir_if(operand(r1EB1).val);
                  exec_list *const f1EAF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EAF->then_instructions;

                     body.emit(assign(r1EAC, body.constant(int(16)), 0x01));

                     body.emit(assign(r1EAA, lshift(r1EA4, body.constant(int(16))), 0x01));


                  body.instructions = f1EAF_parent_instructions;
                  body.emit(f1EAF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1EB3 = bit_and(r1EAA, body.constant(4278190080u));
                  ir_expression *const r1EB4 = equal(r1EB3, body.constant(0u));
                  ir_if *f1EB2 = new(mem_ctx) ir_if(operand(r1EB4).val);
                  exec_list *const f1EB2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EB2->then_instructions;

                     body.emit(assign(r1EAC, add(r1EAC, body.constant(int(8))), 0x01));

                     body.emit(assign(r1EAA, lshift(r1EAA, body.constant(int(8))), 0x01));


                  body.instructions = f1EB2_parent_instructions;
                  body.emit(f1EB2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1EB6 = bit_and(r1EAA, body.constant(4026531840u));
                  ir_expression *const r1EB7 = equal(r1EB6, body.constant(0u));
                  ir_if *f1EB5 = new(mem_ctx) ir_if(operand(r1EB7).val);
                  exec_list *const f1EB5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EB5->then_instructions;

                     body.emit(assign(r1EAC, add(r1EAC, body.constant(int(4))), 0x01));

                     body.emit(assign(r1EAA, lshift(r1EAA, body.constant(int(4))), 0x01));


                  body.instructions = f1EB5_parent_instructions;
                  body.emit(f1EB5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1EB9 = bit_and(r1EAA, body.constant(3221225472u));
                  ir_expression *const r1EBA = equal(r1EB9, body.constant(0u));
                  ir_if *f1EB8 = new(mem_ctx) ir_if(operand(r1EBA).val);
                  exec_list *const f1EB8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EB8->then_instructions;

                     body.emit(assign(r1EAC, add(r1EAC, body.constant(int(2))), 0x01));

                     body.emit(assign(r1EAA, lshift(r1EAA, body.constant(int(2))), 0x01));


                  body.instructions = f1EB8_parent_instructions;
                  body.emit(f1EB8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1EBC = bit_and(r1EAA, body.constant(2147483648u));
                  ir_expression *const r1EBD = equal(r1EBC, body.constant(0u));
                  ir_if *f1EBB = new(mem_ctx) ir_if(operand(r1EBD).val);
                  exec_list *const f1EBB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EBB->then_instructions;

                     body.emit(assign(r1EAC, add(r1EAC, body.constant(int(1))), 0x01));


                  body.instructions = f1EBB_parent_instructions;
                  body.emit(f1EBB);

                  /* END IF */

                  body.emit(assign(r1EAB, r1EAC, 0x01));


               body.instructions = f1EAD_parent_instructions;
               body.emit(f1EAD);

               /* END IF */

               body.emit(assign(r1EA7, add(r1EAB, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1EBF = lequal(body.constant(int(0)), r1EA7);
               ir_if *f1EBE = new(mem_ctx) ir_if(operand(r1EBF).val);
               exec_list *const f1EBE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1EBE->then_instructions;

                  body.emit(assign(r1EA6, body.constant(0u), 0x01));

                  ir_variable *const r1EC0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1EC0, lshift(r1EA5, r1EA7), 0x01));

                  ir_variable *const r1EC1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1EC3 = equal(r1EA7, body.constant(int(0)));
                  ir_if *f1EC2 = new(mem_ctx) ir_if(operand(r1EC3).val);
                  exec_list *const f1EC2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EC2->then_instructions;

                     body.emit(assign(r1EC1, r1EA4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1EC2->else_instructions;

                     ir_expression *const r1EC4 = lshift(r1EA4, r1EA7);
                     ir_expression *const r1EC5 = neg(r1EA7);
                     ir_expression *const r1EC6 = bit_and(r1EC5, body.constant(int(31)));
                     ir_expression *const r1EC7 = rshift(r1EA5, r1EC6);
                     body.emit(assign(r1EC1, bit_or(r1EC4, r1EC7), 0x01));


                  body.instructions = f1EC2_parent_instructions;
                  body.emit(f1EC2);

                  /* END IF */

                  body.emit(assign(r1EA4, r1EC1, 0x01));

                  body.emit(assign(r1EA5, r1EC0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1EBE->else_instructions;

                  ir_variable *const r1EC8 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1EC8, body.constant(0u), 0x01));

                  ir_variable *const r1EC9 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1EC9, neg(r1EA7), 0x01));

                  ir_variable *const r1ECA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1ECA);
                  ir_variable *const r1ECB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1ECB);
                  ir_variable *const r1ECC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1ECC);
                  ir_variable *const r1ECD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1ECE = neg(r1EC9);
                  body.emit(assign(r1ECD, bit_and(r1ECE, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1ED0 = equal(r1EC9, body.constant(int(0)));
                  ir_if *f1ECF = new(mem_ctx) ir_if(operand(r1ED0).val);
                  exec_list *const f1ECF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1ECF->then_instructions;

                     body.emit(assign(r1ECA, r1EC8, 0x01));

                     body.emit(assign(r1ECB, r1EA5, 0x01));

                     body.emit(assign(r1ECC, r1EA4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1ECF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1ED2 = less(r1EC9, body.constant(int(32)));
                     ir_if *f1ED1 = new(mem_ctx) ir_if(operand(r1ED2).val);
                     exec_list *const f1ED1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1ED1->then_instructions;

                        body.emit(assign(r1ECA, lshift(r1EA5, r1ECD), 0x01));

                        ir_expression *const r1ED3 = lshift(r1EA4, r1ECD);
                        ir_expression *const r1ED4 = rshift(r1EA5, r1EC9);
                        body.emit(assign(r1ECB, bit_or(r1ED3, r1ED4), 0x01));

                        body.emit(assign(r1ECC, rshift(r1EA4, r1EC9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1ED1->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1ED6 = equal(r1EC9, body.constant(int(32)));
                        ir_if *f1ED5 = new(mem_ctx) ir_if(operand(r1ED6).val);
                        exec_list *const f1ED5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1ED5->then_instructions;

                           body.emit(assign(r1ECA, r1EA5, 0x01));

                           body.emit(assign(r1ECB, r1EA4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1ED5->else_instructions;

                           body.emit(assign(r1EC8, bit_or(body.constant(0u), r1EA5), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1ED8 = less(r1EC9, body.constant(int(64)));
                           ir_if *f1ED7 = new(mem_ctx) ir_if(operand(r1ED8).val);
                           exec_list *const f1ED7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1ED7->then_instructions;

                              body.emit(assign(r1ECA, lshift(r1EA4, r1ECD), 0x01));

                              ir_expression *const r1ED9 = bit_and(r1EC9, body.constant(int(31)));
                              body.emit(assign(r1ECB, rshift(r1EA4, r1ED9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1ED7->else_instructions;

                              ir_variable *const r1EDA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1EDC = equal(r1EC9, body.constant(int(64)));
                              ir_if *f1EDB = new(mem_ctx) ir_if(operand(r1EDC).val);
                              exec_list *const f1EDB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1EDB->then_instructions;

                                 body.emit(assign(r1EDA, r1EA4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1EDB->else_instructions;

                                 ir_expression *const r1EDD = nequal(r1EA4, body.constant(0u));
                                 ir_expression *const r1EDE = expr(ir_unop_b2i, r1EDD);
                                 body.emit(assign(r1EDA, expr(ir_unop_i2u, r1EDE), 0x01));


                              body.instructions = f1EDB_parent_instructions;
                              body.emit(f1EDB);

                              /* END IF */

                              body.emit(assign(r1ECA, r1EDA, 0x01));

                              body.emit(assign(r1ECB, body.constant(0u), 0x01));


                           body.instructions = f1ED7_parent_instructions;
                           body.emit(f1ED7);

                           /* END IF */


                        body.instructions = f1ED5_parent_instructions;
                        body.emit(f1ED5);

                        /* END IF */

                        body.emit(assign(r1ECC, body.constant(0u), 0x01));


                     body.instructions = f1ED1_parent_instructions;
                     body.emit(f1ED1);

                     /* END IF */

                     ir_expression *const r1EDF = nequal(r1EC8, body.constant(0u));
                     ir_expression *const r1EE0 = expr(ir_unop_b2i, r1EDF);
                     ir_expression *const r1EE1 = expr(ir_unop_i2u, r1EE0);
                     body.emit(assign(r1ECA, bit_or(r1ECA, r1EE1), 0x01));


                  body.instructions = f1ECF_parent_instructions;
                  body.emit(f1ECF);

                  /* END IF */

                  body.emit(assign(r1EA4, r1ECC, 0x01));

                  body.emit(assign(r1EA5, r1ECB, 0x01));

                  body.emit(assign(r1EA6, r1ECA, 0x01));


               body.instructions = f1EBE_parent_instructions;
               body.emit(f1EBE);

               /* END IF */

               body.emit(assign(r1EA3, sub(r1EA3, r1EA7), 0x01));

               ir_variable *const r1EE2 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1EE2, r1EA3, 0x01));

               ir_variable *const r1EE3 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1EE3, r1EA4, 0x01));

               ir_variable *const r1EE4 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1EE4, r1EA5, 0x01));

               ir_variable *const r1EE5 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1EE5, r1EA6, 0x01));

               ir_variable *const r1EE6 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1EE6, body.constant(true), 0x01));

               ir_variable *const r1EE7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1EE8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1EE8);
               ir_expression *const r1EE9 = expr(ir_unop_u2i, r1EA6);
               body.emit(assign(r1EE8, less(r1EE9, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1EEB = lequal(body.constant(int(2045)), r1EA3);
               ir_if *f1EEA = new(mem_ctx) ir_if(operand(r1EEB).val);
               exec_list *const f1EEA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1EEA->then_instructions;

                  ir_variable *const r1EEC = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1EEE = less(body.constant(int(2045)), r1EA3);
                  ir_if *f1EED = new(mem_ctx) ir_if(operand(r1EEE).val);
                  exec_list *const f1EED_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EED->then_instructions;

                     body.emit(assign(r1EEC, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1EED->else_instructions;

                     ir_variable *const r1EEF = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1EF1 = equal(r1EA3, body.constant(int(2045)));
                     ir_if *f1EF0 = new(mem_ctx) ir_if(operand(r1EF1).val);
                     exec_list *const f1EF0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1EF0->then_instructions;

                        ir_expression *const r1EF2 = equal(body.constant(2097151u), r1EA4);
                        ir_expression *const r1EF3 = equal(body.constant(4294967295u), r1EA5);
                        body.emit(assign(r1EEF, logic_and(r1EF2, r1EF3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1EF0->else_instructions;

                        body.emit(assign(r1EEF, body.constant(false), 0x01));


                     body.instructions = f1EF0_parent_instructions;
                     body.emit(f1EF0);

                     /* END IF */

                     body.emit(assign(r1EEC, logic_and(r1EEF, r1EE8), 0x01));


                  body.instructions = f1EED_parent_instructions;
                  body.emit(f1EED);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1EF4 = new(mem_ctx) ir_if(operand(r1EEC).val);
                  exec_list *const f1EF4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EF4->then_instructions;

                     ir_variable *const r1EF5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1EF5);
                     ir_expression *const r1EF6 = lshift(r1E5F, body.constant(int(31)));
                     body.emit(assign(r1EF5, add(r1EF6, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1EF5, body.constant(0u), 0x01));

                     body.emit(assign(r1EE7, r1EF5, 0x03));

                     body.emit(assign(r1EE6, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1EF4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1EF8 = less(r1EA3, body.constant(int(0)));
                     ir_if *f1EF7 = new(mem_ctx) ir_if(operand(r1EF8).val);
                     exec_list *const f1EF7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1EF7->then_instructions;

                        ir_variable *const r1EF9 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1EF9, r1EA6, 0x01));

                        ir_variable *const r1EFA = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1EFA, neg(r1EA3), 0x01));

                        ir_variable *const r1EFB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1EFB);
                        ir_variable *const r1EFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1EFC);
                        ir_variable *const r1EFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1EFD);
                        ir_variable *const r1EFE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1EFF = neg(r1EFA);
                        body.emit(assign(r1EFE, bit_and(r1EFF, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1F01 = equal(r1EFA, body.constant(int(0)));
                        ir_if *f1F00 = new(mem_ctx) ir_if(operand(r1F01).val);
                        exec_list *const f1F00_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F00->then_instructions;

                           body.emit(assign(r1EFB, r1EA6, 0x01));

                           body.emit(assign(r1EFC, r1EA5, 0x01));

                           body.emit(assign(r1EFD, r1EA4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1F00->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1F03 = less(r1EFA, body.constant(int(32)));
                           ir_if *f1F02 = new(mem_ctx) ir_if(operand(r1F03).val);
                           exec_list *const f1F02_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F02->then_instructions;

                              body.emit(assign(r1EFB, lshift(r1EA5, r1EFE), 0x01));

                              ir_expression *const r1F04 = lshift(r1EA4, r1EFE);
                              ir_expression *const r1F05 = rshift(r1EA5, r1EFA);
                              body.emit(assign(r1EFC, bit_or(r1F04, r1F05), 0x01));

                              body.emit(assign(r1EFD, rshift(r1EA4, r1EFA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F02->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1F07 = equal(r1EFA, body.constant(int(32)));
                              ir_if *f1F06 = new(mem_ctx) ir_if(operand(r1F07).val);
                              exec_list *const f1F06_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F06->then_instructions;

                                 body.emit(assign(r1EFB, r1EA5, 0x01));

                                 body.emit(assign(r1EFC, r1EA4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F06->else_instructions;

                                 body.emit(assign(r1EF9, bit_or(r1EA6, r1EA5), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1F09 = less(r1EFA, body.constant(int(64)));
                                 ir_if *f1F08 = new(mem_ctx) ir_if(operand(r1F09).val);
                                 exec_list *const f1F08_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1F08->then_instructions;

                                    body.emit(assign(r1EFB, lshift(r1EA4, r1EFE), 0x01));

                                    ir_expression *const r1F0A = bit_and(r1EFA, body.constant(int(31)));
                                    body.emit(assign(r1EFC, rshift(r1EA4, r1F0A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1F08->else_instructions;

                                    ir_variable *const r1F0B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1F0D = equal(r1EFA, body.constant(int(64)));
                                    ir_if *f1F0C = new(mem_ctx) ir_if(operand(r1F0D).val);
                                    exec_list *const f1F0C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1F0C->then_instructions;

                                       body.emit(assign(r1F0B, r1EA4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1F0C->else_instructions;

                                       ir_expression *const r1F0E = nequal(r1EA4, body.constant(0u));
                                       ir_expression *const r1F0F = expr(ir_unop_b2i, r1F0E);
                                       body.emit(assign(r1F0B, expr(ir_unop_i2u, r1F0F), 0x01));


                                    body.instructions = f1F0C_parent_instructions;
                                    body.emit(f1F0C);

                                    /* END IF */

                                    body.emit(assign(r1EFB, r1F0B, 0x01));

                                    body.emit(assign(r1EFC, body.constant(0u), 0x01));


                                 body.instructions = f1F08_parent_instructions;
                                 body.emit(f1F08);

                                 /* END IF */


                              body.instructions = f1F06_parent_instructions;
                              body.emit(f1F06);

                              /* END IF */

                              body.emit(assign(r1EFD, body.constant(0u), 0x01));


                           body.instructions = f1F02_parent_instructions;
                           body.emit(f1F02);

                           /* END IF */

                           ir_expression *const r1F10 = nequal(r1EF9, body.constant(0u));
                           ir_expression *const r1F11 = expr(ir_unop_b2i, r1F10);
                           ir_expression *const r1F12 = expr(ir_unop_i2u, r1F11);
                           body.emit(assign(r1EFB, bit_or(r1EFB, r1F12), 0x01));


                        body.instructions = f1F00_parent_instructions;
                        body.emit(f1F00);

                        /* END IF */

                        body.emit(assign(r1EE3, r1EFD, 0x01));

                        body.emit(assign(r1EE4, r1EFC, 0x01));

                        body.emit(assign(r1EE5, r1EFB, 0x01));

                        body.emit(assign(r1EE2, body.constant(int(0)), 0x01));

                        body.emit(assign(r1EE8, less(r1EFB, body.constant(0u)), 0x01));


                     body.instructions = f1EF7_parent_instructions;
                     body.emit(f1EF7);

                     /* END IF */


                  body.instructions = f1EF4_parent_instructions;
                  body.emit(f1EF4);

                  /* END IF */


               body.instructions = f1EEA_parent_instructions;
               body.emit(f1EEA);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1F13 = new(mem_ctx) ir_if(operand(r1EE6).val);
               exec_list *const f1F13_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F13->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1F14 = new(mem_ctx) ir_if(operand(r1EE8).val);
                  exec_list *const f1F14_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F14->then_instructions;

                     ir_variable *const r1F15 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1F15, add(r1EE4, body.constant(1u)), 0x01));

                     ir_expression *const r1F16 = less(r1F15, r1EE4);
                     ir_expression *const r1F17 = expr(ir_unop_b2i, r1F16);
                     ir_expression *const r1F18 = expr(ir_unop_i2u, r1F17);
                     body.emit(assign(r1EE3, add(r1EE3, r1F18), 0x01));

                     ir_expression *const r1F19 = equal(r1EE5, body.constant(0u));
                     ir_expression *const r1F1A = expr(ir_unop_b2i, r1F19);
                     ir_expression *const r1F1B = expr(ir_unop_i2u, r1F1A);
                     ir_expression *const r1F1C = add(r1EE5, r1F1B);
                     ir_expression *const r1F1D = bit_and(r1F1C, body.constant(1u));
                     ir_expression *const r1F1E = expr(ir_unop_bit_not, r1F1D);
                     body.emit(assign(r1EE4, bit_and(r1F15, r1F1E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F14->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1F20 = bit_or(r1EE3, r1EE4);
                     ir_expression *const r1F21 = equal(r1F20, body.constant(0u));
                     ir_if *f1F1F = new(mem_ctx) ir_if(operand(r1F21).val);
                     exec_list *const f1F1F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F1F->then_instructions;

                        body.emit(assign(r1EE2, body.constant(int(0)), 0x01));


                     body.instructions = f1F1F_parent_instructions;
                     body.emit(f1F1F);

                     /* END IF */


                  body.instructions = f1F14_parent_instructions;
                  body.emit(f1F14);

                  /* END IF */

                  ir_variable *const r1F22 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1F22);
                  ir_expression *const r1F23 = lshift(r1E5F, body.constant(int(31)));
                  ir_expression *const r1F24 = expr(ir_unop_i2u, r1EE2);
                  ir_expression *const r1F25 = lshift(r1F24, body.constant(int(20)));
                  ir_expression *const r1F26 = add(r1F23, r1F25);
                  body.emit(assign(r1F22, add(r1F26, r1EE3), 0x02));

                  body.emit(assign(r1F22, r1EE4, 0x01));

                  body.emit(assign(r1EE7, r1F22, 0x03));

                  body.emit(assign(r1EE6, body.constant(false), 0x01));


               body.instructions = f1F13_parent_instructions;
               body.emit(f1F13);

               /* END IF */

               body.emit(assign(r1E63, r1EE7, 0x03));


            body.instructions = f1E76_parent_instructions;
            body.emit(f1E76);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1E74->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1F28 = less(r1E64, body.constant(int(0)));
            ir_if *f1F27 = new(mem_ctx) ir_if(operand(r1F28).val);
            exec_list *const f1F27_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1F27->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1F2A = equal(r1E6B, body.constant(int(0)));
               ir_if *f1F29 = new(mem_ctx) ir_if(operand(r1F2A).val);
               exec_list *const f1F29_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F29->then_instructions;

                  body.emit(assign(r1E64, add(r1E64, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F29->else_instructions;

                  body.emit(assign(r1E68, bit_or(swizzle_y(r1E68), body.constant(1073741824u)), 0x02));


               body.instructions = f1F29_parent_instructions;
               body.emit(f1F29);

               /* END IF */

               ir_variable *const r1F2B = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r1F2B, swizzle_y(r1E68), 0x01));

               ir_variable *const r1F2C = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r1F2C, swizzle_x(r1E68), 0x01));

               ir_variable *const r1F2D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1F2D, neg(r1E64), 0x01));

               ir_variable *const r1F2E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1F2E);
               ir_variable *const r1F2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1F2F);
               ir_variable *const r1F30 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1F31 = neg(r1F2D);
               body.emit(assign(r1F30, bit_and(r1F31, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1F33 = equal(r1F2D, body.constant(int(0)));
               ir_if *f1F32 = new(mem_ctx) ir_if(operand(r1F33).val);
               exec_list *const f1F32_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F32->then_instructions;

                  body.emit(assign(r1F2E, r1F2C, 0x01));

                  body.emit(assign(r1F2F, r1F2B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F32->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1F35 = less(r1F2D, body.constant(int(32)));
                  ir_if *f1F34 = new(mem_ctx) ir_if(operand(r1F35).val);
                  exec_list *const f1F34_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F34->then_instructions;

                     ir_expression *const r1F36 = lshift(swizzle_y(r1E68), r1F30);
                     ir_expression *const r1F37 = rshift(r1E6F, r1F2D);
                     ir_expression *const r1F38 = bit_or(r1F36, r1F37);
                     ir_expression *const r1F39 = lshift(r1E6F, r1F30);
                     ir_expression *const r1F3A = nequal(r1F39, body.constant(0u));
                     ir_expression *const r1F3B = expr(ir_unop_b2i, r1F3A);
                     ir_expression *const r1F3C = expr(ir_unop_i2u, r1F3B);
                     body.emit(assign(r1F2E, bit_or(r1F38, r1F3C), 0x01));

                     body.emit(assign(r1F2F, rshift(swizzle_y(r1E68), r1F2D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F34->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1F3E = equal(r1F2D, body.constant(int(32)));
                     ir_if *f1F3D = new(mem_ctx) ir_if(operand(r1F3E).val);
                     exec_list *const f1F3D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F3D->then_instructions;

                        ir_expression *const r1F3F = nequal(r1E6F, body.constant(0u));
                        ir_expression *const r1F40 = expr(ir_unop_b2i, r1F3F);
                        ir_expression *const r1F41 = expr(ir_unop_i2u, r1F40);
                        body.emit(assign(r1F2E, bit_or(swizzle_y(r1E68), r1F41), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1F3D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1F43 = less(r1F2D, body.constant(int(64)));
                        ir_if *f1F42 = new(mem_ctx) ir_if(operand(r1F43).val);
                        exec_list *const f1F42_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F42->then_instructions;

                           ir_expression *const r1F44 = bit_and(r1F2D, body.constant(int(31)));
                           ir_expression *const r1F45 = rshift(swizzle_y(r1E68), r1F44);
                           ir_expression *const r1F46 = lshift(swizzle_y(r1E68), r1F30);
                           ir_expression *const r1F47 = bit_or(r1F46, r1E6F);
                           ir_expression *const r1F48 = nequal(r1F47, body.constant(0u));
                           ir_expression *const r1F49 = expr(ir_unop_b2i, r1F48);
                           ir_expression *const r1F4A = expr(ir_unop_i2u, r1F49);
                           body.emit(assign(r1F2E, bit_or(r1F45, r1F4A), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1F42->else_instructions;

                           ir_expression *const r1F4B = bit_or(swizzle_y(r1E68), r1E6F);
                           ir_expression *const r1F4C = nequal(r1F4B, body.constant(0u));
                           ir_expression *const r1F4D = expr(ir_unop_b2i, r1F4C);
                           body.emit(assign(r1F2E, expr(ir_unop_i2u, r1F4D), 0x01));


                        body.instructions = f1F42_parent_instructions;
                        body.emit(f1F42);

                        /* END IF */


                     body.instructions = f1F3D_parent_instructions;
                     body.emit(f1F3D);

                     /* END IF */

                     body.emit(assign(r1F2F, body.constant(0u), 0x01));


                  body.instructions = f1F34_parent_instructions;
                  body.emit(f1F34);

                  /* END IF */


               body.instructions = f1F32_parent_instructions;
               body.emit(f1F32);

               /* END IF */

               body.emit(assign(r1E68, r1F2F, 0x02));

               body.emit(assign(r1E68, r1F2E, 0x01));

               body.emit(assign(r1E66, bit_or(swizzle_y(r1E66), body.constant(1073741824u)), 0x02));

               ir_variable *const r1F4E = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1F4F = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1F4F, sub(swizzle_x(r1E66), r1F2E), 0x01));

               ir_expression *const r1F50 = sub(swizzle_y(r1E66), r1F2F);
               ir_expression *const r1F51 = less(swizzle_x(r1E66), r1F2E);
               ir_expression *const r1F52 = expr(ir_unop_b2i, r1F51);
               ir_expression *const r1F53 = expr(ir_unop_i2u, r1F52);
               body.emit(assign(r1F4E, sub(r1F50, r1F53), 0x01));

               body.emit(assign(r1E62, bit_xor(r1E5F, body.constant(1u)), 0x01));

               body.emit(assign(r1E69, body.constant(int(1022)), 0x01));

               ir_variable *const r1F54 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1F54, body.constant(int(1012)), 0x01));

               ir_variable *const r1F55 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1F55, r1F4E, 0x01));

               ir_variable *const r1F56 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1F56, r1F4F, 0x01));

               ir_variable *const r1F57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1F57);
               ir_variable *const r1F58 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1F58);
               /* IF CONDITION */
               ir_expression *const r1F5A = equal(r1F4E, body.constant(0u));
               ir_if *f1F59 = new(mem_ctx) ir_if(operand(r1F5A).val);
               exec_list *const f1F59_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F59->then_instructions;

                  body.emit(assign(r1F55, r1F4F, 0x01));

                  body.emit(assign(r1F56, body.constant(0u), 0x01));

                  body.emit(assign(r1F54, body.constant(int(980)), 0x01));


               body.instructions = f1F59_parent_instructions;
               body.emit(f1F59);

               /* END IF */

               ir_variable *const r1F5B = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1F5B, r1F55, 0x01));

               ir_variable *const r1F5C = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1F5D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1F5D);
               /* IF CONDITION */
               ir_expression *const r1F5F = equal(r1F55, body.constant(0u));
               ir_if *f1F5E = new(mem_ctx) ir_if(operand(r1F5F).val);
               exec_list *const f1F5E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F5E->then_instructions;

                  body.emit(assign(r1F5C, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F5E->else_instructions;

                  body.emit(assign(r1F5D, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1F61 = bit_and(r1F55, body.constant(4294901760u));
                  ir_expression *const r1F62 = equal(r1F61, body.constant(0u));
                  ir_if *f1F60 = new(mem_ctx) ir_if(operand(r1F62).val);
                  exec_list *const f1F60_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F60->then_instructions;

                     body.emit(assign(r1F5D, body.constant(int(16)), 0x01));

                     body.emit(assign(r1F5B, lshift(r1F55, body.constant(int(16))), 0x01));


                  body.instructions = f1F60_parent_instructions;
                  body.emit(f1F60);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1F64 = bit_and(r1F5B, body.constant(4278190080u));
                  ir_expression *const r1F65 = equal(r1F64, body.constant(0u));
                  ir_if *f1F63 = new(mem_ctx) ir_if(operand(r1F65).val);
                  exec_list *const f1F63_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F63->then_instructions;

                     body.emit(assign(r1F5D, add(r1F5D, body.constant(int(8))), 0x01));

                     body.emit(assign(r1F5B, lshift(r1F5B, body.constant(int(8))), 0x01));


                  body.instructions = f1F63_parent_instructions;
                  body.emit(f1F63);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1F67 = bit_and(r1F5B, body.constant(4026531840u));
                  ir_expression *const r1F68 = equal(r1F67, body.constant(0u));
                  ir_if *f1F66 = new(mem_ctx) ir_if(operand(r1F68).val);
                  exec_list *const f1F66_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F66->then_instructions;

                     body.emit(assign(r1F5D, add(r1F5D, body.constant(int(4))), 0x01));

                     body.emit(assign(r1F5B, lshift(r1F5B, body.constant(int(4))), 0x01));


                  body.instructions = f1F66_parent_instructions;
                  body.emit(f1F66);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1F6A = bit_and(r1F5B, body.constant(3221225472u));
                  ir_expression *const r1F6B = equal(r1F6A, body.constant(0u));
                  ir_if *f1F69 = new(mem_ctx) ir_if(operand(r1F6B).val);
                  exec_list *const f1F69_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F69->then_instructions;

                     body.emit(assign(r1F5D, add(r1F5D, body.constant(int(2))), 0x01));

                     body.emit(assign(r1F5B, lshift(r1F5B, body.constant(int(2))), 0x01));


                  body.instructions = f1F69_parent_instructions;
                  body.emit(f1F69);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1F6D = bit_and(r1F5B, body.constant(2147483648u));
                  ir_expression *const r1F6E = equal(r1F6D, body.constant(0u));
                  ir_if *f1F6C = new(mem_ctx) ir_if(operand(r1F6E).val);
                  exec_list *const f1F6C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F6C->then_instructions;

                     body.emit(assign(r1F5D, add(r1F5D, body.constant(int(1))), 0x01));


                  body.instructions = f1F6C_parent_instructions;
                  body.emit(f1F6C);

                  /* END IF */

                  body.emit(assign(r1F5C, r1F5D, 0x01));


               body.instructions = f1F5E_parent_instructions;
               body.emit(f1F5E);

               /* END IF */

               body.emit(assign(r1F58, add(r1F5C, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1F70 = lequal(body.constant(int(0)), r1F58);
               ir_if *f1F6F = new(mem_ctx) ir_if(operand(r1F70).val);
               exec_list *const f1F6F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F6F->then_instructions;

                  body.emit(assign(r1F57, body.constant(0u), 0x01));

                  ir_variable *const r1F71 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1F71, lshift(r1F56, r1F58), 0x01));

                  ir_variable *const r1F72 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1F74 = equal(r1F58, body.constant(int(0)));
                  ir_if *f1F73 = new(mem_ctx) ir_if(operand(r1F74).val);
                  exec_list *const f1F73_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F73->then_instructions;

                     body.emit(assign(r1F72, r1F55, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F73->else_instructions;

                     ir_expression *const r1F75 = lshift(r1F55, r1F58);
                     ir_expression *const r1F76 = neg(r1F58);
                     ir_expression *const r1F77 = bit_and(r1F76, body.constant(int(31)));
                     ir_expression *const r1F78 = rshift(r1F56, r1F77);
                     body.emit(assign(r1F72, bit_or(r1F75, r1F78), 0x01));


                  body.instructions = f1F73_parent_instructions;
                  body.emit(f1F73);

                  /* END IF */

                  body.emit(assign(r1F55, r1F72, 0x01));

                  body.emit(assign(r1F56, r1F71, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F6F->else_instructions;

                  ir_variable *const r1F79 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1F79, body.constant(0u), 0x01));

                  ir_variable *const r1F7A = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1F7A, neg(r1F58), 0x01));

                  ir_variable *const r1F7B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1F7B);
                  ir_variable *const r1F7C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1F7C);
                  ir_variable *const r1F7D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1F7D);
                  ir_variable *const r1F7E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1F7F = neg(r1F7A);
                  body.emit(assign(r1F7E, bit_and(r1F7F, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1F81 = equal(r1F7A, body.constant(int(0)));
                  ir_if *f1F80 = new(mem_ctx) ir_if(operand(r1F81).val);
                  exec_list *const f1F80_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F80->then_instructions;

                     body.emit(assign(r1F7B, r1F79, 0x01));

                     body.emit(assign(r1F7C, r1F56, 0x01));

                     body.emit(assign(r1F7D, r1F55, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F80->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1F83 = less(r1F7A, body.constant(int(32)));
                     ir_if *f1F82 = new(mem_ctx) ir_if(operand(r1F83).val);
                     exec_list *const f1F82_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F82->then_instructions;

                        body.emit(assign(r1F7B, lshift(r1F56, r1F7E), 0x01));

                        ir_expression *const r1F84 = lshift(r1F55, r1F7E);
                        ir_expression *const r1F85 = rshift(r1F56, r1F7A);
                        body.emit(assign(r1F7C, bit_or(r1F84, r1F85), 0x01));

                        body.emit(assign(r1F7D, rshift(r1F55, r1F7A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1F82->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1F87 = equal(r1F7A, body.constant(int(32)));
                        ir_if *f1F86 = new(mem_ctx) ir_if(operand(r1F87).val);
                        exec_list *const f1F86_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F86->then_instructions;

                           body.emit(assign(r1F7B, r1F56, 0x01));

                           body.emit(assign(r1F7C, r1F55, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1F86->else_instructions;

                           body.emit(assign(r1F79, bit_or(body.constant(0u), r1F56), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1F89 = less(r1F7A, body.constant(int(64)));
                           ir_if *f1F88 = new(mem_ctx) ir_if(operand(r1F89).val);
                           exec_list *const f1F88_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F88->then_instructions;

                              body.emit(assign(r1F7B, lshift(r1F55, r1F7E), 0x01));

                              ir_expression *const r1F8A = bit_and(r1F7A, body.constant(int(31)));
                              body.emit(assign(r1F7C, rshift(r1F55, r1F8A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F88->else_instructions;

                              ir_variable *const r1F8B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1F8D = equal(r1F7A, body.constant(int(64)));
                              ir_if *f1F8C = new(mem_ctx) ir_if(operand(r1F8D).val);
                              exec_list *const f1F8C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F8C->then_instructions;

                                 body.emit(assign(r1F8B, r1F55, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F8C->else_instructions;

                                 ir_expression *const r1F8E = nequal(r1F55, body.constant(0u));
                                 ir_expression *const r1F8F = expr(ir_unop_b2i, r1F8E);
                                 body.emit(assign(r1F8B, expr(ir_unop_i2u, r1F8F), 0x01));


                              body.instructions = f1F8C_parent_instructions;
                              body.emit(f1F8C);

                              /* END IF */

                              body.emit(assign(r1F7B, r1F8B, 0x01));

                              body.emit(assign(r1F7C, body.constant(0u), 0x01));


                           body.instructions = f1F88_parent_instructions;
                           body.emit(f1F88);

                           /* END IF */


                        body.instructions = f1F86_parent_instructions;
                        body.emit(f1F86);

                        /* END IF */

                        body.emit(assign(r1F7D, body.constant(0u), 0x01));


                     body.instructions = f1F82_parent_instructions;
                     body.emit(f1F82);

                     /* END IF */

                     ir_expression *const r1F90 = nequal(r1F79, body.constant(0u));
                     ir_expression *const r1F91 = expr(ir_unop_b2i, r1F90);
                     ir_expression *const r1F92 = expr(ir_unop_i2u, r1F91);
                     body.emit(assign(r1F7B, bit_or(r1F7B, r1F92), 0x01));


                  body.instructions = f1F80_parent_instructions;
                  body.emit(f1F80);

                  /* END IF */

                  body.emit(assign(r1F55, r1F7D, 0x01));

                  body.emit(assign(r1F56, r1F7C, 0x01));

                  body.emit(assign(r1F57, r1F7B, 0x01));


               body.instructions = f1F6F_parent_instructions;
               body.emit(f1F6F);

               /* END IF */

               body.emit(assign(r1F54, sub(r1F54, r1F58), 0x01));

               ir_variable *const r1F93 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1F93, r1F54, 0x01));

               ir_variable *const r1F94 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1F94, r1F55, 0x01));

               ir_variable *const r1F95 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1F95, r1F56, 0x01));

               ir_variable *const r1F96 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1F96, r1F57, 0x01));

               ir_variable *const r1F97 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1F97, body.constant(true), 0x01));

               ir_variable *const r1F98 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1F99 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1F99);
               ir_expression *const r1F9A = expr(ir_unop_u2i, r1F57);
               body.emit(assign(r1F99, less(r1F9A, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1F9C = lequal(body.constant(int(2045)), r1F54);
               ir_if *f1F9B = new(mem_ctx) ir_if(operand(r1F9C).val);
               exec_list *const f1F9B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F9B->then_instructions;

                  ir_variable *const r1F9D = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1F9F = less(body.constant(int(2045)), r1F54);
                  ir_if *f1F9E = new(mem_ctx) ir_if(operand(r1F9F).val);
                  exec_list *const f1F9E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F9E->then_instructions;

                     body.emit(assign(r1F9D, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F9E->else_instructions;

                     ir_variable *const r1FA0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1FA2 = equal(r1F54, body.constant(int(2045)));
                     ir_if *f1FA1 = new(mem_ctx) ir_if(operand(r1FA2).val);
                     exec_list *const f1FA1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FA1->then_instructions;

                        ir_expression *const r1FA3 = equal(body.constant(2097151u), r1F55);
                        ir_expression *const r1FA4 = equal(body.constant(4294967295u), r1F56);
                        body.emit(assign(r1FA0, logic_and(r1FA3, r1FA4), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1FA1->else_instructions;

                        body.emit(assign(r1FA0, body.constant(false), 0x01));


                     body.instructions = f1FA1_parent_instructions;
                     body.emit(f1FA1);

                     /* END IF */

                     body.emit(assign(r1F9D, logic_and(r1FA0, r1F99), 0x01));


                  body.instructions = f1F9E_parent_instructions;
                  body.emit(f1F9E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1FA5 = new(mem_ctx) ir_if(operand(r1F9D).val);
                  exec_list *const f1FA5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FA5->then_instructions;

                     ir_variable *const r1FA6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1FA6);
                     ir_expression *const r1FA7 = lshift(r1E62, body.constant(int(31)));
                     body.emit(assign(r1FA6, add(r1FA7, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1FA6, body.constant(0u), 0x01));

                     body.emit(assign(r1F98, r1FA6, 0x03));

                     body.emit(assign(r1F97, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1FA5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1FA9 = less(r1F54, body.constant(int(0)));
                     ir_if *f1FA8 = new(mem_ctx) ir_if(operand(r1FA9).val);
                     exec_list *const f1FA8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FA8->then_instructions;

                        ir_variable *const r1FAA = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1FAA, r1F57, 0x01));

                        ir_variable *const r1FAB = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1FAB, neg(r1F54), 0x01));

                        ir_variable *const r1FAC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1FAC);
                        ir_variable *const r1FAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1FAD);
                        ir_variable *const r1FAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1FAE);
                        ir_variable *const r1FAF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1FB0 = neg(r1FAB);
                        body.emit(assign(r1FAF, bit_and(r1FB0, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1FB2 = equal(r1FAB, body.constant(int(0)));
                        ir_if *f1FB1 = new(mem_ctx) ir_if(operand(r1FB2).val);
                        exec_list *const f1FB1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FB1->then_instructions;

                           body.emit(assign(r1FAC, r1F57, 0x01));

                           body.emit(assign(r1FAD, r1F56, 0x01));

                           body.emit(assign(r1FAE, r1F55, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1FB1->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1FB4 = less(r1FAB, body.constant(int(32)));
                           ir_if *f1FB3 = new(mem_ctx) ir_if(operand(r1FB4).val);
                           exec_list *const f1FB3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1FB3->then_instructions;

                              body.emit(assign(r1FAC, lshift(r1F56, r1FAF), 0x01));

                              ir_expression *const r1FB5 = lshift(r1F55, r1FAF);
                              ir_expression *const r1FB6 = rshift(r1F56, r1FAB);
                              body.emit(assign(r1FAD, bit_or(r1FB5, r1FB6), 0x01));

                              body.emit(assign(r1FAE, rshift(r1F55, r1FAB), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1FB3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1FB8 = equal(r1FAB, body.constant(int(32)));
                              ir_if *f1FB7 = new(mem_ctx) ir_if(operand(r1FB8).val);
                              exec_list *const f1FB7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FB7->then_instructions;

                                 body.emit(assign(r1FAC, r1F56, 0x01));

                                 body.emit(assign(r1FAD, r1F55, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FB7->else_instructions;

                                 body.emit(assign(r1FAA, bit_or(r1F57, r1F56), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1FBA = less(r1FAB, body.constant(int(64)));
                                 ir_if *f1FB9 = new(mem_ctx) ir_if(operand(r1FBA).val);
                                 exec_list *const f1FB9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FB9->then_instructions;

                                    body.emit(assign(r1FAC, lshift(r1F55, r1FAF), 0x01));

                                    ir_expression *const r1FBB = bit_and(r1FAB, body.constant(int(31)));
                                    body.emit(assign(r1FAD, rshift(r1F55, r1FBB), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1FB9->else_instructions;

                                    ir_variable *const r1FBC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1FBE = equal(r1FAB, body.constant(int(64)));
                                    ir_if *f1FBD = new(mem_ctx) ir_if(operand(r1FBE).val);
                                    exec_list *const f1FBD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1FBD->then_instructions;

                                       body.emit(assign(r1FBC, r1F55, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1FBD->else_instructions;

                                       ir_expression *const r1FBF = nequal(r1F55, body.constant(0u));
                                       ir_expression *const r1FC0 = expr(ir_unop_b2i, r1FBF);
                                       body.emit(assign(r1FBC, expr(ir_unop_i2u, r1FC0), 0x01));


                                    body.instructions = f1FBD_parent_instructions;
                                    body.emit(f1FBD);

                                    /* END IF */

                                    body.emit(assign(r1FAC, r1FBC, 0x01));

                                    body.emit(assign(r1FAD, body.constant(0u), 0x01));


                                 body.instructions = f1FB9_parent_instructions;
                                 body.emit(f1FB9);

                                 /* END IF */


                              body.instructions = f1FB7_parent_instructions;
                              body.emit(f1FB7);

                              /* END IF */

                              body.emit(assign(r1FAE, body.constant(0u), 0x01));


                           body.instructions = f1FB3_parent_instructions;
                           body.emit(f1FB3);

                           /* END IF */

                           ir_expression *const r1FC1 = nequal(r1FAA, body.constant(0u));
                           ir_expression *const r1FC2 = expr(ir_unop_b2i, r1FC1);
                           ir_expression *const r1FC3 = expr(ir_unop_i2u, r1FC2);
                           body.emit(assign(r1FAC, bit_or(r1FAC, r1FC3), 0x01));


                        body.instructions = f1FB1_parent_instructions;
                        body.emit(f1FB1);

                        /* END IF */

                        body.emit(assign(r1F94, r1FAE, 0x01));

                        body.emit(assign(r1F95, r1FAD, 0x01));

                        body.emit(assign(r1F96, r1FAC, 0x01));

                        body.emit(assign(r1F93, body.constant(int(0)), 0x01));

                        body.emit(assign(r1F99, less(r1FAC, body.constant(0u)), 0x01));


                     body.instructions = f1FA8_parent_instructions;
                     body.emit(f1FA8);

                     /* END IF */


                  body.instructions = f1FA5_parent_instructions;
                  body.emit(f1FA5);

                  /* END IF */


               body.instructions = f1F9B_parent_instructions;
               body.emit(f1F9B);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1FC4 = new(mem_ctx) ir_if(operand(r1F97).val);
               exec_list *const f1FC4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1FC4->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1FC5 = new(mem_ctx) ir_if(operand(r1F99).val);
                  exec_list *const f1FC5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FC5->then_instructions;

                     ir_variable *const r1FC6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1FC6, add(r1F95, body.constant(1u)), 0x01));

                     ir_expression *const r1FC7 = less(r1FC6, r1F95);
                     ir_expression *const r1FC8 = expr(ir_unop_b2i, r1FC7);
                     ir_expression *const r1FC9 = expr(ir_unop_i2u, r1FC8);
                     body.emit(assign(r1F94, add(r1F94, r1FC9), 0x01));

                     ir_expression *const r1FCA = equal(r1F96, body.constant(0u));
                     ir_expression *const r1FCB = expr(ir_unop_b2i, r1FCA);
                     ir_expression *const r1FCC = expr(ir_unop_i2u, r1FCB);
                     ir_expression *const r1FCD = add(r1F96, r1FCC);
                     ir_expression *const r1FCE = bit_and(r1FCD, body.constant(1u));
                     ir_expression *const r1FCF = expr(ir_unop_bit_not, r1FCE);
                     body.emit(assign(r1F95, bit_and(r1FC6, r1FCF), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1FC5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1FD1 = bit_or(r1F94, r1F95);
                     ir_expression *const r1FD2 = equal(r1FD1, body.constant(0u));
                     ir_if *f1FD0 = new(mem_ctx) ir_if(operand(r1FD2).val);
                     exec_list *const f1FD0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FD0->then_instructions;

                        body.emit(assign(r1F93, body.constant(int(0)), 0x01));


                     body.instructions = f1FD0_parent_instructions;
                     body.emit(f1FD0);

                     /* END IF */


                  body.instructions = f1FC5_parent_instructions;
                  body.emit(f1FC5);

                  /* END IF */

                  ir_variable *const r1FD3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1FD3);
                  ir_expression *const r1FD4 = lshift(r1E62, body.constant(int(31)));
                  ir_expression *const r1FD5 = expr(ir_unop_i2u, r1F93);
                  ir_expression *const r1FD6 = lshift(r1FD5, body.constant(int(20)));
                  ir_expression *const r1FD7 = add(r1FD4, r1FD6);
                  body.emit(assign(r1FD3, add(r1FD7, r1F94), 0x02));

                  body.emit(assign(r1FD3, r1F95, 0x01));

                  body.emit(assign(r1F98, r1FD3, 0x03));

                  body.emit(assign(r1F97, body.constant(false), 0x01));


               body.instructions = f1FC4_parent_instructions;
               body.emit(f1FC4);

               /* END IF */

               body.emit(assign(r1E63, r1F98, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1F27->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1FD9 = equal(r1E6B, body.constant(int(2047)));
               ir_if *f1FD8 = new(mem_ctx) ir_if(operand(r1FD9).val);
               exec_list *const f1FD8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1FD8->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1FDB = bit_or(swizzle_y(r1E68), swizzle_x(r1E68));
                  ir_expression *const r1FDC = bit_or(swizzle_y(r1E66), swizzle_x(r1E66));
                  ir_expression *const r1FDD = bit_or(r1FDB, r1FDC);
                  ir_expression *const r1FDE = nequal(r1FDD, body.constant(0u));
                  ir_if *f1FDA = new(mem_ctx) ir_if(operand(r1FDE).val);
                  exec_list *const f1FDA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FDA->then_instructions;

                     ir_variable *const r1FDF = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1FDF, swizzle_x(r1E29), 0x01));

                     ir_variable *const r1FE0 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1FE0, body.constant(0u), 0x01));

                     ir_variable *const r1FE1 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r1FDF, bit_or(swizzle_y(r1E29), body.constant(524288u)), 0x02));

                     body.emit(assign(r1FE0, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1FE3 = lshift(swizzle_y(r1E29), body.constant(int(1)));
                     ir_expression *const r1FE4 = lequal(body.constant(4292870144u), r1FE3);
                     ir_expression *const r1FE5 = nequal(swizzle_x(r1E29), body.constant(0u));
                     ir_expression *const r1FE6 = bit_and(swizzle_y(r1E29), body.constant(1048575u));
                     ir_expression *const r1FE7 = nequal(r1FE6, body.constant(0u));
                     ir_expression *const r1FE8 = logic_or(r1FE5, r1FE7);
                     ir_expression *const r1FE9 = logic_and(r1FE4, r1FE8);
                     ir_if *f1FE2 = new(mem_ctx) ir_if(operand(r1FE9).val);
                     exec_list *const f1FE2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FE2->then_instructions;

                        body.emit(assign(r1FE1, r1FDF, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1FE2->else_instructions;

                        body.emit(assign(r1FE1, r1FE0, 0x03));


                     body.instructions = f1FE2_parent_instructions;
                     body.emit(f1FE2);

                     /* END IF */

                     body.emit(assign(r1E63, r1FE1, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1FDA->else_instructions;

                     ir_constant_data r1FEA_data;
                     memset(&r1FEA_data, 0, sizeof(ir_constant_data));
                     r1FEA_data.u[0] = 4294967295;
                     r1FEA_data.u[1] = 4294967295;
                     ir_constant *const r1FEA = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1FEA_data);
                     body.emit(assign(r1E63, r1FEA, 0x03));


                  body.instructions = f1FDA_parent_instructions;
                  body.emit(f1FDA);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1FD8->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1FEC = equal(r1E6B, body.constant(int(0)));
                  ir_if *f1FEB = new(mem_ctx) ir_if(operand(r1FEC).val);
                  exec_list *const f1FEB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FEB->then_instructions;

                     body.emit(assign(r1E67, body.constant(int(1)), 0x01));

                     body.emit(assign(r1E65, body.constant(int(1)), 0x01));


                  body.instructions = f1FEB_parent_instructions;
                  body.emit(f1FEB);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1FEE = less(swizzle_y(r1E66), swizzle_y(r1E68));
                  ir_if *f1FED = new(mem_ctx) ir_if(operand(r1FEE).val);
                  exec_list *const f1FED_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FED->then_instructions;

                     ir_variable *const r1FEF = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r1FF0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1FF0, sub(swizzle_x(r1E68), swizzle_x(r1E66)), 0x01));

                     ir_expression *const r1FF1 = sub(swizzle_y(r1E68), swizzle_y(r1E66));
                     ir_expression *const r1FF2 = less(swizzle_x(r1E68), swizzle_x(r1E66));
                     ir_expression *const r1FF3 = expr(ir_unop_b2i, r1FF2);
                     ir_expression *const r1FF4 = expr(ir_unop_i2u, r1FF3);
                     body.emit(assign(r1FEF, sub(r1FF1, r1FF4), 0x01));

                     body.emit(assign(r1E69, add(r1E67, body.constant(int(-1))), 0x01));

                     ir_variable *const r1FF5 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1FF5, add(r1E69, body.constant(int(-10))), 0x01));

                     ir_variable *const r1FF6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1FF6, r1FEF, 0x01));

                     ir_variable *const r1FF7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1FF7, r1FF0, 0x01));

                     ir_variable *const r1FF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r1FF8);
                     ir_variable *const r1FF9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1FF9);
                     /* IF CONDITION */
                     ir_expression *const r1FFB = equal(r1FEF, body.constant(0u));
                     ir_if *f1FFA = new(mem_ctx) ir_if(operand(r1FFB).val);
                     exec_list *const f1FFA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FFA->then_instructions;

                        body.emit(assign(r1FF6, r1FF0, 0x01));

                        body.emit(assign(r1FF7, body.constant(0u), 0x01));

                        body.emit(assign(r1FF5, add(r1FF5, body.constant(int(-32))), 0x01));


                     body.instructions = f1FFA_parent_instructions;
                     body.emit(f1FFA);

                     /* END IF */

                     ir_variable *const r1FFC = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1FFC, r1FF6, 0x01));

                     ir_variable *const r1FFD = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1FFE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1FFE);
                     /* IF CONDITION */
                     ir_expression *const r2000 = equal(r1FF6, body.constant(0u));
                     ir_if *f1FFF = new(mem_ctx) ir_if(operand(r2000).val);
                     exec_list *const f1FFF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FFF->then_instructions;

                        body.emit(assign(r1FFD, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1FFF->else_instructions;

                        body.emit(assign(r1FFE, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2002 = bit_and(r1FF6, body.constant(4294901760u));
                        ir_expression *const r2003 = equal(r2002, body.constant(0u));
                        ir_if *f2001 = new(mem_ctx) ir_if(operand(r2003).val);
                        exec_list *const f2001_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2001->then_instructions;

                           body.emit(assign(r1FFE, body.constant(int(16)), 0x01));

                           body.emit(assign(r1FFC, lshift(r1FF6, body.constant(int(16))), 0x01));


                        body.instructions = f2001_parent_instructions;
                        body.emit(f2001);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2005 = bit_and(r1FFC, body.constant(4278190080u));
                        ir_expression *const r2006 = equal(r2005, body.constant(0u));
                        ir_if *f2004 = new(mem_ctx) ir_if(operand(r2006).val);
                        exec_list *const f2004_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2004->then_instructions;

                           body.emit(assign(r1FFE, add(r1FFE, body.constant(int(8))), 0x01));

                           body.emit(assign(r1FFC, lshift(r1FFC, body.constant(int(8))), 0x01));


                        body.instructions = f2004_parent_instructions;
                        body.emit(f2004);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2008 = bit_and(r1FFC, body.constant(4026531840u));
                        ir_expression *const r2009 = equal(r2008, body.constant(0u));
                        ir_if *f2007 = new(mem_ctx) ir_if(operand(r2009).val);
                        exec_list *const f2007_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2007->then_instructions;

                           body.emit(assign(r1FFE, add(r1FFE, body.constant(int(4))), 0x01));

                           body.emit(assign(r1FFC, lshift(r1FFC, body.constant(int(4))), 0x01));


                        body.instructions = f2007_parent_instructions;
                        body.emit(f2007);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r200B = bit_and(r1FFC, body.constant(3221225472u));
                        ir_expression *const r200C = equal(r200B, body.constant(0u));
                        ir_if *f200A = new(mem_ctx) ir_if(operand(r200C).val);
                        exec_list *const f200A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f200A->then_instructions;

                           body.emit(assign(r1FFE, add(r1FFE, body.constant(int(2))), 0x01));

                           body.emit(assign(r1FFC, lshift(r1FFC, body.constant(int(2))), 0x01));


                        body.instructions = f200A_parent_instructions;
                        body.emit(f200A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r200E = bit_and(r1FFC, body.constant(2147483648u));
                        ir_expression *const r200F = equal(r200E, body.constant(0u));
                        ir_if *f200D = new(mem_ctx) ir_if(operand(r200F).val);
                        exec_list *const f200D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f200D->then_instructions;

                           body.emit(assign(r1FFE, add(r1FFE, body.constant(int(1))), 0x01));


                        body.instructions = f200D_parent_instructions;
                        body.emit(f200D);

                        /* END IF */

                        body.emit(assign(r1FFD, r1FFE, 0x01));


                     body.instructions = f1FFF_parent_instructions;
                     body.emit(f1FFF);

                     /* END IF */

                     body.emit(assign(r1FF9, add(r1FFD, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2011 = lequal(body.constant(int(0)), r1FF9);
                     ir_if *f2010 = new(mem_ctx) ir_if(operand(r2011).val);
                     exec_list *const f2010_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2010->then_instructions;

                        body.emit(assign(r1FF8, body.constant(0u), 0x01));

                        ir_variable *const r2012 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2012, lshift(r1FF7, r1FF9), 0x01));

                        ir_variable *const r2013 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2015 = equal(r1FF9, body.constant(int(0)));
                        ir_if *f2014 = new(mem_ctx) ir_if(operand(r2015).val);
                        exec_list *const f2014_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2014->then_instructions;

                           body.emit(assign(r2013, r1FF6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2014->else_instructions;

                           ir_expression *const r2016 = lshift(r1FF6, r1FF9);
                           ir_expression *const r2017 = neg(r1FF9);
                           ir_expression *const r2018 = bit_and(r2017, body.constant(int(31)));
                           ir_expression *const r2019 = rshift(r1FF7, r2018);
                           body.emit(assign(r2013, bit_or(r2016, r2019), 0x01));


                        body.instructions = f2014_parent_instructions;
                        body.emit(f2014);

                        /* END IF */

                        body.emit(assign(r1FF6, r2013, 0x01));

                        body.emit(assign(r1FF7, r2012, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2010->else_instructions;

                        ir_variable *const r201A = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r201A, body.constant(0u), 0x01));

                        ir_variable *const r201B = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r201B, neg(r1FF9), 0x01));

                        ir_variable *const r201C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r201C);
                        ir_variable *const r201D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r201D);
                        ir_variable *const r201E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r201E);
                        ir_variable *const r201F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2020 = neg(r201B);
                        body.emit(assign(r201F, bit_and(r2020, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2022 = equal(r201B, body.constant(int(0)));
                        ir_if *f2021 = new(mem_ctx) ir_if(operand(r2022).val);
                        exec_list *const f2021_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2021->then_instructions;

                           body.emit(assign(r201C, r201A, 0x01));

                           body.emit(assign(r201D, r1FF7, 0x01));

                           body.emit(assign(r201E, r1FF6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2021->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2024 = less(r201B, body.constant(int(32)));
                           ir_if *f2023 = new(mem_ctx) ir_if(operand(r2024).val);
                           exec_list *const f2023_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2023->then_instructions;

                              body.emit(assign(r201C, lshift(r1FF7, r201F), 0x01));

                              ir_expression *const r2025 = lshift(r1FF6, r201F);
                              ir_expression *const r2026 = rshift(r1FF7, r201B);
                              body.emit(assign(r201D, bit_or(r2025, r2026), 0x01));

                              body.emit(assign(r201E, rshift(r1FF6, r201B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2023->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2028 = equal(r201B, body.constant(int(32)));
                              ir_if *f2027 = new(mem_ctx) ir_if(operand(r2028).val);
                              exec_list *const f2027_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2027->then_instructions;

                                 body.emit(assign(r201C, r1FF7, 0x01));

                                 body.emit(assign(r201D, r1FF6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2027->else_instructions;

                                 body.emit(assign(r201A, bit_or(body.constant(0u), r1FF7), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r202A = less(r201B, body.constant(int(64)));
                                 ir_if *f2029 = new(mem_ctx) ir_if(operand(r202A).val);
                                 exec_list *const f2029_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2029->then_instructions;

                                    body.emit(assign(r201C, lshift(r1FF6, r201F), 0x01));

                                    ir_expression *const r202B = bit_and(r201B, body.constant(int(31)));
                                    body.emit(assign(r201D, rshift(r1FF6, r202B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2029->else_instructions;

                                    ir_variable *const r202C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r202E = equal(r201B, body.constant(int(64)));
                                    ir_if *f202D = new(mem_ctx) ir_if(operand(r202E).val);
                                    exec_list *const f202D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f202D->then_instructions;

                                       body.emit(assign(r202C, r1FF6, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f202D->else_instructions;

                                       ir_expression *const r202F = nequal(r1FF6, body.constant(0u));
                                       ir_expression *const r2030 = expr(ir_unop_b2i, r202F);
                                       body.emit(assign(r202C, expr(ir_unop_i2u, r2030), 0x01));


                                    body.instructions = f202D_parent_instructions;
                                    body.emit(f202D);

                                    /* END IF */

                                    body.emit(assign(r201C, r202C, 0x01));

                                    body.emit(assign(r201D, body.constant(0u), 0x01));


                                 body.instructions = f2029_parent_instructions;
                                 body.emit(f2029);

                                 /* END IF */


                              body.instructions = f2027_parent_instructions;
                              body.emit(f2027);

                              /* END IF */

                              body.emit(assign(r201E, body.constant(0u), 0x01));


                           body.instructions = f2023_parent_instructions;
                           body.emit(f2023);

                           /* END IF */

                           ir_expression *const r2031 = nequal(r201A, body.constant(0u));
                           ir_expression *const r2032 = expr(ir_unop_b2i, r2031);
                           ir_expression *const r2033 = expr(ir_unop_i2u, r2032);
                           body.emit(assign(r201C, bit_or(r201C, r2033), 0x01));


                        body.instructions = f2021_parent_instructions;
                        body.emit(f2021);

                        /* END IF */

                        body.emit(assign(r1FF6, r201E, 0x01));

                        body.emit(assign(r1FF7, r201D, 0x01));

                        body.emit(assign(r1FF8, r201C, 0x01));


                     body.instructions = f2010_parent_instructions;
                     body.emit(f2010);

                     /* END IF */

                     body.emit(assign(r1FF5, sub(r1FF5, r1FF9), 0x01));

                     ir_variable *const r2034 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2034, r1FF5, 0x01));

                     ir_variable *const r2035 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2035, r1FF6, 0x01));

                     ir_variable *const r2036 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2036, r1FF7, 0x01));

                     ir_variable *const r2037 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2037, r1FF8, 0x01));

                     ir_variable *const r2038 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2038, body.constant(true), 0x01));

                     ir_variable *const r2039 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r203A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r203A);
                     ir_expression *const r203B = expr(ir_unop_u2i, r1FF8);
                     body.emit(assign(r203A, less(r203B, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r203D = lequal(body.constant(int(2045)), r1FF5);
                     ir_if *f203C = new(mem_ctx) ir_if(operand(r203D).val);
                     exec_list *const f203C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f203C->then_instructions;

                        ir_variable *const r203E = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2040 = less(body.constant(int(2045)), r1FF5);
                        ir_if *f203F = new(mem_ctx) ir_if(operand(r2040).val);
                        exec_list *const f203F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f203F->then_instructions;

                           body.emit(assign(r203E, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f203F->else_instructions;

                           ir_variable *const r2041 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2043 = equal(r1FF5, body.constant(int(2045)));
                           ir_if *f2042 = new(mem_ctx) ir_if(operand(r2043).val);
                           exec_list *const f2042_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2042->then_instructions;

                              ir_expression *const r2044 = equal(body.constant(2097151u), r1FF6);
                              ir_expression *const r2045 = equal(body.constant(4294967295u), r1FF7);
                              body.emit(assign(r2041, logic_and(r2044, r2045), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2042->else_instructions;

                              body.emit(assign(r2041, body.constant(false), 0x01));


                           body.instructions = f2042_parent_instructions;
                           body.emit(f2042);

                           /* END IF */

                           body.emit(assign(r203E, logic_and(r2041, r203A), 0x01));


                        body.instructions = f203F_parent_instructions;
                        body.emit(f203F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2046 = new(mem_ctx) ir_if(operand(r203E).val);
                        exec_list *const f2046_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2046->then_instructions;

                           ir_variable *const r2047 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2047);
                           ir_expression *const r2048 = lshift(r1E62, body.constant(int(31)));
                           body.emit(assign(r2047, add(r2048, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2047, body.constant(0u), 0x01));

                           body.emit(assign(r2039, r2047, 0x03));

                           body.emit(assign(r2038, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2046->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r204A = less(r1FF5, body.constant(int(0)));
                           ir_if *f2049 = new(mem_ctx) ir_if(operand(r204A).val);
                           exec_list *const f2049_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2049->then_instructions;

                              ir_variable *const r204B = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r204B, r1FF8, 0x01));

                              ir_variable *const r204C = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r204C, neg(r1FF5), 0x01));

                              ir_variable *const r204D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r204D);
                              ir_variable *const r204E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r204E);
                              ir_variable *const r204F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r204F);
                              ir_variable *const r2050 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2051 = neg(r204C);
                              body.emit(assign(r2050, bit_and(r2051, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2053 = equal(r204C, body.constant(int(0)));
                              ir_if *f2052 = new(mem_ctx) ir_if(operand(r2053).val);
                              exec_list *const f2052_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2052->then_instructions;

                                 body.emit(assign(r204D, r1FF8, 0x01));

                                 body.emit(assign(r204E, r1FF7, 0x01));

                                 body.emit(assign(r204F, r1FF6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2052->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2055 = less(r204C, body.constant(int(32)));
                                 ir_if *f2054 = new(mem_ctx) ir_if(operand(r2055).val);
                                 exec_list *const f2054_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2054->then_instructions;

                                    body.emit(assign(r204D, lshift(r1FF7, r2050), 0x01));

                                    ir_expression *const r2056 = lshift(r1FF6, r2050);
                                    ir_expression *const r2057 = rshift(r1FF7, r204C);
                                    body.emit(assign(r204E, bit_or(r2056, r2057), 0x01));

                                    body.emit(assign(r204F, rshift(r1FF6, r204C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2054->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2059 = equal(r204C, body.constant(int(32)));
                                    ir_if *f2058 = new(mem_ctx) ir_if(operand(r2059).val);
                                    exec_list *const f2058_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2058->then_instructions;

                                       body.emit(assign(r204D, r1FF7, 0x01));

                                       body.emit(assign(r204E, r1FF6, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2058->else_instructions;

                                       body.emit(assign(r204B, bit_or(r1FF8, r1FF7), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r205B = less(r204C, body.constant(int(64)));
                                       ir_if *f205A = new(mem_ctx) ir_if(operand(r205B).val);
                                       exec_list *const f205A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f205A->then_instructions;

                                          body.emit(assign(r204D, lshift(r1FF6, r2050), 0x01));

                                          ir_expression *const r205C = bit_and(r204C, body.constant(int(31)));
                                          body.emit(assign(r204E, rshift(r1FF6, r205C), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f205A->else_instructions;

                                          ir_variable *const r205D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r205F = equal(r204C, body.constant(int(64)));
                                          ir_if *f205E = new(mem_ctx) ir_if(operand(r205F).val);
                                          exec_list *const f205E_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f205E->then_instructions;

                                             body.emit(assign(r205D, r1FF6, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f205E->else_instructions;

                                             ir_expression *const r2060 = nequal(r1FF6, body.constant(0u));
                                             ir_expression *const r2061 = expr(ir_unop_b2i, r2060);
                                             body.emit(assign(r205D, expr(ir_unop_i2u, r2061), 0x01));


                                          body.instructions = f205E_parent_instructions;
                                          body.emit(f205E);

                                          /* END IF */

                                          body.emit(assign(r204D, r205D, 0x01));

                                          body.emit(assign(r204E, body.constant(0u), 0x01));


                                       body.instructions = f205A_parent_instructions;
                                       body.emit(f205A);

                                       /* END IF */


                                    body.instructions = f2058_parent_instructions;
                                    body.emit(f2058);

                                    /* END IF */

                                    body.emit(assign(r204F, body.constant(0u), 0x01));


                                 body.instructions = f2054_parent_instructions;
                                 body.emit(f2054);

                                 /* END IF */

                                 ir_expression *const r2062 = nequal(r204B, body.constant(0u));
                                 ir_expression *const r2063 = expr(ir_unop_b2i, r2062);
                                 ir_expression *const r2064 = expr(ir_unop_i2u, r2063);
                                 body.emit(assign(r204D, bit_or(r204D, r2064), 0x01));


                              body.instructions = f2052_parent_instructions;
                              body.emit(f2052);

                              /* END IF */

                              body.emit(assign(r2035, r204F, 0x01));

                              body.emit(assign(r2036, r204E, 0x01));

                              body.emit(assign(r2037, r204D, 0x01));

                              body.emit(assign(r2034, body.constant(int(0)), 0x01));

                              body.emit(assign(r203A, less(r204D, body.constant(0u)), 0x01));


                           body.instructions = f2049_parent_instructions;
                           body.emit(f2049);

                           /* END IF */


                        body.instructions = f2046_parent_instructions;
                        body.emit(f2046);

                        /* END IF */


                     body.instructions = f203C_parent_instructions;
                     body.emit(f203C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2065 = new(mem_ctx) ir_if(operand(r2038).val);
                     exec_list *const f2065_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2065->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2066 = new(mem_ctx) ir_if(operand(r203A).val);
                        exec_list *const f2066_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2066->then_instructions;

                           ir_variable *const r2067 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2067, add(r2036, body.constant(1u)), 0x01));

                           ir_expression *const r2068 = less(r2067, r2036);
                           ir_expression *const r2069 = expr(ir_unop_b2i, r2068);
                           ir_expression *const r206A = expr(ir_unop_i2u, r2069);
                           body.emit(assign(r2035, add(r2035, r206A), 0x01));

                           ir_expression *const r206B = equal(r2037, body.constant(0u));
                           ir_expression *const r206C = expr(ir_unop_b2i, r206B);
                           ir_expression *const r206D = expr(ir_unop_i2u, r206C);
                           ir_expression *const r206E = add(r2037, r206D);
                           ir_expression *const r206F = bit_and(r206E, body.constant(1u));
                           ir_expression *const r2070 = expr(ir_unop_bit_not, r206F);
                           body.emit(assign(r2036, bit_and(r2067, r2070), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2066->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2072 = bit_or(r2035, r2036);
                           ir_expression *const r2073 = equal(r2072, body.constant(0u));
                           ir_if *f2071 = new(mem_ctx) ir_if(operand(r2073).val);
                           exec_list *const f2071_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2071->then_instructions;

                              body.emit(assign(r2034, body.constant(int(0)), 0x01));


                           body.instructions = f2071_parent_instructions;
                           body.emit(f2071);

                           /* END IF */


                        body.instructions = f2066_parent_instructions;
                        body.emit(f2066);

                        /* END IF */

                        ir_variable *const r2074 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2074);
                        ir_expression *const r2075 = lshift(r1E62, body.constant(int(31)));
                        ir_expression *const r2076 = expr(ir_unop_i2u, r2034);
                        ir_expression *const r2077 = lshift(r2076, body.constant(int(20)));
                        ir_expression *const r2078 = add(r2075, r2077);
                        body.emit(assign(r2074, add(r2078, r2035), 0x02));

                        body.emit(assign(r2074, r2036, 0x01));

                        body.emit(assign(r2039, r2074, 0x03));

                        body.emit(assign(r2038, body.constant(false), 0x01));


                     body.instructions = f2065_parent_instructions;
                     body.emit(f2065);

                     /* END IF */

                     body.emit(assign(r1E63, r2039, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1FED->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r207A = less(swizzle_y(r1E68), swizzle_y(r1E66));
                     ir_if *f2079 = new(mem_ctx) ir_if(operand(r207A).val);
                     exec_list *const f2079_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2079->then_instructions;

                        ir_variable *const r207B = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r207C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r207C, sub(swizzle_x(r1E66), swizzle_x(r1E68)), 0x01));

                        ir_expression *const r207D = sub(swizzle_y(r1E66), swizzle_y(r1E68));
                        ir_expression *const r207E = less(swizzle_x(r1E66), swizzle_x(r1E68));
                        ir_expression *const r207F = expr(ir_unop_b2i, r207E);
                        ir_expression *const r2080 = expr(ir_unop_i2u, r207F);
                        body.emit(assign(r207B, sub(r207D, r2080), 0x01));

                        body.emit(assign(r1E62, bit_xor(r1E62, body.constant(1u)), 0x01));

                        body.emit(assign(r1E69, add(r1E65, body.constant(int(-1))), 0x01));

                        ir_variable *const r2081 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2081, add(r1E69, body.constant(int(-10))), 0x01));

                        ir_variable *const r2082 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2082, r207B, 0x01));

                        ir_variable *const r2083 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2083, r207C, 0x01));

                        ir_variable *const r2084 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2084);
                        ir_variable *const r2085 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2085);
                        /* IF CONDITION */
                        ir_expression *const r2087 = equal(r207B, body.constant(0u));
                        ir_if *f2086 = new(mem_ctx) ir_if(operand(r2087).val);
                        exec_list *const f2086_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2086->then_instructions;

                           body.emit(assign(r2082, r207C, 0x01));

                           body.emit(assign(r2083, body.constant(0u), 0x01));

                           body.emit(assign(r2081, add(r2081, body.constant(int(-32))), 0x01));


                        body.instructions = f2086_parent_instructions;
                        body.emit(f2086);

                        /* END IF */

                        ir_variable *const r2088 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2088, r2082, 0x01));

                        ir_variable *const r2089 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r208A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r208A);
                        /* IF CONDITION */
                        ir_expression *const r208C = equal(r2082, body.constant(0u));
                        ir_if *f208B = new(mem_ctx) ir_if(operand(r208C).val);
                        exec_list *const f208B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f208B->then_instructions;

                           body.emit(assign(r2089, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f208B->else_instructions;

                           body.emit(assign(r208A, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r208E = bit_and(r2082, body.constant(4294901760u));
                           ir_expression *const r208F = equal(r208E, body.constant(0u));
                           ir_if *f208D = new(mem_ctx) ir_if(operand(r208F).val);
                           exec_list *const f208D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f208D->then_instructions;

                              body.emit(assign(r208A, body.constant(int(16)), 0x01));

                              body.emit(assign(r2088, lshift(r2082, body.constant(int(16))), 0x01));


                           body.instructions = f208D_parent_instructions;
                           body.emit(f208D);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2091 = bit_and(r2088, body.constant(4278190080u));
                           ir_expression *const r2092 = equal(r2091, body.constant(0u));
                           ir_if *f2090 = new(mem_ctx) ir_if(operand(r2092).val);
                           exec_list *const f2090_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2090->then_instructions;

                              body.emit(assign(r208A, add(r208A, body.constant(int(8))), 0x01));

                              body.emit(assign(r2088, lshift(r2088, body.constant(int(8))), 0x01));


                           body.instructions = f2090_parent_instructions;
                           body.emit(f2090);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2094 = bit_and(r2088, body.constant(4026531840u));
                           ir_expression *const r2095 = equal(r2094, body.constant(0u));
                           ir_if *f2093 = new(mem_ctx) ir_if(operand(r2095).val);
                           exec_list *const f2093_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2093->then_instructions;

                              body.emit(assign(r208A, add(r208A, body.constant(int(4))), 0x01));

                              body.emit(assign(r2088, lshift(r2088, body.constant(int(4))), 0x01));


                           body.instructions = f2093_parent_instructions;
                           body.emit(f2093);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2097 = bit_and(r2088, body.constant(3221225472u));
                           ir_expression *const r2098 = equal(r2097, body.constant(0u));
                           ir_if *f2096 = new(mem_ctx) ir_if(operand(r2098).val);
                           exec_list *const f2096_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2096->then_instructions;

                              body.emit(assign(r208A, add(r208A, body.constant(int(2))), 0x01));

                              body.emit(assign(r2088, lshift(r2088, body.constant(int(2))), 0x01));


                           body.instructions = f2096_parent_instructions;
                           body.emit(f2096);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r209A = bit_and(r2088, body.constant(2147483648u));
                           ir_expression *const r209B = equal(r209A, body.constant(0u));
                           ir_if *f2099 = new(mem_ctx) ir_if(operand(r209B).val);
                           exec_list *const f2099_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2099->then_instructions;

                              body.emit(assign(r208A, add(r208A, body.constant(int(1))), 0x01));


                           body.instructions = f2099_parent_instructions;
                           body.emit(f2099);

                           /* END IF */

                           body.emit(assign(r2089, r208A, 0x01));


                        body.instructions = f208B_parent_instructions;
                        body.emit(f208B);

                        /* END IF */

                        body.emit(assign(r2085, add(r2089, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r209D = lequal(body.constant(int(0)), r2085);
                        ir_if *f209C = new(mem_ctx) ir_if(operand(r209D).val);
                        exec_list *const f209C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f209C->then_instructions;

                           body.emit(assign(r2084, body.constant(0u), 0x01));

                           ir_variable *const r209E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r209E, lshift(r2083, r2085), 0x01));

                           ir_variable *const r209F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r20A1 = equal(r2085, body.constant(int(0)));
                           ir_if *f20A0 = new(mem_ctx) ir_if(operand(r20A1).val);
                           exec_list *const f20A0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20A0->then_instructions;

                              body.emit(assign(r209F, r2082, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20A0->else_instructions;

                              ir_expression *const r20A2 = lshift(r2082, r2085);
                              ir_expression *const r20A3 = neg(r2085);
                              ir_expression *const r20A4 = bit_and(r20A3, body.constant(int(31)));
                              ir_expression *const r20A5 = rshift(r2083, r20A4);
                              body.emit(assign(r209F, bit_or(r20A2, r20A5), 0x01));


                           body.instructions = f20A0_parent_instructions;
                           body.emit(f20A0);

                           /* END IF */

                           body.emit(assign(r2082, r209F, 0x01));

                           body.emit(assign(r2083, r209E, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f209C->else_instructions;

                           ir_variable *const r20A6 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r20A6, body.constant(0u), 0x01));

                           ir_variable *const r20A7 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r20A7, neg(r2085), 0x01));

                           ir_variable *const r20A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r20A8);
                           ir_variable *const r20A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r20A9);
                           ir_variable *const r20AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r20AA);
                           ir_variable *const r20AB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r20AC = neg(r20A7);
                           body.emit(assign(r20AB, bit_and(r20AC, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r20AE = equal(r20A7, body.constant(int(0)));
                           ir_if *f20AD = new(mem_ctx) ir_if(operand(r20AE).val);
                           exec_list *const f20AD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20AD->then_instructions;

                              body.emit(assign(r20A8, r20A6, 0x01));

                              body.emit(assign(r20A9, r2083, 0x01));

                              body.emit(assign(r20AA, r2082, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20AD->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r20B0 = less(r20A7, body.constant(int(32)));
                              ir_if *f20AF = new(mem_ctx) ir_if(operand(r20B0).val);
                              exec_list *const f20AF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20AF->then_instructions;

                                 body.emit(assign(r20A8, lshift(r2083, r20AB), 0x01));

                                 ir_expression *const r20B1 = lshift(r2082, r20AB);
                                 ir_expression *const r20B2 = rshift(r2083, r20A7);
                                 body.emit(assign(r20A9, bit_or(r20B1, r20B2), 0x01));

                                 body.emit(assign(r20AA, rshift(r2082, r20A7), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f20AF->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r20B4 = equal(r20A7, body.constant(int(32)));
                                 ir_if *f20B3 = new(mem_ctx) ir_if(operand(r20B4).val);
                                 exec_list *const f20B3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f20B3->then_instructions;

                                    body.emit(assign(r20A8, r2083, 0x01));

                                    body.emit(assign(r20A9, r2082, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f20B3->else_instructions;

                                    body.emit(assign(r20A6, bit_or(body.constant(0u), r2083), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r20B6 = less(r20A7, body.constant(int(64)));
                                    ir_if *f20B5 = new(mem_ctx) ir_if(operand(r20B6).val);
                                    exec_list *const f20B5_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f20B5->then_instructions;

                                       body.emit(assign(r20A8, lshift(r2082, r20AB), 0x01));

                                       ir_expression *const r20B7 = bit_and(r20A7, body.constant(int(31)));
                                       body.emit(assign(r20A9, rshift(r2082, r20B7), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f20B5->else_instructions;

                                       ir_variable *const r20B8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r20BA = equal(r20A7, body.constant(int(64)));
                                       ir_if *f20B9 = new(mem_ctx) ir_if(operand(r20BA).val);
                                       exec_list *const f20B9_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f20B9->then_instructions;

                                          body.emit(assign(r20B8, r2082, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f20B9->else_instructions;

                                          ir_expression *const r20BB = nequal(r2082, body.constant(0u));
                                          ir_expression *const r20BC = expr(ir_unop_b2i, r20BB);
                                          body.emit(assign(r20B8, expr(ir_unop_i2u, r20BC), 0x01));


                                       body.instructions = f20B9_parent_instructions;
                                       body.emit(f20B9);

                                       /* END IF */

                                       body.emit(assign(r20A8, r20B8, 0x01));

                                       body.emit(assign(r20A9, body.constant(0u), 0x01));


                                    body.instructions = f20B5_parent_instructions;
                                    body.emit(f20B5);

                                    /* END IF */


                                 body.instructions = f20B3_parent_instructions;
                                 body.emit(f20B3);

                                 /* END IF */

                                 body.emit(assign(r20AA, body.constant(0u), 0x01));


                              body.instructions = f20AF_parent_instructions;
                              body.emit(f20AF);

                              /* END IF */

                              ir_expression *const r20BD = nequal(r20A6, body.constant(0u));
                              ir_expression *const r20BE = expr(ir_unop_b2i, r20BD);
                              ir_expression *const r20BF = expr(ir_unop_i2u, r20BE);
                              body.emit(assign(r20A8, bit_or(r20A8, r20BF), 0x01));


                           body.instructions = f20AD_parent_instructions;
                           body.emit(f20AD);

                           /* END IF */

                           body.emit(assign(r2082, r20AA, 0x01));

                           body.emit(assign(r2083, r20A9, 0x01));

                           body.emit(assign(r2084, r20A8, 0x01));


                        body.instructions = f209C_parent_instructions;
                        body.emit(f209C);

                        /* END IF */

                        body.emit(assign(r2081, sub(r2081, r2085), 0x01));

                        ir_variable *const r20C0 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r20C0, r2081, 0x01));

                        ir_variable *const r20C1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r20C1, r2082, 0x01));

                        ir_variable *const r20C2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r20C2, r2083, 0x01));

                        ir_variable *const r20C3 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r20C3, r2084, 0x01));

                        ir_variable *const r20C4 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r20C4, body.constant(true), 0x01));

                        ir_variable *const r20C5 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r20C6 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r20C6);
                        ir_expression *const r20C7 = expr(ir_unop_u2i, r2084);
                        body.emit(assign(r20C6, less(r20C7, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r20C9 = lequal(body.constant(int(2045)), r2081);
                        ir_if *f20C8 = new(mem_ctx) ir_if(operand(r20C9).val);
                        exec_list *const f20C8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20C8->then_instructions;

                           ir_variable *const r20CA = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r20CC = less(body.constant(int(2045)), r2081);
                           ir_if *f20CB = new(mem_ctx) ir_if(operand(r20CC).val);
                           exec_list *const f20CB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20CB->then_instructions;

                              body.emit(assign(r20CA, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20CB->else_instructions;

                              ir_variable *const r20CD = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r20CF = equal(r2081, body.constant(int(2045)));
                              ir_if *f20CE = new(mem_ctx) ir_if(operand(r20CF).val);
                              exec_list *const f20CE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20CE->then_instructions;

                                 ir_expression *const r20D0 = equal(body.constant(2097151u), r2082);
                                 ir_expression *const r20D1 = equal(body.constant(4294967295u), r2083);
                                 body.emit(assign(r20CD, logic_and(r20D0, r20D1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f20CE->else_instructions;

                                 body.emit(assign(r20CD, body.constant(false), 0x01));


                              body.instructions = f20CE_parent_instructions;
                              body.emit(f20CE);

                              /* END IF */

                              body.emit(assign(r20CA, logic_and(r20CD, r20C6), 0x01));


                           body.instructions = f20CB_parent_instructions;
                           body.emit(f20CB);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f20D2 = new(mem_ctx) ir_if(operand(r20CA).val);
                           exec_list *const f20D2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20D2->then_instructions;

                              ir_variable *const r20D3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r20D3);
                              ir_expression *const r20D4 = lshift(r1E62, body.constant(int(31)));
                              body.emit(assign(r20D3, add(r20D4, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r20D3, body.constant(0u), 0x01));

                              body.emit(assign(r20C5, r20D3, 0x03));

                              body.emit(assign(r20C4, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20D2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r20D6 = less(r2081, body.constant(int(0)));
                              ir_if *f20D5 = new(mem_ctx) ir_if(operand(r20D6).val);
                              exec_list *const f20D5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20D5->then_instructions;

                                 ir_variable *const r20D7 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r20D7, r2084, 0x01));

                                 ir_variable *const r20D8 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r20D8, neg(r2081), 0x01));

                                 ir_variable *const r20D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r20D9);
                                 ir_variable *const r20DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r20DA);
                                 ir_variable *const r20DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r20DB);
                                 ir_variable *const r20DC = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r20DD = neg(r20D8);
                                 body.emit(assign(r20DC, bit_and(r20DD, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r20DF = equal(r20D8, body.constant(int(0)));
                                 ir_if *f20DE = new(mem_ctx) ir_if(operand(r20DF).val);
                                 exec_list *const f20DE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f20DE->then_instructions;

                                    body.emit(assign(r20D9, r2084, 0x01));

                                    body.emit(assign(r20DA, r2083, 0x01));

                                    body.emit(assign(r20DB, r2082, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f20DE->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r20E1 = less(r20D8, body.constant(int(32)));
                                    ir_if *f20E0 = new(mem_ctx) ir_if(operand(r20E1).val);
                                    exec_list *const f20E0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f20E0->then_instructions;

                                       body.emit(assign(r20D9, lshift(r2083, r20DC), 0x01));

                                       ir_expression *const r20E2 = lshift(r2082, r20DC);
                                       ir_expression *const r20E3 = rshift(r2083, r20D8);
                                       body.emit(assign(r20DA, bit_or(r20E2, r20E3), 0x01));

                                       body.emit(assign(r20DB, rshift(r2082, r20D8), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f20E0->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r20E5 = equal(r20D8, body.constant(int(32)));
                                       ir_if *f20E4 = new(mem_ctx) ir_if(operand(r20E5).val);
                                       exec_list *const f20E4_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f20E4->then_instructions;

                                          body.emit(assign(r20D9, r2083, 0x01));

                                          body.emit(assign(r20DA, r2082, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f20E4->else_instructions;

                                          body.emit(assign(r20D7, bit_or(r2084, r2083), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r20E7 = less(r20D8, body.constant(int(64)));
                                          ir_if *f20E6 = new(mem_ctx) ir_if(operand(r20E7).val);
                                          exec_list *const f20E6_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f20E6->then_instructions;

                                             body.emit(assign(r20D9, lshift(r2082, r20DC), 0x01));

                                             ir_expression *const r20E8 = bit_and(r20D8, body.constant(int(31)));
                                             body.emit(assign(r20DA, rshift(r2082, r20E8), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f20E6->else_instructions;

                                             ir_variable *const r20E9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r20EB = equal(r20D8, body.constant(int(64)));
                                             ir_if *f20EA = new(mem_ctx) ir_if(operand(r20EB).val);
                                             exec_list *const f20EA_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f20EA->then_instructions;

                                                body.emit(assign(r20E9, r2082, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f20EA->else_instructions;

                                                ir_expression *const r20EC = nequal(r2082, body.constant(0u));
                                                ir_expression *const r20ED = expr(ir_unop_b2i, r20EC);
                                                body.emit(assign(r20E9, expr(ir_unop_i2u, r20ED), 0x01));


                                             body.instructions = f20EA_parent_instructions;
                                             body.emit(f20EA);

                                             /* END IF */

                                             body.emit(assign(r20D9, r20E9, 0x01));

                                             body.emit(assign(r20DA, body.constant(0u), 0x01));


                                          body.instructions = f20E6_parent_instructions;
                                          body.emit(f20E6);

                                          /* END IF */


                                       body.instructions = f20E4_parent_instructions;
                                       body.emit(f20E4);

                                       /* END IF */

                                       body.emit(assign(r20DB, body.constant(0u), 0x01));


                                    body.instructions = f20E0_parent_instructions;
                                    body.emit(f20E0);

                                    /* END IF */

                                    ir_expression *const r20EE = nequal(r20D7, body.constant(0u));
                                    ir_expression *const r20EF = expr(ir_unop_b2i, r20EE);
                                    ir_expression *const r20F0 = expr(ir_unop_i2u, r20EF);
                                    body.emit(assign(r20D9, bit_or(r20D9, r20F0), 0x01));


                                 body.instructions = f20DE_parent_instructions;
                                 body.emit(f20DE);

                                 /* END IF */

                                 body.emit(assign(r20C1, r20DB, 0x01));

                                 body.emit(assign(r20C2, r20DA, 0x01));

                                 body.emit(assign(r20C3, r20D9, 0x01));

                                 body.emit(assign(r20C0, body.constant(int(0)), 0x01));

                                 body.emit(assign(r20C6, less(r20D9, body.constant(0u)), 0x01));


                              body.instructions = f20D5_parent_instructions;
                              body.emit(f20D5);

                              /* END IF */


                           body.instructions = f20D2_parent_instructions;
                           body.emit(f20D2);

                           /* END IF */


                        body.instructions = f20C8_parent_instructions;
                        body.emit(f20C8);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f20F1 = new(mem_ctx) ir_if(operand(r20C4).val);
                        exec_list *const f20F1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20F1->then_instructions;

                           /* IF CONDITION */
                           ir_if *f20F2 = new(mem_ctx) ir_if(operand(r20C6).val);
                           exec_list *const f20F2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20F2->then_instructions;

                              ir_variable *const r20F3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r20F3, add(r20C2, body.constant(1u)), 0x01));

                              ir_expression *const r20F4 = less(r20F3, r20C2);
                              ir_expression *const r20F5 = expr(ir_unop_b2i, r20F4);
                              ir_expression *const r20F6 = expr(ir_unop_i2u, r20F5);
                              body.emit(assign(r20C1, add(r20C1, r20F6), 0x01));

                              ir_expression *const r20F7 = equal(r20C3, body.constant(0u));
                              ir_expression *const r20F8 = expr(ir_unop_b2i, r20F7);
                              ir_expression *const r20F9 = expr(ir_unop_i2u, r20F8);
                              ir_expression *const r20FA = add(r20C3, r20F9);
                              ir_expression *const r20FB = bit_and(r20FA, body.constant(1u));
                              ir_expression *const r20FC = expr(ir_unop_bit_not, r20FB);
                              body.emit(assign(r20C2, bit_and(r20F3, r20FC), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20F2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r20FE = bit_or(r20C1, r20C2);
                              ir_expression *const r20FF = equal(r20FE, body.constant(0u));
                              ir_if *f20FD = new(mem_ctx) ir_if(operand(r20FF).val);
                              exec_list *const f20FD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20FD->then_instructions;

                                 body.emit(assign(r20C0, body.constant(int(0)), 0x01));


                              body.instructions = f20FD_parent_instructions;
                              body.emit(f20FD);

                              /* END IF */


                           body.instructions = f20F2_parent_instructions;
                           body.emit(f20F2);

                           /* END IF */

                           ir_variable *const r2100 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2100);
                           ir_expression *const r2101 = lshift(r1E62, body.constant(int(31)));
                           ir_expression *const r2102 = expr(ir_unop_i2u, r20C0);
                           ir_expression *const r2103 = lshift(r2102, body.constant(int(20)));
                           ir_expression *const r2104 = add(r2101, r2103);
                           body.emit(assign(r2100, add(r2104, r20C1), 0x02));

                           body.emit(assign(r2100, r20C2, 0x01));

                           body.emit(assign(r20C5, r2100, 0x03));

                           body.emit(assign(r20C4, body.constant(false), 0x01));


                        body.instructions = f20F1_parent_instructions;
                        body.emit(f20F1);

                        /* END IF */

                        body.emit(assign(r1E63, r20C5, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2079->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2106 = less(swizzle_x(r1E66), swizzle_x(r1E68));
                        ir_if *f2105 = new(mem_ctx) ir_if(operand(r2106).val);
                        exec_list *const f2105_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2105->then_instructions;

                           ir_variable *const r2107 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r2108 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2108, sub(swizzle_x(r1E68), swizzle_x(r1E66)), 0x01));

                           ir_expression *const r2109 = sub(swizzle_y(r1E68), swizzle_y(r1E66));
                           ir_expression *const r210A = less(swizzle_x(r1E68), swizzle_x(r1E66));
                           ir_expression *const r210B = expr(ir_unop_b2i, r210A);
                           ir_expression *const r210C = expr(ir_unop_i2u, r210B);
                           body.emit(assign(r2107, sub(r2109, r210C), 0x01));

                           body.emit(assign(r1E69, add(r1E67, body.constant(int(-1))), 0x01));

                           ir_variable *const r210D = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r210D, add(r1E69, body.constant(int(-10))), 0x01));

                           ir_variable *const r210E = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r210E, r2107, 0x01));

                           ir_variable *const r210F = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r210F, r2108, 0x01));

                           ir_variable *const r2110 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r2110);
                           ir_variable *const r2111 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2111);
                           /* IF CONDITION */
                           ir_expression *const r2113 = equal(r2107, body.constant(0u));
                           ir_if *f2112 = new(mem_ctx) ir_if(operand(r2113).val);
                           exec_list *const f2112_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2112->then_instructions;

                              body.emit(assign(r210E, r2108, 0x01));

                              body.emit(assign(r210F, body.constant(0u), 0x01));

                              body.emit(assign(r210D, add(r210D, body.constant(int(-32))), 0x01));


                           body.instructions = f2112_parent_instructions;
                           body.emit(f2112);

                           /* END IF */

                           ir_variable *const r2114 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r2114, r210E, 0x01));

                           ir_variable *const r2115 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r2116 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2116);
                           /* IF CONDITION */
                           ir_expression *const r2118 = equal(r210E, body.constant(0u));
                           ir_if *f2117 = new(mem_ctx) ir_if(operand(r2118).val);
                           exec_list *const f2117_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2117->then_instructions;

                              body.emit(assign(r2115, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2117->else_instructions;

                              body.emit(assign(r2116, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r211A = bit_and(r210E, body.constant(4294901760u));
                              ir_expression *const r211B = equal(r211A, body.constant(0u));
                              ir_if *f2119 = new(mem_ctx) ir_if(operand(r211B).val);
                              exec_list *const f2119_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2119->then_instructions;

                                 body.emit(assign(r2116, body.constant(int(16)), 0x01));

                                 body.emit(assign(r2114, lshift(r210E, body.constant(int(16))), 0x01));


                              body.instructions = f2119_parent_instructions;
                              body.emit(f2119);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r211D = bit_and(r2114, body.constant(4278190080u));
                              ir_expression *const r211E = equal(r211D, body.constant(0u));
                              ir_if *f211C = new(mem_ctx) ir_if(operand(r211E).val);
                              exec_list *const f211C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f211C->then_instructions;

                                 body.emit(assign(r2116, add(r2116, body.constant(int(8))), 0x01));

                                 body.emit(assign(r2114, lshift(r2114, body.constant(int(8))), 0x01));


                              body.instructions = f211C_parent_instructions;
                              body.emit(f211C);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2120 = bit_and(r2114, body.constant(4026531840u));
                              ir_expression *const r2121 = equal(r2120, body.constant(0u));
                              ir_if *f211F = new(mem_ctx) ir_if(operand(r2121).val);
                              exec_list *const f211F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f211F->then_instructions;

                                 body.emit(assign(r2116, add(r2116, body.constant(int(4))), 0x01));

                                 body.emit(assign(r2114, lshift(r2114, body.constant(int(4))), 0x01));


                              body.instructions = f211F_parent_instructions;
                              body.emit(f211F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2123 = bit_and(r2114, body.constant(3221225472u));
                              ir_expression *const r2124 = equal(r2123, body.constant(0u));
                              ir_if *f2122 = new(mem_ctx) ir_if(operand(r2124).val);
                              exec_list *const f2122_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2122->then_instructions;

                                 body.emit(assign(r2116, add(r2116, body.constant(int(2))), 0x01));

                                 body.emit(assign(r2114, lshift(r2114, body.constant(int(2))), 0x01));


                              body.instructions = f2122_parent_instructions;
                              body.emit(f2122);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2126 = bit_and(r2114, body.constant(2147483648u));
                              ir_expression *const r2127 = equal(r2126, body.constant(0u));
                              ir_if *f2125 = new(mem_ctx) ir_if(operand(r2127).val);
                              exec_list *const f2125_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2125->then_instructions;

                                 body.emit(assign(r2116, add(r2116, body.constant(int(1))), 0x01));


                              body.instructions = f2125_parent_instructions;
                              body.emit(f2125);

                              /* END IF */

                              body.emit(assign(r2115, r2116, 0x01));


                           body.instructions = f2117_parent_instructions;
                           body.emit(f2117);

                           /* END IF */

                           body.emit(assign(r2111, add(r2115, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2129 = lequal(body.constant(int(0)), r2111);
                           ir_if *f2128 = new(mem_ctx) ir_if(operand(r2129).val);
                           exec_list *const f2128_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2128->then_instructions;

                              body.emit(assign(r2110, body.constant(0u), 0x01));

                              ir_variable *const r212A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r212A, lshift(r210F, r2111), 0x01));

                              ir_variable *const r212B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r212D = equal(r2111, body.constant(int(0)));
                              ir_if *f212C = new(mem_ctx) ir_if(operand(r212D).val);
                              exec_list *const f212C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f212C->then_instructions;

                                 body.emit(assign(r212B, r210E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f212C->else_instructions;

                                 ir_expression *const r212E = lshift(r210E, r2111);
                                 ir_expression *const r212F = neg(r2111);
                                 ir_expression *const r2130 = bit_and(r212F, body.constant(int(31)));
                                 ir_expression *const r2131 = rshift(r210F, r2130);
                                 body.emit(assign(r212B, bit_or(r212E, r2131), 0x01));


                              body.instructions = f212C_parent_instructions;
                              body.emit(f212C);

                              /* END IF */

                              body.emit(assign(r210E, r212B, 0x01));

                              body.emit(assign(r210F, r212A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2128->else_instructions;

                              ir_variable *const r2132 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2132, body.constant(0u), 0x01));

                              ir_variable *const r2133 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2133, neg(r2111), 0x01));

                              ir_variable *const r2134 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2134);
                              ir_variable *const r2135 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2135);
                              ir_variable *const r2136 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2136);
                              ir_variable *const r2137 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2138 = neg(r2133);
                              body.emit(assign(r2137, bit_and(r2138, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r213A = equal(r2133, body.constant(int(0)));
                              ir_if *f2139 = new(mem_ctx) ir_if(operand(r213A).val);
                              exec_list *const f2139_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2139->then_instructions;

                                 body.emit(assign(r2134, r2132, 0x01));

                                 body.emit(assign(r2135, r210F, 0x01));

                                 body.emit(assign(r2136, r210E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2139->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r213C = less(r2133, body.constant(int(32)));
                                 ir_if *f213B = new(mem_ctx) ir_if(operand(r213C).val);
                                 exec_list *const f213B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f213B->then_instructions;

                                    body.emit(assign(r2134, lshift(r210F, r2137), 0x01));

                                    ir_expression *const r213D = lshift(r210E, r2137);
                                    ir_expression *const r213E = rshift(r210F, r2133);
                                    body.emit(assign(r2135, bit_or(r213D, r213E), 0x01));

                                    body.emit(assign(r2136, rshift(r210E, r2133), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f213B->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2140 = equal(r2133, body.constant(int(32)));
                                    ir_if *f213F = new(mem_ctx) ir_if(operand(r2140).val);
                                    exec_list *const f213F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f213F->then_instructions;

                                       body.emit(assign(r2134, r210F, 0x01));

                                       body.emit(assign(r2135, r210E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f213F->else_instructions;

                                       body.emit(assign(r2132, bit_or(body.constant(0u), r210F), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2142 = less(r2133, body.constant(int(64)));
                                       ir_if *f2141 = new(mem_ctx) ir_if(operand(r2142).val);
                                       exec_list *const f2141_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2141->then_instructions;

                                          body.emit(assign(r2134, lshift(r210E, r2137), 0x01));

                                          ir_expression *const r2143 = bit_and(r2133, body.constant(int(31)));
                                          body.emit(assign(r2135, rshift(r210E, r2143), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2141->else_instructions;

                                          ir_variable *const r2144 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2146 = equal(r2133, body.constant(int(64)));
                                          ir_if *f2145 = new(mem_ctx) ir_if(operand(r2146).val);
                                          exec_list *const f2145_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2145->then_instructions;

                                             body.emit(assign(r2144, r210E, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2145->else_instructions;

                                             ir_expression *const r2147 = nequal(r210E, body.constant(0u));
                                             ir_expression *const r2148 = expr(ir_unop_b2i, r2147);
                                             body.emit(assign(r2144, expr(ir_unop_i2u, r2148), 0x01));


                                          body.instructions = f2145_parent_instructions;
                                          body.emit(f2145);

                                          /* END IF */

                                          body.emit(assign(r2134, r2144, 0x01));

                                          body.emit(assign(r2135, body.constant(0u), 0x01));


                                       body.instructions = f2141_parent_instructions;
                                       body.emit(f2141);

                                       /* END IF */


                                    body.instructions = f213F_parent_instructions;
                                    body.emit(f213F);

                                    /* END IF */

                                    body.emit(assign(r2136, body.constant(0u), 0x01));


                                 body.instructions = f213B_parent_instructions;
                                 body.emit(f213B);

                                 /* END IF */

                                 ir_expression *const r2149 = nequal(r2132, body.constant(0u));
                                 ir_expression *const r214A = expr(ir_unop_b2i, r2149);
                                 ir_expression *const r214B = expr(ir_unop_i2u, r214A);
                                 body.emit(assign(r2134, bit_or(r2134, r214B), 0x01));


                              body.instructions = f2139_parent_instructions;
                              body.emit(f2139);

                              /* END IF */

                              body.emit(assign(r210E, r2136, 0x01));

                              body.emit(assign(r210F, r2135, 0x01));

                              body.emit(assign(r2110, r2134, 0x01));


                           body.instructions = f2128_parent_instructions;
                           body.emit(f2128);

                           /* END IF */

                           body.emit(assign(r210D, sub(r210D, r2111), 0x01));

                           ir_variable *const r214C = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r214C, r210D, 0x01));

                           ir_variable *const r214D = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r214D, r210E, 0x01));

                           ir_variable *const r214E = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r214E, r210F, 0x01));

                           ir_variable *const r214F = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r214F, r2110, 0x01));

                           ir_variable *const r2150 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r2150, body.constant(true), 0x01));

                           ir_variable *const r2151 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r2152 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r2152);
                           ir_expression *const r2153 = expr(ir_unop_u2i, r2110);
                           body.emit(assign(r2152, less(r2153, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2155 = lequal(body.constant(int(2045)), r210D);
                           ir_if *f2154 = new(mem_ctx) ir_if(operand(r2155).val);
                           exec_list *const f2154_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2154->then_instructions;

                              ir_variable *const r2156 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2158 = less(body.constant(int(2045)), r210D);
                              ir_if *f2157 = new(mem_ctx) ir_if(operand(r2158).val);
                              exec_list *const f2157_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2157->then_instructions;

                                 body.emit(assign(r2156, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2157->else_instructions;

                                 ir_variable *const r2159 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r215B = equal(r210D, body.constant(int(2045)));
                                 ir_if *f215A = new(mem_ctx) ir_if(operand(r215B).val);
                                 exec_list *const f215A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f215A->then_instructions;

                                    ir_expression *const r215C = equal(body.constant(2097151u), r210E);
                                    ir_expression *const r215D = equal(body.constant(4294967295u), r210F);
                                    body.emit(assign(r2159, logic_and(r215C, r215D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f215A->else_instructions;

                                    body.emit(assign(r2159, body.constant(false), 0x01));


                                 body.instructions = f215A_parent_instructions;
                                 body.emit(f215A);

                                 /* END IF */

                                 body.emit(assign(r2156, logic_and(r2159, r2152), 0x01));


                              body.instructions = f2157_parent_instructions;
                              body.emit(f2157);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f215E = new(mem_ctx) ir_if(operand(r2156).val);
                              exec_list *const f215E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f215E->then_instructions;

                                 ir_variable *const r215F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r215F);
                                 ir_expression *const r2160 = lshift(r1E62, body.constant(int(31)));
                                 body.emit(assign(r215F, add(r2160, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r215F, body.constant(0u), 0x01));

                                 body.emit(assign(r2151, r215F, 0x03));

                                 body.emit(assign(r2150, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f215E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2162 = less(r210D, body.constant(int(0)));
                                 ir_if *f2161 = new(mem_ctx) ir_if(operand(r2162).val);
                                 exec_list *const f2161_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2161->then_instructions;

                                    ir_variable *const r2163 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r2163, r2110, 0x01));

                                    ir_variable *const r2164 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r2164, neg(r210D), 0x01));

                                    ir_variable *const r2165 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r2165);
                                    ir_variable *const r2166 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r2166);
                                    ir_variable *const r2167 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2167);
                                    ir_variable *const r2168 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2169 = neg(r2164);
                                    body.emit(assign(r2168, bit_and(r2169, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r216B = equal(r2164, body.constant(int(0)));
                                    ir_if *f216A = new(mem_ctx) ir_if(operand(r216B).val);
                                    exec_list *const f216A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f216A->then_instructions;

                                       body.emit(assign(r2165, r2110, 0x01));

                                       body.emit(assign(r2166, r210F, 0x01));

                                       body.emit(assign(r2167, r210E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f216A->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r216D = less(r2164, body.constant(int(32)));
                                       ir_if *f216C = new(mem_ctx) ir_if(operand(r216D).val);
                                       exec_list *const f216C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f216C->then_instructions;

                                          body.emit(assign(r2165, lshift(r210F, r2168), 0x01));

                                          ir_expression *const r216E = lshift(r210E, r2168);
                                          ir_expression *const r216F = rshift(r210F, r2164);
                                          body.emit(assign(r2166, bit_or(r216E, r216F), 0x01));

                                          body.emit(assign(r2167, rshift(r210E, r2164), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f216C->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2171 = equal(r2164, body.constant(int(32)));
                                          ir_if *f2170 = new(mem_ctx) ir_if(operand(r2171).val);
                                          exec_list *const f2170_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2170->then_instructions;

                                             body.emit(assign(r2165, r210F, 0x01));

                                             body.emit(assign(r2166, r210E, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2170->else_instructions;

                                             body.emit(assign(r2163, bit_or(r2110, r210F), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r2173 = less(r2164, body.constant(int(64)));
                                             ir_if *f2172 = new(mem_ctx) ir_if(operand(r2173).val);
                                             exec_list *const f2172_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2172->then_instructions;

                                                body.emit(assign(r2165, lshift(r210E, r2168), 0x01));

                                                ir_expression *const r2174 = bit_and(r2164, body.constant(int(31)));
                                                body.emit(assign(r2166, rshift(r210E, r2174), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2172->else_instructions;

                                                ir_variable *const r2175 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2177 = equal(r2164, body.constant(int(64)));
                                                ir_if *f2176 = new(mem_ctx) ir_if(operand(r2177).val);
                                                exec_list *const f2176_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2176->then_instructions;

                                                   body.emit(assign(r2175, r210E, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2176->else_instructions;

                                                   ir_expression *const r2178 = nequal(r210E, body.constant(0u));
                                                   ir_expression *const r2179 = expr(ir_unop_b2i, r2178);
                                                   body.emit(assign(r2175, expr(ir_unop_i2u, r2179), 0x01));


                                                body.instructions = f2176_parent_instructions;
                                                body.emit(f2176);

                                                /* END IF */

                                                body.emit(assign(r2165, r2175, 0x01));

                                                body.emit(assign(r2166, body.constant(0u), 0x01));


                                             body.instructions = f2172_parent_instructions;
                                             body.emit(f2172);

                                             /* END IF */


                                          body.instructions = f2170_parent_instructions;
                                          body.emit(f2170);

                                          /* END IF */

                                          body.emit(assign(r2167, body.constant(0u), 0x01));


                                       body.instructions = f216C_parent_instructions;
                                       body.emit(f216C);

                                       /* END IF */

                                       ir_expression *const r217A = nequal(r2163, body.constant(0u));
                                       ir_expression *const r217B = expr(ir_unop_b2i, r217A);
                                       ir_expression *const r217C = expr(ir_unop_i2u, r217B);
                                       body.emit(assign(r2165, bit_or(r2165, r217C), 0x01));


                                    body.instructions = f216A_parent_instructions;
                                    body.emit(f216A);

                                    /* END IF */

                                    body.emit(assign(r214D, r2167, 0x01));

                                    body.emit(assign(r214E, r2166, 0x01));

                                    body.emit(assign(r214F, r2165, 0x01));

                                    body.emit(assign(r214C, body.constant(int(0)), 0x01));

                                    body.emit(assign(r2152, less(r2165, body.constant(0u)), 0x01));


                                 body.instructions = f2161_parent_instructions;
                                 body.emit(f2161);

                                 /* END IF */


                              body.instructions = f215E_parent_instructions;
                              body.emit(f215E);

                              /* END IF */


                           body.instructions = f2154_parent_instructions;
                           body.emit(f2154);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f217D = new(mem_ctx) ir_if(operand(r2150).val);
                           exec_list *const f217D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f217D->then_instructions;

                              /* IF CONDITION */
                              ir_if *f217E = new(mem_ctx) ir_if(operand(r2152).val);
                              exec_list *const f217E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f217E->then_instructions;

                                 ir_variable *const r217F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r217F, add(r214E, body.constant(1u)), 0x01));

                                 ir_expression *const r2180 = less(r217F, r214E);
                                 ir_expression *const r2181 = expr(ir_unop_b2i, r2180);
                                 ir_expression *const r2182 = expr(ir_unop_i2u, r2181);
                                 body.emit(assign(r214D, add(r214D, r2182), 0x01));

                                 ir_expression *const r2183 = equal(r214F, body.constant(0u));
                                 ir_expression *const r2184 = expr(ir_unop_b2i, r2183);
                                 ir_expression *const r2185 = expr(ir_unop_i2u, r2184);
                                 ir_expression *const r2186 = add(r214F, r2185);
                                 ir_expression *const r2187 = bit_and(r2186, body.constant(1u));
                                 ir_expression *const r2188 = expr(ir_unop_bit_not, r2187);
                                 body.emit(assign(r214E, bit_and(r217F, r2188), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f217E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r218A = bit_or(r214D, r214E);
                                 ir_expression *const r218B = equal(r218A, body.constant(0u));
                                 ir_if *f2189 = new(mem_ctx) ir_if(operand(r218B).val);
                                 exec_list *const f2189_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2189->then_instructions;

                                    body.emit(assign(r214C, body.constant(int(0)), 0x01));


                                 body.instructions = f2189_parent_instructions;
                                 body.emit(f2189);

                                 /* END IF */


                              body.instructions = f217E_parent_instructions;
                              body.emit(f217E);

                              /* END IF */

                              ir_variable *const r218C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r218C);
                              ir_expression *const r218D = lshift(r1E62, body.constant(int(31)));
                              ir_expression *const r218E = expr(ir_unop_i2u, r214C);
                              ir_expression *const r218F = lshift(r218E, body.constant(int(20)));
                              ir_expression *const r2190 = add(r218D, r218F);
                              body.emit(assign(r218C, add(r2190, r214D), 0x02));

                              body.emit(assign(r218C, r214E, 0x01));

                              body.emit(assign(r2151, r218C, 0x03));

                              body.emit(assign(r2150, body.constant(false), 0x01));


                           body.instructions = f217D_parent_instructions;
                           body.emit(f217D);

                           /* END IF */

                           body.emit(assign(r1E63, r2151, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2105->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2192 = less(swizzle_x(r1E68), swizzle_x(r1E66));
                           ir_if *f2191 = new(mem_ctx) ir_if(operand(r2192).val);
                           exec_list *const f2191_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2191->then_instructions;

                              ir_variable *const r2193 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r2194 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2194, sub(swizzle_x(r1E66), swizzle_x(r1E68)), 0x01));

                              ir_expression *const r2195 = sub(swizzle_y(r1E66), swizzle_y(r1E68));
                              ir_expression *const r2196 = less(swizzle_x(r1E66), swizzle_x(r1E68));
                              ir_expression *const r2197 = expr(ir_unop_b2i, r2196);
                              ir_expression *const r2198 = expr(ir_unop_i2u, r2197);
                              body.emit(assign(r2193, sub(r2195, r2198), 0x01));

                              body.emit(assign(r1E62, bit_xor(r1E62, body.constant(1u)), 0x01));

                              body.emit(assign(r1E69, add(r1E65, body.constant(int(-1))), 0x01));

                              ir_variable *const r2199 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2199, add(r1E69, body.constant(int(-10))), 0x01));

                              ir_variable *const r219A = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r219A, r2193, 0x01));

                              ir_variable *const r219B = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r219B, r2194, 0x01));

                              ir_variable *const r219C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r219C);
                              ir_variable *const r219D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r219D);
                              /* IF CONDITION */
                              ir_expression *const r219F = equal(r2193, body.constant(0u));
                              ir_if *f219E = new(mem_ctx) ir_if(operand(r219F).val);
                              exec_list *const f219E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f219E->then_instructions;

                                 body.emit(assign(r219A, r2194, 0x01));

                                 body.emit(assign(r219B, body.constant(0u), 0x01));

                                 body.emit(assign(r2199, add(r2199, body.constant(int(-32))), 0x01));


                              body.instructions = f219E_parent_instructions;
                              body.emit(f219E);

                              /* END IF */

                              ir_variable *const r21A0 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r21A0, r219A, 0x01));

                              ir_variable *const r21A1 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r21A2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r21A2);
                              /* IF CONDITION */
                              ir_expression *const r21A4 = equal(r219A, body.constant(0u));
                              ir_if *f21A3 = new(mem_ctx) ir_if(operand(r21A4).val);
                              exec_list *const f21A3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f21A3->then_instructions;

                                 body.emit(assign(r21A1, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f21A3->else_instructions;

                                 body.emit(assign(r21A2, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r21A6 = bit_and(r219A, body.constant(4294901760u));
                                 ir_expression *const r21A7 = equal(r21A6, body.constant(0u));
                                 ir_if *f21A5 = new(mem_ctx) ir_if(operand(r21A7).val);
                                 exec_list *const f21A5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21A5->then_instructions;

                                    body.emit(assign(r21A2, body.constant(int(16)), 0x01));

                                    body.emit(assign(r21A0, lshift(r219A, body.constant(int(16))), 0x01));


                                 body.instructions = f21A5_parent_instructions;
                                 body.emit(f21A5);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r21A9 = bit_and(r21A0, body.constant(4278190080u));
                                 ir_expression *const r21AA = equal(r21A9, body.constant(0u));
                                 ir_if *f21A8 = new(mem_ctx) ir_if(operand(r21AA).val);
                                 exec_list *const f21A8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21A8->then_instructions;

                                    body.emit(assign(r21A2, add(r21A2, body.constant(int(8))), 0x01));

                                    body.emit(assign(r21A0, lshift(r21A0, body.constant(int(8))), 0x01));


                                 body.instructions = f21A8_parent_instructions;
                                 body.emit(f21A8);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r21AC = bit_and(r21A0, body.constant(4026531840u));
                                 ir_expression *const r21AD = equal(r21AC, body.constant(0u));
                                 ir_if *f21AB = new(mem_ctx) ir_if(operand(r21AD).val);
                                 exec_list *const f21AB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21AB->then_instructions;

                                    body.emit(assign(r21A2, add(r21A2, body.constant(int(4))), 0x01));

                                    body.emit(assign(r21A0, lshift(r21A0, body.constant(int(4))), 0x01));


                                 body.instructions = f21AB_parent_instructions;
                                 body.emit(f21AB);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r21AF = bit_and(r21A0, body.constant(3221225472u));
                                 ir_expression *const r21B0 = equal(r21AF, body.constant(0u));
                                 ir_if *f21AE = new(mem_ctx) ir_if(operand(r21B0).val);
                                 exec_list *const f21AE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21AE->then_instructions;

                                    body.emit(assign(r21A2, add(r21A2, body.constant(int(2))), 0x01));

                                    body.emit(assign(r21A0, lshift(r21A0, body.constant(int(2))), 0x01));


                                 body.instructions = f21AE_parent_instructions;
                                 body.emit(f21AE);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r21B2 = bit_and(r21A0, body.constant(2147483648u));
                                 ir_expression *const r21B3 = equal(r21B2, body.constant(0u));
                                 ir_if *f21B1 = new(mem_ctx) ir_if(operand(r21B3).val);
                                 exec_list *const f21B1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21B1->then_instructions;

                                    body.emit(assign(r21A2, add(r21A2, body.constant(int(1))), 0x01));


                                 body.instructions = f21B1_parent_instructions;
                                 body.emit(f21B1);

                                 /* END IF */

                                 body.emit(assign(r21A1, r21A2, 0x01));


                              body.instructions = f21A3_parent_instructions;
                              body.emit(f21A3);

                              /* END IF */

                              body.emit(assign(r219D, add(r21A1, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r21B5 = lequal(body.constant(int(0)), r219D);
                              ir_if *f21B4 = new(mem_ctx) ir_if(operand(r21B5).val);
                              exec_list *const f21B4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f21B4->then_instructions;

                                 body.emit(assign(r219C, body.constant(0u), 0x01));

                                 ir_variable *const r21B6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r21B6, lshift(r219B, r219D), 0x01));

                                 ir_variable *const r21B7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r21B9 = equal(r219D, body.constant(int(0)));
                                 ir_if *f21B8 = new(mem_ctx) ir_if(operand(r21B9).val);
                                 exec_list *const f21B8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21B8->then_instructions;

                                    body.emit(assign(r21B7, r219A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f21B8->else_instructions;

                                    ir_expression *const r21BA = lshift(r219A, r219D);
                                    ir_expression *const r21BB = neg(r219D);
                                    ir_expression *const r21BC = bit_and(r21BB, body.constant(int(31)));
                                    ir_expression *const r21BD = rshift(r219B, r21BC);
                                    body.emit(assign(r21B7, bit_or(r21BA, r21BD), 0x01));


                                 body.instructions = f21B8_parent_instructions;
                                 body.emit(f21B8);

                                 /* END IF */

                                 body.emit(assign(r219A, r21B7, 0x01));

                                 body.emit(assign(r219B, r21B6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f21B4->else_instructions;

                                 ir_variable *const r21BE = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r21BE, body.constant(0u), 0x01));

                                 ir_variable *const r21BF = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r21BF, neg(r219D), 0x01));

                                 ir_variable *const r21C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r21C0);
                                 ir_variable *const r21C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r21C1);
                                 ir_variable *const r21C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r21C2);
                                 ir_variable *const r21C3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r21C4 = neg(r21BF);
                                 body.emit(assign(r21C3, bit_and(r21C4, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r21C6 = equal(r21BF, body.constant(int(0)));
                                 ir_if *f21C5 = new(mem_ctx) ir_if(operand(r21C6).val);
                                 exec_list *const f21C5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21C5->then_instructions;

                                    body.emit(assign(r21C0, r21BE, 0x01));

                                    body.emit(assign(r21C1, r219B, 0x01));

                                    body.emit(assign(r21C2, r219A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f21C5->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r21C8 = less(r21BF, body.constant(int(32)));
                                    ir_if *f21C7 = new(mem_ctx) ir_if(operand(r21C8).val);
                                    exec_list *const f21C7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f21C7->then_instructions;

                                       body.emit(assign(r21C0, lshift(r219B, r21C3), 0x01));

                                       ir_expression *const r21C9 = lshift(r219A, r21C3);
                                       ir_expression *const r21CA = rshift(r219B, r21BF);
                                       body.emit(assign(r21C1, bit_or(r21C9, r21CA), 0x01));

                                       body.emit(assign(r21C2, rshift(r219A, r21BF), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f21C7->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r21CC = equal(r21BF, body.constant(int(32)));
                                       ir_if *f21CB = new(mem_ctx) ir_if(operand(r21CC).val);
                                       exec_list *const f21CB_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f21CB->then_instructions;

                                          body.emit(assign(r21C0, r219B, 0x01));

                                          body.emit(assign(r21C1, r219A, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f21CB->else_instructions;

                                          body.emit(assign(r21BE, bit_or(body.constant(0u), r219B), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r21CE = less(r21BF, body.constant(int(64)));
                                          ir_if *f21CD = new(mem_ctx) ir_if(operand(r21CE).val);
                                          exec_list *const f21CD_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f21CD->then_instructions;

                                             body.emit(assign(r21C0, lshift(r219A, r21C3), 0x01));

                                             ir_expression *const r21CF = bit_and(r21BF, body.constant(int(31)));
                                             body.emit(assign(r21C1, rshift(r219A, r21CF), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f21CD->else_instructions;

                                             ir_variable *const r21D0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r21D2 = equal(r21BF, body.constant(int(64)));
                                             ir_if *f21D1 = new(mem_ctx) ir_if(operand(r21D2).val);
                                             exec_list *const f21D1_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f21D1->then_instructions;

                                                body.emit(assign(r21D0, r219A, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f21D1->else_instructions;

                                                ir_expression *const r21D3 = nequal(r219A, body.constant(0u));
                                                ir_expression *const r21D4 = expr(ir_unop_b2i, r21D3);
                                                body.emit(assign(r21D0, expr(ir_unop_i2u, r21D4), 0x01));


                                             body.instructions = f21D1_parent_instructions;
                                             body.emit(f21D1);

                                             /* END IF */

                                             body.emit(assign(r21C0, r21D0, 0x01));

                                             body.emit(assign(r21C1, body.constant(0u), 0x01));


                                          body.instructions = f21CD_parent_instructions;
                                          body.emit(f21CD);

                                          /* END IF */


                                       body.instructions = f21CB_parent_instructions;
                                       body.emit(f21CB);

                                       /* END IF */

                                       body.emit(assign(r21C2, body.constant(0u), 0x01));


                                    body.instructions = f21C7_parent_instructions;
                                    body.emit(f21C7);

                                    /* END IF */

                                    ir_expression *const r21D5 = nequal(r21BE, body.constant(0u));
                                    ir_expression *const r21D6 = expr(ir_unop_b2i, r21D5);
                                    ir_expression *const r21D7 = expr(ir_unop_i2u, r21D6);
                                    body.emit(assign(r21C0, bit_or(r21C0, r21D7), 0x01));


                                 body.instructions = f21C5_parent_instructions;
                                 body.emit(f21C5);

                                 /* END IF */

                                 body.emit(assign(r219A, r21C2, 0x01));

                                 body.emit(assign(r219B, r21C1, 0x01));

                                 body.emit(assign(r219C, r21C0, 0x01));


                              body.instructions = f21B4_parent_instructions;
                              body.emit(f21B4);

                              /* END IF */

                              body.emit(assign(r2199, sub(r2199, r219D), 0x01));

                              ir_variable *const r21D8 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r21D8, r2199, 0x01));

                              ir_variable *const r21D9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r21D9, r219A, 0x01));

                              ir_variable *const r21DA = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r21DA, r219B, 0x01));

                              ir_variable *const r21DB = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r21DB, r219C, 0x01));

                              ir_variable *const r21DC = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r21DC, body.constant(true), 0x01));

                              ir_variable *const r21DD = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r21DE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r21DE);
                              ir_expression *const r21DF = expr(ir_unop_u2i, r219C);
                              body.emit(assign(r21DE, less(r21DF, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r21E1 = lequal(body.constant(int(2045)), r2199);
                              ir_if *f21E0 = new(mem_ctx) ir_if(operand(r21E1).val);
                              exec_list *const f21E0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f21E0->then_instructions;

                                 ir_variable *const r21E2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r21E4 = less(body.constant(int(2045)), r2199);
                                 ir_if *f21E3 = new(mem_ctx) ir_if(operand(r21E4).val);
                                 exec_list *const f21E3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21E3->then_instructions;

                                    body.emit(assign(r21E2, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f21E3->else_instructions;

                                    ir_variable *const r21E5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r21E7 = equal(r2199, body.constant(int(2045)));
                                    ir_if *f21E6 = new(mem_ctx) ir_if(operand(r21E7).val);
                                    exec_list *const f21E6_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f21E6->then_instructions;

                                       ir_expression *const r21E8 = equal(body.constant(2097151u), r219A);
                                       ir_expression *const r21E9 = equal(body.constant(4294967295u), r219B);
                                       body.emit(assign(r21E5, logic_and(r21E8, r21E9), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f21E6->else_instructions;

                                       body.emit(assign(r21E5, body.constant(false), 0x01));


                                    body.instructions = f21E6_parent_instructions;
                                    body.emit(f21E6);

                                    /* END IF */

                                    body.emit(assign(r21E2, logic_and(r21E5, r21DE), 0x01));


                                 body.instructions = f21E3_parent_instructions;
                                 body.emit(f21E3);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f21EA = new(mem_ctx) ir_if(operand(r21E2).val);
                                 exec_list *const f21EA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21EA->then_instructions;

                                    ir_variable *const r21EB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r21EB);
                                    ir_expression *const r21EC = lshift(r1E62, body.constant(int(31)));
                                    body.emit(assign(r21EB, add(r21EC, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r21EB, body.constant(0u), 0x01));

                                    body.emit(assign(r21DD, r21EB, 0x03));

                                    body.emit(assign(r21DC, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f21EA->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r21EE = less(r2199, body.constant(int(0)));
                                    ir_if *f21ED = new(mem_ctx) ir_if(operand(r21EE).val);
                                    exec_list *const f21ED_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f21ED->then_instructions;

                                       ir_variable *const r21EF = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r21EF, r219C, 0x01));

                                       ir_variable *const r21F0 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r21F0, neg(r2199), 0x01));

                                       ir_variable *const r21F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r21F1);
                                       ir_variable *const r21F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r21F2);
                                       ir_variable *const r21F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r21F3);
                                       ir_variable *const r21F4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r21F5 = neg(r21F0);
                                       body.emit(assign(r21F4, bit_and(r21F5, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r21F7 = equal(r21F0, body.constant(int(0)));
                                       ir_if *f21F6 = new(mem_ctx) ir_if(operand(r21F7).val);
                                       exec_list *const f21F6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f21F6->then_instructions;

                                          body.emit(assign(r21F1, r219C, 0x01));

                                          body.emit(assign(r21F2, r219B, 0x01));

                                          body.emit(assign(r21F3, r219A, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f21F6->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r21F9 = less(r21F0, body.constant(int(32)));
                                          ir_if *f21F8 = new(mem_ctx) ir_if(operand(r21F9).val);
                                          exec_list *const f21F8_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f21F8->then_instructions;

                                             body.emit(assign(r21F1, lshift(r219B, r21F4), 0x01));

                                             ir_expression *const r21FA = lshift(r219A, r21F4);
                                             ir_expression *const r21FB = rshift(r219B, r21F0);
                                             body.emit(assign(r21F2, bit_or(r21FA, r21FB), 0x01));

                                             body.emit(assign(r21F3, rshift(r219A, r21F0), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f21F8->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r21FD = equal(r21F0, body.constant(int(32)));
                                             ir_if *f21FC = new(mem_ctx) ir_if(operand(r21FD).val);
                                             exec_list *const f21FC_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f21FC->then_instructions;

                                                body.emit(assign(r21F1, r219B, 0x01));

                                                body.emit(assign(r21F2, r219A, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f21FC->else_instructions;

                                                body.emit(assign(r21EF, bit_or(r219C, r219B), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r21FF = less(r21F0, body.constant(int(64)));
                                                ir_if *f21FE = new(mem_ctx) ir_if(operand(r21FF).val);
                                                exec_list *const f21FE_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f21FE->then_instructions;

                                                   body.emit(assign(r21F1, lshift(r219A, r21F4), 0x01));

                                                   ir_expression *const r2200 = bit_and(r21F0, body.constant(int(31)));
                                                   body.emit(assign(r21F2, rshift(r219A, r2200), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f21FE->else_instructions;

                                                   ir_variable *const r2201 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r2203 = equal(r21F0, body.constant(int(64)));
                                                   ir_if *f2202 = new(mem_ctx) ir_if(operand(r2203).val);
                                                   exec_list *const f2202_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f2202->then_instructions;

                                                      body.emit(assign(r2201, r219A, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f2202->else_instructions;

                                                      ir_expression *const r2204 = nequal(r219A, body.constant(0u));
                                                      ir_expression *const r2205 = expr(ir_unop_b2i, r2204);
                                                      body.emit(assign(r2201, expr(ir_unop_i2u, r2205), 0x01));


                                                   body.instructions = f2202_parent_instructions;
                                                   body.emit(f2202);

                                                   /* END IF */

                                                   body.emit(assign(r21F1, r2201, 0x01));

                                                   body.emit(assign(r21F2, body.constant(0u), 0x01));


                                                body.instructions = f21FE_parent_instructions;
                                                body.emit(f21FE);

                                                /* END IF */


                                             body.instructions = f21FC_parent_instructions;
                                             body.emit(f21FC);

                                             /* END IF */

                                             body.emit(assign(r21F3, body.constant(0u), 0x01));


                                          body.instructions = f21F8_parent_instructions;
                                          body.emit(f21F8);

                                          /* END IF */

                                          ir_expression *const r2206 = nequal(r21EF, body.constant(0u));
                                          ir_expression *const r2207 = expr(ir_unop_b2i, r2206);
                                          ir_expression *const r2208 = expr(ir_unop_i2u, r2207);
                                          body.emit(assign(r21F1, bit_or(r21F1, r2208), 0x01));


                                       body.instructions = f21F6_parent_instructions;
                                       body.emit(f21F6);

                                       /* END IF */

                                       body.emit(assign(r21D9, r21F3, 0x01));

                                       body.emit(assign(r21DA, r21F2, 0x01));

                                       body.emit(assign(r21DB, r21F1, 0x01));

                                       body.emit(assign(r21D8, body.constant(int(0)), 0x01));

                                       body.emit(assign(r21DE, less(r21F1, body.constant(0u)), 0x01));


                                    body.instructions = f21ED_parent_instructions;
                                    body.emit(f21ED);

                                    /* END IF */


                                 body.instructions = f21EA_parent_instructions;
                                 body.emit(f21EA);

                                 /* END IF */


                              body.instructions = f21E0_parent_instructions;
                              body.emit(f21E0);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2209 = new(mem_ctx) ir_if(operand(r21DC).val);
                              exec_list *const f2209_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2209->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f220A = new(mem_ctx) ir_if(operand(r21DE).val);
                                 exec_list *const f220A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f220A->then_instructions;

                                    ir_variable *const r220B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r220B, add(r21DA, body.constant(1u)), 0x01));

                                    ir_expression *const r220C = less(r220B, r21DA);
                                    ir_expression *const r220D = expr(ir_unop_b2i, r220C);
                                    ir_expression *const r220E = expr(ir_unop_i2u, r220D);
                                    body.emit(assign(r21D9, add(r21D9, r220E), 0x01));

                                    ir_expression *const r220F = equal(r21DB, body.constant(0u));
                                    ir_expression *const r2210 = expr(ir_unop_b2i, r220F);
                                    ir_expression *const r2211 = expr(ir_unop_i2u, r2210);
                                    ir_expression *const r2212 = add(r21DB, r2211);
                                    ir_expression *const r2213 = bit_and(r2212, body.constant(1u));
                                    ir_expression *const r2214 = expr(ir_unop_bit_not, r2213);
                                    body.emit(assign(r21DA, bit_and(r220B, r2214), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f220A->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2216 = bit_or(r21D9, r21DA);
                                    ir_expression *const r2217 = equal(r2216, body.constant(0u));
                                    ir_if *f2215 = new(mem_ctx) ir_if(operand(r2217).val);
                                    exec_list *const f2215_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2215->then_instructions;

                                       body.emit(assign(r21D8, body.constant(int(0)), 0x01));


                                    body.instructions = f2215_parent_instructions;
                                    body.emit(f2215);

                                    /* END IF */


                                 body.instructions = f220A_parent_instructions;
                                 body.emit(f220A);

                                 /* END IF */

                                 ir_variable *const r2218 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2218);
                                 ir_expression *const r2219 = lshift(r1E62, body.constant(int(31)));
                                 ir_expression *const r221A = expr(ir_unop_i2u, r21D8);
                                 ir_expression *const r221B = lshift(r221A, body.constant(int(20)));
                                 ir_expression *const r221C = add(r2219, r221B);
                                 body.emit(assign(r2218, add(r221C, r21D9), 0x02));

                                 body.emit(assign(r2218, r21DA, 0x01));

                                 body.emit(assign(r21DD, r2218, 0x03));

                                 body.emit(assign(r21DC, body.constant(false), 0x01));


                              body.instructions = f2209_parent_instructions;
                              body.emit(f2209);

                              /* END IF */

                              body.emit(assign(r1E63, r21DD, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2191->else_instructions;

                              ir_variable *const r221D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r221D);
                              body.emit(assign(r221D, body.constant(0u), 0x02));

                              body.emit(assign(r221D, body.constant(0u), 0x01));

                              body.emit(assign(r1E63, r221D, 0x03));


                           body.instructions = f2191_parent_instructions;
                           body.emit(f2191);

                           /* END IF */


                        body.instructions = f2105_parent_instructions;
                        body.emit(f2105);

                        /* END IF */


                     body.instructions = f2079_parent_instructions;
                     body.emit(f2079);

                     /* END IF */


                  body.instructions = f1FED_parent_instructions;
                  body.emit(f1FED);

                  /* END IF */


               body.instructions = f1FD8_parent_instructions;
               body.emit(f1FD8);

               /* END IF */


            body.instructions = f1F27_parent_instructions;
            body.emit(f1F27);

            /* END IF */


         body.instructions = f1E74_parent_instructions;
         body.emit(f1E74);

         /* END IF */

         body.emit(assign(r1E5E, r1E63, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1E60->else_instructions;

         ir_variable *const r221E = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r221E, body.constant(true), 0x01));

         ir_variable *const r221F = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2220 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2220);
         ir_variable *const r2221 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r2221);
         ir_variable *const r2222 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r2222);
         ir_variable *const r2223 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2223);
         ir_variable *const r2224 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r2224);
         ir_variable *const r2225 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r2225);
         body.emit(assign(r2225, body.constant(0u), 0x01));

         body.emit(assign(r2224, body.constant(0u), 0x01));

         ir_variable *const r2226 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r2226);
         body.emit(assign(r2226, bit_and(swizzle_y(r1E29), body.constant(1048575u)), 0x02));

         body.emit(assign(r2226, swizzle_x(r1E29), 0x01));

         body.emit(assign(r2222, r2226, 0x03));

         ir_variable *const r2227 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2228 = rshift(swizzle_y(r1E29), body.constant(int(20)));
         ir_expression *const r2229 = bit_and(r2228, body.constant(2047u));
         body.emit(assign(r2227, expr(ir_unop_u2i, r2229), 0x01));

         ir_variable *const r222A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r222A);
         body.emit(assign(r222A, body.constant(0u), 0x02));

         body.emit(assign(r222A, body.constant(0u), 0x01));

         body.emit(assign(r2221, r222A, 0x03));

         ir_variable *const r222B = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r222B, body.constant(int(1023)), 0x01));

         ir_variable *const r222C = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r222C, add(r2227, body.constant(int(-1023))), 0x01));

         body.emit(assign(r2220, r222C, 0x01));

         /* IF CONDITION */
         ir_expression *const r222E = less(body.constant(int(0)), r222C);
         ir_if *f222D = new(mem_ctx) ir_if(operand(r222E).val);
         exec_list *const f222D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f222D->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2230 = equal(r2227, body.constant(int(2047)));
            ir_if *f222F = new(mem_ctx) ir_if(operand(r2230).val);
            exec_list *const f222F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f222F->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2232 = bit_or(swizzle_y(r2226), swizzle_x(r1E29));
               ir_expression *const r2233 = nequal(r2232, body.constant(0u));
               ir_if *f2231 = new(mem_ctx) ir_if(operand(r2233).val);
               exec_list *const f2231_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2231->then_instructions;

                  ir_variable *const r2234 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2234, swizzle_x(r1E29), 0x01));

                  ir_variable *const r2235 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2235, body.constant(0u), 0x01));

                  ir_variable *const r2236 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2234, bit_or(swizzle_y(r1E29), body.constant(524288u)), 0x02));

                  body.emit(assign(r2235, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2238 = lshift(swizzle_y(r1E29), body.constant(int(1)));
                  ir_expression *const r2239 = lequal(body.constant(4292870144u), r2238);
                  ir_expression *const r223A = nequal(swizzle_x(r1E29), body.constant(0u));
                  ir_expression *const r223B = bit_and(swizzle_y(r1E29), body.constant(1048575u));
                  ir_expression *const r223C = nequal(r223B, body.constant(0u));
                  ir_expression *const r223D = logic_or(r223A, r223C);
                  ir_expression *const r223E = logic_and(r2239, r223D);
                  ir_if *f2237 = new(mem_ctx) ir_if(operand(r223E).val);
                  exec_list *const f2237_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2237->then_instructions;

                     body.emit(assign(r2236, r2234, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2237->else_instructions;

                     body.emit(assign(r2236, r2235, 0x03));


                  body.instructions = f2237_parent_instructions;
                  body.emit(f2237);

                  /* END IF */

                  body.emit(assign(r221F, r2236, 0x03));

                  body.emit(assign(r221E, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2231->else_instructions;

                  body.emit(assign(r221F, r1E29, 0x03));

                  body.emit(assign(r221E, body.constant(false), 0x01));


               body.instructions = f2231_parent_instructions;
               body.emit(f2231);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f222F->else_instructions;

               body.emit(assign(r2221, body.constant(1048576u), 0x02));

               ir_variable *const r223F = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r223F, swizzle_y(r2221), 0x01));

               ir_variable *const r2240 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r2240, swizzle_x(r2221), 0x01));

               ir_variable *const r2241 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2241, body.constant(0u), 0x01));

               ir_variable *const r2242 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2242);
               ir_variable *const r2243 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2243);
               ir_variable *const r2244 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2244);
               ir_variable *const r2245 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2246 = neg(r222C);
               body.emit(assign(r2245, bit_and(r2246, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2248 = equal(r222C, body.constant(int(0)));
               ir_if *f2247 = new(mem_ctx) ir_if(operand(r2248).val);
               exec_list *const f2247_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2247->then_instructions;

                  body.emit(assign(r2242, r2241, 0x01));

                  body.emit(assign(r2243, r2240, 0x01));

                  body.emit(assign(r2244, r223F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2247->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r224A = less(r222C, body.constant(int(32)));
                  ir_if *f2249 = new(mem_ctx) ir_if(operand(r224A).val);
                  exec_list *const f2249_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2249->then_instructions;

                     body.emit(assign(r2242, body.constant(0u), 0x01));

                     ir_expression *const r224B = lshift(body.constant(1048576u), r2245);
                     body.emit(assign(r2243, bit_or(r224B, body.constant(0u)), 0x01));

                     body.emit(assign(r2244, rshift(body.constant(1048576u), r222C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2249->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r224D = equal(r222C, body.constant(int(32)));
                     ir_if *f224C = new(mem_ctx) ir_if(operand(r224D).val);
                     exec_list *const f224C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f224C->then_instructions;

                        body.emit(assign(r2242, r2240, 0x01));

                        body.emit(assign(r2243, r223F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f224C->else_instructions;

                        body.emit(assign(r2241, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r224F = less(r222C, body.constant(int(64)));
                        ir_if *f224E = new(mem_ctx) ir_if(operand(r224F).val);
                        exec_list *const f224E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f224E->then_instructions;

                           body.emit(assign(r2242, lshift(body.constant(1048576u), r2245), 0x01));

                           ir_expression *const r2250 = bit_and(r222C, body.constant(int(31)));
                           body.emit(assign(r2243, rshift(body.constant(1048576u), r2250), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f224E->else_instructions;

                           ir_variable *const r2251 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2253 = equal(r222C, body.constant(int(64)));
                           ir_if *f2252 = new(mem_ctx) ir_if(operand(r2253).val);
                           exec_list *const f2252_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2252->then_instructions;

                              body.emit(assign(r2251, r223F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2252->else_instructions;

                              body.emit(assign(r2251, body.constant(1u), 0x01));


                           body.instructions = f2252_parent_instructions;
                           body.emit(f2252);

                           /* END IF */

                           body.emit(assign(r2242, r2251, 0x01));

                           body.emit(assign(r2243, body.constant(0u), 0x01));


                        body.instructions = f224E_parent_instructions;
                        body.emit(f224E);

                        /* END IF */


                     body.instructions = f224C_parent_instructions;
                     body.emit(f224C);

                     /* END IF */

                     body.emit(assign(r2244, body.constant(0u), 0x01));


                  body.instructions = f2249_parent_instructions;
                  body.emit(f2249);

                  /* END IF */

                  ir_expression *const r2254 = nequal(r2241, body.constant(0u));
                  ir_expression *const r2255 = expr(ir_unop_b2i, r2254);
                  ir_expression *const r2256 = expr(ir_unop_i2u, r2255);
                  body.emit(assign(r2242, bit_or(r2242, r2256), 0x01));


               body.instructions = f2247_parent_instructions;
               body.emit(f2247);

               /* END IF */

               body.emit(assign(r2221, r2244, 0x02));

               body.emit(assign(r2221, r2243, 0x01));

               body.emit(assign(r2224, r2242, 0x01));

               body.emit(assign(r2223, r2227, 0x01));


            body.instructions = f222F_parent_instructions;
            body.emit(f222F);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f222D->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2258 = less(r222C, body.constant(int(0)));
            ir_if *f2257 = new(mem_ctx) ir_if(operand(r2258).val);
            exec_list *const f2257_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2257->then_instructions;

               /* IF CONDITION */
               ir_expression *const r225A = equal(r2227, body.constant(int(0)));
               ir_if *f2259 = new(mem_ctx) ir_if(operand(r225A).val);
               exec_list *const f2259_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2259->then_instructions;

                  body.emit(assign(r2220, add(r222C, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2259->else_instructions;

                  body.emit(assign(r2222, bit_or(swizzle_y(r2226), body.constant(1048576u)), 0x02));


               body.instructions = f2259_parent_instructions;
               body.emit(f2259);

               /* END IF */

               ir_variable *const r225B = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r225B, swizzle_y(r2222), 0x01));

               ir_variable *const r225C = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r225C, swizzle_x(r2222), 0x01));

               ir_variable *const r225D = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r225D, body.constant(0u), 0x01));

               ir_variable *const r225E = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r225E, neg(r2220), 0x01));

               ir_variable *const r225F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r225F);
               ir_variable *const r2260 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2260);
               ir_variable *const r2261 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2261);
               ir_variable *const r2262 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2263 = neg(r225E);
               body.emit(assign(r2262, bit_and(r2263, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2265 = equal(r225E, body.constant(int(0)));
               ir_if *f2264 = new(mem_ctx) ir_if(operand(r2265).val);
               exec_list *const f2264_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2264->then_instructions;

                  body.emit(assign(r225F, r225D, 0x01));

                  body.emit(assign(r2260, r225C, 0x01));

                  body.emit(assign(r2261, r225B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2264->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2267 = less(r225E, body.constant(int(32)));
                  ir_if *f2266 = new(mem_ctx) ir_if(operand(r2267).val);
                  exec_list *const f2266_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2266->then_instructions;

                     body.emit(assign(r225F, lshift(swizzle_x(r2226), r2262), 0x01));

                     ir_expression *const r2268 = lshift(swizzle_y(r2222), r2262);
                     ir_expression *const r2269 = rshift(swizzle_x(r2226), r225E);
                     body.emit(assign(r2260, bit_or(r2268, r2269), 0x01));

                     body.emit(assign(r2261, rshift(swizzle_y(r2222), r225E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2266->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r226B = equal(r225E, body.constant(int(32)));
                     ir_if *f226A = new(mem_ctx) ir_if(operand(r226B).val);
                     exec_list *const f226A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f226A->then_instructions;

                        body.emit(assign(r225F, r225C, 0x01));

                        body.emit(assign(r2260, r225B, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f226A->else_instructions;

                        body.emit(assign(r225D, bit_or(body.constant(0u), swizzle_x(r2226)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r226D = less(r225E, body.constant(int(64)));
                        ir_if *f226C = new(mem_ctx) ir_if(operand(r226D).val);
                        exec_list *const f226C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f226C->then_instructions;

                           body.emit(assign(r225F, lshift(swizzle_y(r2222), r2262), 0x01));

                           ir_expression *const r226E = bit_and(r225E, body.constant(int(31)));
                           body.emit(assign(r2260, rshift(swizzle_y(r2222), r226E), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f226C->else_instructions;

                           ir_variable *const r226F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2271 = equal(r225E, body.constant(int(64)));
                           ir_if *f2270 = new(mem_ctx) ir_if(operand(r2271).val);
                           exec_list *const f2270_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2270->then_instructions;

                              body.emit(assign(r226F, r225B, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2270->else_instructions;

                              ir_expression *const r2272 = nequal(swizzle_y(r2222), body.constant(0u));
                              ir_expression *const r2273 = expr(ir_unop_b2i, r2272);
                              body.emit(assign(r226F, expr(ir_unop_i2u, r2273), 0x01));


                           body.instructions = f2270_parent_instructions;
                           body.emit(f2270);

                           /* END IF */

                           body.emit(assign(r225F, r226F, 0x01));

                           body.emit(assign(r2260, body.constant(0u), 0x01));


                        body.instructions = f226C_parent_instructions;
                        body.emit(f226C);

                        /* END IF */


                     body.instructions = f226A_parent_instructions;
                     body.emit(f226A);

                     /* END IF */

                     body.emit(assign(r2261, body.constant(0u), 0x01));


                  body.instructions = f2266_parent_instructions;
                  body.emit(f2266);

                  /* END IF */

                  ir_expression *const r2274 = nequal(r225D, body.constant(0u));
                  ir_expression *const r2275 = expr(ir_unop_b2i, r2274);
                  ir_expression *const r2276 = expr(ir_unop_i2u, r2275);
                  body.emit(assign(r225F, bit_or(r225F, r2276), 0x01));


               body.instructions = f2264_parent_instructions;
               body.emit(f2264);

               /* END IF */

               body.emit(assign(r2222, r2261, 0x02));

               body.emit(assign(r2222, r2260, 0x01));

               body.emit(assign(r2224, r225F, 0x01));

               body.emit(assign(r2223, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2257->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2278 = equal(r2227, body.constant(int(2047)));
               ir_if *f2277 = new(mem_ctx) ir_if(operand(r2278).val);
               exec_list *const f2277_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2277->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r227A = bit_or(swizzle_y(r2222), swizzle_x(r2222));
                  ir_expression *const r227B = bit_or(swizzle_y(r2221), swizzle_x(r2221));
                  ir_expression *const r227C = bit_or(r227A, r227B);
                  ir_expression *const r227D = nequal(r227C, body.constant(0u));
                  ir_if *f2279 = new(mem_ctx) ir_if(operand(r227D).val);
                  exec_list *const f2279_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2279->then_instructions;

                     ir_variable *const r227E = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r227E, swizzle_x(r1E29), 0x01));

                     ir_variable *const r227F = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r227F, body.constant(0u), 0x01));

                     ir_variable *const r2280 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r227E, bit_or(swizzle_y(r1E29), body.constant(524288u)), 0x02));

                     body.emit(assign(r227F, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2282 = lshift(swizzle_y(r1E29), body.constant(int(1)));
                     ir_expression *const r2283 = lequal(body.constant(4292870144u), r2282);
                     ir_expression *const r2284 = nequal(swizzle_x(r1E29), body.constant(0u));
                     ir_expression *const r2285 = bit_and(swizzle_y(r1E29), body.constant(1048575u));
                     ir_expression *const r2286 = nequal(r2285, body.constant(0u));
                     ir_expression *const r2287 = logic_or(r2284, r2286);
                     ir_expression *const r2288 = logic_and(r2283, r2287);
                     ir_if *f2281 = new(mem_ctx) ir_if(operand(r2288).val);
                     exec_list *const f2281_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2281->then_instructions;

                        body.emit(assign(r2280, r227E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2281->else_instructions;

                        body.emit(assign(r2280, r227F, 0x03));


                     body.instructions = f2281_parent_instructions;
                     body.emit(f2281);

                     /* END IF */

                     body.emit(assign(r221F, r2280, 0x03));

                     body.emit(assign(r221E, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2279->else_instructions;

                     body.emit(assign(r221F, r1E29, 0x03));

                     body.emit(assign(r221E, body.constant(false), 0x01));


                  body.instructions = f2279_parent_instructions;
                  body.emit(f2279);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2277->else_instructions;

                  ir_variable *const r2289 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r228A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r228A, add(swizzle_x(r2222), swizzle_x(r2221)), 0x01));

                  ir_expression *const r228B = add(swizzle_y(r2222), swizzle_y(r2221));
                  ir_expression *const r228C = less(r228A, swizzle_x(r2222));
                  ir_expression *const r228D = expr(ir_unop_b2i, r228C);
                  ir_expression *const r228E = expr(ir_unop_i2u, r228D);
                  body.emit(assign(r2289, add(r228B, r228E), 0x01));

                  body.emit(assign(r2225, r2289, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2290 = equal(r2227, body.constant(int(0)));
                  ir_if *f228F = new(mem_ctx) ir_if(operand(r2290).val);
                  exec_list *const f228F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f228F->then_instructions;

                     ir_variable *const r2291 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2291);
                     ir_expression *const r2292 = lshift(r1E5F, body.constant(int(31)));
                     body.emit(assign(r2291, add(r2292, r2289), 0x02));

                     body.emit(assign(r2291, r228A, 0x01));

                     body.emit(assign(r221F, r2291, 0x03));

                     body.emit(assign(r221E, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f228F->else_instructions;

                     body.emit(assign(r2225, bit_or(r2289, body.constant(2097152u)), 0x01));

                     body.emit(assign(r2223, r2227, 0x01));

                     ir_variable *const r2293 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2293);
                     ir_variable *const r2294 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2294);
                     ir_variable *const r2295 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2295);
                     body.emit(assign(r2293, lshift(r228A, body.constant(int(31))), 0x01));

                     ir_expression *const r2296 = lshift(r2225, body.constant(int(31)));
                     ir_expression *const r2297 = rshift(r228A, body.constant(int(1)));
                     body.emit(assign(r2294, bit_or(r2296, r2297), 0x01));

                     body.emit(assign(r2295, rshift(r2225, body.constant(int(1))), 0x01));

                     body.emit(assign(r2293, bit_or(r2293, body.constant(0u)), 0x01));

                     body.emit(assign(r2225, r2295, 0x01));

                     body.emit(assign(r2224, r2293, 0x01));

                     ir_variable *const r2298 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2298, r2227, 0x01));

                     ir_variable *const r2299 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2299, r2295, 0x01));

                     ir_variable *const r229A = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r229A, r2294, 0x01));

                     ir_variable *const r229B = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r229B, r2293, 0x01));

                     ir_variable *const r229C = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r229C, body.constant(true), 0x01));

                     ir_variable *const r229D = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r229E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r229E);
                     ir_expression *const r229F = expr(ir_unop_u2i, r2293);
                     body.emit(assign(r229E, less(r229F, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r22A1 = lequal(body.constant(int(2045)), r2227);
                     ir_if *f22A0 = new(mem_ctx) ir_if(operand(r22A1).val);
                     exec_list *const f22A0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22A0->then_instructions;

                        ir_variable *const r22A2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r22A4 = less(body.constant(int(2045)), r2227);
                        ir_if *f22A3 = new(mem_ctx) ir_if(operand(r22A4).val);
                        exec_list *const f22A3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22A3->then_instructions;

                           body.emit(assign(r22A2, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22A3->else_instructions;

                           ir_variable *const r22A5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r22A7 = equal(r2227, body.constant(int(2045)));
                           ir_if *f22A6 = new(mem_ctx) ir_if(operand(r22A7).val);
                           exec_list *const f22A6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22A6->then_instructions;

                              ir_expression *const r22A8 = equal(body.constant(2097151u), r2295);
                              ir_expression *const r22A9 = equal(body.constant(4294967295u), r2294);
                              body.emit(assign(r22A5, logic_and(r22A8, r22A9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f22A6->else_instructions;

                              body.emit(assign(r22A5, body.constant(false), 0x01));


                           body.instructions = f22A6_parent_instructions;
                           body.emit(f22A6);

                           /* END IF */

                           body.emit(assign(r22A2, logic_and(r22A5, r229E), 0x01));


                        body.instructions = f22A3_parent_instructions;
                        body.emit(f22A3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f22AA = new(mem_ctx) ir_if(operand(r22A2).val);
                        exec_list *const f22AA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22AA->then_instructions;

                           ir_variable *const r22AB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r22AB);
                           ir_expression *const r22AC = lshift(r1E5F, body.constant(int(31)));
                           body.emit(assign(r22AB, add(r22AC, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r22AB, body.constant(0u), 0x01));

                           body.emit(assign(r229D, r22AB, 0x03));

                           body.emit(assign(r229C, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22AA->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r22AE = less(r2227, body.constant(int(0)));
                           ir_if *f22AD = new(mem_ctx) ir_if(operand(r22AE).val);
                           exec_list *const f22AD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22AD->then_instructions;

                              ir_variable *const r22AF = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r22AF, r2293, 0x01));

                              ir_variable *const r22B0 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r22B0, neg(r2227), 0x01));

                              ir_variable *const r22B1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r22B1);
                              ir_variable *const r22B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r22B2);
                              ir_variable *const r22B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r22B3);
                              ir_variable *const r22B4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r22B5 = neg(r22B0);
                              body.emit(assign(r22B4, bit_and(r22B5, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r22B7 = equal(r22B0, body.constant(int(0)));
                              ir_if *f22B6 = new(mem_ctx) ir_if(operand(r22B7).val);
                              exec_list *const f22B6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f22B6->then_instructions;

                                 body.emit(assign(r22B1, r2293, 0x01));

                                 body.emit(assign(r22B2, r2294, 0x01));

                                 body.emit(assign(r22B3, r2295, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f22B6->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r22B9 = less(r22B0, body.constant(int(32)));
                                 ir_if *f22B8 = new(mem_ctx) ir_if(operand(r22B9).val);
                                 exec_list *const f22B8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f22B8->then_instructions;

                                    body.emit(assign(r22B1, lshift(r2294, r22B4), 0x01));

                                    ir_expression *const r22BA = lshift(r2295, r22B4);
                                    ir_expression *const r22BB = rshift(r2294, r22B0);
                                    body.emit(assign(r22B2, bit_or(r22BA, r22BB), 0x01));

                                    body.emit(assign(r22B3, rshift(r2295, r22B0), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f22B8->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r22BD = equal(r22B0, body.constant(int(32)));
                                    ir_if *f22BC = new(mem_ctx) ir_if(operand(r22BD).val);
                                    exec_list *const f22BC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f22BC->then_instructions;

                                       body.emit(assign(r22B1, r2294, 0x01));

                                       body.emit(assign(r22B2, r2295, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f22BC->else_instructions;

                                       body.emit(assign(r22AF, bit_or(r2293, r2294), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r22BF = less(r22B0, body.constant(int(64)));
                                       ir_if *f22BE = new(mem_ctx) ir_if(operand(r22BF).val);
                                       exec_list *const f22BE_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f22BE->then_instructions;

                                          body.emit(assign(r22B1, lshift(r2295, r22B4), 0x01));

                                          ir_expression *const r22C0 = bit_and(r22B0, body.constant(int(31)));
                                          body.emit(assign(r22B2, rshift(r2295, r22C0), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f22BE->else_instructions;

                                          ir_variable *const r22C1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r22C3 = equal(r22B0, body.constant(int(64)));
                                          ir_if *f22C2 = new(mem_ctx) ir_if(operand(r22C3).val);
                                          exec_list *const f22C2_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f22C2->then_instructions;

                                             body.emit(assign(r22C1, r2295, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f22C2->else_instructions;

                                             ir_expression *const r22C4 = nequal(r2295, body.constant(0u));
                                             ir_expression *const r22C5 = expr(ir_unop_b2i, r22C4);
                                             body.emit(assign(r22C1, expr(ir_unop_i2u, r22C5), 0x01));


                                          body.instructions = f22C2_parent_instructions;
                                          body.emit(f22C2);

                                          /* END IF */

                                          body.emit(assign(r22B1, r22C1, 0x01));

                                          body.emit(assign(r22B2, body.constant(0u), 0x01));


                                       body.instructions = f22BE_parent_instructions;
                                       body.emit(f22BE);

                                       /* END IF */


                                    body.instructions = f22BC_parent_instructions;
                                    body.emit(f22BC);

                                    /* END IF */

                                    body.emit(assign(r22B3, body.constant(0u), 0x01));


                                 body.instructions = f22B8_parent_instructions;
                                 body.emit(f22B8);

                                 /* END IF */

                                 ir_expression *const r22C6 = nequal(r22AF, body.constant(0u));
                                 ir_expression *const r22C7 = expr(ir_unop_b2i, r22C6);
                                 ir_expression *const r22C8 = expr(ir_unop_i2u, r22C7);
                                 body.emit(assign(r22B1, bit_or(r22B1, r22C8), 0x01));


                              body.instructions = f22B6_parent_instructions;
                              body.emit(f22B6);

                              /* END IF */

                              body.emit(assign(r2299, r22B3, 0x01));

                              body.emit(assign(r229A, r22B2, 0x01));

                              body.emit(assign(r229B, r22B1, 0x01));

                              body.emit(assign(r2298, body.constant(int(0)), 0x01));

                              body.emit(assign(r229E, less(r22B1, body.constant(0u)), 0x01));


                           body.instructions = f22AD_parent_instructions;
                           body.emit(f22AD);

                           /* END IF */


                        body.instructions = f22AA_parent_instructions;
                        body.emit(f22AA);

                        /* END IF */


                     body.instructions = f22A0_parent_instructions;
                     body.emit(f22A0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f22C9 = new(mem_ctx) ir_if(operand(r229C).val);
                     exec_list *const f22C9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22C9->then_instructions;

                        /* IF CONDITION */
                        ir_if *f22CA = new(mem_ctx) ir_if(operand(r229E).val);
                        exec_list *const f22CA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22CA->then_instructions;

                           ir_variable *const r22CB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r22CB, add(r229A, body.constant(1u)), 0x01));

                           ir_expression *const r22CC = less(r22CB, r229A);
                           ir_expression *const r22CD = expr(ir_unop_b2i, r22CC);
                           ir_expression *const r22CE = expr(ir_unop_i2u, r22CD);
                           body.emit(assign(r2299, add(r2299, r22CE), 0x01));

                           ir_expression *const r22CF = equal(r229B, body.constant(0u));
                           ir_expression *const r22D0 = expr(ir_unop_b2i, r22CF);
                           ir_expression *const r22D1 = expr(ir_unop_i2u, r22D0);
                           ir_expression *const r22D2 = add(r229B, r22D1);
                           ir_expression *const r22D3 = bit_and(r22D2, body.constant(1u));
                           ir_expression *const r22D4 = expr(ir_unop_bit_not, r22D3);
                           body.emit(assign(r229A, bit_and(r22CB, r22D4), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22CA->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r22D6 = bit_or(r2299, r229A);
                           ir_expression *const r22D7 = equal(r22D6, body.constant(0u));
                           ir_if *f22D5 = new(mem_ctx) ir_if(operand(r22D7).val);
                           exec_list *const f22D5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22D5->then_instructions;

                              body.emit(assign(r2298, body.constant(int(0)), 0x01));


                           body.instructions = f22D5_parent_instructions;
                           body.emit(f22D5);

                           /* END IF */


                        body.instructions = f22CA_parent_instructions;
                        body.emit(f22CA);

                        /* END IF */

                        ir_variable *const r22D8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r22D8);
                        ir_expression *const r22D9 = lshift(r1E5F, body.constant(int(31)));
                        ir_expression *const r22DA = expr(ir_unop_i2u, r2298);
                        ir_expression *const r22DB = lshift(r22DA, body.constant(int(20)));
                        ir_expression *const r22DC = add(r22D9, r22DB);
                        body.emit(assign(r22D8, add(r22DC, r2299), 0x02));

                        body.emit(assign(r22D8, r229A, 0x01));

                        body.emit(assign(r229D, r22D8, 0x03));

                        body.emit(assign(r229C, body.constant(false), 0x01));


                     body.instructions = f22C9_parent_instructions;
                     body.emit(f22C9);

                     /* END IF */

                     body.emit(assign(r221F, r229D, 0x03));

                     body.emit(assign(r221E, body.constant(false), 0x01));


                  body.instructions = f228F_parent_instructions;
                  body.emit(f228F);

                  /* END IF */


               body.instructions = f2277_parent_instructions;
               body.emit(f2277);

               /* END IF */


            body.instructions = f2257_parent_instructions;
            body.emit(f2257);

            /* END IF */


         body.instructions = f222D_parent_instructions;
         body.emit(f222D);

         /* END IF */

         /* IF CONDITION */
         ir_if *f22DD = new(mem_ctx) ir_if(operand(r221E).val);
         exec_list *const f22DD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f22DD->then_instructions;

            body.emit(assign(r2222, bit_or(swizzle_y(r2222), body.constant(1048576u)), 0x02));

            ir_variable *const r22DE = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r22DF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r22DF, add(swizzle_x(r2222), swizzle_x(r2221)), 0x01));

            ir_expression *const r22E0 = add(swizzle_y(r2222), swizzle_y(r2221));
            ir_expression *const r22E1 = less(r22DF, swizzle_x(r2222));
            ir_expression *const r22E2 = expr(ir_unop_b2i, r22E1);
            ir_expression *const r22E3 = expr(ir_unop_i2u, r22E2);
            body.emit(assign(r22DE, add(r22E0, r22E3), 0x01));

            body.emit(assign(r2225, r22DE, 0x01));

            body.emit(assign(r2223, add(r2223, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r22E5 = less(r22DE, body.constant(2097152u));
            ir_if *f22E4 = new(mem_ctx) ir_if(operand(r22E5).val);
            exec_list *const f22E4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f22E4->then_instructions;

               ir_variable *const r22E6 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r22E6, r2223, 0x01));

               ir_variable *const r22E7 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r22E7, r22DE, 0x01));

               ir_variable *const r22E8 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r22E8, r22DF, 0x01));

               ir_variable *const r22E9 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r22E9, r2224, 0x01));

               ir_variable *const r22EA = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r22EA, body.constant(true), 0x01));

               ir_variable *const r22EB = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r22EC = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r22EC);
               ir_expression *const r22ED = expr(ir_unop_u2i, r2224);
               body.emit(assign(r22EC, less(r22ED, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r22EF = lequal(body.constant(int(2045)), r2223);
               ir_if *f22EE = new(mem_ctx) ir_if(operand(r22EF).val);
               exec_list *const f22EE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f22EE->then_instructions;

                  ir_variable *const r22F0 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r22F2 = less(body.constant(int(2045)), r2223);
                  ir_if *f22F1 = new(mem_ctx) ir_if(operand(r22F2).val);
                  exec_list *const f22F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f22F1->then_instructions;

                     body.emit(assign(r22F0, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f22F1->else_instructions;

                     ir_variable *const r22F3 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r22F5 = equal(r2223, body.constant(int(2045)));
                     ir_if *f22F4 = new(mem_ctx) ir_if(operand(r22F5).val);
                     exec_list *const f22F4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22F4->then_instructions;

                        ir_expression *const r22F6 = equal(body.constant(2097151u), r22DE);
                        ir_expression *const r22F7 = equal(body.constant(4294967295u), r22DF);
                        body.emit(assign(r22F3, logic_and(r22F6, r22F7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f22F4->else_instructions;

                        body.emit(assign(r22F3, body.constant(false), 0x01));


                     body.instructions = f22F4_parent_instructions;
                     body.emit(f22F4);

                     /* END IF */

                     body.emit(assign(r22F0, logic_and(r22F3, r22EC), 0x01));


                  body.instructions = f22F1_parent_instructions;
                  body.emit(f22F1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f22F8 = new(mem_ctx) ir_if(operand(r22F0).val);
                  exec_list *const f22F8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f22F8->then_instructions;

                     ir_variable *const r22F9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r22F9);
                     ir_expression *const r22FA = lshift(r1E5F, body.constant(int(31)));
                     body.emit(assign(r22F9, add(r22FA, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r22F9, body.constant(0u), 0x01));

                     body.emit(assign(r22EB, r22F9, 0x03));

                     body.emit(assign(r22EA, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f22F8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r22FC = less(r2223, body.constant(int(0)));
                     ir_if *f22FB = new(mem_ctx) ir_if(operand(r22FC).val);
                     exec_list *const f22FB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22FB->then_instructions;

                        ir_variable *const r22FD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r22FD, r2224, 0x01));

                        ir_variable *const r22FE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r22FE, neg(r2223), 0x01));

                        ir_variable *const r22FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r22FF);
                        ir_variable *const r2300 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2300);
                        ir_variable *const r2301 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2301);
                        ir_variable *const r2302 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2303 = neg(r22FE);
                        body.emit(assign(r2302, bit_and(r2303, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2305 = equal(r22FE, body.constant(int(0)));
                        ir_if *f2304 = new(mem_ctx) ir_if(operand(r2305).val);
                        exec_list *const f2304_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2304->then_instructions;

                           body.emit(assign(r22FF, r2224, 0x01));

                           body.emit(assign(r2300, r22DF, 0x01));

                           body.emit(assign(r2301, r22DE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2304->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2307 = less(r22FE, body.constant(int(32)));
                           ir_if *f2306 = new(mem_ctx) ir_if(operand(r2307).val);
                           exec_list *const f2306_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2306->then_instructions;

                              body.emit(assign(r22FF, lshift(r22DF, r2302), 0x01));

                              ir_expression *const r2308 = lshift(r22DE, r2302);
                              ir_expression *const r2309 = rshift(r22DF, r22FE);
                              body.emit(assign(r2300, bit_or(r2308, r2309), 0x01));

                              body.emit(assign(r2301, rshift(r22DE, r22FE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2306->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r230B = equal(r22FE, body.constant(int(32)));
                              ir_if *f230A = new(mem_ctx) ir_if(operand(r230B).val);
                              exec_list *const f230A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f230A->then_instructions;

                                 body.emit(assign(r22FF, r22DF, 0x01));

                                 body.emit(assign(r2300, r22DE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f230A->else_instructions;

                                 body.emit(assign(r22FD, bit_or(r2224, r22DF), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r230D = less(r22FE, body.constant(int(64)));
                                 ir_if *f230C = new(mem_ctx) ir_if(operand(r230D).val);
                                 exec_list *const f230C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f230C->then_instructions;

                                    body.emit(assign(r22FF, lshift(r22DE, r2302), 0x01));

                                    ir_expression *const r230E = bit_and(r22FE, body.constant(int(31)));
                                    body.emit(assign(r2300, rshift(r22DE, r230E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f230C->else_instructions;

                                    ir_variable *const r230F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2311 = equal(r22FE, body.constant(int(64)));
                                    ir_if *f2310 = new(mem_ctx) ir_if(operand(r2311).val);
                                    exec_list *const f2310_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2310->then_instructions;

                                       body.emit(assign(r230F, r22DE, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2310->else_instructions;

                                       ir_expression *const r2312 = nequal(r22DE, body.constant(0u));
                                       ir_expression *const r2313 = expr(ir_unop_b2i, r2312);
                                       body.emit(assign(r230F, expr(ir_unop_i2u, r2313), 0x01));


                                    body.instructions = f2310_parent_instructions;
                                    body.emit(f2310);

                                    /* END IF */

                                    body.emit(assign(r22FF, r230F, 0x01));

                                    body.emit(assign(r2300, body.constant(0u), 0x01));


                                 body.instructions = f230C_parent_instructions;
                                 body.emit(f230C);

                                 /* END IF */


                              body.instructions = f230A_parent_instructions;
                              body.emit(f230A);

                              /* END IF */

                              body.emit(assign(r2301, body.constant(0u), 0x01));


                           body.instructions = f2306_parent_instructions;
                           body.emit(f2306);

                           /* END IF */

                           ir_expression *const r2314 = nequal(r22FD, body.constant(0u));
                           ir_expression *const r2315 = expr(ir_unop_b2i, r2314);
                           ir_expression *const r2316 = expr(ir_unop_i2u, r2315);
                           body.emit(assign(r22FF, bit_or(r22FF, r2316), 0x01));


                        body.instructions = f2304_parent_instructions;
                        body.emit(f2304);

                        /* END IF */

                        body.emit(assign(r22E7, r2301, 0x01));

                        body.emit(assign(r22E8, r2300, 0x01));

                        body.emit(assign(r22E9, r22FF, 0x01));

                        body.emit(assign(r22E6, body.constant(int(0)), 0x01));

                        body.emit(assign(r22EC, less(r22FF, body.constant(0u)), 0x01));


                     body.instructions = f22FB_parent_instructions;
                     body.emit(f22FB);

                     /* END IF */


                  body.instructions = f22F8_parent_instructions;
                  body.emit(f22F8);

                  /* END IF */


               body.instructions = f22EE_parent_instructions;
               body.emit(f22EE);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2317 = new(mem_ctx) ir_if(operand(r22EA).val);
               exec_list *const f2317_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2317->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2318 = new(mem_ctx) ir_if(operand(r22EC).val);
                  exec_list *const f2318_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2318->then_instructions;

                     ir_variable *const r2319 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2319, add(r22E8, body.constant(1u)), 0x01));

                     ir_expression *const r231A = less(r2319, r22E8);
                     ir_expression *const r231B = expr(ir_unop_b2i, r231A);
                     ir_expression *const r231C = expr(ir_unop_i2u, r231B);
                     body.emit(assign(r22E7, add(r22E7, r231C), 0x01));

                     ir_expression *const r231D = equal(r22E9, body.constant(0u));
                     ir_expression *const r231E = expr(ir_unop_b2i, r231D);
                     ir_expression *const r231F = expr(ir_unop_i2u, r231E);
                     ir_expression *const r2320 = add(r22E9, r231F);
                     ir_expression *const r2321 = bit_and(r2320, body.constant(1u));
                     ir_expression *const r2322 = expr(ir_unop_bit_not, r2321);
                     body.emit(assign(r22E8, bit_and(r2319, r2322), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2318->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2324 = bit_or(r22E7, r22E8);
                     ir_expression *const r2325 = equal(r2324, body.constant(0u));
                     ir_if *f2323 = new(mem_ctx) ir_if(operand(r2325).val);
                     exec_list *const f2323_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2323->then_instructions;

                        body.emit(assign(r22E6, body.constant(int(0)), 0x01));


                     body.instructions = f2323_parent_instructions;
                     body.emit(f2323);

                     /* END IF */


                  body.instructions = f2318_parent_instructions;
                  body.emit(f2318);

                  /* END IF */

                  ir_variable *const r2326 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2326);
                  ir_expression *const r2327 = lshift(r1E5F, body.constant(int(31)));
                  ir_expression *const r2328 = expr(ir_unop_i2u, r22E6);
                  ir_expression *const r2329 = lshift(r2328, body.constant(int(20)));
                  ir_expression *const r232A = add(r2327, r2329);
                  body.emit(assign(r2326, add(r232A, r22E7), 0x02));

                  body.emit(assign(r2326, r22E8, 0x01));

                  body.emit(assign(r22EB, r2326, 0x03));

                  body.emit(assign(r22EA, body.constant(false), 0x01));


               body.instructions = f2317_parent_instructions;
               body.emit(f2317);

               /* END IF */

               body.emit(assign(r221F, r22EB, 0x03));

               body.emit(assign(r221E, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f22E4->else_instructions;

               body.emit(assign(r2223, add(r2223, body.constant(int(1))), 0x01));

               ir_variable *const r232B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r232B);
               ir_variable *const r232C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r232C);
               ir_variable *const r232D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r232D);
               body.emit(assign(r232B, lshift(r22DF, body.constant(int(31))), 0x01));

               ir_expression *const r232E = lshift(r22DE, body.constant(int(31)));
               ir_expression *const r232F = rshift(r22DF, body.constant(int(1)));
               body.emit(assign(r232C, bit_or(r232E, r232F), 0x01));

               body.emit(assign(r232D, rshift(r22DE, body.constant(int(1))), 0x01));

               ir_expression *const r2330 = nequal(r2224, body.constant(0u));
               ir_expression *const r2331 = expr(ir_unop_b2i, r2330);
               ir_expression *const r2332 = expr(ir_unop_i2u, r2331);
               body.emit(assign(r232B, bit_or(r232B, r2332), 0x01));

               body.emit(assign(r2225, r232D, 0x01));

               body.emit(assign(r2224, r232B, 0x01));

               ir_variable *const r2333 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2333, r2223, 0x01));

               ir_variable *const r2334 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2334, r232D, 0x01));

               ir_variable *const r2335 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2335, r232C, 0x01));

               ir_variable *const r2336 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2336, r232B, 0x01));

               ir_variable *const r2337 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2337, body.constant(true), 0x01));

               ir_variable *const r2338 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2339 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2339);
               ir_expression *const r233A = expr(ir_unop_u2i, r232B);
               body.emit(assign(r2339, less(r233A, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r233C = lequal(body.constant(int(2045)), r2223);
               ir_if *f233B = new(mem_ctx) ir_if(operand(r233C).val);
               exec_list *const f233B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f233B->then_instructions;

                  ir_variable *const r233D = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r233F = less(body.constant(int(2045)), r2223);
                  ir_if *f233E = new(mem_ctx) ir_if(operand(r233F).val);
                  exec_list *const f233E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f233E->then_instructions;

                     body.emit(assign(r233D, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f233E->else_instructions;

                     ir_variable *const r2340 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2342 = equal(r2223, body.constant(int(2045)));
                     ir_if *f2341 = new(mem_ctx) ir_if(operand(r2342).val);
                     exec_list *const f2341_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2341->then_instructions;

                        ir_expression *const r2343 = equal(body.constant(2097151u), r232D);
                        ir_expression *const r2344 = equal(body.constant(4294967295u), r232C);
                        body.emit(assign(r2340, logic_and(r2343, r2344), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2341->else_instructions;

                        body.emit(assign(r2340, body.constant(false), 0x01));


                     body.instructions = f2341_parent_instructions;
                     body.emit(f2341);

                     /* END IF */

                     body.emit(assign(r233D, logic_and(r2340, r2339), 0x01));


                  body.instructions = f233E_parent_instructions;
                  body.emit(f233E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2345 = new(mem_ctx) ir_if(operand(r233D).val);
                  exec_list *const f2345_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2345->then_instructions;

                     ir_variable *const r2346 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2346);
                     ir_expression *const r2347 = lshift(r1E5F, body.constant(int(31)));
                     body.emit(assign(r2346, add(r2347, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2346, body.constant(0u), 0x01));

                     body.emit(assign(r2338, r2346, 0x03));

                     body.emit(assign(r2337, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2345->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2349 = less(r2223, body.constant(int(0)));
                     ir_if *f2348 = new(mem_ctx) ir_if(operand(r2349).val);
                     exec_list *const f2348_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2348->then_instructions;

                        ir_variable *const r234A = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r234A, r232B, 0x01));

                        ir_variable *const r234B = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r234B, neg(r2223), 0x01));

                        ir_variable *const r234C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r234C);
                        ir_variable *const r234D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r234D);
                        ir_variable *const r234E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r234E);
                        ir_variable *const r234F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2350 = neg(r234B);
                        body.emit(assign(r234F, bit_and(r2350, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2352 = equal(r234B, body.constant(int(0)));
                        ir_if *f2351 = new(mem_ctx) ir_if(operand(r2352).val);
                        exec_list *const f2351_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2351->then_instructions;

                           body.emit(assign(r234C, r232B, 0x01));

                           body.emit(assign(r234D, r232C, 0x01));

                           body.emit(assign(r234E, r232D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2351->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2354 = less(r234B, body.constant(int(32)));
                           ir_if *f2353 = new(mem_ctx) ir_if(operand(r2354).val);
                           exec_list *const f2353_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2353->then_instructions;

                              body.emit(assign(r234C, lshift(r232C, r234F), 0x01));

                              ir_expression *const r2355 = lshift(r232D, r234F);
                              ir_expression *const r2356 = rshift(r232C, r234B);
                              body.emit(assign(r234D, bit_or(r2355, r2356), 0x01));

                              body.emit(assign(r234E, rshift(r232D, r234B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2353->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2358 = equal(r234B, body.constant(int(32)));
                              ir_if *f2357 = new(mem_ctx) ir_if(operand(r2358).val);
                              exec_list *const f2357_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2357->then_instructions;

                                 body.emit(assign(r234C, r232C, 0x01));

                                 body.emit(assign(r234D, r232D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2357->else_instructions;

                                 body.emit(assign(r234A, bit_or(r232B, r232C), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r235A = less(r234B, body.constant(int(64)));
                                 ir_if *f2359 = new(mem_ctx) ir_if(operand(r235A).val);
                                 exec_list *const f2359_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2359->then_instructions;

                                    body.emit(assign(r234C, lshift(r232D, r234F), 0x01));

                                    ir_expression *const r235B = bit_and(r234B, body.constant(int(31)));
                                    body.emit(assign(r234D, rshift(r232D, r235B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2359->else_instructions;

                                    ir_variable *const r235C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r235E = equal(r234B, body.constant(int(64)));
                                    ir_if *f235D = new(mem_ctx) ir_if(operand(r235E).val);
                                    exec_list *const f235D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f235D->then_instructions;

                                       body.emit(assign(r235C, r232D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f235D->else_instructions;

                                       ir_expression *const r235F = nequal(r232D, body.constant(0u));
                                       ir_expression *const r2360 = expr(ir_unop_b2i, r235F);
                                       body.emit(assign(r235C, expr(ir_unop_i2u, r2360), 0x01));


                                    body.instructions = f235D_parent_instructions;
                                    body.emit(f235D);

                                    /* END IF */

                                    body.emit(assign(r234C, r235C, 0x01));

                                    body.emit(assign(r234D, body.constant(0u), 0x01));


                                 body.instructions = f2359_parent_instructions;
                                 body.emit(f2359);

                                 /* END IF */


                              body.instructions = f2357_parent_instructions;
                              body.emit(f2357);

                              /* END IF */

                              body.emit(assign(r234E, body.constant(0u), 0x01));


                           body.instructions = f2353_parent_instructions;
                           body.emit(f2353);

                           /* END IF */

                           ir_expression *const r2361 = nequal(r234A, body.constant(0u));
                           ir_expression *const r2362 = expr(ir_unop_b2i, r2361);
                           ir_expression *const r2363 = expr(ir_unop_i2u, r2362);
                           body.emit(assign(r234C, bit_or(r234C, r2363), 0x01));


                        body.instructions = f2351_parent_instructions;
                        body.emit(f2351);

                        /* END IF */

                        body.emit(assign(r2334, r234E, 0x01));

                        body.emit(assign(r2335, r234D, 0x01));

                        body.emit(assign(r2336, r234C, 0x01));

                        body.emit(assign(r2333, body.constant(int(0)), 0x01));

                        body.emit(assign(r2339, less(r234C, body.constant(0u)), 0x01));


                     body.instructions = f2348_parent_instructions;
                     body.emit(f2348);

                     /* END IF */


                  body.instructions = f2345_parent_instructions;
                  body.emit(f2345);

                  /* END IF */


               body.instructions = f233B_parent_instructions;
               body.emit(f233B);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2364 = new(mem_ctx) ir_if(operand(r2337).val);
               exec_list *const f2364_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2364->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2365 = new(mem_ctx) ir_if(operand(r2339).val);
                  exec_list *const f2365_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2365->then_instructions;

                     ir_variable *const r2366 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2366, add(r2335, body.constant(1u)), 0x01));

                     ir_expression *const r2367 = less(r2366, r2335);
                     ir_expression *const r2368 = expr(ir_unop_b2i, r2367);
                     ir_expression *const r2369 = expr(ir_unop_i2u, r2368);
                     body.emit(assign(r2334, add(r2334, r2369), 0x01));

                     ir_expression *const r236A = equal(r2336, body.constant(0u));
                     ir_expression *const r236B = expr(ir_unop_b2i, r236A);
                     ir_expression *const r236C = expr(ir_unop_i2u, r236B);
                     ir_expression *const r236D = add(r2336, r236C);
                     ir_expression *const r236E = bit_and(r236D, body.constant(1u));
                     ir_expression *const r236F = expr(ir_unop_bit_not, r236E);
                     body.emit(assign(r2335, bit_and(r2366, r236F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2365->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2371 = bit_or(r2334, r2335);
                     ir_expression *const r2372 = equal(r2371, body.constant(0u));
                     ir_if *f2370 = new(mem_ctx) ir_if(operand(r2372).val);
                     exec_list *const f2370_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2370->then_instructions;

                        body.emit(assign(r2333, body.constant(int(0)), 0x01));


                     body.instructions = f2370_parent_instructions;
                     body.emit(f2370);

                     /* END IF */


                  body.instructions = f2365_parent_instructions;
                  body.emit(f2365);

                  /* END IF */

                  ir_variable *const r2373 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2373);
                  ir_expression *const r2374 = lshift(r1E5F, body.constant(int(31)));
                  ir_expression *const r2375 = expr(ir_unop_i2u, r2333);
                  ir_expression *const r2376 = lshift(r2375, body.constant(int(20)));
                  ir_expression *const r2377 = add(r2374, r2376);
                  body.emit(assign(r2373, add(r2377, r2334), 0x02));

                  body.emit(assign(r2373, r2335, 0x01));

                  body.emit(assign(r2338, r2373, 0x03));

                  body.emit(assign(r2337, body.constant(false), 0x01));


               body.instructions = f2364_parent_instructions;
               body.emit(f2364);

               /* END IF */

               body.emit(assign(r221F, r2338, 0x03));

               body.emit(assign(r221E, body.constant(false), 0x01));


            body.instructions = f22E4_parent_instructions;
            body.emit(f22E4);

            /* END IF */


         body.instructions = f22DD_parent_instructions;
         body.emit(f22DD);

         /* END IF */

         body.emit(assign(r1E5E, r221F, 0x03));


      body.instructions = f1E60_parent_instructions;
      body.emit(f1E60);

      /* END IF */

      body.emit(assign(r1E5C, r1E5E, 0x03));


   body.instructions = f1E5D_parent_instructions;
   body.emit(f1E5D);

   /* END IF */

   body.emit(ret(r1E5C));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fceil64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r2378 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r2378);
   ir_variable *const r2379 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r237A = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r237B = rshift(swizzle_y(r2378), body.constant(int(20)));
   ir_expression *const r237C = bit_and(r237B, body.constant(2047u));
   ir_expression *const r237D = expr(ir_unop_u2i, r237C);
   body.emit(assign(r237A, add(r237D, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r237F = less(r237A, body.constant(int(0)));
   ir_if *f237E = new(mem_ctx) ir_if(operand(r237F).val);
   exec_list *const f237E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f237E->then_instructions;

      body.emit(assign(r2379, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f237E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r2381 = greater(r237A, body.constant(int(52)));
      ir_if *f2380 = new(mem_ctx) ir_if(operand(r2381).val);
      exec_list *const f2380_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2380->then_instructions;

         body.emit(assign(r2379, r2378, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2380->else_instructions;

         ir_variable *const r2382 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r2382);
         ir_variable *const r2383 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2383, sub(body.constant(int(52)), r237A), 0x01));

         ir_variable *const r2384 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r2386 = gequal(r2383, body.constant(int(32)));
         ir_if *f2385 = new(mem_ctx) ir_if(operand(r2386).val);
         exec_list *const f2385_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2385->then_instructions;

            body.emit(assign(r2384, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2385->else_instructions;

            body.emit(assign(r2384, lshift(body.constant(4294967295u), r2383), 0x01));


         body.instructions = f2385_parent_instructions;
         body.emit(f2385);

         /* END IF */

         ir_variable *const r2387 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r2389 = less(r2383, body.constant(int(33)));
         ir_if *f2388 = new(mem_ctx) ir_if(operand(r2389).val);
         exec_list *const f2388_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2388->then_instructions;

            body.emit(assign(r2387, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2388->else_instructions;

            ir_expression *const r238A = add(r2383, body.constant(int(-32)));
            body.emit(assign(r2387, lshift(body.constant(4294967295u), r238A), 0x01));


         body.instructions = f2388_parent_instructions;
         body.emit(f2388);

         /* END IF */

         body.emit(assign(r2382, bit_and(r2384, swizzle_x(r2378)), 0x01));

         body.emit(assign(r2382, bit_and(r2387, swizzle_y(r2378)), 0x02));

         body.emit(assign(r2379, r2382, 0x03));


      body.instructions = f2380_parent_instructions;
      body.emit(f2380);

      /* END IF */


   body.instructions = f237E_parent_instructions;
   body.emit(f237E);

   /* END IF */

   ir_variable *const r238B = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r238B, rshift(swizzle_y(r2378), body.constant(int(31))), 0x01));

   ir_variable *const r238C = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r238E = expr(ir_unop_u2i, r238B);
   ir_expression *const r238F = expr(ir_unop_i2b, r238E);
   ir_if *f238D = new(mem_ctx) ir_if(operand(r238F).val);
   exec_list *const f238D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f238D->then_instructions;

      body.emit(assign(r238C, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f238D->else_instructions;

      ir_variable *const r2390 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r2391 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r2391);
      ir_variable *const r2392 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r2392);
      ir_variable *const r2393 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r2393);
      body.emit(assign(r2393, bit_and(swizzle_y(r2378), body.constant(1048575u)), 0x02));

      body.emit(assign(r2393, swizzle_x(r2378), 0x01));

      ir_variable *const r2394 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r2394);
      body.emit(assign(r2394, bit_and(swizzle_y(r2379), body.constant(1048575u)), 0x02));

      body.emit(assign(r2394, swizzle_x(r2379), 0x01));

      ir_expression *const r2395 = rshift(swizzle_y(r2378), body.constant(int(20)));
      ir_expression *const r2396 = bit_and(r2395, body.constant(2047u));
      ir_expression *const r2397 = expr(ir_unop_u2i, r2396);
      ir_expression *const r2398 = equal(r2397, body.constant(int(2047)));
      ir_expression *const r2399 = bit_or(swizzle_y(r2393), swizzle_x(r2378));
      ir_expression *const r239A = nequal(r2399, body.constant(0u));
      body.emit(assign(r2392, logic_and(r2398, r239A), 0x01));

      ir_expression *const r239B = rshift(swizzle_y(r2379), body.constant(int(20)));
      ir_expression *const r239C = bit_and(r239B, body.constant(2047u));
      ir_expression *const r239D = expr(ir_unop_u2i, r239C);
      ir_expression *const r239E = equal(r239D, body.constant(int(2047)));
      ir_expression *const r239F = bit_or(swizzle_y(r2394), swizzle_x(r2379));
      ir_expression *const r23A0 = nequal(r239F, body.constant(0u));
      body.emit(assign(r2391, logic_and(r239E, r23A0), 0x01));

      /* IF CONDITION */
      ir_expression *const r23A2 = logic_or(r2392, r2391);
      ir_if *f23A1 = new(mem_ctx) ir_if(operand(r23A2).val);
      exec_list *const f23A1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f23A1->then_instructions;

         body.emit(assign(r2390, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f23A1->else_instructions;

         ir_expression *const r23A3 = equal(swizzle_x(r2378), swizzle_x(r2379));
         ir_expression *const r23A4 = equal(swizzle_y(r2378), swizzle_y(r2379));
         ir_expression *const r23A5 = equal(swizzle_x(r2378), body.constant(0u));
         ir_expression *const r23A6 = bit_or(swizzle_y(r2378), swizzle_y(r2379));
         ir_expression *const r23A7 = lshift(r23A6, body.constant(int(1)));
         ir_expression *const r23A8 = equal(r23A7, body.constant(0u));
         ir_expression *const r23A9 = logic_and(r23A5, r23A8);
         ir_expression *const r23AA = logic_or(r23A4, r23A9);
         body.emit(assign(r2390, logic_and(r23A3, r23AA), 0x01));


      body.instructions = f23A1_parent_instructions;
      body.emit(f23A1);

      /* END IF */

      body.emit(assign(r238C, r2390, 0x01));


   body.instructions = f238D_parent_instructions;
   body.emit(f238D);

   /* END IF */

   ir_variable *const r23AB = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f23AC = new(mem_ctx) ir_if(operand(r238C).val);
   exec_list *const f23AC_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f23AC->then_instructions;

      body.emit(assign(r23AB, r2379, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f23AC->else_instructions;

      ir_variable *const r23AD = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r23AE = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r23AE, rshift(swizzle_y(r2379), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r23B0 = equal(r23AE, body.constant(0u));
      ir_if *f23AF = new(mem_ctx) ir_if(operand(r23B0).val);
      exec_list *const f23AF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f23AF->then_instructions;

         ir_variable *const r23B1 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r23B1, body.constant(true), 0x01));

         ir_variable *const r23B2 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r23B3 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r23B3);
         ir_variable *const r23B4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r23B4);
         ir_variable *const r23B5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r23B5);
         ir_variable *const r23B6 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r23B6);
         ir_variable *const r23B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r23B7);
         ir_variable *const r23B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r23B8);
         body.emit(assign(r23B8, body.constant(0u), 0x01));

         body.emit(assign(r23B7, body.constant(0u), 0x01));

         ir_variable *const r23B9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r23B9);
         body.emit(assign(r23B9, bit_and(swizzle_y(r2379), body.constant(1048575u)), 0x02));

         body.emit(assign(r23B9, swizzle_x(r2379), 0x01));

         body.emit(assign(r23B5, r23B9, 0x03));

         ir_variable *const r23BA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r23BB = rshift(swizzle_y(r2379), body.constant(int(20)));
         ir_expression *const r23BC = bit_and(r23BB, body.constant(2047u));
         body.emit(assign(r23BA, expr(ir_unop_u2i, r23BC), 0x01));

         ir_variable *const r23BD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r23BD);
         body.emit(assign(r23BD, body.constant(0u), 0x02));

         body.emit(assign(r23BD, body.constant(0u), 0x01));

         body.emit(assign(r23B4, r23BD, 0x03));

         ir_variable *const r23BE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r23BE, body.constant(int(1023)), 0x01));

         ir_variable *const r23BF = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r23BF, add(r23BA, body.constant(int(-1023))), 0x01));

         body.emit(assign(r23B3, r23BF, 0x01));

         /* IF CONDITION */
         ir_expression *const r23C1 = less(body.constant(int(0)), r23BF);
         ir_if *f23C0 = new(mem_ctx) ir_if(operand(r23C1).val);
         exec_list *const f23C0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f23C0->then_instructions;

            /* IF CONDITION */
            ir_expression *const r23C3 = equal(r23BA, body.constant(int(2047)));
            ir_if *f23C2 = new(mem_ctx) ir_if(operand(r23C3).val);
            exec_list *const f23C2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f23C2->then_instructions;

               /* IF CONDITION */
               ir_expression *const r23C5 = bit_or(swizzle_y(r23B9), swizzle_x(r2379));
               ir_expression *const r23C6 = nequal(r23C5, body.constant(0u));
               ir_if *f23C4 = new(mem_ctx) ir_if(operand(r23C6).val);
               exec_list *const f23C4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23C4->then_instructions;

                  ir_variable *const r23C7 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r23C7, swizzle_x(r2379), 0x01));

                  ir_variable *const r23C8 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r23C8, body.constant(0u), 0x01));

                  ir_variable *const r23C9 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r23C7, bit_or(swizzle_y(r2379), body.constant(524288u)), 0x02));

                  body.emit(assign(r23C8, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r23CB = lshift(swizzle_y(r2379), body.constant(int(1)));
                  ir_expression *const r23CC = lequal(body.constant(4292870144u), r23CB);
                  ir_expression *const r23CD = nequal(swizzle_x(r2379), body.constant(0u));
                  ir_expression *const r23CE = bit_and(swizzle_y(r2379), body.constant(1048575u));
                  ir_expression *const r23CF = nequal(r23CE, body.constant(0u));
                  ir_expression *const r23D0 = logic_or(r23CD, r23CF);
                  ir_expression *const r23D1 = logic_and(r23CC, r23D0);
                  ir_if *f23CA = new(mem_ctx) ir_if(operand(r23D1).val);
                  exec_list *const f23CA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23CA->then_instructions;

                     body.emit(assign(r23C9, r23C7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23CA->else_instructions;

                     body.emit(assign(r23C9, r23C8, 0x03));


                  body.instructions = f23CA_parent_instructions;
                  body.emit(f23CA);

                  /* END IF */

                  body.emit(assign(r23B2, r23C9, 0x03));

                  body.emit(assign(r23B1, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23C4->else_instructions;

                  body.emit(assign(r23B2, r2379, 0x03));

                  body.emit(assign(r23B1, body.constant(false), 0x01));


               body.instructions = f23C4_parent_instructions;
               body.emit(f23C4);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f23C2->else_instructions;

               body.emit(assign(r23B4, body.constant(1048576u), 0x02));

               ir_variable *const r23D2 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r23D2, swizzle_y(r23B4), 0x01));

               ir_variable *const r23D3 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r23D3, swizzle_x(r23B4), 0x01));

               ir_variable *const r23D4 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r23D4, body.constant(0u), 0x01));

               ir_variable *const r23D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r23D5);
               ir_variable *const r23D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r23D6);
               ir_variable *const r23D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r23D7);
               ir_variable *const r23D8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r23D9 = neg(r23BF);
               body.emit(assign(r23D8, bit_and(r23D9, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r23DB = equal(r23BF, body.constant(int(0)));
               ir_if *f23DA = new(mem_ctx) ir_if(operand(r23DB).val);
               exec_list *const f23DA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23DA->then_instructions;

                  body.emit(assign(r23D5, r23D4, 0x01));

                  body.emit(assign(r23D6, r23D3, 0x01));

                  body.emit(assign(r23D7, r23D2, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23DA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r23DD = less(r23BF, body.constant(int(32)));
                  ir_if *f23DC = new(mem_ctx) ir_if(operand(r23DD).val);
                  exec_list *const f23DC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23DC->then_instructions;

                     body.emit(assign(r23D5, body.constant(0u), 0x01));

                     ir_expression *const r23DE = lshift(body.constant(1048576u), r23D8);
                     body.emit(assign(r23D6, bit_or(r23DE, body.constant(0u)), 0x01));

                     body.emit(assign(r23D7, rshift(body.constant(1048576u), r23BF), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23DC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r23E0 = equal(r23BF, body.constant(int(32)));
                     ir_if *f23DF = new(mem_ctx) ir_if(operand(r23E0).val);
                     exec_list *const f23DF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f23DF->then_instructions;

                        body.emit(assign(r23D5, r23D3, 0x01));

                        body.emit(assign(r23D6, r23D2, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f23DF->else_instructions;

                        body.emit(assign(r23D4, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r23E2 = less(r23BF, body.constant(int(64)));
                        ir_if *f23E1 = new(mem_ctx) ir_if(operand(r23E2).val);
                        exec_list *const f23E1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f23E1->then_instructions;

                           body.emit(assign(r23D5, lshift(body.constant(1048576u), r23D8), 0x01));

                           ir_expression *const r23E3 = bit_and(r23BF, body.constant(int(31)));
                           body.emit(assign(r23D6, rshift(body.constant(1048576u), r23E3), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f23E1->else_instructions;

                           ir_variable *const r23E4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r23E6 = equal(r23BF, body.constant(int(64)));
                           ir_if *f23E5 = new(mem_ctx) ir_if(operand(r23E6).val);
                           exec_list *const f23E5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f23E5->then_instructions;

                              body.emit(assign(r23E4, r23D2, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f23E5->else_instructions;

                              body.emit(assign(r23E4, body.constant(1u), 0x01));


                           body.instructions = f23E5_parent_instructions;
                           body.emit(f23E5);

                           /* END IF */

                           body.emit(assign(r23D5, r23E4, 0x01));

                           body.emit(assign(r23D6, body.constant(0u), 0x01));


                        body.instructions = f23E1_parent_instructions;
                        body.emit(f23E1);

                        /* END IF */


                     body.instructions = f23DF_parent_instructions;
                     body.emit(f23DF);

                     /* END IF */

                     body.emit(assign(r23D7, body.constant(0u), 0x01));


                  body.instructions = f23DC_parent_instructions;
                  body.emit(f23DC);

                  /* END IF */

                  ir_expression *const r23E7 = nequal(r23D4, body.constant(0u));
                  ir_expression *const r23E8 = expr(ir_unop_b2i, r23E7);
                  ir_expression *const r23E9 = expr(ir_unop_i2u, r23E8);
                  body.emit(assign(r23D5, bit_or(r23D5, r23E9), 0x01));


               body.instructions = f23DA_parent_instructions;
               body.emit(f23DA);

               /* END IF */

               body.emit(assign(r23B4, r23D7, 0x02));

               body.emit(assign(r23B4, r23D6, 0x01));

               body.emit(assign(r23B7, r23D5, 0x01));

               body.emit(assign(r23B6, r23BA, 0x01));


            body.instructions = f23C2_parent_instructions;
            body.emit(f23C2);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f23C0->else_instructions;

            /* IF CONDITION */
            ir_expression *const r23EB = less(r23BF, body.constant(int(0)));
            ir_if *f23EA = new(mem_ctx) ir_if(operand(r23EB).val);
            exec_list *const f23EA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f23EA->then_instructions;

               /* IF CONDITION */
               ir_expression *const r23ED = equal(r23BA, body.constant(int(0)));
               ir_if *f23EC = new(mem_ctx) ir_if(operand(r23ED).val);
               exec_list *const f23EC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23EC->then_instructions;

                  body.emit(assign(r23B3, add(r23BF, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23EC->else_instructions;

                  body.emit(assign(r23B5, bit_or(swizzle_y(r23B9), body.constant(1048576u)), 0x02));


               body.instructions = f23EC_parent_instructions;
               body.emit(f23EC);

               /* END IF */

               ir_variable *const r23EE = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r23EE, swizzle_y(r23B5), 0x01));

               ir_variable *const r23EF = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r23EF, swizzle_x(r23B5), 0x01));

               ir_variable *const r23F0 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r23F0, body.constant(0u), 0x01));

               ir_variable *const r23F1 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r23F1, neg(r23B3), 0x01));

               ir_variable *const r23F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r23F2);
               ir_variable *const r23F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r23F3);
               ir_variable *const r23F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r23F4);
               ir_variable *const r23F5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r23F6 = neg(r23F1);
               body.emit(assign(r23F5, bit_and(r23F6, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r23F8 = equal(r23F1, body.constant(int(0)));
               ir_if *f23F7 = new(mem_ctx) ir_if(operand(r23F8).val);
               exec_list *const f23F7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23F7->then_instructions;

                  body.emit(assign(r23F2, r23F0, 0x01));

                  body.emit(assign(r23F3, r23EF, 0x01));

                  body.emit(assign(r23F4, r23EE, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23F7->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r23FA = less(r23F1, body.constant(int(32)));
                  ir_if *f23F9 = new(mem_ctx) ir_if(operand(r23FA).val);
                  exec_list *const f23F9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23F9->then_instructions;

                     body.emit(assign(r23F2, lshift(swizzle_x(r23B9), r23F5), 0x01));

                     ir_expression *const r23FB = lshift(swizzle_y(r23B5), r23F5);
                     ir_expression *const r23FC = rshift(swizzle_x(r23B9), r23F1);
                     body.emit(assign(r23F3, bit_or(r23FB, r23FC), 0x01));

                     body.emit(assign(r23F4, rshift(swizzle_y(r23B5), r23F1), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23F9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r23FE = equal(r23F1, body.constant(int(32)));
                     ir_if *f23FD = new(mem_ctx) ir_if(operand(r23FE).val);
                     exec_list *const f23FD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f23FD->then_instructions;

                        body.emit(assign(r23F2, r23EF, 0x01));

                        body.emit(assign(r23F3, r23EE, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f23FD->else_instructions;

                        body.emit(assign(r23F0, bit_or(body.constant(0u), swizzle_x(r23B9)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2400 = less(r23F1, body.constant(int(64)));
                        ir_if *f23FF = new(mem_ctx) ir_if(operand(r2400).val);
                        exec_list *const f23FF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f23FF->then_instructions;

                           body.emit(assign(r23F2, lshift(swizzle_y(r23B5), r23F5), 0x01));

                           ir_expression *const r2401 = bit_and(r23F1, body.constant(int(31)));
                           body.emit(assign(r23F3, rshift(swizzle_y(r23B5), r2401), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f23FF->else_instructions;

                           ir_variable *const r2402 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2404 = equal(r23F1, body.constant(int(64)));
                           ir_if *f2403 = new(mem_ctx) ir_if(operand(r2404).val);
                           exec_list *const f2403_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2403->then_instructions;

                              body.emit(assign(r2402, r23EE, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2403->else_instructions;

                              ir_expression *const r2405 = nequal(swizzle_y(r23B5), body.constant(0u));
                              ir_expression *const r2406 = expr(ir_unop_b2i, r2405);
                              body.emit(assign(r2402, expr(ir_unop_i2u, r2406), 0x01));


                           body.instructions = f2403_parent_instructions;
                           body.emit(f2403);

                           /* END IF */

                           body.emit(assign(r23F2, r2402, 0x01));

                           body.emit(assign(r23F3, body.constant(0u), 0x01));


                        body.instructions = f23FF_parent_instructions;
                        body.emit(f23FF);

                        /* END IF */


                     body.instructions = f23FD_parent_instructions;
                     body.emit(f23FD);

                     /* END IF */

                     body.emit(assign(r23F4, body.constant(0u), 0x01));


                  body.instructions = f23F9_parent_instructions;
                  body.emit(f23F9);

                  /* END IF */

                  ir_expression *const r2407 = nequal(r23F0, body.constant(0u));
                  ir_expression *const r2408 = expr(ir_unop_b2i, r2407);
                  ir_expression *const r2409 = expr(ir_unop_i2u, r2408);
                  body.emit(assign(r23F2, bit_or(r23F2, r2409), 0x01));


               body.instructions = f23F7_parent_instructions;
               body.emit(f23F7);

               /* END IF */

               body.emit(assign(r23B5, r23F4, 0x02));

               body.emit(assign(r23B5, r23F3, 0x01));

               body.emit(assign(r23B7, r23F2, 0x01));

               body.emit(assign(r23B6, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f23EA->else_instructions;

               /* IF CONDITION */
               ir_expression *const r240B = equal(r23BA, body.constant(int(2047)));
               ir_if *f240A = new(mem_ctx) ir_if(operand(r240B).val);
               exec_list *const f240A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f240A->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r240D = bit_or(swizzle_y(r23B5), swizzle_x(r23B5));
                  ir_expression *const r240E = bit_or(swizzle_y(r23B4), swizzle_x(r23B4));
                  ir_expression *const r240F = bit_or(r240D, r240E);
                  ir_expression *const r2410 = nequal(r240F, body.constant(0u));
                  ir_if *f240C = new(mem_ctx) ir_if(operand(r2410).val);
                  exec_list *const f240C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f240C->then_instructions;

                     ir_variable *const r2411 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2411, swizzle_x(r2379), 0x01));

                     ir_variable *const r2412 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2412, body.constant(0u), 0x01));

                     ir_variable *const r2413 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2411, bit_or(swizzle_y(r2379), body.constant(524288u)), 0x02));

                     body.emit(assign(r2412, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2415 = lshift(swizzle_y(r2379), body.constant(int(1)));
                     ir_expression *const r2416 = lequal(body.constant(4292870144u), r2415);
                     ir_expression *const r2417 = nequal(swizzle_x(r2379), body.constant(0u));
                     ir_expression *const r2418 = bit_and(swizzle_y(r2379), body.constant(1048575u));
                     ir_expression *const r2419 = nequal(r2418, body.constant(0u));
                     ir_expression *const r241A = logic_or(r2417, r2419);
                     ir_expression *const r241B = logic_and(r2416, r241A);
                     ir_if *f2414 = new(mem_ctx) ir_if(operand(r241B).val);
                     exec_list *const f2414_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2414->then_instructions;

                        body.emit(assign(r2413, r2411, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2414->else_instructions;

                        body.emit(assign(r2413, r2412, 0x03));


                     body.instructions = f2414_parent_instructions;
                     body.emit(f2414);

                     /* END IF */

                     body.emit(assign(r23B2, r2413, 0x03));

                     body.emit(assign(r23B1, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f240C->else_instructions;

                     body.emit(assign(r23B2, r2379, 0x03));

                     body.emit(assign(r23B1, body.constant(false), 0x01));


                  body.instructions = f240C_parent_instructions;
                  body.emit(f240C);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f240A->else_instructions;

                  ir_variable *const r241C = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r241D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r241D, add(swizzle_x(r23B5), swizzle_x(r23B4)), 0x01));

                  ir_expression *const r241E = add(swizzle_y(r23B5), swizzle_y(r23B4));
                  ir_expression *const r241F = less(r241D, swizzle_x(r23B5));
                  ir_expression *const r2420 = expr(ir_unop_b2i, r241F);
                  ir_expression *const r2421 = expr(ir_unop_i2u, r2420);
                  body.emit(assign(r241C, add(r241E, r2421), 0x01));

                  body.emit(assign(r23B8, r241C, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2423 = equal(r23BA, body.constant(int(0)));
                  ir_if *f2422 = new(mem_ctx) ir_if(operand(r2423).val);
                  exec_list *const f2422_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2422->then_instructions;

                     ir_variable *const r2424 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2424);
                     ir_expression *const r2425 = lshift(r23AE, body.constant(int(31)));
                     body.emit(assign(r2424, add(r2425, r241C), 0x02));

                     body.emit(assign(r2424, r241D, 0x01));

                     body.emit(assign(r23B2, r2424, 0x03));

                     body.emit(assign(r23B1, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2422->else_instructions;

                     body.emit(assign(r23B8, bit_or(r241C, body.constant(2097152u)), 0x01));

                     body.emit(assign(r23B6, r23BA, 0x01));

                     ir_variable *const r2426 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2426);
                     ir_variable *const r2427 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2427);
                     ir_variable *const r2428 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2428);
                     body.emit(assign(r2426, lshift(r241D, body.constant(int(31))), 0x01));

                     ir_expression *const r2429 = lshift(r23B8, body.constant(int(31)));
                     ir_expression *const r242A = rshift(r241D, body.constant(int(1)));
                     body.emit(assign(r2427, bit_or(r2429, r242A), 0x01));

                     body.emit(assign(r2428, rshift(r23B8, body.constant(int(1))), 0x01));

                     body.emit(assign(r2426, bit_or(r2426, body.constant(0u)), 0x01));

                     body.emit(assign(r23B8, r2428, 0x01));

                     body.emit(assign(r23B7, r2426, 0x01));

                     ir_variable *const r242B = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r242B, r23BA, 0x01));

                     ir_variable *const r242C = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r242C, r2428, 0x01));

                     ir_variable *const r242D = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r242D, r2427, 0x01));

                     ir_variable *const r242E = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r242E, r2426, 0x01));

                     ir_variable *const r242F = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r242F, body.constant(true), 0x01));

                     ir_variable *const r2430 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2431 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2431);
                     ir_expression *const r2432 = expr(ir_unop_u2i, r2426);
                     body.emit(assign(r2431, less(r2432, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2434 = lequal(body.constant(int(2045)), r23BA);
                     ir_if *f2433 = new(mem_ctx) ir_if(operand(r2434).val);
                     exec_list *const f2433_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2433->then_instructions;

                        ir_variable *const r2435 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2437 = less(body.constant(int(2045)), r23BA);
                        ir_if *f2436 = new(mem_ctx) ir_if(operand(r2437).val);
                        exec_list *const f2436_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2436->then_instructions;

                           body.emit(assign(r2435, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2436->else_instructions;

                           ir_variable *const r2438 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r243A = equal(r23BA, body.constant(int(2045)));
                           ir_if *f2439 = new(mem_ctx) ir_if(operand(r243A).val);
                           exec_list *const f2439_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2439->then_instructions;

                              ir_expression *const r243B = equal(body.constant(2097151u), r2428);
                              ir_expression *const r243C = equal(body.constant(4294967295u), r2427);
                              body.emit(assign(r2438, logic_and(r243B, r243C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2439->else_instructions;

                              body.emit(assign(r2438, body.constant(false), 0x01));


                           body.instructions = f2439_parent_instructions;
                           body.emit(f2439);

                           /* END IF */

                           body.emit(assign(r2435, logic_and(r2438, r2431), 0x01));


                        body.instructions = f2436_parent_instructions;
                        body.emit(f2436);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f243D = new(mem_ctx) ir_if(operand(r2435).val);
                        exec_list *const f243D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f243D->then_instructions;

                           ir_variable *const r243E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r243E);
                           ir_expression *const r243F = lshift(r23AE, body.constant(int(31)));
                           body.emit(assign(r243E, add(r243F, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r243E, body.constant(0u), 0x01));

                           body.emit(assign(r2430, r243E, 0x03));

                           body.emit(assign(r242F, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f243D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2441 = less(r23BA, body.constant(int(0)));
                           ir_if *f2440 = new(mem_ctx) ir_if(operand(r2441).val);
                           exec_list *const f2440_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2440->then_instructions;

                              ir_variable *const r2442 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2442, r2426, 0x01));

                              ir_variable *const r2443 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2443, neg(r23BA), 0x01));

                              ir_variable *const r2444 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2444);
                              ir_variable *const r2445 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2445);
                              ir_variable *const r2446 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2446);
                              ir_variable *const r2447 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2448 = neg(r2443);
                              body.emit(assign(r2447, bit_and(r2448, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r244A = equal(r2443, body.constant(int(0)));
                              ir_if *f2449 = new(mem_ctx) ir_if(operand(r244A).val);
                              exec_list *const f2449_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2449->then_instructions;

                                 body.emit(assign(r2444, r2426, 0x01));

                                 body.emit(assign(r2445, r2427, 0x01));

                                 body.emit(assign(r2446, r2428, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2449->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r244C = less(r2443, body.constant(int(32)));
                                 ir_if *f244B = new(mem_ctx) ir_if(operand(r244C).val);
                                 exec_list *const f244B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f244B->then_instructions;

                                    body.emit(assign(r2444, lshift(r2427, r2447), 0x01));

                                    ir_expression *const r244D = lshift(r2428, r2447);
                                    ir_expression *const r244E = rshift(r2427, r2443);
                                    body.emit(assign(r2445, bit_or(r244D, r244E), 0x01));

                                    body.emit(assign(r2446, rshift(r2428, r2443), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f244B->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2450 = equal(r2443, body.constant(int(32)));
                                    ir_if *f244F = new(mem_ctx) ir_if(operand(r2450).val);
                                    exec_list *const f244F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f244F->then_instructions;

                                       body.emit(assign(r2444, r2427, 0x01));

                                       body.emit(assign(r2445, r2428, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f244F->else_instructions;

                                       body.emit(assign(r2442, bit_or(r2426, r2427), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2452 = less(r2443, body.constant(int(64)));
                                       ir_if *f2451 = new(mem_ctx) ir_if(operand(r2452).val);
                                       exec_list *const f2451_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2451->then_instructions;

                                          body.emit(assign(r2444, lshift(r2428, r2447), 0x01));

                                          ir_expression *const r2453 = bit_and(r2443, body.constant(int(31)));
                                          body.emit(assign(r2445, rshift(r2428, r2453), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2451->else_instructions;

                                          ir_variable *const r2454 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2456 = equal(r2443, body.constant(int(64)));
                                          ir_if *f2455 = new(mem_ctx) ir_if(operand(r2456).val);
                                          exec_list *const f2455_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2455->then_instructions;

                                             body.emit(assign(r2454, r2428, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2455->else_instructions;

                                             ir_expression *const r2457 = nequal(r2428, body.constant(0u));
                                             ir_expression *const r2458 = expr(ir_unop_b2i, r2457);
                                             body.emit(assign(r2454, expr(ir_unop_i2u, r2458), 0x01));


                                          body.instructions = f2455_parent_instructions;
                                          body.emit(f2455);

                                          /* END IF */

                                          body.emit(assign(r2444, r2454, 0x01));

                                          body.emit(assign(r2445, body.constant(0u), 0x01));


                                       body.instructions = f2451_parent_instructions;
                                       body.emit(f2451);

                                       /* END IF */


                                    body.instructions = f244F_parent_instructions;
                                    body.emit(f244F);

                                    /* END IF */

                                    body.emit(assign(r2446, body.constant(0u), 0x01));


                                 body.instructions = f244B_parent_instructions;
                                 body.emit(f244B);

                                 /* END IF */

                                 ir_expression *const r2459 = nequal(r2442, body.constant(0u));
                                 ir_expression *const r245A = expr(ir_unop_b2i, r2459);
                                 ir_expression *const r245B = expr(ir_unop_i2u, r245A);
                                 body.emit(assign(r2444, bit_or(r2444, r245B), 0x01));


                              body.instructions = f2449_parent_instructions;
                              body.emit(f2449);

                              /* END IF */

                              body.emit(assign(r242C, r2446, 0x01));

                              body.emit(assign(r242D, r2445, 0x01));

                              body.emit(assign(r242E, r2444, 0x01));

                              body.emit(assign(r242B, body.constant(int(0)), 0x01));

                              body.emit(assign(r2431, less(r2444, body.constant(0u)), 0x01));


                           body.instructions = f2440_parent_instructions;
                           body.emit(f2440);

                           /* END IF */


                        body.instructions = f243D_parent_instructions;
                        body.emit(f243D);

                        /* END IF */


                     body.instructions = f2433_parent_instructions;
                     body.emit(f2433);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f245C = new(mem_ctx) ir_if(operand(r242F).val);
                     exec_list *const f245C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f245C->then_instructions;

                        /* IF CONDITION */
                        ir_if *f245D = new(mem_ctx) ir_if(operand(r2431).val);
                        exec_list *const f245D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f245D->then_instructions;

                           ir_variable *const r245E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r245E, add(r242D, body.constant(1u)), 0x01));

                           ir_expression *const r245F = less(r245E, r242D);
                           ir_expression *const r2460 = expr(ir_unop_b2i, r245F);
                           ir_expression *const r2461 = expr(ir_unop_i2u, r2460);
                           body.emit(assign(r242C, add(r242C, r2461), 0x01));

                           ir_expression *const r2462 = equal(r242E, body.constant(0u));
                           ir_expression *const r2463 = expr(ir_unop_b2i, r2462);
                           ir_expression *const r2464 = expr(ir_unop_i2u, r2463);
                           ir_expression *const r2465 = add(r242E, r2464);
                           ir_expression *const r2466 = bit_and(r2465, body.constant(1u));
                           ir_expression *const r2467 = expr(ir_unop_bit_not, r2466);
                           body.emit(assign(r242D, bit_and(r245E, r2467), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f245D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2469 = bit_or(r242C, r242D);
                           ir_expression *const r246A = equal(r2469, body.constant(0u));
                           ir_if *f2468 = new(mem_ctx) ir_if(operand(r246A).val);
                           exec_list *const f2468_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2468->then_instructions;

                              body.emit(assign(r242B, body.constant(int(0)), 0x01));


                           body.instructions = f2468_parent_instructions;
                           body.emit(f2468);

                           /* END IF */


                        body.instructions = f245D_parent_instructions;
                        body.emit(f245D);

                        /* END IF */

                        ir_variable *const r246B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r246B);
                        ir_expression *const r246C = lshift(r23AE, body.constant(int(31)));
                        ir_expression *const r246D = expr(ir_unop_i2u, r242B);
                        ir_expression *const r246E = lshift(r246D, body.constant(int(20)));
                        ir_expression *const r246F = add(r246C, r246E);
                        body.emit(assign(r246B, add(r246F, r242C), 0x02));

                        body.emit(assign(r246B, r242D, 0x01));

                        body.emit(assign(r2430, r246B, 0x03));

                        body.emit(assign(r242F, body.constant(false), 0x01));


                     body.instructions = f245C_parent_instructions;
                     body.emit(f245C);

                     /* END IF */

                     body.emit(assign(r23B2, r2430, 0x03));

                     body.emit(assign(r23B1, body.constant(false), 0x01));


                  body.instructions = f2422_parent_instructions;
                  body.emit(f2422);

                  /* END IF */


               body.instructions = f240A_parent_instructions;
               body.emit(f240A);

               /* END IF */


            body.instructions = f23EA_parent_instructions;
            body.emit(f23EA);

            /* END IF */


         body.instructions = f23C0_parent_instructions;
         body.emit(f23C0);

         /* END IF */

         /* IF CONDITION */
         ir_if *f2470 = new(mem_ctx) ir_if(operand(r23B1).val);
         exec_list *const f2470_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2470->then_instructions;

            body.emit(assign(r23B5, bit_or(swizzle_y(r23B5), body.constant(1048576u)), 0x02));

            ir_variable *const r2471 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2472 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r2472, add(swizzle_x(r23B5), swizzle_x(r23B4)), 0x01));

            ir_expression *const r2473 = add(swizzle_y(r23B5), swizzle_y(r23B4));
            ir_expression *const r2474 = less(r2472, swizzle_x(r23B5));
            ir_expression *const r2475 = expr(ir_unop_b2i, r2474);
            ir_expression *const r2476 = expr(ir_unop_i2u, r2475);
            body.emit(assign(r2471, add(r2473, r2476), 0x01));

            body.emit(assign(r23B8, r2471, 0x01));

            body.emit(assign(r23B6, add(r23B6, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2478 = less(r2471, body.constant(2097152u));
            ir_if *f2477 = new(mem_ctx) ir_if(operand(r2478).val);
            exec_list *const f2477_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2477->then_instructions;

               ir_variable *const r2479 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2479, r23B6, 0x01));

               ir_variable *const r247A = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r247A, r2471, 0x01));

               ir_variable *const r247B = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r247B, r2472, 0x01));

               ir_variable *const r247C = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r247C, r23B7, 0x01));

               ir_variable *const r247D = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r247D, body.constant(true), 0x01));

               ir_variable *const r247E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r247F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r247F);
               ir_expression *const r2480 = expr(ir_unop_u2i, r23B7);
               body.emit(assign(r247F, less(r2480, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2482 = lequal(body.constant(int(2045)), r23B6);
               ir_if *f2481 = new(mem_ctx) ir_if(operand(r2482).val);
               exec_list *const f2481_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2481->then_instructions;

                  ir_variable *const r2483 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2485 = less(body.constant(int(2045)), r23B6);
                  ir_if *f2484 = new(mem_ctx) ir_if(operand(r2485).val);
                  exec_list *const f2484_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2484->then_instructions;

                     body.emit(assign(r2483, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2484->else_instructions;

                     ir_variable *const r2486 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2488 = equal(r23B6, body.constant(int(2045)));
                     ir_if *f2487 = new(mem_ctx) ir_if(operand(r2488).val);
                     exec_list *const f2487_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2487->then_instructions;

                        ir_expression *const r2489 = equal(body.constant(2097151u), r2471);
                        ir_expression *const r248A = equal(body.constant(4294967295u), r2472);
                        body.emit(assign(r2486, logic_and(r2489, r248A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2487->else_instructions;

                        body.emit(assign(r2486, body.constant(false), 0x01));


                     body.instructions = f2487_parent_instructions;
                     body.emit(f2487);

                     /* END IF */

                     body.emit(assign(r2483, logic_and(r2486, r247F), 0x01));


                  body.instructions = f2484_parent_instructions;
                  body.emit(f2484);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f248B = new(mem_ctx) ir_if(operand(r2483).val);
                  exec_list *const f248B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f248B->then_instructions;

                     ir_variable *const r248C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r248C);
                     ir_expression *const r248D = lshift(r23AE, body.constant(int(31)));
                     body.emit(assign(r248C, add(r248D, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r248C, body.constant(0u), 0x01));

                     body.emit(assign(r247E, r248C, 0x03));

                     body.emit(assign(r247D, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f248B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r248F = less(r23B6, body.constant(int(0)));
                     ir_if *f248E = new(mem_ctx) ir_if(operand(r248F).val);
                     exec_list *const f248E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f248E->then_instructions;

                        ir_variable *const r2490 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2490, r23B7, 0x01));

                        ir_variable *const r2491 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2491, neg(r23B6), 0x01));

                        ir_variable *const r2492 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2492);
                        ir_variable *const r2493 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2493);
                        ir_variable *const r2494 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2494);
                        ir_variable *const r2495 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2496 = neg(r2491);
                        body.emit(assign(r2495, bit_and(r2496, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2498 = equal(r2491, body.constant(int(0)));
                        ir_if *f2497 = new(mem_ctx) ir_if(operand(r2498).val);
                        exec_list *const f2497_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2497->then_instructions;

                           body.emit(assign(r2492, r23B7, 0x01));

                           body.emit(assign(r2493, r2472, 0x01));

                           body.emit(assign(r2494, r2471, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2497->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r249A = less(r2491, body.constant(int(32)));
                           ir_if *f2499 = new(mem_ctx) ir_if(operand(r249A).val);
                           exec_list *const f2499_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2499->then_instructions;

                              body.emit(assign(r2492, lshift(r2472, r2495), 0x01));

                              ir_expression *const r249B = lshift(r2471, r2495);
                              ir_expression *const r249C = rshift(r2472, r2491);
                              body.emit(assign(r2493, bit_or(r249B, r249C), 0x01));

                              body.emit(assign(r2494, rshift(r2471, r2491), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2499->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r249E = equal(r2491, body.constant(int(32)));
                              ir_if *f249D = new(mem_ctx) ir_if(operand(r249E).val);
                              exec_list *const f249D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f249D->then_instructions;

                                 body.emit(assign(r2492, r2472, 0x01));

                                 body.emit(assign(r2493, r2471, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f249D->else_instructions;

                                 body.emit(assign(r2490, bit_or(r23B7, r2472), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r24A0 = less(r2491, body.constant(int(64)));
                                 ir_if *f249F = new(mem_ctx) ir_if(operand(r24A0).val);
                                 exec_list *const f249F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f249F->then_instructions;

                                    body.emit(assign(r2492, lshift(r2471, r2495), 0x01));

                                    ir_expression *const r24A1 = bit_and(r2491, body.constant(int(31)));
                                    body.emit(assign(r2493, rshift(r2471, r24A1), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f249F->else_instructions;

                                    ir_variable *const r24A2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r24A4 = equal(r2491, body.constant(int(64)));
                                    ir_if *f24A3 = new(mem_ctx) ir_if(operand(r24A4).val);
                                    exec_list *const f24A3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f24A3->then_instructions;

                                       body.emit(assign(r24A2, r2471, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f24A3->else_instructions;

                                       ir_expression *const r24A5 = nequal(r2471, body.constant(0u));
                                       ir_expression *const r24A6 = expr(ir_unop_b2i, r24A5);
                                       body.emit(assign(r24A2, expr(ir_unop_i2u, r24A6), 0x01));


                                    body.instructions = f24A3_parent_instructions;
                                    body.emit(f24A3);

                                    /* END IF */

                                    body.emit(assign(r2492, r24A2, 0x01));

                                    body.emit(assign(r2493, body.constant(0u), 0x01));


                                 body.instructions = f249F_parent_instructions;
                                 body.emit(f249F);

                                 /* END IF */


                              body.instructions = f249D_parent_instructions;
                              body.emit(f249D);

                              /* END IF */

                              body.emit(assign(r2494, body.constant(0u), 0x01));


                           body.instructions = f2499_parent_instructions;
                           body.emit(f2499);

                           /* END IF */

                           ir_expression *const r24A7 = nequal(r2490, body.constant(0u));
                           ir_expression *const r24A8 = expr(ir_unop_b2i, r24A7);
                           ir_expression *const r24A9 = expr(ir_unop_i2u, r24A8);
                           body.emit(assign(r2492, bit_or(r2492, r24A9), 0x01));


                        body.instructions = f2497_parent_instructions;
                        body.emit(f2497);

                        /* END IF */

                        body.emit(assign(r247A, r2494, 0x01));

                        body.emit(assign(r247B, r2493, 0x01));

                        body.emit(assign(r247C, r2492, 0x01));

                        body.emit(assign(r2479, body.constant(int(0)), 0x01));

                        body.emit(assign(r247F, less(r2492, body.constant(0u)), 0x01));


                     body.instructions = f248E_parent_instructions;
                     body.emit(f248E);

                     /* END IF */


                  body.instructions = f248B_parent_instructions;
                  body.emit(f248B);

                  /* END IF */


               body.instructions = f2481_parent_instructions;
               body.emit(f2481);

               /* END IF */

               /* IF CONDITION */
               ir_if *f24AA = new(mem_ctx) ir_if(operand(r247D).val);
               exec_list *const f24AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f24AA->then_instructions;

                  /* IF CONDITION */
                  ir_if *f24AB = new(mem_ctx) ir_if(operand(r247F).val);
                  exec_list *const f24AB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24AB->then_instructions;

                     ir_variable *const r24AC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r24AC, add(r247B, body.constant(1u)), 0x01));

                     ir_expression *const r24AD = less(r24AC, r247B);
                     ir_expression *const r24AE = expr(ir_unop_b2i, r24AD);
                     ir_expression *const r24AF = expr(ir_unop_i2u, r24AE);
                     body.emit(assign(r247A, add(r247A, r24AF), 0x01));

                     ir_expression *const r24B0 = equal(r247C, body.constant(0u));
                     ir_expression *const r24B1 = expr(ir_unop_b2i, r24B0);
                     ir_expression *const r24B2 = expr(ir_unop_i2u, r24B1);
                     ir_expression *const r24B3 = add(r247C, r24B2);
                     ir_expression *const r24B4 = bit_and(r24B3, body.constant(1u));
                     ir_expression *const r24B5 = expr(ir_unop_bit_not, r24B4);
                     body.emit(assign(r247B, bit_and(r24AC, r24B5), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24AB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r24B7 = bit_or(r247A, r247B);
                     ir_expression *const r24B8 = equal(r24B7, body.constant(0u));
                     ir_if *f24B6 = new(mem_ctx) ir_if(operand(r24B8).val);
                     exec_list *const f24B6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24B6->then_instructions;

                        body.emit(assign(r2479, body.constant(int(0)), 0x01));


                     body.instructions = f24B6_parent_instructions;
                     body.emit(f24B6);

                     /* END IF */


                  body.instructions = f24AB_parent_instructions;
                  body.emit(f24AB);

                  /* END IF */

                  ir_variable *const r24B9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r24B9);
                  ir_expression *const r24BA = lshift(r23AE, body.constant(int(31)));
                  ir_expression *const r24BB = expr(ir_unop_i2u, r2479);
                  ir_expression *const r24BC = lshift(r24BB, body.constant(int(20)));
                  ir_expression *const r24BD = add(r24BA, r24BC);
                  body.emit(assign(r24B9, add(r24BD, r247A), 0x02));

                  body.emit(assign(r24B9, r247B, 0x01));

                  body.emit(assign(r247E, r24B9, 0x03));

                  body.emit(assign(r247D, body.constant(false), 0x01));


               body.instructions = f24AA_parent_instructions;
               body.emit(f24AA);

               /* END IF */

               body.emit(assign(r23B2, r247E, 0x03));

               body.emit(assign(r23B1, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2477->else_instructions;

               body.emit(assign(r23B6, add(r23B6, body.constant(int(1))), 0x01));

               ir_variable *const r24BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r24BE);
               ir_variable *const r24BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r24BF);
               ir_variable *const r24C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r24C0);
               body.emit(assign(r24BE, lshift(r2472, body.constant(int(31))), 0x01));

               ir_expression *const r24C1 = lshift(r2471, body.constant(int(31)));
               ir_expression *const r24C2 = rshift(r2472, body.constant(int(1)));
               body.emit(assign(r24BF, bit_or(r24C1, r24C2), 0x01));

               body.emit(assign(r24C0, rshift(r2471, body.constant(int(1))), 0x01));

               ir_expression *const r24C3 = nequal(r23B7, body.constant(0u));
               ir_expression *const r24C4 = expr(ir_unop_b2i, r24C3);
               ir_expression *const r24C5 = expr(ir_unop_i2u, r24C4);
               body.emit(assign(r24BE, bit_or(r24BE, r24C5), 0x01));

               body.emit(assign(r23B8, r24C0, 0x01));

               body.emit(assign(r23B7, r24BE, 0x01));

               ir_variable *const r24C6 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r24C6, r23B6, 0x01));

               ir_variable *const r24C7 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r24C7, r24C0, 0x01));

               ir_variable *const r24C8 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r24C8, r24BF, 0x01));

               ir_variable *const r24C9 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r24C9, r24BE, 0x01));

               ir_variable *const r24CA = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r24CA, body.constant(true), 0x01));

               ir_variable *const r24CB = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r24CC = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r24CC);
               ir_expression *const r24CD = expr(ir_unop_u2i, r24BE);
               body.emit(assign(r24CC, less(r24CD, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r24CF = lequal(body.constant(int(2045)), r23B6);
               ir_if *f24CE = new(mem_ctx) ir_if(operand(r24CF).val);
               exec_list *const f24CE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f24CE->then_instructions;

                  ir_variable *const r24D0 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r24D2 = less(body.constant(int(2045)), r23B6);
                  ir_if *f24D1 = new(mem_ctx) ir_if(operand(r24D2).val);
                  exec_list *const f24D1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24D1->then_instructions;

                     body.emit(assign(r24D0, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24D1->else_instructions;

                     ir_variable *const r24D3 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r24D5 = equal(r23B6, body.constant(int(2045)));
                     ir_if *f24D4 = new(mem_ctx) ir_if(operand(r24D5).val);
                     exec_list *const f24D4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24D4->then_instructions;

                        ir_expression *const r24D6 = equal(body.constant(2097151u), r24C0);
                        ir_expression *const r24D7 = equal(body.constant(4294967295u), r24BF);
                        body.emit(assign(r24D3, logic_and(r24D6, r24D7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f24D4->else_instructions;

                        body.emit(assign(r24D3, body.constant(false), 0x01));


                     body.instructions = f24D4_parent_instructions;
                     body.emit(f24D4);

                     /* END IF */

                     body.emit(assign(r24D0, logic_and(r24D3, r24CC), 0x01));


                  body.instructions = f24D1_parent_instructions;
                  body.emit(f24D1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f24D8 = new(mem_ctx) ir_if(operand(r24D0).val);
                  exec_list *const f24D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24D8->then_instructions;

                     ir_variable *const r24D9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r24D9);
                     ir_expression *const r24DA = lshift(r23AE, body.constant(int(31)));
                     body.emit(assign(r24D9, add(r24DA, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r24D9, body.constant(0u), 0x01));

                     body.emit(assign(r24CB, r24D9, 0x03));

                     body.emit(assign(r24CA, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24D8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r24DC = less(r23B6, body.constant(int(0)));
                     ir_if *f24DB = new(mem_ctx) ir_if(operand(r24DC).val);
                     exec_list *const f24DB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24DB->then_instructions;

                        ir_variable *const r24DD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r24DD, r24BE, 0x01));

                        ir_variable *const r24DE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r24DE, neg(r23B6), 0x01));

                        ir_variable *const r24DF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r24DF);
                        ir_variable *const r24E0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r24E0);
                        ir_variable *const r24E1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r24E1);
                        ir_variable *const r24E2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r24E3 = neg(r24DE);
                        body.emit(assign(r24E2, bit_and(r24E3, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r24E5 = equal(r24DE, body.constant(int(0)));
                        ir_if *f24E4 = new(mem_ctx) ir_if(operand(r24E5).val);
                        exec_list *const f24E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24E4->then_instructions;

                           body.emit(assign(r24DF, r24BE, 0x01));

                           body.emit(assign(r24E0, r24BF, 0x01));

                           body.emit(assign(r24E1, r24C0, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f24E4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r24E7 = less(r24DE, body.constant(int(32)));
                           ir_if *f24E6 = new(mem_ctx) ir_if(operand(r24E7).val);
                           exec_list *const f24E6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f24E6->then_instructions;

                              body.emit(assign(r24DF, lshift(r24BF, r24E2), 0x01));

                              ir_expression *const r24E8 = lshift(r24C0, r24E2);
                              ir_expression *const r24E9 = rshift(r24BF, r24DE);
                              body.emit(assign(r24E0, bit_or(r24E8, r24E9), 0x01));

                              body.emit(assign(r24E1, rshift(r24C0, r24DE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f24E6->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r24EB = equal(r24DE, body.constant(int(32)));
                              ir_if *f24EA = new(mem_ctx) ir_if(operand(r24EB).val);
                              exec_list *const f24EA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f24EA->then_instructions;

                                 body.emit(assign(r24DF, r24BF, 0x01));

                                 body.emit(assign(r24E0, r24C0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f24EA->else_instructions;

                                 body.emit(assign(r24DD, bit_or(r24BE, r24BF), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r24ED = less(r24DE, body.constant(int(64)));
                                 ir_if *f24EC = new(mem_ctx) ir_if(operand(r24ED).val);
                                 exec_list *const f24EC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f24EC->then_instructions;

                                    body.emit(assign(r24DF, lshift(r24C0, r24E2), 0x01));

                                    ir_expression *const r24EE = bit_and(r24DE, body.constant(int(31)));
                                    body.emit(assign(r24E0, rshift(r24C0, r24EE), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f24EC->else_instructions;

                                    ir_variable *const r24EF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r24F1 = equal(r24DE, body.constant(int(64)));
                                    ir_if *f24F0 = new(mem_ctx) ir_if(operand(r24F1).val);
                                    exec_list *const f24F0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f24F0->then_instructions;

                                       body.emit(assign(r24EF, r24C0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f24F0->else_instructions;

                                       ir_expression *const r24F2 = nequal(r24C0, body.constant(0u));
                                       ir_expression *const r24F3 = expr(ir_unop_b2i, r24F2);
                                       body.emit(assign(r24EF, expr(ir_unop_i2u, r24F3), 0x01));


                                    body.instructions = f24F0_parent_instructions;
                                    body.emit(f24F0);

                                    /* END IF */

                                    body.emit(assign(r24DF, r24EF, 0x01));

                                    body.emit(assign(r24E0, body.constant(0u), 0x01));


                                 body.instructions = f24EC_parent_instructions;
                                 body.emit(f24EC);

                                 /* END IF */


                              body.instructions = f24EA_parent_instructions;
                              body.emit(f24EA);

                              /* END IF */

                              body.emit(assign(r24E1, body.constant(0u), 0x01));


                           body.instructions = f24E6_parent_instructions;
                           body.emit(f24E6);

                           /* END IF */

                           ir_expression *const r24F4 = nequal(r24DD, body.constant(0u));
                           ir_expression *const r24F5 = expr(ir_unop_b2i, r24F4);
                           ir_expression *const r24F6 = expr(ir_unop_i2u, r24F5);
                           body.emit(assign(r24DF, bit_or(r24DF, r24F6), 0x01));


                        body.instructions = f24E4_parent_instructions;
                        body.emit(f24E4);

                        /* END IF */

                        body.emit(assign(r24C7, r24E1, 0x01));

                        body.emit(assign(r24C8, r24E0, 0x01));

                        body.emit(assign(r24C9, r24DF, 0x01));

                        body.emit(assign(r24C6, body.constant(int(0)), 0x01));

                        body.emit(assign(r24CC, less(r24DF, body.constant(0u)), 0x01));


                     body.instructions = f24DB_parent_instructions;
                     body.emit(f24DB);

                     /* END IF */


                  body.instructions = f24D8_parent_instructions;
                  body.emit(f24D8);

                  /* END IF */


               body.instructions = f24CE_parent_instructions;
               body.emit(f24CE);

               /* END IF */

               /* IF CONDITION */
               ir_if *f24F7 = new(mem_ctx) ir_if(operand(r24CA).val);
               exec_list *const f24F7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f24F7->then_instructions;

                  /* IF CONDITION */
                  ir_if *f24F8 = new(mem_ctx) ir_if(operand(r24CC).val);
                  exec_list *const f24F8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24F8->then_instructions;

                     ir_variable *const r24F9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r24F9, add(r24C8, body.constant(1u)), 0x01));

                     ir_expression *const r24FA = less(r24F9, r24C8);
                     ir_expression *const r24FB = expr(ir_unop_b2i, r24FA);
                     ir_expression *const r24FC = expr(ir_unop_i2u, r24FB);
                     body.emit(assign(r24C7, add(r24C7, r24FC), 0x01));

                     ir_expression *const r24FD = equal(r24C9, body.constant(0u));
                     ir_expression *const r24FE = expr(ir_unop_b2i, r24FD);
                     ir_expression *const r24FF = expr(ir_unop_i2u, r24FE);
                     ir_expression *const r2500 = add(r24C9, r24FF);
                     ir_expression *const r2501 = bit_and(r2500, body.constant(1u));
                     ir_expression *const r2502 = expr(ir_unop_bit_not, r2501);
                     body.emit(assign(r24C8, bit_and(r24F9, r2502), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24F8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2504 = bit_or(r24C7, r24C8);
                     ir_expression *const r2505 = equal(r2504, body.constant(0u));
                     ir_if *f2503 = new(mem_ctx) ir_if(operand(r2505).val);
                     exec_list *const f2503_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2503->then_instructions;

                        body.emit(assign(r24C6, body.constant(int(0)), 0x01));


                     body.instructions = f2503_parent_instructions;
                     body.emit(f2503);

                     /* END IF */


                  body.instructions = f24F8_parent_instructions;
                  body.emit(f24F8);

                  /* END IF */

                  ir_variable *const r2506 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2506);
                  ir_expression *const r2507 = lshift(r23AE, body.constant(int(31)));
                  ir_expression *const r2508 = expr(ir_unop_i2u, r24C6);
                  ir_expression *const r2509 = lshift(r2508, body.constant(int(20)));
                  ir_expression *const r250A = add(r2507, r2509);
                  body.emit(assign(r2506, add(r250A, r24C7), 0x02));

                  body.emit(assign(r2506, r24C8, 0x01));

                  body.emit(assign(r24CB, r2506, 0x03));

                  body.emit(assign(r24CA, body.constant(false), 0x01));


               body.instructions = f24F7_parent_instructions;
               body.emit(f24F7);

               /* END IF */

               body.emit(assign(r23B2, r24CB, 0x03));

               body.emit(assign(r23B1, body.constant(false), 0x01));


            body.instructions = f2477_parent_instructions;
            body.emit(f2477);

            /* END IF */


         body.instructions = f2470_parent_instructions;
         body.emit(f2470);

         /* END IF */

         body.emit(assign(r23AD, r23B2, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f23AF->else_instructions;

         ir_variable *const r250B = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r250B, r23AE, 0x01));

         ir_variable *const r250C = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r250D = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r250D);
         ir_variable *const r250E = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r250E);
         ir_variable *const r250F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r250F);
         ir_variable *const r2510 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r2510);
         ir_variable *const r2511 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r2511);
         ir_variable *const r2512 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2512);
         ir_variable *const r2513 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r2513);
         body.emit(assign(r2513, bit_and(swizzle_y(r2379), body.constant(1048575u)), 0x02));

         body.emit(assign(r2513, swizzle_x(r2379), 0x01));

         ir_variable *const r2514 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2515 = rshift(swizzle_y(r2379), body.constant(int(20)));
         ir_expression *const r2516 = bit_and(r2515, body.constant(2047u));
         body.emit(assign(r2514, expr(ir_unop_u2i, r2516), 0x01));

         body.emit(assign(r2510, r2514, 0x01));

         ir_variable *const r2517 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r2517);
         body.emit(assign(r2517, body.constant(0u), 0x02));

         body.emit(assign(r2517, body.constant(0u), 0x01));

         body.emit(assign(r250E, body.constant(int(1023)), 0x01));

         body.emit(assign(r250D, add(r2514, body.constant(int(-1023))), 0x01));

         ir_variable *const r2518 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r2518, lshift(swizzle_x(r2379), body.constant(int(10))), 0x01));

         ir_variable *const r2519 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r251A = lshift(swizzle_y(r2513), body.constant(int(10)));
         ir_expression *const r251B = rshift(swizzle_x(r2379), body.constant(int(22)));
         body.emit(assign(r2519, bit_or(r251A, r251B), 0x01));

         body.emit(assign(r2511, r2519, 0x02));

         body.emit(assign(r2511, r2518, 0x01));

         ir_variable *const r251C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r251C, body.constant(0u), 0x01));

         body.emit(assign(r250F, r251C, 0x02));

         body.emit(assign(r250F, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r251E = less(body.constant(int(0)), r250D);
         ir_if *f251D = new(mem_ctx) ir_if(operand(r251E).val);
         exec_list *const f251D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f251D->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2520 = equal(r2514, body.constant(int(2047)));
            ir_if *f251F = new(mem_ctx) ir_if(operand(r2520).val);
            exec_list *const f251F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f251F->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2522 = bit_or(r2519, r2518);
               ir_expression *const r2523 = nequal(r2522, body.constant(0u));
               ir_if *f2521 = new(mem_ctx) ir_if(operand(r2523).val);
               exec_list *const f2521_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2521->then_instructions;

                  ir_variable *const r2524 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2524, swizzle_x(r2379), 0x01));

                  ir_variable *const r2525 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2525, body.constant(0u), 0x01));

                  ir_variable *const r2526 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2524, bit_or(swizzle_y(r2379), body.constant(524288u)), 0x02));

                  body.emit(assign(r2525, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2528 = lshift(swizzle_y(r2379), body.constant(int(1)));
                  ir_expression *const r2529 = lequal(body.constant(4292870144u), r2528);
                  ir_expression *const r252A = nequal(swizzle_x(r2379), body.constant(0u));
                  ir_expression *const r252B = bit_and(swizzle_y(r2379), body.constant(1048575u));
                  ir_expression *const r252C = nequal(r252B, body.constant(0u));
                  ir_expression *const r252D = logic_or(r252A, r252C);
                  ir_expression *const r252E = logic_and(r2529, r252D);
                  ir_if *f2527 = new(mem_ctx) ir_if(operand(r252E).val);
                  exec_list *const f2527_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2527->then_instructions;

                     body.emit(assign(r2526, r2524, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2527->else_instructions;

                     body.emit(assign(r2526, r2525, 0x03));


                  body.instructions = f2527_parent_instructions;
                  body.emit(f2527);

                  /* END IF */

                  body.emit(assign(r250C, r2526, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2521->else_instructions;

                  body.emit(assign(r250C, r2379, 0x03));


               body.instructions = f2521_parent_instructions;
               body.emit(f2521);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f251F->else_instructions;

               body.emit(assign(r250F, body.constant(1073741824u), 0x02));

               ir_variable *const r252F = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r252F, body.constant(1073741824u), 0x01));

               ir_variable *const r2530 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r2530, body.constant(0u), 0x01));

               ir_variable *const r2531 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2531);
               ir_variable *const r2532 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2532);
               ir_variable *const r2533 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2534 = neg(r250D);
               body.emit(assign(r2533, bit_and(r2534, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2536 = equal(r250D, body.constant(int(0)));
               ir_if *f2535 = new(mem_ctx) ir_if(operand(r2536).val);
               exec_list *const f2535_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2535->then_instructions;

                  body.emit(assign(r2531, r2530, 0x01));

                  body.emit(assign(r2532, r252F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2535->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2538 = less(r250D, body.constant(int(32)));
                  ir_if *f2537 = new(mem_ctx) ir_if(operand(r2538).val);
                  exec_list *const f2537_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2537->then_instructions;

                     ir_expression *const r2539 = lshift(body.constant(1073741824u), r2533);
                     ir_expression *const r253A = bit_or(r2539, body.constant(0u));
                     body.emit(assign(r2531, bit_or(r253A, body.constant(0u)), 0x01));

                     body.emit(assign(r2532, rshift(body.constant(1073741824u), r250D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2537->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r253C = equal(r250D, body.constant(int(32)));
                     ir_if *f253B = new(mem_ctx) ir_if(operand(r253C).val);
                     exec_list *const f253B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f253B->then_instructions;

                        body.emit(assign(r2531, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f253B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r253E = less(r250D, body.constant(int(64)));
                        ir_if *f253D = new(mem_ctx) ir_if(operand(r253E).val);
                        exec_list *const f253D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f253D->then_instructions;

                           ir_expression *const r253F = bit_and(r250D, body.constant(int(31)));
                           ir_expression *const r2540 = rshift(body.constant(1073741824u), r253F);
                           ir_expression *const r2541 = lshift(body.constant(1073741824u), r2533);
                           ir_expression *const r2542 = bit_or(r2541, body.constant(0u));
                           ir_expression *const r2543 = nequal(r2542, body.constant(0u));
                           ir_expression *const r2544 = expr(ir_unop_b2i, r2543);
                           ir_expression *const r2545 = expr(ir_unop_i2u, r2544);
                           body.emit(assign(r2531, bit_or(r2540, r2545), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f253D->else_instructions;

                           body.emit(assign(r2531, body.constant(1u), 0x01));


                        body.instructions = f253D_parent_instructions;
                        body.emit(f253D);

                        /* END IF */


                     body.instructions = f253B_parent_instructions;
                     body.emit(f253B);

                     /* END IF */

                     body.emit(assign(r2532, body.constant(0u), 0x01));


                  body.instructions = f2537_parent_instructions;
                  body.emit(f2537);

                  /* END IF */


               body.instructions = f2535_parent_instructions;
               body.emit(f2535);

               /* END IF */

               body.emit(assign(r250F, r2532, 0x02));

               body.emit(assign(r250F, r2531, 0x01));

               body.emit(assign(r2511, bit_or(r2519, body.constant(1073741824u)), 0x02));

               ir_variable *const r2546 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2547 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2547, sub(r2518, r2531), 0x01));

               ir_expression *const r2548 = sub(swizzle_y(r2511), r2532);
               ir_expression *const r2549 = less(r2518, r2531);
               ir_expression *const r254A = expr(ir_unop_b2i, r2549);
               ir_expression *const r254B = expr(ir_unop_i2u, r254A);
               body.emit(assign(r2546, sub(r2548, r254B), 0x01));

               body.emit(assign(r2512, add(r2514, body.constant(int(-1))), 0x01));

               ir_variable *const r254C = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r254C, add(r2512, body.constant(int(-10))), 0x01));

               ir_variable *const r254D = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r254D, r2546, 0x01));

               ir_variable *const r254E = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r254E, r2547, 0x01));

               ir_variable *const r254F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r254F);
               ir_variable *const r2550 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2550);
               /* IF CONDITION */
               ir_expression *const r2552 = equal(r2546, body.constant(0u));
               ir_if *f2551 = new(mem_ctx) ir_if(operand(r2552).val);
               exec_list *const f2551_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2551->then_instructions;

                  body.emit(assign(r254D, r2547, 0x01));

                  body.emit(assign(r254E, body.constant(0u), 0x01));

                  body.emit(assign(r254C, add(r254C, body.constant(int(-32))), 0x01));


               body.instructions = f2551_parent_instructions;
               body.emit(f2551);

               /* END IF */

               ir_variable *const r2553 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2553, r254D, 0x01));

               ir_variable *const r2554 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2555 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2555);
               /* IF CONDITION */
               ir_expression *const r2557 = equal(r254D, body.constant(0u));
               ir_if *f2556 = new(mem_ctx) ir_if(operand(r2557).val);
               exec_list *const f2556_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2556->then_instructions;

                  body.emit(assign(r2554, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2556->else_instructions;

                  body.emit(assign(r2555, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2559 = bit_and(r254D, body.constant(4294901760u));
                  ir_expression *const r255A = equal(r2559, body.constant(0u));
                  ir_if *f2558 = new(mem_ctx) ir_if(operand(r255A).val);
                  exec_list *const f2558_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2558->then_instructions;

                     body.emit(assign(r2555, body.constant(int(16)), 0x01));

                     body.emit(assign(r2553, lshift(r254D, body.constant(int(16))), 0x01));


                  body.instructions = f2558_parent_instructions;
                  body.emit(f2558);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r255C = bit_and(r2553, body.constant(4278190080u));
                  ir_expression *const r255D = equal(r255C, body.constant(0u));
                  ir_if *f255B = new(mem_ctx) ir_if(operand(r255D).val);
                  exec_list *const f255B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f255B->then_instructions;

                     body.emit(assign(r2555, add(r2555, body.constant(int(8))), 0x01));

                     body.emit(assign(r2553, lshift(r2553, body.constant(int(8))), 0x01));


                  body.instructions = f255B_parent_instructions;
                  body.emit(f255B);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r255F = bit_and(r2553, body.constant(4026531840u));
                  ir_expression *const r2560 = equal(r255F, body.constant(0u));
                  ir_if *f255E = new(mem_ctx) ir_if(operand(r2560).val);
                  exec_list *const f255E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f255E->then_instructions;

                     body.emit(assign(r2555, add(r2555, body.constant(int(4))), 0x01));

                     body.emit(assign(r2553, lshift(r2553, body.constant(int(4))), 0x01));


                  body.instructions = f255E_parent_instructions;
                  body.emit(f255E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2562 = bit_and(r2553, body.constant(3221225472u));
                  ir_expression *const r2563 = equal(r2562, body.constant(0u));
                  ir_if *f2561 = new(mem_ctx) ir_if(operand(r2563).val);
                  exec_list *const f2561_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2561->then_instructions;

                     body.emit(assign(r2555, add(r2555, body.constant(int(2))), 0x01));

                     body.emit(assign(r2553, lshift(r2553, body.constant(int(2))), 0x01));


                  body.instructions = f2561_parent_instructions;
                  body.emit(f2561);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2565 = bit_and(r2553, body.constant(2147483648u));
                  ir_expression *const r2566 = equal(r2565, body.constant(0u));
                  ir_if *f2564 = new(mem_ctx) ir_if(operand(r2566).val);
                  exec_list *const f2564_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2564->then_instructions;

                     body.emit(assign(r2555, add(r2555, body.constant(int(1))), 0x01));


                  body.instructions = f2564_parent_instructions;
                  body.emit(f2564);

                  /* END IF */

                  body.emit(assign(r2554, r2555, 0x01));


               body.instructions = f2556_parent_instructions;
               body.emit(f2556);

               /* END IF */

               body.emit(assign(r2550, add(r2554, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2568 = lequal(body.constant(int(0)), r2550);
               ir_if *f2567 = new(mem_ctx) ir_if(operand(r2568).val);
               exec_list *const f2567_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2567->then_instructions;

                  body.emit(assign(r254F, body.constant(0u), 0x01));

                  ir_variable *const r2569 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2569, lshift(r254E, r2550), 0x01));

                  ir_variable *const r256A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r256C = equal(r2550, body.constant(int(0)));
                  ir_if *f256B = new(mem_ctx) ir_if(operand(r256C).val);
                  exec_list *const f256B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f256B->then_instructions;

                     body.emit(assign(r256A, r254D, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f256B->else_instructions;

                     ir_expression *const r256D = lshift(r254D, r2550);
                     ir_expression *const r256E = neg(r2550);
                     ir_expression *const r256F = bit_and(r256E, body.constant(int(31)));
                     ir_expression *const r2570 = rshift(r254E, r256F);
                     body.emit(assign(r256A, bit_or(r256D, r2570), 0x01));


                  body.instructions = f256B_parent_instructions;
                  body.emit(f256B);

                  /* END IF */

                  body.emit(assign(r254D, r256A, 0x01));

                  body.emit(assign(r254E, r2569, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2567->else_instructions;

                  ir_variable *const r2571 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2571, body.constant(0u), 0x01));

                  ir_variable *const r2572 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2572, neg(r2550), 0x01));

                  ir_variable *const r2573 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2573);
                  ir_variable *const r2574 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2574);
                  ir_variable *const r2575 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2575);
                  ir_variable *const r2576 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2577 = neg(r2572);
                  body.emit(assign(r2576, bit_and(r2577, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2579 = equal(r2572, body.constant(int(0)));
                  ir_if *f2578 = new(mem_ctx) ir_if(operand(r2579).val);
                  exec_list *const f2578_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2578->then_instructions;

                     body.emit(assign(r2573, r2571, 0x01));

                     body.emit(assign(r2574, r254E, 0x01));

                     body.emit(assign(r2575, r254D, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2578->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r257B = less(r2572, body.constant(int(32)));
                     ir_if *f257A = new(mem_ctx) ir_if(operand(r257B).val);
                     exec_list *const f257A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f257A->then_instructions;

                        body.emit(assign(r2573, lshift(r254E, r2576), 0x01));

                        ir_expression *const r257C = lshift(r254D, r2576);
                        ir_expression *const r257D = rshift(r254E, r2572);
                        body.emit(assign(r2574, bit_or(r257C, r257D), 0x01));

                        body.emit(assign(r2575, rshift(r254D, r2572), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f257A->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r257F = equal(r2572, body.constant(int(32)));
                        ir_if *f257E = new(mem_ctx) ir_if(operand(r257F).val);
                        exec_list *const f257E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f257E->then_instructions;

                           body.emit(assign(r2573, r254E, 0x01));

                           body.emit(assign(r2574, r254D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f257E->else_instructions;

                           body.emit(assign(r2571, bit_or(body.constant(0u), r254E), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2581 = less(r2572, body.constant(int(64)));
                           ir_if *f2580 = new(mem_ctx) ir_if(operand(r2581).val);
                           exec_list *const f2580_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2580->then_instructions;

                              body.emit(assign(r2573, lshift(r254D, r2576), 0x01));

                              ir_expression *const r2582 = bit_and(r2572, body.constant(int(31)));
                              body.emit(assign(r2574, rshift(r254D, r2582), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2580->else_instructions;

                              ir_variable *const r2583 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2585 = equal(r2572, body.constant(int(64)));
                              ir_if *f2584 = new(mem_ctx) ir_if(operand(r2585).val);
                              exec_list *const f2584_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2584->then_instructions;

                                 body.emit(assign(r2583, r254D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2584->else_instructions;

                                 ir_expression *const r2586 = nequal(r254D, body.constant(0u));
                                 ir_expression *const r2587 = expr(ir_unop_b2i, r2586);
                                 body.emit(assign(r2583, expr(ir_unop_i2u, r2587), 0x01));


                              body.instructions = f2584_parent_instructions;
                              body.emit(f2584);

                              /* END IF */

                              body.emit(assign(r2573, r2583, 0x01));

                              body.emit(assign(r2574, body.constant(0u), 0x01));


                           body.instructions = f2580_parent_instructions;
                           body.emit(f2580);

                           /* END IF */


                        body.instructions = f257E_parent_instructions;
                        body.emit(f257E);

                        /* END IF */

                        body.emit(assign(r2575, body.constant(0u), 0x01));


                     body.instructions = f257A_parent_instructions;
                     body.emit(f257A);

                     /* END IF */

                     ir_expression *const r2588 = nequal(r2571, body.constant(0u));
                     ir_expression *const r2589 = expr(ir_unop_b2i, r2588);
                     ir_expression *const r258A = expr(ir_unop_i2u, r2589);
                     body.emit(assign(r2573, bit_or(r2573, r258A), 0x01));


                  body.instructions = f2578_parent_instructions;
                  body.emit(f2578);

                  /* END IF */

                  body.emit(assign(r254D, r2575, 0x01));

                  body.emit(assign(r254E, r2574, 0x01));

                  body.emit(assign(r254F, r2573, 0x01));


               body.instructions = f2567_parent_instructions;
               body.emit(f2567);

               /* END IF */

               body.emit(assign(r254C, sub(r254C, r2550), 0x01));

               ir_variable *const r258B = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r258B, r254C, 0x01));

               ir_variable *const r258C = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r258C, r254D, 0x01));

               ir_variable *const r258D = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r258D, r254E, 0x01));

               ir_variable *const r258E = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r258E, r254F, 0x01));

               ir_variable *const r258F = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r258F, body.constant(true), 0x01));

               ir_variable *const r2590 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2591 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2591);
               ir_expression *const r2592 = expr(ir_unop_u2i, r254F);
               body.emit(assign(r2591, less(r2592, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2594 = lequal(body.constant(int(2045)), r254C);
               ir_if *f2593 = new(mem_ctx) ir_if(operand(r2594).val);
               exec_list *const f2593_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2593->then_instructions;

                  ir_variable *const r2595 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2597 = less(body.constant(int(2045)), r254C);
                  ir_if *f2596 = new(mem_ctx) ir_if(operand(r2597).val);
                  exec_list *const f2596_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2596->then_instructions;

                     body.emit(assign(r2595, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2596->else_instructions;

                     ir_variable *const r2598 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r259A = equal(r254C, body.constant(int(2045)));
                     ir_if *f2599 = new(mem_ctx) ir_if(operand(r259A).val);
                     exec_list *const f2599_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2599->then_instructions;

                        ir_expression *const r259B = equal(body.constant(2097151u), r254D);
                        ir_expression *const r259C = equal(body.constant(4294967295u), r254E);
                        body.emit(assign(r2598, logic_and(r259B, r259C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2599->else_instructions;

                        body.emit(assign(r2598, body.constant(false), 0x01));


                     body.instructions = f2599_parent_instructions;
                     body.emit(f2599);

                     /* END IF */

                     body.emit(assign(r2595, logic_and(r2598, r2591), 0x01));


                  body.instructions = f2596_parent_instructions;
                  body.emit(f2596);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f259D = new(mem_ctx) ir_if(operand(r2595).val);
                  exec_list *const f259D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f259D->then_instructions;

                     ir_variable *const r259E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r259E);
                     ir_expression *const r259F = lshift(r23AE, body.constant(int(31)));
                     body.emit(assign(r259E, add(r259F, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r259E, body.constant(0u), 0x01));

                     body.emit(assign(r2590, r259E, 0x03));

                     body.emit(assign(r258F, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f259D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r25A1 = less(r254C, body.constant(int(0)));
                     ir_if *f25A0 = new(mem_ctx) ir_if(operand(r25A1).val);
                     exec_list *const f25A0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25A0->then_instructions;

                        ir_variable *const r25A2 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r25A2, r254F, 0x01));

                        ir_variable *const r25A3 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r25A3, neg(r254C), 0x01));

                        ir_variable *const r25A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r25A4);
                        ir_variable *const r25A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r25A5);
                        ir_variable *const r25A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r25A6);
                        ir_variable *const r25A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r25A8 = neg(r25A3);
                        body.emit(assign(r25A7, bit_and(r25A8, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r25AA = equal(r25A3, body.constant(int(0)));
                        ir_if *f25A9 = new(mem_ctx) ir_if(operand(r25AA).val);
                        exec_list *const f25A9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25A9->then_instructions;

                           body.emit(assign(r25A4, r254F, 0x01));

                           body.emit(assign(r25A5, r254E, 0x01));

                           body.emit(assign(r25A6, r254D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f25A9->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r25AC = less(r25A3, body.constant(int(32)));
                           ir_if *f25AB = new(mem_ctx) ir_if(operand(r25AC).val);
                           exec_list *const f25AB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25AB->then_instructions;

                              body.emit(assign(r25A4, lshift(r254E, r25A7), 0x01));

                              ir_expression *const r25AD = lshift(r254D, r25A7);
                              ir_expression *const r25AE = rshift(r254E, r25A3);
                              body.emit(assign(r25A5, bit_or(r25AD, r25AE), 0x01));

                              body.emit(assign(r25A6, rshift(r254D, r25A3), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25AB->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r25B0 = equal(r25A3, body.constant(int(32)));
                              ir_if *f25AF = new(mem_ctx) ir_if(operand(r25B0).val);
                              exec_list *const f25AF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f25AF->then_instructions;

                                 body.emit(assign(r25A4, r254E, 0x01));

                                 body.emit(assign(r25A5, r254D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f25AF->else_instructions;

                                 body.emit(assign(r25A2, bit_or(r254F, r254E), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r25B2 = less(r25A3, body.constant(int(64)));
                                 ir_if *f25B1 = new(mem_ctx) ir_if(operand(r25B2).val);
                                 exec_list *const f25B1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f25B1->then_instructions;

                                    body.emit(assign(r25A4, lshift(r254D, r25A7), 0x01));

                                    ir_expression *const r25B3 = bit_and(r25A3, body.constant(int(31)));
                                    body.emit(assign(r25A5, rshift(r254D, r25B3), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f25B1->else_instructions;

                                    ir_variable *const r25B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r25B6 = equal(r25A3, body.constant(int(64)));
                                    ir_if *f25B5 = new(mem_ctx) ir_if(operand(r25B6).val);
                                    exec_list *const f25B5_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f25B5->then_instructions;

                                       body.emit(assign(r25B4, r254D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f25B5->else_instructions;

                                       ir_expression *const r25B7 = nequal(r254D, body.constant(0u));
                                       ir_expression *const r25B8 = expr(ir_unop_b2i, r25B7);
                                       body.emit(assign(r25B4, expr(ir_unop_i2u, r25B8), 0x01));


                                    body.instructions = f25B5_parent_instructions;
                                    body.emit(f25B5);

                                    /* END IF */

                                    body.emit(assign(r25A4, r25B4, 0x01));

                                    body.emit(assign(r25A5, body.constant(0u), 0x01));


                                 body.instructions = f25B1_parent_instructions;
                                 body.emit(f25B1);

                                 /* END IF */


                              body.instructions = f25AF_parent_instructions;
                              body.emit(f25AF);

                              /* END IF */

                              body.emit(assign(r25A6, body.constant(0u), 0x01));


                           body.instructions = f25AB_parent_instructions;
                           body.emit(f25AB);

                           /* END IF */

                           ir_expression *const r25B9 = nequal(r25A2, body.constant(0u));
                           ir_expression *const r25BA = expr(ir_unop_b2i, r25B9);
                           ir_expression *const r25BB = expr(ir_unop_i2u, r25BA);
                           body.emit(assign(r25A4, bit_or(r25A4, r25BB), 0x01));


                        body.instructions = f25A9_parent_instructions;
                        body.emit(f25A9);

                        /* END IF */

                        body.emit(assign(r258C, r25A6, 0x01));

                        body.emit(assign(r258D, r25A5, 0x01));

                        body.emit(assign(r258E, r25A4, 0x01));

                        body.emit(assign(r258B, body.constant(int(0)), 0x01));

                        body.emit(assign(r2591, less(r25A4, body.constant(0u)), 0x01));


                     body.instructions = f25A0_parent_instructions;
                     body.emit(f25A0);

                     /* END IF */


                  body.instructions = f259D_parent_instructions;
                  body.emit(f259D);

                  /* END IF */


               body.instructions = f2593_parent_instructions;
               body.emit(f2593);

               /* END IF */

               /* IF CONDITION */
               ir_if *f25BC = new(mem_ctx) ir_if(operand(r258F).val);
               exec_list *const f25BC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f25BC->then_instructions;

                  /* IF CONDITION */
                  ir_if *f25BD = new(mem_ctx) ir_if(operand(r2591).val);
                  exec_list *const f25BD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f25BD->then_instructions;

                     ir_variable *const r25BE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r25BE, add(r258D, body.constant(1u)), 0x01));

                     ir_expression *const r25BF = less(r25BE, r258D);
                     ir_expression *const r25C0 = expr(ir_unop_b2i, r25BF);
                     ir_expression *const r25C1 = expr(ir_unop_i2u, r25C0);
                     body.emit(assign(r258C, add(r258C, r25C1), 0x01));

                     ir_expression *const r25C2 = equal(r258E, body.constant(0u));
                     ir_expression *const r25C3 = expr(ir_unop_b2i, r25C2);
                     ir_expression *const r25C4 = expr(ir_unop_i2u, r25C3);
                     ir_expression *const r25C5 = add(r258E, r25C4);
                     ir_expression *const r25C6 = bit_and(r25C5, body.constant(1u));
                     ir_expression *const r25C7 = expr(ir_unop_bit_not, r25C6);
                     body.emit(assign(r258D, bit_and(r25BE, r25C7), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f25BD->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r25C9 = bit_or(r258C, r258D);
                     ir_expression *const r25CA = equal(r25C9, body.constant(0u));
                     ir_if *f25C8 = new(mem_ctx) ir_if(operand(r25CA).val);
                     exec_list *const f25C8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25C8->then_instructions;

                        body.emit(assign(r258B, body.constant(int(0)), 0x01));


                     body.instructions = f25C8_parent_instructions;
                     body.emit(f25C8);

                     /* END IF */


                  body.instructions = f25BD_parent_instructions;
                  body.emit(f25BD);

                  /* END IF */

                  ir_variable *const r25CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r25CB);
                  ir_expression *const r25CC = lshift(r23AE, body.constant(int(31)));
                  ir_expression *const r25CD = expr(ir_unop_i2u, r258B);
                  ir_expression *const r25CE = lshift(r25CD, body.constant(int(20)));
                  ir_expression *const r25CF = add(r25CC, r25CE);
                  body.emit(assign(r25CB, add(r25CF, r258C), 0x02));

                  body.emit(assign(r25CB, r258D, 0x01));

                  body.emit(assign(r2590, r25CB, 0x03));

                  body.emit(assign(r258F, body.constant(false), 0x01));


               body.instructions = f25BC_parent_instructions;
               body.emit(f25BC);

               /* END IF */

               body.emit(assign(r250C, r2590, 0x03));


            body.instructions = f251F_parent_instructions;
            body.emit(f251F);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f251D->else_instructions;

            /* IF CONDITION */
            ir_expression *const r25D1 = less(r250D, body.constant(int(0)));
            ir_if *f25D0 = new(mem_ctx) ir_if(operand(r25D1).val);
            exec_list *const f25D0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f25D0->then_instructions;

               /* IF CONDITION */
               ir_expression *const r25D3 = equal(r2514, body.constant(int(0)));
               ir_if *f25D2 = new(mem_ctx) ir_if(operand(r25D3).val);
               exec_list *const f25D2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f25D2->then_instructions;

                  body.emit(assign(r250D, add(r250D, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f25D2->else_instructions;

                  body.emit(assign(r2511, bit_or(swizzle_y(r2511), body.constant(1073741824u)), 0x02));


               body.instructions = f25D2_parent_instructions;
               body.emit(f25D2);

               /* END IF */

               ir_variable *const r25D4 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r25D4, swizzle_y(r2511), 0x01));

               ir_variable *const r25D5 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r25D5, swizzle_x(r2511), 0x01));

               ir_variable *const r25D6 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r25D6, neg(r250D), 0x01));

               ir_variable *const r25D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r25D7);
               ir_variable *const r25D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r25D8);
               ir_variable *const r25D9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r25DA = neg(r25D6);
               body.emit(assign(r25D9, bit_and(r25DA, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r25DC = equal(r25D6, body.constant(int(0)));
               ir_if *f25DB = new(mem_ctx) ir_if(operand(r25DC).val);
               exec_list *const f25DB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f25DB->then_instructions;

                  body.emit(assign(r25D7, r25D5, 0x01));

                  body.emit(assign(r25D8, r25D4, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f25DB->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r25DE = less(r25D6, body.constant(int(32)));
                  ir_if *f25DD = new(mem_ctx) ir_if(operand(r25DE).val);
                  exec_list *const f25DD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f25DD->then_instructions;

                     ir_expression *const r25DF = lshift(swizzle_y(r2511), r25D9);
                     ir_expression *const r25E0 = rshift(r2518, r25D6);
                     ir_expression *const r25E1 = bit_or(r25DF, r25E0);
                     ir_expression *const r25E2 = lshift(r2518, r25D9);
                     ir_expression *const r25E3 = nequal(r25E2, body.constant(0u));
                     ir_expression *const r25E4 = expr(ir_unop_b2i, r25E3);
                     ir_expression *const r25E5 = expr(ir_unop_i2u, r25E4);
                     body.emit(assign(r25D7, bit_or(r25E1, r25E5), 0x01));

                     body.emit(assign(r25D8, rshift(swizzle_y(r2511), r25D6), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f25DD->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r25E7 = equal(r25D6, body.constant(int(32)));
                     ir_if *f25E6 = new(mem_ctx) ir_if(operand(r25E7).val);
                     exec_list *const f25E6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25E6->then_instructions;

                        ir_expression *const r25E8 = nequal(r2518, body.constant(0u));
                        ir_expression *const r25E9 = expr(ir_unop_b2i, r25E8);
                        ir_expression *const r25EA = expr(ir_unop_i2u, r25E9);
                        body.emit(assign(r25D7, bit_or(swizzle_y(r2511), r25EA), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f25E6->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r25EC = less(r25D6, body.constant(int(64)));
                        ir_if *f25EB = new(mem_ctx) ir_if(operand(r25EC).val);
                        exec_list *const f25EB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25EB->then_instructions;

                           ir_expression *const r25ED = bit_and(r25D6, body.constant(int(31)));
                           ir_expression *const r25EE = rshift(swizzle_y(r2511), r25ED);
                           ir_expression *const r25EF = lshift(swizzle_y(r2511), r25D9);
                           ir_expression *const r25F0 = bit_or(r25EF, r2518);
                           ir_expression *const r25F1 = nequal(r25F0, body.constant(0u));
                           ir_expression *const r25F2 = expr(ir_unop_b2i, r25F1);
                           ir_expression *const r25F3 = expr(ir_unop_i2u, r25F2);
                           body.emit(assign(r25D7, bit_or(r25EE, r25F3), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f25EB->else_instructions;

                           ir_expression *const r25F4 = bit_or(swizzle_y(r2511), r2518);
                           ir_expression *const r25F5 = nequal(r25F4, body.constant(0u));
                           ir_expression *const r25F6 = expr(ir_unop_b2i, r25F5);
                           body.emit(assign(r25D7, expr(ir_unop_i2u, r25F6), 0x01));


                        body.instructions = f25EB_parent_instructions;
                        body.emit(f25EB);

                        /* END IF */


                     body.instructions = f25E6_parent_instructions;
                     body.emit(f25E6);

                     /* END IF */

                     body.emit(assign(r25D8, body.constant(0u), 0x01));


                  body.instructions = f25DD_parent_instructions;
                  body.emit(f25DD);

                  /* END IF */


               body.instructions = f25DB_parent_instructions;
               body.emit(f25DB);

               /* END IF */

               body.emit(assign(r2511, r25D8, 0x02));

               body.emit(assign(r2511, r25D7, 0x01));

               body.emit(assign(r250F, bit_or(swizzle_y(r250F), body.constant(1073741824u)), 0x02));

               ir_variable *const r25F7 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r25F8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r25F8, sub(swizzle_x(r250F), r25D7), 0x01));

               ir_expression *const r25F9 = sub(swizzle_y(r250F), r25D8);
               ir_expression *const r25FA = less(swizzle_x(r250F), r25D7);
               ir_expression *const r25FB = expr(ir_unop_b2i, r25FA);
               ir_expression *const r25FC = expr(ir_unop_i2u, r25FB);
               body.emit(assign(r25F7, sub(r25F9, r25FC), 0x01));

               body.emit(assign(r250B, bit_xor(r23AE, body.constant(1u)), 0x01));

               body.emit(assign(r2512, body.constant(int(1022)), 0x01));

               ir_variable *const r25FD = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r25FD, body.constant(int(1012)), 0x01));

               ir_variable *const r25FE = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r25FE, r25F7, 0x01));

               ir_variable *const r25FF = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r25FF, r25F8, 0x01));

               ir_variable *const r2600 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2600);
               ir_variable *const r2601 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2601);
               /* IF CONDITION */
               ir_expression *const r2603 = equal(r25F7, body.constant(0u));
               ir_if *f2602 = new(mem_ctx) ir_if(operand(r2603).val);
               exec_list *const f2602_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2602->then_instructions;

                  body.emit(assign(r25FE, r25F8, 0x01));

                  body.emit(assign(r25FF, body.constant(0u), 0x01));

                  body.emit(assign(r25FD, body.constant(int(980)), 0x01));


               body.instructions = f2602_parent_instructions;
               body.emit(f2602);

               /* END IF */

               ir_variable *const r2604 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2604, r25FE, 0x01));

               ir_variable *const r2605 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2606 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2606);
               /* IF CONDITION */
               ir_expression *const r2608 = equal(r25FE, body.constant(0u));
               ir_if *f2607 = new(mem_ctx) ir_if(operand(r2608).val);
               exec_list *const f2607_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2607->then_instructions;

                  body.emit(assign(r2605, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2607->else_instructions;

                  body.emit(assign(r2606, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r260A = bit_and(r25FE, body.constant(4294901760u));
                  ir_expression *const r260B = equal(r260A, body.constant(0u));
                  ir_if *f2609 = new(mem_ctx) ir_if(operand(r260B).val);
                  exec_list *const f2609_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2609->then_instructions;

                     body.emit(assign(r2606, body.constant(int(16)), 0x01));

                     body.emit(assign(r2604, lshift(r25FE, body.constant(int(16))), 0x01));


                  body.instructions = f2609_parent_instructions;
                  body.emit(f2609);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r260D = bit_and(r2604, body.constant(4278190080u));
                  ir_expression *const r260E = equal(r260D, body.constant(0u));
                  ir_if *f260C = new(mem_ctx) ir_if(operand(r260E).val);
                  exec_list *const f260C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f260C->then_instructions;

                     body.emit(assign(r2606, add(r2606, body.constant(int(8))), 0x01));

                     body.emit(assign(r2604, lshift(r2604, body.constant(int(8))), 0x01));


                  body.instructions = f260C_parent_instructions;
                  body.emit(f260C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2610 = bit_and(r2604, body.constant(4026531840u));
                  ir_expression *const r2611 = equal(r2610, body.constant(0u));
                  ir_if *f260F = new(mem_ctx) ir_if(operand(r2611).val);
                  exec_list *const f260F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f260F->then_instructions;

                     body.emit(assign(r2606, add(r2606, body.constant(int(4))), 0x01));

                     body.emit(assign(r2604, lshift(r2604, body.constant(int(4))), 0x01));


                  body.instructions = f260F_parent_instructions;
                  body.emit(f260F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2613 = bit_and(r2604, body.constant(3221225472u));
                  ir_expression *const r2614 = equal(r2613, body.constant(0u));
                  ir_if *f2612 = new(mem_ctx) ir_if(operand(r2614).val);
                  exec_list *const f2612_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2612->then_instructions;

                     body.emit(assign(r2606, add(r2606, body.constant(int(2))), 0x01));

                     body.emit(assign(r2604, lshift(r2604, body.constant(int(2))), 0x01));


                  body.instructions = f2612_parent_instructions;
                  body.emit(f2612);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2616 = bit_and(r2604, body.constant(2147483648u));
                  ir_expression *const r2617 = equal(r2616, body.constant(0u));
                  ir_if *f2615 = new(mem_ctx) ir_if(operand(r2617).val);
                  exec_list *const f2615_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2615->then_instructions;

                     body.emit(assign(r2606, add(r2606, body.constant(int(1))), 0x01));


                  body.instructions = f2615_parent_instructions;
                  body.emit(f2615);

                  /* END IF */

                  body.emit(assign(r2605, r2606, 0x01));


               body.instructions = f2607_parent_instructions;
               body.emit(f2607);

               /* END IF */

               body.emit(assign(r2601, add(r2605, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2619 = lequal(body.constant(int(0)), r2601);
               ir_if *f2618 = new(mem_ctx) ir_if(operand(r2619).val);
               exec_list *const f2618_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2618->then_instructions;

                  body.emit(assign(r2600, body.constant(0u), 0x01));

                  ir_variable *const r261A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r261A, lshift(r25FF, r2601), 0x01));

                  ir_variable *const r261B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r261D = equal(r2601, body.constant(int(0)));
                  ir_if *f261C = new(mem_ctx) ir_if(operand(r261D).val);
                  exec_list *const f261C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f261C->then_instructions;

                     body.emit(assign(r261B, r25FE, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f261C->else_instructions;

                     ir_expression *const r261E = lshift(r25FE, r2601);
                     ir_expression *const r261F = neg(r2601);
                     ir_expression *const r2620 = bit_and(r261F, body.constant(int(31)));
                     ir_expression *const r2621 = rshift(r25FF, r2620);
                     body.emit(assign(r261B, bit_or(r261E, r2621), 0x01));


                  body.instructions = f261C_parent_instructions;
                  body.emit(f261C);

                  /* END IF */

                  body.emit(assign(r25FE, r261B, 0x01));

                  body.emit(assign(r25FF, r261A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2618->else_instructions;

                  ir_variable *const r2622 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2622, body.constant(0u), 0x01));

                  ir_variable *const r2623 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2623, neg(r2601), 0x01));

                  ir_variable *const r2624 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2624);
                  ir_variable *const r2625 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2625);
                  ir_variable *const r2626 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2626);
                  ir_variable *const r2627 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2628 = neg(r2623);
                  body.emit(assign(r2627, bit_and(r2628, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r262A = equal(r2623, body.constant(int(0)));
                  ir_if *f2629 = new(mem_ctx) ir_if(operand(r262A).val);
                  exec_list *const f2629_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2629->then_instructions;

                     body.emit(assign(r2624, r2622, 0x01));

                     body.emit(assign(r2625, r25FF, 0x01));

                     body.emit(assign(r2626, r25FE, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2629->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r262C = less(r2623, body.constant(int(32)));
                     ir_if *f262B = new(mem_ctx) ir_if(operand(r262C).val);
                     exec_list *const f262B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f262B->then_instructions;

                        body.emit(assign(r2624, lshift(r25FF, r2627), 0x01));

                        ir_expression *const r262D = lshift(r25FE, r2627);
                        ir_expression *const r262E = rshift(r25FF, r2623);
                        body.emit(assign(r2625, bit_or(r262D, r262E), 0x01));

                        body.emit(assign(r2626, rshift(r25FE, r2623), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f262B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2630 = equal(r2623, body.constant(int(32)));
                        ir_if *f262F = new(mem_ctx) ir_if(operand(r2630).val);
                        exec_list *const f262F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f262F->then_instructions;

                           body.emit(assign(r2624, r25FF, 0x01));

                           body.emit(assign(r2625, r25FE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f262F->else_instructions;

                           body.emit(assign(r2622, bit_or(body.constant(0u), r25FF), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2632 = less(r2623, body.constant(int(64)));
                           ir_if *f2631 = new(mem_ctx) ir_if(operand(r2632).val);
                           exec_list *const f2631_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2631->then_instructions;

                              body.emit(assign(r2624, lshift(r25FE, r2627), 0x01));

                              ir_expression *const r2633 = bit_and(r2623, body.constant(int(31)));
                              body.emit(assign(r2625, rshift(r25FE, r2633), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2631->else_instructions;

                              ir_variable *const r2634 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2636 = equal(r2623, body.constant(int(64)));
                              ir_if *f2635 = new(mem_ctx) ir_if(operand(r2636).val);
                              exec_list *const f2635_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2635->then_instructions;

                                 body.emit(assign(r2634, r25FE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2635->else_instructions;

                                 ir_expression *const r2637 = nequal(r25FE, body.constant(0u));
                                 ir_expression *const r2638 = expr(ir_unop_b2i, r2637);
                                 body.emit(assign(r2634, expr(ir_unop_i2u, r2638), 0x01));


                              body.instructions = f2635_parent_instructions;
                              body.emit(f2635);

                              /* END IF */

                              body.emit(assign(r2624, r2634, 0x01));

                              body.emit(assign(r2625, body.constant(0u), 0x01));


                           body.instructions = f2631_parent_instructions;
                           body.emit(f2631);

                           /* END IF */


                        body.instructions = f262F_parent_instructions;
                        body.emit(f262F);

                        /* END IF */

                        body.emit(assign(r2626, body.constant(0u), 0x01));


                     body.instructions = f262B_parent_instructions;
                     body.emit(f262B);

                     /* END IF */

                     ir_expression *const r2639 = nequal(r2622, body.constant(0u));
                     ir_expression *const r263A = expr(ir_unop_b2i, r2639);
                     ir_expression *const r263B = expr(ir_unop_i2u, r263A);
                     body.emit(assign(r2624, bit_or(r2624, r263B), 0x01));


                  body.instructions = f2629_parent_instructions;
                  body.emit(f2629);

                  /* END IF */

                  body.emit(assign(r25FE, r2626, 0x01));

                  body.emit(assign(r25FF, r2625, 0x01));

                  body.emit(assign(r2600, r2624, 0x01));


               body.instructions = f2618_parent_instructions;
               body.emit(f2618);

               /* END IF */

               body.emit(assign(r25FD, sub(r25FD, r2601), 0x01));

               ir_variable *const r263C = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r263C, r25FD, 0x01));

               ir_variable *const r263D = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r263D, r25FE, 0x01));

               ir_variable *const r263E = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r263E, r25FF, 0x01));

               ir_variable *const r263F = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r263F, r2600, 0x01));

               ir_variable *const r2640 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2640, body.constant(true), 0x01));

               ir_variable *const r2641 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2642 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2642);
               ir_expression *const r2643 = expr(ir_unop_u2i, r2600);
               body.emit(assign(r2642, less(r2643, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2645 = lequal(body.constant(int(2045)), r25FD);
               ir_if *f2644 = new(mem_ctx) ir_if(operand(r2645).val);
               exec_list *const f2644_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2644->then_instructions;

                  ir_variable *const r2646 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2648 = less(body.constant(int(2045)), r25FD);
                  ir_if *f2647 = new(mem_ctx) ir_if(operand(r2648).val);
                  exec_list *const f2647_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2647->then_instructions;

                     body.emit(assign(r2646, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2647->else_instructions;

                     ir_variable *const r2649 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r264B = equal(r25FD, body.constant(int(2045)));
                     ir_if *f264A = new(mem_ctx) ir_if(operand(r264B).val);
                     exec_list *const f264A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f264A->then_instructions;

                        ir_expression *const r264C = equal(body.constant(2097151u), r25FE);
                        ir_expression *const r264D = equal(body.constant(4294967295u), r25FF);
                        body.emit(assign(r2649, logic_and(r264C, r264D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f264A->else_instructions;

                        body.emit(assign(r2649, body.constant(false), 0x01));


                     body.instructions = f264A_parent_instructions;
                     body.emit(f264A);

                     /* END IF */

                     body.emit(assign(r2646, logic_and(r2649, r2642), 0x01));


                  body.instructions = f2647_parent_instructions;
                  body.emit(f2647);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f264E = new(mem_ctx) ir_if(operand(r2646).val);
                  exec_list *const f264E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f264E->then_instructions;

                     ir_variable *const r264F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r264F);
                     ir_expression *const r2650 = lshift(r250B, body.constant(int(31)));
                     body.emit(assign(r264F, add(r2650, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r264F, body.constant(0u), 0x01));

                     body.emit(assign(r2641, r264F, 0x03));

                     body.emit(assign(r2640, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f264E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2652 = less(r25FD, body.constant(int(0)));
                     ir_if *f2651 = new(mem_ctx) ir_if(operand(r2652).val);
                     exec_list *const f2651_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2651->then_instructions;

                        ir_variable *const r2653 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2653, r2600, 0x01));

                        ir_variable *const r2654 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2654, neg(r25FD), 0x01));

                        ir_variable *const r2655 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2655);
                        ir_variable *const r2656 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2656);
                        ir_variable *const r2657 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2657);
                        ir_variable *const r2658 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2659 = neg(r2654);
                        body.emit(assign(r2658, bit_and(r2659, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r265B = equal(r2654, body.constant(int(0)));
                        ir_if *f265A = new(mem_ctx) ir_if(operand(r265B).val);
                        exec_list *const f265A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f265A->then_instructions;

                           body.emit(assign(r2655, r2600, 0x01));

                           body.emit(assign(r2656, r25FF, 0x01));

                           body.emit(assign(r2657, r25FE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f265A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r265D = less(r2654, body.constant(int(32)));
                           ir_if *f265C = new(mem_ctx) ir_if(operand(r265D).val);
                           exec_list *const f265C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f265C->then_instructions;

                              body.emit(assign(r2655, lshift(r25FF, r2658), 0x01));

                              ir_expression *const r265E = lshift(r25FE, r2658);
                              ir_expression *const r265F = rshift(r25FF, r2654);
                              body.emit(assign(r2656, bit_or(r265E, r265F), 0x01));

                              body.emit(assign(r2657, rshift(r25FE, r2654), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f265C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2661 = equal(r2654, body.constant(int(32)));
                              ir_if *f2660 = new(mem_ctx) ir_if(operand(r2661).val);
                              exec_list *const f2660_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2660->then_instructions;

                                 body.emit(assign(r2655, r25FF, 0x01));

                                 body.emit(assign(r2656, r25FE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2660->else_instructions;

                                 body.emit(assign(r2653, bit_or(r2600, r25FF), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2663 = less(r2654, body.constant(int(64)));
                                 ir_if *f2662 = new(mem_ctx) ir_if(operand(r2663).val);
                                 exec_list *const f2662_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2662->then_instructions;

                                    body.emit(assign(r2655, lshift(r25FE, r2658), 0x01));

                                    ir_expression *const r2664 = bit_and(r2654, body.constant(int(31)));
                                    body.emit(assign(r2656, rshift(r25FE, r2664), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2662->else_instructions;

                                    ir_variable *const r2665 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2667 = equal(r2654, body.constant(int(64)));
                                    ir_if *f2666 = new(mem_ctx) ir_if(operand(r2667).val);
                                    exec_list *const f2666_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2666->then_instructions;

                                       body.emit(assign(r2665, r25FE, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2666->else_instructions;

                                       ir_expression *const r2668 = nequal(r25FE, body.constant(0u));
                                       ir_expression *const r2669 = expr(ir_unop_b2i, r2668);
                                       body.emit(assign(r2665, expr(ir_unop_i2u, r2669), 0x01));


                                    body.instructions = f2666_parent_instructions;
                                    body.emit(f2666);

                                    /* END IF */

                                    body.emit(assign(r2655, r2665, 0x01));

                                    body.emit(assign(r2656, body.constant(0u), 0x01));


                                 body.instructions = f2662_parent_instructions;
                                 body.emit(f2662);

                                 /* END IF */


                              body.instructions = f2660_parent_instructions;
                              body.emit(f2660);

                              /* END IF */

                              body.emit(assign(r2657, body.constant(0u), 0x01));


                           body.instructions = f265C_parent_instructions;
                           body.emit(f265C);

                           /* END IF */

                           ir_expression *const r266A = nequal(r2653, body.constant(0u));
                           ir_expression *const r266B = expr(ir_unop_b2i, r266A);
                           ir_expression *const r266C = expr(ir_unop_i2u, r266B);
                           body.emit(assign(r2655, bit_or(r2655, r266C), 0x01));


                        body.instructions = f265A_parent_instructions;
                        body.emit(f265A);

                        /* END IF */

                        body.emit(assign(r263D, r2657, 0x01));

                        body.emit(assign(r263E, r2656, 0x01));

                        body.emit(assign(r263F, r2655, 0x01));

                        body.emit(assign(r263C, body.constant(int(0)), 0x01));

                        body.emit(assign(r2642, less(r2655, body.constant(0u)), 0x01));


                     body.instructions = f2651_parent_instructions;
                     body.emit(f2651);

                     /* END IF */


                  body.instructions = f264E_parent_instructions;
                  body.emit(f264E);

                  /* END IF */


               body.instructions = f2644_parent_instructions;
               body.emit(f2644);

               /* END IF */

               /* IF CONDITION */
               ir_if *f266D = new(mem_ctx) ir_if(operand(r2640).val);
               exec_list *const f266D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f266D->then_instructions;

                  /* IF CONDITION */
                  ir_if *f266E = new(mem_ctx) ir_if(operand(r2642).val);
                  exec_list *const f266E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f266E->then_instructions;

                     ir_variable *const r266F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r266F, add(r263E, body.constant(1u)), 0x01));

                     ir_expression *const r2670 = less(r266F, r263E);
                     ir_expression *const r2671 = expr(ir_unop_b2i, r2670);
                     ir_expression *const r2672 = expr(ir_unop_i2u, r2671);
                     body.emit(assign(r263D, add(r263D, r2672), 0x01));

                     ir_expression *const r2673 = equal(r263F, body.constant(0u));
                     ir_expression *const r2674 = expr(ir_unop_b2i, r2673);
                     ir_expression *const r2675 = expr(ir_unop_i2u, r2674);
                     ir_expression *const r2676 = add(r263F, r2675);
                     ir_expression *const r2677 = bit_and(r2676, body.constant(1u));
                     ir_expression *const r2678 = expr(ir_unop_bit_not, r2677);
                     body.emit(assign(r263E, bit_and(r266F, r2678), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f266E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r267A = bit_or(r263D, r263E);
                     ir_expression *const r267B = equal(r267A, body.constant(0u));
                     ir_if *f2679 = new(mem_ctx) ir_if(operand(r267B).val);
                     exec_list *const f2679_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2679->then_instructions;

                        body.emit(assign(r263C, body.constant(int(0)), 0x01));


                     body.instructions = f2679_parent_instructions;
                     body.emit(f2679);

                     /* END IF */


                  body.instructions = f266E_parent_instructions;
                  body.emit(f266E);

                  /* END IF */

                  ir_variable *const r267C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r267C);
                  ir_expression *const r267D = lshift(r250B, body.constant(int(31)));
                  ir_expression *const r267E = expr(ir_unop_i2u, r263C);
                  ir_expression *const r267F = lshift(r267E, body.constant(int(20)));
                  ir_expression *const r2680 = add(r267D, r267F);
                  body.emit(assign(r267C, add(r2680, r263D), 0x02));

                  body.emit(assign(r267C, r263E, 0x01));

                  body.emit(assign(r2641, r267C, 0x03));

                  body.emit(assign(r2640, body.constant(false), 0x01));


               body.instructions = f266D_parent_instructions;
               body.emit(f266D);

               /* END IF */

               body.emit(assign(r250C, r2641, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f25D0->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2682 = equal(r2514, body.constant(int(2047)));
               ir_if *f2681 = new(mem_ctx) ir_if(operand(r2682).val);
               exec_list *const f2681_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2681->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2684 = bit_or(swizzle_y(r2511), swizzle_x(r2511));
                  ir_expression *const r2685 = bit_or(swizzle_y(r250F), swizzle_x(r250F));
                  ir_expression *const r2686 = bit_or(r2684, r2685);
                  ir_expression *const r2687 = nequal(r2686, body.constant(0u));
                  ir_if *f2683 = new(mem_ctx) ir_if(operand(r2687).val);
                  exec_list *const f2683_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2683->then_instructions;

                     ir_variable *const r2688 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2688, swizzle_x(r2379), 0x01));

                     ir_variable *const r2689 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2689, body.constant(0u), 0x01));

                     ir_variable *const r268A = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2688, bit_or(swizzle_y(r2379), body.constant(524288u)), 0x02));

                     body.emit(assign(r2689, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r268C = lshift(swizzle_y(r2379), body.constant(int(1)));
                     ir_expression *const r268D = lequal(body.constant(4292870144u), r268C);
                     ir_expression *const r268E = nequal(swizzle_x(r2379), body.constant(0u));
                     ir_expression *const r268F = bit_and(swizzle_y(r2379), body.constant(1048575u));
                     ir_expression *const r2690 = nequal(r268F, body.constant(0u));
                     ir_expression *const r2691 = logic_or(r268E, r2690);
                     ir_expression *const r2692 = logic_and(r268D, r2691);
                     ir_if *f268B = new(mem_ctx) ir_if(operand(r2692).val);
                     exec_list *const f268B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f268B->then_instructions;

                        body.emit(assign(r268A, r2688, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f268B->else_instructions;

                        body.emit(assign(r268A, r2689, 0x03));


                     body.instructions = f268B_parent_instructions;
                     body.emit(f268B);

                     /* END IF */

                     body.emit(assign(r250C, r268A, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2683->else_instructions;

                     ir_constant_data r2693_data;
                     memset(&r2693_data, 0, sizeof(ir_constant_data));
                     r2693_data.u[0] = 4294967295;
                     r2693_data.u[1] = 4294967295;
                     ir_constant *const r2693 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r2693_data);
                     body.emit(assign(r250C, r2693, 0x03));


                  body.instructions = f2683_parent_instructions;
                  body.emit(f2683);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2681->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2695 = equal(r2514, body.constant(int(0)));
                  ir_if *f2694 = new(mem_ctx) ir_if(operand(r2695).val);
                  exec_list *const f2694_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2694->then_instructions;

                     body.emit(assign(r2510, body.constant(int(1)), 0x01));

                     body.emit(assign(r250E, body.constant(int(1)), 0x01));


                  body.instructions = f2694_parent_instructions;
                  body.emit(f2694);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2697 = less(swizzle_y(r250F), swizzle_y(r2511));
                  ir_if *f2696 = new(mem_ctx) ir_if(operand(r2697).val);
                  exec_list *const f2696_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2696->then_instructions;

                     ir_variable *const r2698 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r2699 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2699, sub(swizzle_x(r2511), swizzle_x(r250F)), 0x01));

                     ir_expression *const r269A = sub(swizzle_y(r2511), swizzle_y(r250F));
                     ir_expression *const r269B = less(swizzle_x(r2511), swizzle_x(r250F));
                     ir_expression *const r269C = expr(ir_unop_b2i, r269B);
                     ir_expression *const r269D = expr(ir_unop_i2u, r269C);
                     body.emit(assign(r2698, sub(r269A, r269D), 0x01));

                     body.emit(assign(r2512, add(r2510, body.constant(int(-1))), 0x01));

                     ir_variable *const r269E = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r269E, add(r2512, body.constant(int(-10))), 0x01));

                     ir_variable *const r269F = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r269F, r2698, 0x01));

                     ir_variable *const r26A0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r26A0, r2699, 0x01));

                     ir_variable *const r26A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r26A1);
                     ir_variable *const r26A2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r26A2);
                     /* IF CONDITION */
                     ir_expression *const r26A4 = equal(r2698, body.constant(0u));
                     ir_if *f26A3 = new(mem_ctx) ir_if(operand(r26A4).val);
                     exec_list *const f26A3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f26A3->then_instructions;

                        body.emit(assign(r269F, r2699, 0x01));

                        body.emit(assign(r26A0, body.constant(0u), 0x01));

                        body.emit(assign(r269E, add(r269E, body.constant(int(-32))), 0x01));


                     body.instructions = f26A3_parent_instructions;
                     body.emit(f26A3);

                     /* END IF */

                     ir_variable *const r26A5 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r26A5, r269F, 0x01));

                     ir_variable *const r26A6 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r26A7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r26A7);
                     /* IF CONDITION */
                     ir_expression *const r26A9 = equal(r269F, body.constant(0u));
                     ir_if *f26A8 = new(mem_ctx) ir_if(operand(r26A9).val);
                     exec_list *const f26A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f26A8->then_instructions;

                        body.emit(assign(r26A6, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f26A8->else_instructions;

                        body.emit(assign(r26A7, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r26AB = bit_and(r269F, body.constant(4294901760u));
                        ir_expression *const r26AC = equal(r26AB, body.constant(0u));
                        ir_if *f26AA = new(mem_ctx) ir_if(operand(r26AC).val);
                        exec_list *const f26AA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26AA->then_instructions;

                           body.emit(assign(r26A7, body.constant(int(16)), 0x01));

                           body.emit(assign(r26A5, lshift(r269F, body.constant(int(16))), 0x01));


                        body.instructions = f26AA_parent_instructions;
                        body.emit(f26AA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r26AE = bit_and(r26A5, body.constant(4278190080u));
                        ir_expression *const r26AF = equal(r26AE, body.constant(0u));
                        ir_if *f26AD = new(mem_ctx) ir_if(operand(r26AF).val);
                        exec_list *const f26AD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26AD->then_instructions;

                           body.emit(assign(r26A7, add(r26A7, body.constant(int(8))), 0x01));

                           body.emit(assign(r26A5, lshift(r26A5, body.constant(int(8))), 0x01));


                        body.instructions = f26AD_parent_instructions;
                        body.emit(f26AD);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r26B1 = bit_and(r26A5, body.constant(4026531840u));
                        ir_expression *const r26B2 = equal(r26B1, body.constant(0u));
                        ir_if *f26B0 = new(mem_ctx) ir_if(operand(r26B2).val);
                        exec_list *const f26B0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26B0->then_instructions;

                           body.emit(assign(r26A7, add(r26A7, body.constant(int(4))), 0x01));

                           body.emit(assign(r26A5, lshift(r26A5, body.constant(int(4))), 0x01));


                        body.instructions = f26B0_parent_instructions;
                        body.emit(f26B0);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r26B4 = bit_and(r26A5, body.constant(3221225472u));
                        ir_expression *const r26B5 = equal(r26B4, body.constant(0u));
                        ir_if *f26B3 = new(mem_ctx) ir_if(operand(r26B5).val);
                        exec_list *const f26B3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26B3->then_instructions;

                           body.emit(assign(r26A7, add(r26A7, body.constant(int(2))), 0x01));

                           body.emit(assign(r26A5, lshift(r26A5, body.constant(int(2))), 0x01));


                        body.instructions = f26B3_parent_instructions;
                        body.emit(f26B3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r26B7 = bit_and(r26A5, body.constant(2147483648u));
                        ir_expression *const r26B8 = equal(r26B7, body.constant(0u));
                        ir_if *f26B6 = new(mem_ctx) ir_if(operand(r26B8).val);
                        exec_list *const f26B6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26B6->then_instructions;

                           body.emit(assign(r26A7, add(r26A7, body.constant(int(1))), 0x01));


                        body.instructions = f26B6_parent_instructions;
                        body.emit(f26B6);

                        /* END IF */

                        body.emit(assign(r26A6, r26A7, 0x01));


                     body.instructions = f26A8_parent_instructions;
                     body.emit(f26A8);

                     /* END IF */

                     body.emit(assign(r26A2, add(r26A6, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r26BA = lequal(body.constant(int(0)), r26A2);
                     ir_if *f26B9 = new(mem_ctx) ir_if(operand(r26BA).val);
                     exec_list *const f26B9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f26B9->then_instructions;

                        body.emit(assign(r26A1, body.constant(0u), 0x01));

                        ir_variable *const r26BB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r26BB, lshift(r26A0, r26A2), 0x01));

                        ir_variable *const r26BC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r26BE = equal(r26A2, body.constant(int(0)));
                        ir_if *f26BD = new(mem_ctx) ir_if(operand(r26BE).val);
                        exec_list *const f26BD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26BD->then_instructions;

                           body.emit(assign(r26BC, r269F, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f26BD->else_instructions;

                           ir_expression *const r26BF = lshift(r269F, r26A2);
                           ir_expression *const r26C0 = neg(r26A2);
                           ir_expression *const r26C1 = bit_and(r26C0, body.constant(int(31)));
                           ir_expression *const r26C2 = rshift(r26A0, r26C1);
                           body.emit(assign(r26BC, bit_or(r26BF, r26C2), 0x01));


                        body.instructions = f26BD_parent_instructions;
                        body.emit(f26BD);

                        /* END IF */

                        body.emit(assign(r269F, r26BC, 0x01));

                        body.emit(assign(r26A0, r26BB, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f26B9->else_instructions;

                        ir_variable *const r26C3 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r26C3, body.constant(0u), 0x01));

                        ir_variable *const r26C4 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r26C4, neg(r26A2), 0x01));

                        ir_variable *const r26C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r26C5);
                        ir_variable *const r26C6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r26C6);
                        ir_variable *const r26C7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r26C7);
                        ir_variable *const r26C8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r26C9 = neg(r26C4);
                        body.emit(assign(r26C8, bit_and(r26C9, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r26CB = equal(r26C4, body.constant(int(0)));
                        ir_if *f26CA = new(mem_ctx) ir_if(operand(r26CB).val);
                        exec_list *const f26CA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26CA->then_instructions;

                           body.emit(assign(r26C5, r26C3, 0x01));

                           body.emit(assign(r26C6, r26A0, 0x01));

                           body.emit(assign(r26C7, r269F, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f26CA->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r26CD = less(r26C4, body.constant(int(32)));
                           ir_if *f26CC = new(mem_ctx) ir_if(operand(r26CD).val);
                           exec_list *const f26CC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f26CC->then_instructions;

                              body.emit(assign(r26C5, lshift(r26A0, r26C8), 0x01));

                              ir_expression *const r26CE = lshift(r269F, r26C8);
                              ir_expression *const r26CF = rshift(r26A0, r26C4);
                              body.emit(assign(r26C6, bit_or(r26CE, r26CF), 0x01));

                              body.emit(assign(r26C7, rshift(r269F, r26C4), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f26CC->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r26D1 = equal(r26C4, body.constant(int(32)));
                              ir_if *f26D0 = new(mem_ctx) ir_if(operand(r26D1).val);
                              exec_list *const f26D0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26D0->then_instructions;

                                 body.emit(assign(r26C5, r26A0, 0x01));

                                 body.emit(assign(r26C6, r269F, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f26D0->else_instructions;

                                 body.emit(assign(r26C3, bit_or(body.constant(0u), r26A0), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r26D3 = less(r26C4, body.constant(int(64)));
                                 ir_if *f26D2 = new(mem_ctx) ir_if(operand(r26D3).val);
                                 exec_list *const f26D2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26D2->then_instructions;

                                    body.emit(assign(r26C5, lshift(r269F, r26C8), 0x01));

                                    ir_expression *const r26D4 = bit_and(r26C4, body.constant(int(31)));
                                    body.emit(assign(r26C6, rshift(r269F, r26D4), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26D2->else_instructions;

                                    ir_variable *const r26D5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r26D7 = equal(r26C4, body.constant(int(64)));
                                    ir_if *f26D6 = new(mem_ctx) ir_if(operand(r26D7).val);
                                    exec_list *const f26D6_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f26D6->then_instructions;

                                       body.emit(assign(r26D5, r269F, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f26D6->else_instructions;

                                       ir_expression *const r26D8 = nequal(r269F, body.constant(0u));
                                       ir_expression *const r26D9 = expr(ir_unop_b2i, r26D8);
                                       body.emit(assign(r26D5, expr(ir_unop_i2u, r26D9), 0x01));


                                    body.instructions = f26D6_parent_instructions;
                                    body.emit(f26D6);

                                    /* END IF */

                                    body.emit(assign(r26C5, r26D5, 0x01));

                                    body.emit(assign(r26C6, body.constant(0u), 0x01));


                                 body.instructions = f26D2_parent_instructions;
                                 body.emit(f26D2);

                                 /* END IF */


                              body.instructions = f26D0_parent_instructions;
                              body.emit(f26D0);

                              /* END IF */

                              body.emit(assign(r26C7, body.constant(0u), 0x01));


                           body.instructions = f26CC_parent_instructions;
                           body.emit(f26CC);

                           /* END IF */

                           ir_expression *const r26DA = nequal(r26C3, body.constant(0u));
                           ir_expression *const r26DB = expr(ir_unop_b2i, r26DA);
                           ir_expression *const r26DC = expr(ir_unop_i2u, r26DB);
                           body.emit(assign(r26C5, bit_or(r26C5, r26DC), 0x01));


                        body.instructions = f26CA_parent_instructions;
                        body.emit(f26CA);

                        /* END IF */

                        body.emit(assign(r269F, r26C7, 0x01));

                        body.emit(assign(r26A0, r26C6, 0x01));

                        body.emit(assign(r26A1, r26C5, 0x01));


                     body.instructions = f26B9_parent_instructions;
                     body.emit(f26B9);

                     /* END IF */

                     body.emit(assign(r269E, sub(r269E, r26A2), 0x01));

                     ir_variable *const r26DD = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r26DD, r269E, 0x01));

                     ir_variable *const r26DE = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r26DE, r269F, 0x01));

                     ir_variable *const r26DF = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r26DF, r26A0, 0x01));

                     ir_variable *const r26E0 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r26E0, r26A1, 0x01));

                     ir_variable *const r26E1 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r26E1, body.constant(true), 0x01));

                     ir_variable *const r26E2 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r26E3 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r26E3);
                     ir_expression *const r26E4 = expr(ir_unop_u2i, r26A1);
                     body.emit(assign(r26E3, less(r26E4, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r26E6 = lequal(body.constant(int(2045)), r269E);
                     ir_if *f26E5 = new(mem_ctx) ir_if(operand(r26E6).val);
                     exec_list *const f26E5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f26E5->then_instructions;

                        ir_variable *const r26E7 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r26E9 = less(body.constant(int(2045)), r269E);
                        ir_if *f26E8 = new(mem_ctx) ir_if(operand(r26E9).val);
                        exec_list *const f26E8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26E8->then_instructions;

                           body.emit(assign(r26E7, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f26E8->else_instructions;

                           ir_variable *const r26EA = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r26EC = equal(r269E, body.constant(int(2045)));
                           ir_if *f26EB = new(mem_ctx) ir_if(operand(r26EC).val);
                           exec_list *const f26EB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f26EB->then_instructions;

                              ir_expression *const r26ED = equal(body.constant(2097151u), r269F);
                              ir_expression *const r26EE = equal(body.constant(4294967295u), r26A0);
                              body.emit(assign(r26EA, logic_and(r26ED, r26EE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f26EB->else_instructions;

                              body.emit(assign(r26EA, body.constant(false), 0x01));


                           body.instructions = f26EB_parent_instructions;
                           body.emit(f26EB);

                           /* END IF */

                           body.emit(assign(r26E7, logic_and(r26EA, r26E3), 0x01));


                        body.instructions = f26E8_parent_instructions;
                        body.emit(f26E8);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f26EF = new(mem_ctx) ir_if(operand(r26E7).val);
                        exec_list *const f26EF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26EF->then_instructions;

                           ir_variable *const r26F0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r26F0);
                           ir_expression *const r26F1 = lshift(r250B, body.constant(int(31)));
                           body.emit(assign(r26F0, add(r26F1, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r26F0, body.constant(0u), 0x01));

                           body.emit(assign(r26E2, r26F0, 0x03));

                           body.emit(assign(r26E1, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f26EF->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r26F3 = less(r269E, body.constant(int(0)));
                           ir_if *f26F2 = new(mem_ctx) ir_if(operand(r26F3).val);
                           exec_list *const f26F2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f26F2->then_instructions;

                              ir_variable *const r26F4 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r26F4, r26A1, 0x01));

                              ir_variable *const r26F5 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r26F5, neg(r269E), 0x01));

                              ir_variable *const r26F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r26F6);
                              ir_variable *const r26F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r26F7);
                              ir_variable *const r26F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r26F8);
                              ir_variable *const r26F9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r26FA = neg(r26F5);
                              body.emit(assign(r26F9, bit_and(r26FA, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r26FC = equal(r26F5, body.constant(int(0)));
                              ir_if *f26FB = new(mem_ctx) ir_if(operand(r26FC).val);
                              exec_list *const f26FB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26FB->then_instructions;

                                 body.emit(assign(r26F6, r26A1, 0x01));

                                 body.emit(assign(r26F7, r26A0, 0x01));

                                 body.emit(assign(r26F8, r269F, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f26FB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r26FE = less(r26F5, body.constant(int(32)));
                                 ir_if *f26FD = new(mem_ctx) ir_if(operand(r26FE).val);
                                 exec_list *const f26FD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26FD->then_instructions;

                                    body.emit(assign(r26F6, lshift(r26A0, r26F9), 0x01));

                                    ir_expression *const r26FF = lshift(r269F, r26F9);
                                    ir_expression *const r2700 = rshift(r26A0, r26F5);
                                    body.emit(assign(r26F7, bit_or(r26FF, r2700), 0x01));

                                    body.emit(assign(r26F8, rshift(r269F, r26F5), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26FD->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2702 = equal(r26F5, body.constant(int(32)));
                                    ir_if *f2701 = new(mem_ctx) ir_if(operand(r2702).val);
                                    exec_list *const f2701_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2701->then_instructions;

                                       body.emit(assign(r26F6, r26A0, 0x01));

                                       body.emit(assign(r26F7, r269F, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2701->else_instructions;

                                       body.emit(assign(r26F4, bit_or(r26A1, r26A0), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2704 = less(r26F5, body.constant(int(64)));
                                       ir_if *f2703 = new(mem_ctx) ir_if(operand(r2704).val);
                                       exec_list *const f2703_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2703->then_instructions;

                                          body.emit(assign(r26F6, lshift(r269F, r26F9), 0x01));

                                          ir_expression *const r2705 = bit_and(r26F5, body.constant(int(31)));
                                          body.emit(assign(r26F7, rshift(r269F, r2705), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2703->else_instructions;

                                          ir_variable *const r2706 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2708 = equal(r26F5, body.constant(int(64)));
                                          ir_if *f2707 = new(mem_ctx) ir_if(operand(r2708).val);
                                          exec_list *const f2707_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2707->then_instructions;

                                             body.emit(assign(r2706, r269F, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2707->else_instructions;

                                             ir_expression *const r2709 = nequal(r269F, body.constant(0u));
                                             ir_expression *const r270A = expr(ir_unop_b2i, r2709);
                                             body.emit(assign(r2706, expr(ir_unop_i2u, r270A), 0x01));


                                          body.instructions = f2707_parent_instructions;
                                          body.emit(f2707);

                                          /* END IF */

                                          body.emit(assign(r26F6, r2706, 0x01));

                                          body.emit(assign(r26F7, body.constant(0u), 0x01));


                                       body.instructions = f2703_parent_instructions;
                                       body.emit(f2703);

                                       /* END IF */


                                    body.instructions = f2701_parent_instructions;
                                    body.emit(f2701);

                                    /* END IF */

                                    body.emit(assign(r26F8, body.constant(0u), 0x01));


                                 body.instructions = f26FD_parent_instructions;
                                 body.emit(f26FD);

                                 /* END IF */

                                 ir_expression *const r270B = nequal(r26F4, body.constant(0u));
                                 ir_expression *const r270C = expr(ir_unop_b2i, r270B);
                                 ir_expression *const r270D = expr(ir_unop_i2u, r270C);
                                 body.emit(assign(r26F6, bit_or(r26F6, r270D), 0x01));


                              body.instructions = f26FB_parent_instructions;
                              body.emit(f26FB);

                              /* END IF */

                              body.emit(assign(r26DE, r26F8, 0x01));

                              body.emit(assign(r26DF, r26F7, 0x01));

                              body.emit(assign(r26E0, r26F6, 0x01));

                              body.emit(assign(r26DD, body.constant(int(0)), 0x01));

                              body.emit(assign(r26E3, less(r26F6, body.constant(0u)), 0x01));


                           body.instructions = f26F2_parent_instructions;
                           body.emit(f26F2);

                           /* END IF */


                        body.instructions = f26EF_parent_instructions;
                        body.emit(f26EF);

                        /* END IF */


                     body.instructions = f26E5_parent_instructions;
                     body.emit(f26E5);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f270E = new(mem_ctx) ir_if(operand(r26E1).val);
                     exec_list *const f270E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f270E->then_instructions;

                        /* IF CONDITION */
                        ir_if *f270F = new(mem_ctx) ir_if(operand(r26E3).val);
                        exec_list *const f270F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f270F->then_instructions;

                           ir_variable *const r2710 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2710, add(r26DF, body.constant(1u)), 0x01));

                           ir_expression *const r2711 = less(r2710, r26DF);
                           ir_expression *const r2712 = expr(ir_unop_b2i, r2711);
                           ir_expression *const r2713 = expr(ir_unop_i2u, r2712);
                           body.emit(assign(r26DE, add(r26DE, r2713), 0x01));

                           ir_expression *const r2714 = equal(r26E0, body.constant(0u));
                           ir_expression *const r2715 = expr(ir_unop_b2i, r2714);
                           ir_expression *const r2716 = expr(ir_unop_i2u, r2715);
                           ir_expression *const r2717 = add(r26E0, r2716);
                           ir_expression *const r2718 = bit_and(r2717, body.constant(1u));
                           ir_expression *const r2719 = expr(ir_unop_bit_not, r2718);
                           body.emit(assign(r26DF, bit_and(r2710, r2719), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f270F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r271B = bit_or(r26DE, r26DF);
                           ir_expression *const r271C = equal(r271B, body.constant(0u));
                           ir_if *f271A = new(mem_ctx) ir_if(operand(r271C).val);
                           exec_list *const f271A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f271A->then_instructions;

                              body.emit(assign(r26DD, body.constant(int(0)), 0x01));


                           body.instructions = f271A_parent_instructions;
                           body.emit(f271A);

                           /* END IF */


                        body.instructions = f270F_parent_instructions;
                        body.emit(f270F);

                        /* END IF */

                        ir_variable *const r271D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r271D);
                        ir_expression *const r271E = lshift(r250B, body.constant(int(31)));
                        ir_expression *const r271F = expr(ir_unop_i2u, r26DD);
                        ir_expression *const r2720 = lshift(r271F, body.constant(int(20)));
                        ir_expression *const r2721 = add(r271E, r2720);
                        body.emit(assign(r271D, add(r2721, r26DE), 0x02));

                        body.emit(assign(r271D, r26DF, 0x01));

                        body.emit(assign(r26E2, r271D, 0x03));

                        body.emit(assign(r26E1, body.constant(false), 0x01));


                     body.instructions = f270E_parent_instructions;
                     body.emit(f270E);

                     /* END IF */

                     body.emit(assign(r250C, r26E2, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2696->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2723 = less(swizzle_y(r2511), swizzle_y(r250F));
                     ir_if *f2722 = new(mem_ctx) ir_if(operand(r2723).val);
                     exec_list *const f2722_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2722->then_instructions;

                        ir_variable *const r2724 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r2725 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2725, sub(swizzle_x(r250F), swizzle_x(r2511)), 0x01));

                        ir_expression *const r2726 = sub(swizzle_y(r250F), swizzle_y(r2511));
                        ir_expression *const r2727 = less(swizzle_x(r250F), swizzle_x(r2511));
                        ir_expression *const r2728 = expr(ir_unop_b2i, r2727);
                        ir_expression *const r2729 = expr(ir_unop_i2u, r2728);
                        body.emit(assign(r2724, sub(r2726, r2729), 0x01));

                        body.emit(assign(r250B, bit_xor(r250B, body.constant(1u)), 0x01));

                        body.emit(assign(r2512, add(r250E, body.constant(int(-1))), 0x01));

                        ir_variable *const r272A = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r272A, add(r2512, body.constant(int(-10))), 0x01));

                        ir_variable *const r272B = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r272B, r2724, 0x01));

                        ir_variable *const r272C = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r272C, r2725, 0x01));

                        ir_variable *const r272D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r272D);
                        ir_variable *const r272E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r272E);
                        /* IF CONDITION */
                        ir_expression *const r2730 = equal(r2724, body.constant(0u));
                        ir_if *f272F = new(mem_ctx) ir_if(operand(r2730).val);
                        exec_list *const f272F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f272F->then_instructions;

                           body.emit(assign(r272B, r2725, 0x01));

                           body.emit(assign(r272C, body.constant(0u), 0x01));

                           body.emit(assign(r272A, add(r272A, body.constant(int(-32))), 0x01));


                        body.instructions = f272F_parent_instructions;
                        body.emit(f272F);

                        /* END IF */

                        ir_variable *const r2731 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2731, r272B, 0x01));

                        ir_variable *const r2732 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r2733 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2733);
                        /* IF CONDITION */
                        ir_expression *const r2735 = equal(r272B, body.constant(0u));
                        ir_if *f2734 = new(mem_ctx) ir_if(operand(r2735).val);
                        exec_list *const f2734_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2734->then_instructions;

                           body.emit(assign(r2732, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2734->else_instructions;

                           body.emit(assign(r2733, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2737 = bit_and(r272B, body.constant(4294901760u));
                           ir_expression *const r2738 = equal(r2737, body.constant(0u));
                           ir_if *f2736 = new(mem_ctx) ir_if(operand(r2738).val);
                           exec_list *const f2736_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2736->then_instructions;

                              body.emit(assign(r2733, body.constant(int(16)), 0x01));

                              body.emit(assign(r2731, lshift(r272B, body.constant(int(16))), 0x01));


                           body.instructions = f2736_parent_instructions;
                           body.emit(f2736);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r273A = bit_and(r2731, body.constant(4278190080u));
                           ir_expression *const r273B = equal(r273A, body.constant(0u));
                           ir_if *f2739 = new(mem_ctx) ir_if(operand(r273B).val);
                           exec_list *const f2739_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2739->then_instructions;

                              body.emit(assign(r2733, add(r2733, body.constant(int(8))), 0x01));

                              body.emit(assign(r2731, lshift(r2731, body.constant(int(8))), 0x01));


                           body.instructions = f2739_parent_instructions;
                           body.emit(f2739);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r273D = bit_and(r2731, body.constant(4026531840u));
                           ir_expression *const r273E = equal(r273D, body.constant(0u));
                           ir_if *f273C = new(mem_ctx) ir_if(operand(r273E).val);
                           exec_list *const f273C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f273C->then_instructions;

                              body.emit(assign(r2733, add(r2733, body.constant(int(4))), 0x01));

                              body.emit(assign(r2731, lshift(r2731, body.constant(int(4))), 0x01));


                           body.instructions = f273C_parent_instructions;
                           body.emit(f273C);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2740 = bit_and(r2731, body.constant(3221225472u));
                           ir_expression *const r2741 = equal(r2740, body.constant(0u));
                           ir_if *f273F = new(mem_ctx) ir_if(operand(r2741).val);
                           exec_list *const f273F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f273F->then_instructions;

                              body.emit(assign(r2733, add(r2733, body.constant(int(2))), 0x01));

                              body.emit(assign(r2731, lshift(r2731, body.constant(int(2))), 0x01));


                           body.instructions = f273F_parent_instructions;
                           body.emit(f273F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2743 = bit_and(r2731, body.constant(2147483648u));
                           ir_expression *const r2744 = equal(r2743, body.constant(0u));
                           ir_if *f2742 = new(mem_ctx) ir_if(operand(r2744).val);
                           exec_list *const f2742_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2742->then_instructions;

                              body.emit(assign(r2733, add(r2733, body.constant(int(1))), 0x01));


                           body.instructions = f2742_parent_instructions;
                           body.emit(f2742);

                           /* END IF */

                           body.emit(assign(r2732, r2733, 0x01));


                        body.instructions = f2734_parent_instructions;
                        body.emit(f2734);

                        /* END IF */

                        body.emit(assign(r272E, add(r2732, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2746 = lequal(body.constant(int(0)), r272E);
                        ir_if *f2745 = new(mem_ctx) ir_if(operand(r2746).val);
                        exec_list *const f2745_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2745->then_instructions;

                           body.emit(assign(r272D, body.constant(0u), 0x01));

                           ir_variable *const r2747 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2747, lshift(r272C, r272E), 0x01));

                           ir_variable *const r2748 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r274A = equal(r272E, body.constant(int(0)));
                           ir_if *f2749 = new(mem_ctx) ir_if(operand(r274A).val);
                           exec_list *const f2749_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2749->then_instructions;

                              body.emit(assign(r2748, r272B, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2749->else_instructions;

                              ir_expression *const r274B = lshift(r272B, r272E);
                              ir_expression *const r274C = neg(r272E);
                              ir_expression *const r274D = bit_and(r274C, body.constant(int(31)));
                              ir_expression *const r274E = rshift(r272C, r274D);
                              body.emit(assign(r2748, bit_or(r274B, r274E), 0x01));


                           body.instructions = f2749_parent_instructions;
                           body.emit(f2749);

                           /* END IF */

                           body.emit(assign(r272B, r2748, 0x01));

                           body.emit(assign(r272C, r2747, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2745->else_instructions;

                           ir_variable *const r274F = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r274F, body.constant(0u), 0x01));

                           ir_variable *const r2750 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2750, neg(r272E), 0x01));

                           ir_variable *const r2751 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2751);
                           ir_variable *const r2752 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2752);
                           ir_variable *const r2753 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2753);
                           ir_variable *const r2754 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2755 = neg(r2750);
                           body.emit(assign(r2754, bit_and(r2755, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2757 = equal(r2750, body.constant(int(0)));
                           ir_if *f2756 = new(mem_ctx) ir_if(operand(r2757).val);
                           exec_list *const f2756_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2756->then_instructions;

                              body.emit(assign(r2751, r274F, 0x01));

                              body.emit(assign(r2752, r272C, 0x01));

                              body.emit(assign(r2753, r272B, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2756->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2759 = less(r2750, body.constant(int(32)));
                              ir_if *f2758 = new(mem_ctx) ir_if(operand(r2759).val);
                              exec_list *const f2758_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2758->then_instructions;

                                 body.emit(assign(r2751, lshift(r272C, r2754), 0x01));

                                 ir_expression *const r275A = lshift(r272B, r2754);
                                 ir_expression *const r275B = rshift(r272C, r2750);
                                 body.emit(assign(r2752, bit_or(r275A, r275B), 0x01));

                                 body.emit(assign(r2753, rshift(r272B, r2750), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2758->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r275D = equal(r2750, body.constant(int(32)));
                                 ir_if *f275C = new(mem_ctx) ir_if(operand(r275D).val);
                                 exec_list *const f275C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f275C->then_instructions;

                                    body.emit(assign(r2751, r272C, 0x01));

                                    body.emit(assign(r2752, r272B, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f275C->else_instructions;

                                    body.emit(assign(r274F, bit_or(body.constant(0u), r272C), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r275F = less(r2750, body.constant(int(64)));
                                    ir_if *f275E = new(mem_ctx) ir_if(operand(r275F).val);
                                    exec_list *const f275E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f275E->then_instructions;

                                       body.emit(assign(r2751, lshift(r272B, r2754), 0x01));

                                       ir_expression *const r2760 = bit_and(r2750, body.constant(int(31)));
                                       body.emit(assign(r2752, rshift(r272B, r2760), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f275E->else_instructions;

                                       ir_variable *const r2761 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2763 = equal(r2750, body.constant(int(64)));
                                       ir_if *f2762 = new(mem_ctx) ir_if(operand(r2763).val);
                                       exec_list *const f2762_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2762->then_instructions;

                                          body.emit(assign(r2761, r272B, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2762->else_instructions;

                                          ir_expression *const r2764 = nequal(r272B, body.constant(0u));
                                          ir_expression *const r2765 = expr(ir_unop_b2i, r2764);
                                          body.emit(assign(r2761, expr(ir_unop_i2u, r2765), 0x01));


                                       body.instructions = f2762_parent_instructions;
                                       body.emit(f2762);

                                       /* END IF */

                                       body.emit(assign(r2751, r2761, 0x01));

                                       body.emit(assign(r2752, body.constant(0u), 0x01));


                                    body.instructions = f275E_parent_instructions;
                                    body.emit(f275E);

                                    /* END IF */


                                 body.instructions = f275C_parent_instructions;
                                 body.emit(f275C);

                                 /* END IF */

                                 body.emit(assign(r2753, body.constant(0u), 0x01));


                              body.instructions = f2758_parent_instructions;
                              body.emit(f2758);

                              /* END IF */

                              ir_expression *const r2766 = nequal(r274F, body.constant(0u));
                              ir_expression *const r2767 = expr(ir_unop_b2i, r2766);
                              ir_expression *const r2768 = expr(ir_unop_i2u, r2767);
                              body.emit(assign(r2751, bit_or(r2751, r2768), 0x01));


                           body.instructions = f2756_parent_instructions;
                           body.emit(f2756);

                           /* END IF */

                           body.emit(assign(r272B, r2753, 0x01));

                           body.emit(assign(r272C, r2752, 0x01));

                           body.emit(assign(r272D, r2751, 0x01));


                        body.instructions = f2745_parent_instructions;
                        body.emit(f2745);

                        /* END IF */

                        body.emit(assign(r272A, sub(r272A, r272E), 0x01));

                        ir_variable *const r2769 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2769, r272A, 0x01));

                        ir_variable *const r276A = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r276A, r272B, 0x01));

                        ir_variable *const r276B = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r276B, r272C, 0x01));

                        ir_variable *const r276C = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r276C, r272D, 0x01));

                        ir_variable *const r276D = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r276D, body.constant(true), 0x01));

                        ir_variable *const r276E = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r276F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r276F);
                        ir_expression *const r2770 = expr(ir_unop_u2i, r272D);
                        body.emit(assign(r276F, less(r2770, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2772 = lequal(body.constant(int(2045)), r272A);
                        ir_if *f2771 = new(mem_ctx) ir_if(operand(r2772).val);
                        exec_list *const f2771_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2771->then_instructions;

                           ir_variable *const r2773 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2775 = less(body.constant(int(2045)), r272A);
                           ir_if *f2774 = new(mem_ctx) ir_if(operand(r2775).val);
                           exec_list *const f2774_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2774->then_instructions;

                              body.emit(assign(r2773, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2774->else_instructions;

                              ir_variable *const r2776 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2778 = equal(r272A, body.constant(int(2045)));
                              ir_if *f2777 = new(mem_ctx) ir_if(operand(r2778).val);
                              exec_list *const f2777_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2777->then_instructions;

                                 ir_expression *const r2779 = equal(body.constant(2097151u), r272B);
                                 ir_expression *const r277A = equal(body.constant(4294967295u), r272C);
                                 body.emit(assign(r2776, logic_and(r2779, r277A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2777->else_instructions;

                                 body.emit(assign(r2776, body.constant(false), 0x01));


                              body.instructions = f2777_parent_instructions;
                              body.emit(f2777);

                              /* END IF */

                              body.emit(assign(r2773, logic_and(r2776, r276F), 0x01));


                           body.instructions = f2774_parent_instructions;
                           body.emit(f2774);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f277B = new(mem_ctx) ir_if(operand(r2773).val);
                           exec_list *const f277B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f277B->then_instructions;

                              ir_variable *const r277C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r277C);
                              ir_expression *const r277D = lshift(r250B, body.constant(int(31)));
                              body.emit(assign(r277C, add(r277D, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r277C, body.constant(0u), 0x01));

                              body.emit(assign(r276E, r277C, 0x03));

                              body.emit(assign(r276D, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f277B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r277F = less(r272A, body.constant(int(0)));
                              ir_if *f277E = new(mem_ctx) ir_if(operand(r277F).val);
                              exec_list *const f277E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f277E->then_instructions;

                                 ir_variable *const r2780 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2780, r272D, 0x01));

                                 ir_variable *const r2781 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2781, neg(r272A), 0x01));

                                 ir_variable *const r2782 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2782);
                                 ir_variable *const r2783 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2783);
                                 ir_variable *const r2784 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2784);
                                 ir_variable *const r2785 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2786 = neg(r2781);
                                 body.emit(assign(r2785, bit_and(r2786, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2788 = equal(r2781, body.constant(int(0)));
                                 ir_if *f2787 = new(mem_ctx) ir_if(operand(r2788).val);
                                 exec_list *const f2787_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2787->then_instructions;

                                    body.emit(assign(r2782, r272D, 0x01));

                                    body.emit(assign(r2783, r272C, 0x01));

                                    body.emit(assign(r2784, r272B, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2787->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r278A = less(r2781, body.constant(int(32)));
                                    ir_if *f2789 = new(mem_ctx) ir_if(operand(r278A).val);
                                    exec_list *const f2789_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2789->then_instructions;

                                       body.emit(assign(r2782, lshift(r272C, r2785), 0x01));

                                       ir_expression *const r278B = lshift(r272B, r2785);
                                       ir_expression *const r278C = rshift(r272C, r2781);
                                       body.emit(assign(r2783, bit_or(r278B, r278C), 0x01));

                                       body.emit(assign(r2784, rshift(r272B, r2781), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2789->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r278E = equal(r2781, body.constant(int(32)));
                                       ir_if *f278D = new(mem_ctx) ir_if(operand(r278E).val);
                                       exec_list *const f278D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f278D->then_instructions;

                                          body.emit(assign(r2782, r272C, 0x01));

                                          body.emit(assign(r2783, r272B, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f278D->else_instructions;

                                          body.emit(assign(r2780, bit_or(r272D, r272C), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2790 = less(r2781, body.constant(int(64)));
                                          ir_if *f278F = new(mem_ctx) ir_if(operand(r2790).val);
                                          exec_list *const f278F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f278F->then_instructions;

                                             body.emit(assign(r2782, lshift(r272B, r2785), 0x01));

                                             ir_expression *const r2791 = bit_and(r2781, body.constant(int(31)));
                                             body.emit(assign(r2783, rshift(r272B, r2791), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f278F->else_instructions;

                                             ir_variable *const r2792 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2794 = equal(r2781, body.constant(int(64)));
                                             ir_if *f2793 = new(mem_ctx) ir_if(operand(r2794).val);
                                             exec_list *const f2793_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2793->then_instructions;

                                                body.emit(assign(r2792, r272B, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2793->else_instructions;

                                                ir_expression *const r2795 = nequal(r272B, body.constant(0u));
                                                ir_expression *const r2796 = expr(ir_unop_b2i, r2795);
                                                body.emit(assign(r2792, expr(ir_unop_i2u, r2796), 0x01));


                                             body.instructions = f2793_parent_instructions;
                                             body.emit(f2793);

                                             /* END IF */

                                             body.emit(assign(r2782, r2792, 0x01));

                                             body.emit(assign(r2783, body.constant(0u), 0x01));


                                          body.instructions = f278F_parent_instructions;
                                          body.emit(f278F);

                                          /* END IF */


                                       body.instructions = f278D_parent_instructions;
                                       body.emit(f278D);

                                       /* END IF */

                                       body.emit(assign(r2784, body.constant(0u), 0x01));


                                    body.instructions = f2789_parent_instructions;
                                    body.emit(f2789);

                                    /* END IF */

                                    ir_expression *const r2797 = nequal(r2780, body.constant(0u));
                                    ir_expression *const r2798 = expr(ir_unop_b2i, r2797);
                                    ir_expression *const r2799 = expr(ir_unop_i2u, r2798);
                                    body.emit(assign(r2782, bit_or(r2782, r2799), 0x01));


                                 body.instructions = f2787_parent_instructions;
                                 body.emit(f2787);

                                 /* END IF */

                                 body.emit(assign(r276A, r2784, 0x01));

                                 body.emit(assign(r276B, r2783, 0x01));

                                 body.emit(assign(r276C, r2782, 0x01));

                                 body.emit(assign(r2769, body.constant(int(0)), 0x01));

                                 body.emit(assign(r276F, less(r2782, body.constant(0u)), 0x01));


                              body.instructions = f277E_parent_instructions;
                              body.emit(f277E);

                              /* END IF */


                           body.instructions = f277B_parent_instructions;
                           body.emit(f277B);

                           /* END IF */


                        body.instructions = f2771_parent_instructions;
                        body.emit(f2771);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f279A = new(mem_ctx) ir_if(operand(r276D).val);
                        exec_list *const f279A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f279A->then_instructions;

                           /* IF CONDITION */
                           ir_if *f279B = new(mem_ctx) ir_if(operand(r276F).val);
                           exec_list *const f279B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f279B->then_instructions;

                              ir_variable *const r279C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r279C, add(r276B, body.constant(1u)), 0x01));

                              ir_expression *const r279D = less(r279C, r276B);
                              ir_expression *const r279E = expr(ir_unop_b2i, r279D);
                              ir_expression *const r279F = expr(ir_unop_i2u, r279E);
                              body.emit(assign(r276A, add(r276A, r279F), 0x01));

                              ir_expression *const r27A0 = equal(r276C, body.constant(0u));
                              ir_expression *const r27A1 = expr(ir_unop_b2i, r27A0);
                              ir_expression *const r27A2 = expr(ir_unop_i2u, r27A1);
                              ir_expression *const r27A3 = add(r276C, r27A2);
                              ir_expression *const r27A4 = bit_and(r27A3, body.constant(1u));
                              ir_expression *const r27A5 = expr(ir_unop_bit_not, r27A4);
                              body.emit(assign(r276B, bit_and(r279C, r27A5), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f279B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r27A7 = bit_or(r276A, r276B);
                              ir_expression *const r27A8 = equal(r27A7, body.constant(0u));
                              ir_if *f27A6 = new(mem_ctx) ir_if(operand(r27A8).val);
                              exec_list *const f27A6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27A6->then_instructions;

                                 body.emit(assign(r2769, body.constant(int(0)), 0x01));


                              body.instructions = f27A6_parent_instructions;
                              body.emit(f27A6);

                              /* END IF */


                           body.instructions = f279B_parent_instructions;
                           body.emit(f279B);

                           /* END IF */

                           ir_variable *const r27A9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r27A9);
                           ir_expression *const r27AA = lshift(r250B, body.constant(int(31)));
                           ir_expression *const r27AB = expr(ir_unop_i2u, r2769);
                           ir_expression *const r27AC = lshift(r27AB, body.constant(int(20)));
                           ir_expression *const r27AD = add(r27AA, r27AC);
                           body.emit(assign(r27A9, add(r27AD, r276A), 0x02));

                           body.emit(assign(r27A9, r276B, 0x01));

                           body.emit(assign(r276E, r27A9, 0x03));

                           body.emit(assign(r276D, body.constant(false), 0x01));


                        body.instructions = f279A_parent_instructions;
                        body.emit(f279A);

                        /* END IF */

                        body.emit(assign(r250C, r276E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2722->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r27AF = less(swizzle_x(r250F), swizzle_x(r2511));
                        ir_if *f27AE = new(mem_ctx) ir_if(operand(r27AF).val);
                        exec_list *const f27AE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f27AE->then_instructions;

                           ir_variable *const r27B0 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r27B1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r27B1, sub(swizzle_x(r2511), swizzle_x(r250F)), 0x01));

                           ir_expression *const r27B2 = sub(swizzle_y(r2511), swizzle_y(r250F));
                           ir_expression *const r27B3 = less(swizzle_x(r2511), swizzle_x(r250F));
                           ir_expression *const r27B4 = expr(ir_unop_b2i, r27B3);
                           ir_expression *const r27B5 = expr(ir_unop_i2u, r27B4);
                           body.emit(assign(r27B0, sub(r27B2, r27B5), 0x01));

                           body.emit(assign(r2512, add(r2510, body.constant(int(-1))), 0x01));

                           ir_variable *const r27B6 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r27B6, add(r2512, body.constant(int(-10))), 0x01));

                           ir_variable *const r27B7 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r27B7, r27B0, 0x01));

                           ir_variable *const r27B8 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r27B8, r27B1, 0x01));

                           ir_variable *const r27B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r27B9);
                           ir_variable *const r27BA = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r27BA);
                           /* IF CONDITION */
                           ir_expression *const r27BC = equal(r27B0, body.constant(0u));
                           ir_if *f27BB = new(mem_ctx) ir_if(operand(r27BC).val);
                           exec_list *const f27BB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f27BB->then_instructions;

                              body.emit(assign(r27B7, r27B1, 0x01));

                              body.emit(assign(r27B8, body.constant(0u), 0x01));

                              body.emit(assign(r27B6, add(r27B6, body.constant(int(-32))), 0x01));


                           body.instructions = f27BB_parent_instructions;
                           body.emit(f27BB);

                           /* END IF */

                           ir_variable *const r27BD = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r27BD, r27B7, 0x01));

                           ir_variable *const r27BE = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r27BF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r27BF);
                           /* IF CONDITION */
                           ir_expression *const r27C1 = equal(r27B7, body.constant(0u));
                           ir_if *f27C0 = new(mem_ctx) ir_if(operand(r27C1).val);
                           exec_list *const f27C0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f27C0->then_instructions;

                              body.emit(assign(r27BE, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f27C0->else_instructions;

                              body.emit(assign(r27BF, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r27C3 = bit_and(r27B7, body.constant(4294901760u));
                              ir_expression *const r27C4 = equal(r27C3, body.constant(0u));
                              ir_if *f27C2 = new(mem_ctx) ir_if(operand(r27C4).val);
                              exec_list *const f27C2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27C2->then_instructions;

                                 body.emit(assign(r27BF, body.constant(int(16)), 0x01));

                                 body.emit(assign(r27BD, lshift(r27B7, body.constant(int(16))), 0x01));


                              body.instructions = f27C2_parent_instructions;
                              body.emit(f27C2);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r27C6 = bit_and(r27BD, body.constant(4278190080u));
                              ir_expression *const r27C7 = equal(r27C6, body.constant(0u));
                              ir_if *f27C5 = new(mem_ctx) ir_if(operand(r27C7).val);
                              exec_list *const f27C5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27C5->then_instructions;

                                 body.emit(assign(r27BF, add(r27BF, body.constant(int(8))), 0x01));

                                 body.emit(assign(r27BD, lshift(r27BD, body.constant(int(8))), 0x01));


                              body.instructions = f27C5_parent_instructions;
                              body.emit(f27C5);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r27C9 = bit_and(r27BD, body.constant(4026531840u));
                              ir_expression *const r27CA = equal(r27C9, body.constant(0u));
                              ir_if *f27C8 = new(mem_ctx) ir_if(operand(r27CA).val);
                              exec_list *const f27C8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27C8->then_instructions;

                                 body.emit(assign(r27BF, add(r27BF, body.constant(int(4))), 0x01));

                                 body.emit(assign(r27BD, lshift(r27BD, body.constant(int(4))), 0x01));


                              body.instructions = f27C8_parent_instructions;
                              body.emit(f27C8);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r27CC = bit_and(r27BD, body.constant(3221225472u));
                              ir_expression *const r27CD = equal(r27CC, body.constant(0u));
                              ir_if *f27CB = new(mem_ctx) ir_if(operand(r27CD).val);
                              exec_list *const f27CB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27CB->then_instructions;

                                 body.emit(assign(r27BF, add(r27BF, body.constant(int(2))), 0x01));

                                 body.emit(assign(r27BD, lshift(r27BD, body.constant(int(2))), 0x01));


                              body.instructions = f27CB_parent_instructions;
                              body.emit(f27CB);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r27CF = bit_and(r27BD, body.constant(2147483648u));
                              ir_expression *const r27D0 = equal(r27CF, body.constant(0u));
                              ir_if *f27CE = new(mem_ctx) ir_if(operand(r27D0).val);
                              exec_list *const f27CE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27CE->then_instructions;

                                 body.emit(assign(r27BF, add(r27BF, body.constant(int(1))), 0x01));


                              body.instructions = f27CE_parent_instructions;
                              body.emit(f27CE);

                              /* END IF */

                              body.emit(assign(r27BE, r27BF, 0x01));


                           body.instructions = f27C0_parent_instructions;
                           body.emit(f27C0);

                           /* END IF */

                           body.emit(assign(r27BA, add(r27BE, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r27D2 = lequal(body.constant(int(0)), r27BA);
                           ir_if *f27D1 = new(mem_ctx) ir_if(operand(r27D2).val);
                           exec_list *const f27D1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f27D1->then_instructions;

                              body.emit(assign(r27B9, body.constant(0u), 0x01));

                              ir_variable *const r27D3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r27D3, lshift(r27B8, r27BA), 0x01));

                              ir_variable *const r27D4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r27D6 = equal(r27BA, body.constant(int(0)));
                              ir_if *f27D5 = new(mem_ctx) ir_if(operand(r27D6).val);
                              exec_list *const f27D5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27D5->then_instructions;

                                 body.emit(assign(r27D4, r27B7, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f27D5->else_instructions;

                                 ir_expression *const r27D7 = lshift(r27B7, r27BA);
                                 ir_expression *const r27D8 = neg(r27BA);
                                 ir_expression *const r27D9 = bit_and(r27D8, body.constant(int(31)));
                                 ir_expression *const r27DA = rshift(r27B8, r27D9);
                                 body.emit(assign(r27D4, bit_or(r27D7, r27DA), 0x01));


                              body.instructions = f27D5_parent_instructions;
                              body.emit(f27D5);

                              /* END IF */

                              body.emit(assign(r27B7, r27D4, 0x01));

                              body.emit(assign(r27B8, r27D3, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f27D1->else_instructions;

                              ir_variable *const r27DB = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r27DB, body.constant(0u), 0x01));

                              ir_variable *const r27DC = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r27DC, neg(r27BA), 0x01));

                              ir_variable *const r27DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r27DD);
                              ir_variable *const r27DE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r27DE);
                              ir_variable *const r27DF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r27DF);
                              ir_variable *const r27E0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r27E1 = neg(r27DC);
                              body.emit(assign(r27E0, bit_and(r27E1, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r27E3 = equal(r27DC, body.constant(int(0)));
                              ir_if *f27E2 = new(mem_ctx) ir_if(operand(r27E3).val);
                              exec_list *const f27E2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27E2->then_instructions;

                                 body.emit(assign(r27DD, r27DB, 0x01));

                                 body.emit(assign(r27DE, r27B8, 0x01));

                                 body.emit(assign(r27DF, r27B7, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f27E2->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r27E5 = less(r27DC, body.constant(int(32)));
                                 ir_if *f27E4 = new(mem_ctx) ir_if(operand(r27E5).val);
                                 exec_list *const f27E4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f27E4->then_instructions;

                                    body.emit(assign(r27DD, lshift(r27B8, r27E0), 0x01));

                                    ir_expression *const r27E6 = lshift(r27B7, r27E0);
                                    ir_expression *const r27E7 = rshift(r27B8, r27DC);
                                    body.emit(assign(r27DE, bit_or(r27E6, r27E7), 0x01));

                                    body.emit(assign(r27DF, rshift(r27B7, r27DC), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f27E4->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r27E9 = equal(r27DC, body.constant(int(32)));
                                    ir_if *f27E8 = new(mem_ctx) ir_if(operand(r27E9).val);
                                    exec_list *const f27E8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f27E8->then_instructions;

                                       body.emit(assign(r27DD, r27B8, 0x01));

                                       body.emit(assign(r27DE, r27B7, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f27E8->else_instructions;

                                       body.emit(assign(r27DB, bit_or(body.constant(0u), r27B8), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r27EB = less(r27DC, body.constant(int(64)));
                                       ir_if *f27EA = new(mem_ctx) ir_if(operand(r27EB).val);
                                       exec_list *const f27EA_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f27EA->then_instructions;

                                          body.emit(assign(r27DD, lshift(r27B7, r27E0), 0x01));

                                          ir_expression *const r27EC = bit_and(r27DC, body.constant(int(31)));
                                          body.emit(assign(r27DE, rshift(r27B7, r27EC), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f27EA->else_instructions;

                                          ir_variable *const r27ED = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r27EF = equal(r27DC, body.constant(int(64)));
                                          ir_if *f27EE = new(mem_ctx) ir_if(operand(r27EF).val);
                                          exec_list *const f27EE_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f27EE->then_instructions;

                                             body.emit(assign(r27ED, r27B7, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f27EE->else_instructions;

                                             ir_expression *const r27F0 = nequal(r27B7, body.constant(0u));
                                             ir_expression *const r27F1 = expr(ir_unop_b2i, r27F0);
                                             body.emit(assign(r27ED, expr(ir_unop_i2u, r27F1), 0x01));


                                          body.instructions = f27EE_parent_instructions;
                                          body.emit(f27EE);

                                          /* END IF */

                                          body.emit(assign(r27DD, r27ED, 0x01));

                                          body.emit(assign(r27DE, body.constant(0u), 0x01));


                                       body.instructions = f27EA_parent_instructions;
                                       body.emit(f27EA);

                                       /* END IF */


                                    body.instructions = f27E8_parent_instructions;
                                    body.emit(f27E8);

                                    /* END IF */

                                    body.emit(assign(r27DF, body.constant(0u), 0x01));


                                 body.instructions = f27E4_parent_instructions;
                                 body.emit(f27E4);

                                 /* END IF */

                                 ir_expression *const r27F2 = nequal(r27DB, body.constant(0u));
                                 ir_expression *const r27F3 = expr(ir_unop_b2i, r27F2);
                                 ir_expression *const r27F4 = expr(ir_unop_i2u, r27F3);
                                 body.emit(assign(r27DD, bit_or(r27DD, r27F4), 0x01));


                              body.instructions = f27E2_parent_instructions;
                              body.emit(f27E2);

                              /* END IF */

                              body.emit(assign(r27B7, r27DF, 0x01));

                              body.emit(assign(r27B8, r27DE, 0x01));

                              body.emit(assign(r27B9, r27DD, 0x01));


                           body.instructions = f27D1_parent_instructions;
                           body.emit(f27D1);

                           /* END IF */

                           body.emit(assign(r27B6, sub(r27B6, r27BA), 0x01));

                           ir_variable *const r27F5 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r27F5, r27B6, 0x01));

                           ir_variable *const r27F6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r27F6, r27B7, 0x01));

                           ir_variable *const r27F7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r27F7, r27B8, 0x01));

                           ir_variable *const r27F8 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r27F8, r27B9, 0x01));

                           ir_variable *const r27F9 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r27F9, body.constant(true), 0x01));

                           ir_variable *const r27FA = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r27FB = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r27FB);
                           ir_expression *const r27FC = expr(ir_unop_u2i, r27B9);
                           body.emit(assign(r27FB, less(r27FC, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r27FE = lequal(body.constant(int(2045)), r27B6);
                           ir_if *f27FD = new(mem_ctx) ir_if(operand(r27FE).val);
                           exec_list *const f27FD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f27FD->then_instructions;

                              ir_variable *const r27FF = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2801 = less(body.constant(int(2045)), r27B6);
                              ir_if *f2800 = new(mem_ctx) ir_if(operand(r2801).val);
                              exec_list *const f2800_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2800->then_instructions;

                                 body.emit(assign(r27FF, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2800->else_instructions;

                                 ir_variable *const r2802 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2804 = equal(r27B6, body.constant(int(2045)));
                                 ir_if *f2803 = new(mem_ctx) ir_if(operand(r2804).val);
                                 exec_list *const f2803_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2803->then_instructions;

                                    ir_expression *const r2805 = equal(body.constant(2097151u), r27B7);
                                    ir_expression *const r2806 = equal(body.constant(4294967295u), r27B8);
                                    body.emit(assign(r2802, logic_and(r2805, r2806), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2803->else_instructions;

                                    body.emit(assign(r2802, body.constant(false), 0x01));


                                 body.instructions = f2803_parent_instructions;
                                 body.emit(f2803);

                                 /* END IF */

                                 body.emit(assign(r27FF, logic_and(r2802, r27FB), 0x01));


                              body.instructions = f2800_parent_instructions;
                              body.emit(f2800);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2807 = new(mem_ctx) ir_if(operand(r27FF).val);
                              exec_list *const f2807_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2807->then_instructions;

                                 ir_variable *const r2808 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2808);
                                 ir_expression *const r2809 = lshift(r250B, body.constant(int(31)));
                                 body.emit(assign(r2808, add(r2809, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r2808, body.constant(0u), 0x01));

                                 body.emit(assign(r27FA, r2808, 0x03));

                                 body.emit(assign(r27F9, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2807->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r280B = less(r27B6, body.constant(int(0)));
                                 ir_if *f280A = new(mem_ctx) ir_if(operand(r280B).val);
                                 exec_list *const f280A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f280A->then_instructions;

                                    ir_variable *const r280C = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r280C, r27B9, 0x01));

                                    ir_variable *const r280D = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r280D, neg(r27B6), 0x01));

                                    ir_variable *const r280E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r280E);
                                    ir_variable *const r280F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r280F);
                                    ir_variable *const r2810 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2810);
                                    ir_variable *const r2811 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2812 = neg(r280D);
                                    body.emit(assign(r2811, bit_and(r2812, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2814 = equal(r280D, body.constant(int(0)));
                                    ir_if *f2813 = new(mem_ctx) ir_if(operand(r2814).val);
                                    exec_list *const f2813_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2813->then_instructions;

                                       body.emit(assign(r280E, r27B9, 0x01));

                                       body.emit(assign(r280F, r27B8, 0x01));

                                       body.emit(assign(r2810, r27B7, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2813->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2816 = less(r280D, body.constant(int(32)));
                                       ir_if *f2815 = new(mem_ctx) ir_if(operand(r2816).val);
                                       exec_list *const f2815_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2815->then_instructions;

                                          body.emit(assign(r280E, lshift(r27B8, r2811), 0x01));

                                          ir_expression *const r2817 = lshift(r27B7, r2811);
                                          ir_expression *const r2818 = rshift(r27B8, r280D);
                                          body.emit(assign(r280F, bit_or(r2817, r2818), 0x01));

                                          body.emit(assign(r2810, rshift(r27B7, r280D), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2815->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r281A = equal(r280D, body.constant(int(32)));
                                          ir_if *f2819 = new(mem_ctx) ir_if(operand(r281A).val);
                                          exec_list *const f2819_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2819->then_instructions;

                                             body.emit(assign(r280E, r27B8, 0x01));

                                             body.emit(assign(r280F, r27B7, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2819->else_instructions;

                                             body.emit(assign(r280C, bit_or(r27B9, r27B8), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r281C = less(r280D, body.constant(int(64)));
                                             ir_if *f281B = new(mem_ctx) ir_if(operand(r281C).val);
                                             exec_list *const f281B_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f281B->then_instructions;

                                                body.emit(assign(r280E, lshift(r27B7, r2811), 0x01));

                                                ir_expression *const r281D = bit_and(r280D, body.constant(int(31)));
                                                body.emit(assign(r280F, rshift(r27B7, r281D), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f281B->else_instructions;

                                                ir_variable *const r281E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2820 = equal(r280D, body.constant(int(64)));
                                                ir_if *f281F = new(mem_ctx) ir_if(operand(r2820).val);
                                                exec_list *const f281F_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f281F->then_instructions;

                                                   body.emit(assign(r281E, r27B7, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f281F->else_instructions;

                                                   ir_expression *const r2821 = nequal(r27B7, body.constant(0u));
                                                   ir_expression *const r2822 = expr(ir_unop_b2i, r2821);
                                                   body.emit(assign(r281E, expr(ir_unop_i2u, r2822), 0x01));


                                                body.instructions = f281F_parent_instructions;
                                                body.emit(f281F);

                                                /* END IF */

                                                body.emit(assign(r280E, r281E, 0x01));

                                                body.emit(assign(r280F, body.constant(0u), 0x01));


                                             body.instructions = f281B_parent_instructions;
                                             body.emit(f281B);

                                             /* END IF */


                                          body.instructions = f2819_parent_instructions;
                                          body.emit(f2819);

                                          /* END IF */

                                          body.emit(assign(r2810, body.constant(0u), 0x01));


                                       body.instructions = f2815_parent_instructions;
                                       body.emit(f2815);

                                       /* END IF */

                                       ir_expression *const r2823 = nequal(r280C, body.constant(0u));
                                       ir_expression *const r2824 = expr(ir_unop_b2i, r2823);
                                       ir_expression *const r2825 = expr(ir_unop_i2u, r2824);
                                       body.emit(assign(r280E, bit_or(r280E, r2825), 0x01));


                                    body.instructions = f2813_parent_instructions;
                                    body.emit(f2813);

                                    /* END IF */

                                    body.emit(assign(r27F6, r2810, 0x01));

                                    body.emit(assign(r27F7, r280F, 0x01));

                                    body.emit(assign(r27F8, r280E, 0x01));

                                    body.emit(assign(r27F5, body.constant(int(0)), 0x01));

                                    body.emit(assign(r27FB, less(r280E, body.constant(0u)), 0x01));


                                 body.instructions = f280A_parent_instructions;
                                 body.emit(f280A);

                                 /* END IF */


                              body.instructions = f2807_parent_instructions;
                              body.emit(f2807);

                              /* END IF */


                           body.instructions = f27FD_parent_instructions;
                           body.emit(f27FD);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2826 = new(mem_ctx) ir_if(operand(r27F9).val);
                           exec_list *const f2826_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2826->then_instructions;

                              /* IF CONDITION */
                              ir_if *f2827 = new(mem_ctx) ir_if(operand(r27FB).val);
                              exec_list *const f2827_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2827->then_instructions;

                                 ir_variable *const r2828 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r2828, add(r27F7, body.constant(1u)), 0x01));

                                 ir_expression *const r2829 = less(r2828, r27F7);
                                 ir_expression *const r282A = expr(ir_unop_b2i, r2829);
                                 ir_expression *const r282B = expr(ir_unop_i2u, r282A);
                                 body.emit(assign(r27F6, add(r27F6, r282B), 0x01));

                                 ir_expression *const r282C = equal(r27F8, body.constant(0u));
                                 ir_expression *const r282D = expr(ir_unop_b2i, r282C);
                                 ir_expression *const r282E = expr(ir_unop_i2u, r282D);
                                 ir_expression *const r282F = add(r27F8, r282E);
                                 ir_expression *const r2830 = bit_and(r282F, body.constant(1u));
                                 ir_expression *const r2831 = expr(ir_unop_bit_not, r2830);
                                 body.emit(assign(r27F7, bit_and(r2828, r2831), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2827->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2833 = bit_or(r27F6, r27F7);
                                 ir_expression *const r2834 = equal(r2833, body.constant(0u));
                                 ir_if *f2832 = new(mem_ctx) ir_if(operand(r2834).val);
                                 exec_list *const f2832_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2832->then_instructions;

                                    body.emit(assign(r27F5, body.constant(int(0)), 0x01));


                                 body.instructions = f2832_parent_instructions;
                                 body.emit(f2832);

                                 /* END IF */


                              body.instructions = f2827_parent_instructions;
                              body.emit(f2827);

                              /* END IF */

                              ir_variable *const r2835 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2835);
                              ir_expression *const r2836 = lshift(r250B, body.constant(int(31)));
                              ir_expression *const r2837 = expr(ir_unop_i2u, r27F5);
                              ir_expression *const r2838 = lshift(r2837, body.constant(int(20)));
                              ir_expression *const r2839 = add(r2836, r2838);
                              body.emit(assign(r2835, add(r2839, r27F6), 0x02));

                              body.emit(assign(r2835, r27F7, 0x01));

                              body.emit(assign(r27FA, r2835, 0x03));

                              body.emit(assign(r27F9, body.constant(false), 0x01));


                           body.instructions = f2826_parent_instructions;
                           body.emit(f2826);

                           /* END IF */

                           body.emit(assign(r250C, r27FA, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f27AE->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r283B = less(swizzle_x(r2511), swizzle_x(r250F));
                           ir_if *f283A = new(mem_ctx) ir_if(operand(r283B).val);
                           exec_list *const f283A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f283A->then_instructions;

                              ir_variable *const r283C = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r283D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r283D, sub(swizzle_x(r250F), swizzle_x(r2511)), 0x01));

                              ir_expression *const r283E = sub(swizzle_y(r250F), swizzle_y(r2511));
                              ir_expression *const r283F = less(swizzle_x(r250F), swizzle_x(r2511));
                              ir_expression *const r2840 = expr(ir_unop_b2i, r283F);
                              ir_expression *const r2841 = expr(ir_unop_i2u, r2840);
                              body.emit(assign(r283C, sub(r283E, r2841), 0x01));

                              body.emit(assign(r250B, bit_xor(r250B, body.constant(1u)), 0x01));

                              body.emit(assign(r2512, add(r250E, body.constant(int(-1))), 0x01));

                              ir_variable *const r2842 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2842, add(r2512, body.constant(int(-10))), 0x01));

                              ir_variable *const r2843 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2843, r283C, 0x01));

                              ir_variable *const r2844 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2844, r283D, 0x01));

                              ir_variable *const r2845 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r2845);
                              ir_variable *const r2846 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2846);
                              /* IF CONDITION */
                              ir_expression *const r2848 = equal(r283C, body.constant(0u));
                              ir_if *f2847 = new(mem_ctx) ir_if(operand(r2848).val);
                              exec_list *const f2847_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2847->then_instructions;

                                 body.emit(assign(r2843, r283D, 0x01));

                                 body.emit(assign(r2844, body.constant(0u), 0x01));

                                 body.emit(assign(r2842, add(r2842, body.constant(int(-32))), 0x01));


                              body.instructions = f2847_parent_instructions;
                              body.emit(f2847);

                              /* END IF */

                              ir_variable *const r2849 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r2849, r2843, 0x01));

                              ir_variable *const r284A = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r284B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r284B);
                              /* IF CONDITION */
                              ir_expression *const r284D = equal(r2843, body.constant(0u));
                              ir_if *f284C = new(mem_ctx) ir_if(operand(r284D).val);
                              exec_list *const f284C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f284C->then_instructions;

                                 body.emit(assign(r284A, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f284C->else_instructions;

                                 body.emit(assign(r284B, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r284F = bit_and(r2843, body.constant(4294901760u));
                                 ir_expression *const r2850 = equal(r284F, body.constant(0u));
                                 ir_if *f284E = new(mem_ctx) ir_if(operand(r2850).val);
                                 exec_list *const f284E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f284E->then_instructions;

                                    body.emit(assign(r284B, body.constant(int(16)), 0x01));

                                    body.emit(assign(r2849, lshift(r2843, body.constant(int(16))), 0x01));


                                 body.instructions = f284E_parent_instructions;
                                 body.emit(f284E);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2852 = bit_and(r2849, body.constant(4278190080u));
                                 ir_expression *const r2853 = equal(r2852, body.constant(0u));
                                 ir_if *f2851 = new(mem_ctx) ir_if(operand(r2853).val);
                                 exec_list *const f2851_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2851->then_instructions;

                                    body.emit(assign(r284B, add(r284B, body.constant(int(8))), 0x01));

                                    body.emit(assign(r2849, lshift(r2849, body.constant(int(8))), 0x01));


                                 body.instructions = f2851_parent_instructions;
                                 body.emit(f2851);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2855 = bit_and(r2849, body.constant(4026531840u));
                                 ir_expression *const r2856 = equal(r2855, body.constant(0u));
                                 ir_if *f2854 = new(mem_ctx) ir_if(operand(r2856).val);
                                 exec_list *const f2854_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2854->then_instructions;

                                    body.emit(assign(r284B, add(r284B, body.constant(int(4))), 0x01));

                                    body.emit(assign(r2849, lshift(r2849, body.constant(int(4))), 0x01));


                                 body.instructions = f2854_parent_instructions;
                                 body.emit(f2854);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2858 = bit_and(r2849, body.constant(3221225472u));
                                 ir_expression *const r2859 = equal(r2858, body.constant(0u));
                                 ir_if *f2857 = new(mem_ctx) ir_if(operand(r2859).val);
                                 exec_list *const f2857_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2857->then_instructions;

                                    body.emit(assign(r284B, add(r284B, body.constant(int(2))), 0x01));

                                    body.emit(assign(r2849, lshift(r2849, body.constant(int(2))), 0x01));


                                 body.instructions = f2857_parent_instructions;
                                 body.emit(f2857);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r285B = bit_and(r2849, body.constant(2147483648u));
                                 ir_expression *const r285C = equal(r285B, body.constant(0u));
                                 ir_if *f285A = new(mem_ctx) ir_if(operand(r285C).val);
                                 exec_list *const f285A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f285A->then_instructions;

                                    body.emit(assign(r284B, add(r284B, body.constant(int(1))), 0x01));


                                 body.instructions = f285A_parent_instructions;
                                 body.emit(f285A);

                                 /* END IF */

                                 body.emit(assign(r284A, r284B, 0x01));


                              body.instructions = f284C_parent_instructions;
                              body.emit(f284C);

                              /* END IF */

                              body.emit(assign(r2846, add(r284A, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r285E = lequal(body.constant(int(0)), r2846);
                              ir_if *f285D = new(mem_ctx) ir_if(operand(r285E).val);
                              exec_list *const f285D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f285D->then_instructions;

                                 body.emit(assign(r2845, body.constant(0u), 0x01));

                                 ir_variable *const r285F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r285F, lshift(r2844, r2846), 0x01));

                                 ir_variable *const r2860 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2862 = equal(r2846, body.constant(int(0)));
                                 ir_if *f2861 = new(mem_ctx) ir_if(operand(r2862).val);
                                 exec_list *const f2861_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2861->then_instructions;

                                    body.emit(assign(r2860, r2843, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2861->else_instructions;

                                    ir_expression *const r2863 = lshift(r2843, r2846);
                                    ir_expression *const r2864 = neg(r2846);
                                    ir_expression *const r2865 = bit_and(r2864, body.constant(int(31)));
                                    ir_expression *const r2866 = rshift(r2844, r2865);
                                    body.emit(assign(r2860, bit_or(r2863, r2866), 0x01));


                                 body.instructions = f2861_parent_instructions;
                                 body.emit(f2861);

                                 /* END IF */

                                 body.emit(assign(r2843, r2860, 0x01));

                                 body.emit(assign(r2844, r285F, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f285D->else_instructions;

                                 ir_variable *const r2867 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2867, body.constant(0u), 0x01));

                                 ir_variable *const r2868 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2868, neg(r2846), 0x01));

                                 ir_variable *const r2869 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2869);
                                 ir_variable *const r286A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r286A);
                                 ir_variable *const r286B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r286B);
                                 ir_variable *const r286C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r286D = neg(r2868);
                                 body.emit(assign(r286C, bit_and(r286D, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r286F = equal(r2868, body.constant(int(0)));
                                 ir_if *f286E = new(mem_ctx) ir_if(operand(r286F).val);
                                 exec_list *const f286E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f286E->then_instructions;

                                    body.emit(assign(r2869, r2867, 0x01));

                                    body.emit(assign(r286A, r2844, 0x01));

                                    body.emit(assign(r286B, r2843, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f286E->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2871 = less(r2868, body.constant(int(32)));
                                    ir_if *f2870 = new(mem_ctx) ir_if(operand(r2871).val);
                                    exec_list *const f2870_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2870->then_instructions;

                                       body.emit(assign(r2869, lshift(r2844, r286C), 0x01));

                                       ir_expression *const r2872 = lshift(r2843, r286C);
                                       ir_expression *const r2873 = rshift(r2844, r2868);
                                       body.emit(assign(r286A, bit_or(r2872, r2873), 0x01));

                                       body.emit(assign(r286B, rshift(r2843, r2868), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2870->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2875 = equal(r2868, body.constant(int(32)));
                                       ir_if *f2874 = new(mem_ctx) ir_if(operand(r2875).val);
                                       exec_list *const f2874_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2874->then_instructions;

                                          body.emit(assign(r2869, r2844, 0x01));

                                          body.emit(assign(r286A, r2843, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2874->else_instructions;

                                          body.emit(assign(r2867, bit_or(body.constant(0u), r2844), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2877 = less(r2868, body.constant(int(64)));
                                          ir_if *f2876 = new(mem_ctx) ir_if(operand(r2877).val);
                                          exec_list *const f2876_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2876->then_instructions;

                                             body.emit(assign(r2869, lshift(r2843, r286C), 0x01));

                                             ir_expression *const r2878 = bit_and(r2868, body.constant(int(31)));
                                             body.emit(assign(r286A, rshift(r2843, r2878), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2876->else_instructions;

                                             ir_variable *const r2879 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r287B = equal(r2868, body.constant(int(64)));
                                             ir_if *f287A = new(mem_ctx) ir_if(operand(r287B).val);
                                             exec_list *const f287A_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f287A->then_instructions;

                                                body.emit(assign(r2879, r2843, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f287A->else_instructions;

                                                ir_expression *const r287C = nequal(r2843, body.constant(0u));
                                                ir_expression *const r287D = expr(ir_unop_b2i, r287C);
                                                body.emit(assign(r2879, expr(ir_unop_i2u, r287D), 0x01));


                                             body.instructions = f287A_parent_instructions;
                                             body.emit(f287A);

                                             /* END IF */

                                             body.emit(assign(r2869, r2879, 0x01));

                                             body.emit(assign(r286A, body.constant(0u), 0x01));


                                          body.instructions = f2876_parent_instructions;
                                          body.emit(f2876);

                                          /* END IF */


                                       body.instructions = f2874_parent_instructions;
                                       body.emit(f2874);

                                       /* END IF */

                                       body.emit(assign(r286B, body.constant(0u), 0x01));


                                    body.instructions = f2870_parent_instructions;
                                    body.emit(f2870);

                                    /* END IF */

                                    ir_expression *const r287E = nequal(r2867, body.constant(0u));
                                    ir_expression *const r287F = expr(ir_unop_b2i, r287E);
                                    ir_expression *const r2880 = expr(ir_unop_i2u, r287F);
                                    body.emit(assign(r2869, bit_or(r2869, r2880), 0x01));


                                 body.instructions = f286E_parent_instructions;
                                 body.emit(f286E);

                                 /* END IF */

                                 body.emit(assign(r2843, r286B, 0x01));

                                 body.emit(assign(r2844, r286A, 0x01));

                                 body.emit(assign(r2845, r2869, 0x01));


                              body.instructions = f285D_parent_instructions;
                              body.emit(f285D);

                              /* END IF */

                              body.emit(assign(r2842, sub(r2842, r2846), 0x01));

                              ir_variable *const r2881 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2881, r2842, 0x01));

                              ir_variable *const r2882 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2882, r2843, 0x01));

                              ir_variable *const r2883 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2883, r2844, 0x01));

                              ir_variable *const r2884 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r2884, r2845, 0x01));

                              ir_variable *const r2885 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r2885, body.constant(true), 0x01));

                              ir_variable *const r2886 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r2887 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r2887);
                              ir_expression *const r2888 = expr(ir_unop_u2i, r2845);
                              body.emit(assign(r2887, less(r2888, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r288A = lequal(body.constant(int(2045)), r2842);
                              ir_if *f2889 = new(mem_ctx) ir_if(operand(r288A).val);
                              exec_list *const f2889_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2889->then_instructions;

                                 ir_variable *const r288B = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r288D = less(body.constant(int(2045)), r2842);
                                 ir_if *f288C = new(mem_ctx) ir_if(operand(r288D).val);
                                 exec_list *const f288C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f288C->then_instructions;

                                    body.emit(assign(r288B, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f288C->else_instructions;

                                    ir_variable *const r288E = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2890 = equal(r2842, body.constant(int(2045)));
                                    ir_if *f288F = new(mem_ctx) ir_if(operand(r2890).val);
                                    exec_list *const f288F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f288F->then_instructions;

                                       ir_expression *const r2891 = equal(body.constant(2097151u), r2843);
                                       ir_expression *const r2892 = equal(body.constant(4294967295u), r2844);
                                       body.emit(assign(r288E, logic_and(r2891, r2892), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f288F->else_instructions;

                                       body.emit(assign(r288E, body.constant(false), 0x01));


                                    body.instructions = f288F_parent_instructions;
                                    body.emit(f288F);

                                    /* END IF */

                                    body.emit(assign(r288B, logic_and(r288E, r2887), 0x01));


                                 body.instructions = f288C_parent_instructions;
                                 body.emit(f288C);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f2893 = new(mem_ctx) ir_if(operand(r288B).val);
                                 exec_list *const f2893_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2893->then_instructions;

                                    ir_variable *const r2894 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r2894);
                                    ir_expression *const r2895 = lshift(r250B, body.constant(int(31)));
                                    body.emit(assign(r2894, add(r2895, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r2894, body.constant(0u), 0x01));

                                    body.emit(assign(r2886, r2894, 0x03));

                                    body.emit(assign(r2885, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2893->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2897 = less(r2842, body.constant(int(0)));
                                    ir_if *f2896 = new(mem_ctx) ir_if(operand(r2897).val);
                                    exec_list *const f2896_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2896->then_instructions;

                                       ir_variable *const r2898 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r2898, r2845, 0x01));

                                       ir_variable *const r2899 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r2899, neg(r2842), 0x01));

                                       ir_variable *const r289A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r289A);
                                       ir_variable *const r289B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r289B);
                                       ir_variable *const r289C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r289C);
                                       ir_variable *const r289D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r289E = neg(r2899);
                                       body.emit(assign(r289D, bit_and(r289E, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r28A0 = equal(r2899, body.constant(int(0)));
                                       ir_if *f289F = new(mem_ctx) ir_if(operand(r28A0).val);
                                       exec_list *const f289F_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f289F->then_instructions;

                                          body.emit(assign(r289A, r2845, 0x01));

                                          body.emit(assign(r289B, r2844, 0x01));

                                          body.emit(assign(r289C, r2843, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f289F->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r28A2 = less(r2899, body.constant(int(32)));
                                          ir_if *f28A1 = new(mem_ctx) ir_if(operand(r28A2).val);
                                          exec_list *const f28A1_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f28A1->then_instructions;

                                             body.emit(assign(r289A, lshift(r2844, r289D), 0x01));

                                             ir_expression *const r28A3 = lshift(r2843, r289D);
                                             ir_expression *const r28A4 = rshift(r2844, r2899);
                                             body.emit(assign(r289B, bit_or(r28A3, r28A4), 0x01));

                                             body.emit(assign(r289C, rshift(r2843, r2899), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f28A1->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r28A6 = equal(r2899, body.constant(int(32)));
                                             ir_if *f28A5 = new(mem_ctx) ir_if(operand(r28A6).val);
                                             exec_list *const f28A5_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f28A5->then_instructions;

                                                body.emit(assign(r289A, r2844, 0x01));

                                                body.emit(assign(r289B, r2843, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f28A5->else_instructions;

                                                body.emit(assign(r2898, bit_or(r2845, r2844), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r28A8 = less(r2899, body.constant(int(64)));
                                                ir_if *f28A7 = new(mem_ctx) ir_if(operand(r28A8).val);
                                                exec_list *const f28A7_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f28A7->then_instructions;

                                                   body.emit(assign(r289A, lshift(r2843, r289D), 0x01));

                                                   ir_expression *const r28A9 = bit_and(r2899, body.constant(int(31)));
                                                   body.emit(assign(r289B, rshift(r2843, r28A9), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f28A7->else_instructions;

                                                   ir_variable *const r28AA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r28AC = equal(r2899, body.constant(int(64)));
                                                   ir_if *f28AB = new(mem_ctx) ir_if(operand(r28AC).val);
                                                   exec_list *const f28AB_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f28AB->then_instructions;

                                                      body.emit(assign(r28AA, r2843, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f28AB->else_instructions;

                                                      ir_expression *const r28AD = nequal(r2843, body.constant(0u));
                                                      ir_expression *const r28AE = expr(ir_unop_b2i, r28AD);
                                                      body.emit(assign(r28AA, expr(ir_unop_i2u, r28AE), 0x01));


                                                   body.instructions = f28AB_parent_instructions;
                                                   body.emit(f28AB);

                                                   /* END IF */

                                                   body.emit(assign(r289A, r28AA, 0x01));

                                                   body.emit(assign(r289B, body.constant(0u), 0x01));


                                                body.instructions = f28A7_parent_instructions;
                                                body.emit(f28A7);

                                                /* END IF */


                                             body.instructions = f28A5_parent_instructions;
                                             body.emit(f28A5);

                                             /* END IF */

                                             body.emit(assign(r289C, body.constant(0u), 0x01));


                                          body.instructions = f28A1_parent_instructions;
                                          body.emit(f28A1);

                                          /* END IF */

                                          ir_expression *const r28AF = nequal(r2898, body.constant(0u));
                                          ir_expression *const r28B0 = expr(ir_unop_b2i, r28AF);
                                          ir_expression *const r28B1 = expr(ir_unop_i2u, r28B0);
                                          body.emit(assign(r289A, bit_or(r289A, r28B1), 0x01));


                                       body.instructions = f289F_parent_instructions;
                                       body.emit(f289F);

                                       /* END IF */

                                       body.emit(assign(r2882, r289C, 0x01));

                                       body.emit(assign(r2883, r289B, 0x01));

                                       body.emit(assign(r2884, r289A, 0x01));

                                       body.emit(assign(r2881, body.constant(int(0)), 0x01));

                                       body.emit(assign(r2887, less(r289A, body.constant(0u)), 0x01));


                                    body.instructions = f2896_parent_instructions;
                                    body.emit(f2896);

                                    /* END IF */


                                 body.instructions = f2893_parent_instructions;
                                 body.emit(f2893);

                                 /* END IF */


                              body.instructions = f2889_parent_instructions;
                              body.emit(f2889);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f28B2 = new(mem_ctx) ir_if(operand(r2885).val);
                              exec_list *const f28B2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f28B2->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f28B3 = new(mem_ctx) ir_if(operand(r2887).val);
                                 exec_list *const f28B3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f28B3->then_instructions;

                                    ir_variable *const r28B4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r28B4, add(r2883, body.constant(1u)), 0x01));

                                    ir_expression *const r28B5 = less(r28B4, r2883);
                                    ir_expression *const r28B6 = expr(ir_unop_b2i, r28B5);
                                    ir_expression *const r28B7 = expr(ir_unop_i2u, r28B6);
                                    body.emit(assign(r2882, add(r2882, r28B7), 0x01));

                                    ir_expression *const r28B8 = equal(r2884, body.constant(0u));
                                    ir_expression *const r28B9 = expr(ir_unop_b2i, r28B8);
                                    ir_expression *const r28BA = expr(ir_unop_i2u, r28B9);
                                    ir_expression *const r28BB = add(r2884, r28BA);
                                    ir_expression *const r28BC = bit_and(r28BB, body.constant(1u));
                                    ir_expression *const r28BD = expr(ir_unop_bit_not, r28BC);
                                    body.emit(assign(r2883, bit_and(r28B4, r28BD), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f28B3->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r28BF = bit_or(r2882, r2883);
                                    ir_expression *const r28C0 = equal(r28BF, body.constant(0u));
                                    ir_if *f28BE = new(mem_ctx) ir_if(operand(r28C0).val);
                                    exec_list *const f28BE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f28BE->then_instructions;

                                       body.emit(assign(r2881, body.constant(int(0)), 0x01));


                                    body.instructions = f28BE_parent_instructions;
                                    body.emit(f28BE);

                                    /* END IF */


                                 body.instructions = f28B3_parent_instructions;
                                 body.emit(f28B3);

                                 /* END IF */

                                 ir_variable *const r28C1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r28C1);
                                 ir_expression *const r28C2 = lshift(r250B, body.constant(int(31)));
                                 ir_expression *const r28C3 = expr(ir_unop_i2u, r2881);
                                 ir_expression *const r28C4 = lshift(r28C3, body.constant(int(20)));
                                 ir_expression *const r28C5 = add(r28C2, r28C4);
                                 body.emit(assign(r28C1, add(r28C5, r2882), 0x02));

                                 body.emit(assign(r28C1, r2883, 0x01));

                                 body.emit(assign(r2886, r28C1, 0x03));

                                 body.emit(assign(r2885, body.constant(false), 0x01));


                              body.instructions = f28B2_parent_instructions;
                              body.emit(f28B2);

                              /* END IF */

                              body.emit(assign(r250C, r2886, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f283A->else_instructions;

                              ir_variable *const r28C6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r28C6);
                              body.emit(assign(r28C6, body.constant(0u), 0x02));

                              body.emit(assign(r28C6, body.constant(0u), 0x01));

                              body.emit(assign(r250C, r28C6, 0x03));


                           body.instructions = f283A_parent_instructions;
                           body.emit(f283A);

                           /* END IF */


                        body.instructions = f27AE_parent_instructions;
                        body.emit(f27AE);

                        /* END IF */


                     body.instructions = f2722_parent_instructions;
                     body.emit(f2722);

                     /* END IF */


                  body.instructions = f2696_parent_instructions;
                  body.emit(f2696);

                  /* END IF */


               body.instructions = f2681_parent_instructions;
               body.emit(f2681);

               /* END IF */


            body.instructions = f25D0_parent_instructions;
            body.emit(f25D0);

            /* END IF */


         body.instructions = f251D_parent_instructions;
         body.emit(f251D);

         /* END IF */

         body.emit(assign(r23AD, r250C, 0x03));


      body.instructions = f23AF_parent_instructions;
      body.emit(f23AF);

      /* END IF */

      body.emit(assign(r23AB, r23AD, 0x03));


   body.instructions = f23AC_parent_instructions;
   body.emit(f23AC);

   /* END IF */

   body.emit(ret(r23AB));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffract64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r28C7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r28C7);
   ir_variable *const r28C8 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r28C9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r28CA = rshift(swizzle_y(r28C7), body.constant(int(20)));
   ir_expression *const r28CB = bit_and(r28CA, body.constant(2047u));
   ir_expression *const r28CC = expr(ir_unop_u2i, r28CB);
   body.emit(assign(r28C9, add(r28CC, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r28CE = less(r28C9, body.constant(int(0)));
   ir_if *f28CD = new(mem_ctx) ir_if(operand(r28CE).val);
   exec_list *const f28CD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f28CD->then_instructions;

      body.emit(assign(r28C8, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f28CD->else_instructions;

      /* IF CONDITION */
      ir_expression *const r28D0 = greater(r28C9, body.constant(int(52)));
      ir_if *f28CF = new(mem_ctx) ir_if(operand(r28D0).val);
      exec_list *const f28CF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f28CF->then_instructions;

         body.emit(assign(r28C8, r28C7, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f28CF->else_instructions;

         ir_variable *const r28D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r28D1);
         ir_variable *const r28D2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r28D2, sub(body.constant(int(52)), r28C9), 0x01));

         ir_variable *const r28D3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r28D5 = gequal(r28D2, body.constant(int(32)));
         ir_if *f28D4 = new(mem_ctx) ir_if(operand(r28D5).val);
         exec_list *const f28D4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f28D4->then_instructions;

            body.emit(assign(r28D3, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f28D4->else_instructions;

            body.emit(assign(r28D3, lshift(body.constant(4294967295u), r28D2), 0x01));


         body.instructions = f28D4_parent_instructions;
         body.emit(f28D4);

         /* END IF */

         ir_variable *const r28D6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r28D8 = less(r28D2, body.constant(int(33)));
         ir_if *f28D7 = new(mem_ctx) ir_if(operand(r28D8).val);
         exec_list *const f28D7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f28D7->then_instructions;

            body.emit(assign(r28D6, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f28D7->else_instructions;

            ir_expression *const r28D9 = add(r28D2, body.constant(int(-32)));
            body.emit(assign(r28D6, lshift(body.constant(4294967295u), r28D9), 0x01));


         body.instructions = f28D7_parent_instructions;
         body.emit(f28D7);

         /* END IF */

         body.emit(assign(r28D1, bit_and(r28D3, swizzle_x(r28C7)), 0x01));

         body.emit(assign(r28D1, bit_and(r28D6, swizzle_y(r28C7)), 0x02));

         body.emit(assign(r28C8, r28D1, 0x03));


      body.instructions = f28CF_parent_instructions;
      body.emit(f28CF);

      /* END IF */


   body.instructions = f28CD_parent_instructions;
   body.emit(f28CD);

   /* END IF */

   ir_variable *const r28DA = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r28DB = rshift(swizzle_y(r28C7), body.constant(int(31)));
   ir_expression *const r28DC = expr(ir_unop_u2i, r28DB);
   body.emit(assign(r28DA, expr(ir_unop_i2b, r28DC), 0x01));

   ir_variable *const r28DD = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r28DF = expr(ir_unop_logic_not, r28DA);
   ir_if *f28DE = new(mem_ctx) ir_if(operand(r28DF).val);
   exec_list *const f28DE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f28DE->then_instructions;

      body.emit(assign(r28DD, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f28DE->else_instructions;

      ir_variable *const r28E0 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r28E1 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r28E1);
      ir_variable *const r28E2 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r28E2);
      ir_variable *const r28E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r28E3);
      body.emit(assign(r28E3, bit_and(swizzle_y(r28C7), body.constant(1048575u)), 0x02));

      body.emit(assign(r28E3, swizzle_x(r28C7), 0x01));

      ir_variable *const r28E4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r28E4);
      body.emit(assign(r28E4, bit_and(swizzle_y(r28C8), body.constant(1048575u)), 0x02));

      body.emit(assign(r28E4, swizzle_x(r28C8), 0x01));

      ir_expression *const r28E5 = rshift(swizzle_y(r28C7), body.constant(int(20)));
      ir_expression *const r28E6 = bit_and(r28E5, body.constant(2047u));
      ir_expression *const r28E7 = expr(ir_unop_u2i, r28E6);
      ir_expression *const r28E8 = equal(r28E7, body.constant(int(2047)));
      ir_expression *const r28E9 = bit_or(swizzle_y(r28E3), swizzle_x(r28C7));
      ir_expression *const r28EA = nequal(r28E9, body.constant(0u));
      body.emit(assign(r28E2, logic_and(r28E8, r28EA), 0x01));

      ir_expression *const r28EB = rshift(swizzle_y(r28C8), body.constant(int(20)));
      ir_expression *const r28EC = bit_and(r28EB, body.constant(2047u));
      ir_expression *const r28ED = expr(ir_unop_u2i, r28EC);
      ir_expression *const r28EE = equal(r28ED, body.constant(int(2047)));
      ir_expression *const r28EF = bit_or(swizzle_y(r28E4), swizzle_x(r28C8));
      ir_expression *const r28F0 = nequal(r28EF, body.constant(0u));
      body.emit(assign(r28E1, logic_and(r28EE, r28F0), 0x01));

      /* IF CONDITION */
      ir_expression *const r28F2 = logic_or(r28E2, r28E1);
      ir_if *f28F1 = new(mem_ctx) ir_if(operand(r28F2).val);
      exec_list *const f28F1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f28F1->then_instructions;

         body.emit(assign(r28E0, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f28F1->else_instructions;

         ir_expression *const r28F3 = equal(swizzle_x(r28C7), swizzle_x(r28C8));
         ir_expression *const r28F4 = equal(swizzle_y(r28C7), swizzle_y(r28C8));
         ir_expression *const r28F5 = equal(swizzle_x(r28C7), body.constant(0u));
         ir_expression *const r28F6 = bit_or(swizzle_y(r28C7), swizzle_y(r28C8));
         ir_expression *const r28F7 = lshift(r28F6, body.constant(int(1)));
         ir_expression *const r28F8 = equal(r28F7, body.constant(0u));
         ir_expression *const r28F9 = logic_and(r28F5, r28F8);
         ir_expression *const r28FA = logic_or(r28F4, r28F9);
         body.emit(assign(r28E0, logic_and(r28F3, r28FA), 0x01));


      body.instructions = f28F1_parent_instructions;
      body.emit(f28F1);

      /* END IF */

      body.emit(assign(r28DD, r28E0, 0x01));


   body.instructions = f28DE_parent_instructions;
   body.emit(f28DE);

   /* END IF */

   ir_variable *const r28FB = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f28FC = new(mem_ctx) ir_if(operand(r28DD).val);
   exec_list *const f28FC_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f28FC->then_instructions;

      body.emit(assign(r28FB, r28C8, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f28FC->else_instructions;

      ir_variable *const r28FD = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r28FE = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r28FE, rshift(swizzle_y(r28C8), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r2900 = equal(r28FE, body.constant(0u));
      ir_if *f28FF = new(mem_ctx) ir_if(operand(r2900).val);
      exec_list *const f28FF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f28FF->then_instructions;

         ir_variable *const r2901 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r2901, r28FE, 0x01));

         ir_variable *const r2902 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2903 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2903);
         ir_variable *const r2904 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r2904);
         ir_variable *const r2905 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r2905);
         ir_variable *const r2906 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r2906);
         ir_variable *const r2907 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r2907);
         ir_variable *const r2908 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2908);
         ir_variable *const r2909 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r2909);
         body.emit(assign(r2909, bit_and(swizzle_y(r28C8), body.constant(1048575u)), 0x02));

         body.emit(assign(r2909, swizzle_x(r28C8), 0x01));

         ir_variable *const r290A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r290B = rshift(swizzle_y(r28C8), body.constant(int(20)));
         ir_expression *const r290C = bit_and(r290B, body.constant(2047u));
         body.emit(assign(r290A, expr(ir_unop_u2i, r290C), 0x01));

         body.emit(assign(r2906, r290A, 0x01));

         ir_variable *const r290D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r290D);
         body.emit(assign(r290D, body.constant(0u), 0x02));

         body.emit(assign(r290D, body.constant(0u), 0x01));

         body.emit(assign(r2904, body.constant(int(1023)), 0x01));

         body.emit(assign(r2903, add(r290A, body.constant(int(-1023))), 0x01));

         ir_variable *const r290E = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r290E, lshift(swizzle_x(r28C8), body.constant(int(10))), 0x01));

         ir_variable *const r290F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r2910 = lshift(swizzle_y(r2909), body.constant(int(10)));
         ir_expression *const r2911 = rshift(swizzle_x(r28C8), body.constant(int(22)));
         body.emit(assign(r290F, bit_or(r2910, r2911), 0x01));

         body.emit(assign(r2907, r290F, 0x02));

         body.emit(assign(r2907, r290E, 0x01));

         ir_variable *const r2912 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r2912, body.constant(0u), 0x01));

         body.emit(assign(r2905, r2912, 0x02));

         body.emit(assign(r2905, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r2914 = less(body.constant(int(0)), r2903);
         ir_if *f2913 = new(mem_ctx) ir_if(operand(r2914).val);
         exec_list *const f2913_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2913->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2916 = equal(r290A, body.constant(int(2047)));
            ir_if *f2915 = new(mem_ctx) ir_if(operand(r2916).val);
            exec_list *const f2915_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2915->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2918 = bit_or(r290F, r290E);
               ir_expression *const r2919 = nequal(r2918, body.constant(0u));
               ir_if *f2917 = new(mem_ctx) ir_if(operand(r2919).val);
               exec_list *const f2917_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2917->then_instructions;

                  ir_variable *const r291A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r291A, swizzle_x(r28C8), 0x01));

                  ir_variable *const r291B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r291B, body.constant(0u), 0x01));

                  ir_variable *const r291C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r291A, bit_or(swizzle_y(r28C8), body.constant(524288u)), 0x02));

                  body.emit(assign(r291B, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r291E = lshift(swizzle_y(r28C8), body.constant(int(1)));
                  ir_expression *const r291F = lequal(body.constant(4292870144u), r291E);
                  ir_expression *const r2920 = nequal(swizzle_x(r28C8), body.constant(0u));
                  ir_expression *const r2921 = bit_and(swizzle_y(r28C8), body.constant(1048575u));
                  ir_expression *const r2922 = nequal(r2921, body.constant(0u));
                  ir_expression *const r2923 = logic_or(r2920, r2922);
                  ir_expression *const r2924 = logic_and(r291F, r2923);
                  ir_if *f291D = new(mem_ctx) ir_if(operand(r2924).val);
                  exec_list *const f291D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f291D->then_instructions;

                     body.emit(assign(r291C, r291A, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f291D->else_instructions;

                     body.emit(assign(r291C, r291B, 0x03));


                  body.instructions = f291D_parent_instructions;
                  body.emit(f291D);

                  /* END IF */

                  body.emit(assign(r2902, r291C, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2917->else_instructions;

                  body.emit(assign(r2902, r28C8, 0x03));


               body.instructions = f2917_parent_instructions;
               body.emit(f2917);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2915->else_instructions;

               body.emit(assign(r2905, body.constant(1073741824u), 0x02));

               ir_variable *const r2925 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r2925, body.constant(1073741824u), 0x01));

               ir_variable *const r2926 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r2926, body.constant(0u), 0x01));

               ir_variable *const r2927 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2927);
               ir_variable *const r2928 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2928);
               ir_variable *const r2929 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r292A = neg(r2903);
               body.emit(assign(r2929, bit_and(r292A, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r292C = equal(r2903, body.constant(int(0)));
               ir_if *f292B = new(mem_ctx) ir_if(operand(r292C).val);
               exec_list *const f292B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f292B->then_instructions;

                  body.emit(assign(r2927, r2926, 0x01));

                  body.emit(assign(r2928, r2925, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f292B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r292E = less(r2903, body.constant(int(32)));
                  ir_if *f292D = new(mem_ctx) ir_if(operand(r292E).val);
                  exec_list *const f292D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f292D->then_instructions;

                     ir_expression *const r292F = lshift(body.constant(1073741824u), r2929);
                     ir_expression *const r2930 = bit_or(r292F, body.constant(0u));
                     body.emit(assign(r2927, bit_or(r2930, body.constant(0u)), 0x01));

                     body.emit(assign(r2928, rshift(body.constant(1073741824u), r2903), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f292D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2932 = equal(r2903, body.constant(int(32)));
                     ir_if *f2931 = new(mem_ctx) ir_if(operand(r2932).val);
                     exec_list *const f2931_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2931->then_instructions;

                        body.emit(assign(r2927, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2931->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2934 = less(r2903, body.constant(int(64)));
                        ir_if *f2933 = new(mem_ctx) ir_if(operand(r2934).val);
                        exec_list *const f2933_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2933->then_instructions;

                           ir_expression *const r2935 = bit_and(r2903, body.constant(int(31)));
                           ir_expression *const r2936 = rshift(body.constant(1073741824u), r2935);
                           ir_expression *const r2937 = lshift(body.constant(1073741824u), r2929);
                           ir_expression *const r2938 = bit_or(r2937, body.constant(0u));
                           ir_expression *const r2939 = nequal(r2938, body.constant(0u));
                           ir_expression *const r293A = expr(ir_unop_b2i, r2939);
                           ir_expression *const r293B = expr(ir_unop_i2u, r293A);
                           body.emit(assign(r2927, bit_or(r2936, r293B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2933->else_instructions;

                           body.emit(assign(r2927, body.constant(1u), 0x01));


                        body.instructions = f2933_parent_instructions;
                        body.emit(f2933);

                        /* END IF */


                     body.instructions = f2931_parent_instructions;
                     body.emit(f2931);

                     /* END IF */

                     body.emit(assign(r2928, body.constant(0u), 0x01));


                  body.instructions = f292D_parent_instructions;
                  body.emit(f292D);

                  /* END IF */


               body.instructions = f292B_parent_instructions;
               body.emit(f292B);

               /* END IF */

               body.emit(assign(r2905, r2928, 0x02));

               body.emit(assign(r2905, r2927, 0x01));

               body.emit(assign(r2907, bit_or(r290F, body.constant(1073741824u)), 0x02));

               ir_variable *const r293C = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r293D = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r293D, sub(r290E, r2927), 0x01));

               ir_expression *const r293E = sub(swizzle_y(r2907), r2928);
               ir_expression *const r293F = less(r290E, r2927);
               ir_expression *const r2940 = expr(ir_unop_b2i, r293F);
               ir_expression *const r2941 = expr(ir_unop_i2u, r2940);
               body.emit(assign(r293C, sub(r293E, r2941), 0x01));

               body.emit(assign(r2908, add(r290A, body.constant(int(-1))), 0x01));

               ir_variable *const r2942 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2942, add(r2908, body.constant(int(-10))), 0x01));

               ir_variable *const r2943 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2943, r293C, 0x01));

               ir_variable *const r2944 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2944, r293D, 0x01));

               ir_variable *const r2945 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2945);
               ir_variable *const r2946 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2946);
               /* IF CONDITION */
               ir_expression *const r2948 = equal(r293C, body.constant(0u));
               ir_if *f2947 = new(mem_ctx) ir_if(operand(r2948).val);
               exec_list *const f2947_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2947->then_instructions;

                  body.emit(assign(r2943, r293D, 0x01));

                  body.emit(assign(r2944, body.constant(0u), 0x01));

                  body.emit(assign(r2942, add(r2942, body.constant(int(-32))), 0x01));


               body.instructions = f2947_parent_instructions;
               body.emit(f2947);

               /* END IF */

               ir_variable *const r2949 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2949, r2943, 0x01));

               ir_variable *const r294A = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r294B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r294B);
               /* IF CONDITION */
               ir_expression *const r294D = equal(r2943, body.constant(0u));
               ir_if *f294C = new(mem_ctx) ir_if(operand(r294D).val);
               exec_list *const f294C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f294C->then_instructions;

                  body.emit(assign(r294A, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f294C->else_instructions;

                  body.emit(assign(r294B, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r294F = bit_and(r2943, body.constant(4294901760u));
                  ir_expression *const r2950 = equal(r294F, body.constant(0u));
                  ir_if *f294E = new(mem_ctx) ir_if(operand(r2950).val);
                  exec_list *const f294E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f294E->then_instructions;

                     body.emit(assign(r294B, body.constant(int(16)), 0x01));

                     body.emit(assign(r2949, lshift(r2943, body.constant(int(16))), 0x01));


                  body.instructions = f294E_parent_instructions;
                  body.emit(f294E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2952 = bit_and(r2949, body.constant(4278190080u));
                  ir_expression *const r2953 = equal(r2952, body.constant(0u));
                  ir_if *f2951 = new(mem_ctx) ir_if(operand(r2953).val);
                  exec_list *const f2951_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2951->then_instructions;

                     body.emit(assign(r294B, add(r294B, body.constant(int(8))), 0x01));

                     body.emit(assign(r2949, lshift(r2949, body.constant(int(8))), 0x01));


                  body.instructions = f2951_parent_instructions;
                  body.emit(f2951);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2955 = bit_and(r2949, body.constant(4026531840u));
                  ir_expression *const r2956 = equal(r2955, body.constant(0u));
                  ir_if *f2954 = new(mem_ctx) ir_if(operand(r2956).val);
                  exec_list *const f2954_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2954->then_instructions;

                     body.emit(assign(r294B, add(r294B, body.constant(int(4))), 0x01));

                     body.emit(assign(r2949, lshift(r2949, body.constant(int(4))), 0x01));


                  body.instructions = f2954_parent_instructions;
                  body.emit(f2954);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2958 = bit_and(r2949, body.constant(3221225472u));
                  ir_expression *const r2959 = equal(r2958, body.constant(0u));
                  ir_if *f2957 = new(mem_ctx) ir_if(operand(r2959).val);
                  exec_list *const f2957_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2957->then_instructions;

                     body.emit(assign(r294B, add(r294B, body.constant(int(2))), 0x01));

                     body.emit(assign(r2949, lshift(r2949, body.constant(int(2))), 0x01));


                  body.instructions = f2957_parent_instructions;
                  body.emit(f2957);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r295B = bit_and(r2949, body.constant(2147483648u));
                  ir_expression *const r295C = equal(r295B, body.constant(0u));
                  ir_if *f295A = new(mem_ctx) ir_if(operand(r295C).val);
                  exec_list *const f295A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f295A->then_instructions;

                     body.emit(assign(r294B, add(r294B, body.constant(int(1))), 0x01));


                  body.instructions = f295A_parent_instructions;
                  body.emit(f295A);

                  /* END IF */

                  body.emit(assign(r294A, r294B, 0x01));


               body.instructions = f294C_parent_instructions;
               body.emit(f294C);

               /* END IF */

               body.emit(assign(r2946, add(r294A, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r295E = lequal(body.constant(int(0)), r2946);
               ir_if *f295D = new(mem_ctx) ir_if(operand(r295E).val);
               exec_list *const f295D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f295D->then_instructions;

                  body.emit(assign(r2945, body.constant(0u), 0x01));

                  ir_variable *const r295F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r295F, lshift(r2944, r2946), 0x01));

                  ir_variable *const r2960 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2962 = equal(r2946, body.constant(int(0)));
                  ir_if *f2961 = new(mem_ctx) ir_if(operand(r2962).val);
                  exec_list *const f2961_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2961->then_instructions;

                     body.emit(assign(r2960, r2943, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2961->else_instructions;

                     ir_expression *const r2963 = lshift(r2943, r2946);
                     ir_expression *const r2964 = neg(r2946);
                     ir_expression *const r2965 = bit_and(r2964, body.constant(int(31)));
                     ir_expression *const r2966 = rshift(r2944, r2965);
                     body.emit(assign(r2960, bit_or(r2963, r2966), 0x01));


                  body.instructions = f2961_parent_instructions;
                  body.emit(f2961);

                  /* END IF */

                  body.emit(assign(r2943, r2960, 0x01));

                  body.emit(assign(r2944, r295F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f295D->else_instructions;

                  ir_variable *const r2967 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2967, body.constant(0u), 0x01));

                  ir_variable *const r2968 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2968, neg(r2946), 0x01));

                  ir_variable *const r2969 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2969);
                  ir_variable *const r296A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r296A);
                  ir_variable *const r296B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r296B);
                  ir_variable *const r296C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r296D = neg(r2968);
                  body.emit(assign(r296C, bit_and(r296D, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r296F = equal(r2968, body.constant(int(0)));
                  ir_if *f296E = new(mem_ctx) ir_if(operand(r296F).val);
                  exec_list *const f296E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f296E->then_instructions;

                     body.emit(assign(r2969, r2967, 0x01));

                     body.emit(assign(r296A, r2944, 0x01));

                     body.emit(assign(r296B, r2943, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f296E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2971 = less(r2968, body.constant(int(32)));
                     ir_if *f2970 = new(mem_ctx) ir_if(operand(r2971).val);
                     exec_list *const f2970_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2970->then_instructions;

                        body.emit(assign(r2969, lshift(r2944, r296C), 0x01));

                        ir_expression *const r2972 = lshift(r2943, r296C);
                        ir_expression *const r2973 = rshift(r2944, r2968);
                        body.emit(assign(r296A, bit_or(r2972, r2973), 0x01));

                        body.emit(assign(r296B, rshift(r2943, r2968), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2970->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2975 = equal(r2968, body.constant(int(32)));
                        ir_if *f2974 = new(mem_ctx) ir_if(operand(r2975).val);
                        exec_list *const f2974_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2974->then_instructions;

                           body.emit(assign(r2969, r2944, 0x01));

                           body.emit(assign(r296A, r2943, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2974->else_instructions;

                           body.emit(assign(r2967, bit_or(body.constant(0u), r2944), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2977 = less(r2968, body.constant(int(64)));
                           ir_if *f2976 = new(mem_ctx) ir_if(operand(r2977).val);
                           exec_list *const f2976_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2976->then_instructions;

                              body.emit(assign(r2969, lshift(r2943, r296C), 0x01));

                              ir_expression *const r2978 = bit_and(r2968, body.constant(int(31)));
                              body.emit(assign(r296A, rshift(r2943, r2978), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2976->else_instructions;

                              ir_variable *const r2979 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r297B = equal(r2968, body.constant(int(64)));
                              ir_if *f297A = new(mem_ctx) ir_if(operand(r297B).val);
                              exec_list *const f297A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f297A->then_instructions;

                                 body.emit(assign(r2979, r2943, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f297A->else_instructions;

                                 ir_expression *const r297C = nequal(r2943, body.constant(0u));
                                 ir_expression *const r297D = expr(ir_unop_b2i, r297C);
                                 body.emit(assign(r2979, expr(ir_unop_i2u, r297D), 0x01));


                              body.instructions = f297A_parent_instructions;
                              body.emit(f297A);

                              /* END IF */

                              body.emit(assign(r2969, r2979, 0x01));

                              body.emit(assign(r296A, body.constant(0u), 0x01));


                           body.instructions = f2976_parent_instructions;
                           body.emit(f2976);

                           /* END IF */


                        body.instructions = f2974_parent_instructions;
                        body.emit(f2974);

                        /* END IF */

                        body.emit(assign(r296B, body.constant(0u), 0x01));


                     body.instructions = f2970_parent_instructions;
                     body.emit(f2970);

                     /* END IF */

                     ir_expression *const r297E = nequal(r2967, body.constant(0u));
                     ir_expression *const r297F = expr(ir_unop_b2i, r297E);
                     ir_expression *const r2980 = expr(ir_unop_i2u, r297F);
                     body.emit(assign(r2969, bit_or(r2969, r2980), 0x01));


                  body.instructions = f296E_parent_instructions;
                  body.emit(f296E);

                  /* END IF */

                  body.emit(assign(r2943, r296B, 0x01));

                  body.emit(assign(r2944, r296A, 0x01));

                  body.emit(assign(r2945, r2969, 0x01));


               body.instructions = f295D_parent_instructions;
               body.emit(f295D);

               /* END IF */

               body.emit(assign(r2942, sub(r2942, r2946), 0x01));

               ir_variable *const r2981 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2981, r2942, 0x01));

               ir_variable *const r2982 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2982, r2943, 0x01));

               ir_variable *const r2983 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2983, r2944, 0x01));

               ir_variable *const r2984 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2984, r2945, 0x01));

               ir_variable *const r2985 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2985, body.constant(true), 0x01));

               ir_variable *const r2986 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2987 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2987);
               ir_expression *const r2988 = expr(ir_unop_u2i, r2945);
               body.emit(assign(r2987, less(r2988, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r298A = lequal(body.constant(int(2045)), r2942);
               ir_if *f2989 = new(mem_ctx) ir_if(operand(r298A).val);
               exec_list *const f2989_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2989->then_instructions;

                  ir_variable *const r298B = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r298D = less(body.constant(int(2045)), r2942);
                  ir_if *f298C = new(mem_ctx) ir_if(operand(r298D).val);
                  exec_list *const f298C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f298C->then_instructions;

                     body.emit(assign(r298B, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f298C->else_instructions;

                     ir_variable *const r298E = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2990 = equal(r2942, body.constant(int(2045)));
                     ir_if *f298F = new(mem_ctx) ir_if(operand(r2990).val);
                     exec_list *const f298F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f298F->then_instructions;

                        ir_expression *const r2991 = equal(body.constant(2097151u), r2943);
                        ir_expression *const r2992 = equal(body.constant(4294967295u), r2944);
                        body.emit(assign(r298E, logic_and(r2991, r2992), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f298F->else_instructions;

                        body.emit(assign(r298E, body.constant(false), 0x01));


                     body.instructions = f298F_parent_instructions;
                     body.emit(f298F);

                     /* END IF */

                     body.emit(assign(r298B, logic_and(r298E, r2987), 0x01));


                  body.instructions = f298C_parent_instructions;
                  body.emit(f298C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2993 = new(mem_ctx) ir_if(operand(r298B).val);
                  exec_list *const f2993_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2993->then_instructions;

                     ir_variable *const r2994 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2994);
                     ir_expression *const r2995 = lshift(r28FE, body.constant(int(31)));
                     body.emit(assign(r2994, add(r2995, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2994, body.constant(0u), 0x01));

                     body.emit(assign(r2986, r2994, 0x03));

                     body.emit(assign(r2985, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2993->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2997 = less(r2942, body.constant(int(0)));
                     ir_if *f2996 = new(mem_ctx) ir_if(operand(r2997).val);
                     exec_list *const f2996_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2996->then_instructions;

                        ir_variable *const r2998 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2998, r2945, 0x01));

                        ir_variable *const r2999 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2999, neg(r2942), 0x01));

                        ir_variable *const r299A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r299A);
                        ir_variable *const r299B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r299B);
                        ir_variable *const r299C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r299C);
                        ir_variable *const r299D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r299E = neg(r2999);
                        body.emit(assign(r299D, bit_and(r299E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r29A0 = equal(r2999, body.constant(int(0)));
                        ir_if *f299F = new(mem_ctx) ir_if(operand(r29A0).val);
                        exec_list *const f299F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f299F->then_instructions;

                           body.emit(assign(r299A, r2945, 0x01));

                           body.emit(assign(r299B, r2944, 0x01));

                           body.emit(assign(r299C, r2943, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f299F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r29A2 = less(r2999, body.constant(int(32)));
                           ir_if *f29A1 = new(mem_ctx) ir_if(operand(r29A2).val);
                           exec_list *const f29A1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29A1->then_instructions;

                              body.emit(assign(r299A, lshift(r2944, r299D), 0x01));

                              ir_expression *const r29A3 = lshift(r2943, r299D);
                              ir_expression *const r29A4 = rshift(r2944, r2999);
                              body.emit(assign(r299B, bit_or(r29A3, r29A4), 0x01));

                              body.emit(assign(r299C, rshift(r2943, r2999), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29A1->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r29A6 = equal(r2999, body.constant(int(32)));
                              ir_if *f29A5 = new(mem_ctx) ir_if(operand(r29A6).val);
                              exec_list *const f29A5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29A5->then_instructions;

                                 body.emit(assign(r299A, r2944, 0x01));

                                 body.emit(assign(r299B, r2943, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f29A5->else_instructions;

                                 body.emit(assign(r2998, bit_or(r2945, r2944), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r29A8 = less(r2999, body.constant(int(64)));
                                 ir_if *f29A7 = new(mem_ctx) ir_if(operand(r29A8).val);
                                 exec_list *const f29A7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f29A7->then_instructions;

                                    body.emit(assign(r299A, lshift(r2943, r299D), 0x01));

                                    ir_expression *const r29A9 = bit_and(r2999, body.constant(int(31)));
                                    body.emit(assign(r299B, rshift(r2943, r29A9), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f29A7->else_instructions;

                                    ir_variable *const r29AA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r29AC = equal(r2999, body.constant(int(64)));
                                    ir_if *f29AB = new(mem_ctx) ir_if(operand(r29AC).val);
                                    exec_list *const f29AB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f29AB->then_instructions;

                                       body.emit(assign(r29AA, r2943, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f29AB->else_instructions;

                                       ir_expression *const r29AD = nequal(r2943, body.constant(0u));
                                       ir_expression *const r29AE = expr(ir_unop_b2i, r29AD);
                                       body.emit(assign(r29AA, expr(ir_unop_i2u, r29AE), 0x01));


                                    body.instructions = f29AB_parent_instructions;
                                    body.emit(f29AB);

                                    /* END IF */

                                    body.emit(assign(r299A, r29AA, 0x01));

                                    body.emit(assign(r299B, body.constant(0u), 0x01));


                                 body.instructions = f29A7_parent_instructions;
                                 body.emit(f29A7);

                                 /* END IF */


                              body.instructions = f29A5_parent_instructions;
                              body.emit(f29A5);

                              /* END IF */

                              body.emit(assign(r299C, body.constant(0u), 0x01));


                           body.instructions = f29A1_parent_instructions;
                           body.emit(f29A1);

                           /* END IF */

                           ir_expression *const r29AF = nequal(r2998, body.constant(0u));
                           ir_expression *const r29B0 = expr(ir_unop_b2i, r29AF);
                           ir_expression *const r29B1 = expr(ir_unop_i2u, r29B0);
                           body.emit(assign(r299A, bit_or(r299A, r29B1), 0x01));


                        body.instructions = f299F_parent_instructions;
                        body.emit(f299F);

                        /* END IF */

                        body.emit(assign(r2982, r299C, 0x01));

                        body.emit(assign(r2983, r299B, 0x01));

                        body.emit(assign(r2984, r299A, 0x01));

                        body.emit(assign(r2981, body.constant(int(0)), 0x01));

                        body.emit(assign(r2987, less(r299A, body.constant(0u)), 0x01));


                     body.instructions = f2996_parent_instructions;
                     body.emit(f2996);

                     /* END IF */


                  body.instructions = f2993_parent_instructions;
                  body.emit(f2993);

                  /* END IF */


               body.instructions = f2989_parent_instructions;
               body.emit(f2989);

               /* END IF */

               /* IF CONDITION */
               ir_if *f29B2 = new(mem_ctx) ir_if(operand(r2985).val);
               exec_list *const f29B2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29B2->then_instructions;

                  /* IF CONDITION */
                  ir_if *f29B3 = new(mem_ctx) ir_if(operand(r2987).val);
                  exec_list *const f29B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f29B3->then_instructions;

                     ir_variable *const r29B4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r29B4, add(r2983, body.constant(1u)), 0x01));

                     ir_expression *const r29B5 = less(r29B4, r2983);
                     ir_expression *const r29B6 = expr(ir_unop_b2i, r29B5);
                     ir_expression *const r29B7 = expr(ir_unop_i2u, r29B6);
                     body.emit(assign(r2982, add(r2982, r29B7), 0x01));

                     ir_expression *const r29B8 = equal(r2984, body.constant(0u));
                     ir_expression *const r29B9 = expr(ir_unop_b2i, r29B8);
                     ir_expression *const r29BA = expr(ir_unop_i2u, r29B9);
                     ir_expression *const r29BB = add(r2984, r29BA);
                     ir_expression *const r29BC = bit_and(r29BB, body.constant(1u));
                     ir_expression *const r29BD = expr(ir_unop_bit_not, r29BC);
                     body.emit(assign(r2983, bit_and(r29B4, r29BD), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f29B3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r29BF = bit_or(r2982, r2983);
                     ir_expression *const r29C0 = equal(r29BF, body.constant(0u));
                     ir_if *f29BE = new(mem_ctx) ir_if(operand(r29C0).val);
                     exec_list *const f29BE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f29BE->then_instructions;

                        body.emit(assign(r2981, body.constant(int(0)), 0x01));


                     body.instructions = f29BE_parent_instructions;
                     body.emit(f29BE);

                     /* END IF */


                  body.instructions = f29B3_parent_instructions;
                  body.emit(f29B3);

                  /* END IF */

                  ir_variable *const r29C1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r29C1);
                  ir_expression *const r29C2 = lshift(r28FE, body.constant(int(31)));
                  ir_expression *const r29C3 = expr(ir_unop_i2u, r2981);
                  ir_expression *const r29C4 = lshift(r29C3, body.constant(int(20)));
                  ir_expression *const r29C5 = add(r29C2, r29C4);
                  body.emit(assign(r29C1, add(r29C5, r2982), 0x02));

                  body.emit(assign(r29C1, r2983, 0x01));

                  body.emit(assign(r2986, r29C1, 0x03));

                  body.emit(assign(r2985, body.constant(false), 0x01));


               body.instructions = f29B2_parent_instructions;
               body.emit(f29B2);

               /* END IF */

               body.emit(assign(r2902, r2986, 0x03));


            body.instructions = f2915_parent_instructions;
            body.emit(f2915);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2913->else_instructions;

            /* IF CONDITION */
            ir_expression *const r29C7 = less(r2903, body.constant(int(0)));
            ir_if *f29C6 = new(mem_ctx) ir_if(operand(r29C7).val);
            exec_list *const f29C6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f29C6->then_instructions;

               /* IF CONDITION */
               ir_expression *const r29C9 = equal(r290A, body.constant(int(0)));
               ir_if *f29C8 = new(mem_ctx) ir_if(operand(r29C9).val);
               exec_list *const f29C8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29C8->then_instructions;

                  body.emit(assign(r2903, add(r2903, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f29C8->else_instructions;

                  body.emit(assign(r2907, bit_or(swizzle_y(r2907), body.constant(1073741824u)), 0x02));


               body.instructions = f29C8_parent_instructions;
               body.emit(f29C8);

               /* END IF */

               ir_variable *const r29CA = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r29CA, swizzle_y(r2907), 0x01));

               ir_variable *const r29CB = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r29CB, swizzle_x(r2907), 0x01));

               ir_variable *const r29CC = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r29CC, neg(r2903), 0x01));

               ir_variable *const r29CD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r29CD);
               ir_variable *const r29CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r29CE);
               ir_variable *const r29CF = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r29D0 = neg(r29CC);
               body.emit(assign(r29CF, bit_and(r29D0, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r29D2 = equal(r29CC, body.constant(int(0)));
               ir_if *f29D1 = new(mem_ctx) ir_if(operand(r29D2).val);
               exec_list *const f29D1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29D1->then_instructions;

                  body.emit(assign(r29CD, r29CB, 0x01));

                  body.emit(assign(r29CE, r29CA, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f29D1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r29D4 = less(r29CC, body.constant(int(32)));
                  ir_if *f29D3 = new(mem_ctx) ir_if(operand(r29D4).val);
                  exec_list *const f29D3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f29D3->then_instructions;

                     ir_expression *const r29D5 = lshift(swizzle_y(r2907), r29CF);
                     ir_expression *const r29D6 = rshift(r290E, r29CC);
                     ir_expression *const r29D7 = bit_or(r29D5, r29D6);
                     ir_expression *const r29D8 = lshift(r290E, r29CF);
                     ir_expression *const r29D9 = nequal(r29D8, body.constant(0u));
                     ir_expression *const r29DA = expr(ir_unop_b2i, r29D9);
                     ir_expression *const r29DB = expr(ir_unop_i2u, r29DA);
                     body.emit(assign(r29CD, bit_or(r29D7, r29DB), 0x01));

                     body.emit(assign(r29CE, rshift(swizzle_y(r2907), r29CC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f29D3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r29DD = equal(r29CC, body.constant(int(32)));
                     ir_if *f29DC = new(mem_ctx) ir_if(operand(r29DD).val);
                     exec_list *const f29DC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f29DC->then_instructions;

                        ir_expression *const r29DE = nequal(r290E, body.constant(0u));
                        ir_expression *const r29DF = expr(ir_unop_b2i, r29DE);
                        ir_expression *const r29E0 = expr(ir_unop_i2u, r29DF);
                        body.emit(assign(r29CD, bit_or(swizzle_y(r2907), r29E0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f29DC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r29E2 = less(r29CC, body.constant(int(64)));
                        ir_if *f29E1 = new(mem_ctx) ir_if(operand(r29E2).val);
                        exec_list *const f29E1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29E1->then_instructions;

                           ir_expression *const r29E3 = bit_and(r29CC, body.constant(int(31)));
                           ir_expression *const r29E4 = rshift(swizzle_y(r2907), r29E3);
                           ir_expression *const r29E5 = lshift(swizzle_y(r2907), r29CF);
                           ir_expression *const r29E6 = bit_or(r29E5, r290E);
                           ir_expression *const r29E7 = nequal(r29E6, body.constant(0u));
                           ir_expression *const r29E8 = expr(ir_unop_b2i, r29E7);
                           ir_expression *const r29E9 = expr(ir_unop_i2u, r29E8);
                           body.emit(assign(r29CD, bit_or(r29E4, r29E9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f29E1->else_instructions;

                           ir_expression *const r29EA = bit_or(swizzle_y(r2907), r290E);
                           ir_expression *const r29EB = nequal(r29EA, body.constant(0u));
                           ir_expression *const r29EC = expr(ir_unop_b2i, r29EB);
                           body.emit(assign(r29CD, expr(ir_unop_i2u, r29EC), 0x01));


                        body.instructions = f29E1_parent_instructions;
                        body.emit(f29E1);

                        /* END IF */


                     body.instructions = f29DC_parent_instructions;
                     body.emit(f29DC);

                     /* END IF */

                     body.emit(assign(r29CE, body.constant(0u), 0x01));


                  body.instructions = f29D3_parent_instructions;
                  body.emit(f29D3);

                  /* END IF */


               body.instructions = f29D1_parent_instructions;
               body.emit(f29D1);

               /* END IF */

               body.emit(assign(r2907, r29CE, 0x02));

               body.emit(assign(r2907, r29CD, 0x01));

               body.emit(assign(r2905, bit_or(swizzle_y(r2905), body.constant(1073741824u)), 0x02));

               ir_variable *const r29ED = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r29EE = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r29EE, sub(swizzle_x(r2905), r29CD), 0x01));

               ir_expression *const r29EF = sub(swizzle_y(r2905), r29CE);
               ir_expression *const r29F0 = less(swizzle_x(r2905), r29CD);
               ir_expression *const r29F1 = expr(ir_unop_b2i, r29F0);
               ir_expression *const r29F2 = expr(ir_unop_i2u, r29F1);
               body.emit(assign(r29ED, sub(r29EF, r29F2), 0x01));

               body.emit(assign(r2901, bit_xor(r28FE, body.constant(1u)), 0x01));

               body.emit(assign(r2908, body.constant(int(1022)), 0x01));

               ir_variable *const r29F3 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r29F3, body.constant(int(1012)), 0x01));

               ir_variable *const r29F4 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r29F4, r29ED, 0x01));

               ir_variable *const r29F5 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r29F5, r29EE, 0x01));

               ir_variable *const r29F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r29F6);
               ir_variable *const r29F7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r29F7);
               /* IF CONDITION */
               ir_expression *const r29F9 = equal(r29ED, body.constant(0u));
               ir_if *f29F8 = new(mem_ctx) ir_if(operand(r29F9).val);
               exec_list *const f29F8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29F8->then_instructions;

                  body.emit(assign(r29F4, r29EE, 0x01));

                  body.emit(assign(r29F5, body.constant(0u), 0x01));

                  body.emit(assign(r29F3, body.constant(int(980)), 0x01));


               body.instructions = f29F8_parent_instructions;
               body.emit(f29F8);

               /* END IF */

               ir_variable *const r29FA = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r29FA, r29F4, 0x01));

               ir_variable *const r29FB = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r29FC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r29FC);
               /* IF CONDITION */
               ir_expression *const r29FE = equal(r29F4, body.constant(0u));
               ir_if *f29FD = new(mem_ctx) ir_if(operand(r29FE).val);
               exec_list *const f29FD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29FD->then_instructions;

                  body.emit(assign(r29FB, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f29FD->else_instructions;

                  body.emit(assign(r29FC, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2A00 = bit_and(r29F4, body.constant(4294901760u));
                  ir_expression *const r2A01 = equal(r2A00, body.constant(0u));
                  ir_if *f29FF = new(mem_ctx) ir_if(operand(r2A01).val);
                  exec_list *const f29FF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f29FF->then_instructions;

                     body.emit(assign(r29FC, body.constant(int(16)), 0x01));

                     body.emit(assign(r29FA, lshift(r29F4, body.constant(int(16))), 0x01));


                  body.instructions = f29FF_parent_instructions;
                  body.emit(f29FF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A03 = bit_and(r29FA, body.constant(4278190080u));
                  ir_expression *const r2A04 = equal(r2A03, body.constant(0u));
                  ir_if *f2A02 = new(mem_ctx) ir_if(operand(r2A04).val);
                  exec_list *const f2A02_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A02->then_instructions;

                     body.emit(assign(r29FC, add(r29FC, body.constant(int(8))), 0x01));

                     body.emit(assign(r29FA, lshift(r29FA, body.constant(int(8))), 0x01));


                  body.instructions = f2A02_parent_instructions;
                  body.emit(f2A02);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A06 = bit_and(r29FA, body.constant(4026531840u));
                  ir_expression *const r2A07 = equal(r2A06, body.constant(0u));
                  ir_if *f2A05 = new(mem_ctx) ir_if(operand(r2A07).val);
                  exec_list *const f2A05_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A05->then_instructions;

                     body.emit(assign(r29FC, add(r29FC, body.constant(int(4))), 0x01));

                     body.emit(assign(r29FA, lshift(r29FA, body.constant(int(4))), 0x01));


                  body.instructions = f2A05_parent_instructions;
                  body.emit(f2A05);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A09 = bit_and(r29FA, body.constant(3221225472u));
                  ir_expression *const r2A0A = equal(r2A09, body.constant(0u));
                  ir_if *f2A08 = new(mem_ctx) ir_if(operand(r2A0A).val);
                  exec_list *const f2A08_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A08->then_instructions;

                     body.emit(assign(r29FC, add(r29FC, body.constant(int(2))), 0x01));

                     body.emit(assign(r29FA, lshift(r29FA, body.constant(int(2))), 0x01));


                  body.instructions = f2A08_parent_instructions;
                  body.emit(f2A08);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A0C = bit_and(r29FA, body.constant(2147483648u));
                  ir_expression *const r2A0D = equal(r2A0C, body.constant(0u));
                  ir_if *f2A0B = new(mem_ctx) ir_if(operand(r2A0D).val);
                  exec_list *const f2A0B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A0B->then_instructions;

                     body.emit(assign(r29FC, add(r29FC, body.constant(int(1))), 0x01));


                  body.instructions = f2A0B_parent_instructions;
                  body.emit(f2A0B);

                  /* END IF */

                  body.emit(assign(r29FB, r29FC, 0x01));


               body.instructions = f29FD_parent_instructions;
               body.emit(f29FD);

               /* END IF */

               body.emit(assign(r29F7, add(r29FB, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2A0F = lequal(body.constant(int(0)), r29F7);
               ir_if *f2A0E = new(mem_ctx) ir_if(operand(r2A0F).val);
               exec_list *const f2A0E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A0E->then_instructions;

                  body.emit(assign(r29F6, body.constant(0u), 0x01));

                  ir_variable *const r2A10 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2A10, lshift(r29F5, r29F7), 0x01));

                  ir_variable *const r2A11 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2A13 = equal(r29F7, body.constant(int(0)));
                  ir_if *f2A12 = new(mem_ctx) ir_if(operand(r2A13).val);
                  exec_list *const f2A12_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A12->then_instructions;

                     body.emit(assign(r2A11, r29F4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A12->else_instructions;

                     ir_expression *const r2A14 = lshift(r29F4, r29F7);
                     ir_expression *const r2A15 = neg(r29F7);
                     ir_expression *const r2A16 = bit_and(r2A15, body.constant(int(31)));
                     ir_expression *const r2A17 = rshift(r29F5, r2A16);
                     body.emit(assign(r2A11, bit_or(r2A14, r2A17), 0x01));


                  body.instructions = f2A12_parent_instructions;
                  body.emit(f2A12);

                  /* END IF */

                  body.emit(assign(r29F4, r2A11, 0x01));

                  body.emit(assign(r29F5, r2A10, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2A0E->else_instructions;

                  ir_variable *const r2A18 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2A18, body.constant(0u), 0x01));

                  ir_variable *const r2A19 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2A19, neg(r29F7), 0x01));

                  ir_variable *const r2A1A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2A1A);
                  ir_variable *const r2A1B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2A1B);
                  ir_variable *const r2A1C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2A1C);
                  ir_variable *const r2A1D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2A1E = neg(r2A19);
                  body.emit(assign(r2A1D, bit_and(r2A1E, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2A20 = equal(r2A19, body.constant(int(0)));
                  ir_if *f2A1F = new(mem_ctx) ir_if(operand(r2A20).val);
                  exec_list *const f2A1F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A1F->then_instructions;

                     body.emit(assign(r2A1A, r2A18, 0x01));

                     body.emit(assign(r2A1B, r29F5, 0x01));

                     body.emit(assign(r2A1C, r29F4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A1F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2A22 = less(r2A19, body.constant(int(32)));
                     ir_if *f2A21 = new(mem_ctx) ir_if(operand(r2A22).val);
                     exec_list *const f2A21_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A21->then_instructions;

                        body.emit(assign(r2A1A, lshift(r29F5, r2A1D), 0x01));

                        ir_expression *const r2A23 = lshift(r29F4, r2A1D);
                        ir_expression *const r2A24 = rshift(r29F5, r2A19);
                        body.emit(assign(r2A1B, bit_or(r2A23, r2A24), 0x01));

                        body.emit(assign(r2A1C, rshift(r29F4, r2A19), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2A21->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2A26 = equal(r2A19, body.constant(int(32)));
                        ir_if *f2A25 = new(mem_ctx) ir_if(operand(r2A26).val);
                        exec_list *const f2A25_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2A25->then_instructions;

                           body.emit(assign(r2A1A, r29F5, 0x01));

                           body.emit(assign(r2A1B, r29F4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2A25->else_instructions;

                           body.emit(assign(r2A18, bit_or(body.constant(0u), r29F5), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2A28 = less(r2A19, body.constant(int(64)));
                           ir_if *f2A27 = new(mem_ctx) ir_if(operand(r2A28).val);
                           exec_list *const f2A27_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A27->then_instructions;

                              body.emit(assign(r2A1A, lshift(r29F4, r2A1D), 0x01));

                              ir_expression *const r2A29 = bit_and(r2A19, body.constant(int(31)));
                              body.emit(assign(r2A1B, rshift(r29F4, r2A29), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A27->else_instructions;

                              ir_variable *const r2A2A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2A2C = equal(r2A19, body.constant(int(64)));
                              ir_if *f2A2B = new(mem_ctx) ir_if(operand(r2A2C).val);
                              exec_list *const f2A2B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A2B->then_instructions;

                                 body.emit(assign(r2A2A, r29F4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A2B->else_instructions;

                                 ir_expression *const r2A2D = nequal(r29F4, body.constant(0u));
                                 ir_expression *const r2A2E = expr(ir_unop_b2i, r2A2D);
                                 body.emit(assign(r2A2A, expr(ir_unop_i2u, r2A2E), 0x01));


                              body.instructions = f2A2B_parent_instructions;
                              body.emit(f2A2B);

                              /* END IF */

                              body.emit(assign(r2A1A, r2A2A, 0x01));

                              body.emit(assign(r2A1B, body.constant(0u), 0x01));


                           body.instructions = f2A27_parent_instructions;
                           body.emit(f2A27);

                           /* END IF */


                        body.instructions = f2A25_parent_instructions;
                        body.emit(f2A25);

                        /* END IF */

                        body.emit(assign(r2A1C, body.constant(0u), 0x01));


                     body.instructions = f2A21_parent_instructions;
                     body.emit(f2A21);

                     /* END IF */

                     ir_expression *const r2A2F = nequal(r2A18, body.constant(0u));
                     ir_expression *const r2A30 = expr(ir_unop_b2i, r2A2F);
                     ir_expression *const r2A31 = expr(ir_unop_i2u, r2A30);
                     body.emit(assign(r2A1A, bit_or(r2A1A, r2A31), 0x01));


                  body.instructions = f2A1F_parent_instructions;
                  body.emit(f2A1F);

                  /* END IF */

                  body.emit(assign(r29F4, r2A1C, 0x01));

                  body.emit(assign(r29F5, r2A1B, 0x01));

                  body.emit(assign(r29F6, r2A1A, 0x01));


               body.instructions = f2A0E_parent_instructions;
               body.emit(f2A0E);

               /* END IF */

               body.emit(assign(r29F3, sub(r29F3, r29F7), 0x01));

               ir_variable *const r2A32 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2A32, r29F3, 0x01));

               ir_variable *const r2A33 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2A33, r29F4, 0x01));

               ir_variable *const r2A34 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2A34, r29F5, 0x01));

               ir_variable *const r2A35 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2A35, r29F6, 0x01));

               ir_variable *const r2A36 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2A36, body.constant(true), 0x01));

               ir_variable *const r2A37 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2A38 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2A38);
               ir_expression *const r2A39 = expr(ir_unop_u2i, r29F6);
               body.emit(assign(r2A38, less(r2A39, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2A3B = lequal(body.constant(int(2045)), r29F3);
               ir_if *f2A3A = new(mem_ctx) ir_if(operand(r2A3B).val);
               exec_list *const f2A3A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A3A->then_instructions;

                  ir_variable *const r2A3C = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2A3E = less(body.constant(int(2045)), r29F3);
                  ir_if *f2A3D = new(mem_ctx) ir_if(operand(r2A3E).val);
                  exec_list *const f2A3D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A3D->then_instructions;

                     body.emit(assign(r2A3C, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A3D->else_instructions;

                     ir_variable *const r2A3F = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2A41 = equal(r29F3, body.constant(int(2045)));
                     ir_if *f2A40 = new(mem_ctx) ir_if(operand(r2A41).val);
                     exec_list *const f2A40_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A40->then_instructions;

                        ir_expression *const r2A42 = equal(body.constant(2097151u), r29F4);
                        ir_expression *const r2A43 = equal(body.constant(4294967295u), r29F5);
                        body.emit(assign(r2A3F, logic_and(r2A42, r2A43), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2A40->else_instructions;

                        body.emit(assign(r2A3F, body.constant(false), 0x01));


                     body.instructions = f2A40_parent_instructions;
                     body.emit(f2A40);

                     /* END IF */

                     body.emit(assign(r2A3C, logic_and(r2A3F, r2A38), 0x01));


                  body.instructions = f2A3D_parent_instructions;
                  body.emit(f2A3D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2A44 = new(mem_ctx) ir_if(operand(r2A3C).val);
                  exec_list *const f2A44_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A44->then_instructions;

                     ir_variable *const r2A45 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2A45);
                     ir_expression *const r2A46 = lshift(r2901, body.constant(int(31)));
                     body.emit(assign(r2A45, add(r2A46, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2A45, body.constant(0u), 0x01));

                     body.emit(assign(r2A37, r2A45, 0x03));

                     body.emit(assign(r2A36, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A44->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2A48 = less(r29F3, body.constant(int(0)));
                     ir_if *f2A47 = new(mem_ctx) ir_if(operand(r2A48).val);
                     exec_list *const f2A47_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A47->then_instructions;

                        ir_variable *const r2A49 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2A49, r29F6, 0x01));

                        ir_variable *const r2A4A = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2A4A, neg(r29F3), 0x01));

                        ir_variable *const r2A4B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2A4B);
                        ir_variable *const r2A4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2A4C);
                        ir_variable *const r2A4D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2A4D);
                        ir_variable *const r2A4E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2A4F = neg(r2A4A);
                        body.emit(assign(r2A4E, bit_and(r2A4F, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2A51 = equal(r2A4A, body.constant(int(0)));
                        ir_if *f2A50 = new(mem_ctx) ir_if(operand(r2A51).val);
                        exec_list *const f2A50_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2A50->then_instructions;

                           body.emit(assign(r2A4B, r29F6, 0x01));

                           body.emit(assign(r2A4C, r29F5, 0x01));

                           body.emit(assign(r2A4D, r29F4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2A50->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2A53 = less(r2A4A, body.constant(int(32)));
                           ir_if *f2A52 = new(mem_ctx) ir_if(operand(r2A53).val);
                           exec_list *const f2A52_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A52->then_instructions;

                              body.emit(assign(r2A4B, lshift(r29F5, r2A4E), 0x01));

                              ir_expression *const r2A54 = lshift(r29F4, r2A4E);
                              ir_expression *const r2A55 = rshift(r29F5, r2A4A);
                              body.emit(assign(r2A4C, bit_or(r2A54, r2A55), 0x01));

                              body.emit(assign(r2A4D, rshift(r29F4, r2A4A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A52->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2A57 = equal(r2A4A, body.constant(int(32)));
                              ir_if *f2A56 = new(mem_ctx) ir_if(operand(r2A57).val);
                              exec_list *const f2A56_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A56->then_instructions;

                                 body.emit(assign(r2A4B, r29F5, 0x01));

                                 body.emit(assign(r2A4C, r29F4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A56->else_instructions;

                                 body.emit(assign(r2A49, bit_or(r29F6, r29F5), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2A59 = less(r2A4A, body.constant(int(64)));
                                 ir_if *f2A58 = new(mem_ctx) ir_if(operand(r2A59).val);
                                 exec_list *const f2A58_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A58->then_instructions;

                                    body.emit(assign(r2A4B, lshift(r29F4, r2A4E), 0x01));

                                    ir_expression *const r2A5A = bit_and(r2A4A, body.constant(int(31)));
                                    body.emit(assign(r2A4C, rshift(r29F4, r2A5A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A58->else_instructions;

                                    ir_variable *const r2A5B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2A5D = equal(r2A4A, body.constant(int(64)));
                                    ir_if *f2A5C = new(mem_ctx) ir_if(operand(r2A5D).val);
                                    exec_list *const f2A5C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2A5C->then_instructions;

                                       body.emit(assign(r2A5B, r29F4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2A5C->else_instructions;

                                       ir_expression *const r2A5E = nequal(r29F4, body.constant(0u));
                                       ir_expression *const r2A5F = expr(ir_unop_b2i, r2A5E);
                                       body.emit(assign(r2A5B, expr(ir_unop_i2u, r2A5F), 0x01));


                                    body.instructions = f2A5C_parent_instructions;
                                    body.emit(f2A5C);

                                    /* END IF */

                                    body.emit(assign(r2A4B, r2A5B, 0x01));

                                    body.emit(assign(r2A4C, body.constant(0u), 0x01));


                                 body.instructions = f2A58_parent_instructions;
                                 body.emit(f2A58);

                                 /* END IF */


                              body.instructions = f2A56_parent_instructions;
                              body.emit(f2A56);

                              /* END IF */

                              body.emit(assign(r2A4D, body.constant(0u), 0x01));


                           body.instructions = f2A52_parent_instructions;
                           body.emit(f2A52);

                           /* END IF */

                           ir_expression *const r2A60 = nequal(r2A49, body.constant(0u));
                           ir_expression *const r2A61 = expr(ir_unop_b2i, r2A60);
                           ir_expression *const r2A62 = expr(ir_unop_i2u, r2A61);
                           body.emit(assign(r2A4B, bit_or(r2A4B, r2A62), 0x01));


                        body.instructions = f2A50_parent_instructions;
                        body.emit(f2A50);

                        /* END IF */

                        body.emit(assign(r2A33, r2A4D, 0x01));

                        body.emit(assign(r2A34, r2A4C, 0x01));

                        body.emit(assign(r2A35, r2A4B, 0x01));

                        body.emit(assign(r2A32, body.constant(int(0)), 0x01));

                        body.emit(assign(r2A38, less(r2A4B, body.constant(0u)), 0x01));


                     body.instructions = f2A47_parent_instructions;
                     body.emit(f2A47);

                     /* END IF */


                  body.instructions = f2A44_parent_instructions;
                  body.emit(f2A44);

                  /* END IF */


               body.instructions = f2A3A_parent_instructions;
               body.emit(f2A3A);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2A63 = new(mem_ctx) ir_if(operand(r2A36).val);
               exec_list *const f2A63_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A63->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2A64 = new(mem_ctx) ir_if(operand(r2A38).val);
                  exec_list *const f2A64_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A64->then_instructions;

                     ir_variable *const r2A65 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2A65, add(r2A34, body.constant(1u)), 0x01));

                     ir_expression *const r2A66 = less(r2A65, r2A34);
                     ir_expression *const r2A67 = expr(ir_unop_b2i, r2A66);
                     ir_expression *const r2A68 = expr(ir_unop_i2u, r2A67);
                     body.emit(assign(r2A33, add(r2A33, r2A68), 0x01));

                     ir_expression *const r2A69 = equal(r2A35, body.constant(0u));
                     ir_expression *const r2A6A = expr(ir_unop_b2i, r2A69);
                     ir_expression *const r2A6B = expr(ir_unop_i2u, r2A6A);
                     ir_expression *const r2A6C = add(r2A35, r2A6B);
                     ir_expression *const r2A6D = bit_and(r2A6C, body.constant(1u));
                     ir_expression *const r2A6E = expr(ir_unop_bit_not, r2A6D);
                     body.emit(assign(r2A34, bit_and(r2A65, r2A6E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A64->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2A70 = bit_or(r2A33, r2A34);
                     ir_expression *const r2A71 = equal(r2A70, body.constant(0u));
                     ir_if *f2A6F = new(mem_ctx) ir_if(operand(r2A71).val);
                     exec_list *const f2A6F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A6F->then_instructions;

                        body.emit(assign(r2A32, body.constant(int(0)), 0x01));


                     body.instructions = f2A6F_parent_instructions;
                     body.emit(f2A6F);

                     /* END IF */


                  body.instructions = f2A64_parent_instructions;
                  body.emit(f2A64);

                  /* END IF */

                  ir_variable *const r2A72 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2A72);
                  ir_expression *const r2A73 = lshift(r2901, body.constant(int(31)));
                  ir_expression *const r2A74 = expr(ir_unop_i2u, r2A32);
                  ir_expression *const r2A75 = lshift(r2A74, body.constant(int(20)));
                  ir_expression *const r2A76 = add(r2A73, r2A75);
                  body.emit(assign(r2A72, add(r2A76, r2A33), 0x02));

                  body.emit(assign(r2A72, r2A34, 0x01));

                  body.emit(assign(r2A37, r2A72, 0x03));

                  body.emit(assign(r2A36, body.constant(false), 0x01));


               body.instructions = f2A63_parent_instructions;
               body.emit(f2A63);

               /* END IF */

               body.emit(assign(r2902, r2A37, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f29C6->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2A78 = equal(r290A, body.constant(int(2047)));
               ir_if *f2A77 = new(mem_ctx) ir_if(operand(r2A78).val);
               exec_list *const f2A77_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A77->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2A7A = bit_or(swizzle_y(r2907), swizzle_x(r2907));
                  ir_expression *const r2A7B = bit_or(swizzle_y(r2905), swizzle_x(r2905));
                  ir_expression *const r2A7C = bit_or(r2A7A, r2A7B);
                  ir_expression *const r2A7D = nequal(r2A7C, body.constant(0u));
                  ir_if *f2A79 = new(mem_ctx) ir_if(operand(r2A7D).val);
                  exec_list *const f2A79_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A79->then_instructions;

                     ir_variable *const r2A7E = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2A7E, swizzle_x(r28C8), 0x01));

                     ir_variable *const r2A7F = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2A7F, body.constant(0u), 0x01));

                     ir_variable *const r2A80 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2A7E, bit_or(swizzle_y(r28C8), body.constant(524288u)), 0x02));

                     body.emit(assign(r2A7F, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2A82 = lshift(swizzle_y(r28C8), body.constant(int(1)));
                     ir_expression *const r2A83 = lequal(body.constant(4292870144u), r2A82);
                     ir_expression *const r2A84 = nequal(swizzle_x(r28C8), body.constant(0u));
                     ir_expression *const r2A85 = bit_and(swizzle_y(r28C8), body.constant(1048575u));
                     ir_expression *const r2A86 = nequal(r2A85, body.constant(0u));
                     ir_expression *const r2A87 = logic_or(r2A84, r2A86);
                     ir_expression *const r2A88 = logic_and(r2A83, r2A87);
                     ir_if *f2A81 = new(mem_ctx) ir_if(operand(r2A88).val);
                     exec_list *const f2A81_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A81->then_instructions;

                        body.emit(assign(r2A80, r2A7E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2A81->else_instructions;

                        body.emit(assign(r2A80, r2A7F, 0x03));


                     body.instructions = f2A81_parent_instructions;
                     body.emit(f2A81);

                     /* END IF */

                     body.emit(assign(r2902, r2A80, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A79->else_instructions;

                     ir_constant_data r2A89_data;
                     memset(&r2A89_data, 0, sizeof(ir_constant_data));
                     r2A89_data.u[0] = 4294967295;
                     r2A89_data.u[1] = 4294967295;
                     ir_constant *const r2A89 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r2A89_data);
                     body.emit(assign(r2902, r2A89, 0x03));


                  body.instructions = f2A79_parent_instructions;
                  body.emit(f2A79);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2A77->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2A8B = equal(r290A, body.constant(int(0)));
                  ir_if *f2A8A = new(mem_ctx) ir_if(operand(r2A8B).val);
                  exec_list *const f2A8A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A8A->then_instructions;

                     body.emit(assign(r2906, body.constant(int(1)), 0x01));

                     body.emit(assign(r2904, body.constant(int(1)), 0x01));


                  body.instructions = f2A8A_parent_instructions;
                  body.emit(f2A8A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A8D = less(swizzle_y(r2905), swizzle_y(r2907));
                  ir_if *f2A8C = new(mem_ctx) ir_if(operand(r2A8D).val);
                  exec_list *const f2A8C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A8C->then_instructions;

                     ir_variable *const r2A8E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r2A8F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2A8F, sub(swizzle_x(r2907), swizzle_x(r2905)), 0x01));

                     ir_expression *const r2A90 = sub(swizzle_y(r2907), swizzle_y(r2905));
                     ir_expression *const r2A91 = less(swizzle_x(r2907), swizzle_x(r2905));
                     ir_expression *const r2A92 = expr(ir_unop_b2i, r2A91);
                     ir_expression *const r2A93 = expr(ir_unop_i2u, r2A92);
                     body.emit(assign(r2A8E, sub(r2A90, r2A93), 0x01));

                     body.emit(assign(r2908, add(r2906, body.constant(int(-1))), 0x01));

                     ir_variable *const r2A94 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2A94, add(r2908, body.constant(int(-10))), 0x01));

                     ir_variable *const r2A95 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2A95, r2A8E, 0x01));

                     ir_variable *const r2A96 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2A96, r2A8F, 0x01));

                     ir_variable *const r2A97 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r2A97);
                     ir_variable *const r2A98 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2A98);
                     /* IF CONDITION */
                     ir_expression *const r2A9A = equal(r2A8E, body.constant(0u));
                     ir_if *f2A99 = new(mem_ctx) ir_if(operand(r2A9A).val);
                     exec_list *const f2A99_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A99->then_instructions;

                        body.emit(assign(r2A95, r2A8F, 0x01));

                        body.emit(assign(r2A96, body.constant(0u), 0x01));

                        body.emit(assign(r2A94, add(r2A94, body.constant(int(-32))), 0x01));


                     body.instructions = f2A99_parent_instructions;
                     body.emit(f2A99);

                     /* END IF */

                     ir_variable *const r2A9B = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r2A9B, r2A95, 0x01));

                     ir_variable *const r2A9C = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r2A9D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2A9D);
                     /* IF CONDITION */
                     ir_expression *const r2A9F = equal(r2A95, body.constant(0u));
                     ir_if *f2A9E = new(mem_ctx) ir_if(operand(r2A9F).val);
                     exec_list *const f2A9E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A9E->then_instructions;

                        body.emit(assign(r2A9C, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2A9E->else_instructions;

                        body.emit(assign(r2A9D, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2AA1 = bit_and(r2A95, body.constant(4294901760u));
                        ir_expression *const r2AA2 = equal(r2AA1, body.constant(0u));
                        ir_if *f2AA0 = new(mem_ctx) ir_if(operand(r2AA2).val);
                        exec_list *const f2AA0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AA0->then_instructions;

                           body.emit(assign(r2A9D, body.constant(int(16)), 0x01));

                           body.emit(assign(r2A9B, lshift(r2A95, body.constant(int(16))), 0x01));


                        body.instructions = f2AA0_parent_instructions;
                        body.emit(f2AA0);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2AA4 = bit_and(r2A9B, body.constant(4278190080u));
                        ir_expression *const r2AA5 = equal(r2AA4, body.constant(0u));
                        ir_if *f2AA3 = new(mem_ctx) ir_if(operand(r2AA5).val);
                        exec_list *const f2AA3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AA3->then_instructions;

                           body.emit(assign(r2A9D, add(r2A9D, body.constant(int(8))), 0x01));

                           body.emit(assign(r2A9B, lshift(r2A9B, body.constant(int(8))), 0x01));


                        body.instructions = f2AA3_parent_instructions;
                        body.emit(f2AA3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2AA7 = bit_and(r2A9B, body.constant(4026531840u));
                        ir_expression *const r2AA8 = equal(r2AA7, body.constant(0u));
                        ir_if *f2AA6 = new(mem_ctx) ir_if(operand(r2AA8).val);
                        exec_list *const f2AA6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AA6->then_instructions;

                           body.emit(assign(r2A9D, add(r2A9D, body.constant(int(4))), 0x01));

                           body.emit(assign(r2A9B, lshift(r2A9B, body.constant(int(4))), 0x01));


                        body.instructions = f2AA6_parent_instructions;
                        body.emit(f2AA6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2AAA = bit_and(r2A9B, body.constant(3221225472u));
                        ir_expression *const r2AAB = equal(r2AAA, body.constant(0u));
                        ir_if *f2AA9 = new(mem_ctx) ir_if(operand(r2AAB).val);
                        exec_list *const f2AA9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AA9->then_instructions;

                           body.emit(assign(r2A9D, add(r2A9D, body.constant(int(2))), 0x01));

                           body.emit(assign(r2A9B, lshift(r2A9B, body.constant(int(2))), 0x01));


                        body.instructions = f2AA9_parent_instructions;
                        body.emit(f2AA9);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2AAD = bit_and(r2A9B, body.constant(2147483648u));
                        ir_expression *const r2AAE = equal(r2AAD, body.constant(0u));
                        ir_if *f2AAC = new(mem_ctx) ir_if(operand(r2AAE).val);
                        exec_list *const f2AAC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AAC->then_instructions;

                           body.emit(assign(r2A9D, add(r2A9D, body.constant(int(1))), 0x01));


                        body.instructions = f2AAC_parent_instructions;
                        body.emit(f2AAC);

                        /* END IF */

                        body.emit(assign(r2A9C, r2A9D, 0x01));


                     body.instructions = f2A9E_parent_instructions;
                     body.emit(f2A9E);

                     /* END IF */

                     body.emit(assign(r2A98, add(r2A9C, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2AB0 = lequal(body.constant(int(0)), r2A98);
                     ir_if *f2AAF = new(mem_ctx) ir_if(operand(r2AB0).val);
                     exec_list *const f2AAF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2AAF->then_instructions;

                        body.emit(assign(r2A97, body.constant(0u), 0x01));

                        ir_variable *const r2AB1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2AB1, lshift(r2A96, r2A98), 0x01));

                        ir_variable *const r2AB2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2AB4 = equal(r2A98, body.constant(int(0)));
                        ir_if *f2AB3 = new(mem_ctx) ir_if(operand(r2AB4).val);
                        exec_list *const f2AB3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AB3->then_instructions;

                           body.emit(assign(r2AB2, r2A95, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2AB3->else_instructions;

                           ir_expression *const r2AB5 = lshift(r2A95, r2A98);
                           ir_expression *const r2AB6 = neg(r2A98);
                           ir_expression *const r2AB7 = bit_and(r2AB6, body.constant(int(31)));
                           ir_expression *const r2AB8 = rshift(r2A96, r2AB7);
                           body.emit(assign(r2AB2, bit_or(r2AB5, r2AB8), 0x01));


                        body.instructions = f2AB3_parent_instructions;
                        body.emit(f2AB3);

                        /* END IF */

                        body.emit(assign(r2A95, r2AB2, 0x01));

                        body.emit(assign(r2A96, r2AB1, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2AAF->else_instructions;

                        ir_variable *const r2AB9 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2AB9, body.constant(0u), 0x01));

                        ir_variable *const r2ABA = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2ABA, neg(r2A98), 0x01));

                        ir_variable *const r2ABB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2ABB);
                        ir_variable *const r2ABC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2ABC);
                        ir_variable *const r2ABD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2ABD);
                        ir_variable *const r2ABE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2ABF = neg(r2ABA);
                        body.emit(assign(r2ABE, bit_and(r2ABF, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2AC1 = equal(r2ABA, body.constant(int(0)));
                        ir_if *f2AC0 = new(mem_ctx) ir_if(operand(r2AC1).val);
                        exec_list *const f2AC0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AC0->then_instructions;

                           body.emit(assign(r2ABB, r2AB9, 0x01));

                           body.emit(assign(r2ABC, r2A96, 0x01));

                           body.emit(assign(r2ABD, r2A95, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2AC0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2AC3 = less(r2ABA, body.constant(int(32)));
                           ir_if *f2AC2 = new(mem_ctx) ir_if(operand(r2AC3).val);
                           exec_list *const f2AC2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2AC2->then_instructions;

                              body.emit(assign(r2ABB, lshift(r2A96, r2ABE), 0x01));

                              ir_expression *const r2AC4 = lshift(r2A95, r2ABE);
                              ir_expression *const r2AC5 = rshift(r2A96, r2ABA);
                              body.emit(assign(r2ABC, bit_or(r2AC4, r2AC5), 0x01));

                              body.emit(assign(r2ABD, rshift(r2A95, r2ABA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2AC2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2AC7 = equal(r2ABA, body.constant(int(32)));
                              ir_if *f2AC6 = new(mem_ctx) ir_if(operand(r2AC7).val);
                              exec_list *const f2AC6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AC6->then_instructions;

                                 body.emit(assign(r2ABB, r2A96, 0x01));

                                 body.emit(assign(r2ABC, r2A95, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2AC6->else_instructions;

                                 body.emit(assign(r2AB9, bit_or(body.constant(0u), r2A96), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2AC9 = less(r2ABA, body.constant(int(64)));
                                 ir_if *f2AC8 = new(mem_ctx) ir_if(operand(r2AC9).val);
                                 exec_list *const f2AC8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AC8->then_instructions;

                                    body.emit(assign(r2ABB, lshift(r2A95, r2ABE), 0x01));

                                    ir_expression *const r2ACA = bit_and(r2ABA, body.constant(int(31)));
                                    body.emit(assign(r2ABC, rshift(r2A95, r2ACA), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AC8->else_instructions;

                                    ir_variable *const r2ACB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2ACD = equal(r2ABA, body.constant(int(64)));
                                    ir_if *f2ACC = new(mem_ctx) ir_if(operand(r2ACD).val);
                                    exec_list *const f2ACC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2ACC->then_instructions;

                                       body.emit(assign(r2ACB, r2A95, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2ACC->else_instructions;

                                       ir_expression *const r2ACE = nequal(r2A95, body.constant(0u));
                                       ir_expression *const r2ACF = expr(ir_unop_b2i, r2ACE);
                                       body.emit(assign(r2ACB, expr(ir_unop_i2u, r2ACF), 0x01));


                                    body.instructions = f2ACC_parent_instructions;
                                    body.emit(f2ACC);

                                    /* END IF */

                                    body.emit(assign(r2ABB, r2ACB, 0x01));

                                    body.emit(assign(r2ABC, body.constant(0u), 0x01));


                                 body.instructions = f2AC8_parent_instructions;
                                 body.emit(f2AC8);

                                 /* END IF */


                              body.instructions = f2AC6_parent_instructions;
                              body.emit(f2AC6);

                              /* END IF */

                              body.emit(assign(r2ABD, body.constant(0u), 0x01));


                           body.instructions = f2AC2_parent_instructions;
                           body.emit(f2AC2);

                           /* END IF */

                           ir_expression *const r2AD0 = nequal(r2AB9, body.constant(0u));
                           ir_expression *const r2AD1 = expr(ir_unop_b2i, r2AD0);
                           ir_expression *const r2AD2 = expr(ir_unop_i2u, r2AD1);
                           body.emit(assign(r2ABB, bit_or(r2ABB, r2AD2), 0x01));


                        body.instructions = f2AC0_parent_instructions;
                        body.emit(f2AC0);

                        /* END IF */

                        body.emit(assign(r2A95, r2ABD, 0x01));

                        body.emit(assign(r2A96, r2ABC, 0x01));

                        body.emit(assign(r2A97, r2ABB, 0x01));


                     body.instructions = f2AAF_parent_instructions;
                     body.emit(f2AAF);

                     /* END IF */

                     body.emit(assign(r2A94, sub(r2A94, r2A98), 0x01));

                     ir_variable *const r2AD3 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2AD3, r2A94, 0x01));

                     ir_variable *const r2AD4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2AD4, r2A95, 0x01));

                     ir_variable *const r2AD5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2AD5, r2A96, 0x01));

                     ir_variable *const r2AD6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2AD6, r2A97, 0x01));

                     ir_variable *const r2AD7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2AD7, body.constant(true), 0x01));

                     ir_variable *const r2AD8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2AD9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2AD9);
                     ir_expression *const r2ADA = expr(ir_unop_u2i, r2A97);
                     body.emit(assign(r2AD9, less(r2ADA, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2ADC = lequal(body.constant(int(2045)), r2A94);
                     ir_if *f2ADB = new(mem_ctx) ir_if(operand(r2ADC).val);
                     exec_list *const f2ADB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2ADB->then_instructions;

                        ir_variable *const r2ADD = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2ADF = less(body.constant(int(2045)), r2A94);
                        ir_if *f2ADE = new(mem_ctx) ir_if(operand(r2ADF).val);
                        exec_list *const f2ADE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2ADE->then_instructions;

                           body.emit(assign(r2ADD, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2ADE->else_instructions;

                           ir_variable *const r2AE0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2AE2 = equal(r2A94, body.constant(int(2045)));
                           ir_if *f2AE1 = new(mem_ctx) ir_if(operand(r2AE2).val);
                           exec_list *const f2AE1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2AE1->then_instructions;

                              ir_expression *const r2AE3 = equal(body.constant(2097151u), r2A95);
                              ir_expression *const r2AE4 = equal(body.constant(4294967295u), r2A96);
                              body.emit(assign(r2AE0, logic_and(r2AE3, r2AE4), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2AE1->else_instructions;

                              body.emit(assign(r2AE0, body.constant(false), 0x01));


                           body.instructions = f2AE1_parent_instructions;
                           body.emit(f2AE1);

                           /* END IF */

                           body.emit(assign(r2ADD, logic_and(r2AE0, r2AD9), 0x01));


                        body.instructions = f2ADE_parent_instructions;
                        body.emit(f2ADE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2AE5 = new(mem_ctx) ir_if(operand(r2ADD).val);
                        exec_list *const f2AE5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AE5->then_instructions;

                           ir_variable *const r2AE6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2AE6);
                           ir_expression *const r2AE7 = lshift(r2901, body.constant(int(31)));
                           body.emit(assign(r2AE6, add(r2AE7, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2AE6, body.constant(0u), 0x01));

                           body.emit(assign(r2AD8, r2AE6, 0x03));

                           body.emit(assign(r2AD7, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2AE5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2AE9 = less(r2A94, body.constant(int(0)));
                           ir_if *f2AE8 = new(mem_ctx) ir_if(operand(r2AE9).val);
                           exec_list *const f2AE8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2AE8->then_instructions;

                              ir_variable *const r2AEA = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2AEA, r2A97, 0x01));

                              ir_variable *const r2AEB = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2AEB, neg(r2A94), 0x01));

                              ir_variable *const r2AEC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2AEC);
                              ir_variable *const r2AED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2AED);
                              ir_variable *const r2AEE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2AEE);
                              ir_variable *const r2AEF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2AF0 = neg(r2AEB);
                              body.emit(assign(r2AEF, bit_and(r2AF0, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2AF2 = equal(r2AEB, body.constant(int(0)));
                              ir_if *f2AF1 = new(mem_ctx) ir_if(operand(r2AF2).val);
                              exec_list *const f2AF1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AF1->then_instructions;

                                 body.emit(assign(r2AEC, r2A97, 0x01));

                                 body.emit(assign(r2AED, r2A96, 0x01));

                                 body.emit(assign(r2AEE, r2A95, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2AF1->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2AF4 = less(r2AEB, body.constant(int(32)));
                                 ir_if *f2AF3 = new(mem_ctx) ir_if(operand(r2AF4).val);
                                 exec_list *const f2AF3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AF3->then_instructions;

                                    body.emit(assign(r2AEC, lshift(r2A96, r2AEF), 0x01));

                                    ir_expression *const r2AF5 = lshift(r2A95, r2AEF);
                                    ir_expression *const r2AF6 = rshift(r2A96, r2AEB);
                                    body.emit(assign(r2AED, bit_or(r2AF5, r2AF6), 0x01));

                                    body.emit(assign(r2AEE, rshift(r2A95, r2AEB), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AF3->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2AF8 = equal(r2AEB, body.constant(int(32)));
                                    ir_if *f2AF7 = new(mem_ctx) ir_if(operand(r2AF8).val);
                                    exec_list *const f2AF7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2AF7->then_instructions;

                                       body.emit(assign(r2AEC, r2A96, 0x01));

                                       body.emit(assign(r2AED, r2A95, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2AF7->else_instructions;

                                       body.emit(assign(r2AEA, bit_or(r2A97, r2A96), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2AFA = less(r2AEB, body.constant(int(64)));
                                       ir_if *f2AF9 = new(mem_ctx) ir_if(operand(r2AFA).val);
                                       exec_list *const f2AF9_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2AF9->then_instructions;

                                          body.emit(assign(r2AEC, lshift(r2A95, r2AEF), 0x01));

                                          ir_expression *const r2AFB = bit_and(r2AEB, body.constant(int(31)));
                                          body.emit(assign(r2AED, rshift(r2A95, r2AFB), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2AF9->else_instructions;

                                          ir_variable *const r2AFC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2AFE = equal(r2AEB, body.constant(int(64)));
                                          ir_if *f2AFD = new(mem_ctx) ir_if(operand(r2AFE).val);
                                          exec_list *const f2AFD_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2AFD->then_instructions;

                                             body.emit(assign(r2AFC, r2A95, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2AFD->else_instructions;

                                             ir_expression *const r2AFF = nequal(r2A95, body.constant(0u));
                                             ir_expression *const r2B00 = expr(ir_unop_b2i, r2AFF);
                                             body.emit(assign(r2AFC, expr(ir_unop_i2u, r2B00), 0x01));


                                          body.instructions = f2AFD_parent_instructions;
                                          body.emit(f2AFD);

                                          /* END IF */

                                          body.emit(assign(r2AEC, r2AFC, 0x01));

                                          body.emit(assign(r2AED, body.constant(0u), 0x01));


                                       body.instructions = f2AF9_parent_instructions;
                                       body.emit(f2AF9);

                                       /* END IF */


                                    body.instructions = f2AF7_parent_instructions;
                                    body.emit(f2AF7);

                                    /* END IF */

                                    body.emit(assign(r2AEE, body.constant(0u), 0x01));


                                 body.instructions = f2AF3_parent_instructions;
                                 body.emit(f2AF3);

                                 /* END IF */

                                 ir_expression *const r2B01 = nequal(r2AEA, body.constant(0u));
                                 ir_expression *const r2B02 = expr(ir_unop_b2i, r2B01);
                                 ir_expression *const r2B03 = expr(ir_unop_i2u, r2B02);
                                 body.emit(assign(r2AEC, bit_or(r2AEC, r2B03), 0x01));


                              body.instructions = f2AF1_parent_instructions;
                              body.emit(f2AF1);

                              /* END IF */

                              body.emit(assign(r2AD4, r2AEE, 0x01));

                              body.emit(assign(r2AD5, r2AED, 0x01));

                              body.emit(assign(r2AD6, r2AEC, 0x01));

                              body.emit(assign(r2AD3, body.constant(int(0)), 0x01));

                              body.emit(assign(r2AD9, less(r2AEC, body.constant(0u)), 0x01));


                           body.instructions = f2AE8_parent_instructions;
                           body.emit(f2AE8);

                           /* END IF */


                        body.instructions = f2AE5_parent_instructions;
                        body.emit(f2AE5);

                        /* END IF */


                     body.instructions = f2ADB_parent_instructions;
                     body.emit(f2ADB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2B04 = new(mem_ctx) ir_if(operand(r2AD7).val);
                     exec_list *const f2B04_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B04->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2B05 = new(mem_ctx) ir_if(operand(r2AD9).val);
                        exec_list *const f2B05_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B05->then_instructions;

                           ir_variable *const r2B06 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2B06, add(r2AD5, body.constant(1u)), 0x01));

                           ir_expression *const r2B07 = less(r2B06, r2AD5);
                           ir_expression *const r2B08 = expr(ir_unop_b2i, r2B07);
                           ir_expression *const r2B09 = expr(ir_unop_i2u, r2B08);
                           body.emit(assign(r2AD4, add(r2AD4, r2B09), 0x01));

                           ir_expression *const r2B0A = equal(r2AD6, body.constant(0u));
                           ir_expression *const r2B0B = expr(ir_unop_b2i, r2B0A);
                           ir_expression *const r2B0C = expr(ir_unop_i2u, r2B0B);
                           ir_expression *const r2B0D = add(r2AD6, r2B0C);
                           ir_expression *const r2B0E = bit_and(r2B0D, body.constant(1u));
                           ir_expression *const r2B0F = expr(ir_unop_bit_not, r2B0E);
                           body.emit(assign(r2AD5, bit_and(r2B06, r2B0F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B05->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2B11 = bit_or(r2AD4, r2AD5);
                           ir_expression *const r2B12 = equal(r2B11, body.constant(0u));
                           ir_if *f2B10 = new(mem_ctx) ir_if(operand(r2B12).val);
                           exec_list *const f2B10_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B10->then_instructions;

                              body.emit(assign(r2AD3, body.constant(int(0)), 0x01));


                           body.instructions = f2B10_parent_instructions;
                           body.emit(f2B10);

                           /* END IF */


                        body.instructions = f2B05_parent_instructions;
                        body.emit(f2B05);

                        /* END IF */

                        ir_variable *const r2B13 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2B13);
                        ir_expression *const r2B14 = lshift(r2901, body.constant(int(31)));
                        ir_expression *const r2B15 = expr(ir_unop_i2u, r2AD3);
                        ir_expression *const r2B16 = lshift(r2B15, body.constant(int(20)));
                        ir_expression *const r2B17 = add(r2B14, r2B16);
                        body.emit(assign(r2B13, add(r2B17, r2AD4), 0x02));

                        body.emit(assign(r2B13, r2AD5, 0x01));

                        body.emit(assign(r2AD8, r2B13, 0x03));

                        body.emit(assign(r2AD7, body.constant(false), 0x01));


                     body.instructions = f2B04_parent_instructions;
                     body.emit(f2B04);

                     /* END IF */

                     body.emit(assign(r2902, r2AD8, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A8C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2B19 = less(swizzle_y(r2907), swizzle_y(r2905));
                     ir_if *f2B18 = new(mem_ctx) ir_if(operand(r2B19).val);
                     exec_list *const f2B18_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B18->then_instructions;

                        ir_variable *const r2B1A = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r2B1B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2B1B, sub(swizzle_x(r2905), swizzle_x(r2907)), 0x01));

                        ir_expression *const r2B1C = sub(swizzle_y(r2905), swizzle_y(r2907));
                        ir_expression *const r2B1D = less(swizzle_x(r2905), swizzle_x(r2907));
                        ir_expression *const r2B1E = expr(ir_unop_b2i, r2B1D);
                        ir_expression *const r2B1F = expr(ir_unop_i2u, r2B1E);
                        body.emit(assign(r2B1A, sub(r2B1C, r2B1F), 0x01));

                        body.emit(assign(r2901, bit_xor(r2901, body.constant(1u)), 0x01));

                        body.emit(assign(r2908, add(r2904, body.constant(int(-1))), 0x01));

                        ir_variable *const r2B20 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2B20, add(r2908, body.constant(int(-10))), 0x01));

                        ir_variable *const r2B21 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2B21, r2B1A, 0x01));

                        ir_variable *const r2B22 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2B22, r2B1B, 0x01));

                        ir_variable *const r2B23 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2B23);
                        ir_variable *const r2B24 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2B24);
                        /* IF CONDITION */
                        ir_expression *const r2B26 = equal(r2B1A, body.constant(0u));
                        ir_if *f2B25 = new(mem_ctx) ir_if(operand(r2B26).val);
                        exec_list *const f2B25_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B25->then_instructions;

                           body.emit(assign(r2B21, r2B1B, 0x01));

                           body.emit(assign(r2B22, body.constant(0u), 0x01));

                           body.emit(assign(r2B20, add(r2B20, body.constant(int(-32))), 0x01));


                        body.instructions = f2B25_parent_instructions;
                        body.emit(f2B25);

                        /* END IF */

                        ir_variable *const r2B27 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2B27, r2B21, 0x01));

                        ir_variable *const r2B28 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r2B29 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2B29);
                        /* IF CONDITION */
                        ir_expression *const r2B2B = equal(r2B21, body.constant(0u));
                        ir_if *f2B2A = new(mem_ctx) ir_if(operand(r2B2B).val);
                        exec_list *const f2B2A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B2A->then_instructions;

                           body.emit(assign(r2B28, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B2A->else_instructions;

                           body.emit(assign(r2B29, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2B2D = bit_and(r2B21, body.constant(4294901760u));
                           ir_expression *const r2B2E = equal(r2B2D, body.constant(0u));
                           ir_if *f2B2C = new(mem_ctx) ir_if(operand(r2B2E).val);
                           exec_list *const f2B2C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B2C->then_instructions;

                              body.emit(assign(r2B29, body.constant(int(16)), 0x01));

                              body.emit(assign(r2B27, lshift(r2B21, body.constant(int(16))), 0x01));


                           body.instructions = f2B2C_parent_instructions;
                           body.emit(f2B2C);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2B30 = bit_and(r2B27, body.constant(4278190080u));
                           ir_expression *const r2B31 = equal(r2B30, body.constant(0u));
                           ir_if *f2B2F = new(mem_ctx) ir_if(operand(r2B31).val);
                           exec_list *const f2B2F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B2F->then_instructions;

                              body.emit(assign(r2B29, add(r2B29, body.constant(int(8))), 0x01));

                              body.emit(assign(r2B27, lshift(r2B27, body.constant(int(8))), 0x01));


                           body.instructions = f2B2F_parent_instructions;
                           body.emit(f2B2F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2B33 = bit_and(r2B27, body.constant(4026531840u));
                           ir_expression *const r2B34 = equal(r2B33, body.constant(0u));
                           ir_if *f2B32 = new(mem_ctx) ir_if(operand(r2B34).val);
                           exec_list *const f2B32_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B32->then_instructions;

                              body.emit(assign(r2B29, add(r2B29, body.constant(int(4))), 0x01));

                              body.emit(assign(r2B27, lshift(r2B27, body.constant(int(4))), 0x01));


                           body.instructions = f2B32_parent_instructions;
                           body.emit(f2B32);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2B36 = bit_and(r2B27, body.constant(3221225472u));
                           ir_expression *const r2B37 = equal(r2B36, body.constant(0u));
                           ir_if *f2B35 = new(mem_ctx) ir_if(operand(r2B37).val);
                           exec_list *const f2B35_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B35->then_instructions;

                              body.emit(assign(r2B29, add(r2B29, body.constant(int(2))), 0x01));

                              body.emit(assign(r2B27, lshift(r2B27, body.constant(int(2))), 0x01));


                           body.instructions = f2B35_parent_instructions;
                           body.emit(f2B35);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2B39 = bit_and(r2B27, body.constant(2147483648u));
                           ir_expression *const r2B3A = equal(r2B39, body.constant(0u));
                           ir_if *f2B38 = new(mem_ctx) ir_if(operand(r2B3A).val);
                           exec_list *const f2B38_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B38->then_instructions;

                              body.emit(assign(r2B29, add(r2B29, body.constant(int(1))), 0x01));


                           body.instructions = f2B38_parent_instructions;
                           body.emit(f2B38);

                           /* END IF */

                           body.emit(assign(r2B28, r2B29, 0x01));


                        body.instructions = f2B2A_parent_instructions;
                        body.emit(f2B2A);

                        /* END IF */

                        body.emit(assign(r2B24, add(r2B28, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2B3C = lequal(body.constant(int(0)), r2B24);
                        ir_if *f2B3B = new(mem_ctx) ir_if(operand(r2B3C).val);
                        exec_list *const f2B3B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B3B->then_instructions;

                           body.emit(assign(r2B23, body.constant(0u), 0x01));

                           ir_variable *const r2B3D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2B3D, lshift(r2B22, r2B24), 0x01));

                           ir_variable *const r2B3E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2B40 = equal(r2B24, body.constant(int(0)));
                           ir_if *f2B3F = new(mem_ctx) ir_if(operand(r2B40).val);
                           exec_list *const f2B3F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B3F->then_instructions;

                              body.emit(assign(r2B3E, r2B21, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B3F->else_instructions;

                              ir_expression *const r2B41 = lshift(r2B21, r2B24);
                              ir_expression *const r2B42 = neg(r2B24);
                              ir_expression *const r2B43 = bit_and(r2B42, body.constant(int(31)));
                              ir_expression *const r2B44 = rshift(r2B22, r2B43);
                              body.emit(assign(r2B3E, bit_or(r2B41, r2B44), 0x01));


                           body.instructions = f2B3F_parent_instructions;
                           body.emit(f2B3F);

                           /* END IF */

                           body.emit(assign(r2B21, r2B3E, 0x01));

                           body.emit(assign(r2B22, r2B3D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B3B->else_instructions;

                           ir_variable *const r2B45 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2B45, body.constant(0u), 0x01));

                           ir_variable *const r2B46 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2B46, neg(r2B24), 0x01));

                           ir_variable *const r2B47 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2B47);
                           ir_variable *const r2B48 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2B48);
                           ir_variable *const r2B49 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2B49);
                           ir_variable *const r2B4A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2B4B = neg(r2B46);
                           body.emit(assign(r2B4A, bit_and(r2B4B, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2B4D = equal(r2B46, body.constant(int(0)));
                           ir_if *f2B4C = new(mem_ctx) ir_if(operand(r2B4D).val);
                           exec_list *const f2B4C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B4C->then_instructions;

                              body.emit(assign(r2B47, r2B45, 0x01));

                              body.emit(assign(r2B48, r2B22, 0x01));

                              body.emit(assign(r2B49, r2B21, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B4C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2B4F = less(r2B46, body.constant(int(32)));
                              ir_if *f2B4E = new(mem_ctx) ir_if(operand(r2B4F).val);
                              exec_list *const f2B4E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2B4E->then_instructions;

                                 body.emit(assign(r2B47, lshift(r2B22, r2B4A), 0x01));

                                 ir_expression *const r2B50 = lshift(r2B21, r2B4A);
                                 ir_expression *const r2B51 = rshift(r2B22, r2B46);
                                 body.emit(assign(r2B48, bit_or(r2B50, r2B51), 0x01));

                                 body.emit(assign(r2B49, rshift(r2B21, r2B46), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2B4E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2B53 = equal(r2B46, body.constant(int(32)));
                                 ir_if *f2B52 = new(mem_ctx) ir_if(operand(r2B53).val);
                                 exec_list *const f2B52_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2B52->then_instructions;

                                    body.emit(assign(r2B47, r2B22, 0x01));

                                    body.emit(assign(r2B48, r2B21, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2B52->else_instructions;

                                    body.emit(assign(r2B45, bit_or(body.constant(0u), r2B22), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2B55 = less(r2B46, body.constant(int(64)));
                                    ir_if *f2B54 = new(mem_ctx) ir_if(operand(r2B55).val);
                                    exec_list *const f2B54_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2B54->then_instructions;

                                       body.emit(assign(r2B47, lshift(r2B21, r2B4A), 0x01));

                                       ir_expression *const r2B56 = bit_and(r2B46, body.constant(int(31)));
                                       body.emit(assign(r2B48, rshift(r2B21, r2B56), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2B54->else_instructions;

                                       ir_variable *const r2B57 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2B59 = equal(r2B46, body.constant(int(64)));
                                       ir_if *f2B58 = new(mem_ctx) ir_if(operand(r2B59).val);
                                       exec_list *const f2B58_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2B58->then_instructions;

                                          body.emit(assign(r2B57, r2B21, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2B58->else_instructions;

                                          ir_expression *const r2B5A = nequal(r2B21, body.constant(0u));
                                          ir_expression *const r2B5B = expr(ir_unop_b2i, r2B5A);
                                          body.emit(assign(r2B57, expr(ir_unop_i2u, r2B5B), 0x01));


                                       body.instructions = f2B58_parent_instructions;
                                       body.emit(f2B58);

                                       /* END IF */

                                       body.emit(assign(r2B47, r2B57, 0x01));

                                       body.emit(assign(r2B48, body.constant(0u), 0x01));


                                    body.instructions = f2B54_parent_instructions;
                                    body.emit(f2B54);

                                    /* END IF */


                                 body.instructions = f2B52_parent_instructions;
                                 body.emit(f2B52);

                                 /* END IF */

                                 body.emit(assign(r2B49, body.constant(0u), 0x01));


                              body.instructions = f2B4E_parent_instructions;
                              body.emit(f2B4E);

                              /* END IF */

                              ir_expression *const r2B5C = nequal(r2B45, body.constant(0u));
                              ir_expression *const r2B5D = expr(ir_unop_b2i, r2B5C);
                              ir_expression *const r2B5E = expr(ir_unop_i2u, r2B5D);
                              body.emit(assign(r2B47, bit_or(r2B47, r2B5E), 0x01));


                           body.instructions = f2B4C_parent_instructions;
                           body.emit(f2B4C);

                           /* END IF */

                           body.emit(assign(r2B21, r2B49, 0x01));

                           body.emit(assign(r2B22, r2B48, 0x01));

                           body.emit(assign(r2B23, r2B47, 0x01));


                        body.instructions = f2B3B_parent_instructions;
                        body.emit(f2B3B);

                        /* END IF */

                        body.emit(assign(r2B20, sub(r2B20, r2B24), 0x01));

                        ir_variable *const r2B5F = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2B5F, r2B20, 0x01));

                        ir_variable *const r2B60 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2B60, r2B21, 0x01));

                        ir_variable *const r2B61 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2B61, r2B22, 0x01));

                        ir_variable *const r2B62 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r2B62, r2B23, 0x01));

                        ir_variable *const r2B63 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r2B63, body.constant(true), 0x01));

                        ir_variable *const r2B64 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r2B65 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r2B65);
                        ir_expression *const r2B66 = expr(ir_unop_u2i, r2B23);
                        body.emit(assign(r2B65, less(r2B66, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2B68 = lequal(body.constant(int(2045)), r2B20);
                        ir_if *f2B67 = new(mem_ctx) ir_if(operand(r2B68).val);
                        exec_list *const f2B67_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B67->then_instructions;

                           ir_variable *const r2B69 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2B6B = less(body.constant(int(2045)), r2B20);
                           ir_if *f2B6A = new(mem_ctx) ir_if(operand(r2B6B).val);
                           exec_list *const f2B6A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B6A->then_instructions;

                              body.emit(assign(r2B69, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B6A->else_instructions;

                              ir_variable *const r2B6C = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2B6E = equal(r2B20, body.constant(int(2045)));
                              ir_if *f2B6D = new(mem_ctx) ir_if(operand(r2B6E).val);
                              exec_list *const f2B6D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2B6D->then_instructions;

                                 ir_expression *const r2B6F = equal(body.constant(2097151u), r2B21);
                                 ir_expression *const r2B70 = equal(body.constant(4294967295u), r2B22);
                                 body.emit(assign(r2B6C, logic_and(r2B6F, r2B70), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2B6D->else_instructions;

                                 body.emit(assign(r2B6C, body.constant(false), 0x01));


                              body.instructions = f2B6D_parent_instructions;
                              body.emit(f2B6D);

                              /* END IF */

                              body.emit(assign(r2B69, logic_and(r2B6C, r2B65), 0x01));


                           body.instructions = f2B6A_parent_instructions;
                           body.emit(f2B6A);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2B71 = new(mem_ctx) ir_if(operand(r2B69).val);
                           exec_list *const f2B71_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B71->then_instructions;

                              ir_variable *const r2B72 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2B72);
                              ir_expression *const r2B73 = lshift(r2901, body.constant(int(31)));
                              body.emit(assign(r2B72, add(r2B73, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r2B72, body.constant(0u), 0x01));

                              body.emit(assign(r2B64, r2B72, 0x03));

                              body.emit(assign(r2B63, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B71->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2B75 = less(r2B20, body.constant(int(0)));
                              ir_if *f2B74 = new(mem_ctx) ir_if(operand(r2B75).val);
                              exec_list *const f2B74_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2B74->then_instructions;

                                 ir_variable *const r2B76 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2B76, r2B23, 0x01));

                                 ir_variable *const r2B77 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2B77, neg(r2B20), 0x01));

                                 ir_variable *const r2B78 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2B78);
                                 ir_variable *const r2B79 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2B79);
                                 ir_variable *const r2B7A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2B7A);
                                 ir_variable *const r2B7B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2B7C = neg(r2B77);
                                 body.emit(assign(r2B7B, bit_and(r2B7C, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2B7E = equal(r2B77, body.constant(int(0)));
                                 ir_if *f2B7D = new(mem_ctx) ir_if(operand(r2B7E).val);
                                 exec_list *const f2B7D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2B7D->then_instructions;

                                    body.emit(assign(r2B78, r2B23, 0x01));

                                    body.emit(assign(r2B79, r2B22, 0x01));

                                    body.emit(assign(r2B7A, r2B21, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2B7D->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2B80 = less(r2B77, body.constant(int(32)));
                                    ir_if *f2B7F = new(mem_ctx) ir_if(operand(r2B80).val);
                                    exec_list *const f2B7F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2B7F->then_instructions;

                                       body.emit(assign(r2B78, lshift(r2B22, r2B7B), 0x01));

                                       ir_expression *const r2B81 = lshift(r2B21, r2B7B);
                                       ir_expression *const r2B82 = rshift(r2B22, r2B77);
                                       body.emit(assign(r2B79, bit_or(r2B81, r2B82), 0x01));

                                       body.emit(assign(r2B7A, rshift(r2B21, r2B77), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2B7F->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2B84 = equal(r2B77, body.constant(int(32)));
                                       ir_if *f2B83 = new(mem_ctx) ir_if(operand(r2B84).val);
                                       exec_list *const f2B83_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2B83->then_instructions;

                                          body.emit(assign(r2B78, r2B22, 0x01));

                                          body.emit(assign(r2B79, r2B21, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2B83->else_instructions;

                                          body.emit(assign(r2B76, bit_or(r2B23, r2B22), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2B86 = less(r2B77, body.constant(int(64)));
                                          ir_if *f2B85 = new(mem_ctx) ir_if(operand(r2B86).val);
                                          exec_list *const f2B85_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2B85->then_instructions;

                                             body.emit(assign(r2B78, lshift(r2B21, r2B7B), 0x01));

                                             ir_expression *const r2B87 = bit_and(r2B77, body.constant(int(31)));
                                             body.emit(assign(r2B79, rshift(r2B21, r2B87), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2B85->else_instructions;

                                             ir_variable *const r2B88 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2B8A = equal(r2B77, body.constant(int(64)));
                                             ir_if *f2B89 = new(mem_ctx) ir_if(operand(r2B8A).val);
                                             exec_list *const f2B89_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2B89->then_instructions;

                                                body.emit(assign(r2B88, r2B21, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2B89->else_instructions;

                                                ir_expression *const r2B8B = nequal(r2B21, body.constant(0u));
                                                ir_expression *const r2B8C = expr(ir_unop_b2i, r2B8B);
                                                body.emit(assign(r2B88, expr(ir_unop_i2u, r2B8C), 0x01));


                                             body.instructions = f2B89_parent_instructions;
                                             body.emit(f2B89);

                                             /* END IF */

                                             body.emit(assign(r2B78, r2B88, 0x01));

                                             body.emit(assign(r2B79, body.constant(0u), 0x01));


                                          body.instructions = f2B85_parent_instructions;
                                          body.emit(f2B85);

                                          /* END IF */


                                       body.instructions = f2B83_parent_instructions;
                                       body.emit(f2B83);

                                       /* END IF */

                                       body.emit(assign(r2B7A, body.constant(0u), 0x01));


                                    body.instructions = f2B7F_parent_instructions;
                                    body.emit(f2B7F);

                                    /* END IF */

                                    ir_expression *const r2B8D = nequal(r2B76, body.constant(0u));
                                    ir_expression *const r2B8E = expr(ir_unop_b2i, r2B8D);
                                    ir_expression *const r2B8F = expr(ir_unop_i2u, r2B8E);
                                    body.emit(assign(r2B78, bit_or(r2B78, r2B8F), 0x01));


                                 body.instructions = f2B7D_parent_instructions;
                                 body.emit(f2B7D);

                                 /* END IF */

                                 body.emit(assign(r2B60, r2B7A, 0x01));

                                 body.emit(assign(r2B61, r2B79, 0x01));

                                 body.emit(assign(r2B62, r2B78, 0x01));

                                 body.emit(assign(r2B5F, body.constant(int(0)), 0x01));

                                 body.emit(assign(r2B65, less(r2B78, body.constant(0u)), 0x01));


                              body.instructions = f2B74_parent_instructions;
                              body.emit(f2B74);

                              /* END IF */


                           body.instructions = f2B71_parent_instructions;
                           body.emit(f2B71);

                           /* END IF */


                        body.instructions = f2B67_parent_instructions;
                        body.emit(f2B67);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2B90 = new(mem_ctx) ir_if(operand(r2B63).val);
                        exec_list *const f2B90_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B90->then_instructions;

                           /* IF CONDITION */
                           ir_if *f2B91 = new(mem_ctx) ir_if(operand(r2B65).val);
                           exec_list *const f2B91_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B91->then_instructions;

                              ir_variable *const r2B92 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r2B92, add(r2B61, body.constant(1u)), 0x01));

                              ir_expression *const r2B93 = less(r2B92, r2B61);
                              ir_expression *const r2B94 = expr(ir_unop_b2i, r2B93);
                              ir_expression *const r2B95 = expr(ir_unop_i2u, r2B94);
                              body.emit(assign(r2B60, add(r2B60, r2B95), 0x01));

                              ir_expression *const r2B96 = equal(r2B62, body.constant(0u));
                              ir_expression *const r2B97 = expr(ir_unop_b2i, r2B96);
                              ir_expression *const r2B98 = expr(ir_unop_i2u, r2B97);
                              ir_expression *const r2B99 = add(r2B62, r2B98);
                              ir_expression *const r2B9A = bit_and(r2B99, body.constant(1u));
                              ir_expression *const r2B9B = expr(ir_unop_bit_not, r2B9A);
                              body.emit(assign(r2B61, bit_and(r2B92, r2B9B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B91->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2B9D = bit_or(r2B60, r2B61);
                              ir_expression *const r2B9E = equal(r2B9D, body.constant(0u));
                              ir_if *f2B9C = new(mem_ctx) ir_if(operand(r2B9E).val);
                              exec_list *const f2B9C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2B9C->then_instructions;

                                 body.emit(assign(r2B5F, body.constant(int(0)), 0x01));


                              body.instructions = f2B9C_parent_instructions;
                              body.emit(f2B9C);

                              /* END IF */


                           body.instructions = f2B91_parent_instructions;
                           body.emit(f2B91);

                           /* END IF */

                           ir_variable *const r2B9F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2B9F);
                           ir_expression *const r2BA0 = lshift(r2901, body.constant(int(31)));
                           ir_expression *const r2BA1 = expr(ir_unop_i2u, r2B5F);
                           ir_expression *const r2BA2 = lshift(r2BA1, body.constant(int(20)));
                           ir_expression *const r2BA3 = add(r2BA0, r2BA2);
                           body.emit(assign(r2B9F, add(r2BA3, r2B60), 0x02));

                           body.emit(assign(r2B9F, r2B61, 0x01));

                           body.emit(assign(r2B64, r2B9F, 0x03));

                           body.emit(assign(r2B63, body.constant(false), 0x01));


                        body.instructions = f2B90_parent_instructions;
                        body.emit(f2B90);

                        /* END IF */

                        body.emit(assign(r2902, r2B64, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B18->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2BA5 = less(swizzle_x(r2905), swizzle_x(r2907));
                        ir_if *f2BA4 = new(mem_ctx) ir_if(operand(r2BA5).val);
                        exec_list *const f2BA4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BA4->then_instructions;

                           ir_variable *const r2BA6 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r2BA7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2BA7, sub(swizzle_x(r2907), swizzle_x(r2905)), 0x01));

                           ir_expression *const r2BA8 = sub(swizzle_y(r2907), swizzle_y(r2905));
                           ir_expression *const r2BA9 = less(swizzle_x(r2907), swizzle_x(r2905));
                           ir_expression *const r2BAA = expr(ir_unop_b2i, r2BA9);
                           ir_expression *const r2BAB = expr(ir_unop_i2u, r2BAA);
                           body.emit(assign(r2BA6, sub(r2BA8, r2BAB), 0x01));

                           body.emit(assign(r2908, add(r2906, body.constant(int(-1))), 0x01));

                           ir_variable *const r2BAC = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2BAC, add(r2908, body.constant(int(-10))), 0x01));

                           ir_variable *const r2BAD = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2BAD, r2BA6, 0x01));

                           ir_variable *const r2BAE = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2BAE, r2BA7, 0x01));

                           ir_variable *const r2BAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r2BAF);
                           ir_variable *const r2BB0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2BB0);
                           /* IF CONDITION */
                           ir_expression *const r2BB2 = equal(r2BA6, body.constant(0u));
                           ir_if *f2BB1 = new(mem_ctx) ir_if(operand(r2BB2).val);
                           exec_list *const f2BB1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BB1->then_instructions;

                              body.emit(assign(r2BAD, r2BA7, 0x01));

                              body.emit(assign(r2BAE, body.constant(0u), 0x01));

                              body.emit(assign(r2BAC, add(r2BAC, body.constant(int(-32))), 0x01));


                           body.instructions = f2BB1_parent_instructions;
                           body.emit(f2BB1);

                           /* END IF */

                           ir_variable *const r2BB3 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r2BB3, r2BAD, 0x01));

                           ir_variable *const r2BB4 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r2BB5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2BB5);
                           /* IF CONDITION */
                           ir_expression *const r2BB7 = equal(r2BAD, body.constant(0u));
                           ir_if *f2BB6 = new(mem_ctx) ir_if(operand(r2BB7).val);
                           exec_list *const f2BB6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BB6->then_instructions;

                              body.emit(assign(r2BB4, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2BB6->else_instructions;

                              body.emit(assign(r2BB5, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2BB9 = bit_and(r2BAD, body.constant(4294901760u));
                              ir_expression *const r2BBA = equal(r2BB9, body.constant(0u));
                              ir_if *f2BB8 = new(mem_ctx) ir_if(operand(r2BBA).val);
                              exec_list *const f2BB8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BB8->then_instructions;

                                 body.emit(assign(r2BB5, body.constant(int(16)), 0x01));

                                 body.emit(assign(r2BB3, lshift(r2BAD, body.constant(int(16))), 0x01));


                              body.instructions = f2BB8_parent_instructions;
                              body.emit(f2BB8);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2BBC = bit_and(r2BB3, body.constant(4278190080u));
                              ir_expression *const r2BBD = equal(r2BBC, body.constant(0u));
                              ir_if *f2BBB = new(mem_ctx) ir_if(operand(r2BBD).val);
                              exec_list *const f2BBB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BBB->then_instructions;

                                 body.emit(assign(r2BB5, add(r2BB5, body.constant(int(8))), 0x01));

                                 body.emit(assign(r2BB3, lshift(r2BB3, body.constant(int(8))), 0x01));


                              body.instructions = f2BBB_parent_instructions;
                              body.emit(f2BBB);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2BBF = bit_and(r2BB3, body.constant(4026531840u));
                              ir_expression *const r2BC0 = equal(r2BBF, body.constant(0u));
                              ir_if *f2BBE = new(mem_ctx) ir_if(operand(r2BC0).val);
                              exec_list *const f2BBE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BBE->then_instructions;

                                 body.emit(assign(r2BB5, add(r2BB5, body.constant(int(4))), 0x01));

                                 body.emit(assign(r2BB3, lshift(r2BB3, body.constant(int(4))), 0x01));


                              body.instructions = f2BBE_parent_instructions;
                              body.emit(f2BBE);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2BC2 = bit_and(r2BB3, body.constant(3221225472u));
                              ir_expression *const r2BC3 = equal(r2BC2, body.constant(0u));
                              ir_if *f2BC1 = new(mem_ctx) ir_if(operand(r2BC3).val);
                              exec_list *const f2BC1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BC1->then_instructions;

                                 body.emit(assign(r2BB5, add(r2BB5, body.constant(int(2))), 0x01));

                                 body.emit(assign(r2BB3, lshift(r2BB3, body.constant(int(2))), 0x01));


                              body.instructions = f2BC1_parent_instructions;
                              body.emit(f2BC1);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2BC5 = bit_and(r2BB3, body.constant(2147483648u));
                              ir_expression *const r2BC6 = equal(r2BC5, body.constant(0u));
                              ir_if *f2BC4 = new(mem_ctx) ir_if(operand(r2BC6).val);
                              exec_list *const f2BC4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BC4->then_instructions;

                                 body.emit(assign(r2BB5, add(r2BB5, body.constant(int(1))), 0x01));


                              body.instructions = f2BC4_parent_instructions;
                              body.emit(f2BC4);

                              /* END IF */

                              body.emit(assign(r2BB4, r2BB5, 0x01));


                           body.instructions = f2BB6_parent_instructions;
                           body.emit(f2BB6);

                           /* END IF */

                           body.emit(assign(r2BB0, add(r2BB4, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2BC8 = lequal(body.constant(int(0)), r2BB0);
                           ir_if *f2BC7 = new(mem_ctx) ir_if(operand(r2BC8).val);
                           exec_list *const f2BC7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BC7->then_instructions;

                              body.emit(assign(r2BAF, body.constant(0u), 0x01));

                              ir_variable *const r2BC9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2BC9, lshift(r2BAE, r2BB0), 0x01));

                              ir_variable *const r2BCA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2BCC = equal(r2BB0, body.constant(int(0)));
                              ir_if *f2BCB = new(mem_ctx) ir_if(operand(r2BCC).val);
                              exec_list *const f2BCB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BCB->then_instructions;

                                 body.emit(assign(r2BCA, r2BAD, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2BCB->else_instructions;

                                 ir_expression *const r2BCD = lshift(r2BAD, r2BB0);
                                 ir_expression *const r2BCE = neg(r2BB0);
                                 ir_expression *const r2BCF = bit_and(r2BCE, body.constant(int(31)));
                                 ir_expression *const r2BD0 = rshift(r2BAE, r2BCF);
                                 body.emit(assign(r2BCA, bit_or(r2BCD, r2BD0), 0x01));


                              body.instructions = f2BCB_parent_instructions;
                              body.emit(f2BCB);

                              /* END IF */

                              body.emit(assign(r2BAD, r2BCA, 0x01));

                              body.emit(assign(r2BAE, r2BC9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2BC7->else_instructions;

                              ir_variable *const r2BD1 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2BD1, body.constant(0u), 0x01));

                              ir_variable *const r2BD2 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2BD2, neg(r2BB0), 0x01));

                              ir_variable *const r2BD3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2BD3);
                              ir_variable *const r2BD4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2BD4);
                              ir_variable *const r2BD5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2BD5);
                              ir_variable *const r2BD6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2BD7 = neg(r2BD2);
                              body.emit(assign(r2BD6, bit_and(r2BD7, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2BD9 = equal(r2BD2, body.constant(int(0)));
                              ir_if *f2BD8 = new(mem_ctx) ir_if(operand(r2BD9).val);
                              exec_list *const f2BD8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BD8->then_instructions;

                                 body.emit(assign(r2BD3, r2BD1, 0x01));

                                 body.emit(assign(r2BD4, r2BAE, 0x01));

                                 body.emit(assign(r2BD5, r2BAD, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2BD8->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2BDB = less(r2BD2, body.constant(int(32)));
                                 ir_if *f2BDA = new(mem_ctx) ir_if(operand(r2BDB).val);
                                 exec_list *const f2BDA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2BDA->then_instructions;

                                    body.emit(assign(r2BD3, lshift(r2BAE, r2BD6), 0x01));

                                    ir_expression *const r2BDC = lshift(r2BAD, r2BD6);
                                    ir_expression *const r2BDD = rshift(r2BAE, r2BD2);
                                    body.emit(assign(r2BD4, bit_or(r2BDC, r2BDD), 0x01));

                                    body.emit(assign(r2BD5, rshift(r2BAD, r2BD2), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2BDA->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2BDF = equal(r2BD2, body.constant(int(32)));
                                    ir_if *f2BDE = new(mem_ctx) ir_if(operand(r2BDF).val);
                                    exec_list *const f2BDE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2BDE->then_instructions;

                                       body.emit(assign(r2BD3, r2BAE, 0x01));

                                       body.emit(assign(r2BD4, r2BAD, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2BDE->else_instructions;

                                       body.emit(assign(r2BD1, bit_or(body.constant(0u), r2BAE), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2BE1 = less(r2BD2, body.constant(int(64)));
                                       ir_if *f2BE0 = new(mem_ctx) ir_if(operand(r2BE1).val);
                                       exec_list *const f2BE0_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2BE0->then_instructions;

                                          body.emit(assign(r2BD3, lshift(r2BAD, r2BD6), 0x01));

                                          ir_expression *const r2BE2 = bit_and(r2BD2, body.constant(int(31)));
                                          body.emit(assign(r2BD4, rshift(r2BAD, r2BE2), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2BE0->else_instructions;

                                          ir_variable *const r2BE3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2BE5 = equal(r2BD2, body.constant(int(64)));
                                          ir_if *f2BE4 = new(mem_ctx) ir_if(operand(r2BE5).val);
                                          exec_list *const f2BE4_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2BE4->then_instructions;

                                             body.emit(assign(r2BE3, r2BAD, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2BE4->else_instructions;

                                             ir_expression *const r2BE6 = nequal(r2BAD, body.constant(0u));
                                             ir_expression *const r2BE7 = expr(ir_unop_b2i, r2BE6);
                                             body.emit(assign(r2BE3, expr(ir_unop_i2u, r2BE7), 0x01));


                                          body.instructions = f2BE4_parent_instructions;
                                          body.emit(f2BE4);

                                          /* END IF */

                                          body.emit(assign(r2BD3, r2BE3, 0x01));

                                          body.emit(assign(r2BD4, body.constant(0u), 0x01));


                                       body.instructions = f2BE0_parent_instructions;
                                       body.emit(f2BE0);

                                       /* END IF */


                                    body.instructions = f2BDE_parent_instructions;
                                    body.emit(f2BDE);

                                    /* END IF */

                                    body.emit(assign(r2BD5, body.constant(0u), 0x01));


                                 body.instructions = f2BDA_parent_instructions;
                                 body.emit(f2BDA);

                                 /* END IF */

                                 ir_expression *const r2BE8 = nequal(r2BD1, body.constant(0u));
                                 ir_expression *const r2BE9 = expr(ir_unop_b2i, r2BE8);
                                 ir_expression *const r2BEA = expr(ir_unop_i2u, r2BE9);
                                 body.emit(assign(r2BD3, bit_or(r2BD3, r2BEA), 0x01));


                              body.instructions = f2BD8_parent_instructions;
                              body.emit(f2BD8);

                              /* END IF */

                              body.emit(assign(r2BAD, r2BD5, 0x01));

                              body.emit(assign(r2BAE, r2BD4, 0x01));

                              body.emit(assign(r2BAF, r2BD3, 0x01));


                           body.instructions = f2BC7_parent_instructions;
                           body.emit(f2BC7);

                           /* END IF */

                           body.emit(assign(r2BAC, sub(r2BAC, r2BB0), 0x01));

                           ir_variable *const r2BEB = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2BEB, r2BAC, 0x01));

                           ir_variable *const r2BEC = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2BEC, r2BAD, 0x01));

                           ir_variable *const r2BED = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2BED, r2BAE, 0x01));

                           ir_variable *const r2BEE = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r2BEE, r2BAF, 0x01));

                           ir_variable *const r2BEF = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r2BEF, body.constant(true), 0x01));

                           ir_variable *const r2BF0 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r2BF1 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r2BF1);
                           ir_expression *const r2BF2 = expr(ir_unop_u2i, r2BAF);
                           body.emit(assign(r2BF1, less(r2BF2, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2BF4 = lequal(body.constant(int(2045)), r2BAC);
                           ir_if *f2BF3 = new(mem_ctx) ir_if(operand(r2BF4).val);
                           exec_list *const f2BF3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BF3->then_instructions;

                              ir_variable *const r2BF5 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2BF7 = less(body.constant(int(2045)), r2BAC);
                              ir_if *f2BF6 = new(mem_ctx) ir_if(operand(r2BF7).val);
                              exec_list *const f2BF6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BF6->then_instructions;

                                 body.emit(assign(r2BF5, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2BF6->else_instructions;

                                 ir_variable *const r2BF8 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2BFA = equal(r2BAC, body.constant(int(2045)));
                                 ir_if *f2BF9 = new(mem_ctx) ir_if(operand(r2BFA).val);
                                 exec_list *const f2BF9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2BF9->then_instructions;

                                    ir_expression *const r2BFB = equal(body.constant(2097151u), r2BAD);
                                    ir_expression *const r2BFC = equal(body.constant(4294967295u), r2BAE);
                                    body.emit(assign(r2BF8, logic_and(r2BFB, r2BFC), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2BF9->else_instructions;

                                    body.emit(assign(r2BF8, body.constant(false), 0x01));


                                 body.instructions = f2BF9_parent_instructions;
                                 body.emit(f2BF9);

                                 /* END IF */

                                 body.emit(assign(r2BF5, logic_and(r2BF8, r2BF1), 0x01));


                              body.instructions = f2BF6_parent_instructions;
                              body.emit(f2BF6);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2BFD = new(mem_ctx) ir_if(operand(r2BF5).val);
                              exec_list *const f2BFD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BFD->then_instructions;

                                 ir_variable *const r2BFE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2BFE);
                                 ir_expression *const r2BFF = lshift(r2901, body.constant(int(31)));
                                 body.emit(assign(r2BFE, add(r2BFF, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r2BFE, body.constant(0u), 0x01));

                                 body.emit(assign(r2BF0, r2BFE, 0x03));

                                 body.emit(assign(r2BEF, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2BFD->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2C01 = less(r2BAC, body.constant(int(0)));
                                 ir_if *f2C00 = new(mem_ctx) ir_if(operand(r2C01).val);
                                 exec_list *const f2C00_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C00->then_instructions;

                                    ir_variable *const r2C02 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r2C02, r2BAF, 0x01));

                                    ir_variable *const r2C03 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r2C03, neg(r2BAC), 0x01));

                                    ir_variable *const r2C04 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r2C04);
                                    ir_variable *const r2C05 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r2C05);
                                    ir_variable *const r2C06 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2C06);
                                    ir_variable *const r2C07 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2C08 = neg(r2C03);
                                    body.emit(assign(r2C07, bit_and(r2C08, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2C0A = equal(r2C03, body.constant(int(0)));
                                    ir_if *f2C09 = new(mem_ctx) ir_if(operand(r2C0A).val);
                                    exec_list *const f2C09_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C09->then_instructions;

                                       body.emit(assign(r2C04, r2BAF, 0x01));

                                       body.emit(assign(r2C05, r2BAE, 0x01));

                                       body.emit(assign(r2C06, r2BAD, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2C09->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2C0C = less(r2C03, body.constant(int(32)));
                                       ir_if *f2C0B = new(mem_ctx) ir_if(operand(r2C0C).val);
                                       exec_list *const f2C0B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2C0B->then_instructions;

                                          body.emit(assign(r2C04, lshift(r2BAE, r2C07), 0x01));

                                          ir_expression *const r2C0D = lshift(r2BAD, r2C07);
                                          ir_expression *const r2C0E = rshift(r2BAE, r2C03);
                                          body.emit(assign(r2C05, bit_or(r2C0D, r2C0E), 0x01));

                                          body.emit(assign(r2C06, rshift(r2BAD, r2C03), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2C0B->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2C10 = equal(r2C03, body.constant(int(32)));
                                          ir_if *f2C0F = new(mem_ctx) ir_if(operand(r2C10).val);
                                          exec_list *const f2C0F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2C0F->then_instructions;

                                             body.emit(assign(r2C04, r2BAE, 0x01));

                                             body.emit(assign(r2C05, r2BAD, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2C0F->else_instructions;

                                             body.emit(assign(r2C02, bit_or(r2BAF, r2BAE), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r2C12 = less(r2C03, body.constant(int(64)));
                                             ir_if *f2C11 = new(mem_ctx) ir_if(operand(r2C12).val);
                                             exec_list *const f2C11_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2C11->then_instructions;

                                                body.emit(assign(r2C04, lshift(r2BAD, r2C07), 0x01));

                                                ir_expression *const r2C13 = bit_and(r2C03, body.constant(int(31)));
                                                body.emit(assign(r2C05, rshift(r2BAD, r2C13), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2C11->else_instructions;

                                                ir_variable *const r2C14 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2C16 = equal(r2C03, body.constant(int(64)));
                                                ir_if *f2C15 = new(mem_ctx) ir_if(operand(r2C16).val);
                                                exec_list *const f2C15_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2C15->then_instructions;

                                                   body.emit(assign(r2C14, r2BAD, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2C15->else_instructions;

                                                   ir_expression *const r2C17 = nequal(r2BAD, body.constant(0u));
                                                   ir_expression *const r2C18 = expr(ir_unop_b2i, r2C17);
                                                   body.emit(assign(r2C14, expr(ir_unop_i2u, r2C18), 0x01));


                                                body.instructions = f2C15_parent_instructions;
                                                body.emit(f2C15);

                                                /* END IF */

                                                body.emit(assign(r2C04, r2C14, 0x01));

                                                body.emit(assign(r2C05, body.constant(0u), 0x01));


                                             body.instructions = f2C11_parent_instructions;
                                             body.emit(f2C11);

                                             /* END IF */


                                          body.instructions = f2C0F_parent_instructions;
                                          body.emit(f2C0F);

                                          /* END IF */

                                          body.emit(assign(r2C06, body.constant(0u), 0x01));


                                       body.instructions = f2C0B_parent_instructions;
                                       body.emit(f2C0B);

                                       /* END IF */

                                       ir_expression *const r2C19 = nequal(r2C02, body.constant(0u));
                                       ir_expression *const r2C1A = expr(ir_unop_b2i, r2C19);
                                       ir_expression *const r2C1B = expr(ir_unop_i2u, r2C1A);
                                       body.emit(assign(r2C04, bit_or(r2C04, r2C1B), 0x01));


                                    body.instructions = f2C09_parent_instructions;
                                    body.emit(f2C09);

                                    /* END IF */

                                    body.emit(assign(r2BEC, r2C06, 0x01));

                                    body.emit(assign(r2BED, r2C05, 0x01));

                                    body.emit(assign(r2BEE, r2C04, 0x01));

                                    body.emit(assign(r2BEB, body.constant(int(0)), 0x01));

                                    body.emit(assign(r2BF1, less(r2C04, body.constant(0u)), 0x01));


                                 body.instructions = f2C00_parent_instructions;
                                 body.emit(f2C00);

                                 /* END IF */


                              body.instructions = f2BFD_parent_instructions;
                              body.emit(f2BFD);

                              /* END IF */


                           body.instructions = f2BF3_parent_instructions;
                           body.emit(f2BF3);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2C1C = new(mem_ctx) ir_if(operand(r2BEF).val);
                           exec_list *const f2C1C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C1C->then_instructions;

                              /* IF CONDITION */
                              ir_if *f2C1D = new(mem_ctx) ir_if(operand(r2BF1).val);
                              exec_list *const f2C1D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C1D->then_instructions;

                                 ir_variable *const r2C1E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r2C1E, add(r2BED, body.constant(1u)), 0x01));

                                 ir_expression *const r2C1F = less(r2C1E, r2BED);
                                 ir_expression *const r2C20 = expr(ir_unop_b2i, r2C1F);
                                 ir_expression *const r2C21 = expr(ir_unop_i2u, r2C20);
                                 body.emit(assign(r2BEC, add(r2BEC, r2C21), 0x01));

                                 ir_expression *const r2C22 = equal(r2BEE, body.constant(0u));
                                 ir_expression *const r2C23 = expr(ir_unop_b2i, r2C22);
                                 ir_expression *const r2C24 = expr(ir_unop_i2u, r2C23);
                                 ir_expression *const r2C25 = add(r2BEE, r2C24);
                                 ir_expression *const r2C26 = bit_and(r2C25, body.constant(1u));
                                 ir_expression *const r2C27 = expr(ir_unop_bit_not, r2C26);
                                 body.emit(assign(r2BED, bit_and(r2C1E, r2C27), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C1D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2C29 = bit_or(r2BEC, r2BED);
                                 ir_expression *const r2C2A = equal(r2C29, body.constant(0u));
                                 ir_if *f2C28 = new(mem_ctx) ir_if(operand(r2C2A).val);
                                 exec_list *const f2C28_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C28->then_instructions;

                                    body.emit(assign(r2BEB, body.constant(int(0)), 0x01));


                                 body.instructions = f2C28_parent_instructions;
                                 body.emit(f2C28);

                                 /* END IF */


                              body.instructions = f2C1D_parent_instructions;
                              body.emit(f2C1D);

                              /* END IF */

                              ir_variable *const r2C2B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2C2B);
                              ir_expression *const r2C2C = lshift(r2901, body.constant(int(31)));
                              ir_expression *const r2C2D = expr(ir_unop_i2u, r2BEB);
                              ir_expression *const r2C2E = lshift(r2C2D, body.constant(int(20)));
                              ir_expression *const r2C2F = add(r2C2C, r2C2E);
                              body.emit(assign(r2C2B, add(r2C2F, r2BEC), 0x02));

                              body.emit(assign(r2C2B, r2BED, 0x01));

                              body.emit(assign(r2BF0, r2C2B, 0x03));

                              body.emit(assign(r2BEF, body.constant(false), 0x01));


                           body.instructions = f2C1C_parent_instructions;
                           body.emit(f2C1C);

                           /* END IF */

                           body.emit(assign(r2902, r2BF0, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2BA4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2C31 = less(swizzle_x(r2907), swizzle_x(r2905));
                           ir_if *f2C30 = new(mem_ctx) ir_if(operand(r2C31).val);
                           exec_list *const f2C30_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C30->then_instructions;

                              ir_variable *const r2C32 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r2C33 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2C33, sub(swizzle_x(r2905), swizzle_x(r2907)), 0x01));

                              ir_expression *const r2C34 = sub(swizzle_y(r2905), swizzle_y(r2907));
                              ir_expression *const r2C35 = less(swizzle_x(r2905), swizzle_x(r2907));
                              ir_expression *const r2C36 = expr(ir_unop_b2i, r2C35);
                              ir_expression *const r2C37 = expr(ir_unop_i2u, r2C36);
                              body.emit(assign(r2C32, sub(r2C34, r2C37), 0x01));

                              body.emit(assign(r2901, bit_xor(r2901, body.constant(1u)), 0x01));

                              body.emit(assign(r2908, add(r2904, body.constant(int(-1))), 0x01));

                              ir_variable *const r2C38 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2C38, add(r2908, body.constant(int(-10))), 0x01));

                              ir_variable *const r2C39 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2C39, r2C32, 0x01));

                              ir_variable *const r2C3A = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2C3A, r2C33, 0x01));

                              ir_variable *const r2C3B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r2C3B);
                              ir_variable *const r2C3C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2C3C);
                              /* IF CONDITION */
                              ir_expression *const r2C3E = equal(r2C32, body.constant(0u));
                              ir_if *f2C3D = new(mem_ctx) ir_if(operand(r2C3E).val);
                              exec_list *const f2C3D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C3D->then_instructions;

                                 body.emit(assign(r2C39, r2C33, 0x01));

                                 body.emit(assign(r2C3A, body.constant(0u), 0x01));

                                 body.emit(assign(r2C38, add(r2C38, body.constant(int(-32))), 0x01));


                              body.instructions = f2C3D_parent_instructions;
                              body.emit(f2C3D);

                              /* END IF */

                              ir_variable *const r2C3F = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r2C3F, r2C39, 0x01));

                              ir_variable *const r2C40 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r2C41 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2C41);
                              /* IF CONDITION */
                              ir_expression *const r2C43 = equal(r2C39, body.constant(0u));
                              ir_if *f2C42 = new(mem_ctx) ir_if(operand(r2C43).val);
                              exec_list *const f2C42_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C42->then_instructions;

                                 body.emit(assign(r2C40, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C42->else_instructions;

                                 body.emit(assign(r2C41, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2C45 = bit_and(r2C39, body.constant(4294901760u));
                                 ir_expression *const r2C46 = equal(r2C45, body.constant(0u));
                                 ir_if *f2C44 = new(mem_ctx) ir_if(operand(r2C46).val);
                                 exec_list *const f2C44_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C44->then_instructions;

                                    body.emit(assign(r2C41, body.constant(int(16)), 0x01));

                                    body.emit(assign(r2C3F, lshift(r2C39, body.constant(int(16))), 0x01));


                                 body.instructions = f2C44_parent_instructions;
                                 body.emit(f2C44);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2C48 = bit_and(r2C3F, body.constant(4278190080u));
                                 ir_expression *const r2C49 = equal(r2C48, body.constant(0u));
                                 ir_if *f2C47 = new(mem_ctx) ir_if(operand(r2C49).val);
                                 exec_list *const f2C47_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C47->then_instructions;

                                    body.emit(assign(r2C41, add(r2C41, body.constant(int(8))), 0x01));

                                    body.emit(assign(r2C3F, lshift(r2C3F, body.constant(int(8))), 0x01));


                                 body.instructions = f2C47_parent_instructions;
                                 body.emit(f2C47);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2C4B = bit_and(r2C3F, body.constant(4026531840u));
                                 ir_expression *const r2C4C = equal(r2C4B, body.constant(0u));
                                 ir_if *f2C4A = new(mem_ctx) ir_if(operand(r2C4C).val);
                                 exec_list *const f2C4A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C4A->then_instructions;

                                    body.emit(assign(r2C41, add(r2C41, body.constant(int(4))), 0x01));

                                    body.emit(assign(r2C3F, lshift(r2C3F, body.constant(int(4))), 0x01));


                                 body.instructions = f2C4A_parent_instructions;
                                 body.emit(f2C4A);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2C4E = bit_and(r2C3F, body.constant(3221225472u));
                                 ir_expression *const r2C4F = equal(r2C4E, body.constant(0u));
                                 ir_if *f2C4D = new(mem_ctx) ir_if(operand(r2C4F).val);
                                 exec_list *const f2C4D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C4D->then_instructions;

                                    body.emit(assign(r2C41, add(r2C41, body.constant(int(2))), 0x01));

                                    body.emit(assign(r2C3F, lshift(r2C3F, body.constant(int(2))), 0x01));


                                 body.instructions = f2C4D_parent_instructions;
                                 body.emit(f2C4D);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2C51 = bit_and(r2C3F, body.constant(2147483648u));
                                 ir_expression *const r2C52 = equal(r2C51, body.constant(0u));
                                 ir_if *f2C50 = new(mem_ctx) ir_if(operand(r2C52).val);
                                 exec_list *const f2C50_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C50->then_instructions;

                                    body.emit(assign(r2C41, add(r2C41, body.constant(int(1))), 0x01));


                                 body.instructions = f2C50_parent_instructions;
                                 body.emit(f2C50);

                                 /* END IF */

                                 body.emit(assign(r2C40, r2C41, 0x01));


                              body.instructions = f2C42_parent_instructions;
                              body.emit(f2C42);

                              /* END IF */

                              body.emit(assign(r2C3C, add(r2C40, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2C54 = lequal(body.constant(int(0)), r2C3C);
                              ir_if *f2C53 = new(mem_ctx) ir_if(operand(r2C54).val);
                              exec_list *const f2C53_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C53->then_instructions;

                                 body.emit(assign(r2C3B, body.constant(0u), 0x01));

                                 ir_variable *const r2C55 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r2C55, lshift(r2C3A, r2C3C), 0x01));

                                 ir_variable *const r2C56 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2C58 = equal(r2C3C, body.constant(int(0)));
                                 ir_if *f2C57 = new(mem_ctx) ir_if(operand(r2C58).val);
                                 exec_list *const f2C57_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C57->then_instructions;

                                    body.emit(assign(r2C56, r2C39, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C57->else_instructions;

                                    ir_expression *const r2C59 = lshift(r2C39, r2C3C);
                                    ir_expression *const r2C5A = neg(r2C3C);
                                    ir_expression *const r2C5B = bit_and(r2C5A, body.constant(int(31)));
                                    ir_expression *const r2C5C = rshift(r2C3A, r2C5B);
                                    body.emit(assign(r2C56, bit_or(r2C59, r2C5C), 0x01));


                                 body.instructions = f2C57_parent_instructions;
                                 body.emit(f2C57);

                                 /* END IF */

                                 body.emit(assign(r2C39, r2C56, 0x01));

                                 body.emit(assign(r2C3A, r2C55, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C53->else_instructions;

                                 ir_variable *const r2C5D = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2C5D, body.constant(0u), 0x01));

                                 ir_variable *const r2C5E = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2C5E, neg(r2C3C), 0x01));

                                 ir_variable *const r2C5F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2C5F);
                                 ir_variable *const r2C60 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2C60);
                                 ir_variable *const r2C61 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2C61);
                                 ir_variable *const r2C62 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2C63 = neg(r2C5E);
                                 body.emit(assign(r2C62, bit_and(r2C63, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2C65 = equal(r2C5E, body.constant(int(0)));
                                 ir_if *f2C64 = new(mem_ctx) ir_if(operand(r2C65).val);
                                 exec_list *const f2C64_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C64->then_instructions;

                                    body.emit(assign(r2C5F, r2C5D, 0x01));

                                    body.emit(assign(r2C60, r2C3A, 0x01));

                                    body.emit(assign(r2C61, r2C39, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C64->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2C67 = less(r2C5E, body.constant(int(32)));
                                    ir_if *f2C66 = new(mem_ctx) ir_if(operand(r2C67).val);
                                    exec_list *const f2C66_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C66->then_instructions;

                                       body.emit(assign(r2C5F, lshift(r2C3A, r2C62), 0x01));

                                       ir_expression *const r2C68 = lshift(r2C39, r2C62);
                                       ir_expression *const r2C69 = rshift(r2C3A, r2C5E);
                                       body.emit(assign(r2C60, bit_or(r2C68, r2C69), 0x01));

                                       body.emit(assign(r2C61, rshift(r2C39, r2C5E), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2C66->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2C6B = equal(r2C5E, body.constant(int(32)));
                                       ir_if *f2C6A = new(mem_ctx) ir_if(operand(r2C6B).val);
                                       exec_list *const f2C6A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2C6A->then_instructions;

                                          body.emit(assign(r2C5F, r2C3A, 0x01));

                                          body.emit(assign(r2C60, r2C39, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2C6A->else_instructions;

                                          body.emit(assign(r2C5D, bit_or(body.constant(0u), r2C3A), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2C6D = less(r2C5E, body.constant(int(64)));
                                          ir_if *f2C6C = new(mem_ctx) ir_if(operand(r2C6D).val);
                                          exec_list *const f2C6C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2C6C->then_instructions;

                                             body.emit(assign(r2C5F, lshift(r2C39, r2C62), 0x01));

                                             ir_expression *const r2C6E = bit_and(r2C5E, body.constant(int(31)));
                                             body.emit(assign(r2C60, rshift(r2C39, r2C6E), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2C6C->else_instructions;

                                             ir_variable *const r2C6F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2C71 = equal(r2C5E, body.constant(int(64)));
                                             ir_if *f2C70 = new(mem_ctx) ir_if(operand(r2C71).val);
                                             exec_list *const f2C70_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2C70->then_instructions;

                                                body.emit(assign(r2C6F, r2C39, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2C70->else_instructions;

                                                ir_expression *const r2C72 = nequal(r2C39, body.constant(0u));
                                                ir_expression *const r2C73 = expr(ir_unop_b2i, r2C72);
                                                body.emit(assign(r2C6F, expr(ir_unop_i2u, r2C73), 0x01));


                                             body.instructions = f2C70_parent_instructions;
                                             body.emit(f2C70);

                                             /* END IF */

                                             body.emit(assign(r2C5F, r2C6F, 0x01));

                                             body.emit(assign(r2C60, body.constant(0u), 0x01));


                                          body.instructions = f2C6C_parent_instructions;
                                          body.emit(f2C6C);

                                          /* END IF */


                                       body.instructions = f2C6A_parent_instructions;
                                       body.emit(f2C6A);

                                       /* END IF */

                                       body.emit(assign(r2C61, body.constant(0u), 0x01));


                                    body.instructions = f2C66_parent_instructions;
                                    body.emit(f2C66);

                                    /* END IF */

                                    ir_expression *const r2C74 = nequal(r2C5D, body.constant(0u));
                                    ir_expression *const r2C75 = expr(ir_unop_b2i, r2C74);
                                    ir_expression *const r2C76 = expr(ir_unop_i2u, r2C75);
                                    body.emit(assign(r2C5F, bit_or(r2C5F, r2C76), 0x01));


                                 body.instructions = f2C64_parent_instructions;
                                 body.emit(f2C64);

                                 /* END IF */

                                 body.emit(assign(r2C39, r2C61, 0x01));

                                 body.emit(assign(r2C3A, r2C60, 0x01));

                                 body.emit(assign(r2C3B, r2C5F, 0x01));


                              body.instructions = f2C53_parent_instructions;
                              body.emit(f2C53);

                              /* END IF */

                              body.emit(assign(r2C38, sub(r2C38, r2C3C), 0x01));

                              ir_variable *const r2C77 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2C77, r2C38, 0x01));

                              ir_variable *const r2C78 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2C78, r2C39, 0x01));

                              ir_variable *const r2C79 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2C79, r2C3A, 0x01));

                              ir_variable *const r2C7A = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r2C7A, r2C3B, 0x01));

                              ir_variable *const r2C7B = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r2C7B, body.constant(true), 0x01));

                              ir_variable *const r2C7C = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r2C7D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r2C7D);
                              ir_expression *const r2C7E = expr(ir_unop_u2i, r2C3B);
                              body.emit(assign(r2C7D, less(r2C7E, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2C80 = lequal(body.constant(int(2045)), r2C38);
                              ir_if *f2C7F = new(mem_ctx) ir_if(operand(r2C80).val);
                              exec_list *const f2C7F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C7F->then_instructions;

                                 ir_variable *const r2C81 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2C83 = less(body.constant(int(2045)), r2C38);
                                 ir_if *f2C82 = new(mem_ctx) ir_if(operand(r2C83).val);
                                 exec_list *const f2C82_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C82->then_instructions;

                                    body.emit(assign(r2C81, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C82->else_instructions;

                                    ir_variable *const r2C84 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2C86 = equal(r2C38, body.constant(int(2045)));
                                    ir_if *f2C85 = new(mem_ctx) ir_if(operand(r2C86).val);
                                    exec_list *const f2C85_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C85->then_instructions;

                                       ir_expression *const r2C87 = equal(body.constant(2097151u), r2C39);
                                       ir_expression *const r2C88 = equal(body.constant(4294967295u), r2C3A);
                                       body.emit(assign(r2C84, logic_and(r2C87, r2C88), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2C85->else_instructions;

                                       body.emit(assign(r2C84, body.constant(false), 0x01));


                                    body.instructions = f2C85_parent_instructions;
                                    body.emit(f2C85);

                                    /* END IF */

                                    body.emit(assign(r2C81, logic_and(r2C84, r2C7D), 0x01));


                                 body.instructions = f2C82_parent_instructions;
                                 body.emit(f2C82);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f2C89 = new(mem_ctx) ir_if(operand(r2C81).val);
                                 exec_list *const f2C89_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C89->then_instructions;

                                    ir_variable *const r2C8A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r2C8A);
                                    ir_expression *const r2C8B = lshift(r2901, body.constant(int(31)));
                                    body.emit(assign(r2C8A, add(r2C8B, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r2C8A, body.constant(0u), 0x01));

                                    body.emit(assign(r2C7C, r2C8A, 0x03));

                                    body.emit(assign(r2C7B, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C89->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2C8D = less(r2C38, body.constant(int(0)));
                                    ir_if *f2C8C = new(mem_ctx) ir_if(operand(r2C8D).val);
                                    exec_list *const f2C8C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C8C->then_instructions;

                                       ir_variable *const r2C8E = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r2C8E, r2C3B, 0x01));

                                       ir_variable *const r2C8F = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r2C8F, neg(r2C38), 0x01));

                                       ir_variable *const r2C90 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r2C90);
                                       ir_variable *const r2C91 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r2C91);
                                       ir_variable *const r2C92 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r2C92);
                                       ir_variable *const r2C93 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r2C94 = neg(r2C8F);
                                       body.emit(assign(r2C93, bit_and(r2C94, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2C96 = equal(r2C8F, body.constant(int(0)));
                                       ir_if *f2C95 = new(mem_ctx) ir_if(operand(r2C96).val);
                                       exec_list *const f2C95_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2C95->then_instructions;

                                          body.emit(assign(r2C90, r2C3B, 0x01));

                                          body.emit(assign(r2C91, r2C3A, 0x01));

                                          body.emit(assign(r2C92, r2C39, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2C95->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2C98 = less(r2C8F, body.constant(int(32)));
                                          ir_if *f2C97 = new(mem_ctx) ir_if(operand(r2C98).val);
                                          exec_list *const f2C97_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2C97->then_instructions;

                                             body.emit(assign(r2C90, lshift(r2C3A, r2C93), 0x01));

                                             ir_expression *const r2C99 = lshift(r2C39, r2C93);
                                             ir_expression *const r2C9A = rshift(r2C3A, r2C8F);
                                             body.emit(assign(r2C91, bit_or(r2C99, r2C9A), 0x01));

                                             body.emit(assign(r2C92, rshift(r2C39, r2C8F), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2C97->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r2C9C = equal(r2C8F, body.constant(int(32)));
                                             ir_if *f2C9B = new(mem_ctx) ir_if(operand(r2C9C).val);
                                             exec_list *const f2C9B_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2C9B->then_instructions;

                                                body.emit(assign(r2C90, r2C3A, 0x01));

                                                body.emit(assign(r2C91, r2C39, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2C9B->else_instructions;

                                                body.emit(assign(r2C8E, bit_or(r2C3B, r2C3A), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r2C9E = less(r2C8F, body.constant(int(64)));
                                                ir_if *f2C9D = new(mem_ctx) ir_if(operand(r2C9E).val);
                                                exec_list *const f2C9D_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2C9D->then_instructions;

                                                   body.emit(assign(r2C90, lshift(r2C39, r2C93), 0x01));

                                                   ir_expression *const r2C9F = bit_and(r2C8F, body.constant(int(31)));
                                                   body.emit(assign(r2C91, rshift(r2C39, r2C9F), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2C9D->else_instructions;

                                                   ir_variable *const r2CA0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r2CA2 = equal(r2C8F, body.constant(int(64)));
                                                   ir_if *f2CA1 = new(mem_ctx) ir_if(operand(r2CA2).val);
                                                   exec_list *const f2CA1_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f2CA1->then_instructions;

                                                      body.emit(assign(r2CA0, r2C39, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f2CA1->else_instructions;

                                                      ir_expression *const r2CA3 = nequal(r2C39, body.constant(0u));
                                                      ir_expression *const r2CA4 = expr(ir_unop_b2i, r2CA3);
                                                      body.emit(assign(r2CA0, expr(ir_unop_i2u, r2CA4), 0x01));


                                                   body.instructions = f2CA1_parent_instructions;
                                                   body.emit(f2CA1);

                                                   /* END IF */

                                                   body.emit(assign(r2C90, r2CA0, 0x01));

                                                   body.emit(assign(r2C91, body.constant(0u), 0x01));


                                                body.instructions = f2C9D_parent_instructions;
                                                body.emit(f2C9D);

                                                /* END IF */


                                             body.instructions = f2C9B_parent_instructions;
                                             body.emit(f2C9B);

                                             /* END IF */

                                             body.emit(assign(r2C92, body.constant(0u), 0x01));


                                          body.instructions = f2C97_parent_instructions;
                                          body.emit(f2C97);

                                          /* END IF */

                                          ir_expression *const r2CA5 = nequal(r2C8E, body.constant(0u));
                                          ir_expression *const r2CA6 = expr(ir_unop_b2i, r2CA5);
                                          ir_expression *const r2CA7 = expr(ir_unop_i2u, r2CA6);
                                          body.emit(assign(r2C90, bit_or(r2C90, r2CA7), 0x01));


                                       body.instructions = f2C95_parent_instructions;
                                       body.emit(f2C95);

                                       /* END IF */

                                       body.emit(assign(r2C78, r2C92, 0x01));

                                       body.emit(assign(r2C79, r2C91, 0x01));

                                       body.emit(assign(r2C7A, r2C90, 0x01));

                                       body.emit(assign(r2C77, body.constant(int(0)), 0x01));

                                       body.emit(assign(r2C7D, less(r2C90, body.constant(0u)), 0x01));


                                    body.instructions = f2C8C_parent_instructions;
                                    body.emit(f2C8C);

                                    /* END IF */


                                 body.instructions = f2C89_parent_instructions;
                                 body.emit(f2C89);

                                 /* END IF */


                              body.instructions = f2C7F_parent_instructions;
                              body.emit(f2C7F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2CA8 = new(mem_ctx) ir_if(operand(r2C7B).val);
                              exec_list *const f2CA8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2CA8->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f2CA9 = new(mem_ctx) ir_if(operand(r2C7D).val);
                                 exec_list *const f2CA9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2CA9->then_instructions;

                                    ir_variable *const r2CAA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r2CAA, add(r2C79, body.constant(1u)), 0x01));

                                    ir_expression *const r2CAB = less(r2CAA, r2C79);
                                    ir_expression *const r2CAC = expr(ir_unop_b2i, r2CAB);
                                    ir_expression *const r2CAD = expr(ir_unop_i2u, r2CAC);
                                    body.emit(assign(r2C78, add(r2C78, r2CAD), 0x01));

                                    ir_expression *const r2CAE = equal(r2C7A, body.constant(0u));
                                    ir_expression *const r2CAF = expr(ir_unop_b2i, r2CAE);
                                    ir_expression *const r2CB0 = expr(ir_unop_i2u, r2CAF);
                                    ir_expression *const r2CB1 = add(r2C7A, r2CB0);
                                    ir_expression *const r2CB2 = bit_and(r2CB1, body.constant(1u));
                                    ir_expression *const r2CB3 = expr(ir_unop_bit_not, r2CB2);
                                    body.emit(assign(r2C79, bit_and(r2CAA, r2CB3), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2CA9->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2CB5 = bit_or(r2C78, r2C79);
                                    ir_expression *const r2CB6 = equal(r2CB5, body.constant(0u));
                                    ir_if *f2CB4 = new(mem_ctx) ir_if(operand(r2CB6).val);
                                    exec_list *const f2CB4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2CB4->then_instructions;

                                       body.emit(assign(r2C77, body.constant(int(0)), 0x01));


                                    body.instructions = f2CB4_parent_instructions;
                                    body.emit(f2CB4);

                                    /* END IF */


                                 body.instructions = f2CA9_parent_instructions;
                                 body.emit(f2CA9);

                                 /* END IF */

                                 ir_variable *const r2CB7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2CB7);
                                 ir_expression *const r2CB8 = lshift(r2901, body.constant(int(31)));
                                 ir_expression *const r2CB9 = expr(ir_unop_i2u, r2C77);
                                 ir_expression *const r2CBA = lshift(r2CB9, body.constant(int(20)));
                                 ir_expression *const r2CBB = add(r2CB8, r2CBA);
                                 body.emit(assign(r2CB7, add(r2CBB, r2C78), 0x02));

                                 body.emit(assign(r2CB7, r2C79, 0x01));

                                 body.emit(assign(r2C7C, r2CB7, 0x03));

                                 body.emit(assign(r2C7B, body.constant(false), 0x01));


                              body.instructions = f2CA8_parent_instructions;
                              body.emit(f2CA8);

                              /* END IF */

                              body.emit(assign(r2902, r2C7C, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2C30->else_instructions;

                              ir_variable *const r2CBC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2CBC);
                              body.emit(assign(r2CBC, body.constant(0u), 0x02));

                              body.emit(assign(r2CBC, body.constant(0u), 0x01));

                              body.emit(assign(r2902, r2CBC, 0x03));


                           body.instructions = f2C30_parent_instructions;
                           body.emit(f2C30);

                           /* END IF */


                        body.instructions = f2BA4_parent_instructions;
                        body.emit(f2BA4);

                        /* END IF */


                     body.instructions = f2B18_parent_instructions;
                     body.emit(f2B18);

                     /* END IF */


                  body.instructions = f2A8C_parent_instructions;
                  body.emit(f2A8C);

                  /* END IF */


               body.instructions = f2A77_parent_instructions;
               body.emit(f2A77);

               /* END IF */


            body.instructions = f29C6_parent_instructions;
            body.emit(f29C6);

            /* END IF */


         body.instructions = f2913_parent_instructions;
         body.emit(f2913);

         /* END IF */

         body.emit(assign(r28FD, r2902, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f28FF->else_instructions;

         ir_variable *const r2CBD = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r2CBD, body.constant(true), 0x01));

         ir_variable *const r2CBE = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2CBF = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2CBF);
         ir_variable *const r2CC0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r2CC0);
         ir_variable *const r2CC1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r2CC1);
         ir_variable *const r2CC2 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2CC2);
         ir_variable *const r2CC3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r2CC3);
         ir_variable *const r2CC4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r2CC4);
         body.emit(assign(r2CC4, body.constant(0u), 0x01));

         body.emit(assign(r2CC3, body.constant(0u), 0x01));

         ir_variable *const r2CC5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r2CC5);
         body.emit(assign(r2CC5, bit_and(swizzle_y(r28C8), body.constant(1048575u)), 0x02));

         body.emit(assign(r2CC5, swizzle_x(r28C8), 0x01));

         body.emit(assign(r2CC1, r2CC5, 0x03));

         ir_variable *const r2CC6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2CC7 = rshift(swizzle_y(r28C8), body.constant(int(20)));
         ir_expression *const r2CC8 = bit_and(r2CC7, body.constant(2047u));
         body.emit(assign(r2CC6, expr(ir_unop_u2i, r2CC8), 0x01));

         ir_variable *const r2CC9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r2CC9);
         body.emit(assign(r2CC9, body.constant(0u), 0x02));

         body.emit(assign(r2CC9, body.constant(0u), 0x01));

         body.emit(assign(r2CC0, r2CC9, 0x03));

         ir_variable *const r2CCA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r2CCA, body.constant(int(1023)), 0x01));

         ir_variable *const r2CCB = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2CCB, add(r2CC6, body.constant(int(-1023))), 0x01));

         body.emit(assign(r2CBF, r2CCB, 0x01));

         /* IF CONDITION */
         ir_expression *const r2CCD = less(body.constant(int(0)), r2CCB);
         ir_if *f2CCC = new(mem_ctx) ir_if(operand(r2CCD).val);
         exec_list *const f2CCC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2CCC->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2CCF = equal(r2CC6, body.constant(int(2047)));
            ir_if *f2CCE = new(mem_ctx) ir_if(operand(r2CCF).val);
            exec_list *const f2CCE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CCE->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2CD1 = bit_or(swizzle_y(r2CC5), swizzle_x(r28C8));
               ir_expression *const r2CD2 = nequal(r2CD1, body.constant(0u));
               ir_if *f2CD0 = new(mem_ctx) ir_if(operand(r2CD2).val);
               exec_list *const f2CD0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CD0->then_instructions;

                  ir_variable *const r2CD3 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2CD3, swizzle_x(r28C8), 0x01));

                  ir_variable *const r2CD4 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2CD4, body.constant(0u), 0x01));

                  ir_variable *const r2CD5 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2CD3, bit_or(swizzle_y(r28C8), body.constant(524288u)), 0x02));

                  body.emit(assign(r2CD4, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2CD7 = lshift(swizzle_y(r28C8), body.constant(int(1)));
                  ir_expression *const r2CD8 = lequal(body.constant(4292870144u), r2CD7);
                  ir_expression *const r2CD9 = nequal(swizzle_x(r28C8), body.constant(0u));
                  ir_expression *const r2CDA = bit_and(swizzle_y(r28C8), body.constant(1048575u));
                  ir_expression *const r2CDB = nequal(r2CDA, body.constant(0u));
                  ir_expression *const r2CDC = logic_or(r2CD9, r2CDB);
                  ir_expression *const r2CDD = logic_and(r2CD8, r2CDC);
                  ir_if *f2CD6 = new(mem_ctx) ir_if(operand(r2CDD).val);
                  exec_list *const f2CD6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2CD6->then_instructions;

                     body.emit(assign(r2CD5, r2CD3, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2CD6->else_instructions;

                     body.emit(assign(r2CD5, r2CD4, 0x03));


                  body.instructions = f2CD6_parent_instructions;
                  body.emit(f2CD6);

                  /* END IF */

                  body.emit(assign(r2CBE, r2CD5, 0x03));

                  body.emit(assign(r2CBD, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2CD0->else_instructions;

                  body.emit(assign(r2CBE, r28C8, 0x03));

                  body.emit(assign(r2CBD, body.constant(false), 0x01));


               body.instructions = f2CD0_parent_instructions;
               body.emit(f2CD0);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2CCE->else_instructions;

               body.emit(assign(r2CC0, body.constant(1048576u), 0x02));

               ir_variable *const r2CDE = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r2CDE, swizzle_y(r2CC0), 0x01));

               ir_variable *const r2CDF = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r2CDF, swizzle_x(r2CC0), 0x01));

               ir_variable *const r2CE0 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2CE0, body.constant(0u), 0x01));

               ir_variable *const r2CE1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2CE1);
               ir_variable *const r2CE2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2CE2);
               ir_variable *const r2CE3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2CE3);
               ir_variable *const r2CE4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2CE5 = neg(r2CCB);
               body.emit(assign(r2CE4, bit_and(r2CE5, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2CE7 = equal(r2CCB, body.constant(int(0)));
               ir_if *f2CE6 = new(mem_ctx) ir_if(operand(r2CE7).val);
               exec_list *const f2CE6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CE6->then_instructions;

                  body.emit(assign(r2CE1, r2CE0, 0x01));

                  body.emit(assign(r2CE2, r2CDF, 0x01));

                  body.emit(assign(r2CE3, r2CDE, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2CE6->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2CE9 = less(r2CCB, body.constant(int(32)));
                  ir_if *f2CE8 = new(mem_ctx) ir_if(operand(r2CE9).val);
                  exec_list *const f2CE8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2CE8->then_instructions;

                     body.emit(assign(r2CE1, body.constant(0u), 0x01));

                     ir_expression *const r2CEA = lshift(body.constant(1048576u), r2CE4);
                     body.emit(assign(r2CE2, bit_or(r2CEA, body.constant(0u)), 0x01));

                     body.emit(assign(r2CE3, rshift(body.constant(1048576u), r2CCB), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2CE8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2CEC = equal(r2CCB, body.constant(int(32)));
                     ir_if *f2CEB = new(mem_ctx) ir_if(operand(r2CEC).val);
                     exec_list *const f2CEB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2CEB->then_instructions;

                        body.emit(assign(r2CE1, r2CDF, 0x01));

                        body.emit(assign(r2CE2, r2CDE, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2CEB->else_instructions;

                        body.emit(assign(r2CE0, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2CEE = less(r2CCB, body.constant(int(64)));
                        ir_if *f2CED = new(mem_ctx) ir_if(operand(r2CEE).val);
                        exec_list *const f2CED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2CED->then_instructions;

                           body.emit(assign(r2CE1, lshift(body.constant(1048576u), r2CE4), 0x01));

                           ir_expression *const r2CEF = bit_and(r2CCB, body.constant(int(31)));
                           body.emit(assign(r2CE2, rshift(body.constant(1048576u), r2CEF), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2CED->else_instructions;

                           ir_variable *const r2CF0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2CF2 = equal(r2CCB, body.constant(int(64)));
                           ir_if *f2CF1 = new(mem_ctx) ir_if(operand(r2CF2).val);
                           exec_list *const f2CF1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2CF1->then_instructions;

                              body.emit(assign(r2CF0, r2CDE, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2CF1->else_instructions;

                              body.emit(assign(r2CF0, body.constant(1u), 0x01));


                           body.instructions = f2CF1_parent_instructions;
                           body.emit(f2CF1);

                           /* END IF */

                           body.emit(assign(r2CE1, r2CF0, 0x01));

                           body.emit(assign(r2CE2, body.constant(0u), 0x01));


                        body.instructions = f2CED_parent_instructions;
                        body.emit(f2CED);

                        /* END IF */


                     body.instructions = f2CEB_parent_instructions;
                     body.emit(f2CEB);

                     /* END IF */

                     body.emit(assign(r2CE3, body.constant(0u), 0x01));


                  body.instructions = f2CE8_parent_instructions;
                  body.emit(f2CE8);

                  /* END IF */

                  ir_expression *const r2CF3 = nequal(r2CE0, body.constant(0u));
                  ir_expression *const r2CF4 = expr(ir_unop_b2i, r2CF3);
                  ir_expression *const r2CF5 = expr(ir_unop_i2u, r2CF4);
                  body.emit(assign(r2CE1, bit_or(r2CE1, r2CF5), 0x01));


               body.instructions = f2CE6_parent_instructions;
               body.emit(f2CE6);

               /* END IF */

               body.emit(assign(r2CC0, r2CE3, 0x02));

               body.emit(assign(r2CC0, r2CE2, 0x01));

               body.emit(assign(r2CC3, r2CE1, 0x01));

               body.emit(assign(r2CC2, r2CC6, 0x01));


            body.instructions = f2CCE_parent_instructions;
            body.emit(f2CCE);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2CCC->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2CF7 = less(r2CCB, body.constant(int(0)));
            ir_if *f2CF6 = new(mem_ctx) ir_if(operand(r2CF7).val);
            exec_list *const f2CF6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CF6->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2CF9 = equal(r2CC6, body.constant(int(0)));
               ir_if *f2CF8 = new(mem_ctx) ir_if(operand(r2CF9).val);
               exec_list *const f2CF8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CF8->then_instructions;

                  body.emit(assign(r2CBF, add(r2CCB, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2CF8->else_instructions;

                  body.emit(assign(r2CC1, bit_or(swizzle_y(r2CC5), body.constant(1048576u)), 0x02));


               body.instructions = f2CF8_parent_instructions;
               body.emit(f2CF8);

               /* END IF */

               ir_variable *const r2CFA = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r2CFA, swizzle_y(r2CC1), 0x01));

               ir_variable *const r2CFB = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r2CFB, swizzle_x(r2CC1), 0x01));

               ir_variable *const r2CFC = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2CFC, body.constant(0u), 0x01));

               ir_variable *const r2CFD = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2CFD, neg(r2CBF), 0x01));

               ir_variable *const r2CFE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2CFE);
               ir_variable *const r2CFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2CFF);
               ir_variable *const r2D00 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2D00);
               ir_variable *const r2D01 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2D02 = neg(r2CFD);
               body.emit(assign(r2D01, bit_and(r2D02, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2D04 = equal(r2CFD, body.constant(int(0)));
               ir_if *f2D03 = new(mem_ctx) ir_if(operand(r2D04).val);
               exec_list *const f2D03_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D03->then_instructions;

                  body.emit(assign(r2CFE, r2CFC, 0x01));

                  body.emit(assign(r2CFF, r2CFB, 0x01));

                  body.emit(assign(r2D00, r2CFA, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D03->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2D06 = less(r2CFD, body.constant(int(32)));
                  ir_if *f2D05 = new(mem_ctx) ir_if(operand(r2D06).val);
                  exec_list *const f2D05_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D05->then_instructions;

                     body.emit(assign(r2CFE, lshift(swizzle_x(r2CC5), r2D01), 0x01));

                     ir_expression *const r2D07 = lshift(swizzle_y(r2CC1), r2D01);
                     ir_expression *const r2D08 = rshift(swizzle_x(r2CC5), r2CFD);
                     body.emit(assign(r2CFF, bit_or(r2D07, r2D08), 0x01));

                     body.emit(assign(r2D00, rshift(swizzle_y(r2CC1), r2CFD), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D05->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2D0A = equal(r2CFD, body.constant(int(32)));
                     ir_if *f2D09 = new(mem_ctx) ir_if(operand(r2D0A).val);
                     exec_list *const f2D09_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D09->then_instructions;

                        body.emit(assign(r2CFE, r2CFB, 0x01));

                        body.emit(assign(r2CFF, r2CFA, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D09->else_instructions;

                        body.emit(assign(r2CFC, bit_or(body.constant(0u), swizzle_x(r2CC5)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2D0C = less(r2CFD, body.constant(int(64)));
                        ir_if *f2D0B = new(mem_ctx) ir_if(operand(r2D0C).val);
                        exec_list *const f2D0B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D0B->then_instructions;

                           body.emit(assign(r2CFE, lshift(swizzle_y(r2CC1), r2D01), 0x01));

                           ir_expression *const r2D0D = bit_and(r2CFD, body.constant(int(31)));
                           body.emit(assign(r2CFF, rshift(swizzle_y(r2CC1), r2D0D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D0B->else_instructions;

                           ir_variable *const r2D0E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2D10 = equal(r2CFD, body.constant(int(64)));
                           ir_if *f2D0F = new(mem_ctx) ir_if(operand(r2D10).val);
                           exec_list *const f2D0F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D0F->then_instructions;

                              body.emit(assign(r2D0E, r2CFA, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2D0F->else_instructions;

                              ir_expression *const r2D11 = nequal(swizzle_y(r2CC1), body.constant(0u));
                              ir_expression *const r2D12 = expr(ir_unop_b2i, r2D11);
                              body.emit(assign(r2D0E, expr(ir_unop_i2u, r2D12), 0x01));


                           body.instructions = f2D0F_parent_instructions;
                           body.emit(f2D0F);

                           /* END IF */

                           body.emit(assign(r2CFE, r2D0E, 0x01));

                           body.emit(assign(r2CFF, body.constant(0u), 0x01));


                        body.instructions = f2D0B_parent_instructions;
                        body.emit(f2D0B);

                        /* END IF */


                     body.instructions = f2D09_parent_instructions;
                     body.emit(f2D09);

                     /* END IF */

                     body.emit(assign(r2D00, body.constant(0u), 0x01));


                  body.instructions = f2D05_parent_instructions;
                  body.emit(f2D05);

                  /* END IF */

                  ir_expression *const r2D13 = nequal(r2CFC, body.constant(0u));
                  ir_expression *const r2D14 = expr(ir_unop_b2i, r2D13);
                  ir_expression *const r2D15 = expr(ir_unop_i2u, r2D14);
                  body.emit(assign(r2CFE, bit_or(r2CFE, r2D15), 0x01));


               body.instructions = f2D03_parent_instructions;
               body.emit(f2D03);

               /* END IF */

               body.emit(assign(r2CC1, r2D00, 0x02));

               body.emit(assign(r2CC1, r2CFF, 0x01));

               body.emit(assign(r2CC3, r2CFE, 0x01));

               body.emit(assign(r2CC2, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2CF6->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2D17 = equal(r2CC6, body.constant(int(2047)));
               ir_if *f2D16 = new(mem_ctx) ir_if(operand(r2D17).val);
               exec_list *const f2D16_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D16->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2D19 = bit_or(swizzle_y(r2CC1), swizzle_x(r2CC1));
                  ir_expression *const r2D1A = bit_or(swizzle_y(r2CC0), swizzle_x(r2CC0));
                  ir_expression *const r2D1B = bit_or(r2D19, r2D1A);
                  ir_expression *const r2D1C = nequal(r2D1B, body.constant(0u));
                  ir_if *f2D18 = new(mem_ctx) ir_if(operand(r2D1C).val);
                  exec_list *const f2D18_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D18->then_instructions;

                     ir_variable *const r2D1D = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2D1D, swizzle_x(r28C8), 0x01));

                     ir_variable *const r2D1E = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2D1E, body.constant(0u), 0x01));

                     ir_variable *const r2D1F = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2D1D, bit_or(swizzle_y(r28C8), body.constant(524288u)), 0x02));

                     body.emit(assign(r2D1E, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2D21 = lshift(swizzle_y(r28C8), body.constant(int(1)));
                     ir_expression *const r2D22 = lequal(body.constant(4292870144u), r2D21);
                     ir_expression *const r2D23 = nequal(swizzle_x(r28C8), body.constant(0u));
                     ir_expression *const r2D24 = bit_and(swizzle_y(r28C8), body.constant(1048575u));
                     ir_expression *const r2D25 = nequal(r2D24, body.constant(0u));
                     ir_expression *const r2D26 = logic_or(r2D23, r2D25);
                     ir_expression *const r2D27 = logic_and(r2D22, r2D26);
                     ir_if *f2D20 = new(mem_ctx) ir_if(operand(r2D27).val);
                     exec_list *const f2D20_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D20->then_instructions;

                        body.emit(assign(r2D1F, r2D1D, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D20->else_instructions;

                        body.emit(assign(r2D1F, r2D1E, 0x03));


                     body.instructions = f2D20_parent_instructions;
                     body.emit(f2D20);

                     /* END IF */

                     body.emit(assign(r2CBE, r2D1F, 0x03));

                     body.emit(assign(r2CBD, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D18->else_instructions;

                     body.emit(assign(r2CBE, r28C8, 0x03));

                     body.emit(assign(r2CBD, body.constant(false), 0x01));


                  body.instructions = f2D18_parent_instructions;
                  body.emit(f2D18);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D16->else_instructions;

                  ir_variable *const r2D28 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r2D29 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2D29, add(swizzle_x(r2CC1), swizzle_x(r2CC0)), 0x01));

                  ir_expression *const r2D2A = add(swizzle_y(r2CC1), swizzle_y(r2CC0));
                  ir_expression *const r2D2B = less(r2D29, swizzle_x(r2CC1));
                  ir_expression *const r2D2C = expr(ir_unop_b2i, r2D2B);
                  ir_expression *const r2D2D = expr(ir_unop_i2u, r2D2C);
                  body.emit(assign(r2D28, add(r2D2A, r2D2D), 0x01));

                  body.emit(assign(r2CC4, r2D28, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2D2F = equal(r2CC6, body.constant(int(0)));
                  ir_if *f2D2E = new(mem_ctx) ir_if(operand(r2D2F).val);
                  exec_list *const f2D2E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D2E->then_instructions;

                     ir_variable *const r2D30 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2D30);
                     ir_expression *const r2D31 = lshift(r28FE, body.constant(int(31)));
                     body.emit(assign(r2D30, add(r2D31, r2D28), 0x02));

                     body.emit(assign(r2D30, r2D29, 0x01));

                     body.emit(assign(r2CBE, r2D30, 0x03));

                     body.emit(assign(r2CBD, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D2E->else_instructions;

                     body.emit(assign(r2CC4, bit_or(r2D28, body.constant(2097152u)), 0x01));

                     body.emit(assign(r2CC2, r2CC6, 0x01));

                     ir_variable *const r2D32 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2D32);
                     ir_variable *const r2D33 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2D33);
                     ir_variable *const r2D34 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2D34);
                     body.emit(assign(r2D32, lshift(r2D29, body.constant(int(31))), 0x01));

                     ir_expression *const r2D35 = lshift(r2CC4, body.constant(int(31)));
                     ir_expression *const r2D36 = rshift(r2D29, body.constant(int(1)));
                     body.emit(assign(r2D33, bit_or(r2D35, r2D36), 0x01));

                     body.emit(assign(r2D34, rshift(r2CC4, body.constant(int(1))), 0x01));

                     body.emit(assign(r2D32, bit_or(r2D32, body.constant(0u)), 0x01));

                     body.emit(assign(r2CC4, r2D34, 0x01));

                     body.emit(assign(r2CC3, r2D32, 0x01));

                     ir_variable *const r2D37 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2D37, r2CC6, 0x01));

                     ir_variable *const r2D38 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2D38, r2D34, 0x01));

                     ir_variable *const r2D39 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2D39, r2D33, 0x01));

                     ir_variable *const r2D3A = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2D3A, r2D32, 0x01));

                     ir_variable *const r2D3B = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2D3B, body.constant(true), 0x01));

                     ir_variable *const r2D3C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2D3D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2D3D);
                     ir_expression *const r2D3E = expr(ir_unop_u2i, r2D32);
                     body.emit(assign(r2D3D, less(r2D3E, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2D40 = lequal(body.constant(int(2045)), r2CC6);
                     ir_if *f2D3F = new(mem_ctx) ir_if(operand(r2D40).val);
                     exec_list *const f2D3F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D3F->then_instructions;

                        ir_variable *const r2D41 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2D43 = less(body.constant(int(2045)), r2CC6);
                        ir_if *f2D42 = new(mem_ctx) ir_if(operand(r2D43).val);
                        exec_list *const f2D42_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D42->then_instructions;

                           body.emit(assign(r2D41, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D42->else_instructions;

                           ir_variable *const r2D44 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2D46 = equal(r2CC6, body.constant(int(2045)));
                           ir_if *f2D45 = new(mem_ctx) ir_if(operand(r2D46).val);
                           exec_list *const f2D45_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D45->then_instructions;

                              ir_expression *const r2D47 = equal(body.constant(2097151u), r2D34);
                              ir_expression *const r2D48 = equal(body.constant(4294967295u), r2D33);
                              body.emit(assign(r2D44, logic_and(r2D47, r2D48), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2D45->else_instructions;

                              body.emit(assign(r2D44, body.constant(false), 0x01));


                           body.instructions = f2D45_parent_instructions;
                           body.emit(f2D45);

                           /* END IF */

                           body.emit(assign(r2D41, logic_and(r2D44, r2D3D), 0x01));


                        body.instructions = f2D42_parent_instructions;
                        body.emit(f2D42);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2D49 = new(mem_ctx) ir_if(operand(r2D41).val);
                        exec_list *const f2D49_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D49->then_instructions;

                           ir_variable *const r2D4A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2D4A);
                           ir_expression *const r2D4B = lshift(r28FE, body.constant(int(31)));
                           body.emit(assign(r2D4A, add(r2D4B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2D4A, body.constant(0u), 0x01));

                           body.emit(assign(r2D3C, r2D4A, 0x03));

                           body.emit(assign(r2D3B, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D49->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2D4D = less(r2CC6, body.constant(int(0)));
                           ir_if *f2D4C = new(mem_ctx) ir_if(operand(r2D4D).val);
                           exec_list *const f2D4C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D4C->then_instructions;

                              ir_variable *const r2D4E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2D4E, r2D32, 0x01));

                              ir_variable *const r2D4F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2D4F, neg(r2CC6), 0x01));

                              ir_variable *const r2D50 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2D50);
                              ir_variable *const r2D51 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2D51);
                              ir_variable *const r2D52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2D52);
                              ir_variable *const r2D53 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2D54 = neg(r2D4F);
                              body.emit(assign(r2D53, bit_and(r2D54, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2D56 = equal(r2D4F, body.constant(int(0)));
                              ir_if *f2D55 = new(mem_ctx) ir_if(operand(r2D56).val);
                              exec_list *const f2D55_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2D55->then_instructions;

                                 body.emit(assign(r2D50, r2D32, 0x01));

                                 body.emit(assign(r2D51, r2D33, 0x01));

                                 body.emit(assign(r2D52, r2D34, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2D55->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2D58 = less(r2D4F, body.constant(int(32)));
                                 ir_if *f2D57 = new(mem_ctx) ir_if(operand(r2D58).val);
                                 exec_list *const f2D57_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2D57->then_instructions;

                                    body.emit(assign(r2D50, lshift(r2D33, r2D53), 0x01));

                                    ir_expression *const r2D59 = lshift(r2D34, r2D53);
                                    ir_expression *const r2D5A = rshift(r2D33, r2D4F);
                                    body.emit(assign(r2D51, bit_or(r2D59, r2D5A), 0x01));

                                    body.emit(assign(r2D52, rshift(r2D34, r2D4F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2D57->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2D5C = equal(r2D4F, body.constant(int(32)));
                                    ir_if *f2D5B = new(mem_ctx) ir_if(operand(r2D5C).val);
                                    exec_list *const f2D5B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2D5B->then_instructions;

                                       body.emit(assign(r2D50, r2D33, 0x01));

                                       body.emit(assign(r2D51, r2D34, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2D5B->else_instructions;

                                       body.emit(assign(r2D4E, bit_or(r2D32, r2D33), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2D5E = less(r2D4F, body.constant(int(64)));
                                       ir_if *f2D5D = new(mem_ctx) ir_if(operand(r2D5E).val);
                                       exec_list *const f2D5D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2D5D->then_instructions;

                                          body.emit(assign(r2D50, lshift(r2D34, r2D53), 0x01));

                                          ir_expression *const r2D5F = bit_and(r2D4F, body.constant(int(31)));
                                          body.emit(assign(r2D51, rshift(r2D34, r2D5F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2D5D->else_instructions;

                                          ir_variable *const r2D60 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2D62 = equal(r2D4F, body.constant(int(64)));
                                          ir_if *f2D61 = new(mem_ctx) ir_if(operand(r2D62).val);
                                          exec_list *const f2D61_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2D61->then_instructions;

                                             body.emit(assign(r2D60, r2D34, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2D61->else_instructions;

                                             ir_expression *const r2D63 = nequal(r2D34, body.constant(0u));
                                             ir_expression *const r2D64 = expr(ir_unop_b2i, r2D63);
                                             body.emit(assign(r2D60, expr(ir_unop_i2u, r2D64), 0x01));


                                          body.instructions = f2D61_parent_instructions;
                                          body.emit(f2D61);

                                          /* END IF */

                                          body.emit(assign(r2D50, r2D60, 0x01));

                                          body.emit(assign(r2D51, body.constant(0u), 0x01));


                                       body.instructions = f2D5D_parent_instructions;
                                       body.emit(f2D5D);

                                       /* END IF */


                                    body.instructions = f2D5B_parent_instructions;
                                    body.emit(f2D5B);

                                    /* END IF */

                                    body.emit(assign(r2D52, body.constant(0u), 0x01));


                                 body.instructions = f2D57_parent_instructions;
                                 body.emit(f2D57);

                                 /* END IF */

                                 ir_expression *const r2D65 = nequal(r2D4E, body.constant(0u));
                                 ir_expression *const r2D66 = expr(ir_unop_b2i, r2D65);
                                 ir_expression *const r2D67 = expr(ir_unop_i2u, r2D66);
                                 body.emit(assign(r2D50, bit_or(r2D50, r2D67), 0x01));


                              body.instructions = f2D55_parent_instructions;
                              body.emit(f2D55);

                              /* END IF */

                              body.emit(assign(r2D38, r2D52, 0x01));

                              body.emit(assign(r2D39, r2D51, 0x01));

                              body.emit(assign(r2D3A, r2D50, 0x01));

                              body.emit(assign(r2D37, body.constant(int(0)), 0x01));

                              body.emit(assign(r2D3D, less(r2D50, body.constant(0u)), 0x01));


                           body.instructions = f2D4C_parent_instructions;
                           body.emit(f2D4C);

                           /* END IF */


                        body.instructions = f2D49_parent_instructions;
                        body.emit(f2D49);

                        /* END IF */


                     body.instructions = f2D3F_parent_instructions;
                     body.emit(f2D3F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2D68 = new(mem_ctx) ir_if(operand(r2D3B).val);
                     exec_list *const f2D68_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D68->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2D69 = new(mem_ctx) ir_if(operand(r2D3D).val);
                        exec_list *const f2D69_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D69->then_instructions;

                           ir_variable *const r2D6A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2D6A, add(r2D39, body.constant(1u)), 0x01));

                           ir_expression *const r2D6B = less(r2D6A, r2D39);
                           ir_expression *const r2D6C = expr(ir_unop_b2i, r2D6B);
                           ir_expression *const r2D6D = expr(ir_unop_i2u, r2D6C);
                           body.emit(assign(r2D38, add(r2D38, r2D6D), 0x01));

                           ir_expression *const r2D6E = equal(r2D3A, body.constant(0u));
                           ir_expression *const r2D6F = expr(ir_unop_b2i, r2D6E);
                           ir_expression *const r2D70 = expr(ir_unop_i2u, r2D6F);
                           ir_expression *const r2D71 = add(r2D3A, r2D70);
                           ir_expression *const r2D72 = bit_and(r2D71, body.constant(1u));
                           ir_expression *const r2D73 = expr(ir_unop_bit_not, r2D72);
                           body.emit(assign(r2D39, bit_and(r2D6A, r2D73), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D69->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2D75 = bit_or(r2D38, r2D39);
                           ir_expression *const r2D76 = equal(r2D75, body.constant(0u));
                           ir_if *f2D74 = new(mem_ctx) ir_if(operand(r2D76).val);
                           exec_list *const f2D74_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D74->then_instructions;

                              body.emit(assign(r2D37, body.constant(int(0)), 0x01));


                           body.instructions = f2D74_parent_instructions;
                           body.emit(f2D74);

                           /* END IF */


                        body.instructions = f2D69_parent_instructions;
                        body.emit(f2D69);

                        /* END IF */

                        ir_variable *const r2D77 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2D77);
                        ir_expression *const r2D78 = lshift(r28FE, body.constant(int(31)));
                        ir_expression *const r2D79 = expr(ir_unop_i2u, r2D37);
                        ir_expression *const r2D7A = lshift(r2D79, body.constant(int(20)));
                        ir_expression *const r2D7B = add(r2D78, r2D7A);
                        body.emit(assign(r2D77, add(r2D7B, r2D38), 0x02));

                        body.emit(assign(r2D77, r2D39, 0x01));

                        body.emit(assign(r2D3C, r2D77, 0x03));

                        body.emit(assign(r2D3B, body.constant(false), 0x01));


                     body.instructions = f2D68_parent_instructions;
                     body.emit(f2D68);

                     /* END IF */

                     body.emit(assign(r2CBE, r2D3C, 0x03));

                     body.emit(assign(r2CBD, body.constant(false), 0x01));


                  body.instructions = f2D2E_parent_instructions;
                  body.emit(f2D2E);

                  /* END IF */


               body.instructions = f2D16_parent_instructions;
               body.emit(f2D16);

               /* END IF */


            body.instructions = f2CF6_parent_instructions;
            body.emit(f2CF6);

            /* END IF */


         body.instructions = f2CCC_parent_instructions;
         body.emit(f2CCC);

         /* END IF */

         /* IF CONDITION */
         ir_if *f2D7C = new(mem_ctx) ir_if(operand(r2CBD).val);
         exec_list *const f2D7C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2D7C->then_instructions;

            body.emit(assign(r2CC1, bit_or(swizzle_y(r2CC1), body.constant(1048576u)), 0x02));

            ir_variable *const r2D7D = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2D7E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r2D7E, add(swizzle_x(r2CC1), swizzle_x(r2CC0)), 0x01));

            ir_expression *const r2D7F = add(swizzle_y(r2CC1), swizzle_y(r2CC0));
            ir_expression *const r2D80 = less(r2D7E, swizzle_x(r2CC1));
            ir_expression *const r2D81 = expr(ir_unop_b2i, r2D80);
            ir_expression *const r2D82 = expr(ir_unop_i2u, r2D81);
            body.emit(assign(r2D7D, add(r2D7F, r2D82), 0x01));

            body.emit(assign(r2CC4, r2D7D, 0x01));

            body.emit(assign(r2CC2, add(r2CC2, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2D84 = less(r2D7D, body.constant(2097152u));
            ir_if *f2D83 = new(mem_ctx) ir_if(operand(r2D84).val);
            exec_list *const f2D83_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D83->then_instructions;

               ir_variable *const r2D85 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2D85, r2CC2, 0x01));

               ir_variable *const r2D86 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2D86, r2D7D, 0x01));

               ir_variable *const r2D87 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2D87, r2D7E, 0x01));

               ir_variable *const r2D88 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2D88, r2CC3, 0x01));

               ir_variable *const r2D89 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2D89, body.constant(true), 0x01));

               ir_variable *const r2D8A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2D8B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2D8B);
               ir_expression *const r2D8C = expr(ir_unop_u2i, r2CC3);
               body.emit(assign(r2D8B, less(r2D8C, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2D8E = lequal(body.constant(int(2045)), r2CC2);
               ir_if *f2D8D = new(mem_ctx) ir_if(operand(r2D8E).val);
               exec_list *const f2D8D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D8D->then_instructions;

                  ir_variable *const r2D8F = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2D91 = less(body.constant(int(2045)), r2CC2);
                  ir_if *f2D90 = new(mem_ctx) ir_if(operand(r2D91).val);
                  exec_list *const f2D90_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D90->then_instructions;

                     body.emit(assign(r2D8F, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D90->else_instructions;

                     ir_variable *const r2D92 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2D94 = equal(r2CC2, body.constant(int(2045)));
                     ir_if *f2D93 = new(mem_ctx) ir_if(operand(r2D94).val);
                     exec_list *const f2D93_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D93->then_instructions;

                        ir_expression *const r2D95 = equal(body.constant(2097151u), r2D7D);
                        ir_expression *const r2D96 = equal(body.constant(4294967295u), r2D7E);
                        body.emit(assign(r2D92, logic_and(r2D95, r2D96), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D93->else_instructions;

                        body.emit(assign(r2D92, body.constant(false), 0x01));


                     body.instructions = f2D93_parent_instructions;
                     body.emit(f2D93);

                     /* END IF */

                     body.emit(assign(r2D8F, logic_and(r2D92, r2D8B), 0x01));


                  body.instructions = f2D90_parent_instructions;
                  body.emit(f2D90);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2D97 = new(mem_ctx) ir_if(operand(r2D8F).val);
                  exec_list *const f2D97_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D97->then_instructions;

                     ir_variable *const r2D98 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2D98);
                     ir_expression *const r2D99 = lshift(r28FE, body.constant(int(31)));
                     body.emit(assign(r2D98, add(r2D99, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2D98, body.constant(0u), 0x01));

                     body.emit(assign(r2D8A, r2D98, 0x03));

                     body.emit(assign(r2D89, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D97->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2D9B = less(r2CC2, body.constant(int(0)));
                     ir_if *f2D9A = new(mem_ctx) ir_if(operand(r2D9B).val);
                     exec_list *const f2D9A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D9A->then_instructions;

                        ir_variable *const r2D9C = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2D9C, r2CC3, 0x01));

                        ir_variable *const r2D9D = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2D9D, neg(r2CC2), 0x01));

                        ir_variable *const r2D9E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2D9E);
                        ir_variable *const r2D9F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2D9F);
                        ir_variable *const r2DA0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2DA0);
                        ir_variable *const r2DA1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2DA2 = neg(r2D9D);
                        body.emit(assign(r2DA1, bit_and(r2DA2, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2DA4 = equal(r2D9D, body.constant(int(0)));
                        ir_if *f2DA3 = new(mem_ctx) ir_if(operand(r2DA4).val);
                        exec_list *const f2DA3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2DA3->then_instructions;

                           body.emit(assign(r2D9E, r2CC3, 0x01));

                           body.emit(assign(r2D9F, r2D7E, 0x01));

                           body.emit(assign(r2DA0, r2D7D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2DA3->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2DA6 = less(r2D9D, body.constant(int(32)));
                           ir_if *f2DA5 = new(mem_ctx) ir_if(operand(r2DA6).val);
                           exec_list *const f2DA5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2DA5->then_instructions;

                              body.emit(assign(r2D9E, lshift(r2D7E, r2DA1), 0x01));

                              ir_expression *const r2DA7 = lshift(r2D7D, r2DA1);
                              ir_expression *const r2DA8 = rshift(r2D7E, r2D9D);
                              body.emit(assign(r2D9F, bit_or(r2DA7, r2DA8), 0x01));

                              body.emit(assign(r2DA0, rshift(r2D7D, r2D9D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2DA5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2DAA = equal(r2D9D, body.constant(int(32)));
                              ir_if *f2DA9 = new(mem_ctx) ir_if(operand(r2DAA).val);
                              exec_list *const f2DA9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2DA9->then_instructions;

                                 body.emit(assign(r2D9E, r2D7E, 0x01));

                                 body.emit(assign(r2D9F, r2D7D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2DA9->else_instructions;

                                 body.emit(assign(r2D9C, bit_or(r2CC3, r2D7E), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2DAC = less(r2D9D, body.constant(int(64)));
                                 ir_if *f2DAB = new(mem_ctx) ir_if(operand(r2DAC).val);
                                 exec_list *const f2DAB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2DAB->then_instructions;

                                    body.emit(assign(r2D9E, lshift(r2D7D, r2DA1), 0x01));

                                    ir_expression *const r2DAD = bit_and(r2D9D, body.constant(int(31)));
                                    body.emit(assign(r2D9F, rshift(r2D7D, r2DAD), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2DAB->else_instructions;

                                    ir_variable *const r2DAE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2DB0 = equal(r2D9D, body.constant(int(64)));
                                    ir_if *f2DAF = new(mem_ctx) ir_if(operand(r2DB0).val);
                                    exec_list *const f2DAF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2DAF->then_instructions;

                                       body.emit(assign(r2DAE, r2D7D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2DAF->else_instructions;

                                       ir_expression *const r2DB1 = nequal(r2D7D, body.constant(0u));
                                       ir_expression *const r2DB2 = expr(ir_unop_b2i, r2DB1);
                                       body.emit(assign(r2DAE, expr(ir_unop_i2u, r2DB2), 0x01));


                                    body.instructions = f2DAF_parent_instructions;
                                    body.emit(f2DAF);

                                    /* END IF */

                                    body.emit(assign(r2D9E, r2DAE, 0x01));

                                    body.emit(assign(r2D9F, body.constant(0u), 0x01));


                                 body.instructions = f2DAB_parent_instructions;
                                 body.emit(f2DAB);

                                 /* END IF */


                              body.instructions = f2DA9_parent_instructions;
                              body.emit(f2DA9);

                              /* END IF */

                              body.emit(assign(r2DA0, body.constant(0u), 0x01));


                           body.instructions = f2DA5_parent_instructions;
                           body.emit(f2DA5);

                           /* END IF */

                           ir_expression *const r2DB3 = nequal(r2D9C, body.constant(0u));
                           ir_expression *const r2DB4 = expr(ir_unop_b2i, r2DB3);
                           ir_expression *const r2DB5 = expr(ir_unop_i2u, r2DB4);
                           body.emit(assign(r2D9E, bit_or(r2D9E, r2DB5), 0x01));


                        body.instructions = f2DA3_parent_instructions;
                        body.emit(f2DA3);

                        /* END IF */

                        body.emit(assign(r2D86, r2DA0, 0x01));

                        body.emit(assign(r2D87, r2D9F, 0x01));

                        body.emit(assign(r2D88, r2D9E, 0x01));

                        body.emit(assign(r2D85, body.constant(int(0)), 0x01));

                        body.emit(assign(r2D8B, less(r2D9E, body.constant(0u)), 0x01));


                     body.instructions = f2D9A_parent_instructions;
                     body.emit(f2D9A);

                     /* END IF */


                  body.instructions = f2D97_parent_instructions;
                  body.emit(f2D97);

                  /* END IF */


               body.instructions = f2D8D_parent_instructions;
               body.emit(f2D8D);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2DB6 = new(mem_ctx) ir_if(operand(r2D89).val);
               exec_list *const f2DB6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DB6->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2DB7 = new(mem_ctx) ir_if(operand(r2D8B).val);
                  exec_list *const f2DB7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DB7->then_instructions;

                     ir_variable *const r2DB8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2DB8, add(r2D87, body.constant(1u)), 0x01));

                     ir_expression *const r2DB9 = less(r2DB8, r2D87);
                     ir_expression *const r2DBA = expr(ir_unop_b2i, r2DB9);
                     ir_expression *const r2DBB = expr(ir_unop_i2u, r2DBA);
                     body.emit(assign(r2D86, add(r2D86, r2DBB), 0x01));

                     ir_expression *const r2DBC = equal(r2D88, body.constant(0u));
                     ir_expression *const r2DBD = expr(ir_unop_b2i, r2DBC);
                     ir_expression *const r2DBE = expr(ir_unop_i2u, r2DBD);
                     ir_expression *const r2DBF = add(r2D88, r2DBE);
                     ir_expression *const r2DC0 = bit_and(r2DBF, body.constant(1u));
                     ir_expression *const r2DC1 = expr(ir_unop_bit_not, r2DC0);
                     body.emit(assign(r2D87, bit_and(r2DB8, r2DC1), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DB7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2DC3 = bit_or(r2D86, r2D87);
                     ir_expression *const r2DC4 = equal(r2DC3, body.constant(0u));
                     ir_if *f2DC2 = new(mem_ctx) ir_if(operand(r2DC4).val);
                     exec_list *const f2DC2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DC2->then_instructions;

                        body.emit(assign(r2D85, body.constant(int(0)), 0x01));


                     body.instructions = f2DC2_parent_instructions;
                     body.emit(f2DC2);

                     /* END IF */


                  body.instructions = f2DB7_parent_instructions;
                  body.emit(f2DB7);

                  /* END IF */

                  ir_variable *const r2DC5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2DC5);
                  ir_expression *const r2DC6 = lshift(r28FE, body.constant(int(31)));
                  ir_expression *const r2DC7 = expr(ir_unop_i2u, r2D85);
                  ir_expression *const r2DC8 = lshift(r2DC7, body.constant(int(20)));
                  ir_expression *const r2DC9 = add(r2DC6, r2DC8);
                  body.emit(assign(r2DC5, add(r2DC9, r2D86), 0x02));

                  body.emit(assign(r2DC5, r2D87, 0x01));

                  body.emit(assign(r2D8A, r2DC5, 0x03));

                  body.emit(assign(r2D89, body.constant(false), 0x01));


               body.instructions = f2DB6_parent_instructions;
               body.emit(f2DB6);

               /* END IF */

               body.emit(assign(r2CBE, r2D8A, 0x03));

               body.emit(assign(r2CBD, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2D83->else_instructions;

               body.emit(assign(r2CC2, add(r2CC2, body.constant(int(1))), 0x01));

               ir_variable *const r2DCA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2DCA);
               ir_variable *const r2DCB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2DCB);
               ir_variable *const r2DCC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2DCC);
               body.emit(assign(r2DCA, lshift(r2D7E, body.constant(int(31))), 0x01));

               ir_expression *const r2DCD = lshift(r2D7D, body.constant(int(31)));
               ir_expression *const r2DCE = rshift(r2D7E, body.constant(int(1)));
               body.emit(assign(r2DCB, bit_or(r2DCD, r2DCE), 0x01));

               body.emit(assign(r2DCC, rshift(r2D7D, body.constant(int(1))), 0x01));

               ir_expression *const r2DCF = nequal(r2CC3, body.constant(0u));
               ir_expression *const r2DD0 = expr(ir_unop_b2i, r2DCF);
               ir_expression *const r2DD1 = expr(ir_unop_i2u, r2DD0);
               body.emit(assign(r2DCA, bit_or(r2DCA, r2DD1), 0x01));

               body.emit(assign(r2CC4, r2DCC, 0x01));

               body.emit(assign(r2CC3, r2DCA, 0x01));

               ir_variable *const r2DD2 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2DD2, r2CC2, 0x01));

               ir_variable *const r2DD3 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2DD3, r2DCC, 0x01));

               ir_variable *const r2DD4 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2DD4, r2DCB, 0x01));

               ir_variable *const r2DD5 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2DD5, r2DCA, 0x01));

               ir_variable *const r2DD6 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2DD6, body.constant(true), 0x01));

               ir_variable *const r2DD7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2DD8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2DD8);
               ir_expression *const r2DD9 = expr(ir_unop_u2i, r2DCA);
               body.emit(assign(r2DD8, less(r2DD9, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2DDB = lequal(body.constant(int(2045)), r2CC2);
               ir_if *f2DDA = new(mem_ctx) ir_if(operand(r2DDB).val);
               exec_list *const f2DDA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DDA->then_instructions;

                  ir_variable *const r2DDC = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2DDE = less(body.constant(int(2045)), r2CC2);
                  ir_if *f2DDD = new(mem_ctx) ir_if(operand(r2DDE).val);
                  exec_list *const f2DDD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DDD->then_instructions;

                     body.emit(assign(r2DDC, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DDD->else_instructions;

                     ir_variable *const r2DDF = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2DE1 = equal(r2CC2, body.constant(int(2045)));
                     ir_if *f2DE0 = new(mem_ctx) ir_if(operand(r2DE1).val);
                     exec_list *const f2DE0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DE0->then_instructions;

                        ir_expression *const r2DE2 = equal(body.constant(2097151u), r2DCC);
                        ir_expression *const r2DE3 = equal(body.constant(4294967295u), r2DCB);
                        body.emit(assign(r2DDF, logic_and(r2DE2, r2DE3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2DE0->else_instructions;

                        body.emit(assign(r2DDF, body.constant(false), 0x01));


                     body.instructions = f2DE0_parent_instructions;
                     body.emit(f2DE0);

                     /* END IF */

                     body.emit(assign(r2DDC, logic_and(r2DDF, r2DD8), 0x01));


                  body.instructions = f2DDD_parent_instructions;
                  body.emit(f2DDD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2DE4 = new(mem_ctx) ir_if(operand(r2DDC).val);
                  exec_list *const f2DE4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DE4->then_instructions;

                     ir_variable *const r2DE5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2DE5);
                     ir_expression *const r2DE6 = lshift(r28FE, body.constant(int(31)));
                     body.emit(assign(r2DE5, add(r2DE6, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2DE5, body.constant(0u), 0x01));

                     body.emit(assign(r2DD7, r2DE5, 0x03));

                     body.emit(assign(r2DD6, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DE4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2DE8 = less(r2CC2, body.constant(int(0)));
                     ir_if *f2DE7 = new(mem_ctx) ir_if(operand(r2DE8).val);
                     exec_list *const f2DE7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DE7->then_instructions;

                        ir_variable *const r2DE9 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2DE9, r2DCA, 0x01));

                        ir_variable *const r2DEA = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2DEA, neg(r2CC2), 0x01));

                        ir_variable *const r2DEB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2DEB);
                        ir_variable *const r2DEC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2DEC);
                        ir_variable *const r2DED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2DED);
                        ir_variable *const r2DEE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2DEF = neg(r2DEA);
                        body.emit(assign(r2DEE, bit_and(r2DEF, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2DF1 = equal(r2DEA, body.constant(int(0)));
                        ir_if *f2DF0 = new(mem_ctx) ir_if(operand(r2DF1).val);
                        exec_list *const f2DF0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2DF0->then_instructions;

                           body.emit(assign(r2DEB, r2DCA, 0x01));

                           body.emit(assign(r2DEC, r2DCB, 0x01));

                           body.emit(assign(r2DED, r2DCC, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2DF0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2DF3 = less(r2DEA, body.constant(int(32)));
                           ir_if *f2DF2 = new(mem_ctx) ir_if(operand(r2DF3).val);
                           exec_list *const f2DF2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2DF2->then_instructions;

                              body.emit(assign(r2DEB, lshift(r2DCB, r2DEE), 0x01));

                              ir_expression *const r2DF4 = lshift(r2DCC, r2DEE);
                              ir_expression *const r2DF5 = rshift(r2DCB, r2DEA);
                              body.emit(assign(r2DEC, bit_or(r2DF4, r2DF5), 0x01));

                              body.emit(assign(r2DED, rshift(r2DCC, r2DEA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2DF2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2DF7 = equal(r2DEA, body.constant(int(32)));
                              ir_if *f2DF6 = new(mem_ctx) ir_if(operand(r2DF7).val);
                              exec_list *const f2DF6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2DF6->then_instructions;

                                 body.emit(assign(r2DEB, r2DCB, 0x01));

                                 body.emit(assign(r2DEC, r2DCC, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2DF6->else_instructions;

                                 body.emit(assign(r2DE9, bit_or(r2DCA, r2DCB), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2DF9 = less(r2DEA, body.constant(int(64)));
                                 ir_if *f2DF8 = new(mem_ctx) ir_if(operand(r2DF9).val);
                                 exec_list *const f2DF8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2DF8->then_instructions;

                                    body.emit(assign(r2DEB, lshift(r2DCC, r2DEE), 0x01));

                                    ir_expression *const r2DFA = bit_and(r2DEA, body.constant(int(31)));
                                    body.emit(assign(r2DEC, rshift(r2DCC, r2DFA), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2DF8->else_instructions;

                                    ir_variable *const r2DFB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2DFD = equal(r2DEA, body.constant(int(64)));
                                    ir_if *f2DFC = new(mem_ctx) ir_if(operand(r2DFD).val);
                                    exec_list *const f2DFC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2DFC->then_instructions;

                                       body.emit(assign(r2DFB, r2DCC, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2DFC->else_instructions;

                                       ir_expression *const r2DFE = nequal(r2DCC, body.constant(0u));
                                       ir_expression *const r2DFF = expr(ir_unop_b2i, r2DFE);
                                       body.emit(assign(r2DFB, expr(ir_unop_i2u, r2DFF), 0x01));


                                    body.instructions = f2DFC_parent_instructions;
                                    body.emit(f2DFC);

                                    /* END IF */

                                    body.emit(assign(r2DEB, r2DFB, 0x01));

                                    body.emit(assign(r2DEC, body.constant(0u), 0x01));


                                 body.instructions = f2DF8_parent_instructions;
                                 body.emit(f2DF8);

                                 /* END IF */


                              body.instructions = f2DF6_parent_instructions;
                              body.emit(f2DF6);

                              /* END IF */

                              body.emit(assign(r2DED, body.constant(0u), 0x01));


                           body.instructions = f2DF2_parent_instructions;
                           body.emit(f2DF2);

                           /* END IF */

                           ir_expression *const r2E00 = nequal(r2DE9, body.constant(0u));
                           ir_expression *const r2E01 = expr(ir_unop_b2i, r2E00);
                           ir_expression *const r2E02 = expr(ir_unop_i2u, r2E01);
                           body.emit(assign(r2DEB, bit_or(r2DEB, r2E02), 0x01));


                        body.instructions = f2DF0_parent_instructions;
                        body.emit(f2DF0);

                        /* END IF */

                        body.emit(assign(r2DD3, r2DED, 0x01));

                        body.emit(assign(r2DD4, r2DEC, 0x01));

                        body.emit(assign(r2DD5, r2DEB, 0x01));

                        body.emit(assign(r2DD2, body.constant(int(0)), 0x01));

                        body.emit(assign(r2DD8, less(r2DEB, body.constant(0u)), 0x01));


                     body.instructions = f2DE7_parent_instructions;
                     body.emit(f2DE7);

                     /* END IF */


                  body.instructions = f2DE4_parent_instructions;
                  body.emit(f2DE4);

                  /* END IF */


               body.instructions = f2DDA_parent_instructions;
               body.emit(f2DDA);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2E03 = new(mem_ctx) ir_if(operand(r2DD6).val);
               exec_list *const f2E03_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E03->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2E04 = new(mem_ctx) ir_if(operand(r2DD8).val);
                  exec_list *const f2E04_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E04->then_instructions;

                     ir_variable *const r2E05 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2E05, add(r2DD4, body.constant(1u)), 0x01));

                     ir_expression *const r2E06 = less(r2E05, r2DD4);
                     ir_expression *const r2E07 = expr(ir_unop_b2i, r2E06);
                     ir_expression *const r2E08 = expr(ir_unop_i2u, r2E07);
                     body.emit(assign(r2DD3, add(r2DD3, r2E08), 0x01));

                     ir_expression *const r2E09 = equal(r2DD5, body.constant(0u));
                     ir_expression *const r2E0A = expr(ir_unop_b2i, r2E09);
                     ir_expression *const r2E0B = expr(ir_unop_i2u, r2E0A);
                     ir_expression *const r2E0C = add(r2DD5, r2E0B);
                     ir_expression *const r2E0D = bit_and(r2E0C, body.constant(1u));
                     ir_expression *const r2E0E = expr(ir_unop_bit_not, r2E0D);
                     body.emit(assign(r2DD4, bit_and(r2E05, r2E0E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E04->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2E10 = bit_or(r2DD3, r2DD4);
                     ir_expression *const r2E11 = equal(r2E10, body.constant(0u));
                     ir_if *f2E0F = new(mem_ctx) ir_if(operand(r2E11).val);
                     exec_list *const f2E0F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E0F->then_instructions;

                        body.emit(assign(r2DD2, body.constant(int(0)), 0x01));


                     body.instructions = f2E0F_parent_instructions;
                     body.emit(f2E0F);

                     /* END IF */


                  body.instructions = f2E04_parent_instructions;
                  body.emit(f2E04);

                  /* END IF */

                  ir_variable *const r2E12 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2E12);
                  ir_expression *const r2E13 = lshift(r28FE, body.constant(int(31)));
                  ir_expression *const r2E14 = expr(ir_unop_i2u, r2DD2);
                  ir_expression *const r2E15 = lshift(r2E14, body.constant(int(20)));
                  ir_expression *const r2E16 = add(r2E13, r2E15);
                  body.emit(assign(r2E12, add(r2E16, r2DD3), 0x02));

                  body.emit(assign(r2E12, r2DD4, 0x01));

                  body.emit(assign(r2DD7, r2E12, 0x03));

                  body.emit(assign(r2DD6, body.constant(false), 0x01));


               body.instructions = f2E03_parent_instructions;
               body.emit(f2E03);

               /* END IF */

               body.emit(assign(r2CBE, r2DD7, 0x03));

               body.emit(assign(r2CBD, body.constant(false), 0x01));


            body.instructions = f2D83_parent_instructions;
            body.emit(f2D83);

            /* END IF */


         body.instructions = f2D7C_parent_instructions;
         body.emit(f2D7C);

         /* END IF */

         body.emit(assign(r28FD, r2CBE, 0x03));


      body.instructions = f28FF_parent_instructions;
      body.emit(f28FF);

      /* END IF */

      body.emit(assign(r28FB, r28FD, 0x03));


   body.instructions = f28FC_parent_instructions;
   body.emit(f28FC);

   /* END IF */

   ir_variable *const r2E17 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r2E18 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r2E18, rshift(swizzle_y(r28C7), body.constant(int(31))), 0x01));

   ir_variable *const r2E19 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r2E19, rshift(swizzle_y(r28FB), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r2E1B = equal(r2E18, r2E19);
   ir_if *f2E1A = new(mem_ctx) ir_if(operand(r2E1B).val);
   exec_list *const f2E1A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2E1A->then_instructions;

      ir_variable *const r2E1C = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r2E1C, r2E18, 0x01));

      ir_variable *const r2E1D = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r2E1E = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r2E1E);
      ir_variable *const r2E1F = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r2E1F);
      ir_variable *const r2E20 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r2E20);
      ir_variable *const r2E21 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r2E21);
      ir_variable *const r2E22 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r2E22);
      ir_variable *const r2E23 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r2E23);
      ir_variable *const r2E24 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r2E24);
      body.emit(assign(r2E24, bit_and(swizzle_y(r28C7), body.constant(1048575u)), 0x02));

      body.emit(assign(r2E24, swizzle_x(r28C7), 0x01));

      ir_variable *const r2E25 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r2E26 = rshift(swizzle_y(r28C7), body.constant(int(20)));
      ir_expression *const r2E27 = bit_and(r2E26, body.constant(2047u));
      body.emit(assign(r2E25, expr(ir_unop_u2i, r2E27), 0x01));

      body.emit(assign(r2E21, r2E25, 0x01));

      ir_variable *const r2E28 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r2E28);
      body.emit(assign(r2E28, bit_and(swizzle_y(r28FB), body.constant(1048575u)), 0x02));

      body.emit(assign(r2E28, swizzle_x(r28FB), 0x01));

      ir_variable *const r2E29 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r2E2A = rshift(swizzle_y(r28FB), body.constant(int(20)));
      ir_expression *const r2E2B = bit_and(r2E2A, body.constant(2047u));
      body.emit(assign(r2E29, expr(ir_unop_u2i, r2E2B), 0x01));

      body.emit(assign(r2E1F, r2E29, 0x01));

      body.emit(assign(r2E1E, sub(r2E25, r2E29), 0x01));

      ir_variable *const r2E2C = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r2E2C, lshift(swizzle_x(r28C7), body.constant(int(10))), 0x01));

      ir_variable *const r2E2D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r2E2E = lshift(swizzle_y(r2E24), body.constant(int(10)));
      ir_expression *const r2E2F = rshift(swizzle_x(r28C7), body.constant(int(22)));
      body.emit(assign(r2E2D, bit_or(r2E2E, r2E2F), 0x01));

      body.emit(assign(r2E22, r2E2D, 0x02));

      body.emit(assign(r2E22, r2E2C, 0x01));

      ir_variable *const r2E30 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r2E30, lshift(swizzle_x(r28FB), body.constant(int(10))), 0x01));

      ir_variable *const r2E31 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r2E32 = lshift(swizzle_y(r2E28), body.constant(int(10)));
      ir_expression *const r2E33 = rshift(swizzle_x(r28FB), body.constant(int(22)));
      body.emit(assign(r2E31, bit_or(r2E32, r2E33), 0x01));

      body.emit(assign(r2E20, r2E31, 0x02));

      body.emit(assign(r2E20, r2E30, 0x01));

      /* IF CONDITION */
      ir_expression *const r2E35 = less(body.constant(int(0)), r2E1E);
      ir_if *f2E34 = new(mem_ctx) ir_if(operand(r2E35).val);
      exec_list *const f2E34_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2E34->then_instructions;

         /* IF CONDITION */
         ir_expression *const r2E37 = equal(r2E25, body.constant(int(2047)));
         ir_if *f2E36 = new(mem_ctx) ir_if(operand(r2E37).val);
         exec_list *const f2E36_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2E36->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2E39 = bit_or(r2E2D, r2E2C);
            ir_expression *const r2E3A = nequal(r2E39, body.constant(0u));
            ir_if *f2E38 = new(mem_ctx) ir_if(operand(r2E3A).val);
            exec_list *const f2E38_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E38->then_instructions;

               ir_variable *const r2E3B = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r2E3B, swizzle_x(r28C7), 0x01));

               ir_variable *const r2E3C = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r2E3C, swizzle_x(r28FB), 0x01));

               ir_variable *const r2E3D = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2E3E = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r2E3F = rshift(swizzle_y(r28C7), body.constant(int(19)));
               ir_expression *const r2E40 = bit_and(r2E3F, body.constant(4095u));
               ir_expression *const r2E41 = equal(r2E40, body.constant(4094u));
               ir_expression *const r2E42 = nequal(swizzle_x(r28C7), body.constant(0u));
               ir_expression *const r2E43 = bit_and(swizzle_y(r28C7), body.constant(524287u));
               ir_expression *const r2E44 = nequal(r2E43, body.constant(0u));
               ir_expression *const r2E45 = logic_or(r2E42, r2E44);
               body.emit(assign(r2E3E, logic_and(r2E41, r2E45), 0x01));

               ir_variable *const r2E46 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r2E47 = lshift(swizzle_y(r28FB), body.constant(int(1)));
               ir_expression *const r2E48 = lequal(body.constant(4292870144u), r2E47);
               ir_expression *const r2E49 = nequal(swizzle_x(r28FB), body.constant(0u));
               ir_expression *const r2E4A = bit_and(swizzle_y(r28FB), body.constant(1048575u));
               ir_expression *const r2E4B = nequal(r2E4A, body.constant(0u));
               ir_expression *const r2E4C = logic_or(r2E49, r2E4B);
               body.emit(assign(r2E46, logic_and(r2E48, r2E4C), 0x01));

               body.emit(assign(r2E3B, bit_or(swizzle_y(r28C7), body.constant(524288u)), 0x02));

               body.emit(assign(r2E3C, bit_or(swizzle_y(r28FB), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r2E4E = lshift(swizzle_y(r28C7), body.constant(int(1)));
               ir_expression *const r2E4F = lequal(body.constant(4292870144u), r2E4E);
               ir_expression *const r2E50 = nequal(swizzle_x(r28C7), body.constant(0u));
               ir_expression *const r2E51 = bit_and(swizzle_y(r28C7), body.constant(1048575u));
               ir_expression *const r2E52 = nequal(r2E51, body.constant(0u));
               ir_expression *const r2E53 = logic_or(r2E50, r2E52);
               ir_expression *const r2E54 = logic_and(r2E4F, r2E53);
               ir_if *f2E4D = new(mem_ctx) ir_if(operand(r2E54).val);
               exec_list *const f2E4D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E4D->then_instructions;

                  ir_variable *const r2E55 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2E57 = logic_and(r2E3E, r2E46);
                  ir_if *f2E56 = new(mem_ctx) ir_if(operand(r2E57).val);
                  exec_list *const f2E56_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E56->then_instructions;

                     body.emit(assign(r2E55, r2E3C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E56->else_instructions;

                     body.emit(assign(r2E55, r2E3B, 0x03));


                  body.instructions = f2E56_parent_instructions;
                  body.emit(f2E56);

                  /* END IF */

                  body.emit(assign(r2E3D, r2E55, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2E4D->else_instructions;

                  body.emit(assign(r2E3D, r2E3C, 0x03));


               body.instructions = f2E4D_parent_instructions;
               body.emit(f2E4D);

               /* END IF */

               body.emit(assign(r2E1D, r2E3D, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2E38->else_instructions;

               body.emit(assign(r2E1D, r28C7, 0x03));


            body.instructions = f2E38_parent_instructions;
            body.emit(f2E38);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2E36->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2E59 = equal(r2E29, body.constant(int(0)));
            ir_if *f2E58 = new(mem_ctx) ir_if(operand(r2E59).val);
            exec_list *const f2E58_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E58->then_instructions;

               body.emit(assign(r2E1E, add(r2E1E, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2E58->else_instructions;

               body.emit(assign(r2E20, bit_or(r2E31, body.constant(1073741824u)), 0x02));


            body.instructions = f2E58_parent_instructions;
            body.emit(f2E58);

            /* END IF */

            ir_variable *const r2E5A = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r2E5A, swizzle_y(r2E20), 0x01));

            ir_variable *const r2E5B = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r2E5B, swizzle_x(r2E20), 0x01));

            ir_variable *const r2E5C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r2E5C);
            ir_variable *const r2E5D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r2E5D);
            ir_variable *const r2E5E = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r2E5F = neg(r2E1E);
            body.emit(assign(r2E5E, bit_and(r2E5F, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2E61 = equal(r2E1E, body.constant(int(0)));
            ir_if *f2E60 = new(mem_ctx) ir_if(operand(r2E61).val);
            exec_list *const f2E60_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E60->then_instructions;

               body.emit(assign(r2E5C, r2E5B, 0x01));

               body.emit(assign(r2E5D, r2E5A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2E60->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2E63 = less(r2E1E, body.constant(int(32)));
               ir_if *f2E62 = new(mem_ctx) ir_if(operand(r2E63).val);
               exec_list *const f2E62_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E62->then_instructions;

                  ir_expression *const r2E64 = lshift(swizzle_y(r2E20), r2E5E);
                  ir_expression *const r2E65 = rshift(r2E30, r2E1E);
                  ir_expression *const r2E66 = bit_or(r2E64, r2E65);
                  ir_expression *const r2E67 = lshift(r2E30, r2E5E);
                  ir_expression *const r2E68 = nequal(r2E67, body.constant(0u));
                  ir_expression *const r2E69 = expr(ir_unop_b2i, r2E68);
                  ir_expression *const r2E6A = expr(ir_unop_i2u, r2E69);
                  body.emit(assign(r2E5C, bit_or(r2E66, r2E6A), 0x01));

                  body.emit(assign(r2E5D, rshift(swizzle_y(r2E20), r2E1E), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2E62->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2E6C = equal(r2E1E, body.constant(int(32)));
                  ir_if *f2E6B = new(mem_ctx) ir_if(operand(r2E6C).val);
                  exec_list *const f2E6B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E6B->then_instructions;

                     ir_expression *const r2E6D = nequal(r2E30, body.constant(0u));
                     ir_expression *const r2E6E = expr(ir_unop_b2i, r2E6D);
                     ir_expression *const r2E6F = expr(ir_unop_i2u, r2E6E);
                     body.emit(assign(r2E5C, bit_or(swizzle_y(r2E20), r2E6F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E6B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2E71 = less(r2E1E, body.constant(int(64)));
                     ir_if *f2E70 = new(mem_ctx) ir_if(operand(r2E71).val);
                     exec_list *const f2E70_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E70->then_instructions;

                        ir_expression *const r2E72 = bit_and(r2E1E, body.constant(int(31)));
                        ir_expression *const r2E73 = rshift(swizzle_y(r2E20), r2E72);
                        ir_expression *const r2E74 = lshift(swizzle_y(r2E20), r2E5E);
                        ir_expression *const r2E75 = bit_or(r2E74, r2E30);
                        ir_expression *const r2E76 = nequal(r2E75, body.constant(0u));
                        ir_expression *const r2E77 = expr(ir_unop_b2i, r2E76);
                        ir_expression *const r2E78 = expr(ir_unop_i2u, r2E77);
                        body.emit(assign(r2E5C, bit_or(r2E73, r2E78), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E70->else_instructions;

                        ir_expression *const r2E79 = bit_or(swizzle_y(r2E20), r2E30);
                        ir_expression *const r2E7A = nequal(r2E79, body.constant(0u));
                        ir_expression *const r2E7B = expr(ir_unop_b2i, r2E7A);
                        body.emit(assign(r2E5C, expr(ir_unop_i2u, r2E7B), 0x01));


                     body.instructions = f2E70_parent_instructions;
                     body.emit(f2E70);

                     /* END IF */


                  body.instructions = f2E6B_parent_instructions;
                  body.emit(f2E6B);

                  /* END IF */

                  body.emit(assign(r2E5D, body.constant(0u), 0x01));


               body.instructions = f2E62_parent_instructions;
               body.emit(f2E62);

               /* END IF */


            body.instructions = f2E60_parent_instructions;
            body.emit(f2E60);

            /* END IF */

            body.emit(assign(r2E20, r2E5D, 0x02));

            body.emit(assign(r2E20, r2E5C, 0x01));

            body.emit(assign(r2E22, bit_or(r2E2D, body.constant(1073741824u)), 0x02));

            ir_variable *const r2E7C = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2E7D = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r2E7D, sub(r2E2C, r2E5C), 0x01));

            ir_expression *const r2E7E = sub(swizzle_y(r2E22), r2E5D);
            ir_expression *const r2E7F = less(r2E2C, r2E5C);
            ir_expression *const r2E80 = expr(ir_unop_b2i, r2E7F);
            ir_expression *const r2E81 = expr(ir_unop_i2u, r2E80);
            body.emit(assign(r2E7C, sub(r2E7E, r2E81), 0x01));

            body.emit(assign(r2E23, add(r2E25, body.constant(int(-1))), 0x01));

            ir_variable *const r2E82 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r2E82, add(r2E23, body.constant(int(-10))), 0x01));

            ir_variable *const r2E83 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r2E83, r2E7C, 0x01));

            ir_variable *const r2E84 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2E84, r2E7D, 0x01));

            ir_variable *const r2E85 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r2E85);
            ir_variable *const r2E86 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r2E86);
            /* IF CONDITION */
            ir_expression *const r2E88 = equal(r2E7C, body.constant(0u));
            ir_if *f2E87 = new(mem_ctx) ir_if(operand(r2E88).val);
            exec_list *const f2E87_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E87->then_instructions;

               body.emit(assign(r2E83, r2E7D, 0x01));

               body.emit(assign(r2E84, body.constant(0u), 0x01));

               body.emit(assign(r2E82, add(r2E82, body.constant(int(-32))), 0x01));


            body.instructions = f2E87_parent_instructions;
            body.emit(f2E87);

            /* END IF */

            ir_variable *const r2E89 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r2E89, r2E83, 0x01));

            ir_variable *const r2E8A = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r2E8B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r2E8B);
            /* IF CONDITION */
            ir_expression *const r2E8D = equal(r2E83, body.constant(0u));
            ir_if *f2E8C = new(mem_ctx) ir_if(operand(r2E8D).val);
            exec_list *const f2E8C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E8C->then_instructions;

               body.emit(assign(r2E8A, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2E8C->else_instructions;

               body.emit(assign(r2E8B, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r2E8F = bit_and(r2E83, body.constant(4294901760u));
               ir_expression *const r2E90 = equal(r2E8F, body.constant(0u));
               ir_if *f2E8E = new(mem_ctx) ir_if(operand(r2E90).val);
               exec_list *const f2E8E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E8E->then_instructions;

                  body.emit(assign(r2E8B, body.constant(int(16)), 0x01));

                  body.emit(assign(r2E89, lshift(r2E83, body.constant(int(16))), 0x01));


               body.instructions = f2E8E_parent_instructions;
               body.emit(f2E8E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2E92 = bit_and(r2E89, body.constant(4278190080u));
               ir_expression *const r2E93 = equal(r2E92, body.constant(0u));
               ir_if *f2E91 = new(mem_ctx) ir_if(operand(r2E93).val);
               exec_list *const f2E91_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E91->then_instructions;

                  body.emit(assign(r2E8B, add(r2E8B, body.constant(int(8))), 0x01));

                  body.emit(assign(r2E89, lshift(r2E89, body.constant(int(8))), 0x01));


               body.instructions = f2E91_parent_instructions;
               body.emit(f2E91);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2E95 = bit_and(r2E89, body.constant(4026531840u));
               ir_expression *const r2E96 = equal(r2E95, body.constant(0u));
               ir_if *f2E94 = new(mem_ctx) ir_if(operand(r2E96).val);
               exec_list *const f2E94_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E94->then_instructions;

                  body.emit(assign(r2E8B, add(r2E8B, body.constant(int(4))), 0x01));

                  body.emit(assign(r2E89, lshift(r2E89, body.constant(int(4))), 0x01));


               body.instructions = f2E94_parent_instructions;
               body.emit(f2E94);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2E98 = bit_and(r2E89, body.constant(3221225472u));
               ir_expression *const r2E99 = equal(r2E98, body.constant(0u));
               ir_if *f2E97 = new(mem_ctx) ir_if(operand(r2E99).val);
               exec_list *const f2E97_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E97->then_instructions;

                  body.emit(assign(r2E8B, add(r2E8B, body.constant(int(2))), 0x01));

                  body.emit(assign(r2E89, lshift(r2E89, body.constant(int(2))), 0x01));


               body.instructions = f2E97_parent_instructions;
               body.emit(f2E97);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2E9B = bit_and(r2E89, body.constant(2147483648u));
               ir_expression *const r2E9C = equal(r2E9B, body.constant(0u));
               ir_if *f2E9A = new(mem_ctx) ir_if(operand(r2E9C).val);
               exec_list *const f2E9A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E9A->then_instructions;

                  body.emit(assign(r2E8B, add(r2E8B, body.constant(int(1))), 0x01));


               body.instructions = f2E9A_parent_instructions;
               body.emit(f2E9A);

               /* END IF */

               body.emit(assign(r2E8A, r2E8B, 0x01));


            body.instructions = f2E8C_parent_instructions;
            body.emit(f2E8C);

            /* END IF */

            body.emit(assign(r2E86, add(r2E8A, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2E9E = lequal(body.constant(int(0)), r2E86);
            ir_if *f2E9D = new(mem_ctx) ir_if(operand(r2E9E).val);
            exec_list *const f2E9D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E9D->then_instructions;

               body.emit(assign(r2E85, body.constant(0u), 0x01));

               ir_variable *const r2E9F = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2E9F, lshift(r2E84, r2E86), 0x01));

               ir_variable *const r2EA0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r2EA2 = equal(r2E86, body.constant(int(0)));
               ir_if *f2EA1 = new(mem_ctx) ir_if(operand(r2EA2).val);
               exec_list *const f2EA1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2EA1->then_instructions;

                  body.emit(assign(r2EA0, r2E83, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2EA1->else_instructions;

                  ir_expression *const r2EA3 = lshift(r2E83, r2E86);
                  ir_expression *const r2EA4 = neg(r2E86);
                  ir_expression *const r2EA5 = bit_and(r2EA4, body.constant(int(31)));
                  ir_expression *const r2EA6 = rshift(r2E84, r2EA5);
                  body.emit(assign(r2EA0, bit_or(r2EA3, r2EA6), 0x01));


               body.instructions = f2EA1_parent_instructions;
               body.emit(f2EA1);

               /* END IF */

               body.emit(assign(r2E83, r2EA0, 0x01));

               body.emit(assign(r2E84, r2E9F, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2E9D->else_instructions;

               ir_variable *const r2EA7 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2EA7, body.constant(0u), 0x01));

               ir_variable *const r2EA8 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2EA8, neg(r2E86), 0x01));

               ir_variable *const r2EA9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2EA9);
               ir_variable *const r2EAA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2EAA);
               ir_variable *const r2EAB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2EAB);
               ir_variable *const r2EAC = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2EAD = neg(r2EA8);
               body.emit(assign(r2EAC, bit_and(r2EAD, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2EAF = equal(r2EA8, body.constant(int(0)));
               ir_if *f2EAE = new(mem_ctx) ir_if(operand(r2EAF).val);
               exec_list *const f2EAE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2EAE->then_instructions;

                  body.emit(assign(r2EA9, r2EA7, 0x01));

                  body.emit(assign(r2EAA, r2E84, 0x01));

                  body.emit(assign(r2EAB, r2E83, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2EAE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2EB1 = less(r2EA8, body.constant(int(32)));
                  ir_if *f2EB0 = new(mem_ctx) ir_if(operand(r2EB1).val);
                  exec_list *const f2EB0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2EB0->then_instructions;

                     body.emit(assign(r2EA9, lshift(r2E84, r2EAC), 0x01));

                     ir_expression *const r2EB2 = lshift(r2E83, r2EAC);
                     ir_expression *const r2EB3 = rshift(r2E84, r2EA8);
                     body.emit(assign(r2EAA, bit_or(r2EB2, r2EB3), 0x01));

                     body.emit(assign(r2EAB, rshift(r2E83, r2EA8), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2EB0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2EB5 = equal(r2EA8, body.constant(int(32)));
                     ir_if *f2EB4 = new(mem_ctx) ir_if(operand(r2EB5).val);
                     exec_list *const f2EB4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EB4->then_instructions;

                        body.emit(assign(r2EA9, r2E84, 0x01));

                        body.emit(assign(r2EAA, r2E83, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EB4->else_instructions;

                        body.emit(assign(r2EA7, bit_or(body.constant(0u), r2E84), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2EB7 = less(r2EA8, body.constant(int(64)));
                        ir_if *f2EB6 = new(mem_ctx) ir_if(operand(r2EB7).val);
                        exec_list *const f2EB6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EB6->then_instructions;

                           body.emit(assign(r2EA9, lshift(r2E83, r2EAC), 0x01));

                           ir_expression *const r2EB8 = bit_and(r2EA8, body.constant(int(31)));
                           body.emit(assign(r2EAA, rshift(r2E83, r2EB8), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2EB6->else_instructions;

                           ir_variable *const r2EB9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2EBB = equal(r2EA8, body.constant(int(64)));
                           ir_if *f2EBA = new(mem_ctx) ir_if(operand(r2EBB).val);
                           exec_list *const f2EBA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2EBA->then_instructions;

                              body.emit(assign(r2EB9, r2E83, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2EBA->else_instructions;

                              ir_expression *const r2EBC = nequal(r2E83, body.constant(0u));
                              ir_expression *const r2EBD = expr(ir_unop_b2i, r2EBC);
                              body.emit(assign(r2EB9, expr(ir_unop_i2u, r2EBD), 0x01));


                           body.instructions = f2EBA_parent_instructions;
                           body.emit(f2EBA);

                           /* END IF */

                           body.emit(assign(r2EA9, r2EB9, 0x01));

                           body.emit(assign(r2EAA, body.constant(0u), 0x01));


                        body.instructions = f2EB6_parent_instructions;
                        body.emit(f2EB6);

                        /* END IF */


                     body.instructions = f2EB4_parent_instructions;
                     body.emit(f2EB4);

                     /* END IF */

                     body.emit(assign(r2EAB, body.constant(0u), 0x01));


                  body.instructions = f2EB0_parent_instructions;
                  body.emit(f2EB0);

                  /* END IF */

                  ir_expression *const r2EBE = nequal(r2EA7, body.constant(0u));
                  ir_expression *const r2EBF = expr(ir_unop_b2i, r2EBE);
                  ir_expression *const r2EC0 = expr(ir_unop_i2u, r2EBF);
                  body.emit(assign(r2EA9, bit_or(r2EA9, r2EC0), 0x01));


               body.instructions = f2EAE_parent_instructions;
               body.emit(f2EAE);

               /* END IF */

               body.emit(assign(r2E83, r2EAB, 0x01));

               body.emit(assign(r2E84, r2EAA, 0x01));

               body.emit(assign(r2E85, r2EA9, 0x01));


            body.instructions = f2E9D_parent_instructions;
            body.emit(f2E9D);

            /* END IF */

            body.emit(assign(r2E82, sub(r2E82, r2E86), 0x01));

            ir_variable *const r2EC1 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r2EC1, r2E82, 0x01));

            ir_variable *const r2EC2 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r2EC2, r2E83, 0x01));

            ir_variable *const r2EC3 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2EC3, r2E84, 0x01));

            ir_variable *const r2EC4 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r2EC4, r2E85, 0x01));

            ir_variable *const r2EC5 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r2EC5, body.constant(true), 0x01));

            ir_variable *const r2EC6 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r2EC7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r2EC7);
            ir_expression *const r2EC8 = expr(ir_unop_u2i, r2E85);
            body.emit(assign(r2EC7, less(r2EC8, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2ECA = lequal(body.constant(int(2045)), r2E82);
            ir_if *f2EC9 = new(mem_ctx) ir_if(operand(r2ECA).val);
            exec_list *const f2EC9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2EC9->then_instructions;

               ir_variable *const r2ECB = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r2ECD = less(body.constant(int(2045)), r2E82);
               ir_if *f2ECC = new(mem_ctx) ir_if(operand(r2ECD).val);
               exec_list *const f2ECC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2ECC->then_instructions;

                  body.emit(assign(r2ECB, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2ECC->else_instructions;

                  ir_variable *const r2ECE = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2ED0 = equal(r2E82, body.constant(int(2045)));
                  ir_if *f2ECF = new(mem_ctx) ir_if(operand(r2ED0).val);
                  exec_list *const f2ECF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2ECF->then_instructions;

                     ir_expression *const r2ED1 = equal(body.constant(2097151u), r2E83);
                     ir_expression *const r2ED2 = equal(body.constant(4294967295u), r2E84);
                     body.emit(assign(r2ECE, logic_and(r2ED1, r2ED2), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2ECF->else_instructions;

                     body.emit(assign(r2ECE, body.constant(false), 0x01));


                  body.instructions = f2ECF_parent_instructions;
                  body.emit(f2ECF);

                  /* END IF */

                  body.emit(assign(r2ECB, logic_and(r2ECE, r2EC7), 0x01));


               body.instructions = f2ECC_parent_instructions;
               body.emit(f2ECC);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2ED3 = new(mem_ctx) ir_if(operand(r2ECB).val);
               exec_list *const f2ED3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2ED3->then_instructions;

                  ir_variable *const r2ED4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2ED4);
                  ir_expression *const r2ED5 = lshift(r2E18, body.constant(int(31)));
                  body.emit(assign(r2ED4, add(r2ED5, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2ED4, body.constant(0u), 0x01));

                  body.emit(assign(r2EC6, r2ED4, 0x03));

                  body.emit(assign(r2EC5, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2ED3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2ED7 = less(r2E82, body.constant(int(0)));
                  ir_if *f2ED6 = new(mem_ctx) ir_if(operand(r2ED7).val);
                  exec_list *const f2ED6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2ED6->then_instructions;

                     ir_variable *const r2ED8 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2ED8, r2E85, 0x01));

                     ir_variable *const r2ED9 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2ED9, neg(r2E82), 0x01));

                     ir_variable *const r2EDA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2EDA);
                     ir_variable *const r2EDB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2EDB);
                     ir_variable *const r2EDC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2EDC);
                     ir_variable *const r2EDD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r2EDE = neg(r2ED9);
                     body.emit(assign(r2EDD, bit_and(r2EDE, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2EE0 = equal(r2ED9, body.constant(int(0)));
                     ir_if *f2EDF = new(mem_ctx) ir_if(operand(r2EE0).val);
                     exec_list *const f2EDF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EDF->then_instructions;

                        body.emit(assign(r2EDA, r2E85, 0x01));

                        body.emit(assign(r2EDB, r2E84, 0x01));

                        body.emit(assign(r2EDC, r2E83, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EDF->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2EE2 = less(r2ED9, body.constant(int(32)));
                        ir_if *f2EE1 = new(mem_ctx) ir_if(operand(r2EE2).val);
                        exec_list *const f2EE1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EE1->then_instructions;

                           body.emit(assign(r2EDA, lshift(r2E84, r2EDD), 0x01));

                           ir_expression *const r2EE3 = lshift(r2E83, r2EDD);
                           ir_expression *const r2EE4 = rshift(r2E84, r2ED9);
                           body.emit(assign(r2EDB, bit_or(r2EE3, r2EE4), 0x01));

                           body.emit(assign(r2EDC, rshift(r2E83, r2ED9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2EE1->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2EE6 = equal(r2ED9, body.constant(int(32)));
                           ir_if *f2EE5 = new(mem_ctx) ir_if(operand(r2EE6).val);
                           exec_list *const f2EE5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2EE5->then_instructions;

                              body.emit(assign(r2EDA, r2E84, 0x01));

                              body.emit(assign(r2EDB, r2E83, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2EE5->else_instructions;

                              body.emit(assign(r2ED8, bit_or(r2E85, r2E84), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2EE8 = less(r2ED9, body.constant(int(64)));
                              ir_if *f2EE7 = new(mem_ctx) ir_if(operand(r2EE8).val);
                              exec_list *const f2EE7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2EE7->then_instructions;

                                 body.emit(assign(r2EDA, lshift(r2E83, r2EDD), 0x01));

                                 ir_expression *const r2EE9 = bit_and(r2ED9, body.constant(int(31)));
                                 body.emit(assign(r2EDB, rshift(r2E83, r2EE9), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2EE7->else_instructions;

                                 ir_variable *const r2EEA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2EEC = equal(r2ED9, body.constant(int(64)));
                                 ir_if *f2EEB = new(mem_ctx) ir_if(operand(r2EEC).val);
                                 exec_list *const f2EEB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2EEB->then_instructions;

                                    body.emit(assign(r2EEA, r2E83, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2EEB->else_instructions;

                                    ir_expression *const r2EED = nequal(r2E83, body.constant(0u));
                                    ir_expression *const r2EEE = expr(ir_unop_b2i, r2EED);
                                    body.emit(assign(r2EEA, expr(ir_unop_i2u, r2EEE), 0x01));


                                 body.instructions = f2EEB_parent_instructions;
                                 body.emit(f2EEB);

                                 /* END IF */

                                 body.emit(assign(r2EDA, r2EEA, 0x01));

                                 body.emit(assign(r2EDB, body.constant(0u), 0x01));


                              body.instructions = f2EE7_parent_instructions;
                              body.emit(f2EE7);

                              /* END IF */


                           body.instructions = f2EE5_parent_instructions;
                           body.emit(f2EE5);

                           /* END IF */

                           body.emit(assign(r2EDC, body.constant(0u), 0x01));


                        body.instructions = f2EE1_parent_instructions;
                        body.emit(f2EE1);

                        /* END IF */

                        ir_expression *const r2EEF = nequal(r2ED8, body.constant(0u));
                        ir_expression *const r2EF0 = expr(ir_unop_b2i, r2EEF);
                        ir_expression *const r2EF1 = expr(ir_unop_i2u, r2EF0);
                        body.emit(assign(r2EDA, bit_or(r2EDA, r2EF1), 0x01));


                     body.instructions = f2EDF_parent_instructions;
                     body.emit(f2EDF);

                     /* END IF */

                     body.emit(assign(r2EC2, r2EDC, 0x01));

                     body.emit(assign(r2EC3, r2EDB, 0x01));

                     body.emit(assign(r2EC4, r2EDA, 0x01));

                     body.emit(assign(r2EC1, body.constant(int(0)), 0x01));

                     body.emit(assign(r2EC7, less(r2EDA, body.constant(0u)), 0x01));


                  body.instructions = f2ED6_parent_instructions;
                  body.emit(f2ED6);

                  /* END IF */


               body.instructions = f2ED3_parent_instructions;
               body.emit(f2ED3);

               /* END IF */


            body.instructions = f2EC9_parent_instructions;
            body.emit(f2EC9);

            /* END IF */

            /* IF CONDITION */
            ir_if *f2EF2 = new(mem_ctx) ir_if(operand(r2EC5).val);
            exec_list *const f2EF2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2EF2->then_instructions;

               /* IF CONDITION */
               ir_if *f2EF3 = new(mem_ctx) ir_if(operand(r2EC7).val);
               exec_list *const f2EF3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2EF3->then_instructions;

                  ir_variable *const r2EF4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2EF4, add(r2EC3, body.constant(1u)), 0x01));

                  ir_expression *const r2EF5 = less(r2EF4, r2EC3);
                  ir_expression *const r2EF6 = expr(ir_unop_b2i, r2EF5);
                  ir_expression *const r2EF7 = expr(ir_unop_i2u, r2EF6);
                  body.emit(assign(r2EC2, add(r2EC2, r2EF7), 0x01));

                  ir_expression *const r2EF8 = equal(r2EC4, body.constant(0u));
                  ir_expression *const r2EF9 = expr(ir_unop_b2i, r2EF8);
                  ir_expression *const r2EFA = expr(ir_unop_i2u, r2EF9);
                  ir_expression *const r2EFB = add(r2EC4, r2EFA);
                  ir_expression *const r2EFC = bit_and(r2EFB, body.constant(1u));
                  ir_expression *const r2EFD = expr(ir_unop_bit_not, r2EFC);
                  body.emit(assign(r2EC3, bit_and(r2EF4, r2EFD), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2EF3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2EFF = bit_or(r2EC2, r2EC3);
                  ir_expression *const r2F00 = equal(r2EFF, body.constant(0u));
                  ir_if *f2EFE = new(mem_ctx) ir_if(operand(r2F00).val);
                  exec_list *const f2EFE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2EFE->then_instructions;

                     body.emit(assign(r2EC1, body.constant(int(0)), 0x01));


                  body.instructions = f2EFE_parent_instructions;
                  body.emit(f2EFE);

                  /* END IF */


               body.instructions = f2EF3_parent_instructions;
               body.emit(f2EF3);

               /* END IF */

               ir_variable *const r2F01 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r2F01);
               ir_expression *const r2F02 = lshift(r2E18, body.constant(int(31)));
               ir_expression *const r2F03 = expr(ir_unop_i2u, r2EC1);
               ir_expression *const r2F04 = lshift(r2F03, body.constant(int(20)));
               ir_expression *const r2F05 = add(r2F02, r2F04);
               body.emit(assign(r2F01, add(r2F05, r2EC2), 0x02));

               body.emit(assign(r2F01, r2EC3, 0x01));

               body.emit(assign(r2EC6, r2F01, 0x03));

               body.emit(assign(r2EC5, body.constant(false), 0x01));


            body.instructions = f2EF2_parent_instructions;
            body.emit(f2EF2);

            /* END IF */

            body.emit(assign(r2E1D, r2EC6, 0x03));


         body.instructions = f2E36_parent_instructions;
         body.emit(f2E36);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2E34->else_instructions;

         /* IF CONDITION */
         ir_expression *const r2F07 = less(r2E1E, body.constant(int(0)));
         ir_if *f2F06 = new(mem_ctx) ir_if(operand(r2F07).val);
         exec_list *const f2F06_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2F06->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2F09 = equal(r2E29, body.constant(int(2047)));
            ir_if *f2F08 = new(mem_ctx) ir_if(operand(r2F09).val);
            exec_list *const f2F08_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2F08->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2F0B = bit_or(swizzle_y(r2E20), swizzle_x(r2E20));
               ir_expression *const r2F0C = nequal(r2F0B, body.constant(0u));
               ir_if *f2F0A = new(mem_ctx) ir_if(operand(r2F0C).val);
               exec_list *const f2F0A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F0A->then_instructions;

                  ir_variable *const r2F0D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2F0D, swizzle_x(r28C7), 0x01));

                  ir_variable *const r2F0E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2F0E, swizzle_x(r28FB), 0x01));

                  ir_variable *const r2F0F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2F10 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2F11 = rshift(swizzle_y(r28C7), body.constant(int(19)));
                  ir_expression *const r2F12 = bit_and(r2F11, body.constant(4095u));
                  ir_expression *const r2F13 = equal(r2F12, body.constant(4094u));
                  ir_expression *const r2F14 = nequal(swizzle_x(r28C7), body.constant(0u));
                  ir_expression *const r2F15 = bit_and(swizzle_y(r28C7), body.constant(524287u));
                  ir_expression *const r2F16 = nequal(r2F15, body.constant(0u));
                  ir_expression *const r2F17 = logic_or(r2F14, r2F16);
                  body.emit(assign(r2F10, logic_and(r2F13, r2F17), 0x01));

                  ir_variable *const r2F18 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2F19 = lshift(swizzle_y(r28FB), body.constant(int(1)));
                  ir_expression *const r2F1A = lequal(body.constant(4292870144u), r2F19);
                  ir_expression *const r2F1B = nequal(swizzle_x(r28FB), body.constant(0u));
                  ir_expression *const r2F1C = bit_and(swizzle_y(r28FB), body.constant(1048575u));
                  ir_expression *const r2F1D = nequal(r2F1C, body.constant(0u));
                  ir_expression *const r2F1E = logic_or(r2F1B, r2F1D);
                  body.emit(assign(r2F18, logic_and(r2F1A, r2F1E), 0x01));

                  body.emit(assign(r2F0D, bit_or(swizzle_y(r28C7), body.constant(524288u)), 0x02));

                  body.emit(assign(r2F0E, bit_or(swizzle_y(r28FB), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2F20 = lshift(swizzle_y(r28C7), body.constant(int(1)));
                  ir_expression *const r2F21 = lequal(body.constant(4292870144u), r2F20);
                  ir_expression *const r2F22 = nequal(swizzle_x(r28C7), body.constant(0u));
                  ir_expression *const r2F23 = bit_and(swizzle_y(r28C7), body.constant(1048575u));
                  ir_expression *const r2F24 = nequal(r2F23, body.constant(0u));
                  ir_expression *const r2F25 = logic_or(r2F22, r2F24);
                  ir_expression *const r2F26 = logic_and(r2F21, r2F25);
                  ir_if *f2F1F = new(mem_ctx) ir_if(operand(r2F26).val);
                  exec_list *const f2F1F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F1F->then_instructions;

                     ir_variable *const r2F27 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2F29 = logic_and(r2F10, r2F18);
                     ir_if *f2F28 = new(mem_ctx) ir_if(operand(r2F29).val);
                     exec_list *const f2F28_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F28->then_instructions;

                        body.emit(assign(r2F27, r2F0E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2F28->else_instructions;

                        body.emit(assign(r2F27, r2F0D, 0x03));


                     body.instructions = f2F28_parent_instructions;
                     body.emit(f2F28);

                     /* END IF */

                     body.emit(assign(r2F0F, r2F27, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2F1F->else_instructions;

                     body.emit(assign(r2F0F, r2F0E, 0x03));


                  body.instructions = f2F1F_parent_instructions;
                  body.emit(f2F1F);

                  /* END IF */

                  body.emit(assign(r2E1D, r2F0F, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2F0A->else_instructions;

                  ir_variable *const r2F2A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2F2A);
                  ir_expression *const r2F2B = bit_xor(r2E18, body.constant(1u));
                  ir_expression *const r2F2C = lshift(r2F2B, body.constant(int(31)));
                  body.emit(assign(r2F2A, add(r2F2C, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2F2A, body.constant(0u), 0x01));

                  body.emit(assign(r2E1D, r2F2A, 0x03));


               body.instructions = f2F0A_parent_instructions;
               body.emit(f2F0A);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2F08->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2F2E = equal(r2E25, body.constant(int(0)));
               ir_if *f2F2D = new(mem_ctx) ir_if(operand(r2F2E).val);
               exec_list *const f2F2D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F2D->then_instructions;

                  body.emit(assign(r2E1E, add(r2E1E, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2F2D->else_instructions;

                  body.emit(assign(r2E22, bit_or(swizzle_y(r2E22), body.constant(1073741824u)), 0x02));


               body.instructions = f2F2D_parent_instructions;
               body.emit(f2F2D);

               /* END IF */

               ir_variable *const r2F2F = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r2F2F, swizzle_y(r2E22), 0x01));

               ir_variable *const r2F30 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r2F30, swizzle_x(r2E22), 0x01));

               ir_variable *const r2F31 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2F31, neg(r2E1E), 0x01));

               ir_variable *const r2F32 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2F32);
               ir_variable *const r2F33 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2F33);
               ir_variable *const r2F34 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2F35 = neg(r2F31);
               body.emit(assign(r2F34, bit_and(r2F35, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2F37 = equal(r2F31, body.constant(int(0)));
               ir_if *f2F36 = new(mem_ctx) ir_if(operand(r2F37).val);
               exec_list *const f2F36_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F36->then_instructions;

                  body.emit(assign(r2F32, r2F30, 0x01));

                  body.emit(assign(r2F33, r2F2F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2F36->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2F39 = less(r2F31, body.constant(int(32)));
                  ir_if *f2F38 = new(mem_ctx) ir_if(operand(r2F39).val);
                  exec_list *const f2F38_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F38->then_instructions;

                     ir_expression *const r2F3A = lshift(swizzle_y(r2E22), r2F34);
                     ir_expression *const r2F3B = rshift(r2E2C, r2F31);
                     ir_expression *const r2F3C = bit_or(r2F3A, r2F3B);
                     ir_expression *const r2F3D = lshift(r2E2C, r2F34);
                     ir_expression *const r2F3E = nequal(r2F3D, body.constant(0u));
                     ir_expression *const r2F3F = expr(ir_unop_b2i, r2F3E);
                     ir_expression *const r2F40 = expr(ir_unop_i2u, r2F3F);
                     body.emit(assign(r2F32, bit_or(r2F3C, r2F40), 0x01));

                     body.emit(assign(r2F33, rshift(swizzle_y(r2E22), r2F31), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2F38->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2F42 = equal(r2F31, body.constant(int(32)));
                     ir_if *f2F41 = new(mem_ctx) ir_if(operand(r2F42).val);
                     exec_list *const f2F41_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F41->then_instructions;

                        ir_expression *const r2F43 = nequal(r2E2C, body.constant(0u));
                        ir_expression *const r2F44 = expr(ir_unop_b2i, r2F43);
                        ir_expression *const r2F45 = expr(ir_unop_i2u, r2F44);
                        body.emit(assign(r2F32, bit_or(swizzle_y(r2E22), r2F45), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2F41->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2F47 = less(r2F31, body.constant(int(64)));
                        ir_if *f2F46 = new(mem_ctx) ir_if(operand(r2F47).val);
                        exec_list *const f2F46_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F46->then_instructions;

                           ir_expression *const r2F48 = bit_and(r2F31, body.constant(int(31)));
                           ir_expression *const r2F49 = rshift(swizzle_y(r2E22), r2F48);
                           ir_expression *const r2F4A = lshift(swizzle_y(r2E22), r2F34);
                           ir_expression *const r2F4B = bit_or(r2F4A, r2E2C);
                           ir_expression *const r2F4C = nequal(r2F4B, body.constant(0u));
                           ir_expression *const r2F4D = expr(ir_unop_b2i, r2F4C);
                           ir_expression *const r2F4E = expr(ir_unop_i2u, r2F4D);
                           body.emit(assign(r2F32, bit_or(r2F49, r2F4E), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F46->else_instructions;

                           ir_expression *const r2F4F = bit_or(swizzle_y(r2E22), r2E2C);
                           ir_expression *const r2F50 = nequal(r2F4F, body.constant(0u));
                           ir_expression *const r2F51 = expr(ir_unop_b2i, r2F50);
                           body.emit(assign(r2F32, expr(ir_unop_i2u, r2F51), 0x01));


                        body.instructions = f2F46_parent_instructions;
                        body.emit(f2F46);

                        /* END IF */


                     body.instructions = f2F41_parent_instructions;
                     body.emit(f2F41);

                     /* END IF */

                     body.emit(assign(r2F33, body.constant(0u), 0x01));


                  body.instructions = f2F38_parent_instructions;
                  body.emit(f2F38);

                  /* END IF */


               body.instructions = f2F36_parent_instructions;
               body.emit(f2F36);

               /* END IF */

               body.emit(assign(r2E22, r2F33, 0x02));

               body.emit(assign(r2E22, r2F32, 0x01));

               body.emit(assign(r2E20, bit_or(swizzle_y(r2E20), body.constant(1073741824u)), 0x02));

               ir_variable *const r2F52 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2F53 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2F53, sub(swizzle_x(r2E20), r2F32), 0x01));

               ir_expression *const r2F54 = sub(swizzle_y(r2E20), r2F33);
               ir_expression *const r2F55 = less(swizzle_x(r2E20), r2F32);
               ir_expression *const r2F56 = expr(ir_unop_b2i, r2F55);
               ir_expression *const r2F57 = expr(ir_unop_i2u, r2F56);
               body.emit(assign(r2F52, sub(r2F54, r2F57), 0x01));

               body.emit(assign(r2E1C, bit_xor(r2E18, body.constant(1u)), 0x01));

               body.emit(assign(r2E23, add(r2E29, body.constant(int(-1))), 0x01));

               ir_variable *const r2F58 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2F58, add(r2E23, body.constant(int(-10))), 0x01));

               ir_variable *const r2F59 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2F59, r2F52, 0x01));

               ir_variable *const r2F5A = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2F5A, r2F53, 0x01));

               ir_variable *const r2F5B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2F5B);
               ir_variable *const r2F5C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2F5C);
               /* IF CONDITION */
               ir_expression *const r2F5E = equal(r2F52, body.constant(0u));
               ir_if *f2F5D = new(mem_ctx) ir_if(operand(r2F5E).val);
               exec_list *const f2F5D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F5D->then_instructions;

                  body.emit(assign(r2F59, r2F53, 0x01));

                  body.emit(assign(r2F5A, body.constant(0u), 0x01));

                  body.emit(assign(r2F58, add(r2F58, body.constant(int(-32))), 0x01));


               body.instructions = f2F5D_parent_instructions;
               body.emit(f2F5D);

               /* END IF */

               ir_variable *const r2F5F = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2F5F, r2F59, 0x01));

               ir_variable *const r2F60 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2F61 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2F61);
               /* IF CONDITION */
               ir_expression *const r2F63 = equal(r2F59, body.constant(0u));
               ir_if *f2F62 = new(mem_ctx) ir_if(operand(r2F63).val);
               exec_list *const f2F62_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F62->then_instructions;

                  body.emit(assign(r2F60, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2F62->else_instructions;

                  body.emit(assign(r2F61, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2F65 = bit_and(r2F59, body.constant(4294901760u));
                  ir_expression *const r2F66 = equal(r2F65, body.constant(0u));
                  ir_if *f2F64 = new(mem_ctx) ir_if(operand(r2F66).val);
                  exec_list *const f2F64_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F64->then_instructions;

                     body.emit(assign(r2F61, body.constant(int(16)), 0x01));

                     body.emit(assign(r2F5F, lshift(r2F59, body.constant(int(16))), 0x01));


                  body.instructions = f2F64_parent_instructions;
                  body.emit(f2F64);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2F68 = bit_and(r2F5F, body.constant(4278190080u));
                  ir_expression *const r2F69 = equal(r2F68, body.constant(0u));
                  ir_if *f2F67 = new(mem_ctx) ir_if(operand(r2F69).val);
                  exec_list *const f2F67_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F67->then_instructions;

                     body.emit(assign(r2F61, add(r2F61, body.constant(int(8))), 0x01));

                     body.emit(assign(r2F5F, lshift(r2F5F, body.constant(int(8))), 0x01));


                  body.instructions = f2F67_parent_instructions;
                  body.emit(f2F67);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2F6B = bit_and(r2F5F, body.constant(4026531840u));
                  ir_expression *const r2F6C = equal(r2F6B, body.constant(0u));
                  ir_if *f2F6A = new(mem_ctx) ir_if(operand(r2F6C).val);
                  exec_list *const f2F6A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F6A->then_instructions;

                     body.emit(assign(r2F61, add(r2F61, body.constant(int(4))), 0x01));

                     body.emit(assign(r2F5F, lshift(r2F5F, body.constant(int(4))), 0x01));


                  body.instructions = f2F6A_parent_instructions;
                  body.emit(f2F6A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2F6E = bit_and(r2F5F, body.constant(3221225472u));
                  ir_expression *const r2F6F = equal(r2F6E, body.constant(0u));
                  ir_if *f2F6D = new(mem_ctx) ir_if(operand(r2F6F).val);
                  exec_list *const f2F6D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F6D->then_instructions;

                     body.emit(assign(r2F61, add(r2F61, body.constant(int(2))), 0x01));

                     body.emit(assign(r2F5F, lshift(r2F5F, body.constant(int(2))), 0x01));


                  body.instructions = f2F6D_parent_instructions;
                  body.emit(f2F6D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2F71 = bit_and(r2F5F, body.constant(2147483648u));
                  ir_expression *const r2F72 = equal(r2F71, body.constant(0u));
                  ir_if *f2F70 = new(mem_ctx) ir_if(operand(r2F72).val);
                  exec_list *const f2F70_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F70->then_instructions;

                     body.emit(assign(r2F61, add(r2F61, body.constant(int(1))), 0x01));


                  body.instructions = f2F70_parent_instructions;
                  body.emit(f2F70);

                  /* END IF */

                  body.emit(assign(r2F60, r2F61, 0x01));


               body.instructions = f2F62_parent_instructions;
               body.emit(f2F62);

               /* END IF */

               body.emit(assign(r2F5C, add(r2F60, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2F74 = lequal(body.constant(int(0)), r2F5C);
               ir_if *f2F73 = new(mem_ctx) ir_if(operand(r2F74).val);
               exec_list *const f2F73_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F73->then_instructions;

                  body.emit(assign(r2F5B, body.constant(0u), 0x01));

                  ir_variable *const r2F75 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2F75, lshift(r2F5A, r2F5C), 0x01));

                  ir_variable *const r2F76 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2F78 = equal(r2F5C, body.constant(int(0)));
                  ir_if *f2F77 = new(mem_ctx) ir_if(operand(r2F78).val);
                  exec_list *const f2F77_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F77->then_instructions;

                     body.emit(assign(r2F76, r2F59, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2F77->else_instructions;

                     ir_expression *const r2F79 = lshift(r2F59, r2F5C);
                     ir_expression *const r2F7A = neg(r2F5C);
                     ir_expression *const r2F7B = bit_and(r2F7A, body.constant(int(31)));
                     ir_expression *const r2F7C = rshift(r2F5A, r2F7B);
                     body.emit(assign(r2F76, bit_or(r2F79, r2F7C), 0x01));


                  body.instructions = f2F77_parent_instructions;
                  body.emit(f2F77);

                  /* END IF */

                  body.emit(assign(r2F59, r2F76, 0x01));

                  body.emit(assign(r2F5A, r2F75, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2F73->else_instructions;

                  ir_variable *const r2F7D = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2F7D, body.constant(0u), 0x01));

                  ir_variable *const r2F7E = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2F7E, neg(r2F5C), 0x01));

                  ir_variable *const r2F7F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2F7F);
                  ir_variable *const r2F80 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2F80);
                  ir_variable *const r2F81 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2F81);
                  ir_variable *const r2F82 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2F83 = neg(r2F7E);
                  body.emit(assign(r2F82, bit_and(r2F83, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2F85 = equal(r2F7E, body.constant(int(0)));
                  ir_if *f2F84 = new(mem_ctx) ir_if(operand(r2F85).val);
                  exec_list *const f2F84_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F84->then_instructions;

                     body.emit(assign(r2F7F, r2F7D, 0x01));

                     body.emit(assign(r2F80, r2F5A, 0x01));

                     body.emit(assign(r2F81, r2F59, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2F84->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2F87 = less(r2F7E, body.constant(int(32)));
                     ir_if *f2F86 = new(mem_ctx) ir_if(operand(r2F87).val);
                     exec_list *const f2F86_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F86->then_instructions;

                        body.emit(assign(r2F7F, lshift(r2F5A, r2F82), 0x01));

                        ir_expression *const r2F88 = lshift(r2F59, r2F82);
                        ir_expression *const r2F89 = rshift(r2F5A, r2F7E);
                        body.emit(assign(r2F80, bit_or(r2F88, r2F89), 0x01));

                        body.emit(assign(r2F81, rshift(r2F59, r2F7E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2F86->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2F8B = equal(r2F7E, body.constant(int(32)));
                        ir_if *f2F8A = new(mem_ctx) ir_if(operand(r2F8B).val);
                        exec_list *const f2F8A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F8A->then_instructions;

                           body.emit(assign(r2F7F, r2F5A, 0x01));

                           body.emit(assign(r2F80, r2F59, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F8A->else_instructions;

                           body.emit(assign(r2F7D, bit_or(body.constant(0u), r2F5A), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2F8D = less(r2F7E, body.constant(int(64)));
                           ir_if *f2F8C = new(mem_ctx) ir_if(operand(r2F8D).val);
                           exec_list *const f2F8C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F8C->then_instructions;

                              body.emit(assign(r2F7F, lshift(r2F59, r2F82), 0x01));

                              ir_expression *const r2F8E = bit_and(r2F7E, body.constant(int(31)));
                              body.emit(assign(r2F80, rshift(r2F59, r2F8E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2F8C->else_instructions;

                              ir_variable *const r2F8F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2F91 = equal(r2F7E, body.constant(int(64)));
                              ir_if *f2F90 = new(mem_ctx) ir_if(operand(r2F91).val);
                              exec_list *const f2F90_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2F90->then_instructions;

                                 body.emit(assign(r2F8F, r2F59, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2F90->else_instructions;

                                 ir_expression *const r2F92 = nequal(r2F59, body.constant(0u));
                                 ir_expression *const r2F93 = expr(ir_unop_b2i, r2F92);
                                 body.emit(assign(r2F8F, expr(ir_unop_i2u, r2F93), 0x01));


                              body.instructions = f2F90_parent_instructions;
                              body.emit(f2F90);

                              /* END IF */

                              body.emit(assign(r2F7F, r2F8F, 0x01));

                              body.emit(assign(r2F80, body.constant(0u), 0x01));


                           body.instructions = f2F8C_parent_instructions;
                           body.emit(f2F8C);

                           /* END IF */


                        body.instructions = f2F8A_parent_instructions;
                        body.emit(f2F8A);

                        /* END IF */

                        body.emit(assign(r2F81, body.constant(0u), 0x01));


                     body.instructions = f2F86_parent_instructions;
                     body.emit(f2F86);

                     /* END IF */

                     ir_expression *const r2F94 = nequal(r2F7D, body.constant(0u));
                     ir_expression *const r2F95 = expr(ir_unop_b2i, r2F94);
                     ir_expression *const r2F96 = expr(ir_unop_i2u, r2F95);
                     body.emit(assign(r2F7F, bit_or(r2F7F, r2F96), 0x01));


                  body.instructions = f2F84_parent_instructions;
                  body.emit(f2F84);

                  /* END IF */

                  body.emit(assign(r2F59, r2F81, 0x01));

                  body.emit(assign(r2F5A, r2F80, 0x01));

                  body.emit(assign(r2F5B, r2F7F, 0x01));


               body.instructions = f2F73_parent_instructions;
               body.emit(f2F73);

               /* END IF */

               body.emit(assign(r2F58, sub(r2F58, r2F5C), 0x01));

               ir_variable *const r2F97 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2F97, r2F58, 0x01));

               ir_variable *const r2F98 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2F98, r2F59, 0x01));

               ir_variable *const r2F99 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2F99, r2F5A, 0x01));

               ir_variable *const r2F9A = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2F9A, r2F5B, 0x01));

               ir_variable *const r2F9B = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2F9B, body.constant(true), 0x01));

               ir_variable *const r2F9C = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2F9D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2F9D);
               ir_expression *const r2F9E = expr(ir_unop_u2i, r2F5B);
               body.emit(assign(r2F9D, less(r2F9E, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2FA0 = lequal(body.constant(int(2045)), r2F58);
               ir_if *f2F9F = new(mem_ctx) ir_if(operand(r2FA0).val);
               exec_list *const f2F9F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F9F->then_instructions;

                  ir_variable *const r2FA1 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2FA3 = less(body.constant(int(2045)), r2F58);
                  ir_if *f2FA2 = new(mem_ctx) ir_if(operand(r2FA3).val);
                  exec_list *const f2FA2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2FA2->then_instructions;

                     body.emit(assign(r2FA1, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2FA2->else_instructions;

                     ir_variable *const r2FA4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2FA6 = equal(r2F58, body.constant(int(2045)));
                     ir_if *f2FA5 = new(mem_ctx) ir_if(operand(r2FA6).val);
                     exec_list *const f2FA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2FA5->then_instructions;

                        ir_expression *const r2FA7 = equal(body.constant(2097151u), r2F59);
                        ir_expression *const r2FA8 = equal(body.constant(4294967295u), r2F5A);
                        body.emit(assign(r2FA4, logic_and(r2FA7, r2FA8), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2FA5->else_instructions;

                        body.emit(assign(r2FA4, body.constant(false), 0x01));


                     body.instructions = f2FA5_parent_instructions;
                     body.emit(f2FA5);

                     /* END IF */

                     body.emit(assign(r2FA1, logic_and(r2FA4, r2F9D), 0x01));


                  body.instructions = f2FA2_parent_instructions;
                  body.emit(f2FA2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2FA9 = new(mem_ctx) ir_if(operand(r2FA1).val);
                  exec_list *const f2FA9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2FA9->then_instructions;

                     ir_variable *const r2FAA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2FAA);
                     ir_expression *const r2FAB = lshift(r2E1C, body.constant(int(31)));
                     body.emit(assign(r2FAA, add(r2FAB, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2FAA, body.constant(0u), 0x01));

                     body.emit(assign(r2F9C, r2FAA, 0x03));

                     body.emit(assign(r2F9B, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2FA9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2FAD = less(r2F58, body.constant(int(0)));
                     ir_if *f2FAC = new(mem_ctx) ir_if(operand(r2FAD).val);
                     exec_list *const f2FAC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2FAC->then_instructions;

                        ir_variable *const r2FAE = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2FAE, r2F5B, 0x01));

                        ir_variable *const r2FAF = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2FAF, neg(r2F58), 0x01));

                        ir_variable *const r2FB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2FB0);
                        ir_variable *const r2FB1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2FB1);
                        ir_variable *const r2FB2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2FB2);
                        ir_variable *const r2FB3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2FB4 = neg(r2FAF);
                        body.emit(assign(r2FB3, bit_and(r2FB4, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2FB6 = equal(r2FAF, body.constant(int(0)));
                        ir_if *f2FB5 = new(mem_ctx) ir_if(operand(r2FB6).val);
                        exec_list *const f2FB5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2FB5->then_instructions;

                           body.emit(assign(r2FB0, r2F5B, 0x01));

                           body.emit(assign(r2FB1, r2F5A, 0x01));

                           body.emit(assign(r2FB2, r2F59, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2FB5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2FB8 = less(r2FAF, body.constant(int(32)));
                           ir_if *f2FB7 = new(mem_ctx) ir_if(operand(r2FB8).val);
                           exec_list *const f2FB7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FB7->then_instructions;

                              body.emit(assign(r2FB0, lshift(r2F5A, r2FB3), 0x01));

                              ir_expression *const r2FB9 = lshift(r2F59, r2FB3);
                              ir_expression *const r2FBA = rshift(r2F5A, r2FAF);
                              body.emit(assign(r2FB1, bit_or(r2FB9, r2FBA), 0x01));

                              body.emit(assign(r2FB2, rshift(r2F59, r2FAF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FB7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2FBC = equal(r2FAF, body.constant(int(32)));
                              ir_if *f2FBB = new(mem_ctx) ir_if(operand(r2FBC).val);
                              exec_list *const f2FBB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FBB->then_instructions;

                                 body.emit(assign(r2FB0, r2F5A, 0x01));

                                 body.emit(assign(r2FB1, r2F59, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2FBB->else_instructions;

                                 body.emit(assign(r2FAE, bit_or(r2F5B, r2F5A), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2FBE = less(r2FAF, body.constant(int(64)));
                                 ir_if *f2FBD = new(mem_ctx) ir_if(operand(r2FBE).val);
                                 exec_list *const f2FBD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2FBD->then_instructions;

                                    body.emit(assign(r2FB0, lshift(r2F59, r2FB3), 0x01));

                                    ir_expression *const r2FBF = bit_and(r2FAF, body.constant(int(31)));
                                    body.emit(assign(r2FB1, rshift(r2F59, r2FBF), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2FBD->else_instructions;

                                    ir_variable *const r2FC0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2FC2 = equal(r2FAF, body.constant(int(64)));
                                    ir_if *f2FC1 = new(mem_ctx) ir_if(operand(r2FC2).val);
                                    exec_list *const f2FC1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2FC1->then_instructions;

                                       body.emit(assign(r2FC0, r2F59, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2FC1->else_instructions;

                                       ir_expression *const r2FC3 = nequal(r2F59, body.constant(0u));
                                       ir_expression *const r2FC4 = expr(ir_unop_b2i, r2FC3);
                                       body.emit(assign(r2FC0, expr(ir_unop_i2u, r2FC4), 0x01));


                                    body.instructions = f2FC1_parent_instructions;
                                    body.emit(f2FC1);

                                    /* END IF */

                                    body.emit(assign(r2FB0, r2FC0, 0x01));

                                    body.emit(assign(r2FB1, body.constant(0u), 0x01));


                                 body.instructions = f2FBD_parent_instructions;
                                 body.emit(f2FBD);

                                 /* END IF */


                              body.instructions = f2FBB_parent_instructions;
                              body.emit(f2FBB);

                              /* END IF */

                              body.emit(assign(r2FB2, body.constant(0u), 0x01));


                           body.instructions = f2FB7_parent_instructions;
                           body.emit(f2FB7);

                           /* END IF */

                           ir_expression *const r2FC5 = nequal(r2FAE, body.constant(0u));
                           ir_expression *const r2FC6 = expr(ir_unop_b2i, r2FC5);
                           ir_expression *const r2FC7 = expr(ir_unop_i2u, r2FC6);
                           body.emit(assign(r2FB0, bit_or(r2FB0, r2FC7), 0x01));


                        body.instructions = f2FB5_parent_instructions;
                        body.emit(f2FB5);

                        /* END IF */

                        body.emit(assign(r2F98, r2FB2, 0x01));

                        body.emit(assign(r2F99, r2FB1, 0x01));

                        body.emit(assign(r2F9A, r2FB0, 0x01));

                        body.emit(assign(r2F97, body.constant(int(0)), 0x01));

                        body.emit(assign(r2F9D, less(r2FB0, body.constant(0u)), 0x01));


                     body.instructions = f2FAC_parent_instructions;
                     body.emit(f2FAC);

                     /* END IF */


                  body.instructions = f2FA9_parent_instructions;
                  body.emit(f2FA9);

                  /* END IF */


               body.instructions = f2F9F_parent_instructions;
               body.emit(f2F9F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2FC8 = new(mem_ctx) ir_if(operand(r2F9B).val);
               exec_list *const f2FC8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2FC8->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2FC9 = new(mem_ctx) ir_if(operand(r2F9D).val);
                  exec_list *const f2FC9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2FC9->then_instructions;

                     ir_variable *const r2FCA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2FCA, add(r2F99, body.constant(1u)), 0x01));

                     ir_expression *const r2FCB = less(r2FCA, r2F99);
                     ir_expression *const r2FCC = expr(ir_unop_b2i, r2FCB);
                     ir_expression *const r2FCD = expr(ir_unop_i2u, r2FCC);
                     body.emit(assign(r2F98, add(r2F98, r2FCD), 0x01));

                     ir_expression *const r2FCE = equal(r2F9A, body.constant(0u));
                     ir_expression *const r2FCF = expr(ir_unop_b2i, r2FCE);
                     ir_expression *const r2FD0 = expr(ir_unop_i2u, r2FCF);
                     ir_expression *const r2FD1 = add(r2F9A, r2FD0);
                     ir_expression *const r2FD2 = bit_and(r2FD1, body.constant(1u));
                     ir_expression *const r2FD3 = expr(ir_unop_bit_not, r2FD2);
                     body.emit(assign(r2F99, bit_and(r2FCA, r2FD3), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2FC9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2FD5 = bit_or(r2F98, r2F99);
                     ir_expression *const r2FD6 = equal(r2FD5, body.constant(0u));
                     ir_if *f2FD4 = new(mem_ctx) ir_if(operand(r2FD6).val);
                     exec_list *const f2FD4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2FD4->then_instructions;

                        body.emit(assign(r2F97, body.constant(int(0)), 0x01));


                     body.instructions = f2FD4_parent_instructions;
                     body.emit(f2FD4);

                     /* END IF */


                  body.instructions = f2FC9_parent_instructions;
                  body.emit(f2FC9);

                  /* END IF */

                  ir_variable *const r2FD7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2FD7);
                  ir_expression *const r2FD8 = lshift(r2E1C, body.constant(int(31)));
                  ir_expression *const r2FD9 = expr(ir_unop_i2u, r2F97);
                  ir_expression *const r2FDA = lshift(r2FD9, body.constant(int(20)));
                  ir_expression *const r2FDB = add(r2FD8, r2FDA);
                  body.emit(assign(r2FD7, add(r2FDB, r2F98), 0x02));

                  body.emit(assign(r2FD7, r2F99, 0x01));

                  body.emit(assign(r2F9C, r2FD7, 0x03));

                  body.emit(assign(r2F9B, body.constant(false), 0x01));


               body.instructions = f2FC8_parent_instructions;
               body.emit(f2FC8);

               /* END IF */

               body.emit(assign(r2E1D, r2F9C, 0x03));


            body.instructions = f2F08_parent_instructions;
            body.emit(f2F08);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2F06->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2FDD = equal(r2E25, body.constant(int(2047)));
            ir_if *f2FDC = new(mem_ctx) ir_if(operand(r2FDD).val);
            exec_list *const f2FDC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2FDC->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2FDF = bit_or(swizzle_y(r2E22), swizzle_x(r2E22));
               ir_expression *const r2FE0 = bit_or(swizzle_y(r2E20), swizzle_x(r2E20));
               ir_expression *const r2FE1 = bit_or(r2FDF, r2FE0);
               ir_expression *const r2FE2 = nequal(r2FE1, body.constant(0u));
               ir_if *f2FDE = new(mem_ctx) ir_if(operand(r2FE2).val);
               exec_list *const f2FDE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2FDE->then_instructions;

                  ir_variable *const r2FE3 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2FE3, swizzle_x(r28C7), 0x01));

                  ir_variable *const r2FE4 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2FE4, swizzle_x(r28FB), 0x01));

                  ir_variable *const r2FE5 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2FE6 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2FE7 = rshift(swizzle_y(r28C7), body.constant(int(19)));
                  ir_expression *const r2FE8 = bit_and(r2FE7, body.constant(4095u));
                  ir_expression *const r2FE9 = equal(r2FE8, body.constant(4094u));
                  ir_expression *const r2FEA = nequal(swizzle_x(r28C7), body.constant(0u));
                  ir_expression *const r2FEB = bit_and(swizzle_y(r28C7), body.constant(524287u));
                  ir_expression *const r2FEC = nequal(r2FEB, body.constant(0u));
                  ir_expression *const r2FED = logic_or(r2FEA, r2FEC);
                  body.emit(assign(r2FE6, logic_and(r2FE9, r2FED), 0x01));

                  ir_variable *const r2FEE = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2FEF = lshift(swizzle_y(r28FB), body.constant(int(1)));
                  ir_expression *const r2FF0 = lequal(body.constant(4292870144u), r2FEF);
                  ir_expression *const r2FF1 = nequal(swizzle_x(r28FB), body.constant(0u));
                  ir_expression *const r2FF2 = bit_and(swizzle_y(r28FB), body.constant(1048575u));
                  ir_expression *const r2FF3 = nequal(r2FF2, body.constant(0u));
                  ir_expression *const r2FF4 = logic_or(r2FF1, r2FF3);
                  body.emit(assign(r2FEE, logic_and(r2FF0, r2FF4), 0x01));

                  body.emit(assign(r2FE3, bit_or(swizzle_y(r28C7), body.constant(524288u)), 0x02));

                  body.emit(assign(r2FE4, bit_or(swizzle_y(r28FB), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2FF6 = lshift(swizzle_y(r28C7), body.constant(int(1)));
                  ir_expression *const r2FF7 = lequal(body.constant(4292870144u), r2FF6);
                  ir_expression *const r2FF8 = nequal(swizzle_x(r28C7), body.constant(0u));
                  ir_expression *const r2FF9 = bit_and(swizzle_y(r28C7), body.constant(1048575u));
                  ir_expression *const r2FFA = nequal(r2FF9, body.constant(0u));
                  ir_expression *const r2FFB = logic_or(r2FF8, r2FFA);
                  ir_expression *const r2FFC = logic_and(r2FF7, r2FFB);
                  ir_if *f2FF5 = new(mem_ctx) ir_if(operand(r2FFC).val);
                  exec_list *const f2FF5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2FF5->then_instructions;

                     ir_variable *const r2FFD = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2FFF = logic_and(r2FE6, r2FEE);
                     ir_if *f2FFE = new(mem_ctx) ir_if(operand(r2FFF).val);
                     exec_list *const f2FFE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2FFE->then_instructions;

                        body.emit(assign(r2FFD, r2FE4, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2FFE->else_instructions;

                        body.emit(assign(r2FFD, r2FE3, 0x03));


                     body.instructions = f2FFE_parent_instructions;
                     body.emit(f2FFE);

                     /* END IF */

                     body.emit(assign(r2FE5, r2FFD, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2FF5->else_instructions;

                     body.emit(assign(r2FE5, r2FE4, 0x03));


                  body.instructions = f2FF5_parent_instructions;
                  body.emit(f2FF5);

                  /* END IF */

                  body.emit(assign(r2E1D, r2FE5, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2FDE->else_instructions;

                  ir_constant_data r3000_data;
                  memset(&r3000_data, 0, sizeof(ir_constant_data));
                  r3000_data.u[0] = 4294967295;
                  r3000_data.u[1] = 4294967295;
                  ir_constant *const r3000 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3000_data);
                  body.emit(assign(r2E1D, r3000, 0x03));


               body.instructions = f2FDE_parent_instructions;
               body.emit(f2FDE);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2FDC->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3002 = equal(r2E25, body.constant(int(0)));
               ir_if *f3001 = new(mem_ctx) ir_if(operand(r3002).val);
               exec_list *const f3001_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3001->then_instructions;

                  body.emit(assign(r2E21, body.constant(int(1)), 0x01));

                  body.emit(assign(r2E1F, body.constant(int(1)), 0x01));


               body.instructions = f3001_parent_instructions;
               body.emit(f3001);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3004 = less(swizzle_y(r2E20), swizzle_y(r2E22));
               ir_if *f3003 = new(mem_ctx) ir_if(operand(r3004).val);
               exec_list *const f3003_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3003->then_instructions;

                  ir_variable *const r3005 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r3006 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3006, sub(swizzle_x(r2E22), swizzle_x(r2E20)), 0x01));

                  ir_expression *const r3007 = sub(swizzle_y(r2E22), swizzle_y(r2E20));
                  ir_expression *const r3008 = less(swizzle_x(r2E22), swizzle_x(r2E20));
                  ir_expression *const r3009 = expr(ir_unop_b2i, r3008);
                  ir_expression *const r300A = expr(ir_unop_i2u, r3009);
                  body.emit(assign(r3005, sub(r3007, r300A), 0x01));

                  body.emit(assign(r2E23, add(r2E21, body.constant(int(-1))), 0x01));

                  ir_variable *const r300B = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r300B, add(r2E23, body.constant(int(-10))), 0x01));

                  ir_variable *const r300C = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r300C, r3005, 0x01));

                  ir_variable *const r300D = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r300D, r3006, 0x01));

                  ir_variable *const r300E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r300E);
                  ir_variable *const r300F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r300F);
                  /* IF CONDITION */
                  ir_expression *const r3011 = equal(r3005, body.constant(0u));
                  ir_if *f3010 = new(mem_ctx) ir_if(operand(r3011).val);
                  exec_list *const f3010_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3010->then_instructions;

                     body.emit(assign(r300C, r3006, 0x01));

                     body.emit(assign(r300D, body.constant(0u), 0x01));

                     body.emit(assign(r300B, add(r300B, body.constant(int(-32))), 0x01));


                  body.instructions = f3010_parent_instructions;
                  body.emit(f3010);

                  /* END IF */

                  ir_variable *const r3012 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3012, r300C, 0x01));

                  ir_variable *const r3013 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3014 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3014);
                  /* IF CONDITION */
                  ir_expression *const r3016 = equal(r300C, body.constant(0u));
                  ir_if *f3015 = new(mem_ctx) ir_if(operand(r3016).val);
                  exec_list *const f3015_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3015->then_instructions;

                     body.emit(assign(r3013, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3015->else_instructions;

                     body.emit(assign(r3014, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3018 = bit_and(r300C, body.constant(4294901760u));
                     ir_expression *const r3019 = equal(r3018, body.constant(0u));
                     ir_if *f3017 = new(mem_ctx) ir_if(operand(r3019).val);
                     exec_list *const f3017_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3017->then_instructions;

                        body.emit(assign(r3014, body.constant(int(16)), 0x01));

                        body.emit(assign(r3012, lshift(r300C, body.constant(int(16))), 0x01));


                     body.instructions = f3017_parent_instructions;
                     body.emit(f3017);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r301B = bit_and(r3012, body.constant(4278190080u));
                     ir_expression *const r301C = equal(r301B, body.constant(0u));
                     ir_if *f301A = new(mem_ctx) ir_if(operand(r301C).val);
                     exec_list *const f301A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f301A->then_instructions;

                        body.emit(assign(r3014, add(r3014, body.constant(int(8))), 0x01));

                        body.emit(assign(r3012, lshift(r3012, body.constant(int(8))), 0x01));


                     body.instructions = f301A_parent_instructions;
                     body.emit(f301A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r301E = bit_and(r3012, body.constant(4026531840u));
                     ir_expression *const r301F = equal(r301E, body.constant(0u));
                     ir_if *f301D = new(mem_ctx) ir_if(operand(r301F).val);
                     exec_list *const f301D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f301D->then_instructions;

                        body.emit(assign(r3014, add(r3014, body.constant(int(4))), 0x01));

                        body.emit(assign(r3012, lshift(r3012, body.constant(int(4))), 0x01));


                     body.instructions = f301D_parent_instructions;
                     body.emit(f301D);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3021 = bit_and(r3012, body.constant(3221225472u));
                     ir_expression *const r3022 = equal(r3021, body.constant(0u));
                     ir_if *f3020 = new(mem_ctx) ir_if(operand(r3022).val);
                     exec_list *const f3020_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3020->then_instructions;

                        body.emit(assign(r3014, add(r3014, body.constant(int(2))), 0x01));

                        body.emit(assign(r3012, lshift(r3012, body.constant(int(2))), 0x01));


                     body.instructions = f3020_parent_instructions;
                     body.emit(f3020);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3024 = bit_and(r3012, body.constant(2147483648u));
                     ir_expression *const r3025 = equal(r3024, body.constant(0u));
                     ir_if *f3023 = new(mem_ctx) ir_if(operand(r3025).val);
                     exec_list *const f3023_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3023->then_instructions;

                        body.emit(assign(r3014, add(r3014, body.constant(int(1))), 0x01));


                     body.instructions = f3023_parent_instructions;
                     body.emit(f3023);

                     /* END IF */

                     body.emit(assign(r3013, r3014, 0x01));


                  body.instructions = f3015_parent_instructions;
                  body.emit(f3015);

                  /* END IF */

                  body.emit(assign(r300F, add(r3013, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3027 = lequal(body.constant(int(0)), r300F);
                  ir_if *f3026 = new(mem_ctx) ir_if(operand(r3027).val);
                  exec_list *const f3026_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3026->then_instructions;

                     body.emit(assign(r300E, body.constant(0u), 0x01));

                     ir_variable *const r3028 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3028, lshift(r300D, r300F), 0x01));

                     ir_variable *const r3029 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r302B = equal(r300F, body.constant(int(0)));
                     ir_if *f302A = new(mem_ctx) ir_if(operand(r302B).val);
                     exec_list *const f302A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f302A->then_instructions;

                        body.emit(assign(r3029, r300C, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f302A->else_instructions;

                        ir_expression *const r302C = lshift(r300C, r300F);
                        ir_expression *const r302D = neg(r300F);
                        ir_expression *const r302E = bit_and(r302D, body.constant(int(31)));
                        ir_expression *const r302F = rshift(r300D, r302E);
                        body.emit(assign(r3029, bit_or(r302C, r302F), 0x01));


                     body.instructions = f302A_parent_instructions;
                     body.emit(f302A);

                     /* END IF */

                     body.emit(assign(r300C, r3029, 0x01));

                     body.emit(assign(r300D, r3028, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3026->else_instructions;

                     ir_variable *const r3030 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3030, body.constant(0u), 0x01));

                     ir_variable *const r3031 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3031, neg(r300F), 0x01));

                     ir_variable *const r3032 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3032);
                     ir_variable *const r3033 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3033);
                     ir_variable *const r3034 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3034);
                     ir_variable *const r3035 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r3036 = neg(r3031);
                     body.emit(assign(r3035, bit_and(r3036, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3038 = equal(r3031, body.constant(int(0)));
                     ir_if *f3037 = new(mem_ctx) ir_if(operand(r3038).val);
                     exec_list *const f3037_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3037->then_instructions;

                        body.emit(assign(r3032, r3030, 0x01));

                        body.emit(assign(r3033, r300D, 0x01));

                        body.emit(assign(r3034, r300C, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3037->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r303A = less(r3031, body.constant(int(32)));
                        ir_if *f3039 = new(mem_ctx) ir_if(operand(r303A).val);
                        exec_list *const f3039_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3039->then_instructions;

                           body.emit(assign(r3032, lshift(r300D, r3035), 0x01));

                           ir_expression *const r303B = lshift(r300C, r3035);
                           ir_expression *const r303C = rshift(r300D, r3031);
                           body.emit(assign(r3033, bit_or(r303B, r303C), 0x01));

                           body.emit(assign(r3034, rshift(r300C, r3031), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3039->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r303E = equal(r3031, body.constant(int(32)));
                           ir_if *f303D = new(mem_ctx) ir_if(operand(r303E).val);
                           exec_list *const f303D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f303D->then_instructions;

                              body.emit(assign(r3032, r300D, 0x01));

                              body.emit(assign(r3033, r300C, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f303D->else_instructions;

                              body.emit(assign(r3030, bit_or(body.constant(0u), r300D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3040 = less(r3031, body.constant(int(64)));
                              ir_if *f303F = new(mem_ctx) ir_if(operand(r3040).val);
                              exec_list *const f303F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f303F->then_instructions;

                                 body.emit(assign(r3032, lshift(r300C, r3035), 0x01));

                                 ir_expression *const r3041 = bit_and(r3031, body.constant(int(31)));
                                 body.emit(assign(r3033, rshift(r300C, r3041), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f303F->else_instructions;

                                 ir_variable *const r3042 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3044 = equal(r3031, body.constant(int(64)));
                                 ir_if *f3043 = new(mem_ctx) ir_if(operand(r3044).val);
                                 exec_list *const f3043_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3043->then_instructions;

                                    body.emit(assign(r3042, r300C, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3043->else_instructions;

                                    ir_expression *const r3045 = nequal(r300C, body.constant(0u));
                                    ir_expression *const r3046 = expr(ir_unop_b2i, r3045);
                                    body.emit(assign(r3042, expr(ir_unop_i2u, r3046), 0x01));


                                 body.instructions = f3043_parent_instructions;
                                 body.emit(f3043);

                                 /* END IF */

                                 body.emit(assign(r3032, r3042, 0x01));

                                 body.emit(assign(r3033, body.constant(0u), 0x01));


                              body.instructions = f303F_parent_instructions;
                              body.emit(f303F);

                              /* END IF */


                           body.instructions = f303D_parent_instructions;
                           body.emit(f303D);

                           /* END IF */

                           body.emit(assign(r3034, body.constant(0u), 0x01));


                        body.instructions = f3039_parent_instructions;
                        body.emit(f3039);

                        /* END IF */

                        ir_expression *const r3047 = nequal(r3030, body.constant(0u));
                        ir_expression *const r3048 = expr(ir_unop_b2i, r3047);
                        ir_expression *const r3049 = expr(ir_unop_i2u, r3048);
                        body.emit(assign(r3032, bit_or(r3032, r3049), 0x01));


                     body.instructions = f3037_parent_instructions;
                     body.emit(f3037);

                     /* END IF */

                     body.emit(assign(r300C, r3034, 0x01));

                     body.emit(assign(r300D, r3033, 0x01));

                     body.emit(assign(r300E, r3032, 0x01));


                  body.instructions = f3026_parent_instructions;
                  body.emit(f3026);

                  /* END IF */

                  body.emit(assign(r300B, sub(r300B, r300F), 0x01));

                  ir_variable *const r304A = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r304A, r300B, 0x01));

                  ir_variable *const r304B = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r304B, r300C, 0x01));

                  ir_variable *const r304C = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r304C, r300D, 0x01));

                  ir_variable *const r304D = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r304D, r300E, 0x01));

                  ir_variable *const r304E = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r304E, body.constant(true), 0x01));

                  ir_variable *const r304F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3050 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r3050);
                  ir_expression *const r3051 = expr(ir_unop_u2i, r300E);
                  body.emit(assign(r3050, less(r3051, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3053 = lequal(body.constant(int(2045)), r300B);
                  ir_if *f3052 = new(mem_ctx) ir_if(operand(r3053).val);
                  exec_list *const f3052_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3052->then_instructions;

                     ir_variable *const r3054 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3056 = less(body.constant(int(2045)), r300B);
                     ir_if *f3055 = new(mem_ctx) ir_if(operand(r3056).val);
                     exec_list *const f3055_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3055->then_instructions;

                        body.emit(assign(r3054, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3055->else_instructions;

                        ir_variable *const r3057 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3059 = equal(r300B, body.constant(int(2045)));
                        ir_if *f3058 = new(mem_ctx) ir_if(operand(r3059).val);
                        exec_list *const f3058_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3058->then_instructions;

                           ir_expression *const r305A = equal(body.constant(2097151u), r300C);
                           ir_expression *const r305B = equal(body.constant(4294967295u), r300D);
                           body.emit(assign(r3057, logic_and(r305A, r305B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3058->else_instructions;

                           body.emit(assign(r3057, body.constant(false), 0x01));


                        body.instructions = f3058_parent_instructions;
                        body.emit(f3058);

                        /* END IF */

                        body.emit(assign(r3054, logic_and(r3057, r3050), 0x01));


                     body.instructions = f3055_parent_instructions;
                     body.emit(f3055);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f305C = new(mem_ctx) ir_if(operand(r3054).val);
                     exec_list *const f305C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f305C->then_instructions;

                        ir_variable *const r305D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r305D);
                        ir_expression *const r305E = lshift(r2E1C, body.constant(int(31)));
                        body.emit(assign(r305D, add(r305E, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r305D, body.constant(0u), 0x01));

                        body.emit(assign(r304F, r305D, 0x03));

                        body.emit(assign(r304E, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f305C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3060 = less(r300B, body.constant(int(0)));
                        ir_if *f305F = new(mem_ctx) ir_if(operand(r3060).val);
                        exec_list *const f305F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f305F->then_instructions;

                           ir_variable *const r3061 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3061, r300E, 0x01));

                           ir_variable *const r3062 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3062, neg(r300B), 0x01));

                           ir_variable *const r3063 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3063);
                           ir_variable *const r3064 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3064);
                           ir_variable *const r3065 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3065);
                           ir_variable *const r3066 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3067 = neg(r3062);
                           body.emit(assign(r3066, bit_and(r3067, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3069 = equal(r3062, body.constant(int(0)));
                           ir_if *f3068 = new(mem_ctx) ir_if(operand(r3069).val);
                           exec_list *const f3068_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3068->then_instructions;

                              body.emit(assign(r3063, r300E, 0x01));

                              body.emit(assign(r3064, r300D, 0x01));

                              body.emit(assign(r3065, r300C, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3068->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r306B = less(r3062, body.constant(int(32)));
                              ir_if *f306A = new(mem_ctx) ir_if(operand(r306B).val);
                              exec_list *const f306A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f306A->then_instructions;

                                 body.emit(assign(r3063, lshift(r300D, r3066), 0x01));

                                 ir_expression *const r306C = lshift(r300C, r3066);
                                 ir_expression *const r306D = rshift(r300D, r3062);
                                 body.emit(assign(r3064, bit_or(r306C, r306D), 0x01));

                                 body.emit(assign(r3065, rshift(r300C, r3062), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f306A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r306F = equal(r3062, body.constant(int(32)));
                                 ir_if *f306E = new(mem_ctx) ir_if(operand(r306F).val);
                                 exec_list *const f306E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f306E->then_instructions;

                                    body.emit(assign(r3063, r300D, 0x01));

                                    body.emit(assign(r3064, r300C, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f306E->else_instructions;

                                    body.emit(assign(r3061, bit_or(r300E, r300D), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3071 = less(r3062, body.constant(int(64)));
                                    ir_if *f3070 = new(mem_ctx) ir_if(operand(r3071).val);
                                    exec_list *const f3070_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3070->then_instructions;

                                       body.emit(assign(r3063, lshift(r300C, r3066), 0x01));

                                       ir_expression *const r3072 = bit_and(r3062, body.constant(int(31)));
                                       body.emit(assign(r3064, rshift(r300C, r3072), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3070->else_instructions;

                                       ir_variable *const r3073 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3075 = equal(r3062, body.constant(int(64)));
                                       ir_if *f3074 = new(mem_ctx) ir_if(operand(r3075).val);
                                       exec_list *const f3074_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3074->then_instructions;

                                          body.emit(assign(r3073, r300C, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3074->else_instructions;

                                          ir_expression *const r3076 = nequal(r300C, body.constant(0u));
                                          ir_expression *const r3077 = expr(ir_unop_b2i, r3076);
                                          body.emit(assign(r3073, expr(ir_unop_i2u, r3077), 0x01));


                                       body.instructions = f3074_parent_instructions;
                                       body.emit(f3074);

                                       /* END IF */

                                       body.emit(assign(r3063, r3073, 0x01));

                                       body.emit(assign(r3064, body.constant(0u), 0x01));


                                    body.instructions = f3070_parent_instructions;
                                    body.emit(f3070);

                                    /* END IF */


                                 body.instructions = f306E_parent_instructions;
                                 body.emit(f306E);

                                 /* END IF */

                                 body.emit(assign(r3065, body.constant(0u), 0x01));


                              body.instructions = f306A_parent_instructions;
                              body.emit(f306A);

                              /* END IF */

                              ir_expression *const r3078 = nequal(r3061, body.constant(0u));
                              ir_expression *const r3079 = expr(ir_unop_b2i, r3078);
                              ir_expression *const r307A = expr(ir_unop_i2u, r3079);
                              body.emit(assign(r3063, bit_or(r3063, r307A), 0x01));


                           body.instructions = f3068_parent_instructions;
                           body.emit(f3068);

                           /* END IF */

                           body.emit(assign(r304B, r3065, 0x01));

                           body.emit(assign(r304C, r3064, 0x01));

                           body.emit(assign(r304D, r3063, 0x01));

                           body.emit(assign(r304A, body.constant(int(0)), 0x01));

                           body.emit(assign(r3050, less(r3063, body.constant(0u)), 0x01));


                        body.instructions = f305F_parent_instructions;
                        body.emit(f305F);

                        /* END IF */


                     body.instructions = f305C_parent_instructions;
                     body.emit(f305C);

                     /* END IF */


                  body.instructions = f3052_parent_instructions;
                  body.emit(f3052);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f307B = new(mem_ctx) ir_if(operand(r304E).val);
                  exec_list *const f307B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f307B->then_instructions;

                     /* IF CONDITION */
                     ir_if *f307C = new(mem_ctx) ir_if(operand(r3050).val);
                     exec_list *const f307C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f307C->then_instructions;

                        ir_variable *const r307D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r307D, add(r304C, body.constant(1u)), 0x01));

                        ir_expression *const r307E = less(r307D, r304C);
                        ir_expression *const r307F = expr(ir_unop_b2i, r307E);
                        ir_expression *const r3080 = expr(ir_unop_i2u, r307F);
                        body.emit(assign(r304B, add(r304B, r3080), 0x01));

                        ir_expression *const r3081 = equal(r304D, body.constant(0u));
                        ir_expression *const r3082 = expr(ir_unop_b2i, r3081);
                        ir_expression *const r3083 = expr(ir_unop_i2u, r3082);
                        ir_expression *const r3084 = add(r304D, r3083);
                        ir_expression *const r3085 = bit_and(r3084, body.constant(1u));
                        ir_expression *const r3086 = expr(ir_unop_bit_not, r3085);
                        body.emit(assign(r304C, bit_and(r307D, r3086), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f307C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3088 = bit_or(r304B, r304C);
                        ir_expression *const r3089 = equal(r3088, body.constant(0u));
                        ir_if *f3087 = new(mem_ctx) ir_if(operand(r3089).val);
                        exec_list *const f3087_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3087->then_instructions;

                           body.emit(assign(r304A, body.constant(int(0)), 0x01));


                        body.instructions = f3087_parent_instructions;
                        body.emit(f3087);

                        /* END IF */


                     body.instructions = f307C_parent_instructions;
                     body.emit(f307C);

                     /* END IF */

                     ir_variable *const r308A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r308A);
                     ir_expression *const r308B = lshift(r2E1C, body.constant(int(31)));
                     ir_expression *const r308C = expr(ir_unop_i2u, r304A);
                     ir_expression *const r308D = lshift(r308C, body.constant(int(20)));
                     ir_expression *const r308E = add(r308B, r308D);
                     body.emit(assign(r308A, add(r308E, r304B), 0x02));

                     body.emit(assign(r308A, r304C, 0x01));

                     body.emit(assign(r304F, r308A, 0x03));

                     body.emit(assign(r304E, body.constant(false), 0x01));


                  body.instructions = f307B_parent_instructions;
                  body.emit(f307B);

                  /* END IF */

                  body.emit(assign(r2E1D, r304F, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3003->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3090 = less(swizzle_y(r2E22), swizzle_y(r2E20));
                  ir_if *f308F = new(mem_ctx) ir_if(operand(r3090).val);
                  exec_list *const f308F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f308F->then_instructions;

                     ir_variable *const r3091 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r3092 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3092, sub(swizzle_x(r2E20), swizzle_x(r2E22)), 0x01));

                     ir_expression *const r3093 = sub(swizzle_y(r2E20), swizzle_y(r2E22));
                     ir_expression *const r3094 = less(swizzle_x(r2E20), swizzle_x(r2E22));
                     ir_expression *const r3095 = expr(ir_unop_b2i, r3094);
                     ir_expression *const r3096 = expr(ir_unop_i2u, r3095);
                     body.emit(assign(r3091, sub(r3093, r3096), 0x01));

                     body.emit(assign(r2E1C, bit_xor(r2E1C, body.constant(1u)), 0x01));

                     body.emit(assign(r2E23, add(r2E1F, body.constant(int(-1))), 0x01));

                     ir_variable *const r3097 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3097, add(r2E23, body.constant(int(-10))), 0x01));

                     ir_variable *const r3098 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r3098, r3091, 0x01));

                     ir_variable *const r3099 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r3099, r3092, 0x01));

                     ir_variable *const r309A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r309A);
                     ir_variable *const r309B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r309B);
                     /* IF CONDITION */
                     ir_expression *const r309D = equal(r3091, body.constant(0u));
                     ir_if *f309C = new(mem_ctx) ir_if(operand(r309D).val);
                     exec_list *const f309C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f309C->then_instructions;

                        body.emit(assign(r3098, r3092, 0x01));

                        body.emit(assign(r3099, body.constant(0u), 0x01));

                        body.emit(assign(r3097, add(r3097, body.constant(int(-32))), 0x01));


                     body.instructions = f309C_parent_instructions;
                     body.emit(f309C);

                     /* END IF */

                     ir_variable *const r309E = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r309E, r3098, 0x01));

                     ir_variable *const r309F = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r30A0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r30A0);
                     /* IF CONDITION */
                     ir_expression *const r30A2 = equal(r3098, body.constant(0u));
                     ir_if *f30A1 = new(mem_ctx) ir_if(operand(r30A2).val);
                     exec_list *const f30A1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30A1->then_instructions;

                        body.emit(assign(r309F, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f30A1->else_instructions;

                        body.emit(assign(r30A0, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r30A4 = bit_and(r3098, body.constant(4294901760u));
                        ir_expression *const r30A5 = equal(r30A4, body.constant(0u));
                        ir_if *f30A3 = new(mem_ctx) ir_if(operand(r30A5).val);
                        exec_list *const f30A3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30A3->then_instructions;

                           body.emit(assign(r30A0, body.constant(int(16)), 0x01));

                           body.emit(assign(r309E, lshift(r3098, body.constant(int(16))), 0x01));


                        body.instructions = f30A3_parent_instructions;
                        body.emit(f30A3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r30A7 = bit_and(r309E, body.constant(4278190080u));
                        ir_expression *const r30A8 = equal(r30A7, body.constant(0u));
                        ir_if *f30A6 = new(mem_ctx) ir_if(operand(r30A8).val);
                        exec_list *const f30A6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30A6->then_instructions;

                           body.emit(assign(r30A0, add(r30A0, body.constant(int(8))), 0x01));

                           body.emit(assign(r309E, lshift(r309E, body.constant(int(8))), 0x01));


                        body.instructions = f30A6_parent_instructions;
                        body.emit(f30A6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r30AA = bit_and(r309E, body.constant(4026531840u));
                        ir_expression *const r30AB = equal(r30AA, body.constant(0u));
                        ir_if *f30A9 = new(mem_ctx) ir_if(operand(r30AB).val);
                        exec_list *const f30A9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30A9->then_instructions;

                           body.emit(assign(r30A0, add(r30A0, body.constant(int(4))), 0x01));

                           body.emit(assign(r309E, lshift(r309E, body.constant(int(4))), 0x01));


                        body.instructions = f30A9_parent_instructions;
                        body.emit(f30A9);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r30AD = bit_and(r309E, body.constant(3221225472u));
                        ir_expression *const r30AE = equal(r30AD, body.constant(0u));
                        ir_if *f30AC = new(mem_ctx) ir_if(operand(r30AE).val);
                        exec_list *const f30AC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30AC->then_instructions;

                           body.emit(assign(r30A0, add(r30A0, body.constant(int(2))), 0x01));

                           body.emit(assign(r309E, lshift(r309E, body.constant(int(2))), 0x01));


                        body.instructions = f30AC_parent_instructions;
                        body.emit(f30AC);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r30B0 = bit_and(r309E, body.constant(2147483648u));
                        ir_expression *const r30B1 = equal(r30B0, body.constant(0u));
                        ir_if *f30AF = new(mem_ctx) ir_if(operand(r30B1).val);
                        exec_list *const f30AF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30AF->then_instructions;

                           body.emit(assign(r30A0, add(r30A0, body.constant(int(1))), 0x01));


                        body.instructions = f30AF_parent_instructions;
                        body.emit(f30AF);

                        /* END IF */

                        body.emit(assign(r309F, r30A0, 0x01));


                     body.instructions = f30A1_parent_instructions;
                     body.emit(f30A1);

                     /* END IF */

                     body.emit(assign(r309B, add(r309F, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r30B3 = lequal(body.constant(int(0)), r309B);
                     ir_if *f30B2 = new(mem_ctx) ir_if(operand(r30B3).val);
                     exec_list *const f30B2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30B2->then_instructions;

                        body.emit(assign(r309A, body.constant(0u), 0x01));

                        ir_variable *const r30B4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r30B4, lshift(r3099, r309B), 0x01));

                        ir_variable *const r30B5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r30B7 = equal(r309B, body.constant(int(0)));
                        ir_if *f30B6 = new(mem_ctx) ir_if(operand(r30B7).val);
                        exec_list *const f30B6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30B6->then_instructions;

                           body.emit(assign(r30B5, r3098, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30B6->else_instructions;

                           ir_expression *const r30B8 = lshift(r3098, r309B);
                           ir_expression *const r30B9 = neg(r309B);
                           ir_expression *const r30BA = bit_and(r30B9, body.constant(int(31)));
                           ir_expression *const r30BB = rshift(r3099, r30BA);
                           body.emit(assign(r30B5, bit_or(r30B8, r30BB), 0x01));


                        body.instructions = f30B6_parent_instructions;
                        body.emit(f30B6);

                        /* END IF */

                        body.emit(assign(r3098, r30B5, 0x01));

                        body.emit(assign(r3099, r30B4, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f30B2->else_instructions;

                        ir_variable *const r30BC = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r30BC, body.constant(0u), 0x01));

                        ir_variable *const r30BD = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r30BD, neg(r309B), 0x01));

                        ir_variable *const r30BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r30BE);
                        ir_variable *const r30BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r30BF);
                        ir_variable *const r30C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r30C0);
                        ir_variable *const r30C1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r30C2 = neg(r30BD);
                        body.emit(assign(r30C1, bit_and(r30C2, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r30C4 = equal(r30BD, body.constant(int(0)));
                        ir_if *f30C3 = new(mem_ctx) ir_if(operand(r30C4).val);
                        exec_list *const f30C3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30C3->then_instructions;

                           body.emit(assign(r30BE, r30BC, 0x01));

                           body.emit(assign(r30BF, r3099, 0x01));

                           body.emit(assign(r30C0, r3098, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30C3->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r30C6 = less(r30BD, body.constant(int(32)));
                           ir_if *f30C5 = new(mem_ctx) ir_if(operand(r30C6).val);
                           exec_list *const f30C5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f30C5->then_instructions;

                              body.emit(assign(r30BE, lshift(r3099, r30C1), 0x01));

                              ir_expression *const r30C7 = lshift(r3098, r30C1);
                              ir_expression *const r30C8 = rshift(r3099, r30BD);
                              body.emit(assign(r30BF, bit_or(r30C7, r30C8), 0x01));

                              body.emit(assign(r30C0, rshift(r3098, r30BD), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f30C5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r30CA = equal(r30BD, body.constant(int(32)));
                              ir_if *f30C9 = new(mem_ctx) ir_if(operand(r30CA).val);
                              exec_list *const f30C9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f30C9->then_instructions;

                                 body.emit(assign(r30BE, r3099, 0x01));

                                 body.emit(assign(r30BF, r3098, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f30C9->else_instructions;

                                 body.emit(assign(r30BC, bit_or(body.constant(0u), r3099), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r30CC = less(r30BD, body.constant(int(64)));
                                 ir_if *f30CB = new(mem_ctx) ir_if(operand(r30CC).val);
                                 exec_list *const f30CB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f30CB->then_instructions;

                                    body.emit(assign(r30BE, lshift(r3098, r30C1), 0x01));

                                    ir_expression *const r30CD = bit_and(r30BD, body.constant(int(31)));
                                    body.emit(assign(r30BF, rshift(r3098, r30CD), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f30CB->else_instructions;

                                    ir_variable *const r30CE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r30D0 = equal(r30BD, body.constant(int(64)));
                                    ir_if *f30CF = new(mem_ctx) ir_if(operand(r30D0).val);
                                    exec_list *const f30CF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f30CF->then_instructions;

                                       body.emit(assign(r30CE, r3098, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f30CF->else_instructions;

                                       ir_expression *const r30D1 = nequal(r3098, body.constant(0u));
                                       ir_expression *const r30D2 = expr(ir_unop_b2i, r30D1);
                                       body.emit(assign(r30CE, expr(ir_unop_i2u, r30D2), 0x01));


                                    body.instructions = f30CF_parent_instructions;
                                    body.emit(f30CF);

                                    /* END IF */

                                    body.emit(assign(r30BE, r30CE, 0x01));

                                    body.emit(assign(r30BF, body.constant(0u), 0x01));


                                 body.instructions = f30CB_parent_instructions;
                                 body.emit(f30CB);

                                 /* END IF */


                              body.instructions = f30C9_parent_instructions;
                              body.emit(f30C9);

                              /* END IF */

                              body.emit(assign(r30C0, body.constant(0u), 0x01));


                           body.instructions = f30C5_parent_instructions;
                           body.emit(f30C5);

                           /* END IF */

                           ir_expression *const r30D3 = nequal(r30BC, body.constant(0u));
                           ir_expression *const r30D4 = expr(ir_unop_b2i, r30D3);
                           ir_expression *const r30D5 = expr(ir_unop_i2u, r30D4);
                           body.emit(assign(r30BE, bit_or(r30BE, r30D5), 0x01));


                        body.instructions = f30C3_parent_instructions;
                        body.emit(f30C3);

                        /* END IF */

                        body.emit(assign(r3098, r30C0, 0x01));

                        body.emit(assign(r3099, r30BF, 0x01));

                        body.emit(assign(r309A, r30BE, 0x01));


                     body.instructions = f30B2_parent_instructions;
                     body.emit(f30B2);

                     /* END IF */

                     body.emit(assign(r3097, sub(r3097, r309B), 0x01));

                     ir_variable *const r30D6 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r30D6, r3097, 0x01));

                     ir_variable *const r30D7 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r30D7, r3098, 0x01));

                     ir_variable *const r30D8 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r30D8, r3099, 0x01));

                     ir_variable *const r30D9 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r30D9, r309A, 0x01));

                     ir_variable *const r30DA = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r30DA, body.constant(true), 0x01));

                     ir_variable *const r30DB = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r30DC = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r30DC);
                     ir_expression *const r30DD = expr(ir_unop_u2i, r309A);
                     body.emit(assign(r30DC, less(r30DD, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r30DF = lequal(body.constant(int(2045)), r3097);
                     ir_if *f30DE = new(mem_ctx) ir_if(operand(r30DF).val);
                     exec_list *const f30DE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30DE->then_instructions;

                        ir_variable *const r30E0 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r30E2 = less(body.constant(int(2045)), r3097);
                        ir_if *f30E1 = new(mem_ctx) ir_if(operand(r30E2).val);
                        exec_list *const f30E1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30E1->then_instructions;

                           body.emit(assign(r30E0, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30E1->else_instructions;

                           ir_variable *const r30E3 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r30E5 = equal(r3097, body.constant(int(2045)));
                           ir_if *f30E4 = new(mem_ctx) ir_if(operand(r30E5).val);
                           exec_list *const f30E4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f30E4->then_instructions;

                              ir_expression *const r30E6 = equal(body.constant(2097151u), r3098);
                              ir_expression *const r30E7 = equal(body.constant(4294967295u), r3099);
                              body.emit(assign(r30E3, logic_and(r30E6, r30E7), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f30E4->else_instructions;

                              body.emit(assign(r30E3, body.constant(false), 0x01));


                           body.instructions = f30E4_parent_instructions;
                           body.emit(f30E4);

                           /* END IF */

                           body.emit(assign(r30E0, logic_and(r30E3, r30DC), 0x01));


                        body.instructions = f30E1_parent_instructions;
                        body.emit(f30E1);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f30E8 = new(mem_ctx) ir_if(operand(r30E0).val);
                        exec_list *const f30E8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30E8->then_instructions;

                           ir_variable *const r30E9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r30E9);
                           ir_expression *const r30EA = lshift(r2E1C, body.constant(int(31)));
                           body.emit(assign(r30E9, add(r30EA, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r30E9, body.constant(0u), 0x01));

                           body.emit(assign(r30DB, r30E9, 0x03));

                           body.emit(assign(r30DA, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30E8->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r30EC = less(r3097, body.constant(int(0)));
                           ir_if *f30EB = new(mem_ctx) ir_if(operand(r30EC).val);
                           exec_list *const f30EB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f30EB->then_instructions;

                              ir_variable *const r30ED = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r30ED, r309A, 0x01));

                              ir_variable *const r30EE = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r30EE, neg(r3097), 0x01));

                              ir_variable *const r30EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r30EF);
                              ir_variable *const r30F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r30F0);
                              ir_variable *const r30F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r30F1);
                              ir_variable *const r30F2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r30F3 = neg(r30EE);
                              body.emit(assign(r30F2, bit_and(r30F3, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r30F5 = equal(r30EE, body.constant(int(0)));
                              ir_if *f30F4 = new(mem_ctx) ir_if(operand(r30F5).val);
                              exec_list *const f30F4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f30F4->then_instructions;

                                 body.emit(assign(r30EF, r309A, 0x01));

                                 body.emit(assign(r30F0, r3099, 0x01));

                                 body.emit(assign(r30F1, r3098, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f30F4->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r30F7 = less(r30EE, body.constant(int(32)));
                                 ir_if *f30F6 = new(mem_ctx) ir_if(operand(r30F7).val);
                                 exec_list *const f30F6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f30F6->then_instructions;

                                    body.emit(assign(r30EF, lshift(r3099, r30F2), 0x01));

                                    ir_expression *const r30F8 = lshift(r3098, r30F2);
                                    ir_expression *const r30F9 = rshift(r3099, r30EE);
                                    body.emit(assign(r30F0, bit_or(r30F8, r30F9), 0x01));

                                    body.emit(assign(r30F1, rshift(r3098, r30EE), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f30F6->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r30FB = equal(r30EE, body.constant(int(32)));
                                    ir_if *f30FA = new(mem_ctx) ir_if(operand(r30FB).val);
                                    exec_list *const f30FA_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f30FA->then_instructions;

                                       body.emit(assign(r30EF, r3099, 0x01));

                                       body.emit(assign(r30F0, r3098, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f30FA->else_instructions;

                                       body.emit(assign(r30ED, bit_or(r309A, r3099), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r30FD = less(r30EE, body.constant(int(64)));
                                       ir_if *f30FC = new(mem_ctx) ir_if(operand(r30FD).val);
                                       exec_list *const f30FC_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f30FC->then_instructions;

                                          body.emit(assign(r30EF, lshift(r3098, r30F2), 0x01));

                                          ir_expression *const r30FE = bit_and(r30EE, body.constant(int(31)));
                                          body.emit(assign(r30F0, rshift(r3098, r30FE), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f30FC->else_instructions;

                                          ir_variable *const r30FF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3101 = equal(r30EE, body.constant(int(64)));
                                          ir_if *f3100 = new(mem_ctx) ir_if(operand(r3101).val);
                                          exec_list *const f3100_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3100->then_instructions;

                                             body.emit(assign(r30FF, r3098, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3100->else_instructions;

                                             ir_expression *const r3102 = nequal(r3098, body.constant(0u));
                                             ir_expression *const r3103 = expr(ir_unop_b2i, r3102);
                                             body.emit(assign(r30FF, expr(ir_unop_i2u, r3103), 0x01));


                                          body.instructions = f3100_parent_instructions;
                                          body.emit(f3100);

                                          /* END IF */

                                          body.emit(assign(r30EF, r30FF, 0x01));

                                          body.emit(assign(r30F0, body.constant(0u), 0x01));


                                       body.instructions = f30FC_parent_instructions;
                                       body.emit(f30FC);

                                       /* END IF */


                                    body.instructions = f30FA_parent_instructions;
                                    body.emit(f30FA);

                                    /* END IF */

                                    body.emit(assign(r30F1, body.constant(0u), 0x01));


                                 body.instructions = f30F6_parent_instructions;
                                 body.emit(f30F6);

                                 /* END IF */

                                 ir_expression *const r3104 = nequal(r30ED, body.constant(0u));
                                 ir_expression *const r3105 = expr(ir_unop_b2i, r3104);
                                 ir_expression *const r3106 = expr(ir_unop_i2u, r3105);
                                 body.emit(assign(r30EF, bit_or(r30EF, r3106), 0x01));


                              body.instructions = f30F4_parent_instructions;
                              body.emit(f30F4);

                              /* END IF */

                              body.emit(assign(r30D7, r30F1, 0x01));

                              body.emit(assign(r30D8, r30F0, 0x01));

                              body.emit(assign(r30D9, r30EF, 0x01));

                              body.emit(assign(r30D6, body.constant(int(0)), 0x01));

                              body.emit(assign(r30DC, less(r30EF, body.constant(0u)), 0x01));


                           body.instructions = f30EB_parent_instructions;
                           body.emit(f30EB);

                           /* END IF */


                        body.instructions = f30E8_parent_instructions;
                        body.emit(f30E8);

                        /* END IF */


                     body.instructions = f30DE_parent_instructions;
                     body.emit(f30DE);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3107 = new(mem_ctx) ir_if(operand(r30DA).val);
                     exec_list *const f3107_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3107->then_instructions;

                        /* IF CONDITION */
                        ir_if *f3108 = new(mem_ctx) ir_if(operand(r30DC).val);
                        exec_list *const f3108_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3108->then_instructions;

                           ir_variable *const r3109 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r3109, add(r30D8, body.constant(1u)), 0x01));

                           ir_expression *const r310A = less(r3109, r30D8);
                           ir_expression *const r310B = expr(ir_unop_b2i, r310A);
                           ir_expression *const r310C = expr(ir_unop_i2u, r310B);
                           body.emit(assign(r30D7, add(r30D7, r310C), 0x01));

                           ir_expression *const r310D = equal(r30D9, body.constant(0u));
                           ir_expression *const r310E = expr(ir_unop_b2i, r310D);
                           ir_expression *const r310F = expr(ir_unop_i2u, r310E);
                           ir_expression *const r3110 = add(r30D9, r310F);
                           ir_expression *const r3111 = bit_and(r3110, body.constant(1u));
                           ir_expression *const r3112 = expr(ir_unop_bit_not, r3111);
                           body.emit(assign(r30D8, bit_and(r3109, r3112), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3108->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3114 = bit_or(r30D7, r30D8);
                           ir_expression *const r3115 = equal(r3114, body.constant(0u));
                           ir_if *f3113 = new(mem_ctx) ir_if(operand(r3115).val);
                           exec_list *const f3113_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3113->then_instructions;

                              body.emit(assign(r30D6, body.constant(int(0)), 0x01));


                           body.instructions = f3113_parent_instructions;
                           body.emit(f3113);

                           /* END IF */


                        body.instructions = f3108_parent_instructions;
                        body.emit(f3108);

                        /* END IF */

                        ir_variable *const r3116 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3116);
                        ir_expression *const r3117 = lshift(r2E1C, body.constant(int(31)));
                        ir_expression *const r3118 = expr(ir_unop_i2u, r30D6);
                        ir_expression *const r3119 = lshift(r3118, body.constant(int(20)));
                        ir_expression *const r311A = add(r3117, r3119);
                        body.emit(assign(r3116, add(r311A, r30D7), 0x02));

                        body.emit(assign(r3116, r30D8, 0x01));

                        body.emit(assign(r30DB, r3116, 0x03));

                        body.emit(assign(r30DA, body.constant(false), 0x01));


                     body.instructions = f3107_parent_instructions;
                     body.emit(f3107);

                     /* END IF */

                     body.emit(assign(r2E1D, r30DB, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f308F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r311C = less(swizzle_x(r2E20), swizzle_x(r2E22));
                     ir_if *f311B = new(mem_ctx) ir_if(operand(r311C).val);
                     exec_list *const f311B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f311B->then_instructions;

                        ir_variable *const r311D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r311E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r311E, sub(swizzle_x(r2E22), swizzle_x(r2E20)), 0x01));

                        ir_expression *const r311F = sub(swizzle_y(r2E22), swizzle_y(r2E20));
                        ir_expression *const r3120 = less(swizzle_x(r2E22), swizzle_x(r2E20));
                        ir_expression *const r3121 = expr(ir_unop_b2i, r3120);
                        ir_expression *const r3122 = expr(ir_unop_i2u, r3121);
                        body.emit(assign(r311D, sub(r311F, r3122), 0x01));

                        body.emit(assign(r2E23, add(r2E21, body.constant(int(-1))), 0x01));

                        ir_variable *const r3123 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3123, add(r2E23, body.constant(int(-10))), 0x01));

                        ir_variable *const r3124 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3124, r311D, 0x01));

                        ir_variable *const r3125 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3125, r311E, 0x01));

                        ir_variable *const r3126 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r3126);
                        ir_variable *const r3127 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r3127);
                        /* IF CONDITION */
                        ir_expression *const r3129 = equal(r311D, body.constant(0u));
                        ir_if *f3128 = new(mem_ctx) ir_if(operand(r3129).val);
                        exec_list *const f3128_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3128->then_instructions;

                           body.emit(assign(r3124, r311E, 0x01));

                           body.emit(assign(r3125, body.constant(0u), 0x01));

                           body.emit(assign(r3123, add(r3123, body.constant(int(-32))), 0x01));


                        body.instructions = f3128_parent_instructions;
                        body.emit(f3128);

                        /* END IF */

                        ir_variable *const r312A = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r312A, r3124, 0x01));

                        ir_variable *const r312B = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r312C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r312C);
                        /* IF CONDITION */
                        ir_expression *const r312E = equal(r3124, body.constant(0u));
                        ir_if *f312D = new(mem_ctx) ir_if(operand(r312E).val);
                        exec_list *const f312D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f312D->then_instructions;

                           body.emit(assign(r312B, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f312D->else_instructions;

                           body.emit(assign(r312C, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3130 = bit_and(r3124, body.constant(4294901760u));
                           ir_expression *const r3131 = equal(r3130, body.constant(0u));
                           ir_if *f312F = new(mem_ctx) ir_if(operand(r3131).val);
                           exec_list *const f312F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f312F->then_instructions;

                              body.emit(assign(r312C, body.constant(int(16)), 0x01));

                              body.emit(assign(r312A, lshift(r3124, body.constant(int(16))), 0x01));


                           body.instructions = f312F_parent_instructions;
                           body.emit(f312F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3133 = bit_and(r312A, body.constant(4278190080u));
                           ir_expression *const r3134 = equal(r3133, body.constant(0u));
                           ir_if *f3132 = new(mem_ctx) ir_if(operand(r3134).val);
                           exec_list *const f3132_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3132->then_instructions;

                              body.emit(assign(r312C, add(r312C, body.constant(int(8))), 0x01));

                              body.emit(assign(r312A, lshift(r312A, body.constant(int(8))), 0x01));


                           body.instructions = f3132_parent_instructions;
                           body.emit(f3132);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3136 = bit_and(r312A, body.constant(4026531840u));
                           ir_expression *const r3137 = equal(r3136, body.constant(0u));
                           ir_if *f3135 = new(mem_ctx) ir_if(operand(r3137).val);
                           exec_list *const f3135_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3135->then_instructions;

                              body.emit(assign(r312C, add(r312C, body.constant(int(4))), 0x01));

                              body.emit(assign(r312A, lshift(r312A, body.constant(int(4))), 0x01));


                           body.instructions = f3135_parent_instructions;
                           body.emit(f3135);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3139 = bit_and(r312A, body.constant(3221225472u));
                           ir_expression *const r313A = equal(r3139, body.constant(0u));
                           ir_if *f3138 = new(mem_ctx) ir_if(operand(r313A).val);
                           exec_list *const f3138_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3138->then_instructions;

                              body.emit(assign(r312C, add(r312C, body.constant(int(2))), 0x01));

                              body.emit(assign(r312A, lshift(r312A, body.constant(int(2))), 0x01));


                           body.instructions = f3138_parent_instructions;
                           body.emit(f3138);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r313C = bit_and(r312A, body.constant(2147483648u));
                           ir_expression *const r313D = equal(r313C, body.constant(0u));
                           ir_if *f313B = new(mem_ctx) ir_if(operand(r313D).val);
                           exec_list *const f313B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f313B->then_instructions;

                              body.emit(assign(r312C, add(r312C, body.constant(int(1))), 0x01));


                           body.instructions = f313B_parent_instructions;
                           body.emit(f313B);

                           /* END IF */

                           body.emit(assign(r312B, r312C, 0x01));


                        body.instructions = f312D_parent_instructions;
                        body.emit(f312D);

                        /* END IF */

                        body.emit(assign(r3127, add(r312B, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r313F = lequal(body.constant(int(0)), r3127);
                        ir_if *f313E = new(mem_ctx) ir_if(operand(r313F).val);
                        exec_list *const f313E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f313E->then_instructions;

                           body.emit(assign(r3126, body.constant(0u), 0x01));

                           ir_variable *const r3140 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3140, lshift(r3125, r3127), 0x01));

                           ir_variable *const r3141 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3143 = equal(r3127, body.constant(int(0)));
                           ir_if *f3142 = new(mem_ctx) ir_if(operand(r3143).val);
                           exec_list *const f3142_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3142->then_instructions;

                              body.emit(assign(r3141, r3124, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3142->else_instructions;

                              ir_expression *const r3144 = lshift(r3124, r3127);
                              ir_expression *const r3145 = neg(r3127);
                              ir_expression *const r3146 = bit_and(r3145, body.constant(int(31)));
                              ir_expression *const r3147 = rshift(r3125, r3146);
                              body.emit(assign(r3141, bit_or(r3144, r3147), 0x01));


                           body.instructions = f3142_parent_instructions;
                           body.emit(f3142);

                           /* END IF */

                           body.emit(assign(r3124, r3141, 0x01));

                           body.emit(assign(r3125, r3140, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f313E->else_instructions;

                           ir_variable *const r3148 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3148, body.constant(0u), 0x01));

                           ir_variable *const r3149 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3149, neg(r3127), 0x01));

                           ir_variable *const r314A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r314A);
                           ir_variable *const r314B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r314B);
                           ir_variable *const r314C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r314C);
                           ir_variable *const r314D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r314E = neg(r3149);
                           body.emit(assign(r314D, bit_and(r314E, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3150 = equal(r3149, body.constant(int(0)));
                           ir_if *f314F = new(mem_ctx) ir_if(operand(r3150).val);
                           exec_list *const f314F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f314F->then_instructions;

                              body.emit(assign(r314A, r3148, 0x01));

                              body.emit(assign(r314B, r3125, 0x01));

                              body.emit(assign(r314C, r3124, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f314F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3152 = less(r3149, body.constant(int(32)));
                              ir_if *f3151 = new(mem_ctx) ir_if(operand(r3152).val);
                              exec_list *const f3151_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3151->then_instructions;

                                 body.emit(assign(r314A, lshift(r3125, r314D), 0x01));

                                 ir_expression *const r3153 = lshift(r3124, r314D);
                                 ir_expression *const r3154 = rshift(r3125, r3149);
                                 body.emit(assign(r314B, bit_or(r3153, r3154), 0x01));

                                 body.emit(assign(r314C, rshift(r3124, r3149), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3151->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3156 = equal(r3149, body.constant(int(32)));
                                 ir_if *f3155 = new(mem_ctx) ir_if(operand(r3156).val);
                                 exec_list *const f3155_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3155->then_instructions;

                                    body.emit(assign(r314A, r3125, 0x01));

                                    body.emit(assign(r314B, r3124, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3155->else_instructions;

                                    body.emit(assign(r3148, bit_or(body.constant(0u), r3125), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3158 = less(r3149, body.constant(int(64)));
                                    ir_if *f3157 = new(mem_ctx) ir_if(operand(r3158).val);
                                    exec_list *const f3157_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3157->then_instructions;

                                       body.emit(assign(r314A, lshift(r3124, r314D), 0x01));

                                       ir_expression *const r3159 = bit_and(r3149, body.constant(int(31)));
                                       body.emit(assign(r314B, rshift(r3124, r3159), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3157->else_instructions;

                                       ir_variable *const r315A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r315C = equal(r3149, body.constant(int(64)));
                                       ir_if *f315B = new(mem_ctx) ir_if(operand(r315C).val);
                                       exec_list *const f315B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f315B->then_instructions;

                                          body.emit(assign(r315A, r3124, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f315B->else_instructions;

                                          ir_expression *const r315D = nequal(r3124, body.constant(0u));
                                          ir_expression *const r315E = expr(ir_unop_b2i, r315D);
                                          body.emit(assign(r315A, expr(ir_unop_i2u, r315E), 0x01));


                                       body.instructions = f315B_parent_instructions;
                                       body.emit(f315B);

                                       /* END IF */

                                       body.emit(assign(r314A, r315A, 0x01));

                                       body.emit(assign(r314B, body.constant(0u), 0x01));


                                    body.instructions = f3157_parent_instructions;
                                    body.emit(f3157);

                                    /* END IF */


                                 body.instructions = f3155_parent_instructions;
                                 body.emit(f3155);

                                 /* END IF */

                                 body.emit(assign(r314C, body.constant(0u), 0x01));


                              body.instructions = f3151_parent_instructions;
                              body.emit(f3151);

                              /* END IF */

                              ir_expression *const r315F = nequal(r3148, body.constant(0u));
                              ir_expression *const r3160 = expr(ir_unop_b2i, r315F);
                              ir_expression *const r3161 = expr(ir_unop_i2u, r3160);
                              body.emit(assign(r314A, bit_or(r314A, r3161), 0x01));


                           body.instructions = f314F_parent_instructions;
                           body.emit(f314F);

                           /* END IF */

                           body.emit(assign(r3124, r314C, 0x01));

                           body.emit(assign(r3125, r314B, 0x01));

                           body.emit(assign(r3126, r314A, 0x01));


                        body.instructions = f313E_parent_instructions;
                        body.emit(f313E);

                        /* END IF */

                        body.emit(assign(r3123, sub(r3123, r3127), 0x01));

                        ir_variable *const r3162 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3162, r3123, 0x01));

                        ir_variable *const r3163 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3163, r3124, 0x01));

                        ir_variable *const r3164 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3164, r3125, 0x01));

                        ir_variable *const r3165 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r3165, r3126, 0x01));

                        ir_variable *const r3166 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r3166, body.constant(true), 0x01));

                        ir_variable *const r3167 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r3168 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r3168);
                        ir_expression *const r3169 = expr(ir_unop_u2i, r3126);
                        body.emit(assign(r3168, less(r3169, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r316B = lequal(body.constant(int(2045)), r3123);
                        ir_if *f316A = new(mem_ctx) ir_if(operand(r316B).val);
                        exec_list *const f316A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f316A->then_instructions;

                           ir_variable *const r316C = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r316E = less(body.constant(int(2045)), r3123);
                           ir_if *f316D = new(mem_ctx) ir_if(operand(r316E).val);
                           exec_list *const f316D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f316D->then_instructions;

                              body.emit(assign(r316C, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f316D->else_instructions;

                              ir_variable *const r316F = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3171 = equal(r3123, body.constant(int(2045)));
                              ir_if *f3170 = new(mem_ctx) ir_if(operand(r3171).val);
                              exec_list *const f3170_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3170->then_instructions;

                                 ir_expression *const r3172 = equal(body.constant(2097151u), r3124);
                                 ir_expression *const r3173 = equal(body.constant(4294967295u), r3125);
                                 body.emit(assign(r316F, logic_and(r3172, r3173), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3170->else_instructions;

                                 body.emit(assign(r316F, body.constant(false), 0x01));


                              body.instructions = f3170_parent_instructions;
                              body.emit(f3170);

                              /* END IF */

                              body.emit(assign(r316C, logic_and(r316F, r3168), 0x01));


                           body.instructions = f316D_parent_instructions;
                           body.emit(f316D);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3174 = new(mem_ctx) ir_if(operand(r316C).val);
                           exec_list *const f3174_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3174->then_instructions;

                              ir_variable *const r3175 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3175);
                              ir_expression *const r3176 = lshift(r2E1C, body.constant(int(31)));
                              body.emit(assign(r3175, add(r3176, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r3175, body.constant(0u), 0x01));

                              body.emit(assign(r3167, r3175, 0x03));

                              body.emit(assign(r3166, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3174->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3178 = less(r3123, body.constant(int(0)));
                              ir_if *f3177 = new(mem_ctx) ir_if(operand(r3178).val);
                              exec_list *const f3177_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3177->then_instructions;

                                 ir_variable *const r3179 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r3179, r3126, 0x01));

                                 ir_variable *const r317A = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r317A, neg(r3123), 0x01));

                                 ir_variable *const r317B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r317B);
                                 ir_variable *const r317C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r317C);
                                 ir_variable *const r317D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r317D);
                                 ir_variable *const r317E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r317F = neg(r317A);
                                 body.emit(assign(r317E, bit_and(r317F, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3181 = equal(r317A, body.constant(int(0)));
                                 ir_if *f3180 = new(mem_ctx) ir_if(operand(r3181).val);
                                 exec_list *const f3180_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3180->then_instructions;

                                    body.emit(assign(r317B, r3126, 0x01));

                                    body.emit(assign(r317C, r3125, 0x01));

                                    body.emit(assign(r317D, r3124, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3180->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3183 = less(r317A, body.constant(int(32)));
                                    ir_if *f3182 = new(mem_ctx) ir_if(operand(r3183).val);
                                    exec_list *const f3182_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3182->then_instructions;

                                       body.emit(assign(r317B, lshift(r3125, r317E), 0x01));

                                       ir_expression *const r3184 = lshift(r3124, r317E);
                                       ir_expression *const r3185 = rshift(r3125, r317A);
                                       body.emit(assign(r317C, bit_or(r3184, r3185), 0x01));

                                       body.emit(assign(r317D, rshift(r3124, r317A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3182->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3187 = equal(r317A, body.constant(int(32)));
                                       ir_if *f3186 = new(mem_ctx) ir_if(operand(r3187).val);
                                       exec_list *const f3186_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3186->then_instructions;

                                          body.emit(assign(r317B, r3125, 0x01));

                                          body.emit(assign(r317C, r3124, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3186->else_instructions;

                                          body.emit(assign(r3179, bit_or(r3126, r3125), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r3189 = less(r317A, body.constant(int(64)));
                                          ir_if *f3188 = new(mem_ctx) ir_if(operand(r3189).val);
                                          exec_list *const f3188_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3188->then_instructions;

                                             body.emit(assign(r317B, lshift(r3124, r317E), 0x01));

                                             ir_expression *const r318A = bit_and(r317A, body.constant(int(31)));
                                             body.emit(assign(r317C, rshift(r3124, r318A), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3188->else_instructions;

                                             ir_variable *const r318B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r318D = equal(r317A, body.constant(int(64)));
                                             ir_if *f318C = new(mem_ctx) ir_if(operand(r318D).val);
                                             exec_list *const f318C_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f318C->then_instructions;

                                                body.emit(assign(r318B, r3124, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f318C->else_instructions;

                                                ir_expression *const r318E = nequal(r3124, body.constant(0u));
                                                ir_expression *const r318F = expr(ir_unop_b2i, r318E);
                                                body.emit(assign(r318B, expr(ir_unop_i2u, r318F), 0x01));


                                             body.instructions = f318C_parent_instructions;
                                             body.emit(f318C);

                                             /* END IF */

                                             body.emit(assign(r317B, r318B, 0x01));

                                             body.emit(assign(r317C, body.constant(0u), 0x01));


                                          body.instructions = f3188_parent_instructions;
                                          body.emit(f3188);

                                          /* END IF */


                                       body.instructions = f3186_parent_instructions;
                                       body.emit(f3186);

                                       /* END IF */

                                       body.emit(assign(r317D, body.constant(0u), 0x01));


                                    body.instructions = f3182_parent_instructions;
                                    body.emit(f3182);

                                    /* END IF */

                                    ir_expression *const r3190 = nequal(r3179, body.constant(0u));
                                    ir_expression *const r3191 = expr(ir_unop_b2i, r3190);
                                    ir_expression *const r3192 = expr(ir_unop_i2u, r3191);
                                    body.emit(assign(r317B, bit_or(r317B, r3192), 0x01));


                                 body.instructions = f3180_parent_instructions;
                                 body.emit(f3180);

                                 /* END IF */

                                 body.emit(assign(r3163, r317D, 0x01));

                                 body.emit(assign(r3164, r317C, 0x01));

                                 body.emit(assign(r3165, r317B, 0x01));

                                 body.emit(assign(r3162, body.constant(int(0)), 0x01));

                                 body.emit(assign(r3168, less(r317B, body.constant(0u)), 0x01));


                              body.instructions = f3177_parent_instructions;
                              body.emit(f3177);

                              /* END IF */


                           body.instructions = f3174_parent_instructions;
                           body.emit(f3174);

                           /* END IF */


                        body.instructions = f316A_parent_instructions;
                        body.emit(f316A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3193 = new(mem_ctx) ir_if(operand(r3166).val);
                        exec_list *const f3193_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3193->then_instructions;

                           /* IF CONDITION */
                           ir_if *f3194 = new(mem_ctx) ir_if(operand(r3168).val);
                           exec_list *const f3194_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3194->then_instructions;

                              ir_variable *const r3195 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r3195, add(r3164, body.constant(1u)), 0x01));

                              ir_expression *const r3196 = less(r3195, r3164);
                              ir_expression *const r3197 = expr(ir_unop_b2i, r3196);
                              ir_expression *const r3198 = expr(ir_unop_i2u, r3197);
                              body.emit(assign(r3163, add(r3163, r3198), 0x01));

                              ir_expression *const r3199 = equal(r3165, body.constant(0u));
                              ir_expression *const r319A = expr(ir_unop_b2i, r3199);
                              ir_expression *const r319B = expr(ir_unop_i2u, r319A);
                              ir_expression *const r319C = add(r3165, r319B);
                              ir_expression *const r319D = bit_and(r319C, body.constant(1u));
                              ir_expression *const r319E = expr(ir_unop_bit_not, r319D);
                              body.emit(assign(r3164, bit_and(r3195, r319E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3194->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r31A0 = bit_or(r3163, r3164);
                              ir_expression *const r31A1 = equal(r31A0, body.constant(0u));
                              ir_if *f319F = new(mem_ctx) ir_if(operand(r31A1).val);
                              exec_list *const f319F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f319F->then_instructions;

                                 body.emit(assign(r3162, body.constant(int(0)), 0x01));


                              body.instructions = f319F_parent_instructions;
                              body.emit(f319F);

                              /* END IF */


                           body.instructions = f3194_parent_instructions;
                           body.emit(f3194);

                           /* END IF */

                           ir_variable *const r31A2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r31A2);
                           ir_expression *const r31A3 = lshift(r2E1C, body.constant(int(31)));
                           ir_expression *const r31A4 = expr(ir_unop_i2u, r3162);
                           ir_expression *const r31A5 = lshift(r31A4, body.constant(int(20)));
                           ir_expression *const r31A6 = add(r31A3, r31A5);
                           body.emit(assign(r31A2, add(r31A6, r3163), 0x02));

                           body.emit(assign(r31A2, r3164, 0x01));

                           body.emit(assign(r3167, r31A2, 0x03));

                           body.emit(assign(r3166, body.constant(false), 0x01));


                        body.instructions = f3193_parent_instructions;
                        body.emit(f3193);

                        /* END IF */

                        body.emit(assign(r2E1D, r3167, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f311B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r31A8 = less(swizzle_x(r2E22), swizzle_x(r2E20));
                        ir_if *f31A7 = new(mem_ctx) ir_if(operand(r31A8).val);
                        exec_list *const f31A7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f31A7->then_instructions;

                           ir_variable *const r31A9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r31AA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r31AA, sub(swizzle_x(r2E20), swizzle_x(r2E22)), 0x01));

                           ir_expression *const r31AB = sub(swizzle_y(r2E20), swizzle_y(r2E22));
                           ir_expression *const r31AC = less(swizzle_x(r2E20), swizzle_x(r2E22));
                           ir_expression *const r31AD = expr(ir_unop_b2i, r31AC);
                           ir_expression *const r31AE = expr(ir_unop_i2u, r31AD);
                           body.emit(assign(r31A9, sub(r31AB, r31AE), 0x01));

                           body.emit(assign(r2E1C, bit_xor(r2E1C, body.constant(1u)), 0x01));

                           body.emit(assign(r2E23, add(r2E1F, body.constant(int(-1))), 0x01));

                           ir_variable *const r31AF = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r31AF, add(r2E23, body.constant(int(-10))), 0x01));

                           ir_variable *const r31B0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r31B0, r31A9, 0x01));

                           ir_variable *const r31B1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r31B1, r31AA, 0x01));

                           ir_variable *const r31B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r31B2);
                           ir_variable *const r31B3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r31B3);
                           /* IF CONDITION */
                           ir_expression *const r31B5 = equal(r31A9, body.constant(0u));
                           ir_if *f31B4 = new(mem_ctx) ir_if(operand(r31B5).val);
                           exec_list *const f31B4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f31B4->then_instructions;

                              body.emit(assign(r31B0, r31AA, 0x01));

                              body.emit(assign(r31B1, body.constant(0u), 0x01));

                              body.emit(assign(r31AF, add(r31AF, body.constant(int(-32))), 0x01));


                           body.instructions = f31B4_parent_instructions;
                           body.emit(f31B4);

                           /* END IF */

                           ir_variable *const r31B6 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r31B6, r31B0, 0x01));

                           ir_variable *const r31B7 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r31B8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r31B8);
                           /* IF CONDITION */
                           ir_expression *const r31BA = equal(r31B0, body.constant(0u));
                           ir_if *f31B9 = new(mem_ctx) ir_if(operand(r31BA).val);
                           exec_list *const f31B9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f31B9->then_instructions;

                              body.emit(assign(r31B7, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f31B9->else_instructions;

                              body.emit(assign(r31B8, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r31BC = bit_and(r31B0, body.constant(4294901760u));
                              ir_expression *const r31BD = equal(r31BC, body.constant(0u));
                              ir_if *f31BB = new(mem_ctx) ir_if(operand(r31BD).val);
                              exec_list *const f31BB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31BB->then_instructions;

                                 body.emit(assign(r31B8, body.constant(int(16)), 0x01));

                                 body.emit(assign(r31B6, lshift(r31B0, body.constant(int(16))), 0x01));


                              body.instructions = f31BB_parent_instructions;
                              body.emit(f31BB);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r31BF = bit_and(r31B6, body.constant(4278190080u));
                              ir_expression *const r31C0 = equal(r31BF, body.constant(0u));
                              ir_if *f31BE = new(mem_ctx) ir_if(operand(r31C0).val);
                              exec_list *const f31BE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31BE->then_instructions;

                                 body.emit(assign(r31B8, add(r31B8, body.constant(int(8))), 0x01));

                                 body.emit(assign(r31B6, lshift(r31B6, body.constant(int(8))), 0x01));


                              body.instructions = f31BE_parent_instructions;
                              body.emit(f31BE);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r31C2 = bit_and(r31B6, body.constant(4026531840u));
                              ir_expression *const r31C3 = equal(r31C2, body.constant(0u));
                              ir_if *f31C1 = new(mem_ctx) ir_if(operand(r31C3).val);
                              exec_list *const f31C1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31C1->then_instructions;

                                 body.emit(assign(r31B8, add(r31B8, body.constant(int(4))), 0x01));

                                 body.emit(assign(r31B6, lshift(r31B6, body.constant(int(4))), 0x01));


                              body.instructions = f31C1_parent_instructions;
                              body.emit(f31C1);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r31C5 = bit_and(r31B6, body.constant(3221225472u));
                              ir_expression *const r31C6 = equal(r31C5, body.constant(0u));
                              ir_if *f31C4 = new(mem_ctx) ir_if(operand(r31C6).val);
                              exec_list *const f31C4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31C4->then_instructions;

                                 body.emit(assign(r31B8, add(r31B8, body.constant(int(2))), 0x01));

                                 body.emit(assign(r31B6, lshift(r31B6, body.constant(int(2))), 0x01));


                              body.instructions = f31C4_parent_instructions;
                              body.emit(f31C4);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r31C8 = bit_and(r31B6, body.constant(2147483648u));
                              ir_expression *const r31C9 = equal(r31C8, body.constant(0u));
                              ir_if *f31C7 = new(mem_ctx) ir_if(operand(r31C9).val);
                              exec_list *const f31C7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31C7->then_instructions;

                                 body.emit(assign(r31B8, add(r31B8, body.constant(int(1))), 0x01));


                              body.instructions = f31C7_parent_instructions;
                              body.emit(f31C7);

                              /* END IF */

                              body.emit(assign(r31B7, r31B8, 0x01));


                           body.instructions = f31B9_parent_instructions;
                           body.emit(f31B9);

                           /* END IF */

                           body.emit(assign(r31B3, add(r31B7, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r31CB = lequal(body.constant(int(0)), r31B3);
                           ir_if *f31CA = new(mem_ctx) ir_if(operand(r31CB).val);
                           exec_list *const f31CA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f31CA->then_instructions;

                              body.emit(assign(r31B2, body.constant(0u), 0x01));

                              ir_variable *const r31CC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r31CC, lshift(r31B1, r31B3), 0x01));

                              ir_variable *const r31CD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r31CF = equal(r31B3, body.constant(int(0)));
                              ir_if *f31CE = new(mem_ctx) ir_if(operand(r31CF).val);
                              exec_list *const f31CE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31CE->then_instructions;

                                 body.emit(assign(r31CD, r31B0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f31CE->else_instructions;

                                 ir_expression *const r31D0 = lshift(r31B0, r31B3);
                                 ir_expression *const r31D1 = neg(r31B3);
                                 ir_expression *const r31D2 = bit_and(r31D1, body.constant(int(31)));
                                 ir_expression *const r31D3 = rshift(r31B1, r31D2);
                                 body.emit(assign(r31CD, bit_or(r31D0, r31D3), 0x01));


                              body.instructions = f31CE_parent_instructions;
                              body.emit(f31CE);

                              /* END IF */

                              body.emit(assign(r31B0, r31CD, 0x01));

                              body.emit(assign(r31B1, r31CC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f31CA->else_instructions;

                              ir_variable *const r31D4 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r31D4, body.constant(0u), 0x01));

                              ir_variable *const r31D5 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r31D5, neg(r31B3), 0x01));

                              ir_variable *const r31D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r31D6);
                              ir_variable *const r31D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r31D7);
                              ir_variable *const r31D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r31D8);
                              ir_variable *const r31D9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r31DA = neg(r31D5);
                              body.emit(assign(r31D9, bit_and(r31DA, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r31DC = equal(r31D5, body.constant(int(0)));
                              ir_if *f31DB = new(mem_ctx) ir_if(operand(r31DC).val);
                              exec_list *const f31DB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31DB->then_instructions;

                                 body.emit(assign(r31D6, r31D4, 0x01));

                                 body.emit(assign(r31D7, r31B1, 0x01));

                                 body.emit(assign(r31D8, r31B0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f31DB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r31DE = less(r31D5, body.constant(int(32)));
                                 ir_if *f31DD = new(mem_ctx) ir_if(operand(r31DE).val);
                                 exec_list *const f31DD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f31DD->then_instructions;

                                    body.emit(assign(r31D6, lshift(r31B1, r31D9), 0x01));

                                    ir_expression *const r31DF = lshift(r31B0, r31D9);
                                    ir_expression *const r31E0 = rshift(r31B1, r31D5);
                                    body.emit(assign(r31D7, bit_or(r31DF, r31E0), 0x01));

                                    body.emit(assign(r31D8, rshift(r31B0, r31D5), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f31DD->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r31E2 = equal(r31D5, body.constant(int(32)));
                                    ir_if *f31E1 = new(mem_ctx) ir_if(operand(r31E2).val);
                                    exec_list *const f31E1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f31E1->then_instructions;

                                       body.emit(assign(r31D6, r31B1, 0x01));

                                       body.emit(assign(r31D7, r31B0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f31E1->else_instructions;

                                       body.emit(assign(r31D4, bit_or(body.constant(0u), r31B1), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r31E4 = less(r31D5, body.constant(int(64)));
                                       ir_if *f31E3 = new(mem_ctx) ir_if(operand(r31E4).val);
                                       exec_list *const f31E3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f31E3->then_instructions;

                                          body.emit(assign(r31D6, lshift(r31B0, r31D9), 0x01));

                                          ir_expression *const r31E5 = bit_and(r31D5, body.constant(int(31)));
                                          body.emit(assign(r31D7, rshift(r31B0, r31E5), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f31E3->else_instructions;

                                          ir_variable *const r31E6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r31E8 = equal(r31D5, body.constant(int(64)));
                                          ir_if *f31E7 = new(mem_ctx) ir_if(operand(r31E8).val);
                                          exec_list *const f31E7_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f31E7->then_instructions;

                                             body.emit(assign(r31E6, r31B0, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f31E7->else_instructions;

                                             ir_expression *const r31E9 = nequal(r31B0, body.constant(0u));
                                             ir_expression *const r31EA = expr(ir_unop_b2i, r31E9);
                                             body.emit(assign(r31E6, expr(ir_unop_i2u, r31EA), 0x01));


                                          body.instructions = f31E7_parent_instructions;
                                          body.emit(f31E7);

                                          /* END IF */

                                          body.emit(assign(r31D6, r31E6, 0x01));

                                          body.emit(assign(r31D7, body.constant(0u), 0x01));


                                       body.instructions = f31E3_parent_instructions;
                                       body.emit(f31E3);

                                       /* END IF */


                                    body.instructions = f31E1_parent_instructions;
                                    body.emit(f31E1);

                                    /* END IF */

                                    body.emit(assign(r31D8, body.constant(0u), 0x01));


                                 body.instructions = f31DD_parent_instructions;
                                 body.emit(f31DD);

                                 /* END IF */

                                 ir_expression *const r31EB = nequal(r31D4, body.constant(0u));
                                 ir_expression *const r31EC = expr(ir_unop_b2i, r31EB);
                                 ir_expression *const r31ED = expr(ir_unop_i2u, r31EC);
                                 body.emit(assign(r31D6, bit_or(r31D6, r31ED), 0x01));


                              body.instructions = f31DB_parent_instructions;
                              body.emit(f31DB);

                              /* END IF */

                              body.emit(assign(r31B0, r31D8, 0x01));

                              body.emit(assign(r31B1, r31D7, 0x01));

                              body.emit(assign(r31B2, r31D6, 0x01));


                           body.instructions = f31CA_parent_instructions;
                           body.emit(f31CA);

                           /* END IF */

                           body.emit(assign(r31AF, sub(r31AF, r31B3), 0x01));

                           ir_variable *const r31EE = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r31EE, r31AF, 0x01));

                           ir_variable *const r31EF = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r31EF, r31B0, 0x01));

                           ir_variable *const r31F0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r31F0, r31B1, 0x01));

                           ir_variable *const r31F1 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r31F1, r31B2, 0x01));

                           ir_variable *const r31F2 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r31F2, body.constant(true), 0x01));

                           ir_variable *const r31F3 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r31F4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r31F4);
                           ir_expression *const r31F5 = expr(ir_unop_u2i, r31B2);
                           body.emit(assign(r31F4, less(r31F5, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r31F7 = lequal(body.constant(int(2045)), r31AF);
                           ir_if *f31F6 = new(mem_ctx) ir_if(operand(r31F7).val);
                           exec_list *const f31F6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f31F6->then_instructions;

                              ir_variable *const r31F8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r31FA = less(body.constant(int(2045)), r31AF);
                              ir_if *f31F9 = new(mem_ctx) ir_if(operand(r31FA).val);
                              exec_list *const f31F9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31F9->then_instructions;

                                 body.emit(assign(r31F8, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f31F9->else_instructions;

                                 ir_variable *const r31FB = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r31FD = equal(r31AF, body.constant(int(2045)));
                                 ir_if *f31FC = new(mem_ctx) ir_if(operand(r31FD).val);
                                 exec_list *const f31FC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f31FC->then_instructions;

                                    ir_expression *const r31FE = equal(body.constant(2097151u), r31B0);
                                    ir_expression *const r31FF = equal(body.constant(4294967295u), r31B1);
                                    body.emit(assign(r31FB, logic_and(r31FE, r31FF), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f31FC->else_instructions;

                                    body.emit(assign(r31FB, body.constant(false), 0x01));


                                 body.instructions = f31FC_parent_instructions;
                                 body.emit(f31FC);

                                 /* END IF */

                                 body.emit(assign(r31F8, logic_and(r31FB, r31F4), 0x01));


                              body.instructions = f31F9_parent_instructions;
                              body.emit(f31F9);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f3200 = new(mem_ctx) ir_if(operand(r31F8).val);
                              exec_list *const f3200_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3200->then_instructions;

                                 ir_variable *const r3201 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r3201);
                                 ir_expression *const r3202 = lshift(r2E1C, body.constant(int(31)));
                                 body.emit(assign(r3201, add(r3202, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r3201, body.constant(0u), 0x01));

                                 body.emit(assign(r31F3, r3201, 0x03));

                                 body.emit(assign(r31F2, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3200->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3204 = less(r31AF, body.constant(int(0)));
                                 ir_if *f3203 = new(mem_ctx) ir_if(operand(r3204).val);
                                 exec_list *const f3203_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3203->then_instructions;

                                    ir_variable *const r3205 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r3205, r31B2, 0x01));

                                    ir_variable *const r3206 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r3206, neg(r31AF), 0x01));

                                    ir_variable *const r3207 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r3207);
                                    ir_variable *const r3208 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r3208);
                                    ir_variable *const r3209 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r3209);
                                    ir_variable *const r320A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r320B = neg(r3206);
                                    body.emit(assign(r320A, bit_and(r320B, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r320D = equal(r3206, body.constant(int(0)));
                                    ir_if *f320C = new(mem_ctx) ir_if(operand(r320D).val);
                                    exec_list *const f320C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f320C->then_instructions;

                                       body.emit(assign(r3207, r31B2, 0x01));

                                       body.emit(assign(r3208, r31B1, 0x01));

                                       body.emit(assign(r3209, r31B0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f320C->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r320F = less(r3206, body.constant(int(32)));
                                       ir_if *f320E = new(mem_ctx) ir_if(operand(r320F).val);
                                       exec_list *const f320E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f320E->then_instructions;

                                          body.emit(assign(r3207, lshift(r31B1, r320A), 0x01));

                                          ir_expression *const r3210 = lshift(r31B0, r320A);
                                          ir_expression *const r3211 = rshift(r31B1, r3206);
                                          body.emit(assign(r3208, bit_or(r3210, r3211), 0x01));

                                          body.emit(assign(r3209, rshift(r31B0, r3206), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f320E->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r3213 = equal(r3206, body.constant(int(32)));
                                          ir_if *f3212 = new(mem_ctx) ir_if(operand(r3213).val);
                                          exec_list *const f3212_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3212->then_instructions;

                                             body.emit(assign(r3207, r31B1, 0x01));

                                             body.emit(assign(r3208, r31B0, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3212->else_instructions;

                                             body.emit(assign(r3205, bit_or(r31B2, r31B1), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r3215 = less(r3206, body.constant(int(64)));
                                             ir_if *f3214 = new(mem_ctx) ir_if(operand(r3215).val);
                                             exec_list *const f3214_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3214->then_instructions;

                                                body.emit(assign(r3207, lshift(r31B0, r320A), 0x01));

                                                ir_expression *const r3216 = bit_and(r3206, body.constant(int(31)));
                                                body.emit(assign(r3208, rshift(r31B0, r3216), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3214->else_instructions;

                                                ir_variable *const r3217 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r3219 = equal(r3206, body.constant(int(64)));
                                                ir_if *f3218 = new(mem_ctx) ir_if(operand(r3219).val);
                                                exec_list *const f3218_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3218->then_instructions;

                                                   body.emit(assign(r3217, r31B0, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3218->else_instructions;

                                                   ir_expression *const r321A = nequal(r31B0, body.constant(0u));
                                                   ir_expression *const r321B = expr(ir_unop_b2i, r321A);
                                                   body.emit(assign(r3217, expr(ir_unop_i2u, r321B), 0x01));


                                                body.instructions = f3218_parent_instructions;
                                                body.emit(f3218);

                                                /* END IF */

                                                body.emit(assign(r3207, r3217, 0x01));

                                                body.emit(assign(r3208, body.constant(0u), 0x01));


                                             body.instructions = f3214_parent_instructions;
                                             body.emit(f3214);

                                             /* END IF */


                                          body.instructions = f3212_parent_instructions;
                                          body.emit(f3212);

                                          /* END IF */

                                          body.emit(assign(r3209, body.constant(0u), 0x01));


                                       body.instructions = f320E_parent_instructions;
                                       body.emit(f320E);

                                       /* END IF */

                                       ir_expression *const r321C = nequal(r3205, body.constant(0u));
                                       ir_expression *const r321D = expr(ir_unop_b2i, r321C);
                                       ir_expression *const r321E = expr(ir_unop_i2u, r321D);
                                       body.emit(assign(r3207, bit_or(r3207, r321E), 0x01));


                                    body.instructions = f320C_parent_instructions;
                                    body.emit(f320C);

                                    /* END IF */

                                    body.emit(assign(r31EF, r3209, 0x01));

                                    body.emit(assign(r31F0, r3208, 0x01));

                                    body.emit(assign(r31F1, r3207, 0x01));

                                    body.emit(assign(r31EE, body.constant(int(0)), 0x01));

                                    body.emit(assign(r31F4, less(r3207, body.constant(0u)), 0x01));


                                 body.instructions = f3203_parent_instructions;
                                 body.emit(f3203);

                                 /* END IF */


                              body.instructions = f3200_parent_instructions;
                              body.emit(f3200);

                              /* END IF */


                           body.instructions = f31F6_parent_instructions;
                           body.emit(f31F6);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f321F = new(mem_ctx) ir_if(operand(r31F2).val);
                           exec_list *const f321F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f321F->then_instructions;

                              /* IF CONDITION */
                              ir_if *f3220 = new(mem_ctx) ir_if(operand(r31F4).val);
                              exec_list *const f3220_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3220->then_instructions;

                                 ir_variable *const r3221 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r3221, add(r31F0, body.constant(1u)), 0x01));

                                 ir_expression *const r3222 = less(r3221, r31F0);
                                 ir_expression *const r3223 = expr(ir_unop_b2i, r3222);
                                 ir_expression *const r3224 = expr(ir_unop_i2u, r3223);
                                 body.emit(assign(r31EF, add(r31EF, r3224), 0x01));

                                 ir_expression *const r3225 = equal(r31F1, body.constant(0u));
                                 ir_expression *const r3226 = expr(ir_unop_b2i, r3225);
                                 ir_expression *const r3227 = expr(ir_unop_i2u, r3226);
                                 ir_expression *const r3228 = add(r31F1, r3227);
                                 ir_expression *const r3229 = bit_and(r3228, body.constant(1u));
                                 ir_expression *const r322A = expr(ir_unop_bit_not, r3229);
                                 body.emit(assign(r31F0, bit_and(r3221, r322A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3220->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r322C = bit_or(r31EF, r31F0);
                                 ir_expression *const r322D = equal(r322C, body.constant(0u));
                                 ir_if *f322B = new(mem_ctx) ir_if(operand(r322D).val);
                                 exec_list *const f322B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f322B->then_instructions;

                                    body.emit(assign(r31EE, body.constant(int(0)), 0x01));


                                 body.instructions = f322B_parent_instructions;
                                 body.emit(f322B);

                                 /* END IF */


                              body.instructions = f3220_parent_instructions;
                              body.emit(f3220);

                              /* END IF */

                              ir_variable *const r322E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r322E);
                              ir_expression *const r322F = lshift(r2E1C, body.constant(int(31)));
                              ir_expression *const r3230 = expr(ir_unop_i2u, r31EE);
                              ir_expression *const r3231 = lshift(r3230, body.constant(int(20)));
                              ir_expression *const r3232 = add(r322F, r3231);
                              body.emit(assign(r322E, add(r3232, r31EF), 0x02));

                              body.emit(assign(r322E, r31F0, 0x01));

                              body.emit(assign(r31F3, r322E, 0x03));

                              body.emit(assign(r31F2, body.constant(false), 0x01));


                           body.instructions = f321F_parent_instructions;
                           body.emit(f321F);

                           /* END IF */

                           body.emit(assign(r2E1D, r31F3, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f31A7->else_instructions;

                           ir_variable *const r3233 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3233);
                           body.emit(assign(r3233, body.constant(0u), 0x02));

                           body.emit(assign(r3233, body.constant(0u), 0x01));

                           body.emit(assign(r2E1D, r3233, 0x03));


                        body.instructions = f31A7_parent_instructions;
                        body.emit(f31A7);

                        /* END IF */


                     body.instructions = f311B_parent_instructions;
                     body.emit(f311B);

                     /* END IF */


                  body.instructions = f308F_parent_instructions;
                  body.emit(f308F);

                  /* END IF */


               body.instructions = f3003_parent_instructions;
               body.emit(f3003);

               /* END IF */


            body.instructions = f2FDC_parent_instructions;
            body.emit(f2FDC);

            /* END IF */


         body.instructions = f2F06_parent_instructions;
         body.emit(f2F06);

         /* END IF */


      body.instructions = f2E34_parent_instructions;
      body.emit(f2E34);

      /* END IF */

      body.emit(assign(r2E17, r2E1D, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2E1A->else_instructions;

      ir_variable *const r3234 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r3234, body.constant(true), 0x01));

      ir_variable *const r3235 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3236 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r3236);
      ir_variable *const r3237 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r3237);
      ir_variable *const r3238 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r3238);
      ir_variable *const r3239 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r3239);
      ir_variable *const r323A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r323A);
      ir_variable *const r323B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r323B);
      body.emit(assign(r323B, body.constant(0u), 0x01));

      body.emit(assign(r323A, body.constant(0u), 0x01));

      ir_variable *const r323C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r323C);
      body.emit(assign(r323C, bit_and(swizzle_y(r28C7), body.constant(1048575u)), 0x02));

      body.emit(assign(r323C, swizzle_x(r28C7), 0x01));

      body.emit(assign(r3238, r323C, 0x03));

      ir_variable *const r323D = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r323E = rshift(swizzle_y(r28C7), body.constant(int(20)));
      ir_expression *const r323F = bit_and(r323E, body.constant(2047u));
      body.emit(assign(r323D, expr(ir_unop_u2i, r323F), 0x01));

      ir_variable *const r3240 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r3240);
      body.emit(assign(r3240, bit_and(swizzle_y(r28FB), body.constant(1048575u)), 0x02));

      body.emit(assign(r3240, swizzle_x(r28FB), 0x01));

      body.emit(assign(r3237, r3240, 0x03));

      ir_variable *const r3241 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3242 = rshift(swizzle_y(r28FB), body.constant(int(20)));
      ir_expression *const r3243 = bit_and(r3242, body.constant(2047u));
      body.emit(assign(r3241, expr(ir_unop_u2i, r3243), 0x01));

      ir_variable *const r3244 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r3244, sub(r323D, r3241), 0x01));

      body.emit(assign(r3236, r3244, 0x01));

      /* IF CONDITION */
      ir_expression *const r3246 = less(body.constant(int(0)), r3244);
      ir_if *f3245 = new(mem_ctx) ir_if(operand(r3246).val);
      exec_list *const f3245_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3245->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3248 = equal(r323D, body.constant(int(2047)));
         ir_if *f3247 = new(mem_ctx) ir_if(operand(r3248).val);
         exec_list *const f3247_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3247->then_instructions;

            /* IF CONDITION */
            ir_expression *const r324A = bit_or(swizzle_y(r323C), swizzle_x(r28C7));
            ir_expression *const r324B = nequal(r324A, body.constant(0u));
            ir_if *f3249 = new(mem_ctx) ir_if(operand(r324B).val);
            exec_list *const f3249_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3249->then_instructions;

               ir_variable *const r324C = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r324C, swizzle_x(r28C7), 0x01));

               ir_variable *const r324D = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r324D, swizzle_x(r28FB), 0x01));

               ir_variable *const r324E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r324F = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3250 = rshift(swizzle_y(r28C7), body.constant(int(19)));
               ir_expression *const r3251 = bit_and(r3250, body.constant(4095u));
               ir_expression *const r3252 = equal(r3251, body.constant(4094u));
               ir_expression *const r3253 = nequal(swizzle_x(r28C7), body.constant(0u));
               ir_expression *const r3254 = bit_and(swizzle_y(r28C7), body.constant(524287u));
               ir_expression *const r3255 = nequal(r3254, body.constant(0u));
               ir_expression *const r3256 = logic_or(r3253, r3255);
               body.emit(assign(r324F, logic_and(r3252, r3256), 0x01));

               ir_variable *const r3257 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r3258 = lshift(swizzle_y(r28FB), body.constant(int(1)));
               ir_expression *const r3259 = lequal(body.constant(4292870144u), r3258);
               ir_expression *const r325A = nequal(swizzle_x(r28FB), body.constant(0u));
               ir_expression *const r325B = bit_and(swizzle_y(r28FB), body.constant(1048575u));
               ir_expression *const r325C = nequal(r325B, body.constant(0u));
               ir_expression *const r325D = logic_or(r325A, r325C);
               body.emit(assign(r3257, logic_and(r3259, r325D), 0x01));

               body.emit(assign(r324C, bit_or(swizzle_y(r28C7), body.constant(524288u)), 0x02));

               body.emit(assign(r324D, bit_or(swizzle_y(r28FB), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r325F = lshift(swizzle_y(r28C7), body.constant(int(1)));
               ir_expression *const r3260 = lequal(body.constant(4292870144u), r325F);
               ir_expression *const r3261 = nequal(swizzle_x(r28C7), body.constant(0u));
               ir_expression *const r3262 = bit_and(swizzle_y(r28C7), body.constant(1048575u));
               ir_expression *const r3263 = nequal(r3262, body.constant(0u));
               ir_expression *const r3264 = logic_or(r3261, r3263);
               ir_expression *const r3265 = logic_and(r3260, r3264);
               ir_if *f325E = new(mem_ctx) ir_if(operand(r3265).val);
               exec_list *const f325E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f325E->then_instructions;

                  ir_variable *const r3266 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3268 = logic_and(r324F, r3257);
                  ir_if *f3267 = new(mem_ctx) ir_if(operand(r3268).val);
                  exec_list *const f3267_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3267->then_instructions;

                     body.emit(assign(r3266, r324D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3267->else_instructions;

                     body.emit(assign(r3266, r324C, 0x03));


                  body.instructions = f3267_parent_instructions;
                  body.emit(f3267);

                  /* END IF */

                  body.emit(assign(r324E, r3266, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f325E->else_instructions;

                  body.emit(assign(r324E, r324D, 0x03));


               body.instructions = f325E_parent_instructions;
               body.emit(f325E);

               /* END IF */

               body.emit(assign(r3235, r324E, 0x03));

               body.emit(assign(r3234, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3249->else_instructions;

               body.emit(assign(r3235, r28C7, 0x03));

               body.emit(assign(r3234, body.constant(false), 0x01));


            body.instructions = f3249_parent_instructions;
            body.emit(f3249);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3247->else_instructions;

            /* IF CONDITION */
            ir_expression *const r326A = equal(r3241, body.constant(int(0)));
            ir_if *f3269 = new(mem_ctx) ir_if(operand(r326A).val);
            exec_list *const f3269_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3269->then_instructions;

               body.emit(assign(r3236, add(r3244, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3269->else_instructions;

               body.emit(assign(r3237, bit_or(swizzle_y(r3240), body.constant(1048576u)), 0x02));


            body.instructions = f3269_parent_instructions;
            body.emit(f3269);

            /* END IF */

            ir_variable *const r326B = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r326B, swizzle_y(r3237), 0x01));

            ir_variable *const r326C = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r326C, swizzle_x(r3237), 0x01));

            ir_variable *const r326D = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r326D, body.constant(0u), 0x01));

            ir_variable *const r326E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r326E);
            ir_variable *const r326F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r326F);
            ir_variable *const r3270 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r3270);
            ir_variable *const r3271 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r3272 = neg(r3236);
            body.emit(assign(r3271, bit_and(r3272, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3274 = equal(r3236, body.constant(int(0)));
            ir_if *f3273 = new(mem_ctx) ir_if(operand(r3274).val);
            exec_list *const f3273_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3273->then_instructions;

               body.emit(assign(r326E, r326D, 0x01));

               body.emit(assign(r326F, r326C, 0x01));

               body.emit(assign(r3270, r326B, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3273->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3276 = less(r3236, body.constant(int(32)));
               ir_if *f3275 = new(mem_ctx) ir_if(operand(r3276).val);
               exec_list *const f3275_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3275->then_instructions;

                  body.emit(assign(r326E, lshift(swizzle_x(r3240), r3271), 0x01));

                  ir_expression *const r3277 = lshift(swizzle_y(r3237), r3271);
                  ir_expression *const r3278 = rshift(swizzle_x(r3240), r3236);
                  body.emit(assign(r326F, bit_or(r3277, r3278), 0x01));

                  body.emit(assign(r3270, rshift(swizzle_y(r3237), r3236), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3275->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r327A = equal(r3236, body.constant(int(32)));
                  ir_if *f3279 = new(mem_ctx) ir_if(operand(r327A).val);
                  exec_list *const f3279_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3279->then_instructions;

                     body.emit(assign(r326E, r326C, 0x01));

                     body.emit(assign(r326F, r326B, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3279->else_instructions;

                     body.emit(assign(r326D, bit_or(body.constant(0u), swizzle_x(r3240)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r327C = less(r3236, body.constant(int(64)));
                     ir_if *f327B = new(mem_ctx) ir_if(operand(r327C).val);
                     exec_list *const f327B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f327B->then_instructions;

                        body.emit(assign(r326E, lshift(swizzle_y(r3237), r3271), 0x01));

                        ir_expression *const r327D = bit_and(r3236, body.constant(int(31)));
                        body.emit(assign(r326F, rshift(swizzle_y(r3237), r327D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f327B->else_instructions;

                        ir_variable *const r327E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3280 = equal(r3236, body.constant(int(64)));
                        ir_if *f327F = new(mem_ctx) ir_if(operand(r3280).val);
                        exec_list *const f327F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f327F->then_instructions;

                           body.emit(assign(r327E, r326B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f327F->else_instructions;

                           ir_expression *const r3281 = nequal(swizzle_y(r3237), body.constant(0u));
                           ir_expression *const r3282 = expr(ir_unop_b2i, r3281);
                           body.emit(assign(r327E, expr(ir_unop_i2u, r3282), 0x01));


                        body.instructions = f327F_parent_instructions;
                        body.emit(f327F);

                        /* END IF */

                        body.emit(assign(r326E, r327E, 0x01));

                        body.emit(assign(r326F, body.constant(0u), 0x01));


                     body.instructions = f327B_parent_instructions;
                     body.emit(f327B);

                     /* END IF */


                  body.instructions = f3279_parent_instructions;
                  body.emit(f3279);

                  /* END IF */

                  body.emit(assign(r3270, body.constant(0u), 0x01));


               body.instructions = f3275_parent_instructions;
               body.emit(f3275);

               /* END IF */

               ir_expression *const r3283 = nequal(r326D, body.constant(0u));
               ir_expression *const r3284 = expr(ir_unop_b2i, r3283);
               ir_expression *const r3285 = expr(ir_unop_i2u, r3284);
               body.emit(assign(r326E, bit_or(r326E, r3285), 0x01));


            body.instructions = f3273_parent_instructions;
            body.emit(f3273);

            /* END IF */

            body.emit(assign(r3237, r3270, 0x02));

            body.emit(assign(r3237, r326F, 0x01));

            body.emit(assign(r323A, r326E, 0x01));

            body.emit(assign(r3239, r323D, 0x01));


         body.instructions = f3247_parent_instructions;
         body.emit(f3247);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3245->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3287 = less(r3236, body.constant(int(0)));
         ir_if *f3286 = new(mem_ctx) ir_if(operand(r3287).val);
         exec_list *const f3286_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3286->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3289 = equal(r3241, body.constant(int(2047)));
            ir_if *f3288 = new(mem_ctx) ir_if(operand(r3289).val);
            exec_list *const f3288_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3288->then_instructions;

               /* IF CONDITION */
               ir_expression *const r328B = bit_or(swizzle_y(r3237), swizzle_x(r3237));
               ir_expression *const r328C = nequal(r328B, body.constant(0u));
               ir_if *f328A = new(mem_ctx) ir_if(operand(r328C).val);
               exec_list *const f328A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f328A->then_instructions;

                  ir_variable *const r328D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r328D, swizzle_x(r28C7), 0x01));

                  ir_variable *const r328E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r328E, swizzle_x(r28FB), 0x01));

                  ir_variable *const r328F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3290 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r3291 = rshift(swizzle_y(r28C7), body.constant(int(19)));
                  ir_expression *const r3292 = bit_and(r3291, body.constant(4095u));
                  ir_expression *const r3293 = equal(r3292, body.constant(4094u));
                  ir_expression *const r3294 = nequal(swizzle_x(r28C7), body.constant(0u));
                  ir_expression *const r3295 = bit_and(swizzle_y(r28C7), body.constant(524287u));
                  ir_expression *const r3296 = nequal(r3295, body.constant(0u));
                  ir_expression *const r3297 = logic_or(r3294, r3296);
                  body.emit(assign(r3290, logic_and(r3293, r3297), 0x01));

                  ir_variable *const r3298 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r3299 = lshift(swizzle_y(r28FB), body.constant(int(1)));
                  ir_expression *const r329A = lequal(body.constant(4292870144u), r3299);
                  ir_expression *const r329B = nequal(swizzle_x(r28FB), body.constant(0u));
                  ir_expression *const r329C = bit_and(swizzle_y(r28FB), body.constant(1048575u));
                  ir_expression *const r329D = nequal(r329C, body.constant(0u));
                  ir_expression *const r329E = logic_or(r329B, r329D);
                  body.emit(assign(r3298, logic_and(r329A, r329E), 0x01));

                  body.emit(assign(r328D, bit_or(swizzle_y(r28C7), body.constant(524288u)), 0x02));

                  body.emit(assign(r328E, bit_or(swizzle_y(r28FB), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r32A0 = lshift(swizzle_y(r28C7), body.constant(int(1)));
                  ir_expression *const r32A1 = lequal(body.constant(4292870144u), r32A0);
                  ir_expression *const r32A2 = nequal(swizzle_x(r28C7), body.constant(0u));
                  ir_expression *const r32A3 = bit_and(swizzle_y(r28C7), body.constant(1048575u));
                  ir_expression *const r32A4 = nequal(r32A3, body.constant(0u));
                  ir_expression *const r32A5 = logic_or(r32A2, r32A4);
                  ir_expression *const r32A6 = logic_and(r32A1, r32A5);
                  ir_if *f329F = new(mem_ctx) ir_if(operand(r32A6).val);
                  exec_list *const f329F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f329F->then_instructions;

                     ir_variable *const r32A7 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r32A9 = logic_and(r3290, r3298);
                     ir_if *f32A8 = new(mem_ctx) ir_if(operand(r32A9).val);
                     exec_list *const f32A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32A8->then_instructions;

                        body.emit(assign(r32A7, r328E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f32A8->else_instructions;

                        body.emit(assign(r32A7, r328D, 0x03));


                     body.instructions = f32A8_parent_instructions;
                     body.emit(f32A8);

                     /* END IF */

                     body.emit(assign(r328F, r32A7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f329F->else_instructions;

                     body.emit(assign(r328F, r328E, 0x03));


                  body.instructions = f329F_parent_instructions;
                  body.emit(f329F);

                  /* END IF */

                  body.emit(assign(r3235, r328F, 0x03));

                  body.emit(assign(r3234, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f328A->else_instructions;

                  ir_variable *const r32AA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r32AA);
                  ir_expression *const r32AB = lshift(r2E18, body.constant(int(31)));
                  body.emit(assign(r32AA, add(r32AB, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r32AA, body.constant(0u), 0x01));

                  body.emit(assign(r3235, r32AA, 0x03));

                  body.emit(assign(r3234, body.constant(false), 0x01));


               body.instructions = f328A_parent_instructions;
               body.emit(f328A);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3288->else_instructions;

               /* IF CONDITION */
               ir_expression *const r32AD = equal(r323D, body.constant(int(0)));
               ir_if *f32AC = new(mem_ctx) ir_if(operand(r32AD).val);
               exec_list *const f32AC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32AC->then_instructions;

                  body.emit(assign(r3236, add(r3236, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32AC->else_instructions;

                  body.emit(assign(r3238, bit_or(swizzle_y(r323C), body.constant(1048576u)), 0x02));


               body.instructions = f32AC_parent_instructions;
               body.emit(f32AC);

               /* END IF */

               ir_variable *const r32AE = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r32AE, swizzle_y(r3238), 0x01));

               ir_variable *const r32AF = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r32AF, swizzle_x(r3238), 0x01));

               ir_variable *const r32B0 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r32B0, body.constant(0u), 0x01));

               ir_variable *const r32B1 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r32B1, neg(r3236), 0x01));

               ir_variable *const r32B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r32B2);
               ir_variable *const r32B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r32B3);
               ir_variable *const r32B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r32B4);
               ir_variable *const r32B5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r32B6 = neg(r32B1);
               body.emit(assign(r32B5, bit_and(r32B6, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r32B8 = equal(r32B1, body.constant(int(0)));
               ir_if *f32B7 = new(mem_ctx) ir_if(operand(r32B8).val);
               exec_list *const f32B7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32B7->then_instructions;

                  body.emit(assign(r32B2, r32B0, 0x01));

                  body.emit(assign(r32B3, r32AF, 0x01));

                  body.emit(assign(r32B4, r32AE, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32B7->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r32BA = less(r32B1, body.constant(int(32)));
                  ir_if *f32B9 = new(mem_ctx) ir_if(operand(r32BA).val);
                  exec_list *const f32B9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32B9->then_instructions;

                     body.emit(assign(r32B2, lshift(swizzle_x(r323C), r32B5), 0x01));

                     ir_expression *const r32BB = lshift(swizzle_y(r3238), r32B5);
                     ir_expression *const r32BC = rshift(swizzle_x(r323C), r32B1);
                     body.emit(assign(r32B3, bit_or(r32BB, r32BC), 0x01));

                     body.emit(assign(r32B4, rshift(swizzle_y(r3238), r32B1), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32B9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r32BE = equal(r32B1, body.constant(int(32)));
                     ir_if *f32BD = new(mem_ctx) ir_if(operand(r32BE).val);
                     exec_list *const f32BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32BD->then_instructions;

                        body.emit(assign(r32B2, r32AF, 0x01));

                        body.emit(assign(r32B3, r32AE, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f32BD->else_instructions;

                        body.emit(assign(r32B0, bit_or(body.constant(0u), swizzle_x(r323C)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r32C0 = less(r32B1, body.constant(int(64)));
                        ir_if *f32BF = new(mem_ctx) ir_if(operand(r32C0).val);
                        exec_list *const f32BF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f32BF->then_instructions;

                           body.emit(assign(r32B2, lshift(swizzle_y(r3238), r32B5), 0x01));

                           ir_expression *const r32C1 = bit_and(r32B1, body.constant(int(31)));
                           body.emit(assign(r32B3, rshift(swizzle_y(r3238), r32C1), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f32BF->else_instructions;

                           ir_variable *const r32C2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r32C4 = equal(r32B1, body.constant(int(64)));
                           ir_if *f32C3 = new(mem_ctx) ir_if(operand(r32C4).val);
                           exec_list *const f32C3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f32C3->then_instructions;

                              body.emit(assign(r32C2, r32AE, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f32C3->else_instructions;

                              ir_expression *const r32C5 = nequal(swizzle_y(r3238), body.constant(0u));
                              ir_expression *const r32C6 = expr(ir_unop_b2i, r32C5);
                              body.emit(assign(r32C2, expr(ir_unop_i2u, r32C6), 0x01));


                           body.instructions = f32C3_parent_instructions;
                           body.emit(f32C3);

                           /* END IF */

                           body.emit(assign(r32B2, r32C2, 0x01));

                           body.emit(assign(r32B3, body.constant(0u), 0x01));


                        body.instructions = f32BF_parent_instructions;
                        body.emit(f32BF);

                        /* END IF */


                     body.instructions = f32BD_parent_instructions;
                     body.emit(f32BD);

                     /* END IF */

                     body.emit(assign(r32B4, body.constant(0u), 0x01));


                  body.instructions = f32B9_parent_instructions;
                  body.emit(f32B9);

                  /* END IF */

                  ir_expression *const r32C7 = nequal(r32B0, body.constant(0u));
                  ir_expression *const r32C8 = expr(ir_unop_b2i, r32C7);
                  ir_expression *const r32C9 = expr(ir_unop_i2u, r32C8);
                  body.emit(assign(r32B2, bit_or(r32B2, r32C9), 0x01));


               body.instructions = f32B7_parent_instructions;
               body.emit(f32B7);

               /* END IF */

               body.emit(assign(r3238, r32B4, 0x02));

               body.emit(assign(r3238, r32B3, 0x01));

               body.emit(assign(r323A, r32B2, 0x01));

               body.emit(assign(r3239, r3241, 0x01));


            body.instructions = f3288_parent_instructions;
            body.emit(f3288);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3286->else_instructions;

            /* IF CONDITION */
            ir_expression *const r32CB = equal(r323D, body.constant(int(2047)));
            ir_if *f32CA = new(mem_ctx) ir_if(operand(r32CB).val);
            exec_list *const f32CA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f32CA->then_instructions;

               /* IF CONDITION */
               ir_expression *const r32CD = bit_or(swizzle_y(r3238), swizzle_x(r3238));
               ir_expression *const r32CE = bit_or(swizzle_y(r3237), swizzle_x(r3237));
               ir_expression *const r32CF = bit_or(r32CD, r32CE);
               ir_expression *const r32D0 = nequal(r32CF, body.constant(0u));
               ir_if *f32CC = new(mem_ctx) ir_if(operand(r32D0).val);
               exec_list *const f32CC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32CC->then_instructions;

                  ir_variable *const r32D1 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r32D1, swizzle_x(r28C7), 0x01));

                  ir_variable *const r32D2 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r32D2, swizzle_x(r28FB), 0x01));

                  ir_variable *const r32D3 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r32D4 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r32D5 = rshift(swizzle_y(r28C7), body.constant(int(19)));
                  ir_expression *const r32D6 = bit_and(r32D5, body.constant(4095u));
                  ir_expression *const r32D7 = equal(r32D6, body.constant(4094u));
                  ir_expression *const r32D8 = nequal(swizzle_x(r28C7), body.constant(0u));
                  ir_expression *const r32D9 = bit_and(swizzle_y(r28C7), body.constant(524287u));
                  ir_expression *const r32DA = nequal(r32D9, body.constant(0u));
                  ir_expression *const r32DB = logic_or(r32D8, r32DA);
                  body.emit(assign(r32D4, logic_and(r32D7, r32DB), 0x01));

                  ir_variable *const r32DC = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r32DD = lshift(swizzle_y(r28FB), body.constant(int(1)));
                  ir_expression *const r32DE = lequal(body.constant(4292870144u), r32DD);
                  ir_expression *const r32DF = nequal(swizzle_x(r28FB), body.constant(0u));
                  ir_expression *const r32E0 = bit_and(swizzle_y(r28FB), body.constant(1048575u));
                  ir_expression *const r32E1 = nequal(r32E0, body.constant(0u));
                  ir_expression *const r32E2 = logic_or(r32DF, r32E1);
                  body.emit(assign(r32DC, logic_and(r32DE, r32E2), 0x01));

                  body.emit(assign(r32D1, bit_or(swizzle_y(r28C7), body.constant(524288u)), 0x02));

                  body.emit(assign(r32D2, bit_or(swizzle_y(r28FB), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r32E4 = lshift(swizzle_y(r28C7), body.constant(int(1)));
                  ir_expression *const r32E5 = lequal(body.constant(4292870144u), r32E4);
                  ir_expression *const r32E6 = nequal(swizzle_x(r28C7), body.constant(0u));
                  ir_expression *const r32E7 = bit_and(swizzle_y(r28C7), body.constant(1048575u));
                  ir_expression *const r32E8 = nequal(r32E7, body.constant(0u));
                  ir_expression *const r32E9 = logic_or(r32E6, r32E8);
                  ir_expression *const r32EA = logic_and(r32E5, r32E9);
                  ir_if *f32E3 = new(mem_ctx) ir_if(operand(r32EA).val);
                  exec_list *const f32E3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32E3->then_instructions;

                     ir_variable *const r32EB = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r32ED = logic_and(r32D4, r32DC);
                     ir_if *f32EC = new(mem_ctx) ir_if(operand(r32ED).val);
                     exec_list *const f32EC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32EC->then_instructions;

                        body.emit(assign(r32EB, r32D2, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f32EC->else_instructions;

                        body.emit(assign(r32EB, r32D1, 0x03));


                     body.instructions = f32EC_parent_instructions;
                     body.emit(f32EC);

                     /* END IF */

                     body.emit(assign(r32D3, r32EB, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32E3->else_instructions;

                     body.emit(assign(r32D3, r32D2, 0x03));


                  body.instructions = f32E3_parent_instructions;
                  body.emit(f32E3);

                  /* END IF */

                  body.emit(assign(r3235, r32D3, 0x03));

                  body.emit(assign(r3234, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32CC->else_instructions;

                  body.emit(assign(r3235, r28C7, 0x03));

                  body.emit(assign(r3234, body.constant(false), 0x01));


               body.instructions = f32CC_parent_instructions;
               body.emit(f32CC);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f32CA->else_instructions;

               ir_variable *const r32EE = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r32EF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r32EF, add(swizzle_x(r3238), swizzle_x(r3237)), 0x01));

               ir_expression *const r32F0 = add(swizzle_y(r3238), swizzle_y(r3237));
               ir_expression *const r32F1 = less(r32EF, swizzle_x(r3238));
               ir_expression *const r32F2 = expr(ir_unop_b2i, r32F1);
               ir_expression *const r32F3 = expr(ir_unop_i2u, r32F2);
               body.emit(assign(r32EE, add(r32F0, r32F3), 0x01));

               body.emit(assign(r323B, r32EE, 0x01));

               /* IF CONDITION */
               ir_expression *const r32F5 = equal(r323D, body.constant(int(0)));
               ir_if *f32F4 = new(mem_ctx) ir_if(operand(r32F5).val);
               exec_list *const f32F4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32F4->then_instructions;

                  ir_variable *const r32F6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r32F6);
                  ir_expression *const r32F7 = lshift(r2E18, body.constant(int(31)));
                  body.emit(assign(r32F6, add(r32F7, r32EE), 0x02));

                  body.emit(assign(r32F6, r32EF, 0x01));

                  body.emit(assign(r3235, r32F6, 0x03));

                  body.emit(assign(r3234, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32F4->else_instructions;

                  body.emit(assign(r323B, bit_or(r32EE, body.constant(2097152u)), 0x01));

                  body.emit(assign(r3239, r323D, 0x01));

                  ir_variable *const r32F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r32F8);
                  ir_variable *const r32F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r32F9);
                  ir_variable *const r32FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r32FA);
                  body.emit(assign(r32F8, lshift(r32EF, body.constant(int(31))), 0x01));

                  ir_expression *const r32FB = lshift(r323B, body.constant(int(31)));
                  ir_expression *const r32FC = rshift(r32EF, body.constant(int(1)));
                  body.emit(assign(r32F9, bit_or(r32FB, r32FC), 0x01));

                  body.emit(assign(r32FA, rshift(r323B, body.constant(int(1))), 0x01));

                  body.emit(assign(r32F8, bit_or(r32F8, body.constant(0u)), 0x01));

                  body.emit(assign(r323B, r32FA, 0x01));

                  body.emit(assign(r323A, r32F8, 0x01));

                  ir_variable *const r32FD = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r32FD, r323D, 0x01));

                  ir_variable *const r32FE = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r32FE, r32FA, 0x01));

                  ir_variable *const r32FF = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r32FF, r32F9, 0x01));

                  ir_variable *const r3300 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r3300, r32F8, 0x01));

                  ir_variable *const r3301 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r3301, body.constant(true), 0x01));

                  ir_variable *const r3302 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3303 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r3303);
                  ir_expression *const r3304 = expr(ir_unop_u2i, r32F8);
                  body.emit(assign(r3303, less(r3304, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3306 = lequal(body.constant(int(2045)), r323D);
                  ir_if *f3305 = new(mem_ctx) ir_if(operand(r3306).val);
                  exec_list *const f3305_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3305->then_instructions;

                     ir_variable *const r3307 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3309 = less(body.constant(int(2045)), r323D);
                     ir_if *f3308 = new(mem_ctx) ir_if(operand(r3309).val);
                     exec_list *const f3308_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3308->then_instructions;

                        body.emit(assign(r3307, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3308->else_instructions;

                        ir_variable *const r330A = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r330C = equal(r323D, body.constant(int(2045)));
                        ir_if *f330B = new(mem_ctx) ir_if(operand(r330C).val);
                        exec_list *const f330B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f330B->then_instructions;

                           ir_expression *const r330D = equal(body.constant(2097151u), r32FA);
                           ir_expression *const r330E = equal(body.constant(4294967295u), r32F9);
                           body.emit(assign(r330A, logic_and(r330D, r330E), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f330B->else_instructions;

                           body.emit(assign(r330A, body.constant(false), 0x01));


                        body.instructions = f330B_parent_instructions;
                        body.emit(f330B);

                        /* END IF */

                        body.emit(assign(r3307, logic_and(r330A, r3303), 0x01));


                     body.instructions = f3308_parent_instructions;
                     body.emit(f3308);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f330F = new(mem_ctx) ir_if(operand(r3307).val);
                     exec_list *const f330F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f330F->then_instructions;

                        ir_variable *const r3310 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3310);
                        ir_expression *const r3311 = lshift(r2E18, body.constant(int(31)));
                        body.emit(assign(r3310, add(r3311, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r3310, body.constant(0u), 0x01));

                        body.emit(assign(r3302, r3310, 0x03));

                        body.emit(assign(r3301, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f330F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3313 = less(r323D, body.constant(int(0)));
                        ir_if *f3312 = new(mem_ctx) ir_if(operand(r3313).val);
                        exec_list *const f3312_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3312->then_instructions;

                           ir_variable *const r3314 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3314, r32F8, 0x01));

                           ir_variable *const r3315 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3315, neg(r323D), 0x01));

                           ir_variable *const r3316 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3316);
                           ir_variable *const r3317 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3317);
                           ir_variable *const r3318 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3318);
                           ir_variable *const r3319 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r331A = neg(r3315);
                           body.emit(assign(r3319, bit_and(r331A, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r331C = equal(r3315, body.constant(int(0)));
                           ir_if *f331B = new(mem_ctx) ir_if(operand(r331C).val);
                           exec_list *const f331B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f331B->then_instructions;

                              body.emit(assign(r3316, r32F8, 0x01));

                              body.emit(assign(r3317, r32F9, 0x01));

                              body.emit(assign(r3318, r32FA, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f331B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r331E = less(r3315, body.constant(int(32)));
                              ir_if *f331D = new(mem_ctx) ir_if(operand(r331E).val);
                              exec_list *const f331D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f331D->then_instructions;

                                 body.emit(assign(r3316, lshift(r32F9, r3319), 0x01));

                                 ir_expression *const r331F = lshift(r32FA, r3319);
                                 ir_expression *const r3320 = rshift(r32F9, r3315);
                                 body.emit(assign(r3317, bit_or(r331F, r3320), 0x01));

                                 body.emit(assign(r3318, rshift(r32FA, r3315), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f331D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3322 = equal(r3315, body.constant(int(32)));
                                 ir_if *f3321 = new(mem_ctx) ir_if(operand(r3322).val);
                                 exec_list *const f3321_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3321->then_instructions;

                                    body.emit(assign(r3316, r32F9, 0x01));

                                    body.emit(assign(r3317, r32FA, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3321->else_instructions;

                                    body.emit(assign(r3314, bit_or(r32F8, r32F9), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3324 = less(r3315, body.constant(int(64)));
                                    ir_if *f3323 = new(mem_ctx) ir_if(operand(r3324).val);
                                    exec_list *const f3323_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3323->then_instructions;

                                       body.emit(assign(r3316, lshift(r32FA, r3319), 0x01));

                                       ir_expression *const r3325 = bit_and(r3315, body.constant(int(31)));
                                       body.emit(assign(r3317, rshift(r32FA, r3325), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3323->else_instructions;

                                       ir_variable *const r3326 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3328 = equal(r3315, body.constant(int(64)));
                                       ir_if *f3327 = new(mem_ctx) ir_if(operand(r3328).val);
                                       exec_list *const f3327_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3327->then_instructions;

                                          body.emit(assign(r3326, r32FA, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3327->else_instructions;

                                          ir_expression *const r3329 = nequal(r32FA, body.constant(0u));
                                          ir_expression *const r332A = expr(ir_unop_b2i, r3329);
                                          body.emit(assign(r3326, expr(ir_unop_i2u, r332A), 0x01));


                                       body.instructions = f3327_parent_instructions;
                                       body.emit(f3327);

                                       /* END IF */

                                       body.emit(assign(r3316, r3326, 0x01));

                                       body.emit(assign(r3317, body.constant(0u), 0x01));


                                    body.instructions = f3323_parent_instructions;
                                    body.emit(f3323);

                                    /* END IF */


                                 body.instructions = f3321_parent_instructions;
                                 body.emit(f3321);

                                 /* END IF */

                                 body.emit(assign(r3318, body.constant(0u), 0x01));


                              body.instructions = f331D_parent_instructions;
                              body.emit(f331D);

                              /* END IF */

                              ir_expression *const r332B = nequal(r3314, body.constant(0u));
                              ir_expression *const r332C = expr(ir_unop_b2i, r332B);
                              ir_expression *const r332D = expr(ir_unop_i2u, r332C);
                              body.emit(assign(r3316, bit_or(r3316, r332D), 0x01));


                           body.instructions = f331B_parent_instructions;
                           body.emit(f331B);

                           /* END IF */

                           body.emit(assign(r32FE, r3318, 0x01));

                           body.emit(assign(r32FF, r3317, 0x01));

                           body.emit(assign(r3300, r3316, 0x01));

                           body.emit(assign(r32FD, body.constant(int(0)), 0x01));

                           body.emit(assign(r3303, less(r3316, body.constant(0u)), 0x01));


                        body.instructions = f3312_parent_instructions;
                        body.emit(f3312);

                        /* END IF */


                     body.instructions = f330F_parent_instructions;
                     body.emit(f330F);

                     /* END IF */


                  body.instructions = f3305_parent_instructions;
                  body.emit(f3305);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f332E = new(mem_ctx) ir_if(operand(r3301).val);
                  exec_list *const f332E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f332E->then_instructions;

                     /* IF CONDITION */
                     ir_if *f332F = new(mem_ctx) ir_if(operand(r3303).val);
                     exec_list *const f332F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f332F->then_instructions;

                        ir_variable *const r3330 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r3330, add(r32FF, body.constant(1u)), 0x01));

                        ir_expression *const r3331 = less(r3330, r32FF);
                        ir_expression *const r3332 = expr(ir_unop_b2i, r3331);
                        ir_expression *const r3333 = expr(ir_unop_i2u, r3332);
                        body.emit(assign(r32FE, add(r32FE, r3333), 0x01));

                        ir_expression *const r3334 = equal(r3300, body.constant(0u));
                        ir_expression *const r3335 = expr(ir_unop_b2i, r3334);
                        ir_expression *const r3336 = expr(ir_unop_i2u, r3335);
                        ir_expression *const r3337 = add(r3300, r3336);
                        ir_expression *const r3338 = bit_and(r3337, body.constant(1u));
                        ir_expression *const r3339 = expr(ir_unop_bit_not, r3338);
                        body.emit(assign(r32FF, bit_and(r3330, r3339), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f332F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r333B = bit_or(r32FE, r32FF);
                        ir_expression *const r333C = equal(r333B, body.constant(0u));
                        ir_if *f333A = new(mem_ctx) ir_if(operand(r333C).val);
                        exec_list *const f333A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f333A->then_instructions;

                           body.emit(assign(r32FD, body.constant(int(0)), 0x01));


                        body.instructions = f333A_parent_instructions;
                        body.emit(f333A);

                        /* END IF */


                     body.instructions = f332F_parent_instructions;
                     body.emit(f332F);

                     /* END IF */

                     ir_variable *const r333D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r333D);
                     ir_expression *const r333E = lshift(r2E18, body.constant(int(31)));
                     ir_expression *const r333F = expr(ir_unop_i2u, r32FD);
                     ir_expression *const r3340 = lshift(r333F, body.constant(int(20)));
                     ir_expression *const r3341 = add(r333E, r3340);
                     body.emit(assign(r333D, add(r3341, r32FE), 0x02));

                     body.emit(assign(r333D, r32FF, 0x01));

                     body.emit(assign(r3302, r333D, 0x03));

                     body.emit(assign(r3301, body.constant(false), 0x01));


                  body.instructions = f332E_parent_instructions;
                  body.emit(f332E);

                  /* END IF */

                  body.emit(assign(r3235, r3302, 0x03));

                  body.emit(assign(r3234, body.constant(false), 0x01));


               body.instructions = f32F4_parent_instructions;
               body.emit(f32F4);

               /* END IF */


            body.instructions = f32CA_parent_instructions;
            body.emit(f32CA);

            /* END IF */


         body.instructions = f3286_parent_instructions;
         body.emit(f3286);

         /* END IF */


      body.instructions = f3245_parent_instructions;
      body.emit(f3245);

      /* END IF */

      /* IF CONDITION */
      ir_if *f3342 = new(mem_ctx) ir_if(operand(r3234).val);
      exec_list *const f3342_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3342->then_instructions;

         body.emit(assign(r3238, bit_or(swizzle_y(r3238), body.constant(1048576u)), 0x02));

         ir_variable *const r3343 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r3344 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r3344, add(swizzle_x(r3238), swizzle_x(r3237)), 0x01));

         ir_expression *const r3345 = add(swizzle_y(r3238), swizzle_y(r3237));
         ir_expression *const r3346 = less(r3344, swizzle_x(r3238));
         ir_expression *const r3347 = expr(ir_unop_b2i, r3346);
         ir_expression *const r3348 = expr(ir_unop_i2u, r3347);
         body.emit(assign(r3343, add(r3345, r3348), 0x01));

         body.emit(assign(r323B, r3343, 0x01));

         body.emit(assign(r3239, add(r3239, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r334A = less(r3343, body.constant(2097152u));
         ir_if *f3349 = new(mem_ctx) ir_if(operand(r334A).val);
         exec_list *const f3349_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3349->then_instructions;

            ir_variable *const r334B = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r334B, r3239, 0x01));

            ir_variable *const r334C = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r334C, r3343, 0x01));

            ir_variable *const r334D = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r334D, r3344, 0x01));

            ir_variable *const r334E = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r334E, r323A, 0x01));

            ir_variable *const r334F = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r334F, body.constant(true), 0x01));

            ir_variable *const r3350 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3351 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r3351);
            ir_expression *const r3352 = expr(ir_unop_u2i, r323A);
            body.emit(assign(r3351, less(r3352, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3354 = lequal(body.constant(int(2045)), r3239);
            ir_if *f3353 = new(mem_ctx) ir_if(operand(r3354).val);
            exec_list *const f3353_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3353->then_instructions;

               ir_variable *const r3355 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r3357 = less(body.constant(int(2045)), r3239);
               ir_if *f3356 = new(mem_ctx) ir_if(operand(r3357).val);
               exec_list *const f3356_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3356->then_instructions;

                  body.emit(assign(r3355, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3356->else_instructions;

                  ir_variable *const r3358 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r335A = equal(r3239, body.constant(int(2045)));
                  ir_if *f3359 = new(mem_ctx) ir_if(operand(r335A).val);
                  exec_list *const f3359_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3359->then_instructions;

                     ir_expression *const r335B = equal(body.constant(2097151u), r3343);
                     ir_expression *const r335C = equal(body.constant(4294967295u), r3344);
                     body.emit(assign(r3358, logic_and(r335B, r335C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3359->else_instructions;

                     body.emit(assign(r3358, body.constant(false), 0x01));


                  body.instructions = f3359_parent_instructions;
                  body.emit(f3359);

                  /* END IF */

                  body.emit(assign(r3355, logic_and(r3358, r3351), 0x01));


               body.instructions = f3356_parent_instructions;
               body.emit(f3356);

               /* END IF */

               /* IF CONDITION */
               ir_if *f335D = new(mem_ctx) ir_if(operand(r3355).val);
               exec_list *const f335D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f335D->then_instructions;

                  ir_variable *const r335E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r335E);
                  ir_expression *const r335F = lshift(r2E18, body.constant(int(31)));
                  body.emit(assign(r335E, add(r335F, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r335E, body.constant(0u), 0x01));

                  body.emit(assign(r3350, r335E, 0x03));

                  body.emit(assign(r334F, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f335D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3361 = less(r3239, body.constant(int(0)));
                  ir_if *f3360 = new(mem_ctx) ir_if(operand(r3361).val);
                  exec_list *const f3360_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3360->then_instructions;

                     ir_variable *const r3362 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3362, r323A, 0x01));

                     ir_variable *const r3363 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3363, neg(r3239), 0x01));

                     ir_variable *const r3364 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3364);
                     ir_variable *const r3365 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3365);
                     ir_variable *const r3366 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3366);
                     ir_variable *const r3367 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r3368 = neg(r3363);
                     body.emit(assign(r3367, bit_and(r3368, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r336A = equal(r3363, body.constant(int(0)));
                     ir_if *f3369 = new(mem_ctx) ir_if(operand(r336A).val);
                     exec_list *const f3369_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3369->then_instructions;

                        body.emit(assign(r3364, r323A, 0x01));

                        body.emit(assign(r3365, r3344, 0x01));

                        body.emit(assign(r3366, r3343, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3369->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r336C = less(r3363, body.constant(int(32)));
                        ir_if *f336B = new(mem_ctx) ir_if(operand(r336C).val);
                        exec_list *const f336B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f336B->then_instructions;

                           body.emit(assign(r3364, lshift(r3344, r3367), 0x01));

                           ir_expression *const r336D = lshift(r3343, r3367);
                           ir_expression *const r336E = rshift(r3344, r3363);
                           body.emit(assign(r3365, bit_or(r336D, r336E), 0x01));

                           body.emit(assign(r3366, rshift(r3343, r3363), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f336B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3370 = equal(r3363, body.constant(int(32)));
                           ir_if *f336F = new(mem_ctx) ir_if(operand(r3370).val);
                           exec_list *const f336F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f336F->then_instructions;

                              body.emit(assign(r3364, r3344, 0x01));

                              body.emit(assign(r3365, r3343, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f336F->else_instructions;

                              body.emit(assign(r3362, bit_or(r323A, r3344), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3372 = less(r3363, body.constant(int(64)));
                              ir_if *f3371 = new(mem_ctx) ir_if(operand(r3372).val);
                              exec_list *const f3371_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3371->then_instructions;

                                 body.emit(assign(r3364, lshift(r3343, r3367), 0x01));

                                 ir_expression *const r3373 = bit_and(r3363, body.constant(int(31)));
                                 body.emit(assign(r3365, rshift(r3343, r3373), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3371->else_instructions;

                                 ir_variable *const r3374 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3376 = equal(r3363, body.constant(int(64)));
                                 ir_if *f3375 = new(mem_ctx) ir_if(operand(r3376).val);
                                 exec_list *const f3375_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3375->then_instructions;

                                    body.emit(assign(r3374, r3343, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3375->else_instructions;

                                    ir_expression *const r3377 = nequal(r3343, body.constant(0u));
                                    ir_expression *const r3378 = expr(ir_unop_b2i, r3377);
                                    body.emit(assign(r3374, expr(ir_unop_i2u, r3378), 0x01));


                                 body.instructions = f3375_parent_instructions;
                                 body.emit(f3375);

                                 /* END IF */

                                 body.emit(assign(r3364, r3374, 0x01));

                                 body.emit(assign(r3365, body.constant(0u), 0x01));


                              body.instructions = f3371_parent_instructions;
                              body.emit(f3371);

                              /* END IF */


                           body.instructions = f336F_parent_instructions;
                           body.emit(f336F);

                           /* END IF */

                           body.emit(assign(r3366, body.constant(0u), 0x01));


                        body.instructions = f336B_parent_instructions;
                        body.emit(f336B);

                        /* END IF */

                        ir_expression *const r3379 = nequal(r3362, body.constant(0u));
                        ir_expression *const r337A = expr(ir_unop_b2i, r3379);
                        ir_expression *const r337B = expr(ir_unop_i2u, r337A);
                        body.emit(assign(r3364, bit_or(r3364, r337B), 0x01));


                     body.instructions = f3369_parent_instructions;
                     body.emit(f3369);

                     /* END IF */

                     body.emit(assign(r334C, r3366, 0x01));

                     body.emit(assign(r334D, r3365, 0x01));

                     body.emit(assign(r334E, r3364, 0x01));

                     body.emit(assign(r334B, body.constant(int(0)), 0x01));

                     body.emit(assign(r3351, less(r3364, body.constant(0u)), 0x01));


                  body.instructions = f3360_parent_instructions;
                  body.emit(f3360);

                  /* END IF */


               body.instructions = f335D_parent_instructions;
               body.emit(f335D);

               /* END IF */


            body.instructions = f3353_parent_instructions;
            body.emit(f3353);

            /* END IF */

            /* IF CONDITION */
            ir_if *f337C = new(mem_ctx) ir_if(operand(r334F).val);
            exec_list *const f337C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f337C->then_instructions;

               /* IF CONDITION */
               ir_if *f337D = new(mem_ctx) ir_if(operand(r3351).val);
               exec_list *const f337D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f337D->then_instructions;

                  ir_variable *const r337E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r337E, add(r334D, body.constant(1u)), 0x01));

                  ir_expression *const r337F = less(r337E, r334D);
                  ir_expression *const r3380 = expr(ir_unop_b2i, r337F);
                  ir_expression *const r3381 = expr(ir_unop_i2u, r3380);
                  body.emit(assign(r334C, add(r334C, r3381), 0x01));

                  ir_expression *const r3382 = equal(r334E, body.constant(0u));
                  ir_expression *const r3383 = expr(ir_unop_b2i, r3382);
                  ir_expression *const r3384 = expr(ir_unop_i2u, r3383);
                  ir_expression *const r3385 = add(r334E, r3384);
                  ir_expression *const r3386 = bit_and(r3385, body.constant(1u));
                  ir_expression *const r3387 = expr(ir_unop_bit_not, r3386);
                  body.emit(assign(r334D, bit_and(r337E, r3387), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f337D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3389 = bit_or(r334C, r334D);
                  ir_expression *const r338A = equal(r3389, body.constant(0u));
                  ir_if *f3388 = new(mem_ctx) ir_if(operand(r338A).val);
                  exec_list *const f3388_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3388->then_instructions;

                     body.emit(assign(r334B, body.constant(int(0)), 0x01));


                  body.instructions = f3388_parent_instructions;
                  body.emit(f3388);

                  /* END IF */


               body.instructions = f337D_parent_instructions;
               body.emit(f337D);

               /* END IF */

               ir_variable *const r338B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r338B);
               ir_expression *const r338C = lshift(r2E18, body.constant(int(31)));
               ir_expression *const r338D = expr(ir_unop_i2u, r334B);
               ir_expression *const r338E = lshift(r338D, body.constant(int(20)));
               ir_expression *const r338F = add(r338C, r338E);
               body.emit(assign(r338B, add(r338F, r334C), 0x02));

               body.emit(assign(r338B, r334D, 0x01));

               body.emit(assign(r3350, r338B, 0x03));

               body.emit(assign(r334F, body.constant(false), 0x01));


            body.instructions = f337C_parent_instructions;
            body.emit(f337C);

            /* END IF */

            body.emit(assign(r3235, r3350, 0x03));

            body.emit(assign(r3234, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3349->else_instructions;

            body.emit(assign(r3239, add(r3239, body.constant(int(1))), 0x01));

            ir_variable *const r3390 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r3390);
            ir_variable *const r3391 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r3391);
            ir_variable *const r3392 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r3392);
            body.emit(assign(r3390, lshift(r3344, body.constant(int(31))), 0x01));

            ir_expression *const r3393 = lshift(r3343, body.constant(int(31)));
            ir_expression *const r3394 = rshift(r3344, body.constant(int(1)));
            body.emit(assign(r3391, bit_or(r3393, r3394), 0x01));

            body.emit(assign(r3392, rshift(r3343, body.constant(int(1))), 0x01));

            ir_expression *const r3395 = nequal(r323A, body.constant(0u));
            ir_expression *const r3396 = expr(ir_unop_b2i, r3395);
            ir_expression *const r3397 = expr(ir_unop_i2u, r3396);
            body.emit(assign(r3390, bit_or(r3390, r3397), 0x01));

            body.emit(assign(r323B, r3392, 0x01));

            body.emit(assign(r323A, r3390, 0x01));

            ir_variable *const r3398 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r3398, r3239, 0x01));

            ir_variable *const r3399 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r3399, r3392, 0x01));

            ir_variable *const r339A = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r339A, r3391, 0x01));

            ir_variable *const r339B = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r339B, r3390, 0x01));

            ir_variable *const r339C = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r339C, body.constant(true), 0x01));

            ir_variable *const r339D = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r339E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r339E);
            ir_expression *const r339F = expr(ir_unop_u2i, r3390);
            body.emit(assign(r339E, less(r339F, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r33A1 = lequal(body.constant(int(2045)), r3239);
            ir_if *f33A0 = new(mem_ctx) ir_if(operand(r33A1).val);
            exec_list *const f33A0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f33A0->then_instructions;

               ir_variable *const r33A2 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r33A4 = less(body.constant(int(2045)), r3239);
               ir_if *f33A3 = new(mem_ctx) ir_if(operand(r33A4).val);
               exec_list *const f33A3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f33A3->then_instructions;

                  body.emit(assign(r33A2, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f33A3->else_instructions;

                  ir_variable *const r33A5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r33A7 = equal(r3239, body.constant(int(2045)));
                  ir_if *f33A6 = new(mem_ctx) ir_if(operand(r33A7).val);
                  exec_list *const f33A6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33A6->then_instructions;

                     ir_expression *const r33A8 = equal(body.constant(2097151u), r3392);
                     ir_expression *const r33A9 = equal(body.constant(4294967295u), r3391);
                     body.emit(assign(r33A5, logic_and(r33A8, r33A9), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f33A6->else_instructions;

                     body.emit(assign(r33A5, body.constant(false), 0x01));


                  body.instructions = f33A6_parent_instructions;
                  body.emit(f33A6);

                  /* END IF */

                  body.emit(assign(r33A2, logic_and(r33A5, r339E), 0x01));


               body.instructions = f33A3_parent_instructions;
               body.emit(f33A3);

               /* END IF */

               /* IF CONDITION */
               ir_if *f33AA = new(mem_ctx) ir_if(operand(r33A2).val);
               exec_list *const f33AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f33AA->then_instructions;

                  ir_variable *const r33AB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r33AB);
                  ir_expression *const r33AC = lshift(r2E18, body.constant(int(31)));
                  body.emit(assign(r33AB, add(r33AC, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r33AB, body.constant(0u), 0x01));

                  body.emit(assign(r339D, r33AB, 0x03));

                  body.emit(assign(r339C, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f33AA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r33AE = less(r3239, body.constant(int(0)));
                  ir_if *f33AD = new(mem_ctx) ir_if(operand(r33AE).val);
                  exec_list *const f33AD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33AD->then_instructions;

                     ir_variable *const r33AF = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r33AF, r3390, 0x01));

                     ir_variable *const r33B0 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r33B0, neg(r3239), 0x01));

                     ir_variable *const r33B1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r33B1);
                     ir_variable *const r33B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r33B2);
                     ir_variable *const r33B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r33B3);
                     ir_variable *const r33B4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r33B5 = neg(r33B0);
                     body.emit(assign(r33B4, bit_and(r33B5, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r33B7 = equal(r33B0, body.constant(int(0)));
                     ir_if *f33B6 = new(mem_ctx) ir_if(operand(r33B7).val);
                     exec_list *const f33B6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f33B6->then_instructions;

                        body.emit(assign(r33B1, r3390, 0x01));

                        body.emit(assign(r33B2, r3391, 0x01));

                        body.emit(assign(r33B3, r3392, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f33B6->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r33B9 = less(r33B0, body.constant(int(32)));
                        ir_if *f33B8 = new(mem_ctx) ir_if(operand(r33B9).val);
                        exec_list *const f33B8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f33B8->then_instructions;

                           body.emit(assign(r33B1, lshift(r3391, r33B4), 0x01));

                           ir_expression *const r33BA = lshift(r3392, r33B4);
                           ir_expression *const r33BB = rshift(r3391, r33B0);
                           body.emit(assign(r33B2, bit_or(r33BA, r33BB), 0x01));

                           body.emit(assign(r33B3, rshift(r3392, r33B0), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f33B8->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r33BD = equal(r33B0, body.constant(int(32)));
                           ir_if *f33BC = new(mem_ctx) ir_if(operand(r33BD).val);
                           exec_list *const f33BC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f33BC->then_instructions;

                              body.emit(assign(r33B1, r3391, 0x01));

                              body.emit(assign(r33B2, r3392, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f33BC->else_instructions;

                              body.emit(assign(r33AF, bit_or(r3390, r3391), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r33BF = less(r33B0, body.constant(int(64)));
                              ir_if *f33BE = new(mem_ctx) ir_if(operand(r33BF).val);
                              exec_list *const f33BE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f33BE->then_instructions;

                                 body.emit(assign(r33B1, lshift(r3392, r33B4), 0x01));

                                 ir_expression *const r33C0 = bit_and(r33B0, body.constant(int(31)));
                                 body.emit(assign(r33B2, rshift(r3392, r33C0), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f33BE->else_instructions;

                                 ir_variable *const r33C1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r33C3 = equal(r33B0, body.constant(int(64)));
                                 ir_if *f33C2 = new(mem_ctx) ir_if(operand(r33C3).val);
                                 exec_list *const f33C2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f33C2->then_instructions;

                                    body.emit(assign(r33C1, r3392, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f33C2->else_instructions;

                                    ir_expression *const r33C4 = nequal(r3392, body.constant(0u));
                                    ir_expression *const r33C5 = expr(ir_unop_b2i, r33C4);
                                    body.emit(assign(r33C1, expr(ir_unop_i2u, r33C5), 0x01));


                                 body.instructions = f33C2_parent_instructions;
                                 body.emit(f33C2);

                                 /* END IF */

                                 body.emit(assign(r33B1, r33C1, 0x01));

                                 body.emit(assign(r33B2, body.constant(0u), 0x01));


                              body.instructions = f33BE_parent_instructions;
                              body.emit(f33BE);

                              /* END IF */


                           body.instructions = f33BC_parent_instructions;
                           body.emit(f33BC);

                           /* END IF */

                           body.emit(assign(r33B3, body.constant(0u), 0x01));


                        body.instructions = f33B8_parent_instructions;
                        body.emit(f33B8);

                        /* END IF */

                        ir_expression *const r33C6 = nequal(r33AF, body.constant(0u));
                        ir_expression *const r33C7 = expr(ir_unop_b2i, r33C6);
                        ir_expression *const r33C8 = expr(ir_unop_i2u, r33C7);
                        body.emit(assign(r33B1, bit_or(r33B1, r33C8), 0x01));


                     body.instructions = f33B6_parent_instructions;
                     body.emit(f33B6);

                     /* END IF */

                     body.emit(assign(r3399, r33B3, 0x01));

                     body.emit(assign(r339A, r33B2, 0x01));

                     body.emit(assign(r339B, r33B1, 0x01));

                     body.emit(assign(r3398, body.constant(int(0)), 0x01));

                     body.emit(assign(r339E, less(r33B1, body.constant(0u)), 0x01));


                  body.instructions = f33AD_parent_instructions;
                  body.emit(f33AD);

                  /* END IF */


               body.instructions = f33AA_parent_instructions;
               body.emit(f33AA);

               /* END IF */


            body.instructions = f33A0_parent_instructions;
            body.emit(f33A0);

            /* END IF */

            /* IF CONDITION */
            ir_if *f33C9 = new(mem_ctx) ir_if(operand(r339C).val);
            exec_list *const f33C9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f33C9->then_instructions;

               /* IF CONDITION */
               ir_if *f33CA = new(mem_ctx) ir_if(operand(r339E).val);
               exec_list *const f33CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f33CA->then_instructions;

                  ir_variable *const r33CB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33CB, add(r339A, body.constant(1u)), 0x01));

                  ir_expression *const r33CC = less(r33CB, r339A);
                  ir_expression *const r33CD = expr(ir_unop_b2i, r33CC);
                  ir_expression *const r33CE = expr(ir_unop_i2u, r33CD);
                  body.emit(assign(r3399, add(r3399, r33CE), 0x01));

                  ir_expression *const r33CF = equal(r339B, body.constant(0u));
                  ir_expression *const r33D0 = expr(ir_unop_b2i, r33CF);
                  ir_expression *const r33D1 = expr(ir_unop_i2u, r33D0);
                  ir_expression *const r33D2 = add(r339B, r33D1);
                  ir_expression *const r33D3 = bit_and(r33D2, body.constant(1u));
                  ir_expression *const r33D4 = expr(ir_unop_bit_not, r33D3);
                  body.emit(assign(r339A, bit_and(r33CB, r33D4), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f33CA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r33D6 = bit_or(r3399, r339A);
                  ir_expression *const r33D7 = equal(r33D6, body.constant(0u));
                  ir_if *f33D5 = new(mem_ctx) ir_if(operand(r33D7).val);
                  exec_list *const f33D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33D5->then_instructions;

                     body.emit(assign(r3398, body.constant(int(0)), 0x01));


                  body.instructions = f33D5_parent_instructions;
                  body.emit(f33D5);

                  /* END IF */


               body.instructions = f33CA_parent_instructions;
               body.emit(f33CA);

               /* END IF */

               ir_variable *const r33D8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r33D8);
               ir_expression *const r33D9 = lshift(r2E18, body.constant(int(31)));
               ir_expression *const r33DA = expr(ir_unop_i2u, r3398);
               ir_expression *const r33DB = lshift(r33DA, body.constant(int(20)));
               ir_expression *const r33DC = add(r33D9, r33DB);
               body.emit(assign(r33D8, add(r33DC, r3399), 0x02));

               body.emit(assign(r33D8, r339A, 0x01));

               body.emit(assign(r339D, r33D8, 0x03));

               body.emit(assign(r339C, body.constant(false), 0x01));


            body.instructions = f33C9_parent_instructions;
            body.emit(f33C9);

            /* END IF */

            body.emit(assign(r3235, r339D, 0x03));

            body.emit(assign(r3234, body.constant(false), 0x01));


         body.instructions = f3349_parent_instructions;
         body.emit(f3349);

         /* END IF */


      body.instructions = f3342_parent_instructions;
      body.emit(f3342);

      /* END IF */

      body.emit(assign(r2E17, r3235, 0x03));


   body.instructions = f2E1A_parent_instructions;
   body.emit(f2E1A);

   /* END IF */

   body.emit(ret(r2E17));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmod64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r33DD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "x", ir_var_function_in);
   sig_parameters.push_tail(r33DD);
   ir_variable *const r33DE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "y", ir_var_function_in);
   sig_parameters.push_tail(r33DE);
   ir_variable *const r33DF = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r33DF, body.constant(true), 0x01));

   ir_variable *const r33E0 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r33E1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r33E1);
   ir_variable *const r33E2 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r33E2);
   ir_variable *const r33E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r33E3);
   ir_variable *const r33E4 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r33E4);
   ir_variable *const r33E5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r33E5);
   ir_variable *const r33E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r33E6);
   ir_variable *const r33E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r33E7);
   ir_variable *const r33E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r33E8);
   ir_variable *const r33E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r33E9);
   ir_variable *const r33EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r33EA);
   ir_variable *const r33EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r33EB);
   ir_variable *const r33EC = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r33EC);
   body.emit(assign(r33EB, body.constant(0u), 0x01));

   body.emit(assign(r33EA, body.constant(0u), 0x01));

   body.emit(assign(r33E9, body.constant(0u), 0x01));

   body.emit(assign(r33E8, body.constant(0u), 0x01));

   body.emit(assign(r33E7, body.constant(0u), 0x01));

   body.emit(assign(r33E6, body.constant(0u), 0x01));

   ir_variable *const r33ED = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r33ED);
   body.emit(assign(r33ED, bit_and(swizzle_y(r33DD), body.constant(1048575u)), 0x02));

   body.emit(assign(r33ED, swizzle_x(r33DD), 0x01));

   body.emit(assign(r33E5, r33ED, 0x03));

   ir_variable *const r33EE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r33EF = rshift(swizzle_y(r33DD), body.constant(int(20)));
   ir_expression *const r33F0 = bit_and(r33EF, body.constant(2047u));
   body.emit(assign(r33EE, expr(ir_unop_u2i, r33F0), 0x01));

   body.emit(assign(r33E4, r33EE, 0x01));

   ir_variable *const r33F1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r33F1);
   body.emit(assign(r33F1, bit_and(swizzle_y(r33DE), body.constant(1048575u)), 0x02));

   body.emit(assign(r33F1, swizzle_x(r33DE), 0x01));

   body.emit(assign(r33E3, r33F1, 0x03));

   ir_variable *const r33F2 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r33F3 = rshift(swizzle_y(r33DE), body.constant(int(20)));
   ir_expression *const r33F4 = bit_and(r33F3, body.constant(2047u));
   body.emit(assign(r33F2, expr(ir_unop_u2i, r33F4), 0x01));

   body.emit(assign(r33E2, r33F2, 0x01));

   ir_expression *const r33F5 = rshift(swizzle_y(r33DD), body.constant(int(31)));
   ir_expression *const r33F6 = rshift(swizzle_y(r33DE), body.constant(int(31)));
   body.emit(assign(r33E1, bit_xor(r33F5, r33F6), 0x01));

   /* IF CONDITION */
   ir_expression *const r33F8 = equal(r33EE, body.constant(int(2047)));
   ir_if *f33F7 = new(mem_ctx) ir_if(operand(r33F8).val);
   exec_list *const f33F7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f33F7->then_instructions;

      /* IF CONDITION */
      ir_expression *const r33FA = bit_or(swizzle_y(r33ED), swizzle_x(r33DD));
      ir_expression *const r33FB = nequal(r33FA, body.constant(0u));
      ir_if *f33F9 = new(mem_ctx) ir_if(operand(r33FB).val);
      exec_list *const f33F9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f33F9->then_instructions;

         ir_variable *const r33FC = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r33FC, swizzle_x(r33DD), 0x01));

         ir_variable *const r33FD = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r33FD, swizzle_x(r33DE), 0x01));

         ir_variable *const r33FE = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r33FF = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r3400 = rshift(swizzle_y(r33DD), body.constant(int(19)));
         ir_expression *const r3401 = bit_and(r3400, body.constant(4095u));
         ir_expression *const r3402 = equal(r3401, body.constant(4094u));
         ir_expression *const r3403 = nequal(swizzle_x(r33DD), body.constant(0u));
         ir_expression *const r3404 = bit_and(swizzle_y(r33DD), body.constant(524287u));
         ir_expression *const r3405 = nequal(r3404, body.constant(0u));
         ir_expression *const r3406 = logic_or(r3403, r3405);
         body.emit(assign(r33FF, logic_and(r3402, r3406), 0x01));

         ir_variable *const r3407 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r3408 = lshift(swizzle_y(r33DE), body.constant(int(1)));
         ir_expression *const r3409 = lequal(body.constant(4292870144u), r3408);
         ir_expression *const r340A = nequal(swizzle_x(r33DE), body.constant(0u));
         ir_expression *const r340B = bit_and(swizzle_y(r33DE), body.constant(1048575u));
         ir_expression *const r340C = nequal(r340B, body.constant(0u));
         ir_expression *const r340D = logic_or(r340A, r340C);
         body.emit(assign(r3407, logic_and(r3409, r340D), 0x01));

         body.emit(assign(r33FC, bit_or(swizzle_y(r33DD), body.constant(524288u)), 0x02));

         body.emit(assign(r33FD, bit_or(swizzle_y(r33DE), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r340F = lshift(swizzle_y(r33DD), body.constant(int(1)));
         ir_expression *const r3410 = lequal(body.constant(4292870144u), r340F);
         ir_expression *const r3411 = nequal(swizzle_x(r33DD), body.constant(0u));
         ir_expression *const r3412 = bit_and(swizzle_y(r33DD), body.constant(1048575u));
         ir_expression *const r3413 = nequal(r3412, body.constant(0u));
         ir_expression *const r3414 = logic_or(r3411, r3413);
         ir_expression *const r3415 = logic_and(r3410, r3414);
         ir_if *f340E = new(mem_ctx) ir_if(operand(r3415).val);
         exec_list *const f340E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f340E->then_instructions;

            ir_variable *const r3416 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r3418 = logic_and(r33FF, r3407);
            ir_if *f3417 = new(mem_ctx) ir_if(operand(r3418).val);
            exec_list *const f3417_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3417->then_instructions;

               body.emit(assign(r3416, r33FD, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3417->else_instructions;

               body.emit(assign(r3416, r33FC, 0x03));


            body.instructions = f3417_parent_instructions;
            body.emit(f3417);

            /* END IF */

            body.emit(assign(r33FE, r3416, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f340E->else_instructions;

            body.emit(assign(r33FE, r33FD, 0x03));


         body.instructions = f340E_parent_instructions;
         body.emit(f340E);

         /* END IF */

         body.emit(assign(r33E0, r33FE, 0x03));

         body.emit(assign(r33DF, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f33F9->else_instructions;

         /* IF CONDITION */
         ir_expression *const r341A = equal(r33F2, body.constant(int(2047)));
         ir_if *f3419 = new(mem_ctx) ir_if(operand(r341A).val);
         exec_list *const f3419_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3419->then_instructions;

            /* IF CONDITION */
            ir_expression *const r341C = bit_or(swizzle_y(r33F1), swizzle_x(r33DE));
            ir_expression *const r341D = nequal(r341C, body.constant(0u));
            ir_if *f341B = new(mem_ctx) ir_if(operand(r341D).val);
            exec_list *const f341B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f341B->then_instructions;

               ir_variable *const r341E = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r341E, swizzle_x(r33DD), 0x01));

               ir_variable *const r341F = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r341F, swizzle_x(r33DE), 0x01));

               ir_variable *const r3420 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3421 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3422 = rshift(swizzle_y(r33DD), body.constant(int(19)));
               ir_expression *const r3423 = bit_and(r3422, body.constant(4095u));
               ir_expression *const r3424 = equal(r3423, body.constant(4094u));
               ir_expression *const r3425 = nequal(swizzle_x(r33DD), body.constant(0u));
               ir_expression *const r3426 = bit_and(swizzle_y(r33DD), body.constant(524287u));
               ir_expression *const r3427 = nequal(r3426, body.constant(0u));
               ir_expression *const r3428 = logic_or(r3425, r3427);
               body.emit(assign(r3421, logic_and(r3424, r3428), 0x01));

               ir_variable *const r3429 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r342A = lshift(swizzle_y(r33DE), body.constant(int(1)));
               ir_expression *const r342B = lequal(body.constant(4292870144u), r342A);
               ir_expression *const r342C = nequal(swizzle_x(r33DE), body.constant(0u));
               ir_expression *const r342D = bit_and(swizzle_y(r33DE), body.constant(1048575u));
               ir_expression *const r342E = nequal(r342D, body.constant(0u));
               ir_expression *const r342F = logic_or(r342C, r342E);
               body.emit(assign(r3429, logic_and(r342B, r342F), 0x01));

               body.emit(assign(r341E, bit_or(swizzle_y(r33DD), body.constant(524288u)), 0x02));

               body.emit(assign(r341F, bit_or(swizzle_y(r33DE), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r3431 = lshift(swizzle_y(r33DD), body.constant(int(1)));
               ir_expression *const r3432 = lequal(body.constant(4292870144u), r3431);
               ir_expression *const r3433 = nequal(swizzle_x(r33DD), body.constant(0u));
               ir_expression *const r3434 = bit_and(swizzle_y(r33DD), body.constant(1048575u));
               ir_expression *const r3435 = nequal(r3434, body.constant(0u));
               ir_expression *const r3436 = logic_or(r3433, r3435);
               ir_expression *const r3437 = logic_and(r3432, r3436);
               ir_if *f3430 = new(mem_ctx) ir_if(operand(r3437).val);
               exec_list *const f3430_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3430->then_instructions;

                  ir_variable *const r3438 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r343A = logic_and(r3421, r3429);
                  ir_if *f3439 = new(mem_ctx) ir_if(operand(r343A).val);
                  exec_list *const f3439_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3439->then_instructions;

                     body.emit(assign(r3438, r341F, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3439->else_instructions;

                     body.emit(assign(r3438, r341E, 0x03));


                  body.instructions = f3439_parent_instructions;
                  body.emit(f3439);

                  /* END IF */

                  body.emit(assign(r3420, r3438, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3430->else_instructions;

                  body.emit(assign(r3420, r341F, 0x03));


               body.instructions = f3430_parent_instructions;
               body.emit(f3430);

               /* END IF */

               body.emit(assign(r33E0, r3420, 0x03));

               body.emit(assign(r33DF, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f341B->else_instructions;

               ir_constant_data r343B_data;
               memset(&r343B_data, 0, sizeof(ir_constant_data));
               r343B_data.u[0] = 4294967295;
               r343B_data.u[1] = 4294967295;
               ir_constant *const r343B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r343B_data);
               body.emit(assign(r33E0, r343B, 0x03));

               body.emit(assign(r33DF, body.constant(false), 0x01));


            body.instructions = f341B_parent_instructions;
            body.emit(f341B);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3419->else_instructions;

            ir_variable *const r343C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r343C);
            ir_expression *const r343D = lshift(r33E1, body.constant(int(31)));
            body.emit(assign(r343C, add(r343D, body.constant(2146435072u)), 0x02));

            body.emit(assign(r343C, body.constant(0u), 0x01));

            body.emit(assign(r33E0, r343C, 0x03));

            body.emit(assign(r33DF, body.constant(false), 0x01));


         body.instructions = f3419_parent_instructions;
         body.emit(f3419);

         /* END IF */


      body.instructions = f33F9_parent_instructions;
      body.emit(f33F9);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f33F7->else_instructions;

      /* IF CONDITION */
      ir_expression *const r343F = equal(r33F2, body.constant(int(2047)));
      ir_if *f343E = new(mem_ctx) ir_if(operand(r343F).val);
      exec_list *const f343E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f343E->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3441 = bit_or(swizzle_y(r33F1), swizzle_x(r33DE));
         ir_expression *const r3442 = nequal(r3441, body.constant(0u));
         ir_if *f3440 = new(mem_ctx) ir_if(operand(r3442).val);
         exec_list *const f3440_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3440->then_instructions;

            ir_variable *const r3443 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r3443, swizzle_x(r33DD), 0x01));

            ir_variable *const r3444 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r3444, swizzle_x(r33DE), 0x01));

            ir_variable *const r3445 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3446 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r3447 = rshift(swizzle_y(r33DD), body.constant(int(19)));
            ir_expression *const r3448 = bit_and(r3447, body.constant(4095u));
            ir_expression *const r3449 = equal(r3448, body.constant(4094u));
            ir_expression *const r344A = nequal(swizzle_x(r33DD), body.constant(0u));
            ir_expression *const r344B = bit_and(swizzle_y(r33DD), body.constant(524287u));
            ir_expression *const r344C = nequal(r344B, body.constant(0u));
            ir_expression *const r344D = logic_or(r344A, r344C);
            body.emit(assign(r3446, logic_and(r3449, r344D), 0x01));

            ir_variable *const r344E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r344F = lshift(swizzle_y(r33DE), body.constant(int(1)));
            ir_expression *const r3450 = lequal(body.constant(4292870144u), r344F);
            ir_expression *const r3451 = nequal(swizzle_x(r33DE), body.constant(0u));
            ir_expression *const r3452 = bit_and(swizzle_y(r33DE), body.constant(1048575u));
            ir_expression *const r3453 = nequal(r3452, body.constant(0u));
            ir_expression *const r3454 = logic_or(r3451, r3453);
            body.emit(assign(r344E, logic_and(r3450, r3454), 0x01));

            body.emit(assign(r3443, bit_or(swizzle_y(r33DD), body.constant(524288u)), 0x02));

            body.emit(assign(r3444, bit_or(swizzle_y(r33DE), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r3456 = lshift(swizzle_y(r33DD), body.constant(int(1)));
            ir_expression *const r3457 = lequal(body.constant(4292870144u), r3456);
            ir_expression *const r3458 = nequal(swizzle_x(r33DD), body.constant(0u));
            ir_expression *const r3459 = bit_and(swizzle_y(r33DD), body.constant(1048575u));
            ir_expression *const r345A = nequal(r3459, body.constant(0u));
            ir_expression *const r345B = logic_or(r3458, r345A);
            ir_expression *const r345C = logic_and(r3457, r345B);
            ir_if *f3455 = new(mem_ctx) ir_if(operand(r345C).val);
            exec_list *const f3455_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3455->then_instructions;

               ir_variable *const r345D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r345F = logic_and(r3446, r344E);
               ir_if *f345E = new(mem_ctx) ir_if(operand(r345F).val);
               exec_list *const f345E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f345E->then_instructions;

                  body.emit(assign(r345D, r3444, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f345E->else_instructions;

                  body.emit(assign(r345D, r3443, 0x03));


               body.instructions = f345E_parent_instructions;
               body.emit(f345E);

               /* END IF */

               body.emit(assign(r3445, r345D, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3455->else_instructions;

               body.emit(assign(r3445, r3444, 0x03));


            body.instructions = f3455_parent_instructions;
            body.emit(f3455);

            /* END IF */

            body.emit(assign(r33E0, r3445, 0x03));

            body.emit(assign(r33DF, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3440->else_instructions;

            ir_variable *const r3460 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r3460);
            body.emit(assign(r3460, lshift(r33E1, body.constant(int(31))), 0x02));

            body.emit(assign(r3460, body.constant(0u), 0x01));

            body.emit(assign(r33E0, r3460, 0x03));

            body.emit(assign(r33DF, body.constant(false), 0x01));


         body.instructions = f3440_parent_instructions;
         body.emit(f3440);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f343E->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3462 = equal(r33F2, body.constant(int(0)));
         ir_if *f3461 = new(mem_ctx) ir_if(operand(r3462).val);
         exec_list *const f3461_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3461->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3464 = bit_or(swizzle_y(r33F1), swizzle_x(r33DE));
            ir_expression *const r3465 = equal(r3464, body.constant(0u));
            ir_if *f3463 = new(mem_ctx) ir_if(operand(r3465).val);
            exec_list *const f3463_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3463->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3467 = expr(ir_unop_i2u, r33EE);
               ir_expression *const r3468 = bit_or(r3467, swizzle_y(r33ED));
               ir_expression *const r3469 = bit_or(r3468, swizzle_x(r33DD));
               ir_expression *const r346A = equal(r3469, body.constant(0u));
               ir_if *f3466 = new(mem_ctx) ir_if(operand(r346A).val);
               exec_list *const f3466_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3466->then_instructions;

                  ir_constant_data r346B_data;
                  memset(&r346B_data, 0, sizeof(ir_constant_data));
                  r346B_data.u[0] = 4294967295;
                  r346B_data.u[1] = 4294967295;
                  ir_constant *const r346B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r346B_data);
                  body.emit(assign(r33E0, r346B, 0x03));

                  body.emit(assign(r33DF, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3466->else_instructions;

                  ir_variable *const r346C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r346C);
                  ir_expression *const r346D = lshift(r33E1, body.constant(int(31)));
                  body.emit(assign(r346C, add(r346D, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r346C, body.constant(0u), 0x01));

                  body.emit(assign(r33E0, r346C, 0x03));

                  body.emit(assign(r33DF, body.constant(false), 0x01));


               body.instructions = f3466_parent_instructions;
               body.emit(f3466);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3463->else_instructions;

               ir_variable *const r346E = body.make_temp(glsl_type::uint_type, "aFrac0");
               body.emit(assign(r346E, swizzle_y(r33F1), 0x01));

               ir_variable *const r346F = body.make_temp(glsl_type::uint_type, "aFrac1");
               body.emit(assign(r346F, swizzle_x(r33F1), 0x01));

               ir_variable *const r3470 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r3470, r33F2, 0x01));

               ir_variable *const r3471 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r3471, swizzle_y(r33F1), 0x01));

               ir_variable *const r3472 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r3472, swizzle_x(r33F1), 0x01));

               ir_variable *const r3473 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3473);
               /* IF CONDITION */
               ir_expression *const r3475 = equal(swizzle_y(r33F1), body.constant(0u));
               ir_if *f3474 = new(mem_ctx) ir_if(operand(r3475).val);
               exec_list *const f3474_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3474->then_instructions;

                  ir_variable *const r3476 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3476, r346F, 0x01));

                  ir_variable *const r3477 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3478 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3478);
                  /* IF CONDITION */
                  ir_expression *const r347A = equal(swizzle_x(r33DE), body.constant(0u));
                  ir_if *f3479 = new(mem_ctx) ir_if(operand(r347A).val);
                  exec_list *const f3479_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3479->then_instructions;

                     body.emit(assign(r3477, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3479->else_instructions;

                     body.emit(assign(r3478, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r347C = bit_and(swizzle_x(r33DE), body.constant(4294901760u));
                     ir_expression *const r347D = equal(r347C, body.constant(0u));
                     ir_if *f347B = new(mem_ctx) ir_if(operand(r347D).val);
                     exec_list *const f347B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f347B->then_instructions;

                        body.emit(assign(r3478, body.constant(int(16)), 0x01));

                        body.emit(assign(r3476, lshift(swizzle_x(r33DE), body.constant(int(16))), 0x01));


                     body.instructions = f347B_parent_instructions;
                     body.emit(f347B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r347F = bit_and(r3476, body.constant(4278190080u));
                     ir_expression *const r3480 = equal(r347F, body.constant(0u));
                     ir_if *f347E = new(mem_ctx) ir_if(operand(r3480).val);
                     exec_list *const f347E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f347E->then_instructions;

                        body.emit(assign(r3478, add(r3478, body.constant(int(8))), 0x01));

                        body.emit(assign(r3476, lshift(r3476, body.constant(int(8))), 0x01));


                     body.instructions = f347E_parent_instructions;
                     body.emit(f347E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3482 = bit_and(r3476, body.constant(4026531840u));
                     ir_expression *const r3483 = equal(r3482, body.constant(0u));
                     ir_if *f3481 = new(mem_ctx) ir_if(operand(r3483).val);
                     exec_list *const f3481_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3481->then_instructions;

                        body.emit(assign(r3478, add(r3478, body.constant(int(4))), 0x01));

                        body.emit(assign(r3476, lshift(r3476, body.constant(int(4))), 0x01));


                     body.instructions = f3481_parent_instructions;
                     body.emit(f3481);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3485 = bit_and(r3476, body.constant(3221225472u));
                     ir_expression *const r3486 = equal(r3485, body.constant(0u));
                     ir_if *f3484 = new(mem_ctx) ir_if(operand(r3486).val);
                     exec_list *const f3484_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3484->then_instructions;

                        body.emit(assign(r3478, add(r3478, body.constant(int(2))), 0x01));

                        body.emit(assign(r3476, lshift(r3476, body.constant(int(2))), 0x01));


                     body.instructions = f3484_parent_instructions;
                     body.emit(f3484);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3488 = bit_and(r3476, body.constant(2147483648u));
                     ir_expression *const r3489 = equal(r3488, body.constant(0u));
                     ir_if *f3487 = new(mem_ctx) ir_if(operand(r3489).val);
                     exec_list *const f3487_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3487->then_instructions;

                        body.emit(assign(r3478, add(r3478, body.constant(int(1))), 0x01));


                     body.instructions = f3487_parent_instructions;
                     body.emit(f3487);

                     /* END IF */

                     body.emit(assign(r3477, r3478, 0x01));


                  body.instructions = f3479_parent_instructions;
                  body.emit(f3479);

                  /* END IF */

                  body.emit(assign(r3473, add(r3477, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r348B = less(r3473, body.constant(int(0)));
                  ir_if *f348A = new(mem_ctx) ir_if(operand(r348B).val);
                  exec_list *const f348A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f348A->then_instructions;

                     ir_expression *const r348C = neg(r3473);
                     body.emit(assign(r3471, rshift(swizzle_x(r33DE), r348C), 0x01));

                     ir_expression *const r348D = bit_and(r3473, body.constant(int(31)));
                     body.emit(assign(r3472, lshift(swizzle_x(r33DE), r348D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f348A->else_instructions;

                     body.emit(assign(r3471, lshift(swizzle_x(r33DE), r3473), 0x01));

                     body.emit(assign(r3472, body.constant(0u), 0x01));


                  body.instructions = f348A_parent_instructions;
                  body.emit(f348A);

                  /* END IF */

                  body.emit(assign(r3470, sub(body.constant(int(-31)), r3473), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3474->else_instructions;

                  ir_variable *const r348E = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r348E, r346E, 0x01));

                  ir_variable *const r348F = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3490 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3490);
                  /* IF CONDITION */
                  ir_expression *const r3492 = equal(swizzle_y(r33F1), body.constant(0u));
                  ir_if *f3491 = new(mem_ctx) ir_if(operand(r3492).val);
                  exec_list *const f3491_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3491->then_instructions;

                     body.emit(assign(r348F, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3491->else_instructions;

                     body.emit(assign(r3490, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3494 = bit_and(swizzle_y(r33F1), body.constant(4294901760u));
                     ir_expression *const r3495 = equal(r3494, body.constant(0u));
                     ir_if *f3493 = new(mem_ctx) ir_if(operand(r3495).val);
                     exec_list *const f3493_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3493->then_instructions;

                        body.emit(assign(r3490, body.constant(int(16)), 0x01));

                        body.emit(assign(r348E, lshift(swizzle_y(r33F1), body.constant(int(16))), 0x01));


                     body.instructions = f3493_parent_instructions;
                     body.emit(f3493);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3497 = bit_and(r348E, body.constant(4278190080u));
                     ir_expression *const r3498 = equal(r3497, body.constant(0u));
                     ir_if *f3496 = new(mem_ctx) ir_if(operand(r3498).val);
                     exec_list *const f3496_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3496->then_instructions;

                        body.emit(assign(r3490, add(r3490, body.constant(int(8))), 0x01));

                        body.emit(assign(r348E, lshift(r348E, body.constant(int(8))), 0x01));


                     body.instructions = f3496_parent_instructions;
                     body.emit(f3496);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r349A = bit_and(r348E, body.constant(4026531840u));
                     ir_expression *const r349B = equal(r349A, body.constant(0u));
                     ir_if *f3499 = new(mem_ctx) ir_if(operand(r349B).val);
                     exec_list *const f3499_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3499->then_instructions;

                        body.emit(assign(r3490, add(r3490, body.constant(int(4))), 0x01));

                        body.emit(assign(r348E, lshift(r348E, body.constant(int(4))), 0x01));


                     body.instructions = f3499_parent_instructions;
                     body.emit(f3499);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r349D = bit_and(r348E, body.constant(3221225472u));
                     ir_expression *const r349E = equal(r349D, body.constant(0u));
                     ir_if *f349C = new(mem_ctx) ir_if(operand(r349E).val);
                     exec_list *const f349C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f349C->then_instructions;

                        body.emit(assign(r3490, add(r3490, body.constant(int(2))), 0x01));

                        body.emit(assign(r348E, lshift(r348E, body.constant(int(2))), 0x01));


                     body.instructions = f349C_parent_instructions;
                     body.emit(f349C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r34A0 = bit_and(r348E, body.constant(2147483648u));
                     ir_expression *const r34A1 = equal(r34A0, body.constant(0u));
                     ir_if *f349F = new(mem_ctx) ir_if(operand(r34A1).val);
                     exec_list *const f349F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f349F->then_instructions;

                        body.emit(assign(r3490, add(r3490, body.constant(int(1))), 0x01));


                     body.instructions = f349F_parent_instructions;
                     body.emit(f349F);

                     /* END IF */

                     body.emit(assign(r348F, r3490, 0x01));


                  body.instructions = f3491_parent_instructions;
                  body.emit(f3491);

                  /* END IF */

                  body.emit(assign(r3473, add(r348F, body.constant(int(-11))), 0x01));

                  ir_variable *const r34A2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r34A2, lshift(swizzle_x(r33DE), r3473), 0x01));

                  ir_variable *const r34A3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r34A5 = equal(r3473, body.constant(int(0)));
                  ir_if *f34A4 = new(mem_ctx) ir_if(operand(r34A5).val);
                  exec_list *const f34A4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f34A4->then_instructions;

                     body.emit(assign(r34A3, r346E, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f34A4->else_instructions;

                     ir_expression *const r34A6 = lshift(swizzle_y(r33F1), r3473);
                     ir_expression *const r34A7 = neg(r3473);
                     ir_expression *const r34A8 = bit_and(r34A7, body.constant(int(31)));
                     ir_expression *const r34A9 = rshift(swizzle_x(r33DE), r34A8);
                     body.emit(assign(r34A3, bit_or(r34A6, r34A9), 0x01));


                  body.instructions = f34A4_parent_instructions;
                  body.emit(f34A4);

                  /* END IF */

                  body.emit(assign(r3471, r34A3, 0x01));

                  body.emit(assign(r3472, r34A2, 0x01));

                  body.emit(assign(r3470, sub(body.constant(int(1)), r3473), 0x01));


               body.instructions = f3474_parent_instructions;
               body.emit(f3474);

               /* END IF */

               body.emit(assign(r33E2, r3470, 0x01));

               body.emit(assign(r33E3, r3471, 0x02));

               body.emit(assign(r33E3, r3472, 0x01));


            body.instructions = f3463_parent_instructions;
            body.emit(f3463);

            /* END IF */


         body.instructions = f3461_parent_instructions;
         body.emit(f3461);

         /* END IF */

         /* IF CONDITION */
         ir_if *f34AA = new(mem_ctx) ir_if(operand(r33DF).val);
         exec_list *const f34AA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f34AA->then_instructions;

            /* IF CONDITION */
            ir_expression *const r34AC = equal(r33EE, body.constant(int(0)));
            ir_if *f34AB = new(mem_ctx) ir_if(operand(r34AC).val);
            exec_list *const f34AB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f34AB->then_instructions;

               /* IF CONDITION */
               ir_expression *const r34AE = bit_or(swizzle_y(r33ED), swizzle_x(r33DD));
               ir_expression *const r34AF = equal(r34AE, body.constant(0u));
               ir_if *f34AD = new(mem_ctx) ir_if(operand(r34AF).val);
               exec_list *const f34AD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f34AD->then_instructions;

                  ir_variable *const r34B0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r34B0);
                  body.emit(assign(r34B0, lshift(r33E1, body.constant(int(31))), 0x02));

                  body.emit(assign(r34B0, body.constant(0u), 0x01));

                  body.emit(assign(r33E0, r34B0, 0x03));

                  body.emit(assign(r33DF, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f34AD->else_instructions;

                  ir_variable *const r34B1 = body.make_temp(glsl_type::uint_type, "aFrac0");
                  body.emit(assign(r34B1, swizzle_y(r33ED), 0x01));

                  ir_variable *const r34B2 = body.make_temp(glsl_type::uint_type, "aFrac1");
                  body.emit(assign(r34B2, swizzle_x(r33ED), 0x01));

                  ir_variable *const r34B3 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r34B3, r33EE, 0x01));

                  ir_variable *const r34B4 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r34B4, swizzle_y(r33ED), 0x01));

                  ir_variable *const r34B5 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r34B5, swizzle_x(r33ED), 0x01));

                  ir_variable *const r34B6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r34B6);
                  /* IF CONDITION */
                  ir_expression *const r34B8 = equal(swizzle_y(r33ED), body.constant(0u));
                  ir_if *f34B7 = new(mem_ctx) ir_if(operand(r34B8).val);
                  exec_list *const f34B7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f34B7->then_instructions;

                     ir_variable *const r34B9 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r34B9, r34B2, 0x01));

                     ir_variable *const r34BA = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r34BB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r34BB);
                     /* IF CONDITION */
                     ir_expression *const r34BD = equal(swizzle_x(r33DD), body.constant(0u));
                     ir_if *f34BC = new(mem_ctx) ir_if(operand(r34BD).val);
                     exec_list *const f34BC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f34BC->then_instructions;

                        body.emit(assign(r34BA, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f34BC->else_instructions;

                        body.emit(assign(r34BB, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r34BF = bit_and(swizzle_x(r33DD), body.constant(4294901760u));
                        ir_expression *const r34C0 = equal(r34BF, body.constant(0u));
                        ir_if *f34BE = new(mem_ctx) ir_if(operand(r34C0).val);
                        exec_list *const f34BE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f34BE->then_instructions;

                           body.emit(assign(r34BB, body.constant(int(16)), 0x01));

                           body.emit(assign(r34B9, lshift(swizzle_x(r33DD), body.constant(int(16))), 0x01));


                        body.instructions = f34BE_parent_instructions;
                        body.emit(f34BE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r34C2 = bit_and(r34B9, body.constant(4278190080u));
                        ir_expression *const r34C3 = equal(r34C2, body.constant(0u));
                        ir_if *f34C1 = new(mem_ctx) ir_if(operand(r34C3).val);
                        exec_list *const f34C1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f34C1->then_instructions;

                           body.emit(assign(r34BB, add(r34BB, body.constant(int(8))), 0x01));

                           body.emit(assign(r34B9, lshift(r34B9, body.constant(int(8))), 0x01));


                        body.instructions = f34C1_parent_instructions;
                        body.emit(f34C1);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r34C5 = bit_and(r34B9, body.constant(4026531840u));
                        ir_expression *const r34C6 = equal(r34C5, body.constant(0u));
                        ir_if *f34C4 = new(mem_ctx) ir_if(operand(r34C6).val);
                        exec_list *const f34C4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f34C4->then_instructions;

                           body.emit(assign(r34BB, add(r34BB, body.constant(int(4))), 0x01));

                           body.emit(assign(r34B9, lshift(r34B9, body.constant(int(4))), 0x01));


                        body.instructions = f34C4_parent_instructions;
                        body.emit(f34C4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r34C8 = bit_and(r34B9, body.constant(3221225472u));
                        ir_expression *const r34C9 = equal(r34C8, body.constant(0u));
                        ir_if *f34C7 = new(mem_ctx) ir_if(operand(r34C9).val);
                        exec_list *const f34C7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f34C7->then_instructions;

                           body.emit(assign(r34BB, add(r34BB, body.constant(int(2))), 0x01));

                           body.emit(assign(r34B9, lshift(r34B9, body.constant(int(2))), 0x01));


                        body.instructions = f34C7_parent_instructions;
                        body.emit(f34C7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r34CB = bit_and(r34B9, body.constant(2147483648u));
                        ir_expression *const r34CC = equal(r34CB, body.constant(0u));
                        ir_if *f34CA = new(mem_ctx) ir_if(operand(r34CC).val);
                        exec_list *const f34CA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f34CA->then_instructions;

                           body.emit(assign(r34BB, add(r34BB, body.constant(int(1))), 0x01));


                        body.instructions = f34CA_parent_instructions;
                        body.emit(f34CA);

                        /* END IF */

                        body.emit(assign(r34BA, r34BB, 0x01));


                     body.instructions = f34BC_parent_instructions;
                     body.emit(f34BC);

                     /* END IF */

                     body.emit(assign(r34B6, add(r34BA, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r34CE = less(r34B6, body.constant(int(0)));
                     ir_if *f34CD = new(mem_ctx) ir_if(operand(r34CE).val);
                     exec_list *const f34CD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f34CD->then_instructions;

                        ir_expression *const r34CF = neg(r34B6);
                        body.emit(assign(r34B4, rshift(swizzle_x(r33DD), r34CF), 0x01));

                        ir_expression *const r34D0 = bit_and(r34B6, body.constant(int(31)));
                        body.emit(assign(r34B5, lshift(swizzle_x(r33DD), r34D0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f34CD->else_instructions;

                        body.emit(assign(r34B4, lshift(swizzle_x(r33DD), r34B6), 0x01));

                        body.emit(assign(r34B5, body.constant(0u), 0x01));


                     body.instructions = f34CD_parent_instructions;
                     body.emit(f34CD);

                     /* END IF */

                     body.emit(assign(r34B3, sub(body.constant(int(-31)), r34B6), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f34B7->else_instructions;

                     ir_variable *const r34D1 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r34D1, r34B1, 0x01));

                     ir_variable *const r34D2 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r34D3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r34D3);
                     /* IF CONDITION */
                     ir_expression *const r34D5 = equal(swizzle_y(r33ED), body.constant(0u));
                     ir_if *f34D4 = new(mem_ctx) ir_if(operand(r34D5).val);
                     exec_list *const f34D4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f34D4->then_instructions;

                        body.emit(assign(r34D2, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f34D4->else_instructions;

                        body.emit(assign(r34D3, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r34D7 = bit_and(swizzle_y(r33ED), body.constant(4294901760u));
                        ir_expression *const r34D8 = equal(r34D7, body.constant(0u));
                        ir_if *f34D6 = new(mem_ctx) ir_if(operand(r34D8).val);
                        exec_list *const f34D6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f34D6->then_instructions;

                           body.emit(assign(r34D3, body.constant(int(16)), 0x01));

                           body.emit(assign(r34D1, lshift(swizzle_y(r33ED), body.constant(int(16))), 0x01));


                        body.instructions = f34D6_parent_instructions;
                        body.emit(f34D6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r34DA = bit_and(r34D1, body.constant(4278190080u));
                        ir_expression *const r34DB = equal(r34DA, body.constant(0u));
                        ir_if *f34D9 = new(mem_ctx) ir_if(operand(r34DB).val);
                        exec_list *const f34D9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f34D9->then_instructions;

                           body.emit(assign(r34D3, add(r34D3, body.constant(int(8))), 0x01));

                           body.emit(assign(r34D1, lshift(r34D1, body.constant(int(8))), 0x01));


                        body.instructions = f34D9_parent_instructions;
                        body.emit(f34D9);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r34DD = bit_and(r34D1, body.constant(4026531840u));
                        ir_expression *const r34DE = equal(r34DD, body.constant(0u));
                        ir_if *f34DC = new(mem_ctx) ir_if(operand(r34DE).val);
                        exec_list *const f34DC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f34DC->then_instructions;

                           body.emit(assign(r34D3, add(r34D3, body.constant(int(4))), 0x01));

                           body.emit(assign(r34D1, lshift(r34D1, body.constant(int(4))), 0x01));


                        body.instructions = f34DC_parent_instructions;
                        body.emit(f34DC);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r34E0 = bit_and(r34D1, body.constant(3221225472u));
                        ir_expression *const r34E1 = equal(r34E0, body.constant(0u));
                        ir_if *f34DF = new(mem_ctx) ir_if(operand(r34E1).val);
                        exec_list *const f34DF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f34DF->then_instructions;

                           body.emit(assign(r34D3, add(r34D3, body.constant(int(2))), 0x01));

                           body.emit(assign(r34D1, lshift(r34D1, body.constant(int(2))), 0x01));


                        body.instructions = f34DF_parent_instructions;
                        body.emit(f34DF);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r34E3 = bit_and(r34D1, body.constant(2147483648u));
                        ir_expression *const r34E4 = equal(r34E3, body.constant(0u));
                        ir_if *f34E2 = new(mem_ctx) ir_if(operand(r34E4).val);
                        exec_list *const f34E2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f34E2->then_instructions;

                           body.emit(assign(r34D3, add(r34D3, body.constant(int(1))), 0x01));


                        body.instructions = f34E2_parent_instructions;
                        body.emit(f34E2);

                        /* END IF */

                        body.emit(assign(r34D2, r34D3, 0x01));


                     body.instructions = f34D4_parent_instructions;
                     body.emit(f34D4);

                     /* END IF */

                     body.emit(assign(r34B6, add(r34D2, body.constant(int(-11))), 0x01));

                     ir_variable *const r34E5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r34E5, lshift(swizzle_x(r33DD), r34B6), 0x01));

                     ir_variable *const r34E6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r34E8 = equal(r34B6, body.constant(int(0)));
                     ir_if *f34E7 = new(mem_ctx) ir_if(operand(r34E8).val);
                     exec_list *const f34E7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f34E7->then_instructions;

                        body.emit(assign(r34E6, r34B1, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f34E7->else_instructions;

                        ir_expression *const r34E9 = lshift(swizzle_y(r33ED), r34B6);
                        ir_expression *const r34EA = neg(r34B6);
                        ir_expression *const r34EB = bit_and(r34EA, body.constant(int(31)));
                        ir_expression *const r34EC = rshift(swizzle_x(r33DD), r34EB);
                        body.emit(assign(r34E6, bit_or(r34E9, r34EC), 0x01));


                     body.instructions = f34E7_parent_instructions;
                     body.emit(f34E7);

                     /* END IF */

                     body.emit(assign(r34B4, r34E6, 0x01));

                     body.emit(assign(r34B5, r34E5, 0x01));

                     body.emit(assign(r34B3, sub(body.constant(int(1)), r34B6), 0x01));


                  body.instructions = f34B7_parent_instructions;
                  body.emit(f34B7);

                  /* END IF */

                  body.emit(assign(r33E4, r34B3, 0x01));

                  body.emit(assign(r33E5, r34B4, 0x02));

                  body.emit(assign(r33E5, r34B5, 0x01));


               body.instructions = f34AD_parent_instructions;
               body.emit(f34AD);

               /* END IF */


            body.instructions = f34AB_parent_instructions;
            body.emit(f34AB);

            /* END IF */

            /* IF CONDITION */
            ir_if *f34ED = new(mem_ctx) ir_if(operand(r33DF).val);
            exec_list *const f34ED_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f34ED->then_instructions;

               ir_expression *const r34EE = sub(r33E4, r33E2);
               body.emit(assign(r33EC, add(r34EE, body.constant(int(1021))), 0x01));

               ir_variable *const r34EF = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r34EF, lshift(swizzle_x(r33E5), body.constant(int(11))), 0x01));

               ir_variable *const r34F0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r34F1 = bit_or(swizzle_y(r33E5), body.constant(1048576u));
               ir_expression *const r34F2 = lshift(r34F1, body.constant(int(11)));
               ir_expression *const r34F3 = rshift(swizzle_x(r33E5), body.constant(int(21)));
               body.emit(assign(r34F0, bit_or(r34F2, r34F3), 0x01));

               body.emit(assign(r33E5, r34F0, 0x02));

               body.emit(assign(r33E5, r34EF, 0x01));

               ir_variable *const r34F4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r34F4, lshift(swizzle_x(r33E3), body.constant(int(11))), 0x01));

               ir_variable *const r34F5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r34F6 = bit_or(swizzle_y(r33E3), body.constant(1048576u));
               ir_expression *const r34F7 = lshift(r34F6, body.constant(int(11)));
               ir_expression *const r34F8 = rshift(swizzle_x(r33E3), body.constant(int(21)));
               body.emit(assign(r34F5, bit_or(r34F7, r34F8), 0x01));

               body.emit(assign(r33E3, r34F5, 0x02));

               body.emit(assign(r33E3, r34F4, 0x01));

               /* IF CONDITION */
               ir_expression *const r34FA = less(r34F5, r34F0);
               ir_expression *const r34FB = equal(r34F5, r34F0);
               ir_expression *const r34FC = lequal(r34F4, r34EF);
               ir_expression *const r34FD = logic_and(r34FB, r34FC);
               ir_expression *const r34FE = logic_or(r34FA, r34FD);
               ir_if *f34F9 = new(mem_ctx) ir_if(operand(r34FE).val);
               exec_list *const f34F9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f34F9->then_instructions;

                  body.emit(assign(r33E5, rshift(r34F0, body.constant(int(1))), 0x02));

                  ir_expression *const r34FF = lshift(r34F0, body.constant(int(31)));
                  ir_expression *const r3500 = rshift(r34EF, body.constant(int(1)));
                  body.emit(assign(r33E5, bit_or(r34FF, r3500), 0x01));

                  body.emit(assign(r33EC, add(r33EC, body.constant(int(1))), 0x01));


               body.instructions = f34F9_parent_instructions;
               body.emit(f34F9);

               /* END IF */

               ir_variable *const r3501 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r3502 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r3502);
               ir_variable *const r3503 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r3503);
               ir_variable *const r3504 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r3504);
               ir_variable *const r3505 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r3505);
               body.emit(assign(r3504, body.constant(0u), 0x01));

               body.emit(assign(r3503, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r3507 = lequal(r34F5, swizzle_y(r33E5));
               ir_if *f3506 = new(mem_ctx) ir_if(operand(r3507).val);
               exec_list *const f3506_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3506->then_instructions;

                  body.emit(assign(r3501, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3506->else_instructions;

                  body.emit(assign(r3505, rshift(r34F5, body.constant(int(16))), 0x01));

                  ir_variable *const r3508 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r350A = lshift(r3505, body.constant(int(16)));
                  ir_expression *const r350B = lequal(r350A, swizzle_y(r33E5));
                  ir_if *f3509 = new(mem_ctx) ir_if(operand(r350B).val);
                  exec_list *const f3509_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3509->then_instructions;

                     body.emit(assign(r3508, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3509->else_instructions;

                     ir_expression *const r350C = expr(ir_binop_div, swizzle_y(r33E5), r3505);
                     body.emit(assign(r3508, lshift(r350C, body.constant(int(16))), 0x01));


                  body.instructions = f3509_parent_instructions;
                  body.emit(f3509);

                  /* END IF */

                  body.emit(assign(r3502, r3508, 0x01));

                  ir_variable *const r350D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r350D);
                  ir_variable *const r350E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r350E);
                  ir_variable *const r350F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r350F);
                  ir_variable *const r3510 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3510, bit_and(r34F5, body.constant(65535u)), 0x01));

                  ir_variable *const r3511 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3511, rshift(r34F5, body.constant(int(16))), 0x01));

                  ir_variable *const r3512 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3512, bit_and(r3508, body.constant(65535u)), 0x01));

                  ir_variable *const r3513 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3513, rshift(r3508, body.constant(int(16))), 0x01));

                  ir_variable *const r3514 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3514, mul(r3511, r3512), 0x01));

                  ir_expression *const r3515 = mul(r3510, r3513);
                  body.emit(assign(r350E, add(r3515, r3514), 0x01));

                  ir_expression *const r3516 = mul(r3511, r3513);
                  ir_expression *const r3517 = less(r350E, r3514);
                  ir_expression *const r3518 = expr(ir_unop_b2i, r3517);
                  ir_expression *const r3519 = expr(ir_unop_i2u, r3518);
                  ir_expression *const r351A = lshift(r3519, body.constant(int(16)));
                  ir_expression *const r351B = rshift(r350E, body.constant(int(16)));
                  ir_expression *const r351C = add(r351A, r351B);
                  body.emit(assign(r350D, add(r3516, r351C), 0x01));

                  body.emit(assign(r350E, lshift(r350E, body.constant(int(16))), 0x01));

                  ir_expression *const r351D = mul(r3510, r3512);
                  body.emit(assign(r350F, add(r351D, r350E), 0x01));

                  ir_expression *const r351E = less(r350F, r350E);
                  ir_expression *const r351F = expr(ir_unop_b2i, r351E);
                  ir_expression *const r3520 = expr(ir_unop_i2u, r351F);
                  body.emit(assign(r350D, add(r350D, r3520), 0x01));

                  ir_expression *const r3521 = sub(swizzle_y(r33E5), r350D);
                  ir_expression *const r3522 = less(swizzle_x(r33E5), r350F);
                  ir_expression *const r3523 = expr(ir_unop_b2i, r3522);
                  ir_expression *const r3524 = expr(ir_unop_i2u, r3523);
                  body.emit(assign(r3504, sub(r3521, r3524), 0x01));

                  body.emit(assign(r3503, sub(swizzle_x(r33E5), r350F), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f3525 = new(mem_ctx) ir_loop();
                  exec_list *const f3525_parent_instructions = body.instructions;

                     body.instructions = &f3525->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3527 = expr(ir_unop_u2i, r3504);
                     ir_expression *const r3528 = gequal(r3527, body.constant(int(0)));
                     ir_if *f3526 = new(mem_ctx) ir_if(operand(r3528).val);
                     exec_list *const f3526_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3526->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f3526_parent_instructions;
                     body.emit(f3526);

                     /* END IF */

                     body.emit(assign(r3502, add(r3502, body.constant(4294901760u)), 0x01));

                     ir_variable *const r3529 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r352A = lshift(r34F5, body.constant(int(16)));
                     body.emit(assign(r3529, add(r3503, r352A), 0x01));

                     ir_expression *const r352B = add(r3504, r3505);
                     ir_expression *const r352C = less(r3529, r3503);
                     ir_expression *const r352D = expr(ir_unop_b2i, r352C);
                     ir_expression *const r352E = expr(ir_unop_i2u, r352D);
                     body.emit(assign(r3504, add(r352B, r352E), 0x01));

                     body.emit(assign(r3503, r3529, 0x01));

                  /* LOOP END */

                  body.instructions = f3525_parent_instructions;
                  body.emit(f3525);

                  ir_expression *const r352F = lshift(r3504, body.constant(int(16)));
                  ir_expression *const r3530 = rshift(r3503, body.constant(int(16)));
                  body.emit(assign(r3504, bit_or(r352F, r3530), 0x01));

                  ir_variable *const r3531 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3533 = lshift(r3505, body.constant(int(16)));
                  ir_expression *const r3534 = lequal(r3533, r3504);
                  ir_if *f3532 = new(mem_ctx) ir_if(operand(r3534).val);
                  exec_list *const f3532_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3532->then_instructions;

                     body.emit(assign(r3531, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3532->else_instructions;

                     body.emit(assign(r3531, expr(ir_binop_div, r3504, r3505), 0x01));


                  body.instructions = f3532_parent_instructions;
                  body.emit(f3532);

                  /* END IF */

                  body.emit(assign(r3502, bit_or(r3502, r3531), 0x01));

                  body.emit(assign(r3501, r3502, 0x01));


               body.instructions = f3506_parent_instructions;
               body.emit(f3506);

               /* END IF */

               body.emit(assign(r33EB, r3501, 0x01));

               ir_variable *const r3535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3535);
               ir_variable *const r3536 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3536);
               ir_variable *const r3537 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3537);
               ir_variable *const r3538 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3538, bit_and(r34F4, body.constant(65535u)), 0x01));

               ir_variable *const r3539 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3539, rshift(r34F4, body.constant(int(16))), 0x01));

               ir_variable *const r353A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r353A, bit_and(r3501, body.constant(65535u)), 0x01));

               ir_variable *const r353B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r353B, rshift(r3501, body.constant(int(16))), 0x01));

               ir_variable *const r353C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r353C, mul(r3539, r353A), 0x01));

               ir_expression *const r353D = mul(r3538, r353B);
               body.emit(assign(r3536, add(r353D, r353C), 0x01));

               ir_expression *const r353E = mul(r3539, r353B);
               ir_expression *const r353F = less(r3536, r353C);
               ir_expression *const r3540 = expr(ir_unop_b2i, r353F);
               ir_expression *const r3541 = expr(ir_unop_i2u, r3540);
               ir_expression *const r3542 = lshift(r3541, body.constant(int(16)));
               ir_expression *const r3543 = rshift(r3536, body.constant(int(16)));
               ir_expression *const r3544 = add(r3542, r3543);
               body.emit(assign(r3535, add(r353E, r3544), 0x01));

               body.emit(assign(r3536, lshift(r3536, body.constant(int(16))), 0x01));

               ir_expression *const r3545 = mul(r3538, r353A);
               body.emit(assign(r3537, add(r3545, r3536), 0x01));

               ir_expression *const r3546 = less(r3537, r3536);
               ir_expression *const r3547 = expr(ir_unop_b2i, r3546);
               ir_expression *const r3548 = expr(ir_unop_i2u, r3547);
               body.emit(assign(r3535, add(r3535, r3548), 0x01));

               ir_variable *const r3549 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3549);
               ir_variable *const r354A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r354A);
               ir_variable *const r354B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r354B);
               ir_variable *const r354C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r354C, bit_and(r34F5, body.constant(65535u)), 0x01));

               ir_variable *const r354D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r354D, rshift(r34F5, body.constant(int(16))), 0x01));

               ir_variable *const r354E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r354E, bit_and(r3501, body.constant(65535u)), 0x01));

               ir_variable *const r354F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r354F, rshift(r3501, body.constant(int(16))), 0x01));

               ir_variable *const r3550 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3550, mul(r354D, r354E), 0x01));

               ir_expression *const r3551 = mul(r354C, r354F);
               body.emit(assign(r354A, add(r3551, r3550), 0x01));

               ir_expression *const r3552 = mul(r354D, r354F);
               ir_expression *const r3553 = less(r354A, r3550);
               ir_expression *const r3554 = expr(ir_unop_b2i, r3553);
               ir_expression *const r3555 = expr(ir_unop_i2u, r3554);
               ir_expression *const r3556 = lshift(r3555, body.constant(int(16)));
               ir_expression *const r3557 = rshift(r354A, body.constant(int(16)));
               ir_expression *const r3558 = add(r3556, r3557);
               body.emit(assign(r3549, add(r3552, r3558), 0x01));

               body.emit(assign(r354A, lshift(r354A, body.constant(int(16))), 0x01));

               ir_expression *const r3559 = mul(r354C, r354E);
               body.emit(assign(r354B, add(r3559, r354A), 0x01));

               ir_expression *const r355A = less(r354B, r354A);
               ir_expression *const r355B = expr(ir_unop_b2i, r355A);
               ir_expression *const r355C = expr(ir_unop_i2u, r355B);
               body.emit(assign(r3549, add(r3549, r355C), 0x01));

               ir_variable *const r355D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r355D, add(r354B, r3535), 0x01));

               ir_variable *const r355E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r355E);
               ir_variable *const r355F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r3560 = less(body.constant(0u), r3537);
               ir_expression *const r3561 = expr(ir_unop_b2i, r3560);
               body.emit(assign(r355F, expr(ir_unop_i2u, r3561), 0x01));

               ir_variable *const r3562 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3562, sub(swizzle_x(r33E5), r355D), 0x01));

               ir_expression *const r3563 = less(r355D, r354B);
               ir_expression *const r3564 = expr(ir_unop_b2i, r3563);
               ir_expression *const r3565 = expr(ir_unop_i2u, r3564);
               ir_expression *const r3566 = add(r3549, r3565);
               ir_expression *const r3567 = sub(swizzle_y(r33E5), r3566);
               ir_expression *const r3568 = less(r3562, r355F);
               ir_expression *const r3569 = expr(ir_unop_b2i, r3568);
               ir_expression *const r356A = expr(ir_unop_i2u, r3569);
               body.emit(assign(r355E, sub(r3567, r356A), 0x01));

               ir_expression *const r356B = less(swizzle_x(r33E5), r355D);
               ir_expression *const r356C = expr(ir_unop_b2i, r356B);
               ir_expression *const r356D = expr(ir_unop_i2u, r356C);
               body.emit(assign(r355E, sub(r355E, r356D), 0x01));

               body.emit(assign(r33E9, r355E, 0x01));

               body.emit(assign(r33E8, sub(r3562, r355F), 0x01));

               body.emit(assign(r33E7, neg(r3537), 0x01));

               /* LOOP BEGIN */
               ir_loop *f356E = new(mem_ctx) ir_loop();
               exec_list *const f356E_parent_instructions = body.instructions;

                  body.instructions = &f356E->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3570 = expr(ir_unop_u2i, r33E9);
                  ir_expression *const r3571 = gequal(r3570, body.constant(int(0)));
                  ir_if *f356F = new(mem_ctx) ir_if(operand(r3571).val);
                  exec_list *const f356F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f356F->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f356F_parent_instructions;
                  body.emit(f356F);

                  /* END IF */

                  body.emit(assign(r33EB, add(r33EB, body.constant(4294967295u)), 0x01));

                  ir_variable *const r3572 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3572);
                  ir_variable *const r3573 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3573);
                  ir_variable *const r3574 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3574, add(r33E7, r34F4), 0x01));

                  ir_variable *const r3575 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r3576 = less(r3574, r33E7);
                  ir_expression *const r3577 = expr(ir_unop_b2i, r3576);
                  body.emit(assign(r3575, expr(ir_unop_i2u, r3577), 0x01));

                  ir_variable *const r3578 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3578, add(r33E8, r34F5), 0x01));

                  body.emit(assign(r3573, add(r3578, r3575), 0x01));

                  ir_expression *const r3579 = less(r3573, r3575);
                  ir_expression *const r357A = expr(ir_unop_b2i, r3579);
                  ir_expression *const r357B = expr(ir_unop_i2u, r357A);
                  body.emit(assign(r3572, add(r33E9, r357B), 0x01));

                  ir_expression *const r357C = less(r3578, r33E8);
                  ir_expression *const r357D = expr(ir_unop_b2i, r357C);
                  ir_expression *const r357E = expr(ir_unop_i2u, r357D);
                  body.emit(assign(r3572, add(r3572, r357E), 0x01));

                  body.emit(assign(r33E9, r3572, 0x01));

                  body.emit(assign(r33E8, r3573, 0x01));

                  body.emit(assign(r33E7, r3574, 0x01));

               /* LOOP END */

               body.instructions = f356E_parent_instructions;
               body.emit(f356E);

               ir_variable *const r357F = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r3580 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r3580);
               ir_variable *const r3581 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r3581);
               ir_variable *const r3582 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r3582);
               ir_variable *const r3583 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r3583);
               body.emit(assign(r3582, body.constant(0u), 0x01));

               body.emit(assign(r3581, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r3585 = lequal(r34F5, r33E8);
               ir_if *f3584 = new(mem_ctx) ir_if(operand(r3585).val);
               exec_list *const f3584_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3584->then_instructions;

                  body.emit(assign(r357F, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3584->else_instructions;

                  body.emit(assign(r3583, rshift(r34F5, body.constant(int(16))), 0x01));

                  ir_variable *const r3586 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3588 = lshift(r3583, body.constant(int(16)));
                  ir_expression *const r3589 = lequal(r3588, r33E8);
                  ir_if *f3587 = new(mem_ctx) ir_if(operand(r3589).val);
                  exec_list *const f3587_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3587->then_instructions;

                     body.emit(assign(r3586, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3587->else_instructions;

                     ir_expression *const r358A = expr(ir_binop_div, r33E8, r3583);
                     body.emit(assign(r3586, lshift(r358A, body.constant(int(16))), 0x01));


                  body.instructions = f3587_parent_instructions;
                  body.emit(f3587);

                  /* END IF */

                  body.emit(assign(r3580, r3586, 0x01));

                  ir_variable *const r358B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r358B);
                  ir_variable *const r358C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r358C);
                  ir_variable *const r358D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r358D);
                  ir_variable *const r358E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r358E, bit_and(r34F5, body.constant(65535u)), 0x01));

                  ir_variable *const r358F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r358F, rshift(r34F5, body.constant(int(16))), 0x01));

                  ir_variable *const r3590 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3590, bit_and(r3586, body.constant(65535u)), 0x01));

                  ir_variable *const r3591 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3591, rshift(r3586, body.constant(int(16))), 0x01));

                  ir_variable *const r3592 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3592, mul(r358F, r3590), 0x01));

                  ir_expression *const r3593 = mul(r358E, r3591);
                  body.emit(assign(r358C, add(r3593, r3592), 0x01));

                  ir_expression *const r3594 = mul(r358F, r3591);
                  ir_expression *const r3595 = less(r358C, r3592);
                  ir_expression *const r3596 = expr(ir_unop_b2i, r3595);
                  ir_expression *const r3597 = expr(ir_unop_i2u, r3596);
                  ir_expression *const r3598 = lshift(r3597, body.constant(int(16)));
                  ir_expression *const r3599 = rshift(r358C, body.constant(int(16)));
                  ir_expression *const r359A = add(r3598, r3599);
                  body.emit(assign(r358B, add(r3594, r359A), 0x01));

                  body.emit(assign(r358C, lshift(r358C, body.constant(int(16))), 0x01));

                  ir_expression *const r359B = mul(r358E, r3590);
                  body.emit(assign(r358D, add(r359B, r358C), 0x01));

                  ir_expression *const r359C = less(r358D, r358C);
                  ir_expression *const r359D = expr(ir_unop_b2i, r359C);
                  ir_expression *const r359E = expr(ir_unop_i2u, r359D);
                  body.emit(assign(r358B, add(r358B, r359E), 0x01));

                  ir_expression *const r359F = sub(r33E8, r358B);
                  ir_expression *const r35A0 = less(r33E7, r358D);
                  ir_expression *const r35A1 = expr(ir_unop_b2i, r35A0);
                  ir_expression *const r35A2 = expr(ir_unop_i2u, r35A1);
                  body.emit(assign(r3582, sub(r359F, r35A2), 0x01));

                  body.emit(assign(r3581, sub(r33E7, r358D), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f35A3 = new(mem_ctx) ir_loop();
                  exec_list *const f35A3_parent_instructions = body.instructions;

                     body.instructions = &f35A3->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r35A5 = expr(ir_unop_u2i, r3582);
                     ir_expression *const r35A6 = gequal(r35A5, body.constant(int(0)));
                     ir_if *f35A4 = new(mem_ctx) ir_if(operand(r35A6).val);
                     exec_list *const f35A4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f35A4->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f35A4_parent_instructions;
                     body.emit(f35A4);

                     /* END IF */

                     body.emit(assign(r3580, add(r3580, body.constant(4294901760u)), 0x01));

                     ir_variable *const r35A7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r35A8 = lshift(r34F5, body.constant(int(16)));
                     body.emit(assign(r35A7, add(r3581, r35A8), 0x01));

                     ir_expression *const r35A9 = add(r3582, r3583);
                     ir_expression *const r35AA = less(r35A7, r3581);
                     ir_expression *const r35AB = expr(ir_unop_b2i, r35AA);
                     ir_expression *const r35AC = expr(ir_unop_i2u, r35AB);
                     body.emit(assign(r3582, add(r35A9, r35AC), 0x01));

                     body.emit(assign(r3581, r35A7, 0x01));

                  /* LOOP END */

                  body.instructions = f35A3_parent_instructions;
                  body.emit(f35A3);

                  ir_expression *const r35AD = lshift(r3582, body.constant(int(16)));
                  ir_expression *const r35AE = rshift(r3581, body.constant(int(16)));
                  body.emit(assign(r3582, bit_or(r35AD, r35AE), 0x01));

                  ir_variable *const r35AF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r35B1 = lshift(r3583, body.constant(int(16)));
                  ir_expression *const r35B2 = lequal(r35B1, r3582);
                  ir_if *f35B0 = new(mem_ctx) ir_if(operand(r35B2).val);
                  exec_list *const f35B0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35B0->then_instructions;

                     body.emit(assign(r35AF, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f35B0->else_instructions;

                     body.emit(assign(r35AF, expr(ir_binop_div, r3582, r3583), 0x01));


                  body.instructions = f35B0_parent_instructions;
                  body.emit(f35B0);

                  /* END IF */

                  body.emit(assign(r3580, bit_or(r3580, r35AF), 0x01));

                  body.emit(assign(r357F, r3580, 0x01));


               body.instructions = f3584_parent_instructions;
               body.emit(f3584);

               /* END IF */

               body.emit(assign(r33EA, r357F, 0x01));

               /* IF CONDITION */
               ir_expression *const r35B4 = bit_and(r357F, body.constant(1023u));
               ir_expression *const r35B5 = lequal(r35B4, body.constant(4u));
               ir_if *f35B3 = new(mem_ctx) ir_if(operand(r35B5).val);
               exec_list *const f35B3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35B3->then_instructions;

                  ir_variable *const r35B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r35B6);
                  ir_variable *const r35B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r35B7);
                  ir_variable *const r35B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r35B8);
                  ir_variable *const r35B9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r35B9, bit_and(r34F4, body.constant(65535u)), 0x01));

                  ir_variable *const r35BA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r35BA, rshift(r34F4, body.constant(int(16))), 0x01));

                  ir_variable *const r35BB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r35BB, bit_and(r357F, body.constant(65535u)), 0x01));

                  ir_variable *const r35BC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r35BC, rshift(r357F, body.constant(int(16))), 0x01));

                  ir_variable *const r35BD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r35BD, mul(r35BA, r35BB), 0x01));

                  ir_expression *const r35BE = mul(r35B9, r35BC);
                  body.emit(assign(r35B7, add(r35BE, r35BD), 0x01));

                  ir_expression *const r35BF = mul(r35BA, r35BC);
                  ir_expression *const r35C0 = less(r35B7, r35BD);
                  ir_expression *const r35C1 = expr(ir_unop_b2i, r35C0);
                  ir_expression *const r35C2 = expr(ir_unop_i2u, r35C1);
                  ir_expression *const r35C3 = lshift(r35C2, body.constant(int(16)));
                  ir_expression *const r35C4 = rshift(r35B7, body.constant(int(16)));
                  ir_expression *const r35C5 = add(r35C3, r35C4);
                  body.emit(assign(r35B6, add(r35BF, r35C5), 0x01));

                  body.emit(assign(r35B7, lshift(r35B7, body.constant(int(16))), 0x01));

                  ir_expression *const r35C6 = mul(r35B9, r35BB);
                  body.emit(assign(r35B8, add(r35C6, r35B7), 0x01));

                  ir_expression *const r35C7 = less(r35B8, r35B7);
                  ir_expression *const r35C8 = expr(ir_unop_b2i, r35C7);
                  ir_expression *const r35C9 = expr(ir_unop_i2u, r35C8);
                  body.emit(assign(r35B6, add(r35B6, r35C9), 0x01));

                  ir_variable *const r35CA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r35CA);
                  ir_variable *const r35CB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r35CB);
                  ir_variable *const r35CC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r35CC);
                  ir_variable *const r35CD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r35CD, bit_and(r34F5, body.constant(65535u)), 0x01));

                  ir_variable *const r35CE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r35CE, rshift(r34F5, body.constant(int(16))), 0x01));

                  ir_variable *const r35CF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r35CF, bit_and(r357F, body.constant(65535u)), 0x01));

                  ir_variable *const r35D0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r35D0, rshift(r357F, body.constant(int(16))), 0x01));

                  ir_variable *const r35D1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r35D1, mul(r35CE, r35CF), 0x01));

                  ir_expression *const r35D2 = mul(r35CD, r35D0);
                  body.emit(assign(r35CB, add(r35D2, r35D1), 0x01));

                  ir_expression *const r35D3 = mul(r35CE, r35D0);
                  ir_expression *const r35D4 = less(r35CB, r35D1);
                  ir_expression *const r35D5 = expr(ir_unop_b2i, r35D4);
                  ir_expression *const r35D6 = expr(ir_unop_i2u, r35D5);
                  ir_expression *const r35D7 = lshift(r35D6, body.constant(int(16)));
                  ir_expression *const r35D8 = rshift(r35CB, body.constant(int(16)));
                  ir_expression *const r35D9 = add(r35D7, r35D8);
                  body.emit(assign(r35CA, add(r35D3, r35D9), 0x01));

                  body.emit(assign(r35CB, lshift(r35CB, body.constant(int(16))), 0x01));

                  ir_expression *const r35DA = mul(r35CD, r35CF);
                  body.emit(assign(r35CC, add(r35DA, r35CB), 0x01));

                  ir_expression *const r35DB = less(r35CC, r35CB);
                  ir_expression *const r35DC = expr(ir_unop_b2i, r35DB);
                  ir_expression *const r35DD = expr(ir_unop_i2u, r35DC);
                  body.emit(assign(r35CA, add(r35CA, r35DD), 0x01));

                  ir_variable *const r35DE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r35DE, add(r35CC, r35B6), 0x01));

                  ir_variable *const r35DF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r35DF);
                  ir_variable *const r35E0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r35E1 = less(body.constant(0u), r35B8);
                  ir_expression *const r35E2 = expr(ir_unop_b2i, r35E1);
                  body.emit(assign(r35E0, expr(ir_unop_i2u, r35E2), 0x01));

                  ir_variable *const r35E3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r35E3, sub(r33E7, r35DE), 0x01));

                  ir_expression *const r35E4 = less(r35DE, r35CC);
                  ir_expression *const r35E5 = expr(ir_unop_b2i, r35E4);
                  ir_expression *const r35E6 = expr(ir_unop_i2u, r35E5);
                  ir_expression *const r35E7 = add(r35CA, r35E6);
                  ir_expression *const r35E8 = sub(r33E8, r35E7);
                  ir_expression *const r35E9 = less(r35E3, r35E0);
                  ir_expression *const r35EA = expr(ir_unop_b2i, r35E9);
                  ir_expression *const r35EB = expr(ir_unop_i2u, r35EA);
                  body.emit(assign(r35DF, sub(r35E8, r35EB), 0x01));

                  ir_expression *const r35EC = less(r33E7, r35DE);
                  ir_expression *const r35ED = expr(ir_unop_b2i, r35EC);
                  ir_expression *const r35EE = expr(ir_unop_i2u, r35ED);
                  body.emit(assign(r35DF, sub(r35DF, r35EE), 0x01));

                  body.emit(assign(r33E8, r35DF, 0x01));

                  body.emit(assign(r33E7, sub(r35E3, r35E0), 0x01));

                  body.emit(assign(r33E6, neg(r35B8), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f35EF = new(mem_ctx) ir_loop();
                  exec_list *const f35EF_parent_instructions = body.instructions;

                     body.instructions = &f35EF->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r35F1 = expr(ir_unop_u2i, r33E8);
                     ir_expression *const r35F2 = gequal(r35F1, body.constant(int(0)));
                     ir_if *f35F0 = new(mem_ctx) ir_if(operand(r35F2).val);
                     exec_list *const f35F0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f35F0->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f35F0_parent_instructions;
                     body.emit(f35F0);

                     /* END IF */

                     body.emit(assign(r33EA, add(r33EA, body.constant(4294967295u)), 0x01));

                     ir_variable *const r35F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r35F3);
                     ir_variable *const r35F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r35F4);
                     ir_variable *const r35F5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r35F5, add(r33E6, r34F4), 0x01));

                     ir_variable *const r35F6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r35F7 = less(r35F5, r33E6);
                     ir_expression *const r35F8 = expr(ir_unop_b2i, r35F7);
                     body.emit(assign(r35F6, expr(ir_unop_i2u, r35F8), 0x01));

                     ir_variable *const r35F9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r35F9, add(r33E7, r34F5), 0x01));

                     body.emit(assign(r35F4, add(r35F9, r35F6), 0x01));

                     ir_expression *const r35FA = less(r35F4, r35F6);
                     ir_expression *const r35FB = expr(ir_unop_b2i, r35FA);
                     ir_expression *const r35FC = expr(ir_unop_i2u, r35FB);
                     body.emit(assign(r35F3, add(r33E8, r35FC), 0x01));

                     ir_expression *const r35FD = less(r35F9, r33E7);
                     ir_expression *const r35FE = expr(ir_unop_b2i, r35FD);
                     ir_expression *const r35FF = expr(ir_unop_i2u, r35FE);
                     body.emit(assign(r35F3, add(r35F3, r35FF), 0x01));

                     body.emit(assign(r33E8, r35F3, 0x01));

                     body.emit(assign(r33E7, r35F4, 0x01));

                     body.emit(assign(r33E6, r35F5, 0x01));

                  /* LOOP END */

                  body.instructions = f35EF_parent_instructions;
                  body.emit(f35EF);

                  ir_expression *const r3600 = bit_or(r33E8, r33E7);
                  ir_expression *const r3601 = bit_or(r3600, r33E6);
                  ir_expression *const r3602 = nequal(r3601, body.constant(0u));
                  ir_expression *const r3603 = expr(ir_unop_b2i, r3602);
                  ir_expression *const r3604 = expr(ir_unop_i2u, r3603);
                  body.emit(assign(r33EA, bit_or(r33EA, r3604), 0x01));


               body.instructions = f35B3_parent_instructions;
               body.emit(f35B3);

               /* END IF */

               ir_variable *const r3605 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r3605);
               ir_variable *const r3606 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3606);
               ir_variable *const r3607 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3607);
               body.emit(assign(r3605, lshift(r33EA, body.constant(int(21))), 0x01));

               ir_expression *const r3608 = lshift(r33EB, body.constant(int(21)));
               ir_expression *const r3609 = rshift(r33EA, body.constant(int(11)));
               body.emit(assign(r3606, bit_or(r3608, r3609), 0x01));

               body.emit(assign(r3607, rshift(r33EB, body.constant(int(11))), 0x01));

               body.emit(assign(r3605, bit_or(r3605, body.constant(0u)), 0x01));

               body.emit(assign(r33EB, r3607, 0x01));

               body.emit(assign(r33EA, r3606, 0x01));

               ir_variable *const r360A = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r360A, r33EC, 0x01));

               ir_variable *const r360B = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r360B, r3607, 0x01));

               ir_variable *const r360C = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r360C, r3606, 0x01));

               ir_variable *const r360D = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r360D, r3605, 0x01));

               ir_variable *const r360E = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r360E, body.constant(true), 0x01));

               ir_variable *const r360F = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3610 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3610);
               ir_expression *const r3611 = expr(ir_unop_u2i, r3605);
               body.emit(assign(r3610, less(r3611, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3613 = lequal(body.constant(int(2045)), r33EC);
               ir_if *f3612 = new(mem_ctx) ir_if(operand(r3613).val);
               exec_list *const f3612_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3612->then_instructions;

                  ir_variable *const r3614 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3616 = less(body.constant(int(2045)), r33EC);
                  ir_if *f3615 = new(mem_ctx) ir_if(operand(r3616).val);
                  exec_list *const f3615_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3615->then_instructions;

                     body.emit(assign(r3614, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3615->else_instructions;

                     ir_variable *const r3617 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3619 = equal(r33EC, body.constant(int(2045)));
                     ir_if *f3618 = new(mem_ctx) ir_if(operand(r3619).val);
                     exec_list *const f3618_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3618->then_instructions;

                        ir_expression *const r361A = equal(body.constant(2097151u), r3607);
                        ir_expression *const r361B = equal(body.constant(4294967295u), r3606);
                        body.emit(assign(r3617, logic_and(r361A, r361B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3618->else_instructions;

                        body.emit(assign(r3617, body.constant(false), 0x01));


                     body.instructions = f3618_parent_instructions;
                     body.emit(f3618);

                     /* END IF */

                     body.emit(assign(r3614, logic_and(r3617, r3610), 0x01));


                  body.instructions = f3615_parent_instructions;
                  body.emit(f3615);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f361C = new(mem_ctx) ir_if(operand(r3614).val);
                  exec_list *const f361C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f361C->then_instructions;

                     ir_variable *const r361D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r361D);
                     ir_expression *const r361E = lshift(r33E1, body.constant(int(31)));
                     body.emit(assign(r361D, add(r361E, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r361D, body.constant(0u), 0x01));

                     body.emit(assign(r360F, r361D, 0x03));

                     body.emit(assign(r360E, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f361C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3620 = less(r33EC, body.constant(int(0)));
                     ir_if *f361F = new(mem_ctx) ir_if(operand(r3620).val);
                     exec_list *const f361F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f361F->then_instructions;

                        ir_variable *const r3621 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3621, r3605, 0x01));

                        ir_variable *const r3622 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3622, neg(r33EC), 0x01));

                        ir_variable *const r3623 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3623);
                        ir_variable *const r3624 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3624);
                        ir_variable *const r3625 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3625);
                        ir_variable *const r3626 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3627 = neg(r3622);
                        body.emit(assign(r3626, bit_and(r3627, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3629 = equal(r3622, body.constant(int(0)));
                        ir_if *f3628 = new(mem_ctx) ir_if(operand(r3629).val);
                        exec_list *const f3628_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3628->then_instructions;

                           body.emit(assign(r3623, r3605, 0x01));

                           body.emit(assign(r3624, r3606, 0x01));

                           body.emit(assign(r3625, r3607, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3628->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r362B = less(r3622, body.constant(int(32)));
                           ir_if *f362A = new(mem_ctx) ir_if(operand(r362B).val);
                           exec_list *const f362A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f362A->then_instructions;

                              body.emit(assign(r3623, lshift(r3606, r3626), 0x01));

                              ir_expression *const r362C = lshift(r3607, r3626);
                              ir_expression *const r362D = rshift(r3606, r3622);
                              body.emit(assign(r3624, bit_or(r362C, r362D), 0x01));

                              body.emit(assign(r3625, rshift(r3607, r3622), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f362A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r362F = equal(r3622, body.constant(int(32)));
                              ir_if *f362E = new(mem_ctx) ir_if(operand(r362F).val);
                              exec_list *const f362E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f362E->then_instructions;

                                 body.emit(assign(r3623, r3606, 0x01));

                                 body.emit(assign(r3624, r3607, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f362E->else_instructions;

                                 body.emit(assign(r3621, bit_or(r3605, r3606), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3631 = less(r3622, body.constant(int(64)));
                                 ir_if *f3630 = new(mem_ctx) ir_if(operand(r3631).val);
                                 exec_list *const f3630_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3630->then_instructions;

                                    body.emit(assign(r3623, lshift(r3607, r3626), 0x01));

                                    ir_expression *const r3632 = bit_and(r3622, body.constant(int(31)));
                                    body.emit(assign(r3624, rshift(r3607, r3632), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3630->else_instructions;

                                    ir_variable *const r3633 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3635 = equal(r3622, body.constant(int(64)));
                                    ir_if *f3634 = new(mem_ctx) ir_if(operand(r3635).val);
                                    exec_list *const f3634_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3634->then_instructions;

                                       body.emit(assign(r3633, r3607, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3634->else_instructions;

                                       ir_expression *const r3636 = nequal(r3607, body.constant(0u));
                                       ir_expression *const r3637 = expr(ir_unop_b2i, r3636);
                                       body.emit(assign(r3633, expr(ir_unop_i2u, r3637), 0x01));


                                    body.instructions = f3634_parent_instructions;
                                    body.emit(f3634);

                                    /* END IF */

                                    body.emit(assign(r3623, r3633, 0x01));

                                    body.emit(assign(r3624, body.constant(0u), 0x01));


                                 body.instructions = f3630_parent_instructions;
                                 body.emit(f3630);

                                 /* END IF */


                              body.instructions = f362E_parent_instructions;
                              body.emit(f362E);

                              /* END IF */

                              body.emit(assign(r3625, body.constant(0u), 0x01));


                           body.instructions = f362A_parent_instructions;
                           body.emit(f362A);

                           /* END IF */

                           ir_expression *const r3638 = nequal(r3621, body.constant(0u));
                           ir_expression *const r3639 = expr(ir_unop_b2i, r3638);
                           ir_expression *const r363A = expr(ir_unop_i2u, r3639);
                           body.emit(assign(r3623, bit_or(r3623, r363A), 0x01));


                        body.instructions = f3628_parent_instructions;
                        body.emit(f3628);

                        /* END IF */

                        body.emit(assign(r360B, r3625, 0x01));

                        body.emit(assign(r360C, r3624, 0x01));

                        body.emit(assign(r360D, r3623, 0x01));

                        body.emit(assign(r360A, body.constant(int(0)), 0x01));

                        body.emit(assign(r3610, less(r3623, body.constant(0u)), 0x01));


                     body.instructions = f361F_parent_instructions;
                     body.emit(f361F);

                     /* END IF */


                  body.instructions = f361C_parent_instructions;
                  body.emit(f361C);

                  /* END IF */


               body.instructions = f3612_parent_instructions;
               body.emit(f3612);

               /* END IF */

               /* IF CONDITION */
               ir_if *f363B = new(mem_ctx) ir_if(operand(r360E).val);
               exec_list *const f363B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f363B->then_instructions;

                  /* IF CONDITION */
                  ir_if *f363C = new(mem_ctx) ir_if(operand(r3610).val);
                  exec_list *const f363C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f363C->then_instructions;

                     ir_variable *const r363D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r363D, add(r360C, body.constant(1u)), 0x01));

                     ir_expression *const r363E = less(r363D, r360C);
                     ir_expression *const r363F = expr(ir_unop_b2i, r363E);
                     ir_expression *const r3640 = expr(ir_unop_i2u, r363F);
                     body.emit(assign(r360B, add(r360B, r3640), 0x01));

                     ir_expression *const r3641 = equal(r360D, body.constant(0u));
                     ir_expression *const r3642 = expr(ir_unop_b2i, r3641);
                     ir_expression *const r3643 = expr(ir_unop_i2u, r3642);
                     ir_expression *const r3644 = add(r360D, r3643);
                     ir_expression *const r3645 = bit_and(r3644, body.constant(1u));
                     ir_expression *const r3646 = expr(ir_unop_bit_not, r3645);
                     body.emit(assign(r360C, bit_and(r363D, r3646), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f363C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3648 = bit_or(r360B, r360C);
                     ir_expression *const r3649 = equal(r3648, body.constant(0u));
                     ir_if *f3647 = new(mem_ctx) ir_if(operand(r3649).val);
                     exec_list *const f3647_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3647->then_instructions;

                        body.emit(assign(r360A, body.constant(int(0)), 0x01));


                     body.instructions = f3647_parent_instructions;
                     body.emit(f3647);

                     /* END IF */


                  body.instructions = f363C_parent_instructions;
                  body.emit(f363C);

                  /* END IF */

                  ir_variable *const r364A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r364A);
                  ir_expression *const r364B = lshift(r33E1, body.constant(int(31)));
                  ir_expression *const r364C = expr(ir_unop_i2u, r360A);
                  ir_expression *const r364D = lshift(r364C, body.constant(int(20)));
                  ir_expression *const r364E = add(r364B, r364D);
                  body.emit(assign(r364A, add(r364E, r360B), 0x02));

                  body.emit(assign(r364A, r360C, 0x01));

                  body.emit(assign(r360F, r364A, 0x03));

                  body.emit(assign(r360E, body.constant(false), 0x01));


               body.instructions = f363B_parent_instructions;
               body.emit(f363B);

               /* END IF */

               body.emit(assign(r33E0, r360F, 0x03));

               body.emit(assign(r33DF, body.constant(false), 0x01));


            body.instructions = f34ED_parent_instructions;
            body.emit(f34ED);

            /* END IF */


         body.instructions = f34AA_parent_instructions;
         body.emit(f34AA);

         /* END IF */


      body.instructions = f343E_parent_instructions;
      body.emit(f343E);

      /* END IF */


   body.instructions = f33F7_parent_instructions;
   body.emit(f33F7);

   /* END IF */

   ir_variable *const r364F = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3650 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r3651 = rshift(swizzle_y(r33E0), body.constant(int(20)));
   ir_expression *const r3652 = bit_and(r3651, body.constant(2047u));
   ir_expression *const r3653 = expr(ir_unop_u2i, r3652);
   body.emit(assign(r3650, add(r3653, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r3655 = less(r3650, body.constant(int(0)));
   ir_if *f3654 = new(mem_ctx) ir_if(operand(r3655).val);
   exec_list *const f3654_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3654->then_instructions;

      body.emit(assign(r364F, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3654->else_instructions;

      /* IF CONDITION */
      ir_expression *const r3657 = greater(r3650, body.constant(int(52)));
      ir_if *f3656 = new(mem_ctx) ir_if(operand(r3657).val);
      exec_list *const f3656_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3656->then_instructions;

         body.emit(assign(r364F, r33E0, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3656->else_instructions;

         ir_variable *const r3658 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r3658);
         ir_variable *const r3659 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r3659, sub(body.constant(int(52)), r3650), 0x01));

         ir_variable *const r365A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r365C = gequal(r3659, body.constant(int(32)));
         ir_if *f365B = new(mem_ctx) ir_if(operand(r365C).val);
         exec_list *const f365B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f365B->then_instructions;

            body.emit(assign(r365A, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f365B->else_instructions;

            body.emit(assign(r365A, lshift(body.constant(4294967295u), r3659), 0x01));


         body.instructions = f365B_parent_instructions;
         body.emit(f365B);

         /* END IF */

         ir_variable *const r365D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r365F = less(r3659, body.constant(int(33)));
         ir_if *f365E = new(mem_ctx) ir_if(operand(r365F).val);
         exec_list *const f365E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f365E->then_instructions;

            body.emit(assign(r365D, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f365E->else_instructions;

            ir_expression *const r3660 = add(r3659, body.constant(int(-32)));
            body.emit(assign(r365D, lshift(body.constant(4294967295u), r3660), 0x01));


         body.instructions = f365E_parent_instructions;
         body.emit(f365E);

         /* END IF */

         body.emit(assign(r3658, bit_and(r365A, swizzle_x(r33E0)), 0x01));

         body.emit(assign(r3658, bit_and(r365D, swizzle_y(r33E0)), 0x02));

         body.emit(assign(r364F, r3658, 0x03));


      body.instructions = f3656_parent_instructions;
      body.emit(f3656);

      /* END IF */


   body.instructions = f3654_parent_instructions;
   body.emit(f3654);

   /* END IF */

   ir_variable *const r3661 = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r3662 = rshift(swizzle_y(r33E0), body.constant(int(31)));
   ir_expression *const r3663 = expr(ir_unop_u2i, r3662);
   body.emit(assign(r3661, expr(ir_unop_i2b, r3663), 0x01));

   ir_variable *const r3664 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r3666 = expr(ir_unop_logic_not, r3661);
   ir_if *f3665 = new(mem_ctx) ir_if(operand(r3666).val);
   exec_list *const f3665_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3665->then_instructions;

      body.emit(assign(r3664, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3665->else_instructions;

      ir_variable *const r3667 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r3668 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r3668);
      ir_variable *const r3669 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r3669);
      ir_variable *const r366A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r366A);
      body.emit(assign(r366A, bit_and(swizzle_y(r33E0), body.constant(1048575u)), 0x02));

      body.emit(assign(r366A, swizzle_x(r33E0), 0x01));

      ir_variable *const r366B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r366B);
      body.emit(assign(r366B, bit_and(swizzle_y(r364F), body.constant(1048575u)), 0x02));

      body.emit(assign(r366B, swizzle_x(r364F), 0x01));

      ir_expression *const r366C = rshift(swizzle_y(r33E0), body.constant(int(20)));
      ir_expression *const r366D = bit_and(r366C, body.constant(2047u));
      ir_expression *const r366E = expr(ir_unop_u2i, r366D);
      ir_expression *const r366F = equal(r366E, body.constant(int(2047)));
      ir_expression *const r3670 = bit_or(swizzle_y(r366A), swizzle_x(r33E0));
      ir_expression *const r3671 = nequal(r3670, body.constant(0u));
      body.emit(assign(r3669, logic_and(r366F, r3671), 0x01));

      ir_expression *const r3672 = rshift(swizzle_y(r364F), body.constant(int(20)));
      ir_expression *const r3673 = bit_and(r3672, body.constant(2047u));
      ir_expression *const r3674 = expr(ir_unop_u2i, r3673);
      ir_expression *const r3675 = equal(r3674, body.constant(int(2047)));
      ir_expression *const r3676 = bit_or(swizzle_y(r366B), swizzle_x(r364F));
      ir_expression *const r3677 = nequal(r3676, body.constant(0u));
      body.emit(assign(r3668, logic_and(r3675, r3677), 0x01));

      /* IF CONDITION */
      ir_expression *const r3679 = logic_or(r3669, r3668);
      ir_if *f3678 = new(mem_ctx) ir_if(operand(r3679).val);
      exec_list *const f3678_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3678->then_instructions;

         body.emit(assign(r3667, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3678->else_instructions;

         ir_expression *const r367A = equal(swizzle_x(r33E0), swizzle_x(r364F));
         ir_expression *const r367B = equal(swizzle_y(r33E0), swizzle_y(r364F));
         ir_expression *const r367C = equal(swizzle_x(r33E0), body.constant(0u));
         ir_expression *const r367D = bit_or(swizzle_y(r33E0), swizzle_y(r364F));
         ir_expression *const r367E = lshift(r367D, body.constant(int(1)));
         ir_expression *const r367F = equal(r367E, body.constant(0u));
         ir_expression *const r3680 = logic_and(r367C, r367F);
         ir_expression *const r3681 = logic_or(r367B, r3680);
         body.emit(assign(r3667, logic_and(r367A, r3681), 0x01));


      body.instructions = f3678_parent_instructions;
      body.emit(f3678);

      /* END IF */

      body.emit(assign(r3664, r3667, 0x01));


   body.instructions = f3665_parent_instructions;
   body.emit(f3665);

   /* END IF */

   ir_variable *const r3682 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f3683 = new(mem_ctx) ir_if(operand(r3664).val);
   exec_list *const f3683_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3683->then_instructions;

      body.emit(assign(r3682, r364F, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3683->else_instructions;

      ir_variable *const r3684 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3685 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r3685, rshift(swizzle_y(r364F), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r3687 = equal(r3685, body.constant(0u));
      ir_if *f3686 = new(mem_ctx) ir_if(operand(r3687).val);
      exec_list *const f3686_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3686->then_instructions;

         ir_variable *const r3688 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r3688, r3685, 0x01));

         ir_variable *const r3689 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r368A = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r368A);
         ir_variable *const r368B = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r368B);
         ir_variable *const r368C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r368C);
         ir_variable *const r368D = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r368D);
         ir_variable *const r368E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r368E);
         ir_variable *const r368F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r368F);
         ir_variable *const r3690 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r3690);
         body.emit(assign(r3690, bit_and(swizzle_y(r364F), body.constant(1048575u)), 0x02));

         body.emit(assign(r3690, swizzle_x(r364F), 0x01));

         ir_variable *const r3691 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r3692 = rshift(swizzle_y(r364F), body.constant(int(20)));
         ir_expression *const r3693 = bit_and(r3692, body.constant(2047u));
         body.emit(assign(r3691, expr(ir_unop_u2i, r3693), 0x01));

         body.emit(assign(r368D, r3691, 0x01));

         ir_variable *const r3694 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r3694);
         body.emit(assign(r3694, body.constant(0u), 0x02));

         body.emit(assign(r3694, body.constant(0u), 0x01));

         body.emit(assign(r368B, body.constant(int(1023)), 0x01));

         body.emit(assign(r368A, add(r3691, body.constant(int(-1023))), 0x01));

         ir_variable *const r3695 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r3695, lshift(swizzle_x(r364F), body.constant(int(10))), 0x01));

         ir_variable *const r3696 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r3697 = lshift(swizzle_y(r3690), body.constant(int(10)));
         ir_expression *const r3698 = rshift(swizzle_x(r364F), body.constant(int(22)));
         body.emit(assign(r3696, bit_or(r3697, r3698), 0x01));

         body.emit(assign(r368E, r3696, 0x02));

         body.emit(assign(r368E, r3695, 0x01));

         ir_variable *const r3699 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r3699, body.constant(0u), 0x01));

         body.emit(assign(r368C, r3699, 0x02));

         body.emit(assign(r368C, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r369B = less(body.constant(int(0)), r368A);
         ir_if *f369A = new(mem_ctx) ir_if(operand(r369B).val);
         exec_list *const f369A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f369A->then_instructions;

            /* IF CONDITION */
            ir_expression *const r369D = equal(r3691, body.constant(int(2047)));
            ir_if *f369C = new(mem_ctx) ir_if(operand(r369D).val);
            exec_list *const f369C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f369C->then_instructions;

               /* IF CONDITION */
               ir_expression *const r369F = bit_or(r3696, r3695);
               ir_expression *const r36A0 = nequal(r369F, body.constant(0u));
               ir_if *f369E = new(mem_ctx) ir_if(operand(r36A0).val);
               exec_list *const f369E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f369E->then_instructions;

                  ir_variable *const r36A1 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r36A1, swizzle_x(r364F), 0x01));

                  ir_variable *const r36A2 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r36A2, body.constant(0u), 0x01));

                  ir_variable *const r36A3 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r36A1, bit_or(swizzle_y(r364F), body.constant(524288u)), 0x02));

                  body.emit(assign(r36A2, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r36A5 = lshift(swizzle_y(r364F), body.constant(int(1)));
                  ir_expression *const r36A6 = lequal(body.constant(4292870144u), r36A5);
                  ir_expression *const r36A7 = nequal(swizzle_x(r364F), body.constant(0u));
                  ir_expression *const r36A8 = bit_and(swizzle_y(r364F), body.constant(1048575u));
                  ir_expression *const r36A9 = nequal(r36A8, body.constant(0u));
                  ir_expression *const r36AA = logic_or(r36A7, r36A9);
                  ir_expression *const r36AB = logic_and(r36A6, r36AA);
                  ir_if *f36A4 = new(mem_ctx) ir_if(operand(r36AB).val);
                  exec_list *const f36A4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f36A4->then_instructions;

                     body.emit(assign(r36A3, r36A1, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f36A4->else_instructions;

                     body.emit(assign(r36A3, r36A2, 0x03));


                  body.instructions = f36A4_parent_instructions;
                  body.emit(f36A4);

                  /* END IF */

                  body.emit(assign(r3689, r36A3, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f369E->else_instructions;

                  body.emit(assign(r3689, r364F, 0x03));


               body.instructions = f369E_parent_instructions;
               body.emit(f369E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f369C->else_instructions;

               body.emit(assign(r368C, body.constant(1073741824u), 0x02));

               ir_variable *const r36AC = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r36AC, body.constant(1073741824u), 0x01));

               ir_variable *const r36AD = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r36AD, body.constant(0u), 0x01));

               ir_variable *const r36AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r36AE);
               ir_variable *const r36AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r36AF);
               ir_variable *const r36B0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r36B1 = neg(r368A);
               body.emit(assign(r36B0, bit_and(r36B1, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r36B3 = equal(r368A, body.constant(int(0)));
               ir_if *f36B2 = new(mem_ctx) ir_if(operand(r36B3).val);
               exec_list *const f36B2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f36B2->then_instructions;

                  body.emit(assign(r36AE, r36AD, 0x01));

                  body.emit(assign(r36AF, r36AC, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f36B2->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r36B5 = less(r368A, body.constant(int(32)));
                  ir_if *f36B4 = new(mem_ctx) ir_if(operand(r36B5).val);
                  exec_list *const f36B4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f36B4->then_instructions;

                     ir_expression *const r36B6 = lshift(body.constant(1073741824u), r36B0);
                     ir_expression *const r36B7 = bit_or(r36B6, body.constant(0u));
                     body.emit(assign(r36AE, bit_or(r36B7, body.constant(0u)), 0x01));

                     body.emit(assign(r36AF, rshift(body.constant(1073741824u), r368A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f36B4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r36B9 = equal(r368A, body.constant(int(32)));
                     ir_if *f36B8 = new(mem_ctx) ir_if(operand(r36B9).val);
                     exec_list *const f36B8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f36B8->then_instructions;

                        body.emit(assign(r36AE, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f36B8->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r36BB = less(r368A, body.constant(int(64)));
                        ir_if *f36BA = new(mem_ctx) ir_if(operand(r36BB).val);
                        exec_list *const f36BA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36BA->then_instructions;

                           ir_expression *const r36BC = bit_and(r368A, body.constant(int(31)));
                           ir_expression *const r36BD = rshift(body.constant(1073741824u), r36BC);
                           ir_expression *const r36BE = lshift(body.constant(1073741824u), r36B0);
                           ir_expression *const r36BF = bit_or(r36BE, body.constant(0u));
                           ir_expression *const r36C0 = nequal(r36BF, body.constant(0u));
                           ir_expression *const r36C1 = expr(ir_unop_b2i, r36C0);
                           ir_expression *const r36C2 = expr(ir_unop_i2u, r36C1);
                           body.emit(assign(r36AE, bit_or(r36BD, r36C2), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36BA->else_instructions;

                           body.emit(assign(r36AE, body.constant(1u), 0x01));


                        body.instructions = f36BA_parent_instructions;
                        body.emit(f36BA);

                        /* END IF */


                     body.instructions = f36B8_parent_instructions;
                     body.emit(f36B8);

                     /* END IF */

                     body.emit(assign(r36AF, body.constant(0u), 0x01));


                  body.instructions = f36B4_parent_instructions;
                  body.emit(f36B4);

                  /* END IF */


               body.instructions = f36B2_parent_instructions;
               body.emit(f36B2);

               /* END IF */

               body.emit(assign(r368C, r36AF, 0x02));

               body.emit(assign(r368C, r36AE, 0x01));

               body.emit(assign(r368E, bit_or(r3696, body.constant(1073741824u)), 0x02));

               ir_variable *const r36C3 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r36C4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r36C4, sub(r3695, r36AE), 0x01));

               ir_expression *const r36C5 = sub(swizzle_y(r368E), r36AF);
               ir_expression *const r36C6 = less(r3695, r36AE);
               ir_expression *const r36C7 = expr(ir_unop_b2i, r36C6);
               ir_expression *const r36C8 = expr(ir_unop_i2u, r36C7);
               body.emit(assign(r36C3, sub(r36C5, r36C8), 0x01));

               body.emit(assign(r368F, add(r3691, body.constant(int(-1))), 0x01));

               ir_variable *const r36C9 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r36C9, add(r368F, body.constant(int(-10))), 0x01));

               ir_variable *const r36CA = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r36CA, r36C3, 0x01));

               ir_variable *const r36CB = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r36CB, r36C4, 0x01));

               ir_variable *const r36CC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r36CC);
               ir_variable *const r36CD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r36CD);
               /* IF CONDITION */
               ir_expression *const r36CF = equal(r36C3, body.constant(0u));
               ir_if *f36CE = new(mem_ctx) ir_if(operand(r36CF).val);
               exec_list *const f36CE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f36CE->then_instructions;

                  body.emit(assign(r36CA, r36C4, 0x01));

                  body.emit(assign(r36CB, body.constant(0u), 0x01));

                  body.emit(assign(r36C9, add(r36C9, body.constant(int(-32))), 0x01));


               body.instructions = f36CE_parent_instructions;
               body.emit(f36CE);

               /* END IF */

               ir_variable *const r36D0 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r36D0, r36CA, 0x01));

               ir_variable *const r36D1 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r36D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r36D2);
               /* IF CONDITION */
               ir_expression *const r36D4 = equal(r36CA, body.constant(0u));
               ir_if *f36D3 = new(mem_ctx) ir_if(operand(r36D4).val);
               exec_list *const f36D3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f36D3->then_instructions;

                  body.emit(assign(r36D1, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f36D3->else_instructions;

                  body.emit(assign(r36D2, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r36D6 = bit_and(r36CA, body.constant(4294901760u));
                  ir_expression *const r36D7 = equal(r36D6, body.constant(0u));
                  ir_if *f36D5 = new(mem_ctx) ir_if(operand(r36D7).val);
                  exec_list *const f36D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f36D5->then_instructions;

                     body.emit(assign(r36D2, body.constant(int(16)), 0x01));

                     body.emit(assign(r36D0, lshift(r36CA, body.constant(int(16))), 0x01));


                  body.instructions = f36D5_parent_instructions;
                  body.emit(f36D5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r36D9 = bit_and(r36D0, body.constant(4278190080u));
                  ir_expression *const r36DA = equal(r36D9, body.constant(0u));
                  ir_if *f36D8 = new(mem_ctx) ir_if(operand(r36DA).val);
                  exec_list *const f36D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f36D8->then_instructions;

                     body.emit(assign(r36D2, add(r36D2, body.constant(int(8))), 0x01));

                     body.emit(assign(r36D0, lshift(r36D0, body.constant(int(8))), 0x01));


                  body.instructions = f36D8_parent_instructions;
                  body.emit(f36D8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r36DC = bit_and(r36D0, body.constant(4026531840u));
                  ir_expression *const r36DD = equal(r36DC, body.constant(0u));
                  ir_if *f36DB = new(mem_ctx) ir_if(operand(r36DD).val);
                  exec_list *const f36DB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f36DB->then_instructions;

                     body.emit(assign(r36D2, add(r36D2, body.constant(int(4))), 0x01));

                     body.emit(assign(r36D0, lshift(r36D0, body.constant(int(4))), 0x01));


                  body.instructions = f36DB_parent_instructions;
                  body.emit(f36DB);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r36DF = bit_and(r36D0, body.constant(3221225472u));
                  ir_expression *const r36E0 = equal(r36DF, body.constant(0u));
                  ir_if *f36DE = new(mem_ctx) ir_if(operand(r36E0).val);
                  exec_list *const f36DE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f36DE->then_instructions;

                     body.emit(assign(r36D2, add(r36D2, body.constant(int(2))), 0x01));

                     body.emit(assign(r36D0, lshift(r36D0, body.constant(int(2))), 0x01));


                  body.instructions = f36DE_parent_instructions;
                  body.emit(f36DE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r36E2 = bit_and(r36D0, body.constant(2147483648u));
                  ir_expression *const r36E3 = equal(r36E2, body.constant(0u));
                  ir_if *f36E1 = new(mem_ctx) ir_if(operand(r36E3).val);
                  exec_list *const f36E1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f36E1->then_instructions;

                     body.emit(assign(r36D2, add(r36D2, body.constant(int(1))), 0x01));


                  body.instructions = f36E1_parent_instructions;
                  body.emit(f36E1);

                  /* END IF */

                  body.emit(assign(r36D1, r36D2, 0x01));


               body.instructions = f36D3_parent_instructions;
               body.emit(f36D3);

               /* END IF */

               body.emit(assign(r36CD, add(r36D1, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r36E5 = lequal(body.constant(int(0)), r36CD);
               ir_if *f36E4 = new(mem_ctx) ir_if(operand(r36E5).val);
               exec_list *const f36E4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f36E4->then_instructions;

                  body.emit(assign(r36CC, body.constant(0u), 0x01));

                  ir_variable *const r36E6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r36E6, lshift(r36CB, r36CD), 0x01));

                  ir_variable *const r36E7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r36E9 = equal(r36CD, body.constant(int(0)));
                  ir_if *f36E8 = new(mem_ctx) ir_if(operand(r36E9).val);
                  exec_list *const f36E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f36E8->then_instructions;

                     body.emit(assign(r36E7, r36CA, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f36E8->else_instructions;

                     ir_expression *const r36EA = lshift(r36CA, r36CD);
                     ir_expression *const r36EB = neg(r36CD);
                     ir_expression *const r36EC = bit_and(r36EB, body.constant(int(31)));
                     ir_expression *const r36ED = rshift(r36CB, r36EC);
                     body.emit(assign(r36E7, bit_or(r36EA, r36ED), 0x01));


                  body.instructions = f36E8_parent_instructions;
                  body.emit(f36E8);

                  /* END IF */

                  body.emit(assign(r36CA, r36E7, 0x01));

                  body.emit(assign(r36CB, r36E6, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f36E4->else_instructions;

                  ir_variable *const r36EE = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r36EE, body.constant(0u), 0x01));

                  ir_variable *const r36EF = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r36EF, neg(r36CD), 0x01));

                  ir_variable *const r36F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r36F0);
                  ir_variable *const r36F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r36F1);
                  ir_variable *const r36F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r36F2);
                  ir_variable *const r36F3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r36F4 = neg(r36EF);
                  body.emit(assign(r36F3, bit_and(r36F4, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r36F6 = equal(r36EF, body.constant(int(0)));
                  ir_if *f36F5 = new(mem_ctx) ir_if(operand(r36F6).val);
                  exec_list *const f36F5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f36F5->then_instructions;

                     body.emit(assign(r36F0, r36EE, 0x01));

                     body.emit(assign(r36F1, r36CB, 0x01));

                     body.emit(assign(r36F2, r36CA, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f36F5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r36F8 = less(r36EF, body.constant(int(32)));
                     ir_if *f36F7 = new(mem_ctx) ir_if(operand(r36F8).val);
                     exec_list *const f36F7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f36F7->then_instructions;

                        body.emit(assign(r36F0, lshift(r36CB, r36F3), 0x01));

                        ir_expression *const r36F9 = lshift(r36CA, r36F3);
                        ir_expression *const r36FA = rshift(r36CB, r36EF);
                        body.emit(assign(r36F1, bit_or(r36F9, r36FA), 0x01));

                        body.emit(assign(r36F2, rshift(r36CA, r36EF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f36F7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r36FC = equal(r36EF, body.constant(int(32)));
                        ir_if *f36FB = new(mem_ctx) ir_if(operand(r36FC).val);
                        exec_list *const f36FB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36FB->then_instructions;

                           body.emit(assign(r36F0, r36CB, 0x01));

                           body.emit(assign(r36F1, r36CA, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36FB->else_instructions;

                           body.emit(assign(r36EE, bit_or(body.constant(0u), r36CB), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r36FE = less(r36EF, body.constant(int(64)));
                           ir_if *f36FD = new(mem_ctx) ir_if(operand(r36FE).val);
                           exec_list *const f36FD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36FD->then_instructions;

                              body.emit(assign(r36F0, lshift(r36CA, r36F3), 0x01));

                              ir_expression *const r36FF = bit_and(r36EF, body.constant(int(31)));
                              body.emit(assign(r36F1, rshift(r36CA, r36FF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f36FD->else_instructions;

                              ir_variable *const r3700 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3702 = equal(r36EF, body.constant(int(64)));
                              ir_if *f3701 = new(mem_ctx) ir_if(operand(r3702).val);
                              exec_list *const f3701_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3701->then_instructions;

                                 body.emit(assign(r3700, r36CA, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3701->else_instructions;

                                 ir_expression *const r3703 = nequal(r36CA, body.constant(0u));
                                 ir_expression *const r3704 = expr(ir_unop_b2i, r3703);
                                 body.emit(assign(r3700, expr(ir_unop_i2u, r3704), 0x01));


                              body.instructions = f3701_parent_instructions;
                              body.emit(f3701);

                              /* END IF */

                              body.emit(assign(r36F0, r3700, 0x01));

                              body.emit(assign(r36F1, body.constant(0u), 0x01));


                           body.instructions = f36FD_parent_instructions;
                           body.emit(f36FD);

                           /* END IF */


                        body.instructions = f36FB_parent_instructions;
                        body.emit(f36FB);

                        /* END IF */

                        body.emit(assign(r36F2, body.constant(0u), 0x01));


                     body.instructions = f36F7_parent_instructions;
                     body.emit(f36F7);

                     /* END IF */

                     ir_expression *const r3705 = nequal(r36EE, body.constant(0u));
                     ir_expression *const r3706 = expr(ir_unop_b2i, r3705);
                     ir_expression *const r3707 = expr(ir_unop_i2u, r3706);
                     body.emit(assign(r36F0, bit_or(r36F0, r3707), 0x01));


                  body.instructions = f36F5_parent_instructions;
                  body.emit(f36F5);

                  /* END IF */

                  body.emit(assign(r36CA, r36F2, 0x01));

                  body.emit(assign(r36CB, r36F1, 0x01));

                  body.emit(assign(r36CC, r36F0, 0x01));


               body.instructions = f36E4_parent_instructions;
               body.emit(f36E4);

               /* END IF */

               body.emit(assign(r36C9, sub(r36C9, r36CD), 0x01));

               ir_variable *const r3708 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3708, r36C9, 0x01));

               ir_variable *const r3709 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3709, r36CA, 0x01));

               ir_variable *const r370A = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r370A, r36CB, 0x01));

               ir_variable *const r370B = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r370B, r36CC, 0x01));

               ir_variable *const r370C = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r370C, body.constant(true), 0x01));

               ir_variable *const r370D = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r370E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r370E);
               ir_expression *const r370F = expr(ir_unop_u2i, r36CC);
               body.emit(assign(r370E, less(r370F, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3711 = lequal(body.constant(int(2045)), r36C9);
               ir_if *f3710 = new(mem_ctx) ir_if(operand(r3711).val);
               exec_list *const f3710_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3710->then_instructions;

                  ir_variable *const r3712 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3714 = less(body.constant(int(2045)), r36C9);
                  ir_if *f3713 = new(mem_ctx) ir_if(operand(r3714).val);
                  exec_list *const f3713_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3713->then_instructions;

                     body.emit(assign(r3712, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3713->else_instructions;

                     ir_variable *const r3715 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3717 = equal(r36C9, body.constant(int(2045)));
                     ir_if *f3716 = new(mem_ctx) ir_if(operand(r3717).val);
                     exec_list *const f3716_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3716->then_instructions;

                        ir_expression *const r3718 = equal(body.constant(2097151u), r36CA);
                        ir_expression *const r3719 = equal(body.constant(4294967295u), r36CB);
                        body.emit(assign(r3715, logic_and(r3718, r3719), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3716->else_instructions;

                        body.emit(assign(r3715, body.constant(false), 0x01));


                     body.instructions = f3716_parent_instructions;
                     body.emit(f3716);

                     /* END IF */

                     body.emit(assign(r3712, logic_and(r3715, r370E), 0x01));


                  body.instructions = f3713_parent_instructions;
                  body.emit(f3713);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f371A = new(mem_ctx) ir_if(operand(r3712).val);
                  exec_list *const f371A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f371A->then_instructions;

                     ir_variable *const r371B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r371B);
                     ir_expression *const r371C = lshift(r3685, body.constant(int(31)));
                     body.emit(assign(r371B, add(r371C, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r371B, body.constant(0u), 0x01));

                     body.emit(assign(r370D, r371B, 0x03));

                     body.emit(assign(r370C, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f371A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r371E = less(r36C9, body.constant(int(0)));
                     ir_if *f371D = new(mem_ctx) ir_if(operand(r371E).val);
                     exec_list *const f371D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f371D->then_instructions;

                        ir_variable *const r371F = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r371F, r36CC, 0x01));

                        ir_variable *const r3720 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3720, neg(r36C9), 0x01));

                        ir_variable *const r3721 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3721);
                        ir_variable *const r3722 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3722);
                        ir_variable *const r3723 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3723);
                        ir_variable *const r3724 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3725 = neg(r3720);
                        body.emit(assign(r3724, bit_and(r3725, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3727 = equal(r3720, body.constant(int(0)));
                        ir_if *f3726 = new(mem_ctx) ir_if(operand(r3727).val);
                        exec_list *const f3726_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3726->then_instructions;

                           body.emit(assign(r3721, r36CC, 0x01));

                           body.emit(assign(r3722, r36CB, 0x01));

                           body.emit(assign(r3723, r36CA, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3726->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3729 = less(r3720, body.constant(int(32)));
                           ir_if *f3728 = new(mem_ctx) ir_if(operand(r3729).val);
                           exec_list *const f3728_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3728->then_instructions;

                              body.emit(assign(r3721, lshift(r36CB, r3724), 0x01));

                              ir_expression *const r372A = lshift(r36CA, r3724);
                              ir_expression *const r372B = rshift(r36CB, r3720);
                              body.emit(assign(r3722, bit_or(r372A, r372B), 0x01));

                              body.emit(assign(r3723, rshift(r36CA, r3720), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3728->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r372D = equal(r3720, body.constant(int(32)));
                              ir_if *f372C = new(mem_ctx) ir_if(operand(r372D).val);
                              exec_list *const f372C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f372C->then_instructions;

                                 body.emit(assign(r3721, r36CB, 0x01));

                                 body.emit(assign(r3722, r36CA, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f372C->else_instructions;

                                 body.emit(assign(r371F, bit_or(r36CC, r36CB), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r372F = less(r3720, body.constant(int(64)));
                                 ir_if *f372E = new(mem_ctx) ir_if(operand(r372F).val);
                                 exec_list *const f372E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f372E->then_instructions;

                                    body.emit(assign(r3721, lshift(r36CA, r3724), 0x01));

                                    ir_expression *const r3730 = bit_and(r3720, body.constant(int(31)));
                                    body.emit(assign(r3722, rshift(r36CA, r3730), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f372E->else_instructions;

                                    ir_variable *const r3731 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3733 = equal(r3720, body.constant(int(64)));
                                    ir_if *f3732 = new(mem_ctx) ir_if(operand(r3733).val);
                                    exec_list *const f3732_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3732->then_instructions;

                                       body.emit(assign(r3731, r36CA, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3732->else_instructions;

                                       ir_expression *const r3734 = nequal(r36CA, body.constant(0u));
                                       ir_expression *const r3735 = expr(ir_unop_b2i, r3734);
                                       body.emit(assign(r3731, expr(ir_unop_i2u, r3735), 0x01));


                                    body.instructions = f3732_parent_instructions;
                                    body.emit(f3732);

                                    /* END IF */

                                    body.emit(assign(r3721, r3731, 0x01));

                                    body.emit(assign(r3722, body.constant(0u), 0x01));


                                 body.instructions = f372E_parent_instructions;
                                 body.emit(f372E);

                                 /* END IF */


                              body.instructions = f372C_parent_instructions;
                              body.emit(f372C);

                              /* END IF */

                              body.emit(assign(r3723, body.constant(0u), 0x01));


                           body.instructions = f3728_parent_instructions;
                           body.emit(f3728);

                           /* END IF */

                           ir_expression *const r3736 = nequal(r371F, body.constant(0u));
                           ir_expression *const r3737 = expr(ir_unop_b2i, r3736);
                           ir_expression *const r3738 = expr(ir_unop_i2u, r3737);
                           body.emit(assign(r3721, bit_or(r3721, r3738), 0x01));


                        body.instructions = f3726_parent_instructions;
                        body.emit(f3726);

                        /* END IF */

                        body.emit(assign(r3709, r3723, 0x01));

                        body.emit(assign(r370A, r3722, 0x01));

                        body.emit(assign(r370B, r3721, 0x01));

                        body.emit(assign(r3708, body.constant(int(0)), 0x01));

                        body.emit(assign(r370E, less(r3721, body.constant(0u)), 0x01));


                     body.instructions = f371D_parent_instructions;
                     body.emit(f371D);

                     /* END IF */


                  body.instructions = f371A_parent_instructions;
                  body.emit(f371A);

                  /* END IF */


               body.instructions = f3710_parent_instructions;
               body.emit(f3710);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3739 = new(mem_ctx) ir_if(operand(r370C).val);
               exec_list *const f3739_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3739->then_instructions;

                  /* IF CONDITION */
                  ir_if *f373A = new(mem_ctx) ir_if(operand(r370E).val);
                  exec_list *const f373A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f373A->then_instructions;

                     ir_variable *const r373B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r373B, add(r370A, body.constant(1u)), 0x01));

                     ir_expression *const r373C = less(r373B, r370A);
                     ir_expression *const r373D = expr(ir_unop_b2i, r373C);
                     ir_expression *const r373E = expr(ir_unop_i2u, r373D);
                     body.emit(assign(r3709, add(r3709, r373E), 0x01));

                     ir_expression *const r373F = equal(r370B, body.constant(0u));
                     ir_expression *const r3740 = expr(ir_unop_b2i, r373F);
                     ir_expression *const r3741 = expr(ir_unop_i2u, r3740);
                     ir_expression *const r3742 = add(r370B, r3741);
                     ir_expression *const r3743 = bit_and(r3742, body.constant(1u));
                     ir_expression *const r3744 = expr(ir_unop_bit_not, r3743);
                     body.emit(assign(r370A, bit_and(r373B, r3744), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f373A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3746 = bit_or(r3709, r370A);
                     ir_expression *const r3747 = equal(r3746, body.constant(0u));
                     ir_if *f3745 = new(mem_ctx) ir_if(operand(r3747).val);
                     exec_list *const f3745_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3745->then_instructions;

                        body.emit(assign(r3708, body.constant(int(0)), 0x01));


                     body.instructions = f3745_parent_instructions;
                     body.emit(f3745);

                     /* END IF */


                  body.instructions = f373A_parent_instructions;
                  body.emit(f373A);

                  /* END IF */

                  ir_variable *const r3748 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3748);
                  ir_expression *const r3749 = lshift(r3685, body.constant(int(31)));
                  ir_expression *const r374A = expr(ir_unop_i2u, r3708);
                  ir_expression *const r374B = lshift(r374A, body.constant(int(20)));
                  ir_expression *const r374C = add(r3749, r374B);
                  body.emit(assign(r3748, add(r374C, r3709), 0x02));

                  body.emit(assign(r3748, r370A, 0x01));

                  body.emit(assign(r370D, r3748, 0x03));

                  body.emit(assign(r370C, body.constant(false), 0x01));


               body.instructions = f3739_parent_instructions;
               body.emit(f3739);

               /* END IF */

               body.emit(assign(r3689, r370D, 0x03));


            body.instructions = f369C_parent_instructions;
            body.emit(f369C);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f369A->else_instructions;

            /* IF CONDITION */
            ir_expression *const r374E = less(r368A, body.constant(int(0)));
            ir_if *f374D = new(mem_ctx) ir_if(operand(r374E).val);
            exec_list *const f374D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f374D->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3750 = equal(r3691, body.constant(int(0)));
               ir_if *f374F = new(mem_ctx) ir_if(operand(r3750).val);
               exec_list *const f374F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f374F->then_instructions;

                  body.emit(assign(r368A, add(r368A, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f374F->else_instructions;

                  body.emit(assign(r368E, bit_or(swizzle_y(r368E), body.constant(1073741824u)), 0x02));


               body.instructions = f374F_parent_instructions;
               body.emit(f374F);

               /* END IF */

               ir_variable *const r3751 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r3751, swizzle_y(r368E), 0x01));

               ir_variable *const r3752 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r3752, swizzle_x(r368E), 0x01));

               ir_variable *const r3753 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r3753, neg(r368A), 0x01));

               ir_variable *const r3754 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3754);
               ir_variable *const r3755 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3755);
               ir_variable *const r3756 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3757 = neg(r3753);
               body.emit(assign(r3756, bit_and(r3757, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3759 = equal(r3753, body.constant(int(0)));
               ir_if *f3758 = new(mem_ctx) ir_if(operand(r3759).val);
               exec_list *const f3758_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3758->then_instructions;

                  body.emit(assign(r3754, r3752, 0x01));

                  body.emit(assign(r3755, r3751, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3758->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r375B = less(r3753, body.constant(int(32)));
                  ir_if *f375A = new(mem_ctx) ir_if(operand(r375B).val);
                  exec_list *const f375A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f375A->then_instructions;

                     ir_expression *const r375C = lshift(swizzle_y(r368E), r3756);
                     ir_expression *const r375D = rshift(r3695, r3753);
                     ir_expression *const r375E = bit_or(r375C, r375D);
                     ir_expression *const r375F = lshift(r3695, r3756);
                     ir_expression *const r3760 = nequal(r375F, body.constant(0u));
                     ir_expression *const r3761 = expr(ir_unop_b2i, r3760);
                     ir_expression *const r3762 = expr(ir_unop_i2u, r3761);
                     body.emit(assign(r3754, bit_or(r375E, r3762), 0x01));

                     body.emit(assign(r3755, rshift(swizzle_y(r368E), r3753), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f375A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3764 = equal(r3753, body.constant(int(32)));
                     ir_if *f3763 = new(mem_ctx) ir_if(operand(r3764).val);
                     exec_list *const f3763_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3763->then_instructions;

                        ir_expression *const r3765 = nequal(r3695, body.constant(0u));
                        ir_expression *const r3766 = expr(ir_unop_b2i, r3765);
                        ir_expression *const r3767 = expr(ir_unop_i2u, r3766);
                        body.emit(assign(r3754, bit_or(swizzle_y(r368E), r3767), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3763->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3769 = less(r3753, body.constant(int(64)));
                        ir_if *f3768 = new(mem_ctx) ir_if(operand(r3769).val);
                        exec_list *const f3768_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3768->then_instructions;

                           ir_expression *const r376A = bit_and(r3753, body.constant(int(31)));
                           ir_expression *const r376B = rshift(swizzle_y(r368E), r376A);
                           ir_expression *const r376C = lshift(swizzle_y(r368E), r3756);
                           ir_expression *const r376D = bit_or(r376C, r3695);
                           ir_expression *const r376E = nequal(r376D, body.constant(0u));
                           ir_expression *const r376F = expr(ir_unop_b2i, r376E);
                           ir_expression *const r3770 = expr(ir_unop_i2u, r376F);
                           body.emit(assign(r3754, bit_or(r376B, r3770), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3768->else_instructions;

                           ir_expression *const r3771 = bit_or(swizzle_y(r368E), r3695);
                           ir_expression *const r3772 = nequal(r3771, body.constant(0u));
                           ir_expression *const r3773 = expr(ir_unop_b2i, r3772);
                           body.emit(assign(r3754, expr(ir_unop_i2u, r3773), 0x01));


                        body.instructions = f3768_parent_instructions;
                        body.emit(f3768);

                        /* END IF */


                     body.instructions = f3763_parent_instructions;
                     body.emit(f3763);

                     /* END IF */

                     body.emit(assign(r3755, body.constant(0u), 0x01));


                  body.instructions = f375A_parent_instructions;
                  body.emit(f375A);

                  /* END IF */


               body.instructions = f3758_parent_instructions;
               body.emit(f3758);

               /* END IF */

               body.emit(assign(r368E, r3755, 0x02));

               body.emit(assign(r368E, r3754, 0x01));

               body.emit(assign(r368C, bit_or(swizzle_y(r368C), body.constant(1073741824u)), 0x02));

               ir_variable *const r3774 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3775 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3775, sub(swizzle_x(r368C), r3754), 0x01));

               ir_expression *const r3776 = sub(swizzle_y(r368C), r3755);
               ir_expression *const r3777 = less(swizzle_x(r368C), r3754);
               ir_expression *const r3778 = expr(ir_unop_b2i, r3777);
               ir_expression *const r3779 = expr(ir_unop_i2u, r3778);
               body.emit(assign(r3774, sub(r3776, r3779), 0x01));

               body.emit(assign(r3688, bit_xor(r3685, body.constant(1u)), 0x01));

               body.emit(assign(r368F, body.constant(int(1022)), 0x01));

               ir_variable *const r377A = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r377A, body.constant(int(1012)), 0x01));

               ir_variable *const r377B = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r377B, r3774, 0x01));

               ir_variable *const r377C = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r377C, r3775, 0x01));

               ir_variable *const r377D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r377D);
               ir_variable *const r377E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r377E);
               /* IF CONDITION */
               ir_expression *const r3780 = equal(r3774, body.constant(0u));
               ir_if *f377F = new(mem_ctx) ir_if(operand(r3780).val);
               exec_list *const f377F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f377F->then_instructions;

                  body.emit(assign(r377B, r3775, 0x01));

                  body.emit(assign(r377C, body.constant(0u), 0x01));

                  body.emit(assign(r377A, body.constant(int(980)), 0x01));


               body.instructions = f377F_parent_instructions;
               body.emit(f377F);

               /* END IF */

               ir_variable *const r3781 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r3781, r377B, 0x01));

               ir_variable *const r3782 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r3783 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3783);
               /* IF CONDITION */
               ir_expression *const r3785 = equal(r377B, body.constant(0u));
               ir_if *f3784 = new(mem_ctx) ir_if(operand(r3785).val);
               exec_list *const f3784_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3784->then_instructions;

                  body.emit(assign(r3782, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3784->else_instructions;

                  body.emit(assign(r3783, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3787 = bit_and(r377B, body.constant(4294901760u));
                  ir_expression *const r3788 = equal(r3787, body.constant(0u));
                  ir_if *f3786 = new(mem_ctx) ir_if(operand(r3788).val);
                  exec_list *const f3786_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3786->then_instructions;

                     body.emit(assign(r3783, body.constant(int(16)), 0x01));

                     body.emit(assign(r3781, lshift(r377B, body.constant(int(16))), 0x01));


                  body.instructions = f3786_parent_instructions;
                  body.emit(f3786);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r378A = bit_and(r3781, body.constant(4278190080u));
                  ir_expression *const r378B = equal(r378A, body.constant(0u));
                  ir_if *f3789 = new(mem_ctx) ir_if(operand(r378B).val);
                  exec_list *const f3789_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3789->then_instructions;

                     body.emit(assign(r3783, add(r3783, body.constant(int(8))), 0x01));

                     body.emit(assign(r3781, lshift(r3781, body.constant(int(8))), 0x01));


                  body.instructions = f3789_parent_instructions;
                  body.emit(f3789);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r378D = bit_and(r3781, body.constant(4026531840u));
                  ir_expression *const r378E = equal(r378D, body.constant(0u));
                  ir_if *f378C = new(mem_ctx) ir_if(operand(r378E).val);
                  exec_list *const f378C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f378C->then_instructions;

                     body.emit(assign(r3783, add(r3783, body.constant(int(4))), 0x01));

                     body.emit(assign(r3781, lshift(r3781, body.constant(int(4))), 0x01));


                  body.instructions = f378C_parent_instructions;
                  body.emit(f378C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3790 = bit_and(r3781, body.constant(3221225472u));
                  ir_expression *const r3791 = equal(r3790, body.constant(0u));
                  ir_if *f378F = new(mem_ctx) ir_if(operand(r3791).val);
                  exec_list *const f378F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f378F->then_instructions;

                     body.emit(assign(r3783, add(r3783, body.constant(int(2))), 0x01));

                     body.emit(assign(r3781, lshift(r3781, body.constant(int(2))), 0x01));


                  body.instructions = f378F_parent_instructions;
                  body.emit(f378F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3793 = bit_and(r3781, body.constant(2147483648u));
                  ir_expression *const r3794 = equal(r3793, body.constant(0u));
                  ir_if *f3792 = new(mem_ctx) ir_if(operand(r3794).val);
                  exec_list *const f3792_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3792->then_instructions;

                     body.emit(assign(r3783, add(r3783, body.constant(int(1))), 0x01));


                  body.instructions = f3792_parent_instructions;
                  body.emit(f3792);

                  /* END IF */

                  body.emit(assign(r3782, r3783, 0x01));


               body.instructions = f3784_parent_instructions;
               body.emit(f3784);

               /* END IF */

               body.emit(assign(r377E, add(r3782, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3796 = lequal(body.constant(int(0)), r377E);
               ir_if *f3795 = new(mem_ctx) ir_if(operand(r3796).val);
               exec_list *const f3795_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3795->then_instructions;

                  body.emit(assign(r377D, body.constant(0u), 0x01));

                  ir_variable *const r3797 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3797, lshift(r377C, r377E), 0x01));

                  ir_variable *const r3798 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r379A = equal(r377E, body.constant(int(0)));
                  ir_if *f3799 = new(mem_ctx) ir_if(operand(r379A).val);
                  exec_list *const f3799_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3799->then_instructions;

                     body.emit(assign(r3798, r377B, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3799->else_instructions;

                     ir_expression *const r379B = lshift(r377B, r377E);
                     ir_expression *const r379C = neg(r377E);
                     ir_expression *const r379D = bit_and(r379C, body.constant(int(31)));
                     ir_expression *const r379E = rshift(r377C, r379D);
                     body.emit(assign(r3798, bit_or(r379B, r379E), 0x01));


                  body.instructions = f3799_parent_instructions;
                  body.emit(f3799);

                  /* END IF */

                  body.emit(assign(r377B, r3798, 0x01));

                  body.emit(assign(r377C, r3797, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3795->else_instructions;

                  ir_variable *const r379F = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r379F, body.constant(0u), 0x01));

                  ir_variable *const r37A0 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r37A0, neg(r377E), 0x01));

                  ir_variable *const r37A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r37A1);
                  ir_variable *const r37A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r37A2);
                  ir_variable *const r37A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r37A3);
                  ir_variable *const r37A4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r37A5 = neg(r37A0);
                  body.emit(assign(r37A4, bit_and(r37A5, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r37A7 = equal(r37A0, body.constant(int(0)));
                  ir_if *f37A6 = new(mem_ctx) ir_if(operand(r37A7).val);
                  exec_list *const f37A6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f37A6->then_instructions;

                     body.emit(assign(r37A1, r379F, 0x01));

                     body.emit(assign(r37A2, r377C, 0x01));

                     body.emit(assign(r37A3, r377B, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f37A6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r37A9 = less(r37A0, body.constant(int(32)));
                     ir_if *f37A8 = new(mem_ctx) ir_if(operand(r37A9).val);
                     exec_list *const f37A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f37A8->then_instructions;

                        body.emit(assign(r37A1, lshift(r377C, r37A4), 0x01));

                        ir_expression *const r37AA = lshift(r377B, r37A4);
                        ir_expression *const r37AB = rshift(r377C, r37A0);
                        body.emit(assign(r37A2, bit_or(r37AA, r37AB), 0x01));

                        body.emit(assign(r37A3, rshift(r377B, r37A0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f37A8->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r37AD = equal(r37A0, body.constant(int(32)));
                        ir_if *f37AC = new(mem_ctx) ir_if(operand(r37AD).val);
                        exec_list *const f37AC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f37AC->then_instructions;

                           body.emit(assign(r37A1, r377C, 0x01));

                           body.emit(assign(r37A2, r377B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f37AC->else_instructions;

                           body.emit(assign(r379F, bit_or(body.constant(0u), r377C), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r37AF = less(r37A0, body.constant(int(64)));
                           ir_if *f37AE = new(mem_ctx) ir_if(operand(r37AF).val);
                           exec_list *const f37AE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f37AE->then_instructions;

                              body.emit(assign(r37A1, lshift(r377B, r37A4), 0x01));

                              ir_expression *const r37B0 = bit_and(r37A0, body.constant(int(31)));
                              body.emit(assign(r37A2, rshift(r377B, r37B0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f37AE->else_instructions;

                              ir_variable *const r37B1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r37B3 = equal(r37A0, body.constant(int(64)));
                              ir_if *f37B2 = new(mem_ctx) ir_if(operand(r37B3).val);
                              exec_list *const f37B2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37B2->then_instructions;

                                 body.emit(assign(r37B1, r377B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f37B2->else_instructions;

                                 ir_expression *const r37B4 = nequal(r377B, body.constant(0u));
                                 ir_expression *const r37B5 = expr(ir_unop_b2i, r37B4);
                                 body.emit(assign(r37B1, expr(ir_unop_i2u, r37B5), 0x01));


                              body.instructions = f37B2_parent_instructions;
                              body.emit(f37B2);

                              /* END IF */

                              body.emit(assign(r37A1, r37B1, 0x01));

                              body.emit(assign(r37A2, body.constant(0u), 0x01));


                           body.instructions = f37AE_parent_instructions;
                           body.emit(f37AE);

                           /* END IF */


                        body.instructions = f37AC_parent_instructions;
                        body.emit(f37AC);

                        /* END IF */

                        body.emit(assign(r37A3, body.constant(0u), 0x01));


                     body.instructions = f37A8_parent_instructions;
                     body.emit(f37A8);

                     /* END IF */

                     ir_expression *const r37B6 = nequal(r379F, body.constant(0u));
                     ir_expression *const r37B7 = expr(ir_unop_b2i, r37B6);
                     ir_expression *const r37B8 = expr(ir_unop_i2u, r37B7);
                     body.emit(assign(r37A1, bit_or(r37A1, r37B8), 0x01));


                  body.instructions = f37A6_parent_instructions;
                  body.emit(f37A6);

                  /* END IF */

                  body.emit(assign(r377B, r37A3, 0x01));

                  body.emit(assign(r377C, r37A2, 0x01));

                  body.emit(assign(r377D, r37A1, 0x01));


               body.instructions = f3795_parent_instructions;
               body.emit(f3795);

               /* END IF */

               body.emit(assign(r377A, sub(r377A, r377E), 0x01));

               ir_variable *const r37B9 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r37B9, r377A, 0x01));

               ir_variable *const r37BA = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r37BA, r377B, 0x01));

               ir_variable *const r37BB = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r37BB, r377C, 0x01));

               ir_variable *const r37BC = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r37BC, r377D, 0x01));

               ir_variable *const r37BD = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r37BD, body.constant(true), 0x01));

               ir_variable *const r37BE = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r37BF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r37BF);
               ir_expression *const r37C0 = expr(ir_unop_u2i, r377D);
               body.emit(assign(r37BF, less(r37C0, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r37C2 = lequal(body.constant(int(2045)), r377A);
               ir_if *f37C1 = new(mem_ctx) ir_if(operand(r37C2).val);
               exec_list *const f37C1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f37C1->then_instructions;

                  ir_variable *const r37C3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r37C5 = less(body.constant(int(2045)), r377A);
                  ir_if *f37C4 = new(mem_ctx) ir_if(operand(r37C5).val);
                  exec_list *const f37C4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f37C4->then_instructions;

                     body.emit(assign(r37C3, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f37C4->else_instructions;

                     ir_variable *const r37C6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r37C8 = equal(r377A, body.constant(int(2045)));
                     ir_if *f37C7 = new(mem_ctx) ir_if(operand(r37C8).val);
                     exec_list *const f37C7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f37C7->then_instructions;

                        ir_expression *const r37C9 = equal(body.constant(2097151u), r377B);
                        ir_expression *const r37CA = equal(body.constant(4294967295u), r377C);
                        body.emit(assign(r37C6, logic_and(r37C9, r37CA), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f37C7->else_instructions;

                        body.emit(assign(r37C6, body.constant(false), 0x01));


                     body.instructions = f37C7_parent_instructions;
                     body.emit(f37C7);

                     /* END IF */

                     body.emit(assign(r37C3, logic_and(r37C6, r37BF), 0x01));


                  body.instructions = f37C4_parent_instructions;
                  body.emit(f37C4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f37CB = new(mem_ctx) ir_if(operand(r37C3).val);
                  exec_list *const f37CB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f37CB->then_instructions;

                     ir_variable *const r37CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r37CC);
                     ir_expression *const r37CD = lshift(r3688, body.constant(int(31)));
                     body.emit(assign(r37CC, add(r37CD, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r37CC, body.constant(0u), 0x01));

                     body.emit(assign(r37BE, r37CC, 0x03));

                     body.emit(assign(r37BD, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f37CB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r37CF = less(r377A, body.constant(int(0)));
                     ir_if *f37CE = new(mem_ctx) ir_if(operand(r37CF).val);
                     exec_list *const f37CE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f37CE->then_instructions;

                        ir_variable *const r37D0 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r37D0, r377D, 0x01));

                        ir_variable *const r37D1 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r37D1, neg(r377A), 0x01));

                        ir_variable *const r37D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r37D2);
                        ir_variable *const r37D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r37D3);
                        ir_variable *const r37D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r37D4);
                        ir_variable *const r37D5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r37D6 = neg(r37D1);
                        body.emit(assign(r37D5, bit_and(r37D6, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r37D8 = equal(r37D1, body.constant(int(0)));
                        ir_if *f37D7 = new(mem_ctx) ir_if(operand(r37D8).val);
                        exec_list *const f37D7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f37D7->then_instructions;

                           body.emit(assign(r37D2, r377D, 0x01));

                           body.emit(assign(r37D3, r377C, 0x01));

                           body.emit(assign(r37D4, r377B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f37D7->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r37DA = less(r37D1, body.constant(int(32)));
                           ir_if *f37D9 = new(mem_ctx) ir_if(operand(r37DA).val);
                           exec_list *const f37D9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f37D9->then_instructions;

                              body.emit(assign(r37D2, lshift(r377C, r37D5), 0x01));

                              ir_expression *const r37DB = lshift(r377B, r37D5);
                              ir_expression *const r37DC = rshift(r377C, r37D1);
                              body.emit(assign(r37D3, bit_or(r37DB, r37DC), 0x01));

                              body.emit(assign(r37D4, rshift(r377B, r37D1), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f37D9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r37DE = equal(r37D1, body.constant(int(32)));
                              ir_if *f37DD = new(mem_ctx) ir_if(operand(r37DE).val);
                              exec_list *const f37DD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37DD->then_instructions;

                                 body.emit(assign(r37D2, r377C, 0x01));

                                 body.emit(assign(r37D3, r377B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f37DD->else_instructions;

                                 body.emit(assign(r37D0, bit_or(r377D, r377C), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r37E0 = less(r37D1, body.constant(int(64)));
                                 ir_if *f37DF = new(mem_ctx) ir_if(operand(r37E0).val);
                                 exec_list *const f37DF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f37DF->then_instructions;

                                    body.emit(assign(r37D2, lshift(r377B, r37D5), 0x01));

                                    ir_expression *const r37E1 = bit_and(r37D1, body.constant(int(31)));
                                    body.emit(assign(r37D3, rshift(r377B, r37E1), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f37DF->else_instructions;

                                    ir_variable *const r37E2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r37E4 = equal(r37D1, body.constant(int(64)));
                                    ir_if *f37E3 = new(mem_ctx) ir_if(operand(r37E4).val);
                                    exec_list *const f37E3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f37E3->then_instructions;

                                       body.emit(assign(r37E2, r377B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f37E3->else_instructions;

                                       ir_expression *const r37E5 = nequal(r377B, body.constant(0u));
                                       ir_expression *const r37E6 = expr(ir_unop_b2i, r37E5);
                                       body.emit(assign(r37E2, expr(ir_unop_i2u, r37E6), 0x01));


                                    body.instructions = f37E3_parent_instructions;
                                    body.emit(f37E3);

                                    /* END IF */

                                    body.emit(assign(r37D2, r37E2, 0x01));

                                    body.emit(assign(r37D3, body.constant(0u), 0x01));


                                 body.instructions = f37DF_parent_instructions;
                                 body.emit(f37DF);

                                 /* END IF */


                              body.instructions = f37DD_parent_instructions;
                              body.emit(f37DD);

                              /* END IF */

                              body.emit(assign(r37D4, body.constant(0u), 0x01));


                           body.instructions = f37D9_parent_instructions;
                           body.emit(f37D9);

                           /* END IF */

                           ir_expression *const r37E7 = nequal(r37D0, body.constant(0u));
                           ir_expression *const r37E8 = expr(ir_unop_b2i, r37E7);
                           ir_expression *const r37E9 = expr(ir_unop_i2u, r37E8);
                           body.emit(assign(r37D2, bit_or(r37D2, r37E9), 0x01));


                        body.instructions = f37D7_parent_instructions;
                        body.emit(f37D7);

                        /* END IF */

                        body.emit(assign(r37BA, r37D4, 0x01));

                        body.emit(assign(r37BB, r37D3, 0x01));

                        body.emit(assign(r37BC, r37D2, 0x01));

                        body.emit(assign(r37B9, body.constant(int(0)), 0x01));

                        body.emit(assign(r37BF, less(r37D2, body.constant(0u)), 0x01));


                     body.instructions = f37CE_parent_instructions;
                     body.emit(f37CE);

                     /* END IF */


                  body.instructions = f37CB_parent_instructions;
                  body.emit(f37CB);

                  /* END IF */


               body.instructions = f37C1_parent_instructions;
               body.emit(f37C1);

               /* END IF */

               /* IF CONDITION */
               ir_if *f37EA = new(mem_ctx) ir_if(operand(r37BD).val);
               exec_list *const f37EA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f37EA->then_instructions;

                  /* IF CONDITION */
                  ir_if *f37EB = new(mem_ctx) ir_if(operand(r37BF).val);
                  exec_list *const f37EB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f37EB->then_instructions;

                     ir_variable *const r37EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r37EC, add(r37BB, body.constant(1u)), 0x01));

                     ir_expression *const r37ED = less(r37EC, r37BB);
                     ir_expression *const r37EE = expr(ir_unop_b2i, r37ED);
                     ir_expression *const r37EF = expr(ir_unop_i2u, r37EE);
                     body.emit(assign(r37BA, add(r37BA, r37EF), 0x01));

                     ir_expression *const r37F0 = equal(r37BC, body.constant(0u));
                     ir_expression *const r37F1 = expr(ir_unop_b2i, r37F0);
                     ir_expression *const r37F2 = expr(ir_unop_i2u, r37F1);
                     ir_expression *const r37F3 = add(r37BC, r37F2);
                     ir_expression *const r37F4 = bit_and(r37F3, body.constant(1u));
                     ir_expression *const r37F5 = expr(ir_unop_bit_not, r37F4);
                     body.emit(assign(r37BB, bit_and(r37EC, r37F5), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f37EB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r37F7 = bit_or(r37BA, r37BB);
                     ir_expression *const r37F8 = equal(r37F7, body.constant(0u));
                     ir_if *f37F6 = new(mem_ctx) ir_if(operand(r37F8).val);
                     exec_list *const f37F6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f37F6->then_instructions;

                        body.emit(assign(r37B9, body.constant(int(0)), 0x01));


                     body.instructions = f37F6_parent_instructions;
                     body.emit(f37F6);

                     /* END IF */


                  body.instructions = f37EB_parent_instructions;
                  body.emit(f37EB);

                  /* END IF */

                  ir_variable *const r37F9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r37F9);
                  ir_expression *const r37FA = lshift(r3688, body.constant(int(31)));
                  ir_expression *const r37FB = expr(ir_unop_i2u, r37B9);
                  ir_expression *const r37FC = lshift(r37FB, body.constant(int(20)));
                  ir_expression *const r37FD = add(r37FA, r37FC);
                  body.emit(assign(r37F9, add(r37FD, r37BA), 0x02));

                  body.emit(assign(r37F9, r37BB, 0x01));

                  body.emit(assign(r37BE, r37F9, 0x03));

                  body.emit(assign(r37BD, body.constant(false), 0x01));


               body.instructions = f37EA_parent_instructions;
               body.emit(f37EA);

               /* END IF */

               body.emit(assign(r3689, r37BE, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f374D->else_instructions;

               /* IF CONDITION */
               ir_expression *const r37FF = equal(r3691, body.constant(int(2047)));
               ir_if *f37FE = new(mem_ctx) ir_if(operand(r37FF).val);
               exec_list *const f37FE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f37FE->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3801 = bit_or(swizzle_y(r368E), swizzle_x(r368E));
                  ir_expression *const r3802 = bit_or(swizzle_y(r368C), swizzle_x(r368C));
                  ir_expression *const r3803 = bit_or(r3801, r3802);
                  ir_expression *const r3804 = nequal(r3803, body.constant(0u));
                  ir_if *f3800 = new(mem_ctx) ir_if(operand(r3804).val);
                  exec_list *const f3800_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3800->then_instructions;

                     ir_variable *const r3805 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r3805, swizzle_x(r364F), 0x01));

                     ir_variable *const r3806 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r3806, body.constant(0u), 0x01));

                     ir_variable *const r3807 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r3805, bit_or(swizzle_y(r364F), body.constant(524288u)), 0x02));

                     body.emit(assign(r3806, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r3809 = lshift(swizzle_y(r364F), body.constant(int(1)));
                     ir_expression *const r380A = lequal(body.constant(4292870144u), r3809);
                     ir_expression *const r380B = nequal(swizzle_x(r364F), body.constant(0u));
                     ir_expression *const r380C = bit_and(swizzle_y(r364F), body.constant(1048575u));
                     ir_expression *const r380D = nequal(r380C, body.constant(0u));
                     ir_expression *const r380E = logic_or(r380B, r380D);
                     ir_expression *const r380F = logic_and(r380A, r380E);
                     ir_if *f3808 = new(mem_ctx) ir_if(operand(r380F).val);
                     exec_list *const f3808_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3808->then_instructions;

                        body.emit(assign(r3807, r3805, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3808->else_instructions;

                        body.emit(assign(r3807, r3806, 0x03));


                     body.instructions = f3808_parent_instructions;
                     body.emit(f3808);

                     /* END IF */

                     body.emit(assign(r3689, r3807, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3800->else_instructions;

                     ir_constant_data r3810_data;
                     memset(&r3810_data, 0, sizeof(ir_constant_data));
                     r3810_data.u[0] = 4294967295;
                     r3810_data.u[1] = 4294967295;
                     ir_constant *const r3810 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3810_data);
                     body.emit(assign(r3689, r3810, 0x03));


                  body.instructions = f3800_parent_instructions;
                  body.emit(f3800);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f37FE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3812 = equal(r3691, body.constant(int(0)));
                  ir_if *f3811 = new(mem_ctx) ir_if(operand(r3812).val);
                  exec_list *const f3811_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3811->then_instructions;

                     body.emit(assign(r368D, body.constant(int(1)), 0x01));

                     body.emit(assign(r368B, body.constant(int(1)), 0x01));


                  body.instructions = f3811_parent_instructions;
                  body.emit(f3811);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3814 = less(swizzle_y(r368C), swizzle_y(r368E));
                  ir_if *f3813 = new(mem_ctx) ir_if(operand(r3814).val);
                  exec_list *const f3813_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3813->then_instructions;

                     ir_variable *const r3815 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r3816 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3816, sub(swizzle_x(r368E), swizzle_x(r368C)), 0x01));

                     ir_expression *const r3817 = sub(swizzle_y(r368E), swizzle_y(r368C));
                     ir_expression *const r3818 = less(swizzle_x(r368E), swizzle_x(r368C));
                     ir_expression *const r3819 = expr(ir_unop_b2i, r3818);
                     ir_expression *const r381A = expr(ir_unop_i2u, r3819);
                     body.emit(assign(r3815, sub(r3817, r381A), 0x01));

                     body.emit(assign(r368F, add(r368D, body.constant(int(-1))), 0x01));

                     ir_variable *const r381B = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r381B, add(r368F, body.constant(int(-10))), 0x01));

                     ir_variable *const r381C = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r381C, r3815, 0x01));

                     ir_variable *const r381D = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r381D, r3816, 0x01));

                     ir_variable *const r381E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r381E);
                     ir_variable *const r381F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r381F);
                     /* IF CONDITION */
                     ir_expression *const r3821 = equal(r3815, body.constant(0u));
                     ir_if *f3820 = new(mem_ctx) ir_if(operand(r3821).val);
                     exec_list *const f3820_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3820->then_instructions;

                        body.emit(assign(r381C, r3816, 0x01));

                        body.emit(assign(r381D, body.constant(0u), 0x01));

                        body.emit(assign(r381B, add(r381B, body.constant(int(-32))), 0x01));


                     body.instructions = f3820_parent_instructions;
                     body.emit(f3820);

                     /* END IF */

                     ir_variable *const r3822 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3822, r381C, 0x01));

                     ir_variable *const r3823 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3824 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3824);
                     /* IF CONDITION */
                     ir_expression *const r3826 = equal(r381C, body.constant(0u));
                     ir_if *f3825 = new(mem_ctx) ir_if(operand(r3826).val);
                     exec_list *const f3825_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3825->then_instructions;

                        body.emit(assign(r3823, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3825->else_instructions;

                        body.emit(assign(r3824, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3828 = bit_and(r381C, body.constant(4294901760u));
                        ir_expression *const r3829 = equal(r3828, body.constant(0u));
                        ir_if *f3827 = new(mem_ctx) ir_if(operand(r3829).val);
                        exec_list *const f3827_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3827->then_instructions;

                           body.emit(assign(r3824, body.constant(int(16)), 0x01));

                           body.emit(assign(r3822, lshift(r381C, body.constant(int(16))), 0x01));


                        body.instructions = f3827_parent_instructions;
                        body.emit(f3827);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r382B = bit_and(r3822, body.constant(4278190080u));
                        ir_expression *const r382C = equal(r382B, body.constant(0u));
                        ir_if *f382A = new(mem_ctx) ir_if(operand(r382C).val);
                        exec_list *const f382A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f382A->then_instructions;

                           body.emit(assign(r3824, add(r3824, body.constant(int(8))), 0x01));

                           body.emit(assign(r3822, lshift(r3822, body.constant(int(8))), 0x01));


                        body.instructions = f382A_parent_instructions;
                        body.emit(f382A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r382E = bit_and(r3822, body.constant(4026531840u));
                        ir_expression *const r382F = equal(r382E, body.constant(0u));
                        ir_if *f382D = new(mem_ctx) ir_if(operand(r382F).val);
                        exec_list *const f382D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f382D->then_instructions;

                           body.emit(assign(r3824, add(r3824, body.constant(int(4))), 0x01));

                           body.emit(assign(r3822, lshift(r3822, body.constant(int(4))), 0x01));


                        body.instructions = f382D_parent_instructions;
                        body.emit(f382D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3831 = bit_and(r3822, body.constant(3221225472u));
                        ir_expression *const r3832 = equal(r3831, body.constant(0u));
                        ir_if *f3830 = new(mem_ctx) ir_if(operand(r3832).val);
                        exec_list *const f3830_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3830->then_instructions;

                           body.emit(assign(r3824, add(r3824, body.constant(int(2))), 0x01));

                           body.emit(assign(r3822, lshift(r3822, body.constant(int(2))), 0x01));


                        body.instructions = f3830_parent_instructions;
                        body.emit(f3830);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3834 = bit_and(r3822, body.constant(2147483648u));
                        ir_expression *const r3835 = equal(r3834, body.constant(0u));
                        ir_if *f3833 = new(mem_ctx) ir_if(operand(r3835).val);
                        exec_list *const f3833_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3833->then_instructions;

                           body.emit(assign(r3824, add(r3824, body.constant(int(1))), 0x01));


                        body.instructions = f3833_parent_instructions;
                        body.emit(f3833);

                        /* END IF */

                        body.emit(assign(r3823, r3824, 0x01));


                     body.instructions = f3825_parent_instructions;
                     body.emit(f3825);

                     /* END IF */

                     body.emit(assign(r381F, add(r3823, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3837 = lequal(body.constant(int(0)), r381F);
                     ir_if *f3836 = new(mem_ctx) ir_if(operand(r3837).val);
                     exec_list *const f3836_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3836->then_instructions;

                        body.emit(assign(r381E, body.constant(0u), 0x01));

                        ir_variable *const r3838 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r3838, lshift(r381D, r381F), 0x01));

                        ir_variable *const r3839 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r383B = equal(r381F, body.constant(int(0)));
                        ir_if *f383A = new(mem_ctx) ir_if(operand(r383B).val);
                        exec_list *const f383A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f383A->then_instructions;

                           body.emit(assign(r3839, r381C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f383A->else_instructions;

                           ir_expression *const r383C = lshift(r381C, r381F);
                           ir_expression *const r383D = neg(r381F);
                           ir_expression *const r383E = bit_and(r383D, body.constant(int(31)));
                           ir_expression *const r383F = rshift(r381D, r383E);
                           body.emit(assign(r3839, bit_or(r383C, r383F), 0x01));


                        body.instructions = f383A_parent_instructions;
                        body.emit(f383A);

                        /* END IF */

                        body.emit(assign(r381C, r3839, 0x01));

                        body.emit(assign(r381D, r3838, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3836->else_instructions;

                        ir_variable *const r3840 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3840, body.constant(0u), 0x01));

                        ir_variable *const r3841 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3841, neg(r381F), 0x01));

                        ir_variable *const r3842 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3842);
                        ir_variable *const r3843 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3843);
                        ir_variable *const r3844 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3844);
                        ir_variable *const r3845 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3846 = neg(r3841);
                        body.emit(assign(r3845, bit_and(r3846, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3848 = equal(r3841, body.constant(int(0)));
                        ir_if *f3847 = new(mem_ctx) ir_if(operand(r3848).val);
                        exec_list *const f3847_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3847->then_instructions;

                           body.emit(assign(r3842, r3840, 0x01));

                           body.emit(assign(r3843, r381D, 0x01));

                           body.emit(assign(r3844, r381C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3847->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r384A = less(r3841, body.constant(int(32)));
                           ir_if *f3849 = new(mem_ctx) ir_if(operand(r384A).val);
                           exec_list *const f3849_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3849->then_instructions;

                              body.emit(assign(r3842, lshift(r381D, r3845), 0x01));

                              ir_expression *const r384B = lshift(r381C, r3845);
                              ir_expression *const r384C = rshift(r381D, r3841);
                              body.emit(assign(r3843, bit_or(r384B, r384C), 0x01));

                              body.emit(assign(r3844, rshift(r381C, r3841), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3849->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r384E = equal(r3841, body.constant(int(32)));
                              ir_if *f384D = new(mem_ctx) ir_if(operand(r384E).val);
                              exec_list *const f384D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f384D->then_instructions;

                                 body.emit(assign(r3842, r381D, 0x01));

                                 body.emit(assign(r3843, r381C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f384D->else_instructions;

                                 body.emit(assign(r3840, bit_or(body.constant(0u), r381D), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3850 = less(r3841, body.constant(int(64)));
                                 ir_if *f384F = new(mem_ctx) ir_if(operand(r3850).val);
                                 exec_list *const f384F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f384F->then_instructions;

                                    body.emit(assign(r3842, lshift(r381C, r3845), 0x01));

                                    ir_expression *const r3851 = bit_and(r3841, body.constant(int(31)));
                                    body.emit(assign(r3843, rshift(r381C, r3851), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f384F->else_instructions;

                                    ir_variable *const r3852 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3854 = equal(r3841, body.constant(int(64)));
                                    ir_if *f3853 = new(mem_ctx) ir_if(operand(r3854).val);
                                    exec_list *const f3853_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3853->then_instructions;

                                       body.emit(assign(r3852, r381C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3853->else_instructions;

                                       ir_expression *const r3855 = nequal(r381C, body.constant(0u));
                                       ir_expression *const r3856 = expr(ir_unop_b2i, r3855);
                                       body.emit(assign(r3852, expr(ir_unop_i2u, r3856), 0x01));


                                    body.instructions = f3853_parent_instructions;
                                    body.emit(f3853);

                                    /* END IF */

                                    body.emit(assign(r3842, r3852, 0x01));

                                    body.emit(assign(r3843, body.constant(0u), 0x01));


                                 body.instructions = f384F_parent_instructions;
                                 body.emit(f384F);

                                 /* END IF */


                              body.instructions = f384D_parent_instructions;
                              body.emit(f384D);

                              /* END IF */

                              body.emit(assign(r3844, body.constant(0u), 0x01));


                           body.instructions = f3849_parent_instructions;
                           body.emit(f3849);

                           /* END IF */

                           ir_expression *const r3857 = nequal(r3840, body.constant(0u));
                           ir_expression *const r3858 = expr(ir_unop_b2i, r3857);
                           ir_expression *const r3859 = expr(ir_unop_i2u, r3858);
                           body.emit(assign(r3842, bit_or(r3842, r3859), 0x01));


                        body.instructions = f3847_parent_instructions;
                        body.emit(f3847);

                        /* END IF */

                        body.emit(assign(r381C, r3844, 0x01));

                        body.emit(assign(r381D, r3843, 0x01));

                        body.emit(assign(r381E, r3842, 0x01));


                     body.instructions = f3836_parent_instructions;
                     body.emit(f3836);

                     /* END IF */

                     body.emit(assign(r381B, sub(r381B, r381F), 0x01));

                     ir_variable *const r385A = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r385A, r381B, 0x01));

                     ir_variable *const r385B = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r385B, r381C, 0x01));

                     ir_variable *const r385C = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r385C, r381D, 0x01));

                     ir_variable *const r385D = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r385D, r381E, 0x01));

                     ir_variable *const r385E = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r385E, body.constant(true), 0x01));

                     ir_variable *const r385F = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r3860 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r3860);
                     ir_expression *const r3861 = expr(ir_unop_u2i, r381E);
                     body.emit(assign(r3860, less(r3861, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3863 = lequal(body.constant(int(2045)), r381B);
                     ir_if *f3862 = new(mem_ctx) ir_if(operand(r3863).val);
                     exec_list *const f3862_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3862->then_instructions;

                        ir_variable *const r3864 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3866 = less(body.constant(int(2045)), r381B);
                        ir_if *f3865 = new(mem_ctx) ir_if(operand(r3866).val);
                        exec_list *const f3865_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3865->then_instructions;

                           body.emit(assign(r3864, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3865->else_instructions;

                           ir_variable *const r3867 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3869 = equal(r381B, body.constant(int(2045)));
                           ir_if *f3868 = new(mem_ctx) ir_if(operand(r3869).val);
                           exec_list *const f3868_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3868->then_instructions;

                              ir_expression *const r386A = equal(body.constant(2097151u), r381C);
                              ir_expression *const r386B = equal(body.constant(4294967295u), r381D);
                              body.emit(assign(r3867, logic_and(r386A, r386B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3868->else_instructions;

                              body.emit(assign(r3867, body.constant(false), 0x01));


                           body.instructions = f3868_parent_instructions;
                           body.emit(f3868);

                           /* END IF */

                           body.emit(assign(r3864, logic_and(r3867, r3860), 0x01));


                        body.instructions = f3865_parent_instructions;
                        body.emit(f3865);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f386C = new(mem_ctx) ir_if(operand(r3864).val);
                        exec_list *const f386C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f386C->then_instructions;

                           ir_variable *const r386D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r386D);
                           ir_expression *const r386E = lshift(r3688, body.constant(int(31)));
                           body.emit(assign(r386D, add(r386E, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r386D, body.constant(0u), 0x01));

                           body.emit(assign(r385F, r386D, 0x03));

                           body.emit(assign(r385E, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f386C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3870 = less(r381B, body.constant(int(0)));
                           ir_if *f386F = new(mem_ctx) ir_if(operand(r3870).val);
                           exec_list *const f386F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f386F->then_instructions;

                              ir_variable *const r3871 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3871, r381E, 0x01));

                              ir_variable *const r3872 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3872, neg(r381B), 0x01));

                              ir_variable *const r3873 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3873);
                              ir_variable *const r3874 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3874);
                              ir_variable *const r3875 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3875);
                              ir_variable *const r3876 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3877 = neg(r3872);
                              body.emit(assign(r3876, bit_and(r3877, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3879 = equal(r3872, body.constant(int(0)));
                              ir_if *f3878 = new(mem_ctx) ir_if(operand(r3879).val);
                              exec_list *const f3878_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3878->then_instructions;

                                 body.emit(assign(r3873, r381E, 0x01));

                                 body.emit(assign(r3874, r381D, 0x01));

                                 body.emit(assign(r3875, r381C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3878->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r387B = less(r3872, body.constant(int(32)));
                                 ir_if *f387A = new(mem_ctx) ir_if(operand(r387B).val);
                                 exec_list *const f387A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f387A->then_instructions;

                                    body.emit(assign(r3873, lshift(r381D, r3876), 0x01));

                                    ir_expression *const r387C = lshift(r381C, r3876);
                                    ir_expression *const r387D = rshift(r381D, r3872);
                                    body.emit(assign(r3874, bit_or(r387C, r387D), 0x01));

                                    body.emit(assign(r3875, rshift(r381C, r3872), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f387A->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r387F = equal(r3872, body.constant(int(32)));
                                    ir_if *f387E = new(mem_ctx) ir_if(operand(r387F).val);
                                    exec_list *const f387E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f387E->then_instructions;

                                       body.emit(assign(r3873, r381D, 0x01));

                                       body.emit(assign(r3874, r381C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f387E->else_instructions;

                                       body.emit(assign(r3871, bit_or(r381E, r381D), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3881 = less(r3872, body.constant(int(64)));
                                       ir_if *f3880 = new(mem_ctx) ir_if(operand(r3881).val);
                                       exec_list *const f3880_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3880->then_instructions;

                                          body.emit(assign(r3873, lshift(r381C, r3876), 0x01));

                                          ir_expression *const r3882 = bit_and(r3872, body.constant(int(31)));
                                          body.emit(assign(r3874, rshift(r381C, r3882), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3880->else_instructions;

                                          ir_variable *const r3883 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3885 = equal(r3872, body.constant(int(64)));
                                          ir_if *f3884 = new(mem_ctx) ir_if(operand(r3885).val);
                                          exec_list *const f3884_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3884->then_instructions;

                                             body.emit(assign(r3883, r381C, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3884->else_instructions;

                                             ir_expression *const r3886 = nequal(r381C, body.constant(0u));
                                             ir_expression *const r3887 = expr(ir_unop_b2i, r3886);
                                             body.emit(assign(r3883, expr(ir_unop_i2u, r3887), 0x01));


                                          body.instructions = f3884_parent_instructions;
                                          body.emit(f3884);

                                          /* END IF */

                                          body.emit(assign(r3873, r3883, 0x01));

                                          body.emit(assign(r3874, body.constant(0u), 0x01));


                                       body.instructions = f3880_parent_instructions;
                                       body.emit(f3880);

                                       /* END IF */


                                    body.instructions = f387E_parent_instructions;
                                    body.emit(f387E);

                                    /* END IF */

                                    body.emit(assign(r3875, body.constant(0u), 0x01));


                                 body.instructions = f387A_parent_instructions;
                                 body.emit(f387A);

                                 /* END IF */

                                 ir_expression *const r3888 = nequal(r3871, body.constant(0u));
                                 ir_expression *const r3889 = expr(ir_unop_b2i, r3888);
                                 ir_expression *const r388A = expr(ir_unop_i2u, r3889);
                                 body.emit(assign(r3873, bit_or(r3873, r388A), 0x01));


                              body.instructions = f3878_parent_instructions;
                              body.emit(f3878);

                              /* END IF */

                              body.emit(assign(r385B, r3875, 0x01));

                              body.emit(assign(r385C, r3874, 0x01));

                              body.emit(assign(r385D, r3873, 0x01));

                              body.emit(assign(r385A, body.constant(int(0)), 0x01));

                              body.emit(assign(r3860, less(r3873, body.constant(0u)), 0x01));


                           body.instructions = f386F_parent_instructions;
                           body.emit(f386F);

                           /* END IF */


                        body.instructions = f386C_parent_instructions;
                        body.emit(f386C);

                        /* END IF */


                     body.instructions = f3862_parent_instructions;
                     body.emit(f3862);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f388B = new(mem_ctx) ir_if(operand(r385E).val);
                     exec_list *const f388B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f388B->then_instructions;

                        /* IF CONDITION */
                        ir_if *f388C = new(mem_ctx) ir_if(operand(r3860).val);
                        exec_list *const f388C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f388C->then_instructions;

                           ir_variable *const r388D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r388D, add(r385C, body.constant(1u)), 0x01));

                           ir_expression *const r388E = less(r388D, r385C);
                           ir_expression *const r388F = expr(ir_unop_b2i, r388E);
                           ir_expression *const r3890 = expr(ir_unop_i2u, r388F);
                           body.emit(assign(r385B, add(r385B, r3890), 0x01));

                           ir_expression *const r3891 = equal(r385D, body.constant(0u));
                           ir_expression *const r3892 = expr(ir_unop_b2i, r3891);
                           ir_expression *const r3893 = expr(ir_unop_i2u, r3892);
                           ir_expression *const r3894 = add(r385D, r3893);
                           ir_expression *const r3895 = bit_and(r3894, body.constant(1u));
                           ir_expression *const r3896 = expr(ir_unop_bit_not, r3895);
                           body.emit(assign(r385C, bit_and(r388D, r3896), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f388C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3898 = bit_or(r385B, r385C);
                           ir_expression *const r3899 = equal(r3898, body.constant(0u));
                           ir_if *f3897 = new(mem_ctx) ir_if(operand(r3899).val);
                           exec_list *const f3897_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3897->then_instructions;

                              body.emit(assign(r385A, body.constant(int(0)), 0x01));


                           body.instructions = f3897_parent_instructions;
                           body.emit(f3897);

                           /* END IF */


                        body.instructions = f388C_parent_instructions;
                        body.emit(f388C);

                        /* END IF */

                        ir_variable *const r389A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r389A);
                        ir_expression *const r389B = lshift(r3688, body.constant(int(31)));
                        ir_expression *const r389C = expr(ir_unop_i2u, r385A);
                        ir_expression *const r389D = lshift(r389C, body.constant(int(20)));
                        ir_expression *const r389E = add(r389B, r389D);
                        body.emit(assign(r389A, add(r389E, r385B), 0x02));

                        body.emit(assign(r389A, r385C, 0x01));

                        body.emit(assign(r385F, r389A, 0x03));

                        body.emit(assign(r385E, body.constant(false), 0x01));


                     body.instructions = f388B_parent_instructions;
                     body.emit(f388B);

                     /* END IF */

                     body.emit(assign(r3689, r385F, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3813->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r38A0 = less(swizzle_y(r368E), swizzle_y(r368C));
                     ir_if *f389F = new(mem_ctx) ir_if(operand(r38A0).val);
                     exec_list *const f389F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f389F->then_instructions;

                        ir_variable *const r38A1 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r38A2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r38A2, sub(swizzle_x(r368C), swizzle_x(r368E)), 0x01));

                        ir_expression *const r38A3 = sub(swizzle_y(r368C), swizzle_y(r368E));
                        ir_expression *const r38A4 = less(swizzle_x(r368C), swizzle_x(r368E));
                        ir_expression *const r38A5 = expr(ir_unop_b2i, r38A4);
                        ir_expression *const r38A6 = expr(ir_unop_i2u, r38A5);
                        body.emit(assign(r38A1, sub(r38A3, r38A6), 0x01));

                        body.emit(assign(r3688, bit_xor(r3688, body.constant(1u)), 0x01));

                        body.emit(assign(r368F, add(r368B, body.constant(int(-1))), 0x01));

                        ir_variable *const r38A7 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r38A7, add(r368F, body.constant(int(-10))), 0x01));

                        ir_variable *const r38A8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r38A8, r38A1, 0x01));

                        ir_variable *const r38A9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r38A9, r38A2, 0x01));

                        ir_variable *const r38AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r38AA);
                        ir_variable *const r38AB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r38AB);
                        /* IF CONDITION */
                        ir_expression *const r38AD = equal(r38A1, body.constant(0u));
                        ir_if *f38AC = new(mem_ctx) ir_if(operand(r38AD).val);
                        exec_list *const f38AC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f38AC->then_instructions;

                           body.emit(assign(r38A8, r38A2, 0x01));

                           body.emit(assign(r38A9, body.constant(0u), 0x01));

                           body.emit(assign(r38A7, add(r38A7, body.constant(int(-32))), 0x01));


                        body.instructions = f38AC_parent_instructions;
                        body.emit(f38AC);

                        /* END IF */

                        ir_variable *const r38AE = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r38AE, r38A8, 0x01));

                        ir_variable *const r38AF = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r38B0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r38B0);
                        /* IF CONDITION */
                        ir_expression *const r38B2 = equal(r38A8, body.constant(0u));
                        ir_if *f38B1 = new(mem_ctx) ir_if(operand(r38B2).val);
                        exec_list *const f38B1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f38B1->then_instructions;

                           body.emit(assign(r38AF, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f38B1->else_instructions;

                           body.emit(assign(r38B0, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r38B4 = bit_and(r38A8, body.constant(4294901760u));
                           ir_expression *const r38B5 = equal(r38B4, body.constant(0u));
                           ir_if *f38B3 = new(mem_ctx) ir_if(operand(r38B5).val);
                           exec_list *const f38B3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38B3->then_instructions;

                              body.emit(assign(r38B0, body.constant(int(16)), 0x01));

                              body.emit(assign(r38AE, lshift(r38A8, body.constant(int(16))), 0x01));


                           body.instructions = f38B3_parent_instructions;
                           body.emit(f38B3);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r38B7 = bit_and(r38AE, body.constant(4278190080u));
                           ir_expression *const r38B8 = equal(r38B7, body.constant(0u));
                           ir_if *f38B6 = new(mem_ctx) ir_if(operand(r38B8).val);
                           exec_list *const f38B6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38B6->then_instructions;

                              body.emit(assign(r38B0, add(r38B0, body.constant(int(8))), 0x01));

                              body.emit(assign(r38AE, lshift(r38AE, body.constant(int(8))), 0x01));


                           body.instructions = f38B6_parent_instructions;
                           body.emit(f38B6);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r38BA = bit_and(r38AE, body.constant(4026531840u));
                           ir_expression *const r38BB = equal(r38BA, body.constant(0u));
                           ir_if *f38B9 = new(mem_ctx) ir_if(operand(r38BB).val);
                           exec_list *const f38B9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38B9->then_instructions;

                              body.emit(assign(r38B0, add(r38B0, body.constant(int(4))), 0x01));

                              body.emit(assign(r38AE, lshift(r38AE, body.constant(int(4))), 0x01));


                           body.instructions = f38B9_parent_instructions;
                           body.emit(f38B9);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r38BD = bit_and(r38AE, body.constant(3221225472u));
                           ir_expression *const r38BE = equal(r38BD, body.constant(0u));
                           ir_if *f38BC = new(mem_ctx) ir_if(operand(r38BE).val);
                           exec_list *const f38BC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38BC->then_instructions;

                              body.emit(assign(r38B0, add(r38B0, body.constant(int(2))), 0x01));

                              body.emit(assign(r38AE, lshift(r38AE, body.constant(int(2))), 0x01));


                           body.instructions = f38BC_parent_instructions;
                           body.emit(f38BC);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r38C0 = bit_and(r38AE, body.constant(2147483648u));
                           ir_expression *const r38C1 = equal(r38C0, body.constant(0u));
                           ir_if *f38BF = new(mem_ctx) ir_if(operand(r38C1).val);
                           exec_list *const f38BF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38BF->then_instructions;

                              body.emit(assign(r38B0, add(r38B0, body.constant(int(1))), 0x01));


                           body.instructions = f38BF_parent_instructions;
                           body.emit(f38BF);

                           /* END IF */

                           body.emit(assign(r38AF, r38B0, 0x01));


                        body.instructions = f38B1_parent_instructions;
                        body.emit(f38B1);

                        /* END IF */

                        body.emit(assign(r38AB, add(r38AF, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r38C3 = lequal(body.constant(int(0)), r38AB);
                        ir_if *f38C2 = new(mem_ctx) ir_if(operand(r38C3).val);
                        exec_list *const f38C2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f38C2->then_instructions;

                           body.emit(assign(r38AA, body.constant(0u), 0x01));

                           ir_variable *const r38C4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r38C4, lshift(r38A9, r38AB), 0x01));

                           ir_variable *const r38C5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r38C7 = equal(r38AB, body.constant(int(0)));
                           ir_if *f38C6 = new(mem_ctx) ir_if(operand(r38C7).val);
                           exec_list *const f38C6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38C6->then_instructions;

                              body.emit(assign(r38C5, r38A8, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f38C6->else_instructions;

                              ir_expression *const r38C8 = lshift(r38A8, r38AB);
                              ir_expression *const r38C9 = neg(r38AB);
                              ir_expression *const r38CA = bit_and(r38C9, body.constant(int(31)));
                              ir_expression *const r38CB = rshift(r38A9, r38CA);
                              body.emit(assign(r38C5, bit_or(r38C8, r38CB), 0x01));


                           body.instructions = f38C6_parent_instructions;
                           body.emit(f38C6);

                           /* END IF */

                           body.emit(assign(r38A8, r38C5, 0x01));

                           body.emit(assign(r38A9, r38C4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f38C2->else_instructions;

                           ir_variable *const r38CC = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r38CC, body.constant(0u), 0x01));

                           ir_variable *const r38CD = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r38CD, neg(r38AB), 0x01));

                           ir_variable *const r38CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r38CE);
                           ir_variable *const r38CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r38CF);
                           ir_variable *const r38D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r38D0);
                           ir_variable *const r38D1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r38D2 = neg(r38CD);
                           body.emit(assign(r38D1, bit_and(r38D2, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r38D4 = equal(r38CD, body.constant(int(0)));
                           ir_if *f38D3 = new(mem_ctx) ir_if(operand(r38D4).val);
                           exec_list *const f38D3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38D3->then_instructions;

                              body.emit(assign(r38CE, r38CC, 0x01));

                              body.emit(assign(r38CF, r38A9, 0x01));

                              body.emit(assign(r38D0, r38A8, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f38D3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r38D6 = less(r38CD, body.constant(int(32)));
                              ir_if *f38D5 = new(mem_ctx) ir_if(operand(r38D6).val);
                              exec_list *const f38D5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f38D5->then_instructions;

                                 body.emit(assign(r38CE, lshift(r38A9, r38D1), 0x01));

                                 ir_expression *const r38D7 = lshift(r38A8, r38D1);
                                 ir_expression *const r38D8 = rshift(r38A9, r38CD);
                                 body.emit(assign(r38CF, bit_or(r38D7, r38D8), 0x01));

                                 body.emit(assign(r38D0, rshift(r38A8, r38CD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f38D5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r38DA = equal(r38CD, body.constant(int(32)));
                                 ir_if *f38D9 = new(mem_ctx) ir_if(operand(r38DA).val);
                                 exec_list *const f38D9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f38D9->then_instructions;

                                    body.emit(assign(r38CE, r38A9, 0x01));

                                    body.emit(assign(r38CF, r38A8, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f38D9->else_instructions;

                                    body.emit(assign(r38CC, bit_or(body.constant(0u), r38A9), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r38DC = less(r38CD, body.constant(int(64)));
                                    ir_if *f38DB = new(mem_ctx) ir_if(operand(r38DC).val);
                                    exec_list *const f38DB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f38DB->then_instructions;

                                       body.emit(assign(r38CE, lshift(r38A8, r38D1), 0x01));

                                       ir_expression *const r38DD = bit_and(r38CD, body.constant(int(31)));
                                       body.emit(assign(r38CF, rshift(r38A8, r38DD), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f38DB->else_instructions;

                                       ir_variable *const r38DE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r38E0 = equal(r38CD, body.constant(int(64)));
                                       ir_if *f38DF = new(mem_ctx) ir_if(operand(r38E0).val);
                                       exec_list *const f38DF_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f38DF->then_instructions;

                                          body.emit(assign(r38DE, r38A8, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f38DF->else_instructions;

                                          ir_expression *const r38E1 = nequal(r38A8, body.constant(0u));
                                          ir_expression *const r38E2 = expr(ir_unop_b2i, r38E1);
                                          body.emit(assign(r38DE, expr(ir_unop_i2u, r38E2), 0x01));


                                       body.instructions = f38DF_parent_instructions;
                                       body.emit(f38DF);

                                       /* END IF */

                                       body.emit(assign(r38CE, r38DE, 0x01));

                                       body.emit(assign(r38CF, body.constant(0u), 0x01));


                                    body.instructions = f38DB_parent_instructions;
                                    body.emit(f38DB);

                                    /* END IF */


                                 body.instructions = f38D9_parent_instructions;
                                 body.emit(f38D9);

                                 /* END IF */

                                 body.emit(assign(r38D0, body.constant(0u), 0x01));


                              body.instructions = f38D5_parent_instructions;
                              body.emit(f38D5);

                              /* END IF */

                              ir_expression *const r38E3 = nequal(r38CC, body.constant(0u));
                              ir_expression *const r38E4 = expr(ir_unop_b2i, r38E3);
                              ir_expression *const r38E5 = expr(ir_unop_i2u, r38E4);
                              body.emit(assign(r38CE, bit_or(r38CE, r38E5), 0x01));


                           body.instructions = f38D3_parent_instructions;
                           body.emit(f38D3);

                           /* END IF */

                           body.emit(assign(r38A8, r38D0, 0x01));

                           body.emit(assign(r38A9, r38CF, 0x01));

                           body.emit(assign(r38AA, r38CE, 0x01));


                        body.instructions = f38C2_parent_instructions;
                        body.emit(f38C2);

                        /* END IF */

                        body.emit(assign(r38A7, sub(r38A7, r38AB), 0x01));

                        ir_variable *const r38E6 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r38E6, r38A7, 0x01));

                        ir_variable *const r38E7 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r38E7, r38A8, 0x01));

                        ir_variable *const r38E8 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r38E8, r38A9, 0x01));

                        ir_variable *const r38E9 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r38E9, r38AA, 0x01));

                        ir_variable *const r38EA = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r38EA, body.constant(true), 0x01));

                        ir_variable *const r38EB = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r38EC = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r38EC);
                        ir_expression *const r38ED = expr(ir_unop_u2i, r38AA);
                        body.emit(assign(r38EC, less(r38ED, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r38EF = lequal(body.constant(int(2045)), r38A7);
                        ir_if *f38EE = new(mem_ctx) ir_if(operand(r38EF).val);
                        exec_list *const f38EE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f38EE->then_instructions;

                           ir_variable *const r38F0 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r38F2 = less(body.constant(int(2045)), r38A7);
                           ir_if *f38F1 = new(mem_ctx) ir_if(operand(r38F2).val);
                           exec_list *const f38F1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38F1->then_instructions;

                              body.emit(assign(r38F0, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f38F1->else_instructions;

                              ir_variable *const r38F3 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r38F5 = equal(r38A7, body.constant(int(2045)));
                              ir_if *f38F4 = new(mem_ctx) ir_if(operand(r38F5).val);
                              exec_list *const f38F4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f38F4->then_instructions;

                                 ir_expression *const r38F6 = equal(body.constant(2097151u), r38A8);
                                 ir_expression *const r38F7 = equal(body.constant(4294967295u), r38A9);
                                 body.emit(assign(r38F3, logic_and(r38F6, r38F7), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f38F4->else_instructions;

                                 body.emit(assign(r38F3, body.constant(false), 0x01));


                              body.instructions = f38F4_parent_instructions;
                              body.emit(f38F4);

                              /* END IF */

                              body.emit(assign(r38F0, logic_and(r38F3, r38EC), 0x01));


                           body.instructions = f38F1_parent_instructions;
                           body.emit(f38F1);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f38F8 = new(mem_ctx) ir_if(operand(r38F0).val);
                           exec_list *const f38F8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38F8->then_instructions;

                              ir_variable *const r38F9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r38F9);
                              ir_expression *const r38FA = lshift(r3688, body.constant(int(31)));
                              body.emit(assign(r38F9, add(r38FA, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r38F9, body.constant(0u), 0x01));

                              body.emit(assign(r38EB, r38F9, 0x03));

                              body.emit(assign(r38EA, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f38F8->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r38FC = less(r38A7, body.constant(int(0)));
                              ir_if *f38FB = new(mem_ctx) ir_if(operand(r38FC).val);
                              exec_list *const f38FB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f38FB->then_instructions;

                                 ir_variable *const r38FD = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r38FD, r38AA, 0x01));

                                 ir_variable *const r38FE = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r38FE, neg(r38A7), 0x01));

                                 ir_variable *const r38FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r38FF);
                                 ir_variable *const r3900 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r3900);
                                 ir_variable *const r3901 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r3901);
                                 ir_variable *const r3902 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r3903 = neg(r38FE);
                                 body.emit(assign(r3902, bit_and(r3903, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3905 = equal(r38FE, body.constant(int(0)));
                                 ir_if *f3904 = new(mem_ctx) ir_if(operand(r3905).val);
                                 exec_list *const f3904_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3904->then_instructions;

                                    body.emit(assign(r38FF, r38AA, 0x01));

                                    body.emit(assign(r3900, r38A9, 0x01));

                                    body.emit(assign(r3901, r38A8, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3904->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3907 = less(r38FE, body.constant(int(32)));
                                    ir_if *f3906 = new(mem_ctx) ir_if(operand(r3907).val);
                                    exec_list *const f3906_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3906->then_instructions;

                                       body.emit(assign(r38FF, lshift(r38A9, r3902), 0x01));

                                       ir_expression *const r3908 = lshift(r38A8, r3902);
                                       ir_expression *const r3909 = rshift(r38A9, r38FE);
                                       body.emit(assign(r3900, bit_or(r3908, r3909), 0x01));

                                       body.emit(assign(r3901, rshift(r38A8, r38FE), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3906->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r390B = equal(r38FE, body.constant(int(32)));
                                       ir_if *f390A = new(mem_ctx) ir_if(operand(r390B).val);
                                       exec_list *const f390A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f390A->then_instructions;

                                          body.emit(assign(r38FF, r38A9, 0x01));

                                          body.emit(assign(r3900, r38A8, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f390A->else_instructions;

                                          body.emit(assign(r38FD, bit_or(r38AA, r38A9), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r390D = less(r38FE, body.constant(int(64)));
                                          ir_if *f390C = new(mem_ctx) ir_if(operand(r390D).val);
                                          exec_list *const f390C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f390C->then_instructions;

                                             body.emit(assign(r38FF, lshift(r38A8, r3902), 0x01));

                                             ir_expression *const r390E = bit_and(r38FE, body.constant(int(31)));
                                             body.emit(assign(r3900, rshift(r38A8, r390E), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f390C->else_instructions;

                                             ir_variable *const r390F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r3911 = equal(r38FE, body.constant(int(64)));
                                             ir_if *f3910 = new(mem_ctx) ir_if(operand(r3911).val);
                                             exec_list *const f3910_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3910->then_instructions;

                                                body.emit(assign(r390F, r38A8, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3910->else_instructions;

                                                ir_expression *const r3912 = nequal(r38A8, body.constant(0u));
                                                ir_expression *const r3913 = expr(ir_unop_b2i, r3912);
                                                body.emit(assign(r390F, expr(ir_unop_i2u, r3913), 0x01));


                                             body.instructions = f3910_parent_instructions;
                                             body.emit(f3910);

                                             /* END IF */

                                             body.emit(assign(r38FF, r390F, 0x01));

                                             body.emit(assign(r3900, body.constant(0u), 0x01));


                                          body.instructions = f390C_parent_instructions;
                                          body.emit(f390C);

                                          /* END IF */


                                       body.instructions = f390A_parent_instructions;
                                       body.emit(f390A);

                                       /* END IF */

                                       body.emit(assign(r3901, body.constant(0u), 0x01));


                                    body.instructions = f3906_parent_instructions;
                                    body.emit(f3906);

                                    /* END IF */

                                    ir_expression *const r3914 = nequal(r38FD, body.constant(0u));
                                    ir_expression *const r3915 = expr(ir_unop_b2i, r3914);
                                    ir_expression *const r3916 = expr(ir_unop_i2u, r3915);
                                    body.emit(assign(r38FF, bit_or(r38FF, r3916), 0x01));


                                 body.instructions = f3904_parent_instructions;
                                 body.emit(f3904);

                                 /* END IF */

                                 body.emit(assign(r38E7, r3901, 0x01));

                                 body.emit(assign(r38E8, r3900, 0x01));

                                 body.emit(assign(r38E9, r38FF, 0x01));

                                 body.emit(assign(r38E6, body.constant(int(0)), 0x01));

                                 body.emit(assign(r38EC, less(r38FF, body.constant(0u)), 0x01));


                              body.instructions = f38FB_parent_instructions;
                              body.emit(f38FB);

                              /* END IF */


                           body.instructions = f38F8_parent_instructions;
                           body.emit(f38F8);

                           /* END IF */


                        body.instructions = f38EE_parent_instructions;
                        body.emit(f38EE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3917 = new(mem_ctx) ir_if(operand(r38EA).val);
                        exec_list *const f3917_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3917->then_instructions;

                           /* IF CONDITION */
                           ir_if *f3918 = new(mem_ctx) ir_if(operand(r38EC).val);
                           exec_list *const f3918_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3918->then_instructions;

                              ir_variable *const r3919 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r3919, add(r38E8, body.constant(1u)), 0x01));

                              ir_expression *const r391A = less(r3919, r38E8);
                              ir_expression *const r391B = expr(ir_unop_b2i, r391A);
                              ir_expression *const r391C = expr(ir_unop_i2u, r391B);
                              body.emit(assign(r38E7, add(r38E7, r391C), 0x01));

                              ir_expression *const r391D = equal(r38E9, body.constant(0u));
                              ir_expression *const r391E = expr(ir_unop_b2i, r391D);
                              ir_expression *const r391F = expr(ir_unop_i2u, r391E);
                              ir_expression *const r3920 = add(r38E9, r391F);
                              ir_expression *const r3921 = bit_and(r3920, body.constant(1u));
                              ir_expression *const r3922 = expr(ir_unop_bit_not, r3921);
                              body.emit(assign(r38E8, bit_and(r3919, r3922), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3918->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3924 = bit_or(r38E7, r38E8);
                              ir_expression *const r3925 = equal(r3924, body.constant(0u));
                              ir_if *f3923 = new(mem_ctx) ir_if(operand(r3925).val);
                              exec_list *const f3923_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3923->then_instructions;

                                 body.emit(assign(r38E6, body.constant(int(0)), 0x01));


                              body.instructions = f3923_parent_instructions;
                              body.emit(f3923);

                              /* END IF */


                           body.instructions = f3918_parent_instructions;
                           body.emit(f3918);

                           /* END IF */

                           ir_variable *const r3926 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3926);
                           ir_expression *const r3927 = lshift(r3688, body.constant(int(31)));
                           ir_expression *const r3928 = expr(ir_unop_i2u, r38E6);
                           ir_expression *const r3929 = lshift(r3928, body.constant(int(20)));
                           ir_expression *const r392A = add(r3927, r3929);
                           body.emit(assign(r3926, add(r392A, r38E7), 0x02));

                           body.emit(assign(r3926, r38E8, 0x01));

                           body.emit(assign(r38EB, r3926, 0x03));

                           body.emit(assign(r38EA, body.constant(false), 0x01));


                        body.instructions = f3917_parent_instructions;
                        body.emit(f3917);

                        /* END IF */

                        body.emit(assign(r3689, r38EB, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f389F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r392C = less(swizzle_x(r368C), swizzle_x(r368E));
                        ir_if *f392B = new(mem_ctx) ir_if(operand(r392C).val);
                        exec_list *const f392B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f392B->then_instructions;

                           ir_variable *const r392D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r392E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r392E, sub(swizzle_x(r368E), swizzle_x(r368C)), 0x01));

                           ir_expression *const r392F = sub(swizzle_y(r368E), swizzle_y(r368C));
                           ir_expression *const r3930 = less(swizzle_x(r368E), swizzle_x(r368C));
                           ir_expression *const r3931 = expr(ir_unop_b2i, r3930);
                           ir_expression *const r3932 = expr(ir_unop_i2u, r3931);
                           body.emit(assign(r392D, sub(r392F, r3932), 0x01));

                           body.emit(assign(r368F, add(r368D, body.constant(int(-1))), 0x01));

                           ir_variable *const r3933 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3933, add(r368F, body.constant(int(-10))), 0x01));

                           ir_variable *const r3934 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3934, r392D, 0x01));

                           ir_variable *const r3935 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3935, r392E, 0x01));

                           ir_variable *const r3936 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r3936);
                           ir_variable *const r3937 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r3937);
                           /* IF CONDITION */
                           ir_expression *const r3939 = equal(r392D, body.constant(0u));
                           ir_if *f3938 = new(mem_ctx) ir_if(operand(r3939).val);
                           exec_list *const f3938_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3938->then_instructions;

                              body.emit(assign(r3934, r392E, 0x01));

                              body.emit(assign(r3935, body.constant(0u), 0x01));

                              body.emit(assign(r3933, add(r3933, body.constant(int(-32))), 0x01));


                           body.instructions = f3938_parent_instructions;
                           body.emit(f3938);

                           /* END IF */

                           ir_variable *const r393A = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r393A, r3934, 0x01));

                           ir_variable *const r393B = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r393C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r393C);
                           /* IF CONDITION */
                           ir_expression *const r393E = equal(r3934, body.constant(0u));
                           ir_if *f393D = new(mem_ctx) ir_if(operand(r393E).val);
                           exec_list *const f393D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f393D->then_instructions;

                              body.emit(assign(r393B, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f393D->else_instructions;

                              body.emit(assign(r393C, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3940 = bit_and(r3934, body.constant(4294901760u));
                              ir_expression *const r3941 = equal(r3940, body.constant(0u));
                              ir_if *f393F = new(mem_ctx) ir_if(operand(r3941).val);
                              exec_list *const f393F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f393F->then_instructions;

                                 body.emit(assign(r393C, body.constant(int(16)), 0x01));

                                 body.emit(assign(r393A, lshift(r3934, body.constant(int(16))), 0x01));


                              body.instructions = f393F_parent_instructions;
                              body.emit(f393F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3943 = bit_and(r393A, body.constant(4278190080u));
                              ir_expression *const r3944 = equal(r3943, body.constant(0u));
                              ir_if *f3942 = new(mem_ctx) ir_if(operand(r3944).val);
                              exec_list *const f3942_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3942->then_instructions;

                                 body.emit(assign(r393C, add(r393C, body.constant(int(8))), 0x01));

                                 body.emit(assign(r393A, lshift(r393A, body.constant(int(8))), 0x01));


                              body.instructions = f3942_parent_instructions;
                              body.emit(f3942);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3946 = bit_and(r393A, body.constant(4026531840u));
                              ir_expression *const r3947 = equal(r3946, body.constant(0u));
                              ir_if *f3945 = new(mem_ctx) ir_if(operand(r3947).val);
                              exec_list *const f3945_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3945->then_instructions;

                                 body.emit(assign(r393C, add(r393C, body.constant(int(4))), 0x01));

                                 body.emit(assign(r393A, lshift(r393A, body.constant(int(4))), 0x01));


                              body.instructions = f3945_parent_instructions;
                              body.emit(f3945);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3949 = bit_and(r393A, body.constant(3221225472u));
                              ir_expression *const r394A = equal(r3949, body.constant(0u));
                              ir_if *f3948 = new(mem_ctx) ir_if(operand(r394A).val);
                              exec_list *const f3948_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3948->then_instructions;

                                 body.emit(assign(r393C, add(r393C, body.constant(int(2))), 0x01));

                                 body.emit(assign(r393A, lshift(r393A, body.constant(int(2))), 0x01));


                              body.instructions = f3948_parent_instructions;
                              body.emit(f3948);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r394C = bit_and(r393A, body.constant(2147483648u));
                              ir_expression *const r394D = equal(r394C, body.constant(0u));
                              ir_if *f394B = new(mem_ctx) ir_if(operand(r394D).val);
                              exec_list *const f394B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f394B->then_instructions;

                                 body.emit(assign(r393C, add(r393C, body.constant(int(1))), 0x01));


                              body.instructions = f394B_parent_instructions;
                              body.emit(f394B);

                              /* END IF */

                              body.emit(assign(r393B, r393C, 0x01));


                           body.instructions = f393D_parent_instructions;
                           body.emit(f393D);

                           /* END IF */

                           body.emit(assign(r3937, add(r393B, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r394F = lequal(body.constant(int(0)), r3937);
                           ir_if *f394E = new(mem_ctx) ir_if(operand(r394F).val);
                           exec_list *const f394E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f394E->then_instructions;

                              body.emit(assign(r3936, body.constant(0u), 0x01));

                              ir_variable *const r3950 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r3950, lshift(r3935, r3937), 0x01));

                              ir_variable *const r3951 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3953 = equal(r3937, body.constant(int(0)));
                              ir_if *f3952 = new(mem_ctx) ir_if(operand(r3953).val);
                              exec_list *const f3952_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3952->then_instructions;

                                 body.emit(assign(r3951, r3934, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3952->else_instructions;

                                 ir_expression *const r3954 = lshift(r3934, r3937);
                                 ir_expression *const r3955 = neg(r3937);
                                 ir_expression *const r3956 = bit_and(r3955, body.constant(int(31)));
                                 ir_expression *const r3957 = rshift(r3935, r3956);
                                 body.emit(assign(r3951, bit_or(r3954, r3957), 0x01));


                              body.instructions = f3952_parent_instructions;
                              body.emit(f3952);

                              /* END IF */

                              body.emit(assign(r3934, r3951, 0x01));

                              body.emit(assign(r3935, r3950, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f394E->else_instructions;

                              ir_variable *const r3958 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3958, body.constant(0u), 0x01));

                              ir_variable *const r3959 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3959, neg(r3937), 0x01));

                              ir_variable *const r395A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r395A);
                              ir_variable *const r395B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r395B);
                              ir_variable *const r395C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r395C);
                              ir_variable *const r395D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r395E = neg(r3959);
                              body.emit(assign(r395D, bit_and(r395E, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3960 = equal(r3959, body.constant(int(0)));
                              ir_if *f395F = new(mem_ctx) ir_if(operand(r3960).val);
                              exec_list *const f395F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f395F->then_instructions;

                                 body.emit(assign(r395A, r3958, 0x01));

                                 body.emit(assign(r395B, r3935, 0x01));

                                 body.emit(assign(r395C, r3934, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f395F->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3962 = less(r3959, body.constant(int(32)));
                                 ir_if *f3961 = new(mem_ctx) ir_if(operand(r3962).val);
                                 exec_list *const f3961_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3961->then_instructions;

                                    body.emit(assign(r395A, lshift(r3935, r395D), 0x01));

                                    ir_expression *const r3963 = lshift(r3934, r395D);
                                    ir_expression *const r3964 = rshift(r3935, r3959);
                                    body.emit(assign(r395B, bit_or(r3963, r3964), 0x01));

                                    body.emit(assign(r395C, rshift(r3934, r3959), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3961->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3966 = equal(r3959, body.constant(int(32)));
                                    ir_if *f3965 = new(mem_ctx) ir_if(operand(r3966).val);
                                    exec_list *const f3965_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3965->then_instructions;

                                       body.emit(assign(r395A, r3935, 0x01));

                                       body.emit(assign(r395B, r3934, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3965->else_instructions;

                                       body.emit(assign(r3958, bit_or(body.constant(0u), r3935), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3968 = less(r3959, body.constant(int(64)));
                                       ir_if *f3967 = new(mem_ctx) ir_if(operand(r3968).val);
                                       exec_list *const f3967_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3967->then_instructions;

                                          body.emit(assign(r395A, lshift(r3934, r395D), 0x01));

                                          ir_expression *const r3969 = bit_and(r3959, body.constant(int(31)));
                                          body.emit(assign(r395B, rshift(r3934, r3969), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3967->else_instructions;

                                          ir_variable *const r396A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r396C = equal(r3959, body.constant(int(64)));
                                          ir_if *f396B = new(mem_ctx) ir_if(operand(r396C).val);
                                          exec_list *const f396B_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f396B->then_instructions;

                                             body.emit(assign(r396A, r3934, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f396B->else_instructions;

                                             ir_expression *const r396D = nequal(r3934, body.constant(0u));
                                             ir_expression *const r396E = expr(ir_unop_b2i, r396D);
                                             body.emit(assign(r396A, expr(ir_unop_i2u, r396E), 0x01));


                                          body.instructions = f396B_parent_instructions;
                                          body.emit(f396B);

                                          /* END IF */

                                          body.emit(assign(r395A, r396A, 0x01));

                                          body.emit(assign(r395B, body.constant(0u), 0x01));


                                       body.instructions = f3967_parent_instructions;
                                       body.emit(f3967);

                                       /* END IF */


                                    body.instructions = f3965_parent_instructions;
                                    body.emit(f3965);

                                    /* END IF */

                                    body.emit(assign(r395C, body.constant(0u), 0x01));


                                 body.instructions = f3961_parent_instructions;
                                 body.emit(f3961);

                                 /* END IF */

                                 ir_expression *const r396F = nequal(r3958, body.constant(0u));
                                 ir_expression *const r3970 = expr(ir_unop_b2i, r396F);
                                 ir_expression *const r3971 = expr(ir_unop_i2u, r3970);
                                 body.emit(assign(r395A, bit_or(r395A, r3971), 0x01));


                              body.instructions = f395F_parent_instructions;
                              body.emit(f395F);

                              /* END IF */

                              body.emit(assign(r3934, r395C, 0x01));

                              body.emit(assign(r3935, r395B, 0x01));

                              body.emit(assign(r3936, r395A, 0x01));


                           body.instructions = f394E_parent_instructions;
                           body.emit(f394E);

                           /* END IF */

                           body.emit(assign(r3933, sub(r3933, r3937), 0x01));

                           ir_variable *const r3972 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3972, r3933, 0x01));

                           ir_variable *const r3973 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3973, r3934, 0x01));

                           ir_variable *const r3974 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3974, r3935, 0x01));

                           ir_variable *const r3975 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r3975, r3936, 0x01));

                           ir_variable *const r3976 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r3976, body.constant(true), 0x01));

                           ir_variable *const r3977 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r3978 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r3978);
                           ir_expression *const r3979 = expr(ir_unop_u2i, r3936);
                           body.emit(assign(r3978, less(r3979, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r397B = lequal(body.constant(int(2045)), r3933);
                           ir_if *f397A = new(mem_ctx) ir_if(operand(r397B).val);
                           exec_list *const f397A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f397A->then_instructions;

                              ir_variable *const r397C = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r397E = less(body.constant(int(2045)), r3933);
                              ir_if *f397D = new(mem_ctx) ir_if(operand(r397E).val);
                              exec_list *const f397D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f397D->then_instructions;

                                 body.emit(assign(r397C, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f397D->else_instructions;

                                 ir_variable *const r397F = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3981 = equal(r3933, body.constant(int(2045)));
                                 ir_if *f3980 = new(mem_ctx) ir_if(operand(r3981).val);
                                 exec_list *const f3980_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3980->then_instructions;

                                    ir_expression *const r3982 = equal(body.constant(2097151u), r3934);
                                    ir_expression *const r3983 = equal(body.constant(4294967295u), r3935);
                                    body.emit(assign(r397F, logic_and(r3982, r3983), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3980->else_instructions;

                                    body.emit(assign(r397F, body.constant(false), 0x01));


                                 body.instructions = f3980_parent_instructions;
                                 body.emit(f3980);

                                 /* END IF */

                                 body.emit(assign(r397C, logic_and(r397F, r3978), 0x01));


                              body.instructions = f397D_parent_instructions;
                              body.emit(f397D);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f3984 = new(mem_ctx) ir_if(operand(r397C).val);
                              exec_list *const f3984_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3984->then_instructions;

                                 ir_variable *const r3985 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r3985);
                                 ir_expression *const r3986 = lshift(r3688, body.constant(int(31)));
                                 body.emit(assign(r3985, add(r3986, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r3985, body.constant(0u), 0x01));

                                 body.emit(assign(r3977, r3985, 0x03));

                                 body.emit(assign(r3976, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3984->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3988 = less(r3933, body.constant(int(0)));
                                 ir_if *f3987 = new(mem_ctx) ir_if(operand(r3988).val);
                                 exec_list *const f3987_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3987->then_instructions;

                                    ir_variable *const r3989 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r3989, r3936, 0x01));

                                    ir_variable *const r398A = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r398A, neg(r3933), 0x01));

                                    ir_variable *const r398B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r398B);
                                    ir_variable *const r398C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r398C);
                                    ir_variable *const r398D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r398D);
                                    ir_variable *const r398E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r398F = neg(r398A);
                                    body.emit(assign(r398E, bit_and(r398F, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3991 = equal(r398A, body.constant(int(0)));
                                    ir_if *f3990 = new(mem_ctx) ir_if(operand(r3991).val);
                                    exec_list *const f3990_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3990->then_instructions;

                                       body.emit(assign(r398B, r3936, 0x01));

                                       body.emit(assign(r398C, r3935, 0x01));

                                       body.emit(assign(r398D, r3934, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3990->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3993 = less(r398A, body.constant(int(32)));
                                       ir_if *f3992 = new(mem_ctx) ir_if(operand(r3993).val);
                                       exec_list *const f3992_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3992->then_instructions;

                                          body.emit(assign(r398B, lshift(r3935, r398E), 0x01));

                                          ir_expression *const r3994 = lshift(r3934, r398E);
                                          ir_expression *const r3995 = rshift(r3935, r398A);
                                          body.emit(assign(r398C, bit_or(r3994, r3995), 0x01));

                                          body.emit(assign(r398D, rshift(r3934, r398A), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3992->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r3997 = equal(r398A, body.constant(int(32)));
                                          ir_if *f3996 = new(mem_ctx) ir_if(operand(r3997).val);
                                          exec_list *const f3996_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3996->then_instructions;

                                             body.emit(assign(r398B, r3935, 0x01));

                                             body.emit(assign(r398C, r3934, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3996->else_instructions;

                                             body.emit(assign(r3989, bit_or(r3936, r3935), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r3999 = less(r398A, body.constant(int(64)));
                                             ir_if *f3998 = new(mem_ctx) ir_if(operand(r3999).val);
                                             exec_list *const f3998_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3998->then_instructions;

                                                body.emit(assign(r398B, lshift(r3934, r398E), 0x01));

                                                ir_expression *const r399A = bit_and(r398A, body.constant(int(31)));
                                                body.emit(assign(r398C, rshift(r3934, r399A), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3998->else_instructions;

                                                ir_variable *const r399B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r399D = equal(r398A, body.constant(int(64)));
                                                ir_if *f399C = new(mem_ctx) ir_if(operand(r399D).val);
                                                exec_list *const f399C_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f399C->then_instructions;

                                                   body.emit(assign(r399B, r3934, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f399C->else_instructions;

                                                   ir_expression *const r399E = nequal(r3934, body.constant(0u));
                                                   ir_expression *const r399F = expr(ir_unop_b2i, r399E);
                                                   body.emit(assign(r399B, expr(ir_unop_i2u, r399F), 0x01));


                                                body.instructions = f399C_parent_instructions;
                                                body.emit(f399C);

                                                /* END IF */

                                                body.emit(assign(r398B, r399B, 0x01));

                                                body.emit(assign(r398C, body.constant(0u), 0x01));


                                             body.instructions = f3998_parent_instructions;
                                             body.emit(f3998);

                                             /* END IF */


                                          body.instructions = f3996_parent_instructions;
                                          body.emit(f3996);

                                          /* END IF */

                                          body.emit(assign(r398D, body.constant(0u), 0x01));


                                       body.instructions = f3992_parent_instructions;
                                       body.emit(f3992);

                                       /* END IF */

                                       ir_expression *const r39A0 = nequal(r3989, body.constant(0u));
                                       ir_expression *const r39A1 = expr(ir_unop_b2i, r39A0);
                                       ir_expression *const r39A2 = expr(ir_unop_i2u, r39A1);
                                       body.emit(assign(r398B, bit_or(r398B, r39A2), 0x01));


                                    body.instructions = f3990_parent_instructions;
                                    body.emit(f3990);

                                    /* END IF */

                                    body.emit(assign(r3973, r398D, 0x01));

                                    body.emit(assign(r3974, r398C, 0x01));

                                    body.emit(assign(r3975, r398B, 0x01));

                                    body.emit(assign(r3972, body.constant(int(0)), 0x01));

                                    body.emit(assign(r3978, less(r398B, body.constant(0u)), 0x01));


                                 body.instructions = f3987_parent_instructions;
                                 body.emit(f3987);

                                 /* END IF */


                              body.instructions = f3984_parent_instructions;
                              body.emit(f3984);

                              /* END IF */


                           body.instructions = f397A_parent_instructions;
                           body.emit(f397A);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f39A3 = new(mem_ctx) ir_if(operand(r3976).val);
                           exec_list *const f39A3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f39A3->then_instructions;

                              /* IF CONDITION */
                              ir_if *f39A4 = new(mem_ctx) ir_if(operand(r3978).val);
                              exec_list *const f39A4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f39A4->then_instructions;

                                 ir_variable *const r39A5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r39A5, add(r3974, body.constant(1u)), 0x01));

                                 ir_expression *const r39A6 = less(r39A5, r3974);
                                 ir_expression *const r39A7 = expr(ir_unop_b2i, r39A6);
                                 ir_expression *const r39A8 = expr(ir_unop_i2u, r39A7);
                                 body.emit(assign(r3973, add(r3973, r39A8), 0x01));

                                 ir_expression *const r39A9 = equal(r3975, body.constant(0u));
                                 ir_expression *const r39AA = expr(ir_unop_b2i, r39A9);
                                 ir_expression *const r39AB = expr(ir_unop_i2u, r39AA);
                                 ir_expression *const r39AC = add(r3975, r39AB);
                                 ir_expression *const r39AD = bit_and(r39AC, body.constant(1u));
                                 ir_expression *const r39AE = expr(ir_unop_bit_not, r39AD);
                                 body.emit(assign(r3974, bit_and(r39A5, r39AE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f39A4->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r39B0 = bit_or(r3973, r3974);
                                 ir_expression *const r39B1 = equal(r39B0, body.constant(0u));
                                 ir_if *f39AF = new(mem_ctx) ir_if(operand(r39B1).val);
                                 exec_list *const f39AF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f39AF->then_instructions;

                                    body.emit(assign(r3972, body.constant(int(0)), 0x01));


                                 body.instructions = f39AF_parent_instructions;
                                 body.emit(f39AF);

                                 /* END IF */


                              body.instructions = f39A4_parent_instructions;
                              body.emit(f39A4);

                              /* END IF */

                              ir_variable *const r39B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r39B2);
                              ir_expression *const r39B3 = lshift(r3688, body.constant(int(31)));
                              ir_expression *const r39B4 = expr(ir_unop_i2u, r3972);
                              ir_expression *const r39B5 = lshift(r39B4, body.constant(int(20)));
                              ir_expression *const r39B6 = add(r39B3, r39B5);
                              body.emit(assign(r39B2, add(r39B6, r3973), 0x02));

                              body.emit(assign(r39B2, r3974, 0x01));

                              body.emit(assign(r3977, r39B2, 0x03));

                              body.emit(assign(r3976, body.constant(false), 0x01));


                           body.instructions = f39A3_parent_instructions;
                           body.emit(f39A3);

                           /* END IF */

                           body.emit(assign(r3689, r3977, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f392B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r39B8 = less(swizzle_x(r368E), swizzle_x(r368C));
                           ir_if *f39B7 = new(mem_ctx) ir_if(operand(r39B8).val);
                           exec_list *const f39B7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f39B7->then_instructions;

                              ir_variable *const r39B9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r39BA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r39BA, sub(swizzle_x(r368C), swizzle_x(r368E)), 0x01));

                              ir_expression *const r39BB = sub(swizzle_y(r368C), swizzle_y(r368E));
                              ir_expression *const r39BC = less(swizzle_x(r368C), swizzle_x(r368E));
                              ir_expression *const r39BD = expr(ir_unop_b2i, r39BC);
                              ir_expression *const r39BE = expr(ir_unop_i2u, r39BD);
                              body.emit(assign(r39B9, sub(r39BB, r39BE), 0x01));

                              body.emit(assign(r3688, bit_xor(r3688, body.constant(1u)), 0x01));

                              body.emit(assign(r368F, add(r368B, body.constant(int(-1))), 0x01));

                              ir_variable *const r39BF = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r39BF, add(r368F, body.constant(int(-10))), 0x01));

                              ir_variable *const r39C0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r39C0, r39B9, 0x01));

                              ir_variable *const r39C1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r39C1, r39BA, 0x01));

                              ir_variable *const r39C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r39C2);
                              ir_variable *const r39C3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r39C3);
                              /* IF CONDITION */
                              ir_expression *const r39C5 = equal(r39B9, body.constant(0u));
                              ir_if *f39C4 = new(mem_ctx) ir_if(operand(r39C5).val);
                              exec_list *const f39C4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f39C4->then_instructions;

                                 body.emit(assign(r39C0, r39BA, 0x01));

                                 body.emit(assign(r39C1, body.constant(0u), 0x01));

                                 body.emit(assign(r39BF, add(r39BF, body.constant(int(-32))), 0x01));


                              body.instructions = f39C4_parent_instructions;
                              body.emit(f39C4);

                              /* END IF */

                              ir_variable *const r39C6 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r39C6, r39C0, 0x01));

                              ir_variable *const r39C7 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r39C8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r39C8);
                              /* IF CONDITION */
                              ir_expression *const r39CA = equal(r39C0, body.constant(0u));
                              ir_if *f39C9 = new(mem_ctx) ir_if(operand(r39CA).val);
                              exec_list *const f39C9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f39C9->then_instructions;

                                 body.emit(assign(r39C7, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f39C9->else_instructions;

                                 body.emit(assign(r39C8, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r39CC = bit_and(r39C0, body.constant(4294901760u));
                                 ir_expression *const r39CD = equal(r39CC, body.constant(0u));
                                 ir_if *f39CB = new(mem_ctx) ir_if(operand(r39CD).val);
                                 exec_list *const f39CB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f39CB->then_instructions;

                                    body.emit(assign(r39C8, body.constant(int(16)), 0x01));

                                    body.emit(assign(r39C6, lshift(r39C0, body.constant(int(16))), 0x01));


                                 body.instructions = f39CB_parent_instructions;
                                 body.emit(f39CB);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r39CF = bit_and(r39C6, body.constant(4278190080u));
                                 ir_expression *const r39D0 = equal(r39CF, body.constant(0u));
                                 ir_if *f39CE = new(mem_ctx) ir_if(operand(r39D0).val);
                                 exec_list *const f39CE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f39CE->then_instructions;

                                    body.emit(assign(r39C8, add(r39C8, body.constant(int(8))), 0x01));

                                    body.emit(assign(r39C6, lshift(r39C6, body.constant(int(8))), 0x01));


                                 body.instructions = f39CE_parent_instructions;
                                 body.emit(f39CE);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r39D2 = bit_and(r39C6, body.constant(4026531840u));
                                 ir_expression *const r39D3 = equal(r39D2, body.constant(0u));
                                 ir_if *f39D1 = new(mem_ctx) ir_if(operand(r39D3).val);
                                 exec_list *const f39D1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f39D1->then_instructions;

                                    body.emit(assign(r39C8, add(r39C8, body.constant(int(4))), 0x01));

                                    body.emit(assign(r39C6, lshift(r39C6, body.constant(int(4))), 0x01));


                                 body.instructions = f39D1_parent_instructions;
                                 body.emit(f39D1);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r39D5 = bit_and(r39C6, body.constant(3221225472u));
                                 ir_expression *const r39D6 = equal(r39D5, body.constant(0u));
                                 ir_if *f39D4 = new(mem_ctx) ir_if(operand(r39D6).val);
                                 exec_list *const f39D4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f39D4->then_instructions;

                                    body.emit(assign(r39C8, add(r39C8, body.constant(int(2))), 0x01));

                                    body.emit(assign(r39C6, lshift(r39C6, body.constant(int(2))), 0x01));


                                 body.instructions = f39D4_parent_instructions;
                                 body.emit(f39D4);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r39D8 = bit_and(r39C6, body.constant(2147483648u));
                                 ir_expression *const r39D9 = equal(r39D8, body.constant(0u));
                                 ir_if *f39D7 = new(mem_ctx) ir_if(operand(r39D9).val);
                                 exec_list *const f39D7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f39D7->then_instructions;

                                    body.emit(assign(r39C8, add(r39C8, body.constant(int(1))), 0x01));


                                 body.instructions = f39D7_parent_instructions;
                                 body.emit(f39D7);

                                 /* END IF */

                                 body.emit(assign(r39C7, r39C8, 0x01));


                              body.instructions = f39C9_parent_instructions;
                              body.emit(f39C9);

                              /* END IF */

                              body.emit(assign(r39C3, add(r39C7, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r39DB = lequal(body.constant(int(0)), r39C3);
                              ir_if *f39DA = new(mem_ctx) ir_if(operand(r39DB).val);
                              exec_list *const f39DA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f39DA->then_instructions;

                                 body.emit(assign(r39C2, body.constant(0u), 0x01));

                                 ir_variable *const r39DC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r39DC, lshift(r39C1, r39C3), 0x01));

                                 ir_variable *const r39DD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r39DF = equal(r39C3, body.constant(int(0)));
                                 ir_if *f39DE = new(mem_ctx) ir_if(operand(r39DF).val);
                                 exec_list *const f39DE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f39DE->then_instructions;

                                    body.emit(assign(r39DD, r39C0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f39DE->else_instructions;

                                    ir_expression *const r39E0 = lshift(r39C0, r39C3);
                                    ir_expression *const r39E1 = neg(r39C3);
                                    ir_expression *const r39E2 = bit_and(r39E1, body.constant(int(31)));
                                    ir_expression *const r39E3 = rshift(r39C1, r39E2);
                                    body.emit(assign(r39DD, bit_or(r39E0, r39E3), 0x01));


                                 body.instructions = f39DE_parent_instructions;
                                 body.emit(f39DE);

                                 /* END IF */

                                 body.emit(assign(r39C0, r39DD, 0x01));

                                 body.emit(assign(r39C1, r39DC, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f39DA->else_instructions;

                                 ir_variable *const r39E4 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r39E4, body.constant(0u), 0x01));

                                 ir_variable *const r39E5 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r39E5, neg(r39C3), 0x01));

                                 ir_variable *const r39E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r39E6);
                                 ir_variable *const r39E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r39E7);
                                 ir_variable *const r39E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r39E8);
                                 ir_variable *const r39E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r39EA = neg(r39E5);
                                 body.emit(assign(r39E9, bit_and(r39EA, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r39EC = equal(r39E5, body.constant(int(0)));
                                 ir_if *f39EB = new(mem_ctx) ir_if(operand(r39EC).val);
                                 exec_list *const f39EB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f39EB->then_instructions;

                                    body.emit(assign(r39E6, r39E4, 0x01));

                                    body.emit(assign(r39E7, r39C1, 0x01));

                                    body.emit(assign(r39E8, r39C0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f39EB->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r39EE = less(r39E5, body.constant(int(32)));
                                    ir_if *f39ED = new(mem_ctx) ir_if(operand(r39EE).val);
                                    exec_list *const f39ED_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f39ED->then_instructions;

                                       body.emit(assign(r39E6, lshift(r39C1, r39E9), 0x01));

                                       ir_expression *const r39EF = lshift(r39C0, r39E9);
                                       ir_expression *const r39F0 = rshift(r39C1, r39E5);
                                       body.emit(assign(r39E7, bit_or(r39EF, r39F0), 0x01));

                                       body.emit(assign(r39E8, rshift(r39C0, r39E5), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f39ED->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r39F2 = equal(r39E5, body.constant(int(32)));
                                       ir_if *f39F1 = new(mem_ctx) ir_if(operand(r39F2).val);
                                       exec_list *const f39F1_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f39F1->then_instructions;

                                          body.emit(assign(r39E6, r39C1, 0x01));

                                          body.emit(assign(r39E7, r39C0, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f39F1->else_instructions;

                                          body.emit(assign(r39E4, bit_or(body.constant(0u), r39C1), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r39F4 = less(r39E5, body.constant(int(64)));
                                          ir_if *f39F3 = new(mem_ctx) ir_if(operand(r39F4).val);
                                          exec_list *const f39F3_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f39F3->then_instructions;

                                             body.emit(assign(r39E6, lshift(r39C0, r39E9), 0x01));

                                             ir_expression *const r39F5 = bit_and(r39E5, body.constant(int(31)));
                                             body.emit(assign(r39E7, rshift(r39C0, r39F5), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f39F3->else_instructions;

                                             ir_variable *const r39F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r39F8 = equal(r39E5, body.constant(int(64)));
                                             ir_if *f39F7 = new(mem_ctx) ir_if(operand(r39F8).val);
                                             exec_list *const f39F7_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f39F7->then_instructions;

                                                body.emit(assign(r39F6, r39C0, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f39F7->else_instructions;

                                                ir_expression *const r39F9 = nequal(r39C0, body.constant(0u));
                                                ir_expression *const r39FA = expr(ir_unop_b2i, r39F9);
                                                body.emit(assign(r39F6, expr(ir_unop_i2u, r39FA), 0x01));


                                             body.instructions = f39F7_parent_instructions;
                                             body.emit(f39F7);

                                             /* END IF */

                                             body.emit(assign(r39E6, r39F6, 0x01));

                                             body.emit(assign(r39E7, body.constant(0u), 0x01));


                                          body.instructions = f39F3_parent_instructions;
                                          body.emit(f39F3);

                                          /* END IF */


                                       body.instructions = f39F1_parent_instructions;
                                       body.emit(f39F1);

                                       /* END IF */

                                       body.emit(assign(r39E8, body.constant(0u), 0x01));


                                    body.instructions = f39ED_parent_instructions;
                                    body.emit(f39ED);

                                    /* END IF */

                                    ir_expression *const r39FB = nequal(r39E4, body.constant(0u));
                                    ir_expression *const r39FC = expr(ir_unop_b2i, r39FB);
                                    ir_expression *const r39FD = expr(ir_unop_i2u, r39FC);
                                    body.emit(assign(r39E6, bit_or(r39E6, r39FD), 0x01));


                                 body.instructions = f39EB_parent_instructions;
                                 body.emit(f39EB);

                                 /* END IF */

                                 body.emit(assign(r39C0, r39E8, 0x01));

                                 body.emit(assign(r39C1, r39E7, 0x01));

                                 body.emit(assign(r39C2, r39E6, 0x01));


                              body.instructions = f39DA_parent_instructions;
                              body.emit(f39DA);

                              /* END IF */

                              body.emit(assign(r39BF, sub(r39BF, r39C3), 0x01));

                              ir_variable *const r39FE = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r39FE, r39BF, 0x01));

                              ir_variable *const r39FF = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r39FF, r39C0, 0x01));

                              ir_variable *const r3A00 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r3A00, r39C1, 0x01));

                              ir_variable *const r3A01 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r3A01, r39C2, 0x01));

                              ir_variable *const r3A02 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r3A02, body.constant(true), 0x01));

                              ir_variable *const r3A03 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r3A04 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r3A04);
                              ir_expression *const r3A05 = expr(ir_unop_u2i, r39C2);
                              body.emit(assign(r3A04, less(r3A05, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3A07 = lequal(body.constant(int(2045)), r39BF);
                              ir_if *f3A06 = new(mem_ctx) ir_if(operand(r3A07).val);
                              exec_list *const f3A06_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3A06->then_instructions;

                                 ir_variable *const r3A08 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3A0A = less(body.constant(int(2045)), r39BF);
                                 ir_if *f3A09 = new(mem_ctx) ir_if(operand(r3A0A).val);
                                 exec_list *const f3A09_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3A09->then_instructions;

                                    body.emit(assign(r3A08, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3A09->else_instructions;

                                    ir_variable *const r3A0B = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3A0D = equal(r39BF, body.constant(int(2045)));
                                    ir_if *f3A0C = new(mem_ctx) ir_if(operand(r3A0D).val);
                                    exec_list *const f3A0C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3A0C->then_instructions;

                                       ir_expression *const r3A0E = equal(body.constant(2097151u), r39C0);
                                       ir_expression *const r3A0F = equal(body.constant(4294967295u), r39C1);
                                       body.emit(assign(r3A0B, logic_and(r3A0E, r3A0F), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3A0C->else_instructions;

                                       body.emit(assign(r3A0B, body.constant(false), 0x01));


                                    body.instructions = f3A0C_parent_instructions;
                                    body.emit(f3A0C);

                                    /* END IF */

                                    body.emit(assign(r3A08, logic_and(r3A0B, r3A04), 0x01));


                                 body.instructions = f3A09_parent_instructions;
                                 body.emit(f3A09);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f3A10 = new(mem_ctx) ir_if(operand(r3A08).val);
                                 exec_list *const f3A10_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3A10->then_instructions;

                                    ir_variable *const r3A11 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r3A11);
                                    ir_expression *const r3A12 = lshift(r3688, body.constant(int(31)));
                                    body.emit(assign(r3A11, add(r3A12, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r3A11, body.constant(0u), 0x01));

                                    body.emit(assign(r3A03, r3A11, 0x03));

                                    body.emit(assign(r3A02, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3A10->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3A14 = less(r39BF, body.constant(int(0)));
                                    ir_if *f3A13 = new(mem_ctx) ir_if(operand(r3A14).val);
                                    exec_list *const f3A13_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3A13->then_instructions;

                                       ir_variable *const r3A15 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r3A15, r39C2, 0x01));

                                       ir_variable *const r3A16 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r3A16, neg(r39BF), 0x01));

                                       ir_variable *const r3A17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r3A17);
                                       ir_variable *const r3A18 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r3A18);
                                       ir_variable *const r3A19 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r3A19);
                                       ir_variable *const r3A1A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r3A1B = neg(r3A16);
                                       body.emit(assign(r3A1A, bit_and(r3A1B, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3A1D = equal(r3A16, body.constant(int(0)));
                                       ir_if *f3A1C = new(mem_ctx) ir_if(operand(r3A1D).val);
                                       exec_list *const f3A1C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3A1C->then_instructions;

                                          body.emit(assign(r3A17, r39C2, 0x01));

                                          body.emit(assign(r3A18, r39C1, 0x01));

                                          body.emit(assign(r3A19, r39C0, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3A1C->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r3A1F = less(r3A16, body.constant(int(32)));
                                          ir_if *f3A1E = new(mem_ctx) ir_if(operand(r3A1F).val);
                                          exec_list *const f3A1E_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3A1E->then_instructions;

                                             body.emit(assign(r3A17, lshift(r39C1, r3A1A), 0x01));

                                             ir_expression *const r3A20 = lshift(r39C0, r3A1A);
                                             ir_expression *const r3A21 = rshift(r39C1, r3A16);
                                             body.emit(assign(r3A18, bit_or(r3A20, r3A21), 0x01));

                                             body.emit(assign(r3A19, rshift(r39C0, r3A16), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3A1E->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r3A23 = equal(r3A16, body.constant(int(32)));
                                             ir_if *f3A22 = new(mem_ctx) ir_if(operand(r3A23).val);
                                             exec_list *const f3A22_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3A22->then_instructions;

                                                body.emit(assign(r3A17, r39C1, 0x01));

                                                body.emit(assign(r3A18, r39C0, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3A22->else_instructions;

                                                body.emit(assign(r3A15, bit_or(r39C2, r39C1), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r3A25 = less(r3A16, body.constant(int(64)));
                                                ir_if *f3A24 = new(mem_ctx) ir_if(operand(r3A25).val);
                                                exec_list *const f3A24_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3A24->then_instructions;

                                                   body.emit(assign(r3A17, lshift(r39C0, r3A1A), 0x01));

                                                   ir_expression *const r3A26 = bit_and(r3A16, body.constant(int(31)));
                                                   body.emit(assign(r3A18, rshift(r39C0, r3A26), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3A24->else_instructions;

                                                   ir_variable *const r3A27 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r3A29 = equal(r3A16, body.constant(int(64)));
                                                   ir_if *f3A28 = new(mem_ctx) ir_if(operand(r3A29).val);
                                                   exec_list *const f3A28_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f3A28->then_instructions;

                                                      body.emit(assign(r3A27, r39C0, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f3A28->else_instructions;

                                                      ir_expression *const r3A2A = nequal(r39C0, body.constant(0u));
                                                      ir_expression *const r3A2B = expr(ir_unop_b2i, r3A2A);
                                                      body.emit(assign(r3A27, expr(ir_unop_i2u, r3A2B), 0x01));


                                                   body.instructions = f3A28_parent_instructions;
                                                   body.emit(f3A28);

                                                   /* END IF */

                                                   body.emit(assign(r3A17, r3A27, 0x01));

                                                   body.emit(assign(r3A18, body.constant(0u), 0x01));


                                                body.instructions = f3A24_parent_instructions;
                                                body.emit(f3A24);

                                                /* END IF */


                                             body.instructions = f3A22_parent_instructions;
                                             body.emit(f3A22);

                                             /* END IF */

                                             body.emit(assign(r3A19, body.constant(0u), 0x01));


                                          body.instructions = f3A1E_parent_instructions;
                                          body.emit(f3A1E);

                                          /* END IF */

                                          ir_expression *const r3A2C = nequal(r3A15, body.constant(0u));
                                          ir_expression *const r3A2D = expr(ir_unop_b2i, r3A2C);
                                          ir_expression *const r3A2E = expr(ir_unop_i2u, r3A2D);
                                          body.emit(assign(r3A17, bit_or(r3A17, r3A2E), 0x01));


                                       body.instructions = f3A1C_parent_instructions;
                                       body.emit(f3A1C);

                                       /* END IF */

                                       body.emit(assign(r39FF, r3A19, 0x01));

                                       body.emit(assign(r3A00, r3A18, 0x01));

                                       body.emit(assign(r3A01, r3A17, 0x01));

                                       body.emit(assign(r39FE, body.constant(int(0)), 0x01));

                                       body.emit(assign(r3A04, less(r3A17, body.constant(0u)), 0x01));


                                    body.instructions = f3A13_parent_instructions;
                                    body.emit(f3A13);

                                    /* END IF */


                                 body.instructions = f3A10_parent_instructions;
                                 body.emit(f3A10);

                                 /* END IF */


                              body.instructions = f3A06_parent_instructions;
                              body.emit(f3A06);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f3A2F = new(mem_ctx) ir_if(operand(r3A02).val);
                              exec_list *const f3A2F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3A2F->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f3A30 = new(mem_ctx) ir_if(operand(r3A04).val);
                                 exec_list *const f3A30_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3A30->then_instructions;

                                    ir_variable *const r3A31 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r3A31, add(r3A00, body.constant(1u)), 0x01));

                                    ir_expression *const r3A32 = less(r3A31, r3A00);
                                    ir_expression *const r3A33 = expr(ir_unop_b2i, r3A32);
                                    ir_expression *const r3A34 = expr(ir_unop_i2u, r3A33);
                                    body.emit(assign(r39FF, add(r39FF, r3A34), 0x01));

                                    ir_expression *const r3A35 = equal(r3A01, body.constant(0u));
                                    ir_expression *const r3A36 = expr(ir_unop_b2i, r3A35);
                                    ir_expression *const r3A37 = expr(ir_unop_i2u, r3A36);
                                    ir_expression *const r3A38 = add(r3A01, r3A37);
                                    ir_expression *const r3A39 = bit_and(r3A38, body.constant(1u));
                                    ir_expression *const r3A3A = expr(ir_unop_bit_not, r3A39);
                                    body.emit(assign(r3A00, bit_and(r3A31, r3A3A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3A30->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3A3C = bit_or(r39FF, r3A00);
                                    ir_expression *const r3A3D = equal(r3A3C, body.constant(0u));
                                    ir_if *f3A3B = new(mem_ctx) ir_if(operand(r3A3D).val);
                                    exec_list *const f3A3B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3A3B->then_instructions;

                                       body.emit(assign(r39FE, body.constant(int(0)), 0x01));


                                    body.instructions = f3A3B_parent_instructions;
                                    body.emit(f3A3B);

                                    /* END IF */


                                 body.instructions = f3A30_parent_instructions;
                                 body.emit(f3A30);

                                 /* END IF */

                                 ir_variable *const r3A3E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r3A3E);
                                 ir_expression *const r3A3F = lshift(r3688, body.constant(int(31)));
                                 ir_expression *const r3A40 = expr(ir_unop_i2u, r39FE);
                                 ir_expression *const r3A41 = lshift(r3A40, body.constant(int(20)));
                                 ir_expression *const r3A42 = add(r3A3F, r3A41);
                                 body.emit(assign(r3A3E, add(r3A42, r39FF), 0x02));

                                 body.emit(assign(r3A3E, r3A00, 0x01));

                                 body.emit(assign(r3A03, r3A3E, 0x03));

                                 body.emit(assign(r3A02, body.constant(false), 0x01));


                              body.instructions = f3A2F_parent_instructions;
                              body.emit(f3A2F);

                              /* END IF */

                              body.emit(assign(r3689, r3A03, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f39B7->else_instructions;

                              ir_variable *const r3A43 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3A43);
                              body.emit(assign(r3A43, body.constant(0u), 0x02));

                              body.emit(assign(r3A43, body.constant(0u), 0x01));

                              body.emit(assign(r3689, r3A43, 0x03));


                           body.instructions = f39B7_parent_instructions;
                           body.emit(f39B7);

                           /* END IF */


                        body.instructions = f392B_parent_instructions;
                        body.emit(f392B);

                        /* END IF */


                     body.instructions = f389F_parent_instructions;
                     body.emit(f389F);

                     /* END IF */


                  body.instructions = f3813_parent_instructions;
                  body.emit(f3813);

                  /* END IF */


               body.instructions = f37FE_parent_instructions;
               body.emit(f37FE);

               /* END IF */


            body.instructions = f374D_parent_instructions;
            body.emit(f374D);

            /* END IF */


         body.instructions = f369A_parent_instructions;
         body.emit(f369A);

         /* END IF */

         body.emit(assign(r3684, r3689, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3686->else_instructions;

         ir_variable *const r3A44 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r3A44, body.constant(true), 0x01));

         ir_variable *const r3A45 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r3A46 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r3A46);
         ir_variable *const r3A47 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r3A47);
         ir_variable *const r3A48 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r3A48);
         ir_variable *const r3A49 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r3A49);
         ir_variable *const r3A4A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r3A4A);
         ir_variable *const r3A4B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r3A4B);
         body.emit(assign(r3A4B, body.constant(0u), 0x01));

         body.emit(assign(r3A4A, body.constant(0u), 0x01));

         ir_variable *const r3A4C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r3A4C);
         body.emit(assign(r3A4C, bit_and(swizzle_y(r364F), body.constant(1048575u)), 0x02));

         body.emit(assign(r3A4C, swizzle_x(r364F), 0x01));

         body.emit(assign(r3A48, r3A4C, 0x03));

         ir_variable *const r3A4D = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r3A4E = rshift(swizzle_y(r364F), body.constant(int(20)));
         ir_expression *const r3A4F = bit_and(r3A4E, body.constant(2047u));
         body.emit(assign(r3A4D, expr(ir_unop_u2i, r3A4F), 0x01));

         ir_variable *const r3A50 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r3A50);
         body.emit(assign(r3A50, body.constant(0u), 0x02));

         body.emit(assign(r3A50, body.constant(0u), 0x01));

         body.emit(assign(r3A47, r3A50, 0x03));

         ir_variable *const r3A51 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r3A51, body.constant(int(1023)), 0x01));

         ir_variable *const r3A52 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r3A52, add(r3A4D, body.constant(int(-1023))), 0x01));

         body.emit(assign(r3A46, r3A52, 0x01));

         /* IF CONDITION */
         ir_expression *const r3A54 = less(body.constant(int(0)), r3A52);
         ir_if *f3A53 = new(mem_ctx) ir_if(operand(r3A54).val);
         exec_list *const f3A53_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A53->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3A56 = equal(r3A4D, body.constant(int(2047)));
            ir_if *f3A55 = new(mem_ctx) ir_if(operand(r3A56).val);
            exec_list *const f3A55_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A55->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3A58 = bit_or(swizzle_y(r3A4C), swizzle_x(r364F));
               ir_expression *const r3A59 = nequal(r3A58, body.constant(0u));
               ir_if *f3A57 = new(mem_ctx) ir_if(operand(r3A59).val);
               exec_list *const f3A57_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A57->then_instructions;

                  ir_variable *const r3A5A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r3A5A, swizzle_x(r364F), 0x01));

                  ir_variable *const r3A5B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r3A5B, body.constant(0u), 0x01));

                  ir_variable *const r3A5C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r3A5A, bit_or(swizzle_y(r364F), body.constant(524288u)), 0x02));

                  body.emit(assign(r3A5B, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3A5E = lshift(swizzle_y(r364F), body.constant(int(1)));
                  ir_expression *const r3A5F = lequal(body.constant(4292870144u), r3A5E);
                  ir_expression *const r3A60 = nequal(swizzle_x(r364F), body.constant(0u));
                  ir_expression *const r3A61 = bit_and(swizzle_y(r364F), body.constant(1048575u));
                  ir_expression *const r3A62 = nequal(r3A61, body.constant(0u));
                  ir_expression *const r3A63 = logic_or(r3A60, r3A62);
                  ir_expression *const r3A64 = logic_and(r3A5F, r3A63);
                  ir_if *f3A5D = new(mem_ctx) ir_if(operand(r3A64).val);
                  exec_list *const f3A5D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A5D->then_instructions;

                     body.emit(assign(r3A5C, r3A5A, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A5D->else_instructions;

                     body.emit(assign(r3A5C, r3A5B, 0x03));


                  body.instructions = f3A5D_parent_instructions;
                  body.emit(f3A5D);

                  /* END IF */

                  body.emit(assign(r3A45, r3A5C, 0x03));

                  body.emit(assign(r3A44, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A57->else_instructions;

                  body.emit(assign(r3A45, r364F, 0x03));

                  body.emit(assign(r3A44, body.constant(false), 0x01));


               body.instructions = f3A57_parent_instructions;
               body.emit(f3A57);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A55->else_instructions;

               body.emit(assign(r3A47, body.constant(1048576u), 0x02));

               ir_variable *const r3A65 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r3A65, swizzle_y(r3A47), 0x01));

               ir_variable *const r3A66 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r3A66, swizzle_x(r3A47), 0x01));

               ir_variable *const r3A67 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r3A67, body.constant(0u), 0x01));

               ir_variable *const r3A68 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r3A68);
               ir_variable *const r3A69 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3A69);
               ir_variable *const r3A6A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3A6A);
               ir_variable *const r3A6B = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3A6C = neg(r3A52);
               body.emit(assign(r3A6B, bit_and(r3A6C, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3A6E = equal(r3A52, body.constant(int(0)));
               ir_if *f3A6D = new(mem_ctx) ir_if(operand(r3A6E).val);
               exec_list *const f3A6D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A6D->then_instructions;

                  body.emit(assign(r3A68, r3A67, 0x01));

                  body.emit(assign(r3A69, r3A66, 0x01));

                  body.emit(assign(r3A6A, r3A65, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A6D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3A70 = less(r3A52, body.constant(int(32)));
                  ir_if *f3A6F = new(mem_ctx) ir_if(operand(r3A70).val);
                  exec_list *const f3A6F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A6F->then_instructions;

                     body.emit(assign(r3A68, body.constant(0u), 0x01));

                     ir_expression *const r3A71 = lshift(body.constant(1048576u), r3A6B);
                     body.emit(assign(r3A69, bit_or(r3A71, body.constant(0u)), 0x01));

                     body.emit(assign(r3A6A, rshift(body.constant(1048576u), r3A52), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A6F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3A73 = equal(r3A52, body.constant(int(32)));
                     ir_if *f3A72 = new(mem_ctx) ir_if(operand(r3A73).val);
                     exec_list *const f3A72_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A72->then_instructions;

                        body.emit(assign(r3A68, r3A66, 0x01));

                        body.emit(assign(r3A69, r3A65, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3A72->else_instructions;

                        body.emit(assign(r3A67, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3A75 = less(r3A52, body.constant(int(64)));
                        ir_if *f3A74 = new(mem_ctx) ir_if(operand(r3A75).val);
                        exec_list *const f3A74_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3A74->then_instructions;

                           body.emit(assign(r3A68, lshift(body.constant(1048576u), r3A6B), 0x01));

                           ir_expression *const r3A76 = bit_and(r3A52, body.constant(int(31)));
                           body.emit(assign(r3A69, rshift(body.constant(1048576u), r3A76), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3A74->else_instructions;

                           ir_variable *const r3A77 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3A79 = equal(r3A52, body.constant(int(64)));
                           ir_if *f3A78 = new(mem_ctx) ir_if(operand(r3A79).val);
                           exec_list *const f3A78_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3A78->then_instructions;

                              body.emit(assign(r3A77, r3A65, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3A78->else_instructions;

                              body.emit(assign(r3A77, body.constant(1u), 0x01));


                           body.instructions = f3A78_parent_instructions;
                           body.emit(f3A78);

                           /* END IF */

                           body.emit(assign(r3A68, r3A77, 0x01));

                           body.emit(assign(r3A69, body.constant(0u), 0x01));


                        body.instructions = f3A74_parent_instructions;
                        body.emit(f3A74);

                        /* END IF */


                     body.instructions = f3A72_parent_instructions;
                     body.emit(f3A72);

                     /* END IF */

                     body.emit(assign(r3A6A, body.constant(0u), 0x01));


                  body.instructions = f3A6F_parent_instructions;
                  body.emit(f3A6F);

                  /* END IF */

                  ir_expression *const r3A7A = nequal(r3A67, body.constant(0u));
                  ir_expression *const r3A7B = expr(ir_unop_b2i, r3A7A);
                  ir_expression *const r3A7C = expr(ir_unop_i2u, r3A7B);
                  body.emit(assign(r3A68, bit_or(r3A68, r3A7C), 0x01));


               body.instructions = f3A6D_parent_instructions;
               body.emit(f3A6D);

               /* END IF */

               body.emit(assign(r3A47, r3A6A, 0x02));

               body.emit(assign(r3A47, r3A69, 0x01));

               body.emit(assign(r3A4A, r3A68, 0x01));

               body.emit(assign(r3A49, r3A4D, 0x01));


            body.instructions = f3A55_parent_instructions;
            body.emit(f3A55);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3A53->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3A7E = less(r3A52, body.constant(int(0)));
            ir_if *f3A7D = new(mem_ctx) ir_if(operand(r3A7E).val);
            exec_list *const f3A7D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A7D->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3A80 = equal(r3A4D, body.constant(int(0)));
               ir_if *f3A7F = new(mem_ctx) ir_if(operand(r3A80).val);
               exec_list *const f3A7F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A7F->then_instructions;

                  body.emit(assign(r3A46, add(r3A52, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A7F->else_instructions;

                  body.emit(assign(r3A48, bit_or(swizzle_y(r3A4C), body.constant(1048576u)), 0x02));


               body.instructions = f3A7F_parent_instructions;
               body.emit(f3A7F);

               /* END IF */

               ir_variable *const r3A81 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r3A81, swizzle_y(r3A48), 0x01));

               ir_variable *const r3A82 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r3A82, swizzle_x(r3A48), 0x01));

               ir_variable *const r3A83 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r3A83, body.constant(0u), 0x01));

               ir_variable *const r3A84 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r3A84, neg(r3A46), 0x01));

               ir_variable *const r3A85 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r3A85);
               ir_variable *const r3A86 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3A86);
               ir_variable *const r3A87 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3A87);
               ir_variable *const r3A88 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3A89 = neg(r3A84);
               body.emit(assign(r3A88, bit_and(r3A89, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3A8B = equal(r3A84, body.constant(int(0)));
               ir_if *f3A8A = new(mem_ctx) ir_if(operand(r3A8B).val);
               exec_list *const f3A8A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A8A->then_instructions;

                  body.emit(assign(r3A85, r3A83, 0x01));

                  body.emit(assign(r3A86, r3A82, 0x01));

                  body.emit(assign(r3A87, r3A81, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A8A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3A8D = less(r3A84, body.constant(int(32)));
                  ir_if *f3A8C = new(mem_ctx) ir_if(operand(r3A8D).val);
                  exec_list *const f3A8C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A8C->then_instructions;

                     body.emit(assign(r3A85, lshift(swizzle_x(r3A4C), r3A88), 0x01));

                     ir_expression *const r3A8E = lshift(swizzle_y(r3A48), r3A88);
                     ir_expression *const r3A8F = rshift(swizzle_x(r3A4C), r3A84);
                     body.emit(assign(r3A86, bit_or(r3A8E, r3A8F), 0x01));

                     body.emit(assign(r3A87, rshift(swizzle_y(r3A48), r3A84), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A8C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3A91 = equal(r3A84, body.constant(int(32)));
                     ir_if *f3A90 = new(mem_ctx) ir_if(operand(r3A91).val);
                     exec_list *const f3A90_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A90->then_instructions;

                        body.emit(assign(r3A85, r3A82, 0x01));

                        body.emit(assign(r3A86, r3A81, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3A90->else_instructions;

                        body.emit(assign(r3A83, bit_or(body.constant(0u), swizzle_x(r3A4C)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3A93 = less(r3A84, body.constant(int(64)));
                        ir_if *f3A92 = new(mem_ctx) ir_if(operand(r3A93).val);
                        exec_list *const f3A92_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3A92->then_instructions;

                           body.emit(assign(r3A85, lshift(swizzle_y(r3A48), r3A88), 0x01));

                           ir_expression *const r3A94 = bit_and(r3A84, body.constant(int(31)));
                           body.emit(assign(r3A86, rshift(swizzle_y(r3A48), r3A94), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3A92->else_instructions;

                           ir_variable *const r3A95 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3A97 = equal(r3A84, body.constant(int(64)));
                           ir_if *f3A96 = new(mem_ctx) ir_if(operand(r3A97).val);
                           exec_list *const f3A96_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3A96->then_instructions;

                              body.emit(assign(r3A95, r3A81, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3A96->else_instructions;

                              ir_expression *const r3A98 = nequal(swizzle_y(r3A48), body.constant(0u));
                              ir_expression *const r3A99 = expr(ir_unop_b2i, r3A98);
                              body.emit(assign(r3A95, expr(ir_unop_i2u, r3A99), 0x01));


                           body.instructions = f3A96_parent_instructions;
                           body.emit(f3A96);

                           /* END IF */

                           body.emit(assign(r3A85, r3A95, 0x01));

                           body.emit(assign(r3A86, body.constant(0u), 0x01));


                        body.instructions = f3A92_parent_instructions;
                        body.emit(f3A92);

                        /* END IF */


                     body.instructions = f3A90_parent_instructions;
                     body.emit(f3A90);

                     /* END IF */

                     body.emit(assign(r3A87, body.constant(0u), 0x01));


                  body.instructions = f3A8C_parent_instructions;
                  body.emit(f3A8C);

                  /* END IF */

                  ir_expression *const r3A9A = nequal(r3A83, body.constant(0u));
                  ir_expression *const r3A9B = expr(ir_unop_b2i, r3A9A);
                  ir_expression *const r3A9C = expr(ir_unop_i2u, r3A9B);
                  body.emit(assign(r3A85, bit_or(r3A85, r3A9C), 0x01));


               body.instructions = f3A8A_parent_instructions;
               body.emit(f3A8A);

               /* END IF */

               body.emit(assign(r3A48, r3A87, 0x02));

               body.emit(assign(r3A48, r3A86, 0x01));

               body.emit(assign(r3A4A, r3A85, 0x01));

               body.emit(assign(r3A49, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A7D->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3A9E = equal(r3A4D, body.constant(int(2047)));
               ir_if *f3A9D = new(mem_ctx) ir_if(operand(r3A9E).val);
               exec_list *const f3A9D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A9D->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3AA0 = bit_or(swizzle_y(r3A48), swizzle_x(r3A48));
                  ir_expression *const r3AA1 = bit_or(swizzle_y(r3A47), swizzle_x(r3A47));
                  ir_expression *const r3AA2 = bit_or(r3AA0, r3AA1);
                  ir_expression *const r3AA3 = nequal(r3AA2, body.constant(0u));
                  ir_if *f3A9F = new(mem_ctx) ir_if(operand(r3AA3).val);
                  exec_list *const f3A9F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A9F->then_instructions;

                     ir_variable *const r3AA4 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r3AA4, swizzle_x(r364F), 0x01));

                     ir_variable *const r3AA5 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r3AA5, body.constant(0u), 0x01));

                     ir_variable *const r3AA6 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r3AA4, bit_or(swizzle_y(r364F), body.constant(524288u)), 0x02));

                     body.emit(assign(r3AA5, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r3AA8 = lshift(swizzle_y(r364F), body.constant(int(1)));
                     ir_expression *const r3AA9 = lequal(body.constant(4292870144u), r3AA8);
                     ir_expression *const r3AAA = nequal(swizzle_x(r364F), body.constant(0u));
                     ir_expression *const r3AAB = bit_and(swizzle_y(r364F), body.constant(1048575u));
                     ir_expression *const r3AAC = nequal(r3AAB, body.constant(0u));
                     ir_expression *const r3AAD = logic_or(r3AAA, r3AAC);
                     ir_expression *const r3AAE = logic_and(r3AA9, r3AAD);
                     ir_if *f3AA7 = new(mem_ctx) ir_if(operand(r3AAE).val);
                     exec_list *const f3AA7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AA7->then_instructions;

                        body.emit(assign(r3AA6, r3AA4, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3AA7->else_instructions;

                        body.emit(assign(r3AA6, r3AA5, 0x03));


                     body.instructions = f3AA7_parent_instructions;
                     body.emit(f3AA7);

                     /* END IF */

                     body.emit(assign(r3A45, r3AA6, 0x03));

                     body.emit(assign(r3A44, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A9F->else_instructions;

                     body.emit(assign(r3A45, r364F, 0x03));

                     body.emit(assign(r3A44, body.constant(false), 0x01));


                  body.instructions = f3A9F_parent_instructions;
                  body.emit(f3A9F);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A9D->else_instructions;

                  ir_variable *const r3AAF = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r3AB0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3AB0, add(swizzle_x(r3A48), swizzle_x(r3A47)), 0x01));

                  ir_expression *const r3AB1 = add(swizzle_y(r3A48), swizzle_y(r3A47));
                  ir_expression *const r3AB2 = less(r3AB0, swizzle_x(r3A48));
                  ir_expression *const r3AB3 = expr(ir_unop_b2i, r3AB2);
                  ir_expression *const r3AB4 = expr(ir_unop_i2u, r3AB3);
                  body.emit(assign(r3AAF, add(r3AB1, r3AB4), 0x01));

                  body.emit(assign(r3A4B, r3AAF, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3AB6 = equal(r3A4D, body.constant(int(0)));
                  ir_if *f3AB5 = new(mem_ctx) ir_if(operand(r3AB6).val);
                  exec_list *const f3AB5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3AB5->then_instructions;

                     ir_variable *const r3AB7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3AB7);
                     ir_expression *const r3AB8 = lshift(r3685, body.constant(int(31)));
                     body.emit(assign(r3AB7, add(r3AB8, r3AAF), 0x02));

                     body.emit(assign(r3AB7, r3AB0, 0x01));

                     body.emit(assign(r3A45, r3AB7, 0x03));

                     body.emit(assign(r3A44, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3AB5->else_instructions;

                     body.emit(assign(r3A4B, bit_or(r3AAF, body.constant(2097152u)), 0x01));

                     body.emit(assign(r3A49, r3A4D, 0x01));

                     ir_variable *const r3AB9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3AB9);
                     ir_variable *const r3ABA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3ABA);
                     ir_variable *const r3ABB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3ABB);
                     body.emit(assign(r3AB9, lshift(r3AB0, body.constant(int(31))), 0x01));

                     ir_expression *const r3ABC = lshift(r3A4B, body.constant(int(31)));
                     ir_expression *const r3ABD = rshift(r3AB0, body.constant(int(1)));
                     body.emit(assign(r3ABA, bit_or(r3ABC, r3ABD), 0x01));

                     body.emit(assign(r3ABB, rshift(r3A4B, body.constant(int(1))), 0x01));

                     body.emit(assign(r3AB9, bit_or(r3AB9, body.constant(0u)), 0x01));

                     body.emit(assign(r3A4B, r3ABB, 0x01));

                     body.emit(assign(r3A4A, r3AB9, 0x01));

                     ir_variable *const r3ABE = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3ABE, r3A4D, 0x01));

                     ir_variable *const r3ABF = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r3ABF, r3ABB, 0x01));

                     ir_variable *const r3AC0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r3AC0, r3ABA, 0x01));

                     ir_variable *const r3AC1 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r3AC1, r3AB9, 0x01));

                     ir_variable *const r3AC2 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r3AC2, body.constant(true), 0x01));

                     ir_variable *const r3AC3 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r3AC4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r3AC4);
                     ir_expression *const r3AC5 = expr(ir_unop_u2i, r3AB9);
                     body.emit(assign(r3AC4, less(r3AC5, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3AC7 = lequal(body.constant(int(2045)), r3A4D);
                     ir_if *f3AC6 = new(mem_ctx) ir_if(operand(r3AC7).val);
                     exec_list *const f3AC6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AC6->then_instructions;

                        ir_variable *const r3AC8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3ACA = less(body.constant(int(2045)), r3A4D);
                        ir_if *f3AC9 = new(mem_ctx) ir_if(operand(r3ACA).val);
                        exec_list *const f3AC9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AC9->then_instructions;

                           body.emit(assign(r3AC8, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3AC9->else_instructions;

                           ir_variable *const r3ACB = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3ACD = equal(r3A4D, body.constant(int(2045)));
                           ir_if *f3ACC = new(mem_ctx) ir_if(operand(r3ACD).val);
                           exec_list *const f3ACC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3ACC->then_instructions;

                              ir_expression *const r3ACE = equal(body.constant(2097151u), r3ABB);
                              ir_expression *const r3ACF = equal(body.constant(4294967295u), r3ABA);
                              body.emit(assign(r3ACB, logic_and(r3ACE, r3ACF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3ACC->else_instructions;

                              body.emit(assign(r3ACB, body.constant(false), 0x01));


                           body.instructions = f3ACC_parent_instructions;
                           body.emit(f3ACC);

                           /* END IF */

                           body.emit(assign(r3AC8, logic_and(r3ACB, r3AC4), 0x01));


                        body.instructions = f3AC9_parent_instructions;
                        body.emit(f3AC9);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3AD0 = new(mem_ctx) ir_if(operand(r3AC8).val);
                        exec_list *const f3AD0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AD0->then_instructions;

                           ir_variable *const r3AD1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3AD1);
                           ir_expression *const r3AD2 = lshift(r3685, body.constant(int(31)));
                           body.emit(assign(r3AD1, add(r3AD2, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r3AD1, body.constant(0u), 0x01));

                           body.emit(assign(r3AC3, r3AD1, 0x03));

                           body.emit(assign(r3AC2, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3AD0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3AD4 = less(r3A4D, body.constant(int(0)));
                           ir_if *f3AD3 = new(mem_ctx) ir_if(operand(r3AD4).val);
                           exec_list *const f3AD3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3AD3->then_instructions;

                              ir_variable *const r3AD5 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3AD5, r3AB9, 0x01));

                              ir_variable *const r3AD6 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3AD6, neg(r3A4D), 0x01));

                              ir_variable *const r3AD7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3AD7);
                              ir_variable *const r3AD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3AD8);
                              ir_variable *const r3AD9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3AD9);
                              ir_variable *const r3ADA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3ADB = neg(r3AD6);
                              body.emit(assign(r3ADA, bit_and(r3ADB, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3ADD = equal(r3AD6, body.constant(int(0)));
                              ir_if *f3ADC = new(mem_ctx) ir_if(operand(r3ADD).val);
                              exec_list *const f3ADC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3ADC->then_instructions;

                                 body.emit(assign(r3AD7, r3AB9, 0x01));

                                 body.emit(assign(r3AD8, r3ABA, 0x01));

                                 body.emit(assign(r3AD9, r3ABB, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3ADC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3ADF = less(r3AD6, body.constant(int(32)));
                                 ir_if *f3ADE = new(mem_ctx) ir_if(operand(r3ADF).val);
                                 exec_list *const f3ADE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3ADE->then_instructions;

                                    body.emit(assign(r3AD7, lshift(r3ABA, r3ADA), 0x01));

                                    ir_expression *const r3AE0 = lshift(r3ABB, r3ADA);
                                    ir_expression *const r3AE1 = rshift(r3ABA, r3AD6);
                                    body.emit(assign(r3AD8, bit_or(r3AE0, r3AE1), 0x01));

                                    body.emit(assign(r3AD9, rshift(r3ABB, r3AD6), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3ADE->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3AE3 = equal(r3AD6, body.constant(int(32)));
                                    ir_if *f3AE2 = new(mem_ctx) ir_if(operand(r3AE3).val);
                                    exec_list *const f3AE2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3AE2->then_instructions;

                                       body.emit(assign(r3AD7, r3ABA, 0x01));

                                       body.emit(assign(r3AD8, r3ABB, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3AE2->else_instructions;

                                       body.emit(assign(r3AD5, bit_or(r3AB9, r3ABA), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3AE5 = less(r3AD6, body.constant(int(64)));
                                       ir_if *f3AE4 = new(mem_ctx) ir_if(operand(r3AE5).val);
                                       exec_list *const f3AE4_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3AE4->then_instructions;

                                          body.emit(assign(r3AD7, lshift(r3ABB, r3ADA), 0x01));

                                          ir_expression *const r3AE6 = bit_and(r3AD6, body.constant(int(31)));
                                          body.emit(assign(r3AD8, rshift(r3ABB, r3AE6), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3AE4->else_instructions;

                                          ir_variable *const r3AE7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3AE9 = equal(r3AD6, body.constant(int(64)));
                                          ir_if *f3AE8 = new(mem_ctx) ir_if(operand(r3AE9).val);
                                          exec_list *const f3AE8_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3AE8->then_instructions;

                                             body.emit(assign(r3AE7, r3ABB, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3AE8->else_instructions;

                                             ir_expression *const r3AEA = nequal(r3ABB, body.constant(0u));
                                             ir_expression *const r3AEB = expr(ir_unop_b2i, r3AEA);
                                             body.emit(assign(r3AE7, expr(ir_unop_i2u, r3AEB), 0x01));


                                          body.instructions = f3AE8_parent_instructions;
                                          body.emit(f3AE8);

                                          /* END IF */

                                          body.emit(assign(r3AD7, r3AE7, 0x01));

                                          body.emit(assign(r3AD8, body.constant(0u), 0x01));


                                       body.instructions = f3AE4_parent_instructions;
                                       body.emit(f3AE4);

                                       /* END IF */


                                    body.instructions = f3AE2_parent_instructions;
                                    body.emit(f3AE2);

                                    /* END IF */

                                    body.emit(assign(r3AD9, body.constant(0u), 0x01));


                                 body.instructions = f3ADE_parent_instructions;
                                 body.emit(f3ADE);

                                 /* END IF */

                                 ir_expression *const r3AEC = nequal(r3AD5, body.constant(0u));
                                 ir_expression *const r3AED = expr(ir_unop_b2i, r3AEC);
                                 ir_expression *const r3AEE = expr(ir_unop_i2u, r3AED);
                                 body.emit(assign(r3AD7, bit_or(r3AD7, r3AEE), 0x01));


                              body.instructions = f3ADC_parent_instructions;
                              body.emit(f3ADC);

                              /* END IF */

                              body.emit(assign(r3ABF, r3AD9, 0x01));

                              body.emit(assign(r3AC0, r3AD8, 0x01));

                              body.emit(assign(r3AC1, r3AD7, 0x01));

                              body.emit(assign(r3ABE, body.constant(int(0)), 0x01));

                              body.emit(assign(r3AC4, less(r3AD7, body.constant(0u)), 0x01));


                           body.instructions = f3AD3_parent_instructions;
                           body.emit(f3AD3);

                           /* END IF */


                        body.instructions = f3AD0_parent_instructions;
                        body.emit(f3AD0);

                        /* END IF */


                     body.instructions = f3AC6_parent_instructions;
                     body.emit(f3AC6);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3AEF = new(mem_ctx) ir_if(operand(r3AC2).val);
                     exec_list *const f3AEF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AEF->then_instructions;

                        /* IF CONDITION */
                        ir_if *f3AF0 = new(mem_ctx) ir_if(operand(r3AC4).val);
                        exec_list *const f3AF0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AF0->then_instructions;

                           ir_variable *const r3AF1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r3AF1, add(r3AC0, body.constant(1u)), 0x01));

                           ir_expression *const r3AF2 = less(r3AF1, r3AC0);
                           ir_expression *const r3AF3 = expr(ir_unop_b2i, r3AF2);
                           ir_expression *const r3AF4 = expr(ir_unop_i2u, r3AF3);
                           body.emit(assign(r3ABF, add(r3ABF, r3AF4), 0x01));

                           ir_expression *const r3AF5 = equal(r3AC1, body.constant(0u));
                           ir_expression *const r3AF6 = expr(ir_unop_b2i, r3AF5);
                           ir_expression *const r3AF7 = expr(ir_unop_i2u, r3AF6);
                           ir_expression *const r3AF8 = add(r3AC1, r3AF7);
                           ir_expression *const r3AF9 = bit_and(r3AF8, body.constant(1u));
                           ir_expression *const r3AFA = expr(ir_unop_bit_not, r3AF9);
                           body.emit(assign(r3AC0, bit_and(r3AF1, r3AFA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3AF0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3AFC = bit_or(r3ABF, r3AC0);
                           ir_expression *const r3AFD = equal(r3AFC, body.constant(0u));
                           ir_if *f3AFB = new(mem_ctx) ir_if(operand(r3AFD).val);
                           exec_list *const f3AFB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3AFB->then_instructions;

                              body.emit(assign(r3ABE, body.constant(int(0)), 0x01));


                           body.instructions = f3AFB_parent_instructions;
                           body.emit(f3AFB);

                           /* END IF */


                        body.instructions = f3AF0_parent_instructions;
                        body.emit(f3AF0);

                        /* END IF */

                        ir_variable *const r3AFE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3AFE);
                        ir_expression *const r3AFF = lshift(r3685, body.constant(int(31)));
                        ir_expression *const r3B00 = expr(ir_unop_i2u, r3ABE);
                        ir_expression *const r3B01 = lshift(r3B00, body.constant(int(20)));
                        ir_expression *const r3B02 = add(r3AFF, r3B01);
                        body.emit(assign(r3AFE, add(r3B02, r3ABF), 0x02));

                        body.emit(assign(r3AFE, r3AC0, 0x01));

                        body.emit(assign(r3AC3, r3AFE, 0x03));

                        body.emit(assign(r3AC2, body.constant(false), 0x01));


                     body.instructions = f3AEF_parent_instructions;
                     body.emit(f3AEF);

                     /* END IF */

                     body.emit(assign(r3A45, r3AC3, 0x03));

                     body.emit(assign(r3A44, body.constant(false), 0x01));


                  body.instructions = f3AB5_parent_instructions;
                  body.emit(f3AB5);

                  /* END IF */


               body.instructions = f3A9D_parent_instructions;
               body.emit(f3A9D);

               /* END IF */


            body.instructions = f3A7D_parent_instructions;
            body.emit(f3A7D);

            /* END IF */


         body.instructions = f3A53_parent_instructions;
         body.emit(f3A53);

         /* END IF */

         /* IF CONDITION */
         ir_if *f3B03 = new(mem_ctx) ir_if(operand(r3A44).val);
         exec_list *const f3B03_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3B03->then_instructions;

            body.emit(assign(r3A48, bit_or(swizzle_y(r3A48), body.constant(1048576u)), 0x02));

            ir_variable *const r3B04 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r3B05 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r3B05, add(swizzle_x(r3A48), swizzle_x(r3A47)), 0x01));

            ir_expression *const r3B06 = add(swizzle_y(r3A48), swizzle_y(r3A47));
            ir_expression *const r3B07 = less(r3B05, swizzle_x(r3A48));
            ir_expression *const r3B08 = expr(ir_unop_b2i, r3B07);
            ir_expression *const r3B09 = expr(ir_unop_i2u, r3B08);
            body.emit(assign(r3B04, add(r3B06, r3B09), 0x01));

            body.emit(assign(r3A4B, r3B04, 0x01));

            body.emit(assign(r3A49, add(r3A49, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3B0B = less(r3B04, body.constant(2097152u));
            ir_if *f3B0A = new(mem_ctx) ir_if(operand(r3B0B).val);
            exec_list *const f3B0A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3B0A->then_instructions;

               ir_variable *const r3B0C = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3B0C, r3A49, 0x01));

               ir_variable *const r3B0D = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3B0D, r3B04, 0x01));

               ir_variable *const r3B0E = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3B0E, r3B05, 0x01));

               ir_variable *const r3B0F = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3B0F, r3A4A, 0x01));

               ir_variable *const r3B10 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3B10, body.constant(true), 0x01));

               ir_variable *const r3B11 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3B12 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3B12);
               ir_expression *const r3B13 = expr(ir_unop_u2i, r3A4A);
               body.emit(assign(r3B12, less(r3B13, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3B15 = lequal(body.constant(int(2045)), r3A49);
               ir_if *f3B14 = new(mem_ctx) ir_if(operand(r3B15).val);
               exec_list *const f3B14_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3B14->then_instructions;

                  ir_variable *const r3B16 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3B18 = less(body.constant(int(2045)), r3A49);
                  ir_if *f3B17 = new(mem_ctx) ir_if(operand(r3B18).val);
                  exec_list *const f3B17_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B17->then_instructions;

                     body.emit(assign(r3B16, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B17->else_instructions;

                     ir_variable *const r3B19 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3B1B = equal(r3A49, body.constant(int(2045)));
                     ir_if *f3B1A = new(mem_ctx) ir_if(operand(r3B1B).val);
                     exec_list *const f3B1A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B1A->then_instructions;

                        ir_expression *const r3B1C = equal(body.constant(2097151u), r3B04);
                        ir_expression *const r3B1D = equal(body.constant(4294967295u), r3B05);
                        body.emit(assign(r3B19, logic_and(r3B1C, r3B1D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3B1A->else_instructions;

                        body.emit(assign(r3B19, body.constant(false), 0x01));


                     body.instructions = f3B1A_parent_instructions;
                     body.emit(f3B1A);

                     /* END IF */

                     body.emit(assign(r3B16, logic_and(r3B19, r3B12), 0x01));


                  body.instructions = f3B17_parent_instructions;
                  body.emit(f3B17);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3B1E = new(mem_ctx) ir_if(operand(r3B16).val);
                  exec_list *const f3B1E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B1E->then_instructions;

                     ir_variable *const r3B1F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3B1F);
                     ir_expression *const r3B20 = lshift(r3685, body.constant(int(31)));
                     body.emit(assign(r3B1F, add(r3B20, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3B1F, body.constant(0u), 0x01));

                     body.emit(assign(r3B11, r3B1F, 0x03));

                     body.emit(assign(r3B10, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B1E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3B22 = less(r3A49, body.constant(int(0)));
                     ir_if *f3B21 = new(mem_ctx) ir_if(operand(r3B22).val);
                     exec_list *const f3B21_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B21->then_instructions;

                        ir_variable *const r3B23 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3B23, r3A4A, 0x01));

                        ir_variable *const r3B24 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3B24, neg(r3A49), 0x01));

                        ir_variable *const r3B25 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3B25);
                        ir_variable *const r3B26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3B26);
                        ir_variable *const r3B27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3B27);
                        ir_variable *const r3B28 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3B29 = neg(r3B24);
                        body.emit(assign(r3B28, bit_and(r3B29, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3B2B = equal(r3B24, body.constant(int(0)));
                        ir_if *f3B2A = new(mem_ctx) ir_if(operand(r3B2B).val);
                        exec_list *const f3B2A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B2A->then_instructions;

                           body.emit(assign(r3B25, r3A4A, 0x01));

                           body.emit(assign(r3B26, r3B05, 0x01));

                           body.emit(assign(r3B27, r3B04, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3B2A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3B2D = less(r3B24, body.constant(int(32)));
                           ir_if *f3B2C = new(mem_ctx) ir_if(operand(r3B2D).val);
                           exec_list *const f3B2C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3B2C->then_instructions;

                              body.emit(assign(r3B25, lshift(r3B05, r3B28), 0x01));

                              ir_expression *const r3B2E = lshift(r3B04, r3B28);
                              ir_expression *const r3B2F = rshift(r3B05, r3B24);
                              body.emit(assign(r3B26, bit_or(r3B2E, r3B2F), 0x01));

                              body.emit(assign(r3B27, rshift(r3B04, r3B24), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3B2C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3B31 = equal(r3B24, body.constant(int(32)));
                              ir_if *f3B30 = new(mem_ctx) ir_if(operand(r3B31).val);
                              exec_list *const f3B30_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3B30->then_instructions;

                                 body.emit(assign(r3B25, r3B05, 0x01));

                                 body.emit(assign(r3B26, r3B04, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3B30->else_instructions;

                                 body.emit(assign(r3B23, bit_or(r3A4A, r3B05), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3B33 = less(r3B24, body.constant(int(64)));
                                 ir_if *f3B32 = new(mem_ctx) ir_if(operand(r3B33).val);
                                 exec_list *const f3B32_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3B32->then_instructions;

                                    body.emit(assign(r3B25, lshift(r3B04, r3B28), 0x01));

                                    ir_expression *const r3B34 = bit_and(r3B24, body.constant(int(31)));
                                    body.emit(assign(r3B26, rshift(r3B04, r3B34), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3B32->else_instructions;

                                    ir_variable *const r3B35 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3B37 = equal(r3B24, body.constant(int(64)));
                                    ir_if *f3B36 = new(mem_ctx) ir_if(operand(r3B37).val);
                                    exec_list *const f3B36_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3B36->then_instructions;

                                       body.emit(assign(r3B35, r3B04, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3B36->else_instructions;

                                       ir_expression *const r3B38 = nequal(r3B04, body.constant(0u));
                                       ir_expression *const r3B39 = expr(ir_unop_b2i, r3B38);
                                       body.emit(assign(r3B35, expr(ir_unop_i2u, r3B39), 0x01));


                                    body.instructions = f3B36_parent_instructions;
                                    body.emit(f3B36);

                                    /* END IF */

                                    body.emit(assign(r3B25, r3B35, 0x01));

                                    body.emit(assign(r3B26, body.constant(0u), 0x01));


                                 body.instructions = f3B32_parent_instructions;
                                 body.emit(f3B32);

                                 /* END IF */


                              body.instructions = f3B30_parent_instructions;
                              body.emit(f3B30);

                              /* END IF */

                              body.emit(assign(r3B27, body.constant(0u), 0x01));


                           body.instructions = f3B2C_parent_instructions;
                           body.emit(f3B2C);

                           /* END IF */

                           ir_expression *const r3B3A = nequal(r3B23, body.constant(0u));
                           ir_expression *const r3B3B = expr(ir_unop_b2i, r3B3A);
                           ir_expression *const r3B3C = expr(ir_unop_i2u, r3B3B);
                           body.emit(assign(r3B25, bit_or(r3B25, r3B3C), 0x01));


                        body.instructions = f3B2A_parent_instructions;
                        body.emit(f3B2A);

                        /* END IF */

                        body.emit(assign(r3B0D, r3B27, 0x01));

                        body.emit(assign(r3B0E, r3B26, 0x01));

                        body.emit(assign(r3B0F, r3B25, 0x01));

                        body.emit(assign(r3B0C, body.constant(int(0)), 0x01));

                        body.emit(assign(r3B12, less(r3B25, body.constant(0u)), 0x01));


                     body.instructions = f3B21_parent_instructions;
                     body.emit(f3B21);

                     /* END IF */


                  body.instructions = f3B1E_parent_instructions;
                  body.emit(f3B1E);

                  /* END IF */


               body.instructions = f3B14_parent_instructions;
               body.emit(f3B14);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3B3D = new(mem_ctx) ir_if(operand(r3B10).val);
               exec_list *const f3B3D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3B3D->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3B3E = new(mem_ctx) ir_if(operand(r3B12).val);
                  exec_list *const f3B3E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B3E->then_instructions;

                     ir_variable *const r3B3F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3B3F, add(r3B0E, body.constant(1u)), 0x01));

                     ir_expression *const r3B40 = less(r3B3F, r3B0E);
                     ir_expression *const r3B41 = expr(ir_unop_b2i, r3B40);
                     ir_expression *const r3B42 = expr(ir_unop_i2u, r3B41);
                     body.emit(assign(r3B0D, add(r3B0D, r3B42), 0x01));

                     ir_expression *const r3B43 = equal(r3B0F, body.constant(0u));
                     ir_expression *const r3B44 = expr(ir_unop_b2i, r3B43);
                     ir_expression *const r3B45 = expr(ir_unop_i2u, r3B44);
                     ir_expression *const r3B46 = add(r3B0F, r3B45);
                     ir_expression *const r3B47 = bit_and(r3B46, body.constant(1u));
                     ir_expression *const r3B48 = expr(ir_unop_bit_not, r3B47);
                     body.emit(assign(r3B0E, bit_and(r3B3F, r3B48), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B3E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3B4A = bit_or(r3B0D, r3B0E);
                     ir_expression *const r3B4B = equal(r3B4A, body.constant(0u));
                     ir_if *f3B49 = new(mem_ctx) ir_if(operand(r3B4B).val);
                     exec_list *const f3B49_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B49->then_instructions;

                        body.emit(assign(r3B0C, body.constant(int(0)), 0x01));


                     body.instructions = f3B49_parent_instructions;
                     body.emit(f3B49);

                     /* END IF */


                  body.instructions = f3B3E_parent_instructions;
                  body.emit(f3B3E);

                  /* END IF */

                  ir_variable *const r3B4C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3B4C);
                  ir_expression *const r3B4D = lshift(r3685, body.constant(int(31)));
                  ir_expression *const r3B4E = expr(ir_unop_i2u, r3B0C);
                  ir_expression *const r3B4F = lshift(r3B4E, body.constant(int(20)));
                  ir_expression *const r3B50 = add(r3B4D, r3B4F);
                  body.emit(assign(r3B4C, add(r3B50, r3B0D), 0x02));

                  body.emit(assign(r3B4C, r3B0E, 0x01));

                  body.emit(assign(r3B11, r3B4C, 0x03));

                  body.emit(assign(r3B10, body.constant(false), 0x01));


               body.instructions = f3B3D_parent_instructions;
               body.emit(f3B3D);

               /* END IF */

               body.emit(assign(r3A45, r3B11, 0x03));

               body.emit(assign(r3A44, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3B0A->else_instructions;

               body.emit(assign(r3A49, add(r3A49, body.constant(int(1))), 0x01));

               ir_variable *const r3B51 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r3B51);
               ir_variable *const r3B52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3B52);
               ir_variable *const r3B53 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3B53);
               body.emit(assign(r3B51, lshift(r3B05, body.constant(int(31))), 0x01));

               ir_expression *const r3B54 = lshift(r3B04, body.constant(int(31)));
               ir_expression *const r3B55 = rshift(r3B05, body.constant(int(1)));
               body.emit(assign(r3B52, bit_or(r3B54, r3B55), 0x01));

               body.emit(assign(r3B53, rshift(r3B04, body.constant(int(1))), 0x01));

               ir_expression *const r3B56 = nequal(r3A4A, body.constant(0u));
               ir_expression *const r3B57 = expr(ir_unop_b2i, r3B56);
               ir_expression *const r3B58 = expr(ir_unop_i2u, r3B57);
               body.emit(assign(r3B51, bit_or(r3B51, r3B58), 0x01));

               body.emit(assign(r3A4B, r3B53, 0x01));

               body.emit(assign(r3A4A, r3B51, 0x01));

               ir_variable *const r3B59 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3B59, r3A49, 0x01));

               ir_variable *const r3B5A = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3B5A, r3B53, 0x01));

               ir_variable *const r3B5B = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3B5B, r3B52, 0x01));

               ir_variable *const r3B5C = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3B5C, r3B51, 0x01));

               ir_variable *const r3B5D = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3B5D, body.constant(true), 0x01));

               ir_variable *const r3B5E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3B5F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3B5F);
               ir_expression *const r3B60 = expr(ir_unop_u2i, r3B51);
               body.emit(assign(r3B5F, less(r3B60, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3B62 = lequal(body.constant(int(2045)), r3A49);
               ir_if *f3B61 = new(mem_ctx) ir_if(operand(r3B62).val);
               exec_list *const f3B61_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3B61->then_instructions;

                  ir_variable *const r3B63 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3B65 = less(body.constant(int(2045)), r3A49);
                  ir_if *f3B64 = new(mem_ctx) ir_if(operand(r3B65).val);
                  exec_list *const f3B64_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B64->then_instructions;

                     body.emit(assign(r3B63, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B64->else_instructions;

                     ir_variable *const r3B66 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3B68 = equal(r3A49, body.constant(int(2045)));
                     ir_if *f3B67 = new(mem_ctx) ir_if(operand(r3B68).val);
                     exec_list *const f3B67_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B67->then_instructions;

                        ir_expression *const r3B69 = equal(body.constant(2097151u), r3B53);
                        ir_expression *const r3B6A = equal(body.constant(4294967295u), r3B52);
                        body.emit(assign(r3B66, logic_and(r3B69, r3B6A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3B67->else_instructions;

                        body.emit(assign(r3B66, body.constant(false), 0x01));


                     body.instructions = f3B67_parent_instructions;
                     body.emit(f3B67);

                     /* END IF */

                     body.emit(assign(r3B63, logic_and(r3B66, r3B5F), 0x01));


                  body.instructions = f3B64_parent_instructions;
                  body.emit(f3B64);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3B6B = new(mem_ctx) ir_if(operand(r3B63).val);
                  exec_list *const f3B6B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B6B->then_instructions;

                     ir_variable *const r3B6C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3B6C);
                     ir_expression *const r3B6D = lshift(r3685, body.constant(int(31)));
                     body.emit(assign(r3B6C, add(r3B6D, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3B6C, body.constant(0u), 0x01));

                     body.emit(assign(r3B5E, r3B6C, 0x03));

                     body.emit(assign(r3B5D, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B6B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3B6F = less(r3A49, body.constant(int(0)));
                     ir_if *f3B6E = new(mem_ctx) ir_if(operand(r3B6F).val);
                     exec_list *const f3B6E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B6E->then_instructions;

                        ir_variable *const r3B70 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3B70, r3B51, 0x01));

                        ir_variable *const r3B71 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3B71, neg(r3A49), 0x01));

                        ir_variable *const r3B72 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3B72);
                        ir_variable *const r3B73 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3B73);
                        ir_variable *const r3B74 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3B74);
                        ir_variable *const r3B75 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3B76 = neg(r3B71);
                        body.emit(assign(r3B75, bit_and(r3B76, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3B78 = equal(r3B71, body.constant(int(0)));
                        ir_if *f3B77 = new(mem_ctx) ir_if(operand(r3B78).val);
                        exec_list *const f3B77_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B77->then_instructions;

                           body.emit(assign(r3B72, r3B51, 0x01));

                           body.emit(assign(r3B73, r3B52, 0x01));

                           body.emit(assign(r3B74, r3B53, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3B77->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3B7A = less(r3B71, body.constant(int(32)));
                           ir_if *f3B79 = new(mem_ctx) ir_if(operand(r3B7A).val);
                           exec_list *const f3B79_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3B79->then_instructions;

                              body.emit(assign(r3B72, lshift(r3B52, r3B75), 0x01));

                              ir_expression *const r3B7B = lshift(r3B53, r3B75);
                              ir_expression *const r3B7C = rshift(r3B52, r3B71);
                              body.emit(assign(r3B73, bit_or(r3B7B, r3B7C), 0x01));

                              body.emit(assign(r3B74, rshift(r3B53, r3B71), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3B79->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3B7E = equal(r3B71, body.constant(int(32)));
                              ir_if *f3B7D = new(mem_ctx) ir_if(operand(r3B7E).val);
                              exec_list *const f3B7D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3B7D->then_instructions;

                                 body.emit(assign(r3B72, r3B52, 0x01));

                                 body.emit(assign(r3B73, r3B53, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3B7D->else_instructions;

                                 body.emit(assign(r3B70, bit_or(r3B51, r3B52), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3B80 = less(r3B71, body.constant(int(64)));
                                 ir_if *f3B7F = new(mem_ctx) ir_if(operand(r3B80).val);
                                 exec_list *const f3B7F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3B7F->then_instructions;

                                    body.emit(assign(r3B72, lshift(r3B53, r3B75), 0x01));

                                    ir_expression *const r3B81 = bit_and(r3B71, body.constant(int(31)));
                                    body.emit(assign(r3B73, rshift(r3B53, r3B81), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3B7F->else_instructions;

                                    ir_variable *const r3B82 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3B84 = equal(r3B71, body.constant(int(64)));
                                    ir_if *f3B83 = new(mem_ctx) ir_if(operand(r3B84).val);
                                    exec_list *const f3B83_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3B83->then_instructions;

                                       body.emit(assign(r3B82, r3B53, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3B83->else_instructions;

                                       ir_expression *const r3B85 = nequal(r3B53, body.constant(0u));
                                       ir_expression *const r3B86 = expr(ir_unop_b2i, r3B85);
                                       body.emit(assign(r3B82, expr(ir_unop_i2u, r3B86), 0x01));


                                    body.instructions = f3B83_parent_instructions;
                                    body.emit(f3B83);

                                    /* END IF */

                                    body.emit(assign(r3B72, r3B82, 0x01));

                                    body.emit(assign(r3B73, body.constant(0u), 0x01));


                                 body.instructions = f3B7F_parent_instructions;
                                 body.emit(f3B7F);

                                 /* END IF */


                              body.instructions = f3B7D_parent_instructions;
                              body.emit(f3B7D);

                              /* END IF */

                              body.emit(assign(r3B74, body.constant(0u), 0x01));


                           body.instructions = f3B79_parent_instructions;
                           body.emit(f3B79);

                           /* END IF */

                           ir_expression *const r3B87 = nequal(r3B70, body.constant(0u));
                           ir_expression *const r3B88 = expr(ir_unop_b2i, r3B87);
                           ir_expression *const r3B89 = expr(ir_unop_i2u, r3B88);
                           body.emit(assign(r3B72, bit_or(r3B72, r3B89), 0x01));


                        body.instructions = f3B77_parent_instructions;
                        body.emit(f3B77);

                        /* END IF */

                        body.emit(assign(r3B5A, r3B74, 0x01));

                        body.emit(assign(r3B5B, r3B73, 0x01));

                        body.emit(assign(r3B5C, r3B72, 0x01));

                        body.emit(assign(r3B59, body.constant(int(0)), 0x01));

                        body.emit(assign(r3B5F, less(r3B72, body.constant(0u)), 0x01));


                     body.instructions = f3B6E_parent_instructions;
                     body.emit(f3B6E);

                     /* END IF */


                  body.instructions = f3B6B_parent_instructions;
                  body.emit(f3B6B);

                  /* END IF */


               body.instructions = f3B61_parent_instructions;
               body.emit(f3B61);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3B8A = new(mem_ctx) ir_if(operand(r3B5D).val);
               exec_list *const f3B8A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3B8A->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3B8B = new(mem_ctx) ir_if(operand(r3B5F).val);
                  exec_list *const f3B8B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B8B->then_instructions;

                     ir_variable *const r3B8C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3B8C, add(r3B5B, body.constant(1u)), 0x01));

                     ir_expression *const r3B8D = less(r3B8C, r3B5B);
                     ir_expression *const r3B8E = expr(ir_unop_b2i, r3B8D);
                     ir_expression *const r3B8F = expr(ir_unop_i2u, r3B8E);
                     body.emit(assign(r3B5A, add(r3B5A, r3B8F), 0x01));

                     ir_expression *const r3B90 = equal(r3B5C, body.constant(0u));
                     ir_expression *const r3B91 = expr(ir_unop_b2i, r3B90);
                     ir_expression *const r3B92 = expr(ir_unop_i2u, r3B91);
                     ir_expression *const r3B93 = add(r3B5C, r3B92);
                     ir_expression *const r3B94 = bit_and(r3B93, body.constant(1u));
                     ir_expression *const r3B95 = expr(ir_unop_bit_not, r3B94);
                     body.emit(assign(r3B5B, bit_and(r3B8C, r3B95), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B8B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3B97 = bit_or(r3B5A, r3B5B);
                     ir_expression *const r3B98 = equal(r3B97, body.constant(0u));
                     ir_if *f3B96 = new(mem_ctx) ir_if(operand(r3B98).val);
                     exec_list *const f3B96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B96->then_instructions;

                        body.emit(assign(r3B59, body.constant(int(0)), 0x01));


                     body.instructions = f3B96_parent_instructions;
                     body.emit(f3B96);

                     /* END IF */


                  body.instructions = f3B8B_parent_instructions;
                  body.emit(f3B8B);

                  /* END IF */

                  ir_variable *const r3B99 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3B99);
                  ir_expression *const r3B9A = lshift(r3685, body.constant(int(31)));
                  ir_expression *const r3B9B = expr(ir_unop_i2u, r3B59);
                  ir_expression *const r3B9C = lshift(r3B9B, body.constant(int(20)));
                  ir_expression *const r3B9D = add(r3B9A, r3B9C);
                  body.emit(assign(r3B99, add(r3B9D, r3B5A), 0x02));

                  body.emit(assign(r3B99, r3B5B, 0x01));

                  body.emit(assign(r3B5E, r3B99, 0x03));

                  body.emit(assign(r3B5D, body.constant(false), 0x01));


               body.instructions = f3B8A_parent_instructions;
               body.emit(f3B8A);

               /* END IF */

               body.emit(assign(r3A45, r3B5E, 0x03));

               body.emit(assign(r3A44, body.constant(false), 0x01));


            body.instructions = f3B0A_parent_instructions;
            body.emit(f3B0A);

            /* END IF */


         body.instructions = f3B03_parent_instructions;
         body.emit(f3B03);

         /* END IF */

         body.emit(assign(r3684, r3A45, 0x03));


      body.instructions = f3686_parent_instructions;
      body.emit(f3686);

      /* END IF */

      body.emit(assign(r3682, r3684, 0x03));


   body.instructions = f3683_parent_instructions;
   body.emit(f3683);

   /* END IF */

   ir_variable *const r3B9E = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r3B9E, body.constant(true), 0x01));

   ir_variable *const r3B9F = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3BA0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r3BA0);
   ir_variable *const r3BA1 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r3BA1);
   ir_variable *const r3BA2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r3BA2);
   ir_variable *const r3BA3 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r3BA3);
   ir_variable *const r3BA4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r3BA4);
   ir_variable *const r3BA5 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r3BA5);
   ir_variable *const r3BA6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r3BA6);
   ir_variable *const r3BA7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r3BA7);
   ir_variable *const r3BA8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r3BA8);
   body.emit(assign(r3BA8, body.constant(0u), 0x01));

   body.emit(assign(r3BA7, body.constant(0u), 0x01));

   body.emit(assign(r3BA6, body.constant(0u), 0x01));

   ir_variable *const r3BA9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r3BA9);
   body.emit(assign(r3BA9, bit_and(swizzle_y(r33DE), body.constant(1048575u)), 0x02));

   body.emit(assign(r3BA9, swizzle_x(r33DE), 0x01));

   body.emit(assign(r3BA4, r3BA9, 0x03));

   ir_variable *const r3BAA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r3BAB = rshift(swizzle_y(r33DE), body.constant(int(20)));
   ir_expression *const r3BAC = bit_and(r3BAB, body.constant(2047u));
   body.emit(assign(r3BAA, expr(ir_unop_u2i, r3BAC), 0x01));

   body.emit(assign(r3BA3, r3BAA, 0x01));

   ir_variable *const r3BAD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r3BAD);
   body.emit(assign(r3BAD, bit_and(swizzle_y(r3682), body.constant(1048575u)), 0x02));

   body.emit(assign(r3BAD, swizzle_x(r3682), 0x01));

   body.emit(assign(r3BA2, r3BAD, 0x03));

   ir_variable *const r3BAE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r3BAF = rshift(swizzle_y(r3682), body.constant(int(20)));
   ir_expression *const r3BB0 = bit_and(r3BAF, body.constant(2047u));
   body.emit(assign(r3BAE, expr(ir_unop_u2i, r3BB0), 0x01));

   body.emit(assign(r3BA1, r3BAE, 0x01));

   ir_expression *const r3BB1 = rshift(swizzle_y(r33DE), body.constant(int(31)));
   ir_expression *const r3BB2 = rshift(swizzle_y(r3682), body.constant(int(31)));
   body.emit(assign(r3BA0, bit_xor(r3BB1, r3BB2), 0x01));

   /* IF CONDITION */
   ir_expression *const r3BB4 = equal(r3BAA, body.constant(int(2047)));
   ir_if *f3BB3 = new(mem_ctx) ir_if(operand(r3BB4).val);
   exec_list *const f3BB3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3BB3->then_instructions;

      /* IF CONDITION */
      ir_expression *const r3BB6 = bit_or(swizzle_y(r3BA9), swizzle_x(r33DE));
      ir_expression *const r3BB7 = nequal(r3BB6, body.constant(0u));
      ir_expression *const r3BB8 = equal(r3BAE, body.constant(int(2047)));
      ir_expression *const r3BB9 = bit_or(swizzle_y(r3BAD), swizzle_x(r3682));
      ir_expression *const r3BBA = nequal(r3BB9, body.constant(0u));
      ir_expression *const r3BBB = logic_and(r3BB8, r3BBA);
      ir_expression *const r3BBC = logic_or(r3BB7, r3BBB);
      ir_if *f3BB5 = new(mem_ctx) ir_if(operand(r3BBC).val);
      exec_list *const f3BB5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3BB5->then_instructions;

         ir_variable *const r3BBD = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r3BBD, swizzle_x(r33DE), 0x01));

         ir_variable *const r3BBE = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r3BBE, swizzle_x(r3682), 0x01));

         ir_variable *const r3BBF = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r3BC0 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r3BC1 = rshift(swizzle_y(r33DE), body.constant(int(19)));
         ir_expression *const r3BC2 = bit_and(r3BC1, body.constant(4095u));
         ir_expression *const r3BC3 = equal(r3BC2, body.constant(4094u));
         ir_expression *const r3BC4 = nequal(swizzle_x(r33DE), body.constant(0u));
         ir_expression *const r3BC5 = bit_and(swizzle_y(r33DE), body.constant(524287u));
         ir_expression *const r3BC6 = nequal(r3BC5, body.constant(0u));
         ir_expression *const r3BC7 = logic_or(r3BC4, r3BC6);
         body.emit(assign(r3BC0, logic_and(r3BC3, r3BC7), 0x01));

         ir_variable *const r3BC8 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r3BC9 = lshift(swizzle_y(r3682), body.constant(int(1)));
         ir_expression *const r3BCA = lequal(body.constant(4292870144u), r3BC9);
         ir_expression *const r3BCB = nequal(swizzle_x(r3682), body.constant(0u));
         ir_expression *const r3BCC = bit_and(swizzle_y(r3682), body.constant(1048575u));
         ir_expression *const r3BCD = nequal(r3BCC, body.constant(0u));
         ir_expression *const r3BCE = logic_or(r3BCB, r3BCD);
         body.emit(assign(r3BC8, logic_and(r3BCA, r3BCE), 0x01));

         body.emit(assign(r3BBD, bit_or(swizzle_y(r33DE), body.constant(524288u)), 0x02));

         body.emit(assign(r3BBE, bit_or(swizzle_y(r3682), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r3BD0 = lshift(swizzle_y(r33DE), body.constant(int(1)));
         ir_expression *const r3BD1 = lequal(body.constant(4292870144u), r3BD0);
         ir_expression *const r3BD2 = nequal(swizzle_x(r33DE), body.constant(0u));
         ir_expression *const r3BD3 = bit_and(swizzle_y(r33DE), body.constant(1048575u));
         ir_expression *const r3BD4 = nequal(r3BD3, body.constant(0u));
         ir_expression *const r3BD5 = logic_or(r3BD2, r3BD4);
         ir_expression *const r3BD6 = logic_and(r3BD1, r3BD5);
         ir_if *f3BCF = new(mem_ctx) ir_if(operand(r3BD6).val);
         exec_list *const f3BCF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3BCF->then_instructions;

            ir_variable *const r3BD7 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r3BD9 = logic_and(r3BC0, r3BC8);
            ir_if *f3BD8 = new(mem_ctx) ir_if(operand(r3BD9).val);
            exec_list *const f3BD8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3BD8->then_instructions;

               body.emit(assign(r3BD7, r3BBE, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3BD8->else_instructions;

               body.emit(assign(r3BD7, r3BBD, 0x03));


            body.instructions = f3BD8_parent_instructions;
            body.emit(f3BD8);

            /* END IF */

            body.emit(assign(r3BBF, r3BD7, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3BCF->else_instructions;

            body.emit(assign(r3BBF, r3BBE, 0x03));


         body.instructions = f3BCF_parent_instructions;
         body.emit(f3BCF);

         /* END IF */

         body.emit(assign(r3B9F, r3BBF, 0x03));

         body.emit(assign(r3B9E, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3BB5->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3BDB = expr(ir_unop_i2u, r3BAE);
         ir_expression *const r3BDC = bit_or(r3BDB, swizzle_y(r3BAD));
         ir_expression *const r3BDD = bit_or(r3BDC, swizzle_x(r3682));
         ir_expression *const r3BDE = equal(r3BDD, body.constant(0u));
         ir_if *f3BDA = new(mem_ctx) ir_if(operand(r3BDE).val);
         exec_list *const f3BDA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3BDA->then_instructions;

            ir_constant_data r3BDF_data;
            memset(&r3BDF_data, 0, sizeof(ir_constant_data));
            r3BDF_data.u[0] = 4294967295;
            r3BDF_data.u[1] = 4294967295;
            ir_constant *const r3BDF = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3BDF_data);
            body.emit(assign(r3B9F, r3BDF, 0x03));

            body.emit(assign(r3B9E, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3BDA->else_instructions;

            ir_variable *const r3BE0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r3BE0);
            ir_expression *const r3BE1 = lshift(r3BA0, body.constant(int(31)));
            body.emit(assign(r3BE0, add(r3BE1, body.constant(2146435072u)), 0x02));

            body.emit(assign(r3BE0, body.constant(0u), 0x01));

            body.emit(assign(r3B9F, r3BE0, 0x03));

            body.emit(assign(r3B9E, body.constant(false), 0x01));


         body.instructions = f3BDA_parent_instructions;
         body.emit(f3BDA);

         /* END IF */


      body.instructions = f3BB5_parent_instructions;
      body.emit(f3BB5);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3BB3->else_instructions;

      /* IF CONDITION */
      ir_expression *const r3BE3 = equal(r3BAE, body.constant(int(2047)));
      ir_if *f3BE2 = new(mem_ctx) ir_if(operand(r3BE3).val);
      exec_list *const f3BE2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3BE2->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3BE5 = bit_or(swizzle_y(r3BAD), swizzle_x(r3682));
         ir_expression *const r3BE6 = nequal(r3BE5, body.constant(0u));
         ir_if *f3BE4 = new(mem_ctx) ir_if(operand(r3BE6).val);
         exec_list *const f3BE4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3BE4->then_instructions;

            ir_variable *const r3BE7 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r3BE7, swizzle_x(r33DE), 0x01));

            ir_variable *const r3BE8 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r3BE8, swizzle_x(r3682), 0x01));

            ir_variable *const r3BE9 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3BEA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r3BEB = rshift(swizzle_y(r33DE), body.constant(int(19)));
            ir_expression *const r3BEC = bit_and(r3BEB, body.constant(4095u));
            ir_expression *const r3BED = equal(r3BEC, body.constant(4094u));
            ir_expression *const r3BEE = nequal(swizzle_x(r33DE), body.constant(0u));
            ir_expression *const r3BEF = bit_and(swizzle_y(r33DE), body.constant(524287u));
            ir_expression *const r3BF0 = nequal(r3BEF, body.constant(0u));
            ir_expression *const r3BF1 = logic_or(r3BEE, r3BF0);
            body.emit(assign(r3BEA, logic_and(r3BED, r3BF1), 0x01));

            ir_variable *const r3BF2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r3BF3 = lshift(swizzle_y(r3682), body.constant(int(1)));
            ir_expression *const r3BF4 = lequal(body.constant(4292870144u), r3BF3);
            ir_expression *const r3BF5 = nequal(swizzle_x(r3682), body.constant(0u));
            ir_expression *const r3BF6 = bit_and(swizzle_y(r3682), body.constant(1048575u));
            ir_expression *const r3BF7 = nequal(r3BF6, body.constant(0u));
            ir_expression *const r3BF8 = logic_or(r3BF5, r3BF7);
            body.emit(assign(r3BF2, logic_and(r3BF4, r3BF8), 0x01));

            body.emit(assign(r3BE7, bit_or(swizzle_y(r33DE), body.constant(524288u)), 0x02));

            body.emit(assign(r3BE8, bit_or(swizzle_y(r3682), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r3BFA = lshift(swizzle_y(r33DE), body.constant(int(1)));
            ir_expression *const r3BFB = lequal(body.constant(4292870144u), r3BFA);
            ir_expression *const r3BFC = nequal(swizzle_x(r33DE), body.constant(0u));
            ir_expression *const r3BFD = bit_and(swizzle_y(r33DE), body.constant(1048575u));
            ir_expression *const r3BFE = nequal(r3BFD, body.constant(0u));
            ir_expression *const r3BFF = logic_or(r3BFC, r3BFE);
            ir_expression *const r3C00 = logic_and(r3BFB, r3BFF);
            ir_if *f3BF9 = new(mem_ctx) ir_if(operand(r3C00).val);
            exec_list *const f3BF9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3BF9->then_instructions;

               ir_variable *const r3C01 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r3C03 = logic_and(r3BEA, r3BF2);
               ir_if *f3C02 = new(mem_ctx) ir_if(operand(r3C03).val);
               exec_list *const f3C02_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C02->then_instructions;

                  body.emit(assign(r3C01, r3BE8, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C02->else_instructions;

                  body.emit(assign(r3C01, r3BE7, 0x03));


               body.instructions = f3C02_parent_instructions;
               body.emit(f3C02);

               /* END IF */

               body.emit(assign(r3BE9, r3C01, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3BF9->else_instructions;

               body.emit(assign(r3BE9, r3BE8, 0x03));


            body.instructions = f3BF9_parent_instructions;
            body.emit(f3BF9);

            /* END IF */

            body.emit(assign(r3B9F, r3BE9, 0x03));

            body.emit(assign(r3B9E, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3BE4->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3C05 = expr(ir_unop_i2u, r3BAA);
            ir_expression *const r3C06 = bit_or(r3C05, swizzle_y(r3BA9));
            ir_expression *const r3C07 = bit_or(r3C06, swizzle_x(r33DE));
            ir_expression *const r3C08 = equal(r3C07, body.constant(0u));
            ir_if *f3C04 = new(mem_ctx) ir_if(operand(r3C08).val);
            exec_list *const f3C04_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C04->then_instructions;

               ir_constant_data r3C09_data;
               memset(&r3C09_data, 0, sizeof(ir_constant_data));
               r3C09_data.u[0] = 4294967295;
               r3C09_data.u[1] = 4294967295;
               ir_constant *const r3C09 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3C09_data);
               body.emit(assign(r3B9F, r3C09, 0x03));

               body.emit(assign(r3B9E, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3C04->else_instructions;

               ir_variable *const r3C0A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3C0A);
               ir_expression *const r3C0B = lshift(r3BA0, body.constant(int(31)));
               body.emit(assign(r3C0A, add(r3C0B, body.constant(2146435072u)), 0x02));

               body.emit(assign(r3C0A, body.constant(0u), 0x01));

               body.emit(assign(r3B9F, r3C0A, 0x03));

               body.emit(assign(r3B9E, body.constant(false), 0x01));


            body.instructions = f3C04_parent_instructions;
            body.emit(f3C04);

            /* END IF */


         body.instructions = f3BE4_parent_instructions;
         body.emit(f3BE4);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3BE2->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3C0D = equal(r3BAA, body.constant(int(0)));
         ir_if *f3C0C = new(mem_ctx) ir_if(operand(r3C0D).val);
         exec_list *const f3C0C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3C0C->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3C0F = bit_or(swizzle_y(r3BA9), swizzle_x(r33DE));
            ir_expression *const r3C10 = equal(r3C0F, body.constant(0u));
            ir_if *f3C0E = new(mem_ctx) ir_if(operand(r3C10).val);
            exec_list *const f3C0E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C0E->then_instructions;

               ir_variable *const r3C11 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3C11);
               body.emit(assign(r3C11, lshift(r3BA0, body.constant(int(31))), 0x02));

               body.emit(assign(r3C11, body.constant(0u), 0x01));

               body.emit(assign(r3B9F, r3C11, 0x03));

               body.emit(assign(r3B9E, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3C0E->else_instructions;

               ir_variable *const r3C12 = body.make_temp(glsl_type::uint_type, "aFrac0");
               body.emit(assign(r3C12, swizzle_y(r3BA9), 0x01));

               ir_variable *const r3C13 = body.make_temp(glsl_type::uint_type, "aFrac1");
               body.emit(assign(r3C13, swizzle_x(r3BA9), 0x01));

               ir_variable *const r3C14 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r3C14, r3BAA, 0x01));

               ir_variable *const r3C15 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r3C15, swizzle_y(r3BA9), 0x01));

               ir_variable *const r3C16 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r3C16, swizzle_x(r3BA9), 0x01));

               ir_variable *const r3C17 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3C17);
               /* IF CONDITION */
               ir_expression *const r3C19 = equal(swizzle_y(r3BA9), body.constant(0u));
               ir_if *f3C18 = new(mem_ctx) ir_if(operand(r3C19).val);
               exec_list *const f3C18_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C18->then_instructions;

                  ir_variable *const r3C1A = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3C1A, r3C13, 0x01));

                  ir_variable *const r3C1B = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3C1C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3C1C);
                  /* IF CONDITION */
                  ir_expression *const r3C1E = equal(swizzle_x(r33DE), body.constant(0u));
                  ir_if *f3C1D = new(mem_ctx) ir_if(operand(r3C1E).val);
                  exec_list *const f3C1D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C1D->then_instructions;

                     body.emit(assign(r3C1B, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C1D->else_instructions;

                     body.emit(assign(r3C1C, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3C20 = bit_and(swizzle_x(r33DE), body.constant(4294901760u));
                     ir_expression *const r3C21 = equal(r3C20, body.constant(0u));
                     ir_if *f3C1F = new(mem_ctx) ir_if(operand(r3C21).val);
                     exec_list *const f3C1F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C1F->then_instructions;

                        body.emit(assign(r3C1C, body.constant(int(16)), 0x01));

                        body.emit(assign(r3C1A, lshift(swizzle_x(r33DE), body.constant(int(16))), 0x01));


                     body.instructions = f3C1F_parent_instructions;
                     body.emit(f3C1F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3C23 = bit_and(r3C1A, body.constant(4278190080u));
                     ir_expression *const r3C24 = equal(r3C23, body.constant(0u));
                     ir_if *f3C22 = new(mem_ctx) ir_if(operand(r3C24).val);
                     exec_list *const f3C22_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C22->then_instructions;

                        body.emit(assign(r3C1C, add(r3C1C, body.constant(int(8))), 0x01));

                        body.emit(assign(r3C1A, lshift(r3C1A, body.constant(int(8))), 0x01));


                     body.instructions = f3C22_parent_instructions;
                     body.emit(f3C22);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3C26 = bit_and(r3C1A, body.constant(4026531840u));
                     ir_expression *const r3C27 = equal(r3C26, body.constant(0u));
                     ir_if *f3C25 = new(mem_ctx) ir_if(operand(r3C27).val);
                     exec_list *const f3C25_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C25->then_instructions;

                        body.emit(assign(r3C1C, add(r3C1C, body.constant(int(4))), 0x01));

                        body.emit(assign(r3C1A, lshift(r3C1A, body.constant(int(4))), 0x01));


                     body.instructions = f3C25_parent_instructions;
                     body.emit(f3C25);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3C29 = bit_and(r3C1A, body.constant(3221225472u));
                     ir_expression *const r3C2A = equal(r3C29, body.constant(0u));
                     ir_if *f3C28 = new(mem_ctx) ir_if(operand(r3C2A).val);
                     exec_list *const f3C28_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C28->then_instructions;

                        body.emit(assign(r3C1C, add(r3C1C, body.constant(int(2))), 0x01));

                        body.emit(assign(r3C1A, lshift(r3C1A, body.constant(int(2))), 0x01));


                     body.instructions = f3C28_parent_instructions;
                     body.emit(f3C28);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3C2C = bit_and(r3C1A, body.constant(2147483648u));
                     ir_expression *const r3C2D = equal(r3C2C, body.constant(0u));
                     ir_if *f3C2B = new(mem_ctx) ir_if(operand(r3C2D).val);
                     exec_list *const f3C2B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C2B->then_instructions;

                        body.emit(assign(r3C1C, add(r3C1C, body.constant(int(1))), 0x01));


                     body.instructions = f3C2B_parent_instructions;
                     body.emit(f3C2B);

                     /* END IF */

                     body.emit(assign(r3C1B, r3C1C, 0x01));


                  body.instructions = f3C1D_parent_instructions;
                  body.emit(f3C1D);

                  /* END IF */

                  body.emit(assign(r3C17, add(r3C1B, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3C2F = less(r3C17, body.constant(int(0)));
                  ir_if *f3C2E = new(mem_ctx) ir_if(operand(r3C2F).val);
                  exec_list *const f3C2E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C2E->then_instructions;

                     ir_expression *const r3C30 = neg(r3C17);
                     body.emit(assign(r3C15, rshift(swizzle_x(r33DE), r3C30), 0x01));

                     ir_expression *const r3C31 = bit_and(r3C17, body.constant(int(31)));
                     body.emit(assign(r3C16, lshift(swizzle_x(r33DE), r3C31), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C2E->else_instructions;

                     body.emit(assign(r3C15, lshift(swizzle_x(r33DE), r3C17), 0x01));

                     body.emit(assign(r3C16, body.constant(0u), 0x01));


                  body.instructions = f3C2E_parent_instructions;
                  body.emit(f3C2E);

                  /* END IF */

                  body.emit(assign(r3C14, sub(body.constant(int(-31)), r3C17), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C18->else_instructions;

                  ir_variable *const r3C32 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3C32, r3C12, 0x01));

                  ir_variable *const r3C33 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3C34 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3C34);
                  /* IF CONDITION */
                  ir_expression *const r3C36 = equal(swizzle_y(r3BA9), body.constant(0u));
                  ir_if *f3C35 = new(mem_ctx) ir_if(operand(r3C36).val);
                  exec_list *const f3C35_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C35->then_instructions;

                     body.emit(assign(r3C33, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C35->else_instructions;

                     body.emit(assign(r3C34, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3C38 = bit_and(swizzle_y(r3BA9), body.constant(4294901760u));
                     ir_expression *const r3C39 = equal(r3C38, body.constant(0u));
                     ir_if *f3C37 = new(mem_ctx) ir_if(operand(r3C39).val);
                     exec_list *const f3C37_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C37->then_instructions;

                        body.emit(assign(r3C34, body.constant(int(16)), 0x01));

                        body.emit(assign(r3C32, lshift(swizzle_y(r3BA9), body.constant(int(16))), 0x01));


                     body.instructions = f3C37_parent_instructions;
                     body.emit(f3C37);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3C3B = bit_and(r3C32, body.constant(4278190080u));
                     ir_expression *const r3C3C = equal(r3C3B, body.constant(0u));
                     ir_if *f3C3A = new(mem_ctx) ir_if(operand(r3C3C).val);
                     exec_list *const f3C3A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C3A->then_instructions;

                        body.emit(assign(r3C34, add(r3C34, body.constant(int(8))), 0x01));

                        body.emit(assign(r3C32, lshift(r3C32, body.constant(int(8))), 0x01));


                     body.instructions = f3C3A_parent_instructions;
                     body.emit(f3C3A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3C3E = bit_and(r3C32, body.constant(4026531840u));
                     ir_expression *const r3C3F = equal(r3C3E, body.constant(0u));
                     ir_if *f3C3D = new(mem_ctx) ir_if(operand(r3C3F).val);
                     exec_list *const f3C3D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C3D->then_instructions;

                        body.emit(assign(r3C34, add(r3C34, body.constant(int(4))), 0x01));

                        body.emit(assign(r3C32, lshift(r3C32, body.constant(int(4))), 0x01));


                     body.instructions = f3C3D_parent_instructions;
                     body.emit(f3C3D);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3C41 = bit_and(r3C32, body.constant(3221225472u));
                     ir_expression *const r3C42 = equal(r3C41, body.constant(0u));
                     ir_if *f3C40 = new(mem_ctx) ir_if(operand(r3C42).val);
                     exec_list *const f3C40_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C40->then_instructions;

                        body.emit(assign(r3C34, add(r3C34, body.constant(int(2))), 0x01));

                        body.emit(assign(r3C32, lshift(r3C32, body.constant(int(2))), 0x01));


                     body.instructions = f3C40_parent_instructions;
                     body.emit(f3C40);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3C44 = bit_and(r3C32, body.constant(2147483648u));
                     ir_expression *const r3C45 = equal(r3C44, body.constant(0u));
                     ir_if *f3C43 = new(mem_ctx) ir_if(operand(r3C45).val);
                     exec_list *const f3C43_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C43->then_instructions;

                        body.emit(assign(r3C34, add(r3C34, body.constant(int(1))), 0x01));


                     body.instructions = f3C43_parent_instructions;
                     body.emit(f3C43);

                     /* END IF */

                     body.emit(assign(r3C33, r3C34, 0x01));


                  body.instructions = f3C35_parent_instructions;
                  body.emit(f3C35);

                  /* END IF */

                  body.emit(assign(r3C17, add(r3C33, body.constant(int(-11))), 0x01));

                  ir_variable *const r3C46 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3C46, lshift(swizzle_x(r33DE), r3C17), 0x01));

                  ir_variable *const r3C47 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3C49 = equal(r3C17, body.constant(int(0)));
                  ir_if *f3C48 = new(mem_ctx) ir_if(operand(r3C49).val);
                  exec_list *const f3C48_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C48->then_instructions;

                     body.emit(assign(r3C47, r3C12, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C48->else_instructions;

                     ir_expression *const r3C4A = lshift(swizzle_y(r3BA9), r3C17);
                     ir_expression *const r3C4B = neg(r3C17);
                     ir_expression *const r3C4C = bit_and(r3C4B, body.constant(int(31)));
                     ir_expression *const r3C4D = rshift(swizzle_x(r33DE), r3C4C);
                     body.emit(assign(r3C47, bit_or(r3C4A, r3C4D), 0x01));


                  body.instructions = f3C48_parent_instructions;
                  body.emit(f3C48);

                  /* END IF */

                  body.emit(assign(r3C15, r3C47, 0x01));

                  body.emit(assign(r3C16, r3C46, 0x01));

                  body.emit(assign(r3C14, sub(body.constant(int(1)), r3C17), 0x01));


               body.instructions = f3C18_parent_instructions;
               body.emit(f3C18);

               /* END IF */

               body.emit(assign(r3BA3, r3C14, 0x01));

               body.emit(assign(r3BA4, r3C15, 0x02));

               body.emit(assign(r3BA4, r3C16, 0x01));


            body.instructions = f3C0E_parent_instructions;
            body.emit(f3C0E);

            /* END IF */


         body.instructions = f3C0C_parent_instructions;
         body.emit(f3C0C);

         /* END IF */

         /* IF CONDITION */
         ir_if *f3C4E = new(mem_ctx) ir_if(operand(r3B9E).val);
         exec_list *const f3C4E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3C4E->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3C50 = equal(r3BAE, body.constant(int(0)));
            ir_if *f3C4F = new(mem_ctx) ir_if(operand(r3C50).val);
            exec_list *const f3C4F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C4F->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3C52 = bit_or(swizzle_y(r3BAD), swizzle_x(r3682));
               ir_expression *const r3C53 = equal(r3C52, body.constant(0u));
               ir_if *f3C51 = new(mem_ctx) ir_if(operand(r3C53).val);
               exec_list *const f3C51_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C51->then_instructions;

                  ir_variable *const r3C54 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3C54);
                  body.emit(assign(r3C54, lshift(r3BA0, body.constant(int(31))), 0x02));

                  body.emit(assign(r3C54, body.constant(0u), 0x01));

                  body.emit(assign(r3B9F, r3C54, 0x03));

                  body.emit(assign(r3B9E, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C51->else_instructions;

                  ir_variable *const r3C55 = body.make_temp(glsl_type::uint_type, "aFrac0");
                  body.emit(assign(r3C55, swizzle_y(r3BAD), 0x01));

                  ir_variable *const r3C56 = body.make_temp(glsl_type::uint_type, "aFrac1");
                  body.emit(assign(r3C56, swizzle_x(r3BAD), 0x01));

                  ir_variable *const r3C57 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r3C57, r3BAE, 0x01));

                  ir_variable *const r3C58 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r3C58, swizzle_y(r3BAD), 0x01));

                  ir_variable *const r3C59 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r3C59, swizzle_x(r3BAD), 0x01));

                  ir_variable *const r3C5A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3C5A);
                  /* IF CONDITION */
                  ir_expression *const r3C5C = equal(swizzle_y(r3BAD), body.constant(0u));
                  ir_if *f3C5B = new(mem_ctx) ir_if(operand(r3C5C).val);
                  exec_list *const f3C5B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C5B->then_instructions;

                     ir_variable *const r3C5D = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3C5D, r3C56, 0x01));

                     ir_variable *const r3C5E = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3C5F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3C5F);
                     /* IF CONDITION */
                     ir_expression *const r3C61 = equal(swizzle_x(r3682), body.constant(0u));
                     ir_if *f3C60 = new(mem_ctx) ir_if(operand(r3C61).val);
                     exec_list *const f3C60_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C60->then_instructions;

                        body.emit(assign(r3C5E, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3C60->else_instructions;

                        body.emit(assign(r3C5F, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3C63 = bit_and(swizzle_x(r3682), body.constant(4294901760u));
                        ir_expression *const r3C64 = equal(r3C63, body.constant(0u));
                        ir_if *f3C62 = new(mem_ctx) ir_if(operand(r3C64).val);
                        exec_list *const f3C62_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C62->then_instructions;

                           body.emit(assign(r3C5F, body.constant(int(16)), 0x01));

                           body.emit(assign(r3C5D, lshift(swizzle_x(r3682), body.constant(int(16))), 0x01));


                        body.instructions = f3C62_parent_instructions;
                        body.emit(f3C62);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3C66 = bit_and(r3C5D, body.constant(4278190080u));
                        ir_expression *const r3C67 = equal(r3C66, body.constant(0u));
                        ir_if *f3C65 = new(mem_ctx) ir_if(operand(r3C67).val);
                        exec_list *const f3C65_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C65->then_instructions;

                           body.emit(assign(r3C5F, add(r3C5F, body.constant(int(8))), 0x01));

                           body.emit(assign(r3C5D, lshift(r3C5D, body.constant(int(8))), 0x01));


                        body.instructions = f3C65_parent_instructions;
                        body.emit(f3C65);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3C69 = bit_and(r3C5D, body.constant(4026531840u));
                        ir_expression *const r3C6A = equal(r3C69, body.constant(0u));
                        ir_if *f3C68 = new(mem_ctx) ir_if(operand(r3C6A).val);
                        exec_list *const f3C68_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C68->then_instructions;

                           body.emit(assign(r3C5F, add(r3C5F, body.constant(int(4))), 0x01));

                           body.emit(assign(r3C5D, lshift(r3C5D, body.constant(int(4))), 0x01));


                        body.instructions = f3C68_parent_instructions;
                        body.emit(f3C68);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3C6C = bit_and(r3C5D, body.constant(3221225472u));
                        ir_expression *const r3C6D = equal(r3C6C, body.constant(0u));
                        ir_if *f3C6B = new(mem_ctx) ir_if(operand(r3C6D).val);
                        exec_list *const f3C6B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C6B->then_instructions;

                           body.emit(assign(r3C5F, add(r3C5F, body.constant(int(2))), 0x01));

                           body.emit(assign(r3C5D, lshift(r3C5D, body.constant(int(2))), 0x01));


                        body.instructions = f3C6B_parent_instructions;
                        body.emit(f3C6B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3C6F = bit_and(r3C5D, body.constant(2147483648u));
                        ir_expression *const r3C70 = equal(r3C6F, body.constant(0u));
                        ir_if *f3C6E = new(mem_ctx) ir_if(operand(r3C70).val);
                        exec_list *const f3C6E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C6E->then_instructions;

                           body.emit(assign(r3C5F, add(r3C5F, body.constant(int(1))), 0x01));


                        body.instructions = f3C6E_parent_instructions;
                        body.emit(f3C6E);

                        /* END IF */

                        body.emit(assign(r3C5E, r3C5F, 0x01));


                     body.instructions = f3C60_parent_instructions;
                     body.emit(f3C60);

                     /* END IF */

                     body.emit(assign(r3C5A, add(r3C5E, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3C72 = less(r3C5A, body.constant(int(0)));
                     ir_if *f3C71 = new(mem_ctx) ir_if(operand(r3C72).val);
                     exec_list *const f3C71_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C71->then_instructions;

                        ir_expression *const r3C73 = neg(r3C5A);
                        body.emit(assign(r3C58, rshift(swizzle_x(r3682), r3C73), 0x01));

                        ir_expression *const r3C74 = bit_and(r3C5A, body.constant(int(31)));
                        body.emit(assign(r3C59, lshift(swizzle_x(r3682), r3C74), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3C71->else_instructions;

                        body.emit(assign(r3C58, lshift(swizzle_x(r3682), r3C5A), 0x01));

                        body.emit(assign(r3C59, body.constant(0u), 0x01));


                     body.instructions = f3C71_parent_instructions;
                     body.emit(f3C71);

                     /* END IF */

                     body.emit(assign(r3C57, sub(body.constant(int(-31)), r3C5A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C5B->else_instructions;

                     ir_variable *const r3C75 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3C75, r3C55, 0x01));

                     ir_variable *const r3C76 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3C77 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3C77);
                     /* IF CONDITION */
                     ir_expression *const r3C79 = equal(swizzle_y(r3BAD), body.constant(0u));
                     ir_if *f3C78 = new(mem_ctx) ir_if(operand(r3C79).val);
                     exec_list *const f3C78_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C78->then_instructions;

                        body.emit(assign(r3C76, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3C78->else_instructions;

                        body.emit(assign(r3C77, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3C7B = bit_and(swizzle_y(r3BAD), body.constant(4294901760u));
                        ir_expression *const r3C7C = equal(r3C7B, body.constant(0u));
                        ir_if *f3C7A = new(mem_ctx) ir_if(operand(r3C7C).val);
                        exec_list *const f3C7A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C7A->then_instructions;

                           body.emit(assign(r3C77, body.constant(int(16)), 0x01));

                           body.emit(assign(r3C75, lshift(swizzle_y(r3BAD), body.constant(int(16))), 0x01));


                        body.instructions = f3C7A_parent_instructions;
                        body.emit(f3C7A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3C7E = bit_and(r3C75, body.constant(4278190080u));
                        ir_expression *const r3C7F = equal(r3C7E, body.constant(0u));
                        ir_if *f3C7D = new(mem_ctx) ir_if(operand(r3C7F).val);
                        exec_list *const f3C7D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C7D->then_instructions;

                           body.emit(assign(r3C77, add(r3C77, body.constant(int(8))), 0x01));

                           body.emit(assign(r3C75, lshift(r3C75, body.constant(int(8))), 0x01));


                        body.instructions = f3C7D_parent_instructions;
                        body.emit(f3C7D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3C81 = bit_and(r3C75, body.constant(4026531840u));
                        ir_expression *const r3C82 = equal(r3C81, body.constant(0u));
                        ir_if *f3C80 = new(mem_ctx) ir_if(operand(r3C82).val);
                        exec_list *const f3C80_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C80->then_instructions;

                           body.emit(assign(r3C77, add(r3C77, body.constant(int(4))), 0x01));

                           body.emit(assign(r3C75, lshift(r3C75, body.constant(int(4))), 0x01));


                        body.instructions = f3C80_parent_instructions;
                        body.emit(f3C80);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3C84 = bit_and(r3C75, body.constant(3221225472u));
                        ir_expression *const r3C85 = equal(r3C84, body.constant(0u));
                        ir_if *f3C83 = new(mem_ctx) ir_if(operand(r3C85).val);
                        exec_list *const f3C83_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C83->then_instructions;

                           body.emit(assign(r3C77, add(r3C77, body.constant(int(2))), 0x01));

                           body.emit(assign(r3C75, lshift(r3C75, body.constant(int(2))), 0x01));


                        body.instructions = f3C83_parent_instructions;
                        body.emit(f3C83);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3C87 = bit_and(r3C75, body.constant(2147483648u));
                        ir_expression *const r3C88 = equal(r3C87, body.constant(0u));
                        ir_if *f3C86 = new(mem_ctx) ir_if(operand(r3C88).val);
                        exec_list *const f3C86_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C86->then_instructions;

                           body.emit(assign(r3C77, add(r3C77, body.constant(int(1))), 0x01));


                        body.instructions = f3C86_parent_instructions;
                        body.emit(f3C86);

                        /* END IF */

                        body.emit(assign(r3C76, r3C77, 0x01));


                     body.instructions = f3C78_parent_instructions;
                     body.emit(f3C78);

                     /* END IF */

                     body.emit(assign(r3C5A, add(r3C76, body.constant(int(-11))), 0x01));

                     ir_variable *const r3C89 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3C89, lshift(swizzle_x(r3682), r3C5A), 0x01));

                     ir_variable *const r3C8A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3C8C = equal(r3C5A, body.constant(int(0)));
                     ir_if *f3C8B = new(mem_ctx) ir_if(operand(r3C8C).val);
                     exec_list *const f3C8B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C8B->then_instructions;

                        body.emit(assign(r3C8A, r3C55, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3C8B->else_instructions;

                        ir_expression *const r3C8D = lshift(swizzle_y(r3BAD), r3C5A);
                        ir_expression *const r3C8E = neg(r3C5A);
                        ir_expression *const r3C8F = bit_and(r3C8E, body.constant(int(31)));
                        ir_expression *const r3C90 = rshift(swizzle_x(r3682), r3C8F);
                        body.emit(assign(r3C8A, bit_or(r3C8D, r3C90), 0x01));


                     body.instructions = f3C8B_parent_instructions;
                     body.emit(f3C8B);

                     /* END IF */

                     body.emit(assign(r3C58, r3C8A, 0x01));

                     body.emit(assign(r3C59, r3C89, 0x01));

                     body.emit(assign(r3C57, sub(body.constant(int(1)), r3C5A), 0x01));


                  body.instructions = f3C5B_parent_instructions;
                  body.emit(f3C5B);

                  /* END IF */

                  body.emit(assign(r3BA1, r3C57, 0x01));

                  body.emit(assign(r3BA2, r3C58, 0x02));

                  body.emit(assign(r3BA2, r3C59, 0x01));


               body.instructions = f3C51_parent_instructions;
               body.emit(f3C51);

               /* END IF */


            body.instructions = f3C4F_parent_instructions;
            body.emit(f3C4F);

            /* END IF */

            /* IF CONDITION */
            ir_if *f3C91 = new(mem_ctx) ir_if(operand(r3B9E).val);
            exec_list *const f3C91_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C91->then_instructions;

               ir_expression *const r3C92 = add(r3BA3, r3BA1);
               body.emit(assign(r3BA5, add(r3C92, body.constant(int(-1024))), 0x01));

               body.emit(assign(r3BA4, bit_or(swizzle_y(r3BA4), body.constant(1048576u)), 0x02));

               ir_variable *const r3C93 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3C93, lshift(swizzle_x(r3BA2), body.constant(int(12))), 0x01));

               ir_variable *const r3C94 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r3C95 = lshift(swizzle_y(r3BA2), body.constant(int(12)));
               ir_expression *const r3C96 = rshift(swizzle_x(r3BA2), body.constant(int(20)));
               body.emit(assign(r3C94, bit_or(r3C95, r3C96), 0x01));

               body.emit(assign(r3BA2, r3C94, 0x02));

               body.emit(assign(r3BA2, r3C93, 0x01));

               ir_variable *const r3C97 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3C97);
               ir_variable *const r3C98 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3C98);
               ir_variable *const r3C99 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3C99);
               ir_variable *const r3C9A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3C9A, bit_and(swizzle_x(r3BA4), body.constant(65535u)), 0x01));

               ir_variable *const r3C9B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3C9B, rshift(swizzle_x(r3BA4), body.constant(int(16))), 0x01));

               ir_variable *const r3C9C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3C9C, bit_and(r3C93, body.constant(65535u)), 0x01));

               ir_variable *const r3C9D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3C9D, rshift(r3C93, body.constant(int(16))), 0x01));

               ir_variable *const r3C9E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3C9E, mul(r3C9B, r3C9C), 0x01));

               ir_expression *const r3C9F = mul(r3C9A, r3C9D);
               body.emit(assign(r3C98, add(r3C9F, r3C9E), 0x01));

               ir_expression *const r3CA0 = mul(r3C9B, r3C9D);
               ir_expression *const r3CA1 = less(r3C98, r3C9E);
               ir_expression *const r3CA2 = expr(ir_unop_b2i, r3CA1);
               ir_expression *const r3CA3 = expr(ir_unop_i2u, r3CA2);
               ir_expression *const r3CA4 = lshift(r3CA3, body.constant(int(16)));
               ir_expression *const r3CA5 = rshift(r3C98, body.constant(int(16)));
               ir_expression *const r3CA6 = add(r3CA4, r3CA5);
               body.emit(assign(r3C97, add(r3CA0, r3CA6), 0x01));

               body.emit(assign(r3C98, lshift(r3C98, body.constant(int(16))), 0x01));

               ir_expression *const r3CA7 = mul(r3C9A, r3C9C);
               body.emit(assign(r3C99, add(r3CA7, r3C98), 0x01));

               ir_expression *const r3CA8 = less(r3C99, r3C98);
               ir_expression *const r3CA9 = expr(ir_unop_b2i, r3CA8);
               ir_expression *const r3CAA = expr(ir_unop_i2u, r3CA9);
               body.emit(assign(r3C97, add(r3C97, r3CAA), 0x01));

               ir_variable *const r3CAB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3CAB);
               ir_variable *const r3CAC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3CAC);
               ir_variable *const r3CAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3CAD);
               ir_variable *const r3CAE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CAE, bit_and(swizzle_x(r3BA4), body.constant(65535u)), 0x01));

               ir_variable *const r3CAF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CAF, rshift(swizzle_x(r3BA4), body.constant(int(16))), 0x01));

               ir_variable *const r3CB0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CB0, bit_and(r3C94, body.constant(65535u)), 0x01));

               ir_variable *const r3CB1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CB1, rshift(r3C94, body.constant(int(16))), 0x01));

               ir_variable *const r3CB2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CB2, mul(r3CAF, r3CB0), 0x01));

               ir_expression *const r3CB3 = mul(r3CAE, r3CB1);
               body.emit(assign(r3CAC, add(r3CB3, r3CB2), 0x01));

               ir_expression *const r3CB4 = mul(r3CAF, r3CB1);
               ir_expression *const r3CB5 = less(r3CAC, r3CB2);
               ir_expression *const r3CB6 = expr(ir_unop_b2i, r3CB5);
               ir_expression *const r3CB7 = expr(ir_unop_i2u, r3CB6);
               ir_expression *const r3CB8 = lshift(r3CB7, body.constant(int(16)));
               ir_expression *const r3CB9 = rshift(r3CAC, body.constant(int(16)));
               ir_expression *const r3CBA = add(r3CB8, r3CB9);
               body.emit(assign(r3CAB, add(r3CB4, r3CBA), 0x01));

               body.emit(assign(r3CAC, lshift(r3CAC, body.constant(int(16))), 0x01));

               ir_expression *const r3CBB = mul(r3CAE, r3CB0);
               body.emit(assign(r3CAD, add(r3CBB, r3CAC), 0x01));

               ir_expression *const r3CBC = less(r3CAD, r3CAC);
               ir_expression *const r3CBD = expr(ir_unop_b2i, r3CBC);
               ir_expression *const r3CBE = expr(ir_unop_i2u, r3CBD);
               body.emit(assign(r3CAB, add(r3CAB, r3CBE), 0x01));

               ir_variable *const r3CBF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CBF, add(r3CAD, r3C97), 0x01));

               ir_variable *const r3CC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3CC0);
               ir_variable *const r3CC1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3CC1);
               ir_variable *const r3CC2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3CC2);
               ir_variable *const r3CC3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CC3, bit_and(swizzle_y(r3BA4), body.constant(65535u)), 0x01));

               ir_variable *const r3CC4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CC4, rshift(swizzle_y(r3BA4), body.constant(int(16))), 0x01));

               ir_variable *const r3CC5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CC5, bit_and(r3C94, body.constant(65535u)), 0x01));

               ir_variable *const r3CC6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CC6, rshift(r3C94, body.constant(int(16))), 0x01));

               ir_variable *const r3CC7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CC7, mul(r3CC4, r3CC5), 0x01));

               ir_expression *const r3CC8 = mul(r3CC3, r3CC6);
               body.emit(assign(r3CC1, add(r3CC8, r3CC7), 0x01));

               ir_expression *const r3CC9 = mul(r3CC4, r3CC6);
               ir_expression *const r3CCA = less(r3CC1, r3CC7);
               ir_expression *const r3CCB = expr(ir_unop_b2i, r3CCA);
               ir_expression *const r3CCC = expr(ir_unop_i2u, r3CCB);
               ir_expression *const r3CCD = lshift(r3CCC, body.constant(int(16)));
               ir_expression *const r3CCE = rshift(r3CC1, body.constant(int(16)));
               ir_expression *const r3CCF = add(r3CCD, r3CCE);
               body.emit(assign(r3CC0, add(r3CC9, r3CCF), 0x01));

               body.emit(assign(r3CC1, lshift(r3CC1, body.constant(int(16))), 0x01));

               ir_expression *const r3CD0 = mul(r3CC3, r3CC5);
               body.emit(assign(r3CC2, add(r3CD0, r3CC1), 0x01));

               ir_expression *const r3CD1 = less(r3CC2, r3CC1);
               ir_expression *const r3CD2 = expr(ir_unop_b2i, r3CD1);
               ir_expression *const r3CD3 = expr(ir_unop_i2u, r3CD2);
               body.emit(assign(r3CC0, add(r3CC0, r3CD3), 0x01));

               ir_variable *const r3CD4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r3CD5 = less(r3CBF, r3CAD);
               ir_expression *const r3CD6 = expr(ir_unop_b2i, r3CD5);
               ir_expression *const r3CD7 = expr(ir_unop_i2u, r3CD6);
               ir_expression *const r3CD8 = add(r3CAB, r3CD7);
               body.emit(assign(r3CD4, add(r3CC2, r3CD8), 0x01));

               ir_variable *const r3CD9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3CD9);
               ir_variable *const r3CDA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3CDA);
               ir_variable *const r3CDB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3CDB);
               ir_variable *const r3CDC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CDC, bit_and(swizzle_y(r3BA4), body.constant(65535u)), 0x01));

               ir_variable *const r3CDD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CDD, rshift(swizzle_y(r3BA4), body.constant(int(16))), 0x01));

               ir_variable *const r3CDE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CDE, bit_and(r3C93, body.constant(65535u)), 0x01));

               ir_variable *const r3CDF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CDF, rshift(r3C93, body.constant(int(16))), 0x01));

               ir_variable *const r3CE0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CE0, mul(r3CDD, r3CDE), 0x01));

               ir_expression *const r3CE1 = mul(r3CDC, r3CDF);
               body.emit(assign(r3CDA, add(r3CE1, r3CE0), 0x01));

               ir_expression *const r3CE2 = mul(r3CDD, r3CDF);
               ir_expression *const r3CE3 = less(r3CDA, r3CE0);
               ir_expression *const r3CE4 = expr(ir_unop_b2i, r3CE3);
               ir_expression *const r3CE5 = expr(ir_unop_i2u, r3CE4);
               ir_expression *const r3CE6 = lshift(r3CE5, body.constant(int(16)));
               ir_expression *const r3CE7 = rshift(r3CDA, body.constant(int(16)));
               ir_expression *const r3CE8 = add(r3CE6, r3CE7);
               body.emit(assign(r3CD9, add(r3CE2, r3CE8), 0x01));

               body.emit(assign(r3CDA, lshift(r3CDA, body.constant(int(16))), 0x01));

               ir_expression *const r3CE9 = mul(r3CDC, r3CDE);
               body.emit(assign(r3CDB, add(r3CE9, r3CDA), 0x01));

               ir_expression *const r3CEA = less(r3CDB, r3CDA);
               ir_expression *const r3CEB = expr(ir_unop_b2i, r3CEA);
               ir_expression *const r3CEC = expr(ir_unop_i2u, r3CEB);
               body.emit(assign(r3CD9, add(r3CD9, r3CEC), 0x01));

               ir_variable *const r3CED = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CED, add(r3CDB, r3CBF), 0x01));

               ir_variable *const r3CEE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r3CEF = less(r3CED, r3CDB);
               ir_expression *const r3CF0 = expr(ir_unop_b2i, r3CEF);
               ir_expression *const r3CF1 = expr(ir_unop_i2u, r3CF0);
               ir_expression *const r3CF2 = add(r3CD9, r3CF1);
               body.emit(assign(r3CEE, add(r3CD4, r3CF2), 0x01));

               ir_variable *const r3CF3 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3CF4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3CF4, add(r3CEE, swizzle_x(r3BA4)), 0x01));

               ir_expression *const r3CF5 = less(r3CD4, r3CC2);
               ir_expression *const r3CF6 = expr(ir_unop_b2i, r3CF5);
               ir_expression *const r3CF7 = expr(ir_unop_i2u, r3CF6);
               ir_expression *const r3CF8 = add(r3CC0, r3CF7);
               ir_expression *const r3CF9 = less(r3CEE, r3CD4);
               ir_expression *const r3CFA = expr(ir_unop_b2i, r3CF9);
               ir_expression *const r3CFB = expr(ir_unop_i2u, r3CFA);
               ir_expression *const r3CFC = add(r3CF8, r3CFB);
               ir_expression *const r3CFD = add(r3CFC, swizzle_y(r3BA4));
               ir_expression *const r3CFE = less(r3CF4, r3CEE);
               ir_expression *const r3CFF = expr(ir_unop_b2i, r3CFE);
               ir_expression *const r3D00 = expr(ir_unop_i2u, r3CFF);
               body.emit(assign(r3CF3, add(r3CFD, r3D00), 0x01));

               body.emit(assign(r3BA8, r3CF3, 0x01));

               body.emit(assign(r3BA7, r3CF4, 0x01));

               ir_expression *const r3D01 = nequal(r3C99, body.constant(0u));
               ir_expression *const r3D02 = expr(ir_unop_b2i, r3D01);
               ir_expression *const r3D03 = expr(ir_unop_i2u, r3D02);
               body.emit(assign(r3BA6, bit_or(r3CED, r3D03), 0x01));

               /* IF CONDITION */
               ir_expression *const r3D05 = lequal(body.constant(2097152u), r3CF3);
               ir_if *f3D04 = new(mem_ctx) ir_if(operand(r3D05).val);
               exec_list *const f3D04_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D04->then_instructions;

                  ir_variable *const r3D06 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3D06);
                  body.emit(assign(r3D06, lshift(r3CF4, body.constant(int(31))), 0x01));

                  ir_expression *const r3D07 = nequal(r3BA6, body.constant(0u));
                  ir_expression *const r3D08 = expr(ir_unop_b2i, r3D07);
                  ir_expression *const r3D09 = expr(ir_unop_i2u, r3D08);
                  body.emit(assign(r3D06, bit_or(r3D06, r3D09), 0x01));

                  body.emit(assign(r3BA8, rshift(r3CF3, body.constant(int(1))), 0x01));

                  ir_expression *const r3D0A = lshift(r3CF3, body.constant(int(31)));
                  ir_expression *const r3D0B = rshift(r3CF4, body.constant(int(1)));
                  body.emit(assign(r3BA7, bit_or(r3D0A, r3D0B), 0x01));

                  body.emit(assign(r3BA6, r3D06, 0x01));

                  body.emit(assign(r3BA5, add(r3BA5, body.constant(int(1))), 0x01));


               body.instructions = f3D04_parent_instructions;
               body.emit(f3D04);

               /* END IF */

               ir_variable *const r3D0C = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3D0C, r3BA5, 0x01));

               ir_variable *const r3D0D = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3D0D, r3BA8, 0x01));

               ir_variable *const r3D0E = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3D0E, r3BA7, 0x01));

               ir_variable *const r3D0F = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3D0F, r3BA6, 0x01));

               ir_variable *const r3D10 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3D10, body.constant(true), 0x01));

               ir_variable *const r3D11 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3D12 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3D12);
               ir_expression *const r3D13 = expr(ir_unop_u2i, r3BA6);
               body.emit(assign(r3D12, less(r3D13, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3D15 = lequal(body.constant(int(2045)), r3BA5);
               ir_if *f3D14 = new(mem_ctx) ir_if(operand(r3D15).val);
               exec_list *const f3D14_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D14->then_instructions;

                  ir_variable *const r3D16 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3D18 = less(body.constant(int(2045)), r3BA5);
                  ir_if *f3D17 = new(mem_ctx) ir_if(operand(r3D18).val);
                  exec_list *const f3D17_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D17->then_instructions;

                     body.emit(assign(r3D16, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D17->else_instructions;

                     ir_variable *const r3D19 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3D1B = equal(r3BA5, body.constant(int(2045)));
                     ir_if *f3D1A = new(mem_ctx) ir_if(operand(r3D1B).val);
                     exec_list *const f3D1A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D1A->then_instructions;

                        ir_expression *const r3D1C = equal(body.constant(2097151u), r3BA8);
                        ir_expression *const r3D1D = equal(body.constant(4294967295u), r3BA7);
                        body.emit(assign(r3D19, logic_and(r3D1C, r3D1D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3D1A->else_instructions;

                        body.emit(assign(r3D19, body.constant(false), 0x01));


                     body.instructions = f3D1A_parent_instructions;
                     body.emit(f3D1A);

                     /* END IF */

                     body.emit(assign(r3D16, logic_and(r3D19, r3D12), 0x01));


                  body.instructions = f3D17_parent_instructions;
                  body.emit(f3D17);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3D1E = new(mem_ctx) ir_if(operand(r3D16).val);
                  exec_list *const f3D1E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D1E->then_instructions;

                     ir_variable *const r3D1F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3D1F);
                     ir_expression *const r3D20 = lshift(r3BA0, body.constant(int(31)));
                     body.emit(assign(r3D1F, add(r3D20, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3D1F, body.constant(0u), 0x01));

                     body.emit(assign(r3D11, r3D1F, 0x03));

                     body.emit(assign(r3D10, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D1E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3D22 = less(r3BA5, body.constant(int(0)));
                     ir_if *f3D21 = new(mem_ctx) ir_if(operand(r3D22).val);
                     exec_list *const f3D21_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D21->then_instructions;

                        ir_variable *const r3D23 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3D23, r3BA6, 0x01));

                        ir_variable *const r3D24 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3D24, neg(r3BA5), 0x01));

                        ir_variable *const r3D25 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3D25);
                        ir_variable *const r3D26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3D26);
                        ir_variable *const r3D27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3D27);
                        ir_variable *const r3D28 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3D29 = neg(r3D24);
                        body.emit(assign(r3D28, bit_and(r3D29, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3D2B = equal(r3D24, body.constant(int(0)));
                        ir_if *f3D2A = new(mem_ctx) ir_if(operand(r3D2B).val);
                        exec_list *const f3D2A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3D2A->then_instructions;

                           body.emit(assign(r3D25, r3BA6, 0x01));

                           body.emit(assign(r3D26, r3BA7, 0x01));

                           body.emit(assign(r3D27, r3BA8, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3D2A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3D2D = less(r3D24, body.constant(int(32)));
                           ir_if *f3D2C = new(mem_ctx) ir_if(operand(r3D2D).val);
                           exec_list *const f3D2C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3D2C->then_instructions;

                              body.emit(assign(r3D25, lshift(r3BA7, r3D28), 0x01));

                              ir_expression *const r3D2E = lshift(r3BA8, r3D28);
                              ir_expression *const r3D2F = rshift(r3BA7, r3D24);
                              body.emit(assign(r3D26, bit_or(r3D2E, r3D2F), 0x01));

                              body.emit(assign(r3D27, rshift(r3BA8, r3D24), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3D2C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3D31 = equal(r3D24, body.constant(int(32)));
                              ir_if *f3D30 = new(mem_ctx) ir_if(operand(r3D31).val);
                              exec_list *const f3D30_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3D30->then_instructions;

                                 body.emit(assign(r3D25, r3BA7, 0x01));

                                 body.emit(assign(r3D26, r3BA8, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3D30->else_instructions;

                                 body.emit(assign(r3D23, bit_or(r3BA6, r3BA7), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3D33 = less(r3D24, body.constant(int(64)));
                                 ir_if *f3D32 = new(mem_ctx) ir_if(operand(r3D33).val);
                                 exec_list *const f3D32_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3D32->then_instructions;

                                    body.emit(assign(r3D25, lshift(r3BA8, r3D28), 0x01));

                                    ir_expression *const r3D34 = bit_and(r3D24, body.constant(int(31)));
                                    body.emit(assign(r3D26, rshift(r3BA8, r3D34), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3D32->else_instructions;

                                    ir_variable *const r3D35 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3D37 = equal(r3D24, body.constant(int(64)));
                                    ir_if *f3D36 = new(mem_ctx) ir_if(operand(r3D37).val);
                                    exec_list *const f3D36_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3D36->then_instructions;

                                       body.emit(assign(r3D35, r3BA8, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3D36->else_instructions;

                                       ir_expression *const r3D38 = nequal(r3BA8, body.constant(0u));
                                       ir_expression *const r3D39 = expr(ir_unop_b2i, r3D38);
                                       body.emit(assign(r3D35, expr(ir_unop_i2u, r3D39), 0x01));


                                    body.instructions = f3D36_parent_instructions;
                                    body.emit(f3D36);

                                    /* END IF */

                                    body.emit(assign(r3D25, r3D35, 0x01));

                                    body.emit(assign(r3D26, body.constant(0u), 0x01));


                                 body.instructions = f3D32_parent_instructions;
                                 body.emit(f3D32);

                                 /* END IF */


                              body.instructions = f3D30_parent_instructions;
                              body.emit(f3D30);

                              /* END IF */

                              body.emit(assign(r3D27, body.constant(0u), 0x01));


                           body.instructions = f3D2C_parent_instructions;
                           body.emit(f3D2C);

                           /* END IF */

                           ir_expression *const r3D3A = nequal(r3D23, body.constant(0u));
                           ir_expression *const r3D3B = expr(ir_unop_b2i, r3D3A);
                           ir_expression *const r3D3C = expr(ir_unop_i2u, r3D3B);
                           body.emit(assign(r3D25, bit_or(r3D25, r3D3C), 0x01));


                        body.instructions = f3D2A_parent_instructions;
                        body.emit(f3D2A);

                        /* END IF */

                        body.emit(assign(r3D0D, r3D27, 0x01));

                        body.emit(assign(r3D0E, r3D26, 0x01));

                        body.emit(assign(r3D0F, r3D25, 0x01));

                        body.emit(assign(r3D0C, body.constant(int(0)), 0x01));

                        body.emit(assign(r3D12, less(r3D25, body.constant(0u)), 0x01));


                     body.instructions = f3D21_parent_instructions;
                     body.emit(f3D21);

                     /* END IF */


                  body.instructions = f3D1E_parent_instructions;
                  body.emit(f3D1E);

                  /* END IF */


               body.instructions = f3D14_parent_instructions;
               body.emit(f3D14);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3D3D = new(mem_ctx) ir_if(operand(r3D10).val);
               exec_list *const f3D3D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D3D->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3D3E = new(mem_ctx) ir_if(operand(r3D12).val);
                  exec_list *const f3D3E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D3E->then_instructions;

                     ir_variable *const r3D3F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3D3F, add(r3D0E, body.constant(1u)), 0x01));

                     ir_expression *const r3D40 = less(r3D3F, r3D0E);
                     ir_expression *const r3D41 = expr(ir_unop_b2i, r3D40);
                     ir_expression *const r3D42 = expr(ir_unop_i2u, r3D41);
                     body.emit(assign(r3D0D, add(r3D0D, r3D42), 0x01));

                     ir_expression *const r3D43 = equal(r3D0F, body.constant(0u));
                     ir_expression *const r3D44 = expr(ir_unop_b2i, r3D43);
                     ir_expression *const r3D45 = expr(ir_unop_i2u, r3D44);
                     ir_expression *const r3D46 = add(r3D0F, r3D45);
                     ir_expression *const r3D47 = bit_and(r3D46, body.constant(1u));
                     ir_expression *const r3D48 = expr(ir_unop_bit_not, r3D47);
                     body.emit(assign(r3D0E, bit_and(r3D3F, r3D48), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D3E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3D4A = bit_or(r3D0D, r3D0E);
                     ir_expression *const r3D4B = equal(r3D4A, body.constant(0u));
                     ir_if *f3D49 = new(mem_ctx) ir_if(operand(r3D4B).val);
                     exec_list *const f3D49_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D49->then_instructions;

                        body.emit(assign(r3D0C, body.constant(int(0)), 0x01));


                     body.instructions = f3D49_parent_instructions;
                     body.emit(f3D49);

                     /* END IF */


                  body.instructions = f3D3E_parent_instructions;
                  body.emit(f3D3E);

                  /* END IF */

                  ir_variable *const r3D4C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3D4C);
                  ir_expression *const r3D4D = lshift(r3BA0, body.constant(int(31)));
                  ir_expression *const r3D4E = expr(ir_unop_i2u, r3D0C);
                  ir_expression *const r3D4F = lshift(r3D4E, body.constant(int(20)));
                  ir_expression *const r3D50 = add(r3D4D, r3D4F);
                  body.emit(assign(r3D4C, add(r3D50, r3D0D), 0x02));

                  body.emit(assign(r3D4C, r3D0E, 0x01));

                  body.emit(assign(r3D11, r3D4C, 0x03));

                  body.emit(assign(r3D10, body.constant(false), 0x01));


               body.instructions = f3D3D_parent_instructions;
               body.emit(f3D3D);

               /* END IF */

               body.emit(assign(r3B9F, r3D11, 0x03));

               body.emit(assign(r3B9E, body.constant(false), 0x01));


            body.instructions = f3C91_parent_instructions;
            body.emit(f3C91);

            /* END IF */


         body.instructions = f3C4E_parent_instructions;
         body.emit(f3C4E);

         /* END IF */


      body.instructions = f3BE2_parent_instructions;
      body.emit(f3BE2);

      /* END IF */


   body.instructions = f3BB3_parent_instructions;
   body.emit(f3BB3);

   /* END IF */

   ir_variable *const r3D51 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3D52 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r3D52, rshift(swizzle_y(r33DD), body.constant(int(31))), 0x01));

   ir_variable *const r3D53 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r3D53, rshift(swizzle_y(r3B9F), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r3D55 = equal(r3D52, r3D53);
   ir_if *f3D54 = new(mem_ctx) ir_if(operand(r3D55).val);
   exec_list *const f3D54_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3D54->then_instructions;

      ir_variable *const r3D56 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r3D56, r3D52, 0x01));

      ir_variable *const r3D57 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3D58 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r3D58);
      ir_variable *const r3D59 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r3D59);
      ir_variable *const r3D5A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r3D5A);
      ir_variable *const r3D5B = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r3D5B);
      ir_variable *const r3D5C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r3D5C);
      ir_variable *const r3D5D = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r3D5D);
      ir_variable *const r3D5E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r3D5E);
      body.emit(assign(r3D5E, bit_and(swizzle_y(r33DD), body.constant(1048575u)), 0x02));

      body.emit(assign(r3D5E, swizzle_x(r33DD), 0x01));

      ir_variable *const r3D5F = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3D60 = rshift(swizzle_y(r33DD), body.constant(int(20)));
      ir_expression *const r3D61 = bit_and(r3D60, body.constant(2047u));
      body.emit(assign(r3D5F, expr(ir_unop_u2i, r3D61), 0x01));

      body.emit(assign(r3D5B, r3D5F, 0x01));

      ir_variable *const r3D62 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r3D62);
      body.emit(assign(r3D62, bit_and(swizzle_y(r3B9F), body.constant(1048575u)), 0x02));

      body.emit(assign(r3D62, swizzle_x(r3B9F), 0x01));

      ir_variable *const r3D63 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3D64 = rshift(swizzle_y(r3B9F), body.constant(int(20)));
      ir_expression *const r3D65 = bit_and(r3D64, body.constant(2047u));
      body.emit(assign(r3D63, expr(ir_unop_u2i, r3D65), 0x01));

      body.emit(assign(r3D59, r3D63, 0x01));

      body.emit(assign(r3D58, sub(r3D5F, r3D63), 0x01));

      ir_variable *const r3D66 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r3D66, lshift(swizzle_x(r33DD), body.constant(int(10))), 0x01));

      ir_variable *const r3D67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r3D68 = lshift(swizzle_y(r3D5E), body.constant(int(10)));
      ir_expression *const r3D69 = rshift(swizzle_x(r33DD), body.constant(int(22)));
      body.emit(assign(r3D67, bit_or(r3D68, r3D69), 0x01));

      body.emit(assign(r3D5C, r3D67, 0x02));

      body.emit(assign(r3D5C, r3D66, 0x01));

      ir_variable *const r3D6A = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r3D6A, lshift(swizzle_x(r3B9F), body.constant(int(10))), 0x01));

      ir_variable *const r3D6B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r3D6C = lshift(swizzle_y(r3D62), body.constant(int(10)));
      ir_expression *const r3D6D = rshift(swizzle_x(r3B9F), body.constant(int(22)));
      body.emit(assign(r3D6B, bit_or(r3D6C, r3D6D), 0x01));

      body.emit(assign(r3D5A, r3D6B, 0x02));

      body.emit(assign(r3D5A, r3D6A, 0x01));

      /* IF CONDITION */
      ir_expression *const r3D6F = less(body.constant(int(0)), r3D58);
      ir_if *f3D6E = new(mem_ctx) ir_if(operand(r3D6F).val);
      exec_list *const f3D6E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3D6E->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3D71 = equal(r3D5F, body.constant(int(2047)));
         ir_if *f3D70 = new(mem_ctx) ir_if(operand(r3D71).val);
         exec_list *const f3D70_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3D70->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3D73 = bit_or(r3D67, r3D66);
            ir_expression *const r3D74 = nequal(r3D73, body.constant(0u));
            ir_if *f3D72 = new(mem_ctx) ir_if(operand(r3D74).val);
            exec_list *const f3D72_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3D72->then_instructions;

               ir_variable *const r3D75 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r3D75, swizzle_x(r33DD), 0x01));

               ir_variable *const r3D76 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r3D76, swizzle_x(r3B9F), 0x01));

               ir_variable *const r3D77 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3D78 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3D79 = rshift(swizzle_y(r33DD), body.constant(int(19)));
               ir_expression *const r3D7A = bit_and(r3D79, body.constant(4095u));
               ir_expression *const r3D7B = equal(r3D7A, body.constant(4094u));
               ir_expression *const r3D7C = nequal(swizzle_x(r33DD), body.constant(0u));
               ir_expression *const r3D7D = bit_and(swizzle_y(r33DD), body.constant(524287u));
               ir_expression *const r3D7E = nequal(r3D7D, body.constant(0u));
               ir_expression *const r3D7F = logic_or(r3D7C, r3D7E);
               body.emit(assign(r3D78, logic_and(r3D7B, r3D7F), 0x01));

               ir_variable *const r3D80 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r3D81 = lshift(swizzle_y(r3B9F), body.constant(int(1)));
               ir_expression *const r3D82 = lequal(body.constant(4292870144u), r3D81);
               ir_expression *const r3D83 = nequal(swizzle_x(r3B9F), body.constant(0u));
               ir_expression *const r3D84 = bit_and(swizzle_y(r3B9F), body.constant(1048575u));
               ir_expression *const r3D85 = nequal(r3D84, body.constant(0u));
               ir_expression *const r3D86 = logic_or(r3D83, r3D85);
               body.emit(assign(r3D80, logic_and(r3D82, r3D86), 0x01));

               body.emit(assign(r3D75, bit_or(swizzle_y(r33DD), body.constant(524288u)), 0x02));

               body.emit(assign(r3D76, bit_or(swizzle_y(r3B9F), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r3D88 = lshift(swizzle_y(r33DD), body.constant(int(1)));
               ir_expression *const r3D89 = lequal(body.constant(4292870144u), r3D88);
               ir_expression *const r3D8A = nequal(swizzle_x(r33DD), body.constant(0u));
               ir_expression *const r3D8B = bit_and(swizzle_y(r33DD), body.constant(1048575u));
               ir_expression *const r3D8C = nequal(r3D8B, body.constant(0u));
               ir_expression *const r3D8D = logic_or(r3D8A, r3D8C);
               ir_expression *const r3D8E = logic_and(r3D89, r3D8D);
               ir_if *f3D87 = new(mem_ctx) ir_if(operand(r3D8E).val);
               exec_list *const f3D87_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D87->then_instructions;

                  ir_variable *const r3D8F = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3D91 = logic_and(r3D78, r3D80);
                  ir_if *f3D90 = new(mem_ctx) ir_if(operand(r3D91).val);
                  exec_list *const f3D90_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D90->then_instructions;

                     body.emit(assign(r3D8F, r3D76, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D90->else_instructions;

                     body.emit(assign(r3D8F, r3D75, 0x03));


                  body.instructions = f3D90_parent_instructions;
                  body.emit(f3D90);

                  /* END IF */

                  body.emit(assign(r3D77, r3D8F, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3D87->else_instructions;

                  body.emit(assign(r3D77, r3D76, 0x03));


               body.instructions = f3D87_parent_instructions;
               body.emit(f3D87);

               /* END IF */

               body.emit(assign(r3D57, r3D77, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3D72->else_instructions;

               body.emit(assign(r3D57, r33DD, 0x03));


            body.instructions = f3D72_parent_instructions;
            body.emit(f3D72);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3D70->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3D93 = equal(r3D63, body.constant(int(0)));
            ir_if *f3D92 = new(mem_ctx) ir_if(operand(r3D93).val);
            exec_list *const f3D92_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3D92->then_instructions;

               body.emit(assign(r3D58, add(r3D58, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3D92->else_instructions;

               body.emit(assign(r3D5A, bit_or(r3D6B, body.constant(1073741824u)), 0x02));


            body.instructions = f3D92_parent_instructions;
            body.emit(f3D92);

            /* END IF */

            ir_variable *const r3D94 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r3D94, swizzle_y(r3D5A), 0x01));

            ir_variable *const r3D95 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r3D95, swizzle_x(r3D5A), 0x01));

            ir_variable *const r3D96 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r3D96);
            ir_variable *const r3D97 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r3D97);
            ir_variable *const r3D98 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r3D99 = neg(r3D58);
            body.emit(assign(r3D98, bit_and(r3D99, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3D9B = equal(r3D58, body.constant(int(0)));
            ir_if *f3D9A = new(mem_ctx) ir_if(operand(r3D9B).val);
            exec_list *const f3D9A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3D9A->then_instructions;

               body.emit(assign(r3D96, r3D95, 0x01));

               body.emit(assign(r3D97, r3D94, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3D9A->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3D9D = less(r3D58, body.constant(int(32)));
               ir_if *f3D9C = new(mem_ctx) ir_if(operand(r3D9D).val);
               exec_list *const f3D9C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D9C->then_instructions;

                  ir_expression *const r3D9E = lshift(swizzle_y(r3D5A), r3D98);
                  ir_expression *const r3D9F = rshift(r3D6A, r3D58);
                  ir_expression *const r3DA0 = bit_or(r3D9E, r3D9F);
                  ir_expression *const r3DA1 = lshift(r3D6A, r3D98);
                  ir_expression *const r3DA2 = nequal(r3DA1, body.constant(0u));
                  ir_expression *const r3DA3 = expr(ir_unop_b2i, r3DA2);
                  ir_expression *const r3DA4 = expr(ir_unop_i2u, r3DA3);
                  body.emit(assign(r3D96, bit_or(r3DA0, r3DA4), 0x01));

                  body.emit(assign(r3D97, rshift(swizzle_y(r3D5A), r3D58), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3D9C->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3DA6 = equal(r3D58, body.constant(int(32)));
                  ir_if *f3DA5 = new(mem_ctx) ir_if(operand(r3DA6).val);
                  exec_list *const f3DA5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3DA5->then_instructions;

                     ir_expression *const r3DA7 = nequal(r3D6A, body.constant(0u));
                     ir_expression *const r3DA8 = expr(ir_unop_b2i, r3DA7);
                     ir_expression *const r3DA9 = expr(ir_unop_i2u, r3DA8);
                     body.emit(assign(r3D96, bit_or(swizzle_y(r3D5A), r3DA9), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3DA5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3DAB = less(r3D58, body.constant(int(64)));
                     ir_if *f3DAA = new(mem_ctx) ir_if(operand(r3DAB).val);
                     exec_list *const f3DAA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DAA->then_instructions;

                        ir_expression *const r3DAC = bit_and(r3D58, body.constant(int(31)));
                        ir_expression *const r3DAD = rshift(swizzle_y(r3D5A), r3DAC);
                        ir_expression *const r3DAE = lshift(swizzle_y(r3D5A), r3D98);
                        ir_expression *const r3DAF = bit_or(r3DAE, r3D6A);
                        ir_expression *const r3DB0 = nequal(r3DAF, body.constant(0u));
                        ir_expression *const r3DB1 = expr(ir_unop_b2i, r3DB0);
                        ir_expression *const r3DB2 = expr(ir_unop_i2u, r3DB1);
                        body.emit(assign(r3D96, bit_or(r3DAD, r3DB2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DAA->else_instructions;

                        ir_expression *const r3DB3 = bit_or(swizzle_y(r3D5A), r3D6A);
                        ir_expression *const r3DB4 = nequal(r3DB3, body.constant(0u));
                        ir_expression *const r3DB5 = expr(ir_unop_b2i, r3DB4);
                        body.emit(assign(r3D96, expr(ir_unop_i2u, r3DB5), 0x01));


                     body.instructions = f3DAA_parent_instructions;
                     body.emit(f3DAA);

                     /* END IF */


                  body.instructions = f3DA5_parent_instructions;
                  body.emit(f3DA5);

                  /* END IF */

                  body.emit(assign(r3D97, body.constant(0u), 0x01));


               body.instructions = f3D9C_parent_instructions;
               body.emit(f3D9C);

               /* END IF */


            body.instructions = f3D9A_parent_instructions;
            body.emit(f3D9A);

            /* END IF */

            body.emit(assign(r3D5A, r3D97, 0x02));

            body.emit(assign(r3D5A, r3D96, 0x01));

            body.emit(assign(r3D5C, bit_or(r3D67, body.constant(1073741824u)), 0x02));

            ir_variable *const r3DB6 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r3DB7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r3DB7, sub(r3D66, r3D96), 0x01));

            ir_expression *const r3DB8 = sub(swizzle_y(r3D5C), r3D97);
            ir_expression *const r3DB9 = less(r3D66, r3D96);
            ir_expression *const r3DBA = expr(ir_unop_b2i, r3DB9);
            ir_expression *const r3DBB = expr(ir_unop_i2u, r3DBA);
            body.emit(assign(r3DB6, sub(r3DB8, r3DBB), 0x01));

            body.emit(assign(r3D5D, add(r3D5F, body.constant(int(-1))), 0x01));

            ir_variable *const r3DBC = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r3DBC, add(r3D5D, body.constant(int(-10))), 0x01));

            ir_variable *const r3DBD = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r3DBD, r3DB6, 0x01));

            ir_variable *const r3DBE = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r3DBE, r3DB7, 0x01));

            ir_variable *const r3DBF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r3DBF);
            ir_variable *const r3DC0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r3DC0);
            /* IF CONDITION */
            ir_expression *const r3DC2 = equal(r3DB6, body.constant(0u));
            ir_if *f3DC1 = new(mem_ctx) ir_if(operand(r3DC2).val);
            exec_list *const f3DC1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3DC1->then_instructions;

               body.emit(assign(r3DBD, r3DB7, 0x01));

               body.emit(assign(r3DBE, body.constant(0u), 0x01));

               body.emit(assign(r3DBC, add(r3DBC, body.constant(int(-32))), 0x01));


            body.instructions = f3DC1_parent_instructions;
            body.emit(f3DC1);

            /* END IF */

            ir_variable *const r3DC3 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r3DC3, r3DBD, 0x01));

            ir_variable *const r3DC4 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r3DC5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r3DC5);
            /* IF CONDITION */
            ir_expression *const r3DC7 = equal(r3DBD, body.constant(0u));
            ir_if *f3DC6 = new(mem_ctx) ir_if(operand(r3DC7).val);
            exec_list *const f3DC6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3DC6->then_instructions;

               body.emit(assign(r3DC4, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3DC6->else_instructions;

               body.emit(assign(r3DC5, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r3DC9 = bit_and(r3DBD, body.constant(4294901760u));
               ir_expression *const r3DCA = equal(r3DC9, body.constant(0u));
               ir_if *f3DC8 = new(mem_ctx) ir_if(operand(r3DCA).val);
               exec_list *const f3DC8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3DC8->then_instructions;

                  body.emit(assign(r3DC5, body.constant(int(16)), 0x01));

                  body.emit(assign(r3DC3, lshift(r3DBD, body.constant(int(16))), 0x01));


               body.instructions = f3DC8_parent_instructions;
               body.emit(f3DC8);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3DCC = bit_and(r3DC3, body.constant(4278190080u));
               ir_expression *const r3DCD = equal(r3DCC, body.constant(0u));
               ir_if *f3DCB = new(mem_ctx) ir_if(operand(r3DCD).val);
               exec_list *const f3DCB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3DCB->then_instructions;

                  body.emit(assign(r3DC5, add(r3DC5, body.constant(int(8))), 0x01));

                  body.emit(assign(r3DC3, lshift(r3DC3, body.constant(int(8))), 0x01));


               body.instructions = f3DCB_parent_instructions;
               body.emit(f3DCB);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3DCF = bit_and(r3DC3, body.constant(4026531840u));
               ir_expression *const r3DD0 = equal(r3DCF, body.constant(0u));
               ir_if *f3DCE = new(mem_ctx) ir_if(operand(r3DD0).val);
               exec_list *const f3DCE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3DCE->then_instructions;

                  body.emit(assign(r3DC5, add(r3DC5, body.constant(int(4))), 0x01));

                  body.emit(assign(r3DC3, lshift(r3DC3, body.constant(int(4))), 0x01));


               body.instructions = f3DCE_parent_instructions;
               body.emit(f3DCE);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3DD2 = bit_and(r3DC3, body.constant(3221225472u));
               ir_expression *const r3DD3 = equal(r3DD2, body.constant(0u));
               ir_if *f3DD1 = new(mem_ctx) ir_if(operand(r3DD3).val);
               exec_list *const f3DD1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3DD1->then_instructions;

                  body.emit(assign(r3DC5, add(r3DC5, body.constant(int(2))), 0x01));

                  body.emit(assign(r3DC3, lshift(r3DC3, body.constant(int(2))), 0x01));


               body.instructions = f3DD1_parent_instructions;
               body.emit(f3DD1);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3DD5 = bit_and(r3DC3, body.constant(2147483648u));
               ir_expression *const r3DD6 = equal(r3DD5, body.constant(0u));
               ir_if *f3DD4 = new(mem_ctx) ir_if(operand(r3DD6).val);
               exec_list *const f3DD4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3DD4->then_instructions;

                  body.emit(assign(r3DC5, add(r3DC5, body.constant(int(1))), 0x01));


               body.instructions = f3DD4_parent_instructions;
               body.emit(f3DD4);

               /* END IF */

               body.emit(assign(r3DC4, r3DC5, 0x01));


            body.instructions = f3DC6_parent_instructions;
            body.emit(f3DC6);

            /* END IF */

            body.emit(assign(r3DC0, add(r3DC4, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3DD8 = lequal(body.constant(int(0)), r3DC0);
            ir_if *f3DD7 = new(mem_ctx) ir_if(operand(r3DD8).val);
            exec_list *const f3DD7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3DD7->then_instructions;

               body.emit(assign(r3DBF, body.constant(0u), 0x01));

               ir_variable *const r3DD9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3DD9, lshift(r3DBE, r3DC0), 0x01));

               ir_variable *const r3DDA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r3DDC = equal(r3DC0, body.constant(int(0)));
               ir_if *f3DDB = new(mem_ctx) ir_if(operand(r3DDC).val);
               exec_list *const f3DDB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3DDB->then_instructions;

                  body.emit(assign(r3DDA, r3DBD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3DDB->else_instructions;

                  ir_expression *const r3DDD = lshift(r3DBD, r3DC0);
                  ir_expression *const r3DDE = neg(r3DC0);
                  ir_expression *const r3DDF = bit_and(r3DDE, body.constant(int(31)));
                  ir_expression *const r3DE0 = rshift(r3DBE, r3DDF);
                  body.emit(assign(r3DDA, bit_or(r3DDD, r3DE0), 0x01));


               body.instructions = f3DDB_parent_instructions;
               body.emit(f3DDB);

               /* END IF */

               body.emit(assign(r3DBD, r3DDA, 0x01));

               body.emit(assign(r3DBE, r3DD9, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3DD7->else_instructions;

               ir_variable *const r3DE1 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r3DE1, body.constant(0u), 0x01));

               ir_variable *const r3DE2 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r3DE2, neg(r3DC0), 0x01));

               ir_variable *const r3DE3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r3DE3);
               ir_variable *const r3DE4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3DE4);
               ir_variable *const r3DE5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3DE5);
               ir_variable *const r3DE6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3DE7 = neg(r3DE2);
               body.emit(assign(r3DE6, bit_and(r3DE7, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3DE9 = equal(r3DE2, body.constant(int(0)));
               ir_if *f3DE8 = new(mem_ctx) ir_if(operand(r3DE9).val);
               exec_list *const f3DE8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3DE8->then_instructions;

                  body.emit(assign(r3DE3, r3DE1, 0x01));

                  body.emit(assign(r3DE4, r3DBE, 0x01));

                  body.emit(assign(r3DE5, r3DBD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3DE8->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3DEB = less(r3DE2, body.constant(int(32)));
                  ir_if *f3DEA = new(mem_ctx) ir_if(operand(r3DEB).val);
                  exec_list *const f3DEA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3DEA->then_instructions;

                     body.emit(assign(r3DE3, lshift(r3DBE, r3DE6), 0x01));

                     ir_expression *const r3DEC = lshift(r3DBD, r3DE6);
                     ir_expression *const r3DED = rshift(r3DBE, r3DE2);
                     body.emit(assign(r3DE4, bit_or(r3DEC, r3DED), 0x01));

                     body.emit(assign(r3DE5, rshift(r3DBD, r3DE2), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3DEA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3DEF = equal(r3DE2, body.constant(int(32)));
                     ir_if *f3DEE = new(mem_ctx) ir_if(operand(r3DEF).val);
                     exec_list *const f3DEE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DEE->then_instructions;

                        body.emit(assign(r3DE3, r3DBE, 0x01));

                        body.emit(assign(r3DE4, r3DBD, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DEE->else_instructions;

                        body.emit(assign(r3DE1, bit_or(body.constant(0u), r3DBE), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3DF1 = less(r3DE2, body.constant(int(64)));
                        ir_if *f3DF0 = new(mem_ctx) ir_if(operand(r3DF1).val);
                        exec_list *const f3DF0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3DF0->then_instructions;

                           body.emit(assign(r3DE3, lshift(r3DBD, r3DE6), 0x01));

                           ir_expression *const r3DF2 = bit_and(r3DE2, body.constant(int(31)));
                           body.emit(assign(r3DE4, rshift(r3DBD, r3DF2), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3DF0->else_instructions;

                           ir_variable *const r3DF3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3DF5 = equal(r3DE2, body.constant(int(64)));
                           ir_if *f3DF4 = new(mem_ctx) ir_if(operand(r3DF5).val);
                           exec_list *const f3DF4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3DF4->then_instructions;

                              body.emit(assign(r3DF3, r3DBD, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3DF4->else_instructions;

                              ir_expression *const r3DF6 = nequal(r3DBD, body.constant(0u));
                              ir_expression *const r3DF7 = expr(ir_unop_b2i, r3DF6);
                              body.emit(assign(r3DF3, expr(ir_unop_i2u, r3DF7), 0x01));


                           body.instructions = f3DF4_parent_instructions;
                           body.emit(f3DF4);

                           /* END IF */

                           body.emit(assign(r3DE3, r3DF3, 0x01));

                           body.emit(assign(r3DE4, body.constant(0u), 0x01));


                        body.instructions = f3DF0_parent_instructions;
                        body.emit(f3DF0);

                        /* END IF */


                     body.instructions = f3DEE_parent_instructions;
                     body.emit(f3DEE);

                     /* END IF */

                     body.emit(assign(r3DE5, body.constant(0u), 0x01));


                  body.instructions = f3DEA_parent_instructions;
                  body.emit(f3DEA);

                  /* END IF */

                  ir_expression *const r3DF8 = nequal(r3DE1, body.constant(0u));
                  ir_expression *const r3DF9 = expr(ir_unop_b2i, r3DF8);
                  ir_expression *const r3DFA = expr(ir_unop_i2u, r3DF9);
                  body.emit(assign(r3DE3, bit_or(r3DE3, r3DFA), 0x01));


               body.instructions = f3DE8_parent_instructions;
               body.emit(f3DE8);

               /* END IF */

               body.emit(assign(r3DBD, r3DE5, 0x01));

               body.emit(assign(r3DBE, r3DE4, 0x01));

               body.emit(assign(r3DBF, r3DE3, 0x01));


            body.instructions = f3DD7_parent_instructions;
            body.emit(f3DD7);

            /* END IF */

            body.emit(assign(r3DBC, sub(r3DBC, r3DC0), 0x01));

            ir_variable *const r3DFB = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r3DFB, r3DBC, 0x01));

            ir_variable *const r3DFC = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r3DFC, r3DBD, 0x01));

            ir_variable *const r3DFD = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r3DFD, r3DBE, 0x01));

            ir_variable *const r3DFE = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r3DFE, r3DBF, 0x01));

            ir_variable *const r3DFF = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r3DFF, body.constant(true), 0x01));

            ir_variable *const r3E00 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3E01 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r3E01);
            ir_expression *const r3E02 = expr(ir_unop_u2i, r3DBF);
            body.emit(assign(r3E01, less(r3E02, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3E04 = lequal(body.constant(int(2045)), r3DBC);
            ir_if *f3E03 = new(mem_ctx) ir_if(operand(r3E04).val);
            exec_list *const f3E03_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3E03->then_instructions;

               ir_variable *const r3E05 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r3E07 = less(body.constant(int(2045)), r3DBC);
               ir_if *f3E06 = new(mem_ctx) ir_if(operand(r3E07).val);
               exec_list *const f3E06_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3E06->then_instructions;

                  body.emit(assign(r3E05, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3E06->else_instructions;

                  ir_variable *const r3E08 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3E0A = equal(r3DBC, body.constant(int(2045)));
                  ir_if *f3E09 = new(mem_ctx) ir_if(operand(r3E0A).val);
                  exec_list *const f3E09_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3E09->then_instructions;

                     ir_expression *const r3E0B = equal(body.constant(2097151u), r3DBD);
                     ir_expression *const r3E0C = equal(body.constant(4294967295u), r3DBE);
                     body.emit(assign(r3E08, logic_and(r3E0B, r3E0C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3E09->else_instructions;

                     body.emit(assign(r3E08, body.constant(false), 0x01));


                  body.instructions = f3E09_parent_instructions;
                  body.emit(f3E09);

                  /* END IF */

                  body.emit(assign(r3E05, logic_and(r3E08, r3E01), 0x01));


               body.instructions = f3E06_parent_instructions;
               body.emit(f3E06);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3E0D = new(mem_ctx) ir_if(operand(r3E05).val);
               exec_list *const f3E0D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3E0D->then_instructions;

                  ir_variable *const r3E0E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3E0E);
                  ir_expression *const r3E0F = lshift(r3D52, body.constant(int(31)));
                  body.emit(assign(r3E0E, add(r3E0F, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r3E0E, body.constant(0u), 0x01));

                  body.emit(assign(r3E00, r3E0E, 0x03));

                  body.emit(assign(r3DFF, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3E0D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3E11 = less(r3DBC, body.constant(int(0)));
                  ir_if *f3E10 = new(mem_ctx) ir_if(operand(r3E11).val);
                  exec_list *const f3E10_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3E10->then_instructions;

                     ir_variable *const r3E12 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3E12, r3DBF, 0x01));

                     ir_variable *const r3E13 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3E13, neg(r3DBC), 0x01));

                     ir_variable *const r3E14 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3E14);
                     ir_variable *const r3E15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3E15);
                     ir_variable *const r3E16 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3E16);
                     ir_variable *const r3E17 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r3E18 = neg(r3E13);
                     body.emit(assign(r3E17, bit_and(r3E18, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3E1A = equal(r3E13, body.constant(int(0)));
                     ir_if *f3E19 = new(mem_ctx) ir_if(operand(r3E1A).val);
                     exec_list *const f3E19_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E19->then_instructions;

                        body.emit(assign(r3E14, r3DBF, 0x01));

                        body.emit(assign(r3E15, r3DBE, 0x01));

                        body.emit(assign(r3E16, r3DBD, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3E19->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3E1C = less(r3E13, body.constant(int(32)));
                        ir_if *f3E1B = new(mem_ctx) ir_if(operand(r3E1C).val);
                        exec_list *const f3E1B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E1B->then_instructions;

                           body.emit(assign(r3E14, lshift(r3DBE, r3E17), 0x01));

                           ir_expression *const r3E1D = lshift(r3DBD, r3E17);
                           ir_expression *const r3E1E = rshift(r3DBE, r3E13);
                           body.emit(assign(r3E15, bit_or(r3E1D, r3E1E), 0x01));

                           body.emit(assign(r3E16, rshift(r3DBD, r3E13), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E1B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3E20 = equal(r3E13, body.constant(int(32)));
                           ir_if *f3E1F = new(mem_ctx) ir_if(operand(r3E20).val);
                           exec_list *const f3E1F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3E1F->then_instructions;

                              body.emit(assign(r3E14, r3DBE, 0x01));

                              body.emit(assign(r3E15, r3DBD, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3E1F->else_instructions;

                              body.emit(assign(r3E12, bit_or(r3DBF, r3DBE), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3E22 = less(r3E13, body.constant(int(64)));
                              ir_if *f3E21 = new(mem_ctx) ir_if(operand(r3E22).val);
                              exec_list *const f3E21_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3E21->then_instructions;

                                 body.emit(assign(r3E14, lshift(r3DBD, r3E17), 0x01));

                                 ir_expression *const r3E23 = bit_and(r3E13, body.constant(int(31)));
                                 body.emit(assign(r3E15, rshift(r3DBD, r3E23), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3E21->else_instructions;

                                 ir_variable *const r3E24 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3E26 = equal(r3E13, body.constant(int(64)));
                                 ir_if *f3E25 = new(mem_ctx) ir_if(operand(r3E26).val);
                                 exec_list *const f3E25_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3E25->then_instructions;

                                    body.emit(assign(r3E24, r3DBD, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3E25->else_instructions;

                                    ir_expression *const r3E27 = nequal(r3DBD, body.constant(0u));
                                    ir_expression *const r3E28 = expr(ir_unop_b2i, r3E27);
                                    body.emit(assign(r3E24, expr(ir_unop_i2u, r3E28), 0x01));


                                 body.instructions = f3E25_parent_instructions;
                                 body.emit(f3E25);

                                 /* END IF */

                                 body.emit(assign(r3E14, r3E24, 0x01));

                                 body.emit(assign(r3E15, body.constant(0u), 0x01));


                              body.instructions = f3E21_parent_instructions;
                              body.emit(f3E21);

                              /* END IF */


                           body.instructions = f3E1F_parent_instructions;
                           body.emit(f3E1F);

                           /* END IF */

                           body.emit(assign(r3E16, body.constant(0u), 0x01));


                        body.instructions = f3E1B_parent_instructions;
                        body.emit(f3E1B);

                        /* END IF */

                        ir_expression *const r3E29 = nequal(r3E12, body.constant(0u));
                        ir_expression *const r3E2A = expr(ir_unop_b2i, r3E29);
                        ir_expression *const r3E2B = expr(ir_unop_i2u, r3E2A);
                        body.emit(assign(r3E14, bit_or(r3E14, r3E2B), 0x01));


                     body.instructions = f3E19_parent_instructions;
                     body.emit(f3E19);

                     /* END IF */

                     body.emit(assign(r3DFC, r3E16, 0x01));

                     body.emit(assign(r3DFD, r3E15, 0x01));

                     body.emit(assign(r3DFE, r3E14, 0x01));

                     body.emit(assign(r3DFB, body.constant(int(0)), 0x01));

                     body.emit(assign(r3E01, less(r3E14, body.constant(0u)), 0x01));


                  body.instructions = f3E10_parent_instructions;
                  body.emit(f3E10);

                  /* END IF */


               body.instructions = f3E0D_parent_instructions;
               body.emit(f3E0D);

               /* END IF */


            body.instructions = f3E03_parent_instructions;
            body.emit(f3E03);

            /* END IF */

            /* IF CONDITION */
            ir_if *f3E2C = new(mem_ctx) ir_if(operand(r3DFF).val);
            exec_list *const f3E2C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3E2C->then_instructions;

               /* IF CONDITION */
               ir_if *f3E2D = new(mem_ctx) ir_if(operand(r3E01).val);
               exec_list *const f3E2D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3E2D->then_instructions;

                  ir_variable *const r3E2E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3E2E, add(r3DFD, body.constant(1u)), 0x01));

                  ir_expression *const r3E2F = less(r3E2E, r3DFD);
                  ir_expression *const r3E30 = expr(ir_unop_b2i, r3E2F);
                  ir_expression *const r3E31 = expr(ir_unop_i2u, r3E30);
                  body.emit(assign(r3DFC, add(r3DFC, r3E31), 0x01));

                  ir_expression *const r3E32 = equal(r3DFE, body.constant(0u));
                  ir_expression *const r3E33 = expr(ir_unop_b2i, r3E32);
                  ir_expression *const r3E34 = expr(ir_unop_i2u, r3E33);
                  ir_expression *const r3E35 = add(r3DFE, r3E34);
                  ir_expression *const r3E36 = bit_and(r3E35, body.constant(1u));
                  ir_expression *const r3E37 = expr(ir_unop_bit_not, r3E36);
                  body.emit(assign(r3DFD, bit_and(r3E2E, r3E37), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3E2D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3E39 = bit_or(r3DFC, r3DFD);
                  ir_expression *const r3E3A = equal(r3E39, body.constant(0u));
                  ir_if *f3E38 = new(mem_ctx) ir_if(operand(r3E3A).val);
                  exec_list *const f3E38_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3E38->then_instructions;

                     body.emit(assign(r3DFB, body.constant(int(0)), 0x01));


                  body.instructions = f3E38_parent_instructions;
                  body.emit(f3E38);

                  /* END IF */


               body.instructions = f3E2D_parent_instructions;
               body.emit(f3E2D);

               /* END IF */

               ir_variable *const r3E3B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3E3B);
               ir_expression *const r3E3C = lshift(r3D52, body.constant(int(31)));
               ir_expression *const r3E3D = expr(ir_unop_i2u, r3DFB);
               ir_expression *const r3E3E = lshift(r3E3D, body.constant(int(20)));
               ir_expression *const r3E3F = add(r3E3C, r3E3E);
               body.emit(assign(r3E3B, add(r3E3F, r3DFC), 0x02));

               body.emit(assign(r3E3B, r3DFD, 0x01));

               body.emit(assign(r3E00, r3E3B, 0x03));

               body.emit(assign(r3DFF, body.constant(false), 0x01));


            body.instructions = f3E2C_parent_instructions;
            body.emit(f3E2C);

            /* END IF */

            body.emit(assign(r3D57, r3E00, 0x03));


         body.instructions = f3D70_parent_instructions;
         body.emit(f3D70);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3D6E->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3E41 = less(r3D58, body.constant(int(0)));
         ir_if *f3E40 = new(mem_ctx) ir_if(operand(r3E41).val);
         exec_list *const f3E40_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3E40->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3E43 = equal(r3D63, body.constant(int(2047)));
            ir_if *f3E42 = new(mem_ctx) ir_if(operand(r3E43).val);
            exec_list *const f3E42_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3E42->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3E45 = bit_or(swizzle_y(r3D5A), swizzle_x(r3D5A));
               ir_expression *const r3E46 = nequal(r3E45, body.constant(0u));
               ir_if *f3E44 = new(mem_ctx) ir_if(operand(r3E46).val);
               exec_list *const f3E44_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3E44->then_instructions;

                  ir_variable *const r3E47 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r3E47, swizzle_x(r33DD), 0x01));

                  ir_variable *const r3E48 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r3E48, swizzle_x(r3B9F), 0x01));

                  ir_variable *const r3E49 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3E4A = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r3E4B = rshift(swizzle_y(r33DD), body.constant(int(19)));
                  ir_expression *const r3E4C = bit_and(r3E4B, body.constant(4095u));
                  ir_expression *const r3E4D = equal(r3E4C, body.constant(4094u));
                  ir_expression *const r3E4E = nequal(swizzle_x(r33DD), body.constant(0u));
                  ir_expression *const r3E4F = bit_and(swizzle_y(r33DD), body.constant(524287u));
                  ir_expression *const r3E50 = nequal(r3E4F, body.constant(0u));
                  ir_expression *const r3E51 = logic_or(r3E4E, r3E50);
                  body.emit(assign(r3E4A, logic_and(r3E4D, r3E51), 0x01));

                  ir_variable *const r3E52 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r3E53 = lshift(swizzle_y(r3B9F), body.constant(int(1)));
                  ir_expression *const r3E54 = lequal(body.constant(4292870144u), r3E53);
                  ir_expression *const r3E55 = nequal(swizzle_x(r3B9F), body.constant(0u));
                  ir_expression *const r3E56 = bit_and(swizzle_y(r3B9F), body.constant(1048575u));
                  ir_expression *const r3E57 = nequal(r3E56, body.constant(0u));
                  ir_expression *const r3E58 = logic_or(r3E55, r3E57);
                  body.emit(assign(r3E52, logic_and(r3E54, r3E58), 0x01));

                  body.emit(assign(r3E47, bit_or(swizzle_y(r33DD), body.constant(524288u)), 0x02));

                  body.emit(assign(r3E48, bit_or(swizzle_y(r3B9F), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3E5A = lshift(swizzle_y(r33DD), body.constant(int(1)));
                  ir_expression *const r3E5B = lequal(body.constant(4292870144u), r3E5A);
                  ir_expression *const r3E5C = nequal(swizzle_x(r33DD), body.constant(0u));
                  ir_expression *const r3E5D = bit_and(swizzle_y(r33DD), body.constant(1048575u));
                  ir_expression *const r3E5E = nequal(r3E5D, body.constant(0u));
                  ir_expression *const r3E5F = logic_or(r3E5C, r3E5E);
                  ir_expression *const r3E60 = logic_and(r3E5B, r3E5F);
                  ir_if *f3E59 = new(mem_ctx) ir_if(operand(r3E60).val);
                  exec_list *const f3E59_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3E59->then_instructions;

                     ir_variable *const r3E61 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3E63 = logic_and(r3E4A, r3E52);
                     ir_if *f3E62 = new(mem_ctx) ir_if(operand(r3E63).val);
                     exec_list *const f3E62_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E62->then_instructions;

                        body.emit(assign(r3E61, r3E48, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3E62->else_instructions;

                        body.emit(assign(r3E61, r3E47, 0x03));


                     body.instructions = f3E62_parent_instructions;
                     body.emit(f3E62);

                     /* END IF */

                     body.emit(assign(r3E49, r3E61, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3E59->else_instructions;

                     body.emit(assign(r3E49, r3E48, 0x03));


                  body.instructions = f3E59_parent_instructions;
                  body.emit(f3E59);

                  /* END IF */

                  body.emit(assign(r3D57, r3E49, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3E44->else_instructions;

                  ir_variable *const r3E64 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3E64);
                  ir_expression *const r3E65 = bit_xor(r3D52, body.constant(1u));
                  ir_expression *const r3E66 = lshift(r3E65, body.constant(int(31)));
                  body.emit(assign(r3E64, add(r3E66, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r3E64, body.constant(0u), 0x01));

                  body.emit(assign(r3D57, r3E64, 0x03));


               body.instructions = f3E44_parent_instructions;
               body.emit(f3E44);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3E42->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3E68 = equal(r3D5F, body.constant(int(0)));
               ir_if *f3E67 = new(mem_ctx) ir_if(operand(r3E68).val);
               exec_list *const f3E67_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3E67->then_instructions;

                  body.emit(assign(r3D58, add(r3D58, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3E67->else_instructions;

                  body.emit(assign(r3D5C, bit_or(swizzle_y(r3D5C), body.constant(1073741824u)), 0x02));


               body.instructions = f3E67_parent_instructions;
               body.emit(f3E67);

               /* END IF */

               ir_variable *const r3E69 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r3E69, swizzle_y(r3D5C), 0x01));

               ir_variable *const r3E6A = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r3E6A, swizzle_x(r3D5C), 0x01));

               ir_variable *const r3E6B = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r3E6B, neg(r3D58), 0x01));

               ir_variable *const r3E6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3E6C);
               ir_variable *const r3E6D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3E6D);
               ir_variable *const r3E6E = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3E6F = neg(r3E6B);
               body.emit(assign(r3E6E, bit_and(r3E6F, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3E71 = equal(r3E6B, body.constant(int(0)));
               ir_if *f3E70 = new(mem_ctx) ir_if(operand(r3E71).val);
               exec_list *const f3E70_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3E70->then_instructions;

                  body.emit(assign(r3E6C, r3E6A, 0x01));

                  body.emit(assign(r3E6D, r3E69, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3E70->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3E73 = less(r3E6B, body.constant(int(32)));
                  ir_if *f3E72 = new(mem_ctx) ir_if(operand(r3E73).val);
                  exec_list *const f3E72_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3E72->then_instructions;

                     ir_expression *const r3E74 = lshift(swizzle_y(r3D5C), r3E6E);
                     ir_expression *const r3E75 = rshift(r3D66, r3E6B);
                     ir_expression *const r3E76 = bit_or(r3E74, r3E75);
                     ir_expression *const r3E77 = lshift(r3D66, r3E6E);
                     ir_expression *const r3E78 = nequal(r3E77, body.constant(0u));
                     ir_expression *const r3E79 = expr(ir_unop_b2i, r3E78);
                     ir_expression *const r3E7A = expr(ir_unop_i2u, r3E79);
                     body.emit(assign(r3E6C, bit_or(r3E76, r3E7A), 0x01));

                     body.emit(assign(r3E6D, rshift(swizzle_y(r3D5C), r3E6B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3E72->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3E7C = equal(r3E6B, body.constant(int(32)));
                     ir_if *f3E7B = new(mem_ctx) ir_if(operand(r3E7C).val);
                     exec_list *const f3E7B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E7B->then_instructions;

                        ir_expression *const r3E7D = nequal(r3D66, body.constant(0u));
                        ir_expression *const r3E7E = expr(ir_unop_b2i, r3E7D);
                        ir_expression *const r3E7F = expr(ir_unop_i2u, r3E7E);
                        body.emit(assign(r3E6C, bit_or(swizzle_y(r3D5C), r3E7F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3E7B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3E81 = less(r3E6B, body.constant(int(64)));
                        ir_if *f3E80 = new(mem_ctx) ir_if(operand(r3E81).val);
                        exec_list *const f3E80_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E80->then_instructions;

                           ir_expression *const r3E82 = bit_and(r3E6B, body.constant(int(31)));
                           ir_expression *const r3E83 = rshift(swizzle_y(r3D5C), r3E82);
                           ir_expression *const r3E84 = lshift(swizzle_y(r3D5C), r3E6E);
                           ir_expression *const r3E85 = bit_or(r3E84, r3D66);
                           ir_expression *const r3E86 = nequal(r3E85, body.constant(0u));
                           ir_expression *const r3E87 = expr(ir_unop_b2i, r3E86);
                           ir_expression *const r3E88 = expr(ir_unop_i2u, r3E87);
                           body.emit(assign(r3E6C, bit_or(r3E83, r3E88), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E80->else_instructions;

                           ir_expression *const r3E89 = bit_or(swizzle_y(r3D5C), r3D66);
                           ir_expression *const r3E8A = nequal(r3E89, body.constant(0u));
                           ir_expression *const r3E8B = expr(ir_unop_b2i, r3E8A);
                           body.emit(assign(r3E6C, expr(ir_unop_i2u, r3E8B), 0x01));


                        body.instructions = f3E80_parent_instructions;
                        body.emit(f3E80);

                        /* END IF */


                     body.instructions = f3E7B_parent_instructions;
                     body.emit(f3E7B);

                     /* END IF */

                     body.emit(assign(r3E6D, body.constant(0u), 0x01));


                  body.instructions = f3E72_parent_instructions;
                  body.emit(f3E72);

                  /* END IF */


               body.instructions = f3E70_parent_instructions;
               body.emit(f3E70);

               /* END IF */

               body.emit(assign(r3D5C, r3E6D, 0x02));

               body.emit(assign(r3D5C, r3E6C, 0x01));

               body.emit(assign(r3D5A, bit_or(swizzle_y(r3D5A), body.constant(1073741824u)), 0x02));

               ir_variable *const r3E8C = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3E8D = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3E8D, sub(swizzle_x(r3D5A), r3E6C), 0x01));

               ir_expression *const r3E8E = sub(swizzle_y(r3D5A), r3E6D);
               ir_expression *const r3E8F = less(swizzle_x(r3D5A), r3E6C);
               ir_expression *const r3E90 = expr(ir_unop_b2i, r3E8F);
               ir_expression *const r3E91 = expr(ir_unop_i2u, r3E90);
               body.emit(assign(r3E8C, sub(r3E8E, r3E91), 0x01));

               body.emit(assign(r3D56, bit_xor(r3D52, body.constant(1u)), 0x01));

               body.emit(assign(r3D5D, add(r3D63, body.constant(int(-1))), 0x01));

               ir_variable *const r3E92 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3E92, add(r3D5D, body.constant(int(-10))), 0x01));

               ir_variable *const r3E93 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3E93, r3E8C, 0x01));

               ir_variable *const r3E94 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3E94, r3E8D, 0x01));

               ir_variable *const r3E95 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r3E95);
               ir_variable *const r3E96 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3E96);
               /* IF CONDITION */
               ir_expression *const r3E98 = equal(r3E8C, body.constant(0u));
               ir_if *f3E97 = new(mem_ctx) ir_if(operand(r3E98).val);
               exec_list *const f3E97_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3E97->then_instructions;

                  body.emit(assign(r3E93, r3E8D, 0x01));

                  body.emit(assign(r3E94, body.constant(0u), 0x01));

                  body.emit(assign(r3E92, add(r3E92, body.constant(int(-32))), 0x01));


               body.instructions = f3E97_parent_instructions;
               body.emit(f3E97);

               /* END IF */

               ir_variable *const r3E99 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r3E99, r3E93, 0x01));

               ir_variable *const r3E9A = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r3E9B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3E9B);
               /* IF CONDITION */
               ir_expression *const r3E9D = equal(r3E93, body.constant(0u));
               ir_if *f3E9C = new(mem_ctx) ir_if(operand(r3E9D).val);
               exec_list *const f3E9C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3E9C->then_instructions;

                  body.emit(assign(r3E9A, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3E9C->else_instructions;

                  body.emit(assign(r3E9B, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3E9F = bit_and(r3E93, body.constant(4294901760u));
                  ir_expression *const r3EA0 = equal(r3E9F, body.constant(0u));
                  ir_if *f3E9E = new(mem_ctx) ir_if(operand(r3EA0).val);
                  exec_list *const f3E9E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3E9E->then_instructions;

                     body.emit(assign(r3E9B, body.constant(int(16)), 0x01));

                     body.emit(assign(r3E99, lshift(r3E93, body.constant(int(16))), 0x01));


                  body.instructions = f3E9E_parent_instructions;
                  body.emit(f3E9E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3EA2 = bit_and(r3E99, body.constant(4278190080u));
                  ir_expression *const r3EA3 = equal(r3EA2, body.constant(0u));
                  ir_if *f3EA1 = new(mem_ctx) ir_if(operand(r3EA3).val);
                  exec_list *const f3EA1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3EA1->then_instructions;

                     body.emit(assign(r3E9B, add(r3E9B, body.constant(int(8))), 0x01));

                     body.emit(assign(r3E99, lshift(r3E99, body.constant(int(8))), 0x01));


                  body.instructions = f3EA1_parent_instructions;
                  body.emit(f3EA1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3EA5 = bit_and(r3E99, body.constant(4026531840u));
                  ir_expression *const r3EA6 = equal(r3EA5, body.constant(0u));
                  ir_if *f3EA4 = new(mem_ctx) ir_if(operand(r3EA6).val);
                  exec_list *const f3EA4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3EA4->then_instructions;

                     body.emit(assign(r3E9B, add(r3E9B, body.constant(int(4))), 0x01));

                     body.emit(assign(r3E99, lshift(r3E99, body.constant(int(4))), 0x01));


                  body.instructions = f3EA4_parent_instructions;
                  body.emit(f3EA4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3EA8 = bit_and(r3E99, body.constant(3221225472u));
                  ir_expression *const r3EA9 = equal(r3EA8, body.constant(0u));
                  ir_if *f3EA7 = new(mem_ctx) ir_if(operand(r3EA9).val);
                  exec_list *const f3EA7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3EA7->then_instructions;

                     body.emit(assign(r3E9B, add(r3E9B, body.constant(int(2))), 0x01));

                     body.emit(assign(r3E99, lshift(r3E99, body.constant(int(2))), 0x01));


                  body.instructions = f3EA7_parent_instructions;
                  body.emit(f3EA7);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3EAB = bit_and(r3E99, body.constant(2147483648u));
                  ir_expression *const r3EAC = equal(r3EAB, body.constant(0u));
                  ir_if *f3EAA = new(mem_ctx) ir_if(operand(r3EAC).val);
                  exec_list *const f3EAA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3EAA->then_instructions;

                     body.emit(assign(r3E9B, add(r3E9B, body.constant(int(1))), 0x01));


                  body.instructions = f3EAA_parent_instructions;
                  body.emit(f3EAA);

                  /* END IF */

                  body.emit(assign(r3E9A, r3E9B, 0x01));


               body.instructions = f3E9C_parent_instructions;
               body.emit(f3E9C);

               /* END IF */

               body.emit(assign(r3E96, add(r3E9A, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3EAE = lequal(body.constant(int(0)), r3E96);
               ir_if *f3EAD = new(mem_ctx) ir_if(operand(r3EAE).val);
               exec_list *const f3EAD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3EAD->then_instructions;

                  body.emit(assign(r3E95, body.constant(0u), 0x01));

                  ir_variable *const r3EAF = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3EAF, lshift(r3E94, r3E96), 0x01));

                  ir_variable *const r3EB0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3EB2 = equal(r3E96, body.constant(int(0)));
                  ir_if *f3EB1 = new(mem_ctx) ir_if(operand(r3EB2).val);
                  exec_list *const f3EB1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3EB1->then_instructions;

                     body.emit(assign(r3EB0, r3E93, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3EB1->else_instructions;

                     ir_expression *const r3EB3 = lshift(r3E93, r3E96);
                     ir_expression *const r3EB4 = neg(r3E96);
                     ir_expression *const r3EB5 = bit_and(r3EB4, body.constant(int(31)));
                     ir_expression *const r3EB6 = rshift(r3E94, r3EB5);
                     body.emit(assign(r3EB0, bit_or(r3EB3, r3EB6), 0x01));


                  body.instructions = f3EB1_parent_instructions;
                  body.emit(f3EB1);

                  /* END IF */

                  body.emit(assign(r3E93, r3EB0, 0x01));

                  body.emit(assign(r3E94, r3EAF, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3EAD->else_instructions;

                  ir_variable *const r3EB7 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r3EB7, body.constant(0u), 0x01));

                  ir_variable *const r3EB8 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r3EB8, neg(r3E96), 0x01));

                  ir_variable *const r3EB9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3EB9);
                  ir_variable *const r3EBA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3EBA);
                  ir_variable *const r3EBB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3EBB);
                  ir_variable *const r3EBC = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r3EBD = neg(r3EB8);
                  body.emit(assign(r3EBC, bit_and(r3EBD, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3EBF = equal(r3EB8, body.constant(int(0)));
                  ir_if *f3EBE = new(mem_ctx) ir_if(operand(r3EBF).val);
                  exec_list *const f3EBE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3EBE->then_instructions;

                     body.emit(assign(r3EB9, r3EB7, 0x01));

                     body.emit(assign(r3EBA, r3E94, 0x01));

                     body.emit(assign(r3EBB, r3E93, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3EBE->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3EC1 = less(r3EB8, body.constant(int(32)));
                     ir_if *f3EC0 = new(mem_ctx) ir_if(operand(r3EC1).val);
                     exec_list *const f3EC0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3EC0->then_instructions;

                        body.emit(assign(r3EB9, lshift(r3E94, r3EBC), 0x01));

                        ir_expression *const r3EC2 = lshift(r3E93, r3EBC);
                        ir_expression *const r3EC3 = rshift(r3E94, r3EB8);
                        body.emit(assign(r3EBA, bit_or(r3EC2, r3EC3), 0x01));

                        body.emit(assign(r3EBB, rshift(r3E93, r3EB8), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3EC0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3EC5 = equal(r3EB8, body.constant(int(32)));
                        ir_if *f3EC4 = new(mem_ctx) ir_if(operand(r3EC5).val);
                        exec_list *const f3EC4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3EC4->then_instructions;

                           body.emit(assign(r3EB9, r3E94, 0x01));

                           body.emit(assign(r3EBA, r3E93, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3EC4->else_instructions;

                           body.emit(assign(r3EB7, bit_or(body.constant(0u), r3E94), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3EC7 = less(r3EB8, body.constant(int(64)));
                           ir_if *f3EC6 = new(mem_ctx) ir_if(operand(r3EC7).val);
                           exec_list *const f3EC6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EC6->then_instructions;

                              body.emit(assign(r3EB9, lshift(r3E93, r3EBC), 0x01));

                              ir_expression *const r3EC8 = bit_and(r3EB8, body.constant(int(31)));
                              body.emit(assign(r3EBA, rshift(r3E93, r3EC8), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3EC6->else_instructions;

                              ir_variable *const r3EC9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3ECB = equal(r3EB8, body.constant(int(64)));
                              ir_if *f3ECA = new(mem_ctx) ir_if(operand(r3ECB).val);
                              exec_list *const f3ECA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3ECA->then_instructions;

                                 body.emit(assign(r3EC9, r3E93, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3ECA->else_instructions;

                                 ir_expression *const r3ECC = nequal(r3E93, body.constant(0u));
                                 ir_expression *const r3ECD = expr(ir_unop_b2i, r3ECC);
                                 body.emit(assign(r3EC9, expr(ir_unop_i2u, r3ECD), 0x01));


                              body.instructions = f3ECA_parent_instructions;
                              body.emit(f3ECA);

                              /* END IF */

                              body.emit(assign(r3EB9, r3EC9, 0x01));

                              body.emit(assign(r3EBA, body.constant(0u), 0x01));


                           body.instructions = f3EC6_parent_instructions;
                           body.emit(f3EC6);

                           /* END IF */


                        body.instructions = f3EC4_parent_instructions;
                        body.emit(f3EC4);

                        /* END IF */

                        body.emit(assign(r3EBB, body.constant(0u), 0x01));


                     body.instructions = f3EC0_parent_instructions;
                     body.emit(f3EC0);

                     /* END IF */

                     ir_expression *const r3ECE = nequal(r3EB7, body.constant(0u));
                     ir_expression *const r3ECF = expr(ir_unop_b2i, r3ECE);
                     ir_expression *const r3ED0 = expr(ir_unop_i2u, r3ECF);
                     body.emit(assign(r3EB9, bit_or(r3EB9, r3ED0), 0x01));


                  body.instructions = f3EBE_parent_instructions;
                  body.emit(f3EBE);

                  /* END IF */

                  body.emit(assign(r3E93, r3EBB, 0x01));

                  body.emit(assign(r3E94, r3EBA, 0x01));

                  body.emit(assign(r3E95, r3EB9, 0x01));


               body.instructions = f3EAD_parent_instructions;
               body.emit(f3EAD);

               /* END IF */

               body.emit(assign(r3E92, sub(r3E92, r3E96), 0x01));

               ir_variable *const r3ED1 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3ED1, r3E92, 0x01));

               ir_variable *const r3ED2 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3ED2, r3E93, 0x01));

               ir_variable *const r3ED3 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3ED3, r3E94, 0x01));

               ir_variable *const r3ED4 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3ED4, r3E95, 0x01));

               ir_variable *const r3ED5 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3ED5, body.constant(true), 0x01));

               ir_variable *const r3ED6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3ED7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3ED7);
               ir_expression *const r3ED8 = expr(ir_unop_u2i, r3E95);
               body.emit(assign(r3ED7, less(r3ED8, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3EDA = lequal(body.constant(int(2045)), r3E92);
               ir_if *f3ED9 = new(mem_ctx) ir_if(operand(r3EDA).val);
               exec_list *const f3ED9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3ED9->then_instructions;

                  ir_variable *const r3EDB = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3EDD = less(body.constant(int(2045)), r3E92);
                  ir_if *f3EDC = new(mem_ctx) ir_if(operand(r3EDD).val);
                  exec_list *const f3EDC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3EDC->then_instructions;

                     body.emit(assign(r3EDB, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3EDC->else_instructions;

                     ir_variable *const r3EDE = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3EE0 = equal(r3E92, body.constant(int(2045)));
                     ir_if *f3EDF = new(mem_ctx) ir_if(operand(r3EE0).val);
                     exec_list *const f3EDF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3EDF->then_instructions;

                        ir_expression *const r3EE1 = equal(body.constant(2097151u), r3E93);
                        ir_expression *const r3EE2 = equal(body.constant(4294967295u), r3E94);
                        body.emit(assign(r3EDE, logic_and(r3EE1, r3EE2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3EDF->else_instructions;

                        body.emit(assign(r3EDE, body.constant(false), 0x01));


                     body.instructions = f3EDF_parent_instructions;
                     body.emit(f3EDF);

                     /* END IF */

                     body.emit(assign(r3EDB, logic_and(r3EDE, r3ED7), 0x01));


                  body.instructions = f3EDC_parent_instructions;
                  body.emit(f3EDC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3EE3 = new(mem_ctx) ir_if(operand(r3EDB).val);
                  exec_list *const f3EE3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3EE3->then_instructions;

                     ir_variable *const r3EE4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3EE4);
                     ir_expression *const r3EE5 = lshift(r3D56, body.constant(int(31)));
                     body.emit(assign(r3EE4, add(r3EE5, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3EE4, body.constant(0u), 0x01));

                     body.emit(assign(r3ED6, r3EE4, 0x03));

                     body.emit(assign(r3ED5, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3EE3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3EE7 = less(r3E92, body.constant(int(0)));
                     ir_if *f3EE6 = new(mem_ctx) ir_if(operand(r3EE7).val);
                     exec_list *const f3EE6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3EE6->then_instructions;

                        ir_variable *const r3EE8 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3EE8, r3E95, 0x01));

                        ir_variable *const r3EE9 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3EE9, neg(r3E92), 0x01));

                        ir_variable *const r3EEA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3EEA);
                        ir_variable *const r3EEB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3EEB);
                        ir_variable *const r3EEC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3EEC);
                        ir_variable *const r3EED = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3EEE = neg(r3EE9);
                        body.emit(assign(r3EED, bit_and(r3EEE, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3EF0 = equal(r3EE9, body.constant(int(0)));
                        ir_if *f3EEF = new(mem_ctx) ir_if(operand(r3EF0).val);
                        exec_list *const f3EEF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3EEF->then_instructions;

                           body.emit(assign(r3EEA, r3E95, 0x01));

                           body.emit(assign(r3EEB, r3E94, 0x01));

                           body.emit(assign(r3EEC, r3E93, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3EEF->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3EF2 = less(r3EE9, body.constant(int(32)));
                           ir_if *f3EF1 = new(mem_ctx) ir_if(operand(r3EF2).val);
                           exec_list *const f3EF1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EF1->then_instructions;

                              body.emit(assign(r3EEA, lshift(r3E94, r3EED), 0x01));

                              ir_expression *const r3EF3 = lshift(r3E93, r3EED);
                              ir_expression *const r3EF4 = rshift(r3E94, r3EE9);
                              body.emit(assign(r3EEB, bit_or(r3EF3, r3EF4), 0x01));

                              body.emit(assign(r3EEC, rshift(r3E93, r3EE9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3EF1->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3EF6 = equal(r3EE9, body.constant(int(32)));
                              ir_if *f3EF5 = new(mem_ctx) ir_if(operand(r3EF6).val);
                              exec_list *const f3EF5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3EF5->then_instructions;

                                 body.emit(assign(r3EEA, r3E94, 0x01));

                                 body.emit(assign(r3EEB, r3E93, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3EF5->else_instructions;

                                 body.emit(assign(r3EE8, bit_or(r3E95, r3E94), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3EF8 = less(r3EE9, body.constant(int(64)));
                                 ir_if *f3EF7 = new(mem_ctx) ir_if(operand(r3EF8).val);
                                 exec_list *const f3EF7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3EF7->then_instructions;

                                    body.emit(assign(r3EEA, lshift(r3E93, r3EED), 0x01));

                                    ir_expression *const r3EF9 = bit_and(r3EE9, body.constant(int(31)));
                                    body.emit(assign(r3EEB, rshift(r3E93, r3EF9), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3EF7->else_instructions;

                                    ir_variable *const r3EFA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3EFC = equal(r3EE9, body.constant(int(64)));
                                    ir_if *f3EFB = new(mem_ctx) ir_if(operand(r3EFC).val);
                                    exec_list *const f3EFB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3EFB->then_instructions;

                                       body.emit(assign(r3EFA, r3E93, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3EFB->else_instructions;

                                       ir_expression *const r3EFD = nequal(r3E93, body.constant(0u));
                                       ir_expression *const r3EFE = expr(ir_unop_b2i, r3EFD);
                                       body.emit(assign(r3EFA, expr(ir_unop_i2u, r3EFE), 0x01));


                                    body.instructions = f3EFB_parent_instructions;
                                    body.emit(f3EFB);

                                    /* END IF */

                                    body.emit(assign(r3EEA, r3EFA, 0x01));

                                    body.emit(assign(r3EEB, body.constant(0u), 0x01));


                                 body.instructions = f3EF7_parent_instructions;
                                 body.emit(f3EF7);

                                 /* END IF */


                              body.instructions = f3EF5_parent_instructions;
                              body.emit(f3EF5);

                              /* END IF */

                              body.emit(assign(r3EEC, body.constant(0u), 0x01));


                           body.instructions = f3EF1_parent_instructions;
                           body.emit(f3EF1);

                           /* END IF */

                           ir_expression *const r3EFF = nequal(r3EE8, body.constant(0u));
                           ir_expression *const r3F00 = expr(ir_unop_b2i, r3EFF);
                           ir_expression *const r3F01 = expr(ir_unop_i2u, r3F00);
                           body.emit(assign(r3EEA, bit_or(r3EEA, r3F01), 0x01));


                        body.instructions = f3EEF_parent_instructions;
                        body.emit(f3EEF);

                        /* END IF */

                        body.emit(assign(r3ED2, r3EEC, 0x01));

                        body.emit(assign(r3ED3, r3EEB, 0x01));

                        body.emit(assign(r3ED4, r3EEA, 0x01));

                        body.emit(assign(r3ED1, body.constant(int(0)), 0x01));

                        body.emit(assign(r3ED7, less(r3EEA, body.constant(0u)), 0x01));


                     body.instructions = f3EE6_parent_instructions;
                     body.emit(f3EE6);

                     /* END IF */


                  body.instructions = f3EE3_parent_instructions;
                  body.emit(f3EE3);

                  /* END IF */


               body.instructions = f3ED9_parent_instructions;
               body.emit(f3ED9);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3F02 = new(mem_ctx) ir_if(operand(r3ED5).val);
               exec_list *const f3F02_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3F02->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3F03 = new(mem_ctx) ir_if(operand(r3ED7).val);
                  exec_list *const f3F03_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3F03->then_instructions;

                     ir_variable *const r3F04 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3F04, add(r3ED3, body.constant(1u)), 0x01));

                     ir_expression *const r3F05 = less(r3F04, r3ED3);
                     ir_expression *const r3F06 = expr(ir_unop_b2i, r3F05);
                     ir_expression *const r3F07 = expr(ir_unop_i2u, r3F06);
                     body.emit(assign(r3ED2, add(r3ED2, r3F07), 0x01));

                     ir_expression *const r3F08 = equal(r3ED4, body.constant(0u));
                     ir_expression *const r3F09 = expr(ir_unop_b2i, r3F08);
                     ir_expression *const r3F0A = expr(ir_unop_i2u, r3F09);
                     ir_expression *const r3F0B = add(r3ED4, r3F0A);
                     ir_expression *const r3F0C = bit_and(r3F0B, body.constant(1u));
                     ir_expression *const r3F0D = expr(ir_unop_bit_not, r3F0C);
                     body.emit(assign(r3ED3, bit_and(r3F04, r3F0D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3F03->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3F0F = bit_or(r3ED2, r3ED3);
                     ir_expression *const r3F10 = equal(r3F0F, body.constant(0u));
                     ir_if *f3F0E = new(mem_ctx) ir_if(operand(r3F10).val);
                     exec_list *const f3F0E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3F0E->then_instructions;

                        body.emit(assign(r3ED1, body.constant(int(0)), 0x01));


                     body.instructions = f3F0E_parent_instructions;
                     body.emit(f3F0E);

                     /* END IF */


                  body.instructions = f3F03_parent_instructions;
                  body.emit(f3F03);

                  /* END IF */

                  ir_variable *const r3F11 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3F11);
                  ir_expression *const r3F12 = lshift(r3D56, body.constant(int(31)));
                  ir_expression *const r3F13 = expr(ir_unop_i2u, r3ED1);
                  ir_expression *const r3F14 = lshift(r3F13, body.constant(int(20)));
                  ir_expression *const r3F15 = add(r3F12, r3F14);
                  body.emit(assign(r3F11, add(r3F15, r3ED2), 0x02));

                  body.emit(assign(r3F11, r3ED3, 0x01));

                  body.emit(assign(r3ED6, r3F11, 0x03));

                  body.emit(assign(r3ED5, body.constant(false), 0x01));


               body.instructions = f3F02_parent_instructions;
               body.emit(f3F02);

               /* END IF */

               body.emit(assign(r3D57, r3ED6, 0x03));


            body.instructions = f3E42_parent_instructions;
            body.emit(f3E42);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3E40->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3F17 = equal(r3D5F, body.constant(int(2047)));
            ir_if *f3F16 = new(mem_ctx) ir_if(operand(r3F17).val);
            exec_list *const f3F16_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3F16->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3F19 = bit_or(swizzle_y(r3D5C), swizzle_x(r3D5C));
               ir_expression *const r3F1A = bit_or(swizzle_y(r3D5A), swizzle_x(r3D5A));
               ir_expression *const r3F1B = bit_or(r3F19, r3F1A);
               ir_expression *const r3F1C = nequal(r3F1B, body.constant(0u));
               ir_if *f3F18 = new(mem_ctx) ir_if(operand(r3F1C).val);
               exec_list *const f3F18_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3F18->then_instructions;

                  ir_variable *const r3F1D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r3F1D, swizzle_x(r33DD), 0x01));

                  ir_variable *const r3F1E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r3F1E, swizzle_x(r3B9F), 0x01));

                  ir_variable *const r3F1F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3F20 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r3F21 = rshift(swizzle_y(r33DD), body.constant(int(19)));
                  ir_expression *const r3F22 = bit_and(r3F21, body.constant(4095u));
                  ir_expression *const r3F23 = equal(r3F22, body.constant(4094u));
                  ir_expression *const r3F24 = nequal(swizzle_x(r33DD), body.constant(0u));
                  ir_expression *const r3F25 = bit_and(swizzle_y(r33DD), body.constant(524287u));
                  ir_expression *const r3F26 = nequal(r3F25, body.constant(0u));
                  ir_expression *const r3F27 = logic_or(r3F24, r3F26);
                  body.emit(assign(r3F20, logic_and(r3F23, r3F27), 0x01));

                  ir_variable *const r3F28 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r3F29 = lshift(swizzle_y(r3B9F), body.constant(int(1)));
                  ir_expression *const r3F2A = lequal(body.constant(4292870144u), r3F29);
                  ir_expression *const r3F2B = nequal(swizzle_x(r3B9F), body.constant(0u));
                  ir_expression *const r3F2C = bit_and(swizzle_y(r3B9F), body.constant(1048575u));
                  ir_expression *const r3F2D = nequal(r3F2C, body.constant(0u));
                  ir_expression *const r3F2E = logic_or(r3F2B, r3F2D);
                  body.emit(assign(r3F28, logic_and(r3F2A, r3F2E), 0x01));

                  body.emit(assign(r3F1D, bit_or(swizzle_y(r33DD), body.constant(524288u)), 0x02));

                  body.emit(assign(r3F1E, bit_or(swizzle_y(r3B9F), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3F30 = lshift(swizzle_y(r33DD), body.constant(int(1)));
                  ir_expression *const r3F31 = lequal(body.constant(4292870144u), r3F30);
                  ir_expression *const r3F32 = nequal(swizzle_x(r33DD), body.constant(0u));
                  ir_expression *const r3F33 = bit_and(swizzle_y(r33DD), body.constant(1048575u));
                  ir_expression *const r3F34 = nequal(r3F33, body.constant(0u));
                  ir_expression *const r3F35 = logic_or(r3F32, r3F34);
                  ir_expression *const r3F36 = logic_and(r3F31, r3F35);
                  ir_if *f3F2F = new(mem_ctx) ir_if(operand(r3F36).val);
                  exec_list *const f3F2F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3F2F->then_instructions;

                     ir_variable *const r3F37 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3F39 = logic_and(r3F20, r3F28);
                     ir_if *f3F38 = new(mem_ctx) ir_if(operand(r3F39).val);
                     exec_list *const f3F38_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3F38->then_instructions;

                        body.emit(assign(r3F37, r3F1E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3F38->else_instructions;

                        body.emit(assign(r3F37, r3F1D, 0x03));


                     body.instructions = f3F38_parent_instructions;
                     body.emit(f3F38);

                     /* END IF */

                     body.emit(assign(r3F1F, r3F37, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3F2F->else_instructions;

                     body.emit(assign(r3F1F, r3F1E, 0x03));


                  body.instructions = f3F2F_parent_instructions;
                  body.emit(f3F2F);

                  /* END IF */

                  body.emit(assign(r3D57, r3F1F, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3F18->else_instructions;

                  ir_constant_data r3F3A_data;
                  memset(&r3F3A_data, 0, sizeof(ir_constant_data));
                  r3F3A_data.u[0] = 4294967295;
                  r3F3A_data.u[1] = 4294967295;
                  ir_constant *const r3F3A = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3F3A_data);
                  body.emit(assign(r3D57, r3F3A, 0x03));


               body.instructions = f3F18_parent_instructions;
               body.emit(f3F18);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3F16->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3F3C = equal(r3D5F, body.constant(int(0)));
               ir_if *f3F3B = new(mem_ctx) ir_if(operand(r3F3C).val);
               exec_list *const f3F3B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3F3B->then_instructions;

                  body.emit(assign(r3D5B, body.constant(int(1)), 0x01));

                  body.emit(assign(r3D59, body.constant(int(1)), 0x01));


               body.instructions = f3F3B_parent_instructions;
               body.emit(f3F3B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3F3E = less(swizzle_y(r3D5A), swizzle_y(r3D5C));
               ir_if *f3F3D = new(mem_ctx) ir_if(operand(r3F3E).val);
               exec_list *const f3F3D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3F3D->then_instructions;

                  ir_variable *const r3F3F = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r3F40 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3F40, sub(swizzle_x(r3D5C), swizzle_x(r3D5A)), 0x01));

                  ir_expression *const r3F41 = sub(swizzle_y(r3D5C), swizzle_y(r3D5A));
                  ir_expression *const r3F42 = less(swizzle_x(r3D5C), swizzle_x(r3D5A));
                  ir_expression *const r3F43 = expr(ir_unop_b2i, r3F42);
                  ir_expression *const r3F44 = expr(ir_unop_i2u, r3F43);
                  body.emit(assign(r3F3F, sub(r3F41, r3F44), 0x01));

                  body.emit(assign(r3D5D, add(r3D5B, body.constant(int(-1))), 0x01));

                  ir_variable *const r3F45 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r3F45, add(r3D5D, body.constant(int(-10))), 0x01));

                  ir_variable *const r3F46 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r3F46, r3F3F, 0x01));

                  ir_variable *const r3F47 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3F47, r3F40, 0x01));

                  ir_variable *const r3F48 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r3F48);
                  ir_variable *const r3F49 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3F49);
                  /* IF CONDITION */
                  ir_expression *const r3F4B = equal(r3F3F, body.constant(0u));
                  ir_if *f3F4A = new(mem_ctx) ir_if(operand(r3F4B).val);
                  exec_list *const f3F4A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3F4A->then_instructions;

                     body.emit(assign(r3F46, r3F40, 0x01));

                     body.emit(assign(r3F47, body.constant(0u), 0x01));

                     body.emit(assign(r3F45, add(r3F45, body.constant(int(-32))), 0x01));


                  body.instructions = f3F4A_parent_instructions;
                  body.emit(f3F4A);

                  /* END IF */

                  ir_variable *const r3F4C = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3F4C, r3F46, 0x01));

                  ir_variable *const r3F4D = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3F4E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3F4E);
                  /* IF CONDITION */
                  ir_expression *const r3F50 = equal(r3F46, body.constant(0u));
                  ir_if *f3F4F = new(mem_ctx) ir_if(operand(r3F50).val);
                  exec_list *const f3F4F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3F4F->then_instructions;

                     body.emit(assign(r3F4D, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3F4F->else_instructions;

                     body.emit(assign(r3F4E, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3F52 = bit_and(r3F46, body.constant(4294901760u));
                     ir_expression *const r3F53 = equal(r3F52, body.constant(0u));
                     ir_if *f3F51 = new(mem_ctx) ir_if(operand(r3F53).val);
                     exec_list *const f3F51_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3F51->then_instructions;

                        body.emit(assign(r3F4E, body.constant(int(16)), 0x01));

                        body.emit(assign(r3F4C, lshift(r3F46, body.constant(int(16))), 0x01));


                     body.instructions = f3F51_parent_instructions;
                     body.emit(f3F51);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3F55 = bit_and(r3F4C, body.constant(4278190080u));
                     ir_expression *const r3F56 = equal(r3F55, body.constant(0u));
                     ir_if *f3F54 = new(mem_ctx) ir_if(operand(r3F56).val);
                     exec_list *const f3F54_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3F54->then_instructions;

                        body.emit(assign(r3F4E, add(r3F4E, body.constant(int(8))), 0x01));

                        body.emit(assign(r3F4C, lshift(r3F4C, body.constant(int(8))), 0x01));


                     body.instructions = f3F54_parent_instructions;
                     body.emit(f3F54);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3F58 = bit_and(r3F4C, body.constant(4026531840u));
                     ir_expression *const r3F59 = equal(r3F58, body.constant(0u));
                     ir_if *f3F57 = new(mem_ctx) ir_if(operand(r3F59).val);
                     exec_list *const f3F57_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3F57->then_instructions;

                        body.emit(assign(r3F4E, add(r3F4E, body.constant(int(4))), 0x01));

                        body.emit(assign(r3F4C, lshift(r3F4C, body.constant(int(4))), 0x01));


                     body.instructions = f3F57_parent_instructions;
                     body.emit(f3F57);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3F5B = bit_and(r3F4C, body.constant(3221225472u));
                     ir_expression *const r3F5C = equal(r3F5B, body.constant(0u));
                     ir_if *f3F5A = new(mem_ctx) ir_if(operand(r3F5C).val);
                     exec_list *const f3F5A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3F5A->then_instructions;

                        body.emit(assign(r3F4E, add(r3F4E, body.constant(int(2))), 0x01));

                        body.emit(assign(r3F4C, lshift(r3F4C, body.constant(int(2))), 0x01));


                     body.instructions = f3F5A_parent_instructions;
                     body.emit(f3F5A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3F5E = bit_and(r3F4C, body.constant(2147483648u));
                     ir_expression *const r3F5F = equal(r3F5E, body.constant(0u));
                     ir_if *f3F5D = new(mem_ctx) ir_if(operand(r3F5F).val);
                     exec_list *const f3F5D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3F5D->then_instructions;

                        body.emit(assign(r3F4E, add(r3F4E, body.constant(int(1))), 0x01));


                     body.instructions = f3F5D_parent_instructions;
                     body.emit(f3F5D);

                     /* END IF */

                     body.emit(assign(r3F4D, r3F4E, 0x01));


                  body.instructions = f3F4F_parent_instructions;
                  body.emit(f3F4F);

                  /* END IF */

                  body.emit(assign(r3F49, add(r3F4D, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3F61 = lequal(body.constant(int(0)), r3F49);
                  ir_if *f3F60 = new(mem_ctx) ir_if(operand(r3F61).val);
                  exec_list *const f3F60_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3F60->then_instructions;

                     body.emit(assign(r3F48, body.constant(0u), 0x01));

                     ir_variable *const r3F62 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3F62, lshift(r3F47, r3F49), 0x01));

                     ir_variable *const r3F63 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3F65 = equal(r3F49, body.constant(int(0)));
                     ir_if *f3F64 = new(mem_ctx) ir_if(operand(r3F65).val);
                     exec_list *const f3F64_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3F64->then_instructions;

                        body.emit(assign(r3F63, r3F46, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3F64->else_instructions;

                        ir_expression *const r3F66 = lshift(r3F46, r3F49);
                        ir_expression *const r3F67 = neg(r3F49);
                        ir_expression *const r3F68 = bit_and(r3F67, body.constant(int(31)));
                        ir_expression *const r3F69 = rshift(r3F47, r3F68);
                        body.emit(assign(r3F63, bit_or(r3F66, r3F69), 0x01));


                     body.instructions = f3F64_parent_instructions;
                     body.emit(f3F64);

                     /* END IF */

                     body.emit(assign(r3F46, r3F63, 0x01));

                     body.emit(assign(r3F47, r3F62, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3F60->else_instructions;

                     ir_variable *const r3F6A = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3F6A, body.constant(0u), 0x01));

                     ir_variable *const r3F6B = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3F6B, neg(r3F49), 0x01));

                     ir_variable *const r3F6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3F6C);
                     ir_variable *const r3F6D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3F6D);
                     ir_variable *const r3F6E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3F6E);
                     ir_variable *const r3F6F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r3F70 = neg(r3F6B);
                     body.emit(assign(r3F6F, bit_and(r3F70, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3F72 = equal(r3F6B, body.constant(int(0)));
                     ir_if *f3F71 = new(mem_ctx) ir_if(operand(r3F72).val);
                     exec_list *const f3F71_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3F71->then_instructions;

                        body.emit(assign(r3F6C, r3F6A, 0x01));

                        body.emit(assign(r3F6D, r3F47, 0x01));

                        body.emit(assign(r3F6E, r3F46, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3F71->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3F74 = less(r3F6B, body.constant(int(32)));
                        ir_if *f3F73 = new(mem_ctx) ir_if(operand(r3F74).val);
                        exec_list *const f3F73_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3F73->then_instructions;

                           body.emit(assign(r3F6C, lshift(r3F47, r3F6F), 0x01));

                           ir_expression *const r3F75 = lshift(r3F46, r3F6F);
                           ir_expression *const r3F76 = rshift(r3F47, r3F6B);
                           body.emit(assign(r3F6D, bit_or(r3F75, r3F76), 0x01));

                           body.emit(assign(r3F6E, rshift(r3F46, r3F6B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3F73->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3F78 = equal(r3F6B, body.constant(int(32)));
                           ir_if *f3F77 = new(mem_ctx) ir_if(operand(r3F78).val);
                           exec_list *const f3F77_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F77->then_instructions;

                              body.emit(assign(r3F6C, r3F47, 0x01));

                              body.emit(assign(r3F6D, r3F46, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3F77->else_instructions;

                              body.emit(assign(r3F6A, bit_or(body.constant(0u), r3F47), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3F7A = less(r3F6B, body.constant(int(64)));
                              ir_if *f3F79 = new(mem_ctx) ir_if(operand(r3F7A).val);
                              exec_list *const f3F79_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F79->then_instructions;

                                 body.emit(assign(r3F6C, lshift(r3F46, r3F6F), 0x01));

                                 ir_expression *const r3F7B = bit_and(r3F6B, body.constant(int(31)));
                                 body.emit(assign(r3F6D, rshift(r3F46, r3F7B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F79->else_instructions;

                                 ir_variable *const r3F7C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3F7E = equal(r3F6B, body.constant(int(64)));
                                 ir_if *f3F7D = new(mem_ctx) ir_if(operand(r3F7E).val);
                                 exec_list *const f3F7D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3F7D->then_instructions;

                                    body.emit(assign(r3F7C, r3F46, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3F7D->else_instructions;

                                    ir_expression *const r3F7F = nequal(r3F46, body.constant(0u));
                                    ir_expression *const r3F80 = expr(ir_unop_b2i, r3F7F);
                                    body.emit(assign(r3F7C, expr(ir_unop_i2u, r3F80), 0x01));


                                 body.instructions = f3F7D_parent_instructions;
                                 body.emit(f3F7D);

                                 /* END IF */

                                 body.emit(assign(r3F6C, r3F7C, 0x01));

                                 body.emit(assign(r3F6D, body.constant(0u), 0x01));


                              body.instructions = f3F79_parent_instructions;
                              body.emit(f3F79);

                              /* END IF */


                           body.instructions = f3F77_parent_instructions;
                           body.emit(f3F77);

                           /* END IF */

                           body.emit(assign(r3F6E, body.constant(0u), 0x01));


                        body.instructions = f3F73_parent_instructions;
                        body.emit(f3F73);

                        /* END IF */

                        ir_expression *const r3F81 = nequal(r3F6A, body.constant(0u));
                        ir_expression *const r3F82 = expr(ir_unop_b2i, r3F81);
                        ir_expression *const r3F83 = expr(ir_unop_i2u, r3F82);
                        body.emit(assign(r3F6C, bit_or(r3F6C, r3F83), 0x01));


                     body.instructions = f3F71_parent_instructions;
                     body.emit(f3F71);

                     /* END IF */

                     body.emit(assign(r3F46, r3F6E, 0x01));

                     body.emit(assign(r3F47, r3F6D, 0x01));

                     body.emit(assign(r3F48, r3F6C, 0x01));


                  body.instructions = f3F60_parent_instructions;
                  body.emit(f3F60);

                  /* END IF */

                  body.emit(assign(r3F45, sub(r3F45, r3F49), 0x01));

                  ir_variable *const r3F84 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r3F84, r3F45, 0x01));

                  ir_variable *const r3F85 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r3F85, r3F46, 0x01));

                  ir_variable *const r3F86 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3F86, r3F47, 0x01));

                  ir_variable *const r3F87 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r3F87, r3F48, 0x01));

                  ir_variable *const r3F88 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r3F88, body.constant(true), 0x01));

                  ir_variable *const r3F89 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3F8A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r3F8A);
                  ir_expression *const r3F8B = expr(ir_unop_u2i, r3F48);
                  body.emit(assign(r3F8A, less(r3F8B, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3F8D = lequal(body.constant(int(2045)), r3F45);
                  ir_if *f3F8C = new(mem_ctx) ir_if(operand(r3F8D).val);
                  exec_list *const f3F8C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3F8C->then_instructions;

                     ir_variable *const r3F8E = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3F90 = less(body.constant(int(2045)), r3F45);
                     ir_if *f3F8F = new(mem_ctx) ir_if(operand(r3F90).val);
                     exec_list *const f3F8F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3F8F->then_instructions;

                        body.emit(assign(r3F8E, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3F8F->else_instructions;

                        ir_variable *const r3F91 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3F93 = equal(r3F45, body.constant(int(2045)));
                        ir_if *f3F92 = new(mem_ctx) ir_if(operand(r3F93).val);
                        exec_list *const f3F92_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3F92->then_instructions;

                           ir_expression *const r3F94 = equal(body.constant(2097151u), r3F46);
                           ir_expression *const r3F95 = equal(body.constant(4294967295u), r3F47);
                           body.emit(assign(r3F91, logic_and(r3F94, r3F95), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3F92->else_instructions;

                           body.emit(assign(r3F91, body.constant(false), 0x01));


                        body.instructions = f3F92_parent_instructions;
                        body.emit(f3F92);

                        /* END IF */

                        body.emit(assign(r3F8E, logic_and(r3F91, r3F8A), 0x01));


                     body.instructions = f3F8F_parent_instructions;
                     body.emit(f3F8F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3F96 = new(mem_ctx) ir_if(operand(r3F8E).val);
                     exec_list *const f3F96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3F96->then_instructions;

                        ir_variable *const r3F97 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3F97);
                        ir_expression *const r3F98 = lshift(r3D56, body.constant(int(31)));
                        body.emit(assign(r3F97, add(r3F98, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r3F97, body.constant(0u), 0x01));

                        body.emit(assign(r3F89, r3F97, 0x03));

                        body.emit(assign(r3F88, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3F96->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3F9A = less(r3F45, body.constant(int(0)));
                        ir_if *f3F99 = new(mem_ctx) ir_if(operand(r3F9A).val);
                        exec_list *const f3F99_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3F99->then_instructions;

                           ir_variable *const r3F9B = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3F9B, r3F48, 0x01));

                           ir_variable *const r3F9C = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3F9C, neg(r3F45), 0x01));

                           ir_variable *const r3F9D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3F9D);
                           ir_variable *const r3F9E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3F9E);
                           ir_variable *const r3F9F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3F9F);
                           ir_variable *const r3FA0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3FA1 = neg(r3F9C);
                           body.emit(assign(r3FA0, bit_and(r3FA1, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3FA3 = equal(r3F9C, body.constant(int(0)));
                           ir_if *f3FA2 = new(mem_ctx) ir_if(operand(r3FA3).val);
                           exec_list *const f3FA2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3FA2->then_instructions;

                              body.emit(assign(r3F9D, r3F48, 0x01));

                              body.emit(assign(r3F9E, r3F47, 0x01));

                              body.emit(assign(r3F9F, r3F46, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3FA2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3FA5 = less(r3F9C, body.constant(int(32)));
                              ir_if *f3FA4 = new(mem_ctx) ir_if(operand(r3FA5).val);
                              exec_list *const f3FA4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3FA4->then_instructions;

                                 body.emit(assign(r3F9D, lshift(r3F47, r3FA0), 0x01));

                                 ir_expression *const r3FA6 = lshift(r3F46, r3FA0);
                                 ir_expression *const r3FA7 = rshift(r3F47, r3F9C);
                                 body.emit(assign(r3F9E, bit_or(r3FA6, r3FA7), 0x01));

                                 body.emit(assign(r3F9F, rshift(r3F46, r3F9C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3FA4->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3FA9 = equal(r3F9C, body.constant(int(32)));
                                 ir_if *f3FA8 = new(mem_ctx) ir_if(operand(r3FA9).val);
                                 exec_list *const f3FA8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3FA8->then_instructions;

                                    body.emit(assign(r3F9D, r3F47, 0x01));

                                    body.emit(assign(r3F9E, r3F46, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3FA8->else_instructions;

                                    body.emit(assign(r3F9B, bit_or(r3F48, r3F47), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3FAB = less(r3F9C, body.constant(int(64)));
                                    ir_if *f3FAA = new(mem_ctx) ir_if(operand(r3FAB).val);
                                    exec_list *const f3FAA_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3FAA->then_instructions;

                                       body.emit(assign(r3F9D, lshift(r3F46, r3FA0), 0x01));

                                       ir_expression *const r3FAC = bit_and(r3F9C, body.constant(int(31)));
                                       body.emit(assign(r3F9E, rshift(r3F46, r3FAC), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3FAA->else_instructions;

                                       ir_variable *const r3FAD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3FAF = equal(r3F9C, body.constant(int(64)));
                                       ir_if *f3FAE = new(mem_ctx) ir_if(operand(r3FAF).val);
                                       exec_list *const f3FAE_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3FAE->then_instructions;

                                          body.emit(assign(r3FAD, r3F46, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3FAE->else_instructions;

                                          ir_expression *const r3FB0 = nequal(r3F46, body.constant(0u));
                                          ir_expression *const r3FB1 = expr(ir_unop_b2i, r3FB0);
                                          body.emit(assign(r3FAD, expr(ir_unop_i2u, r3FB1), 0x01));


                                       body.instructions = f3FAE_parent_instructions;
                                       body.emit(f3FAE);

                                       /* END IF */

                                       body.emit(assign(r3F9D, r3FAD, 0x01));

                                       body.emit(assign(r3F9E, body.constant(0u), 0x01));


                                    body.instructions = f3FAA_parent_instructions;
                                    body.emit(f3FAA);

                                    /* END IF */


                                 body.instructions = f3FA8_parent_instructions;
                                 body.emit(f3FA8);

                                 /* END IF */

                                 body.emit(assign(r3F9F, body.constant(0u), 0x01));


                              body.instructions = f3FA4_parent_instructions;
                              body.emit(f3FA4);

                              /* END IF */

                              ir_expression *const r3FB2 = nequal(r3F9B, body.constant(0u));
                              ir_expression *const r3FB3 = expr(ir_unop_b2i, r3FB2);
                              ir_expression *const r3FB4 = expr(ir_unop_i2u, r3FB3);
                              body.emit(assign(r3F9D, bit_or(r3F9D, r3FB4), 0x01));


                           body.instructions = f3FA2_parent_instructions;
                           body.emit(f3FA2);

                           /* END IF */

                           body.emit(assign(r3F85, r3F9F, 0x01));

                           body.emit(assign(r3F86, r3F9E, 0x01));

                           body.emit(assign(r3F87, r3F9D, 0x01));

                           body.emit(assign(r3F84, body.constant(int(0)), 0x01));

                           body.emit(assign(r3F8A, less(r3F9D, body.constant(0u)), 0x01));


                        body.instructions = f3F99_parent_instructions;
                        body.emit(f3F99);

                        /* END IF */


                     body.instructions = f3F96_parent_instructions;
                     body.emit(f3F96);

                     /* END IF */


                  body.instructions = f3F8C_parent_instructions;
                  body.emit(f3F8C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3FB5 = new(mem_ctx) ir_if(operand(r3F88).val);
                  exec_list *const f3FB5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3FB5->then_instructions;

                     /* IF CONDITION */
                     ir_if *f3FB6 = new(mem_ctx) ir_if(operand(r3F8A).val);
                     exec_list *const f3FB6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3FB6->then_instructions;

                        ir_variable *const r3FB7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r3FB7, add(r3F86, body.constant(1u)), 0x01));

                        ir_expression *const r3FB8 = less(r3FB7, r3F86);
                        ir_expression *const r3FB9 = expr(ir_unop_b2i, r3FB8);
                        ir_expression *const r3FBA = expr(ir_unop_i2u, r3FB9);
                        body.emit(assign(r3F85, add(r3F85, r3FBA), 0x01));

                        ir_expression *const r3FBB = equal(r3F87, body.constant(0u));
                        ir_expression *const r3FBC = expr(ir_unop_b2i, r3FBB);
                        ir_expression *const r3FBD = expr(ir_unop_i2u, r3FBC);
                        ir_expression *const r3FBE = add(r3F87, r3FBD);
                        ir_expression *const r3FBF = bit_and(r3FBE, body.constant(1u));
                        ir_expression *const r3FC0 = expr(ir_unop_bit_not, r3FBF);
                        body.emit(assign(r3F86, bit_and(r3FB7, r3FC0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3FB6->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3FC2 = bit_or(r3F85, r3F86);
                        ir_expression *const r3FC3 = equal(r3FC2, body.constant(0u));
                        ir_if *f3FC1 = new(mem_ctx) ir_if(operand(r3FC3).val);
                        exec_list *const f3FC1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3FC1->then_instructions;

                           body.emit(assign(r3F84, body.constant(int(0)), 0x01));


                        body.instructions = f3FC1_parent_instructions;
                        body.emit(f3FC1);

                        /* END IF */


                     body.instructions = f3FB6_parent_instructions;
                     body.emit(f3FB6);

                     /* END IF */

                     ir_variable *const r3FC4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3FC4);
                     ir_expression *const r3FC5 = lshift(r3D56, body.constant(int(31)));
                     ir_expression *const r3FC6 = expr(ir_unop_i2u, r3F84);
                     ir_expression *const r3FC7 = lshift(r3FC6, body.constant(int(20)));
                     ir_expression *const r3FC8 = add(r3FC5, r3FC7);
                     body.emit(assign(r3FC4, add(r3FC8, r3F85), 0x02));

                     body.emit(assign(r3FC4, r3F86, 0x01));

                     body.emit(assign(r3F89, r3FC4, 0x03));

                     body.emit(assign(r3F88, body.constant(false), 0x01));


                  body.instructions = f3FB5_parent_instructions;
                  body.emit(f3FB5);

                  /* END IF */

                  body.emit(assign(r3D57, r3F89, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3F3D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3FCA = less(swizzle_y(r3D5C), swizzle_y(r3D5A));
                  ir_if *f3FC9 = new(mem_ctx) ir_if(operand(r3FCA).val);
                  exec_list *const f3FC9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3FC9->then_instructions;

                     ir_variable *const r3FCB = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r3FCC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3FCC, sub(swizzle_x(r3D5A), swizzle_x(r3D5C)), 0x01));

                     ir_expression *const r3FCD = sub(swizzle_y(r3D5A), swizzle_y(r3D5C));
                     ir_expression *const r3FCE = less(swizzle_x(r3D5A), swizzle_x(r3D5C));
                     ir_expression *const r3FCF = expr(ir_unop_b2i, r3FCE);
                     ir_expression *const r3FD0 = expr(ir_unop_i2u, r3FCF);
                     body.emit(assign(r3FCB, sub(r3FCD, r3FD0), 0x01));

                     body.emit(assign(r3D56, bit_xor(r3D56, body.constant(1u)), 0x01));

                     body.emit(assign(r3D5D, add(r3D59, body.constant(int(-1))), 0x01));

                     ir_variable *const r3FD1 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3FD1, add(r3D5D, body.constant(int(-10))), 0x01));

                     ir_variable *const r3FD2 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r3FD2, r3FCB, 0x01));

                     ir_variable *const r3FD3 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r3FD3, r3FCC, 0x01));

                     ir_variable *const r3FD4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r3FD4);
                     ir_variable *const r3FD5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3FD5);
                     /* IF CONDITION */
                     ir_expression *const r3FD7 = equal(r3FCB, body.constant(0u));
                     ir_if *f3FD6 = new(mem_ctx) ir_if(operand(r3FD7).val);
                     exec_list *const f3FD6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3FD6->then_instructions;

                        body.emit(assign(r3FD2, r3FCC, 0x01));

                        body.emit(assign(r3FD3, body.constant(0u), 0x01));

                        body.emit(assign(r3FD1, add(r3FD1, body.constant(int(-32))), 0x01));


                     body.instructions = f3FD6_parent_instructions;
                     body.emit(f3FD6);

                     /* END IF */

                     ir_variable *const r3FD8 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3FD8, r3FD2, 0x01));

                     ir_variable *const r3FD9 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3FDA = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3FDA);
                     /* IF CONDITION */
                     ir_expression *const r3FDC = equal(r3FD2, body.constant(0u));
                     ir_if *f3FDB = new(mem_ctx) ir_if(operand(r3FDC).val);
                     exec_list *const f3FDB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3FDB->then_instructions;

                        body.emit(assign(r3FD9, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3FDB->else_instructions;

                        body.emit(assign(r3FDA, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3FDE = bit_and(r3FD2, body.constant(4294901760u));
                        ir_expression *const r3FDF = equal(r3FDE, body.constant(0u));
                        ir_if *f3FDD = new(mem_ctx) ir_if(operand(r3FDF).val);
                        exec_list *const f3FDD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3FDD->then_instructions;

                           body.emit(assign(r3FDA, body.constant(int(16)), 0x01));

                           body.emit(assign(r3FD8, lshift(r3FD2, body.constant(int(16))), 0x01));


                        body.instructions = f3FDD_parent_instructions;
                        body.emit(f3FDD);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3FE1 = bit_and(r3FD8, body.constant(4278190080u));
                        ir_expression *const r3FE2 = equal(r3FE1, body.constant(0u));
                        ir_if *f3FE0 = new(mem_ctx) ir_if(operand(r3FE2).val);
                        exec_list *const f3FE0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3FE0->then_instructions;

                           body.emit(assign(r3FDA, add(r3FDA, body.constant(int(8))), 0x01));

                           body.emit(assign(r3FD8, lshift(r3FD8, body.constant(int(8))), 0x01));


                        body.instructions = f3FE0_parent_instructions;
                        body.emit(f3FE0);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3FE4 = bit_and(r3FD8, body.constant(4026531840u));
                        ir_expression *const r3FE5 = equal(r3FE4, body.constant(0u));
                        ir_if *f3FE3 = new(mem_ctx) ir_if(operand(r3FE5).val);
                        exec_list *const f3FE3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3FE3->then_instructions;

                           body.emit(assign(r3FDA, add(r3FDA, body.constant(int(4))), 0x01));

                           body.emit(assign(r3FD8, lshift(r3FD8, body.constant(int(4))), 0x01));


                        body.instructions = f3FE3_parent_instructions;
                        body.emit(f3FE3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3FE7 = bit_and(r3FD8, body.constant(3221225472u));
                        ir_expression *const r3FE8 = equal(r3FE7, body.constant(0u));
                        ir_if *f3FE6 = new(mem_ctx) ir_if(operand(r3FE8).val);
                        exec_list *const f3FE6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3FE6->then_instructions;

                           body.emit(assign(r3FDA, add(r3FDA, body.constant(int(2))), 0x01));

                           body.emit(assign(r3FD8, lshift(r3FD8, body.constant(int(2))), 0x01));


                        body.instructions = f3FE6_parent_instructions;
                        body.emit(f3FE6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3FEA = bit_and(r3FD8, body.constant(2147483648u));
                        ir_expression *const r3FEB = equal(r3FEA, body.constant(0u));
                        ir_if *f3FE9 = new(mem_ctx) ir_if(operand(r3FEB).val);
                        exec_list *const f3FE9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3FE9->then_instructions;

                           body.emit(assign(r3FDA, add(r3FDA, body.constant(int(1))), 0x01));


                        body.instructions = f3FE9_parent_instructions;
                        body.emit(f3FE9);

                        /* END IF */

                        body.emit(assign(r3FD9, r3FDA, 0x01));


                     body.instructions = f3FDB_parent_instructions;
                     body.emit(f3FDB);

                     /* END IF */

                     body.emit(assign(r3FD5, add(r3FD9, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3FED = lequal(body.constant(int(0)), r3FD5);
                     ir_if *f3FEC = new(mem_ctx) ir_if(operand(r3FED).val);
                     exec_list *const f3FEC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3FEC->then_instructions;

                        body.emit(assign(r3FD4, body.constant(0u), 0x01));

                        ir_variable *const r3FEE = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r3FEE, lshift(r3FD3, r3FD5), 0x01));

                        ir_variable *const r3FEF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3FF1 = equal(r3FD5, body.constant(int(0)));
                        ir_if *f3FF0 = new(mem_ctx) ir_if(operand(r3FF1).val);
                        exec_list *const f3FF0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3FF0->then_instructions;

                           body.emit(assign(r3FEF, r3FD2, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3FF0->else_instructions;

                           ir_expression *const r3FF2 = lshift(r3FD2, r3FD5);
                           ir_expression *const r3FF3 = neg(r3FD5);
                           ir_expression *const r3FF4 = bit_and(r3FF3, body.constant(int(31)));
                           ir_expression *const r3FF5 = rshift(r3FD3, r3FF4);
                           body.emit(assign(r3FEF, bit_or(r3FF2, r3FF5), 0x01));


                        body.instructions = f3FF0_parent_instructions;
                        body.emit(f3FF0);

                        /* END IF */

                        body.emit(assign(r3FD2, r3FEF, 0x01));

                        body.emit(assign(r3FD3, r3FEE, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3FEC->else_instructions;

                        ir_variable *const r3FF6 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3FF6, body.constant(0u), 0x01));

                        ir_variable *const r3FF7 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3FF7, neg(r3FD5), 0x01));

                        ir_variable *const r3FF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3FF8);
                        ir_variable *const r3FF9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3FF9);
                        ir_variable *const r3FFA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3FFA);
                        ir_variable *const r3FFB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3FFC = neg(r3FF7);
                        body.emit(assign(r3FFB, bit_and(r3FFC, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3FFE = equal(r3FF7, body.constant(int(0)));
                        ir_if *f3FFD = new(mem_ctx) ir_if(operand(r3FFE).val);
                        exec_list *const f3FFD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3FFD->then_instructions;

                           body.emit(assign(r3FF8, r3FF6, 0x01));

                           body.emit(assign(r3FF9, r3FD3, 0x01));

                           body.emit(assign(r3FFA, r3FD2, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3FFD->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r4000 = less(r3FF7, body.constant(int(32)));
                           ir_if *f3FFF = new(mem_ctx) ir_if(operand(r4000).val);
                           exec_list *const f3FFF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3FFF->then_instructions;

                              body.emit(assign(r3FF8, lshift(r3FD3, r3FFB), 0x01));

                              ir_expression *const r4001 = lshift(r3FD2, r3FFB);
                              ir_expression *const r4002 = rshift(r3FD3, r3FF7);
                              body.emit(assign(r3FF9, bit_or(r4001, r4002), 0x01));

                              body.emit(assign(r3FFA, rshift(r3FD2, r3FF7), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3FFF->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r4004 = equal(r3FF7, body.constant(int(32)));
                              ir_if *f4003 = new(mem_ctx) ir_if(operand(r4004).val);
                              exec_list *const f4003_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f4003->then_instructions;

                                 body.emit(assign(r3FF8, r3FD3, 0x01));

                                 body.emit(assign(r3FF9, r3FD2, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f4003->else_instructions;

                                 body.emit(assign(r3FF6, bit_or(body.constant(0u), r3FD3), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r4006 = less(r3FF7, body.constant(int(64)));
                                 ir_if *f4005 = new(mem_ctx) ir_if(operand(r4006).val);
                                 exec_list *const f4005_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f4005->then_instructions;

                                    body.emit(assign(r3FF8, lshift(r3FD2, r3FFB), 0x01));

                                    ir_expression *const r4007 = bit_and(r3FF7, body.constant(int(31)));
                                    body.emit(assign(r3FF9, rshift(r3FD2, r4007), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f4005->else_instructions;

                                    ir_variable *const r4008 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r400A = equal(r3FF7, body.constant(int(64)));
                                    ir_if *f4009 = new(mem_ctx) ir_if(operand(r400A).val);
                                    exec_list *const f4009_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f4009->then_instructions;

                                       body.emit(assign(r4008, r3FD2, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f4009->else_instructions;

                                       ir_expression *const r400B = nequal(r3FD2, body.constant(0u));
                                       ir_expression *const r400C = expr(ir_unop_b2i, r400B);
                                       body.emit(assign(r4008, expr(ir_unop_i2u, r400C), 0x01));


                                    body.instructions = f4009_parent_instructions;
                                    body.emit(f4009);

                                    /* END IF */

                                    body.emit(assign(r3FF8, r4008, 0x01));

                                    body.emit(assign(r3FF9, body.constant(0u), 0x01));


                                 body.instructions = f4005_parent_instructions;
                                 body.emit(f4005);

                                 /* END IF */


                              body.instructions = f4003_parent_instructions;
                              body.emit(f4003);

                              /* END IF */

                              body.emit(assign(r3FFA, body.constant(0u), 0x01));


                           body.instructions = f3FFF_parent_instructions;
                           body.emit(f3FFF);

                           /* END IF */

                           ir_expression *const r400D = nequal(r3FF6, body.constant(0u));
                           ir_expression *const r400E = expr(ir_unop_b2i, r400D);
                           ir_expression *const r400F = expr(ir_unop_i2u, r400E);
                           body.emit(assign(r3FF8, bit_or(r3FF8, r400F), 0x01));


                        body.instructions = f3FFD_parent_instructions;
                        body.emit(f3FFD);

                        /* END IF */

                        body.emit(assign(r3FD2, r3FFA, 0x01));

                        body.emit(assign(r3FD3, r3FF9, 0x01));

                        body.emit(assign(r3FD4, r3FF8, 0x01));


                     body.instructions = f3FEC_parent_instructions;
                     body.emit(f3FEC);

                     /* END IF */

                     body.emit(assign(r3FD1, sub(r3FD1, r3FD5), 0x01));

                     ir_variable *const r4010 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r4010, r3FD1, 0x01));

                     ir_variable *const r4011 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r4011, r3FD2, 0x01));

                     ir_variable *const r4012 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r4012, r3FD3, 0x01));

                     ir_variable *const r4013 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r4013, r3FD4, 0x01));

                     ir_variable *const r4014 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r4014, body.constant(true), 0x01));

                     ir_variable *const r4015 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r4016 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r4016);
                     ir_expression *const r4017 = expr(ir_unop_u2i, r3FD4);
                     body.emit(assign(r4016, less(r4017, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r4019 = lequal(body.constant(int(2045)), r3FD1);
                     ir_if *f4018 = new(mem_ctx) ir_if(operand(r4019).val);
                     exec_list *const f4018_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4018->then_instructions;

                        ir_variable *const r401A = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r401C = less(body.constant(int(2045)), r3FD1);
                        ir_if *f401B = new(mem_ctx) ir_if(operand(r401C).val);
                        exec_list *const f401B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f401B->then_instructions;

                           body.emit(assign(r401A, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f401B->else_instructions;

                           ir_variable *const r401D = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r401F = equal(r3FD1, body.constant(int(2045)));
                           ir_if *f401E = new(mem_ctx) ir_if(operand(r401F).val);
                           exec_list *const f401E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f401E->then_instructions;

                              ir_expression *const r4020 = equal(body.constant(2097151u), r3FD2);
                              ir_expression *const r4021 = equal(body.constant(4294967295u), r3FD3);
                              body.emit(assign(r401D, logic_and(r4020, r4021), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f401E->else_instructions;

                              body.emit(assign(r401D, body.constant(false), 0x01));


                           body.instructions = f401E_parent_instructions;
                           body.emit(f401E);

                           /* END IF */

                           body.emit(assign(r401A, logic_and(r401D, r4016), 0x01));


                        body.instructions = f401B_parent_instructions;
                        body.emit(f401B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f4022 = new(mem_ctx) ir_if(operand(r401A).val);
                        exec_list *const f4022_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4022->then_instructions;

                           ir_variable *const r4023 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r4023);
                           ir_expression *const r4024 = lshift(r3D56, body.constant(int(31)));
                           body.emit(assign(r4023, add(r4024, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r4023, body.constant(0u), 0x01));

                           body.emit(assign(r4015, r4023, 0x03));

                           body.emit(assign(r4014, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f4022->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r4026 = less(r3FD1, body.constant(int(0)));
                           ir_if *f4025 = new(mem_ctx) ir_if(operand(r4026).val);
                           exec_list *const f4025_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4025->then_instructions;

                              ir_variable *const r4027 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r4027, r3FD4, 0x01));

                              ir_variable *const r4028 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r4028, neg(r3FD1), 0x01));

                              ir_variable *const r4029 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r4029);
                              ir_variable *const r402A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r402A);
                              ir_variable *const r402B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r402B);
                              ir_variable *const r402C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r402D = neg(r4028);
                              body.emit(assign(r402C, bit_and(r402D, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r402F = equal(r4028, body.constant(int(0)));
                              ir_if *f402E = new(mem_ctx) ir_if(operand(r402F).val);
                              exec_list *const f402E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f402E->then_instructions;

                                 body.emit(assign(r4029, r3FD4, 0x01));

                                 body.emit(assign(r402A, r3FD3, 0x01));

                                 body.emit(assign(r402B, r3FD2, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f402E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r4031 = less(r4028, body.constant(int(32)));
                                 ir_if *f4030 = new(mem_ctx) ir_if(operand(r4031).val);
                                 exec_list *const f4030_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f4030->then_instructions;

                                    body.emit(assign(r4029, lshift(r3FD3, r402C), 0x01));

                                    ir_expression *const r4032 = lshift(r3FD2, r402C);
                                    ir_expression *const r4033 = rshift(r3FD3, r4028);
                                    body.emit(assign(r402A, bit_or(r4032, r4033), 0x01));

                                    body.emit(assign(r402B, rshift(r3FD2, r4028), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f4030->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r4035 = equal(r4028, body.constant(int(32)));
                                    ir_if *f4034 = new(mem_ctx) ir_if(operand(r4035).val);
                                    exec_list *const f4034_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f4034->then_instructions;

                                       body.emit(assign(r4029, r3FD3, 0x01));

                                       body.emit(assign(r402A, r3FD2, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f4034->else_instructions;

                                       body.emit(assign(r4027, bit_or(r3FD4, r3FD3), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r4037 = less(r4028, body.constant(int(64)));
                                       ir_if *f4036 = new(mem_ctx) ir_if(operand(r4037).val);
                                       exec_list *const f4036_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f4036->then_instructions;

                                          body.emit(assign(r4029, lshift(r3FD2, r402C), 0x01));

                                          ir_expression *const r4038 = bit_and(r4028, body.constant(int(31)));
                                          body.emit(assign(r402A, rshift(r3FD2, r4038), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f4036->else_instructions;

                                          ir_variable *const r4039 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r403B = equal(r4028, body.constant(int(64)));
                                          ir_if *f403A = new(mem_ctx) ir_if(operand(r403B).val);
                                          exec_list *const f403A_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f403A->then_instructions;

                                             body.emit(assign(r4039, r3FD2, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f403A->else_instructions;

                                             ir_expression *const r403C = nequal(r3FD2, body.constant(0u));
                                             ir_expression *const r403D = expr(ir_unop_b2i, r403C);
                                             body.emit(assign(r4039, expr(ir_unop_i2u, r403D), 0x01));


                                          body.instructions = f403A_parent_instructions;
                                          body.emit(f403A);

                                          /* END IF */

                                          body.emit(assign(r4029, r4039, 0x01));

                                          body.emit(assign(r402A, body.constant(0u), 0x01));


                                       body.instructions = f4036_parent_instructions;
                                       body.emit(f4036);

                                       /* END IF */


                                    body.instructions = f4034_parent_instructions;
                                    body.emit(f4034);

                                    /* END IF */

                                    body.emit(assign(r402B, body.constant(0u), 0x01));


                                 body.instructions = f4030_parent_instructions;
                                 body.emit(f4030);

                                 /* END IF */

                                 ir_expression *const r403E = nequal(r4027, body.constant(0u));
                                 ir_expression *const r403F = expr(ir_unop_b2i, r403E);
                                 ir_expression *const r4040 = expr(ir_unop_i2u, r403F);
                                 body.emit(assign(r4029, bit_or(r4029, r4040), 0x01));


                              body.instructions = f402E_parent_instructions;
                              body.emit(f402E);

                              /* END IF */

                              body.emit(assign(r4011, r402B, 0x01));

                              body.emit(assign(r4012, r402A, 0x01));

                              body.emit(assign(r4013, r4029, 0x01));

                              body.emit(assign(r4010, body.constant(int(0)), 0x01));

                              body.emit(assign(r4016, less(r4029, body.constant(0u)), 0x01));


                           body.instructions = f4025_parent_instructions;
                           body.emit(f4025);

                           /* END IF */


                        body.instructions = f4022_parent_instructions;
                        body.emit(f4022);

                        /* END IF */


                     body.instructions = f4018_parent_instructions;
                     body.emit(f4018);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f4041 = new(mem_ctx) ir_if(operand(r4014).val);
                     exec_list *const f4041_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4041->then_instructions;

                        /* IF CONDITION */
                        ir_if *f4042 = new(mem_ctx) ir_if(operand(r4016).val);
                        exec_list *const f4042_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4042->then_instructions;

                           ir_variable *const r4043 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r4043, add(r4012, body.constant(1u)), 0x01));

                           ir_expression *const r4044 = less(r4043, r4012);
                           ir_expression *const r4045 = expr(ir_unop_b2i, r4044);
                           ir_expression *const r4046 = expr(ir_unop_i2u, r4045);
                           body.emit(assign(r4011, add(r4011, r4046), 0x01));

                           ir_expression *const r4047 = equal(r4013, body.constant(0u));
                           ir_expression *const r4048 = expr(ir_unop_b2i, r4047);
                           ir_expression *const r4049 = expr(ir_unop_i2u, r4048);
                           ir_expression *const r404A = add(r4013, r4049);
                           ir_expression *const r404B = bit_and(r404A, body.constant(1u));
                           ir_expression *const r404C = expr(ir_unop_bit_not, r404B);
                           body.emit(assign(r4012, bit_and(r4043, r404C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f4042->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r404E = bit_or(r4011, r4012);
                           ir_expression *const r404F = equal(r404E, body.constant(0u));
                           ir_if *f404D = new(mem_ctx) ir_if(operand(r404F).val);
                           exec_list *const f404D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f404D->then_instructions;

                              body.emit(assign(r4010, body.constant(int(0)), 0x01));


                           body.instructions = f404D_parent_instructions;
                           body.emit(f404D);

                           /* END IF */


                        body.instructions = f4042_parent_instructions;
                        body.emit(f4042);

                        /* END IF */

                        ir_variable *const r4050 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r4050);
                        ir_expression *const r4051 = lshift(r3D56, body.constant(int(31)));
                        ir_expression *const r4052 = expr(ir_unop_i2u, r4010);
                        ir_expression *const r4053 = lshift(r4052, body.constant(int(20)));
                        ir_expression *const r4054 = add(r4051, r4053);
                        body.emit(assign(r4050, add(r4054, r4011), 0x02));

                        body.emit(assign(r4050, r4012, 0x01));

                        body.emit(assign(r4015, r4050, 0x03));

                        body.emit(assign(r4014, body.constant(false), 0x01));


                     body.instructions = f4041_parent_instructions;
                     body.emit(f4041);

                     /* END IF */

                     body.emit(assign(r3D57, r4015, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3FC9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r4056 = less(swizzle_x(r3D5A), swizzle_x(r3D5C));
                     ir_if *f4055 = new(mem_ctx) ir_if(operand(r4056).val);
                     exec_list *const f4055_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4055->then_instructions;

                        ir_variable *const r4057 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r4058 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r4058, sub(swizzle_x(r3D5C), swizzle_x(r3D5A)), 0x01));

                        ir_expression *const r4059 = sub(swizzle_y(r3D5C), swizzle_y(r3D5A));
                        ir_expression *const r405A = less(swizzle_x(r3D5C), swizzle_x(r3D5A));
                        ir_expression *const r405B = expr(ir_unop_b2i, r405A);
                        ir_expression *const r405C = expr(ir_unop_i2u, r405B);
                        body.emit(assign(r4057, sub(r4059, r405C), 0x01));

                        body.emit(assign(r3D5D, add(r3D5B, body.constant(int(-1))), 0x01));

                        ir_variable *const r405D = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r405D, add(r3D5D, body.constant(int(-10))), 0x01));

                        ir_variable *const r405E = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r405E, r4057, 0x01));

                        ir_variable *const r405F = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r405F, r4058, 0x01));

                        ir_variable *const r4060 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r4060);
                        ir_variable *const r4061 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r4061);
                        /* IF CONDITION */
                        ir_expression *const r4063 = equal(r4057, body.constant(0u));
                        ir_if *f4062 = new(mem_ctx) ir_if(operand(r4063).val);
                        exec_list *const f4062_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4062->then_instructions;

                           body.emit(assign(r405E, r4058, 0x01));

                           body.emit(assign(r405F, body.constant(0u), 0x01));

                           body.emit(assign(r405D, add(r405D, body.constant(int(-32))), 0x01));


                        body.instructions = f4062_parent_instructions;
                        body.emit(f4062);

                        /* END IF */

                        ir_variable *const r4064 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r4064, r405E, 0x01));

                        ir_variable *const r4065 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r4066 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r4066);
                        /* IF CONDITION */
                        ir_expression *const r4068 = equal(r405E, body.constant(0u));
                        ir_if *f4067 = new(mem_ctx) ir_if(operand(r4068).val);
                        exec_list *const f4067_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4067->then_instructions;

                           body.emit(assign(r4065, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f4067->else_instructions;

                           body.emit(assign(r4066, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r406A = bit_and(r405E, body.constant(4294901760u));
                           ir_expression *const r406B = equal(r406A, body.constant(0u));
                           ir_if *f4069 = new(mem_ctx) ir_if(operand(r406B).val);
                           exec_list *const f4069_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4069->then_instructions;

                              body.emit(assign(r4066, body.constant(int(16)), 0x01));

                              body.emit(assign(r4064, lshift(r405E, body.constant(int(16))), 0x01));


                           body.instructions = f4069_parent_instructions;
                           body.emit(f4069);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r406D = bit_and(r4064, body.constant(4278190080u));
                           ir_expression *const r406E = equal(r406D, body.constant(0u));
                           ir_if *f406C = new(mem_ctx) ir_if(operand(r406E).val);
                           exec_list *const f406C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f406C->then_instructions;

                              body.emit(assign(r4066, add(r4066, body.constant(int(8))), 0x01));

                              body.emit(assign(r4064, lshift(r4064, body.constant(int(8))), 0x01));


                           body.instructions = f406C_parent_instructions;
                           body.emit(f406C);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r4070 = bit_and(r4064, body.constant(4026531840u));
                           ir_expression *const r4071 = equal(r4070, body.constant(0u));
                           ir_if *f406F = new(mem_ctx) ir_if(operand(r4071).val);
                           exec_list *const f406F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f406F->then_instructions;

                              body.emit(assign(r4066, add(r4066, body.constant(int(4))), 0x01));

                              body.emit(assign(r4064, lshift(r4064, body.constant(int(4))), 0x01));


                           body.instructions = f406F_parent_instructions;
                           body.emit(f406F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r4073 = bit_and(r4064, body.constant(3221225472u));
                           ir_expression *const r4074 = equal(r4073, body.constant(0u));
                           ir_if *f4072 = new(mem_ctx) ir_if(operand(r4074).val);
                           exec_list *const f4072_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4072->then_instructions;

                              body.emit(assign(r4066, add(r4066, body.constant(int(2))), 0x01));

                              body.emit(assign(r4064, lshift(r4064, body.constant(int(2))), 0x01));


                           body.instructions = f4072_parent_instructions;
                           body.emit(f4072);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r4076 = bit_and(r4064, body.constant(2147483648u));
                           ir_expression *const r4077 = equal(r4076, body.constant(0u));
                           ir_if *f4075 = new(mem_ctx) ir_if(operand(r4077).val);
                           exec_list *const f4075_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4075->then_instructions;

                              body.emit(assign(r4066, add(r4066, body.constant(int(1))), 0x01));


                           body.instructions = f4075_parent_instructions;
                           body.emit(f4075);

                           /* END IF */

                           body.emit(assign(r4065, r4066, 0x01));


                        body.instructions = f4067_parent_instructions;
                        body.emit(f4067);

                        /* END IF */

                        body.emit(assign(r4061, add(r4065, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r4079 = lequal(body.constant(int(0)), r4061);
                        ir_if *f4078 = new(mem_ctx) ir_if(operand(r4079).val);
                        exec_list *const f4078_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4078->then_instructions;

                           body.emit(assign(r4060, body.constant(0u), 0x01));

                           ir_variable *const r407A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r407A, lshift(r405F, r4061), 0x01));

                           ir_variable *const r407B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r407D = equal(r4061, body.constant(int(0)));
                           ir_if *f407C = new(mem_ctx) ir_if(operand(r407D).val);
                           exec_list *const f407C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f407C->then_instructions;

                              body.emit(assign(r407B, r405E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f407C->else_instructions;

                              ir_expression *const r407E = lshift(r405E, r4061);
                              ir_expression *const r407F = neg(r4061);
                              ir_expression *const r4080 = bit_and(r407F, body.constant(int(31)));
                              ir_expression *const r4081 = rshift(r405F, r4080);
                              body.emit(assign(r407B, bit_or(r407E, r4081), 0x01));


                           body.instructions = f407C_parent_instructions;
                           body.emit(f407C);

                           /* END IF */

                           body.emit(assign(r405E, r407B, 0x01));

                           body.emit(assign(r405F, r407A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f4078->else_instructions;

                           ir_variable *const r4082 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r4082, body.constant(0u), 0x01));

                           ir_variable *const r4083 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r4083, neg(r4061), 0x01));

                           ir_variable *const r4084 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r4084);
                           ir_variable *const r4085 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r4085);
                           ir_variable *const r4086 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r4086);
                           ir_variable *const r4087 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r4088 = neg(r4083);
                           body.emit(assign(r4087, bit_and(r4088, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r408A = equal(r4083, body.constant(int(0)));
                           ir_if *f4089 = new(mem_ctx) ir_if(operand(r408A).val);
                           exec_list *const f4089_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4089->then_instructions;

                              body.emit(assign(r4084, r4082, 0x01));

                              body.emit(assign(r4085, r405F, 0x01));

                              body.emit(assign(r4086, r405E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f4089->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r408C = less(r4083, body.constant(int(32)));
                              ir_if *f408B = new(mem_ctx) ir_if(operand(r408C).val);
                              exec_list *const f408B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f408B->then_instructions;

                                 body.emit(assign(r4084, lshift(r405F, r4087), 0x01));

                                 ir_expression *const r408D = lshift(r405E, r4087);
                                 ir_expression *const r408E = rshift(r405F, r4083);
                                 body.emit(assign(r4085, bit_or(r408D, r408E), 0x01));

                                 body.emit(assign(r4086, rshift(r405E, r4083), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f408B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r4090 = equal(r4083, body.constant(int(32)));
                                 ir_if *f408F = new(mem_ctx) ir_if(operand(r4090).val);
                                 exec_list *const f408F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f408F->then_instructions;

                                    body.emit(assign(r4084, r405F, 0x01));

                                    body.emit(assign(r4085, r405E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f408F->else_instructions;

                                    body.emit(assign(r4082, bit_or(body.constant(0u), r405F), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r4092 = less(r4083, body.constant(int(64)));
                                    ir_if *f4091 = new(mem_ctx) ir_if(operand(r4092).val);
                                    exec_list *const f4091_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f4091->then_instructions;

                                       body.emit(assign(r4084, lshift(r405E, r4087), 0x01));

                                       ir_expression *const r4093 = bit_and(r4083, body.constant(int(31)));
                                       body.emit(assign(r4085, rshift(r405E, r4093), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f4091->else_instructions;

                                       ir_variable *const r4094 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r4096 = equal(r4083, body.constant(int(64)));
                                       ir_if *f4095 = new(mem_ctx) ir_if(operand(r4096).val);
                                       exec_list *const f4095_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f4095->then_instructions;

                                          body.emit(assign(r4094, r405E, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f4095->else_instructions;

                                          ir_expression *const r4097 = nequal(r405E, body.constant(0u));
                                          ir_expression *const r4098 = expr(ir_unop_b2i, r4097);
                                          body.emit(assign(r4094, expr(ir_unop_i2u, r4098), 0x01));


                                       body.instructions = f4095_parent_instructions;
                                       body.emit(f4095);

                                       /* END IF */

                                       body.emit(assign(r4084, r4094, 0x01));

                                       body.emit(assign(r4085, body.constant(0u), 0x01));


                                    body.instructions = f4091_parent_instructions;
                                    body.emit(f4091);

                                    /* END IF */


                                 body.instructions = f408F_parent_instructions;
                                 body.emit(f408F);

                                 /* END IF */

                                 body.emit(assign(r4086, body.constant(0u), 0x01));


                              body.instructions = f408B_parent_instructions;
                              body.emit(f408B);

                              /* END IF */

                              ir_expression *const r4099 = nequal(r4082, body.constant(0u));
                              ir_expression *const r409A = expr(ir_unop_b2i, r4099);
                              ir_expression *const r409B = expr(ir_unop_i2u, r409A);
                              body.emit(assign(r4084, bit_or(r4084, r409B), 0x01));


                           body.instructions = f4089_parent_instructions;
                           body.emit(f4089);

                           /* END IF */

                           body.emit(assign(r405E, r4086, 0x01));

                           body.emit(assign(r405F, r4085, 0x01));

                           body.emit(assign(r4060, r4084, 0x01));


                        body.instructions = f4078_parent_instructions;
                        body.emit(f4078);

                        /* END IF */

                        body.emit(assign(r405D, sub(r405D, r4061), 0x01));

                        ir_variable *const r409C = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r409C, r405D, 0x01));

                        ir_variable *const r409D = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r409D, r405E, 0x01));

                        ir_variable *const r409E = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r409E, r405F, 0x01));

                        ir_variable *const r409F = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r409F, r4060, 0x01));

                        ir_variable *const r40A0 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r40A0, body.constant(true), 0x01));

                        ir_variable *const r40A1 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r40A2 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r40A2);
                        ir_expression *const r40A3 = expr(ir_unop_u2i, r4060);
                        body.emit(assign(r40A2, less(r40A3, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r40A5 = lequal(body.constant(int(2045)), r405D);
                        ir_if *f40A4 = new(mem_ctx) ir_if(operand(r40A5).val);
                        exec_list *const f40A4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f40A4->then_instructions;

                           ir_variable *const r40A6 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r40A8 = less(body.constant(int(2045)), r405D);
                           ir_if *f40A7 = new(mem_ctx) ir_if(operand(r40A8).val);
                           exec_list *const f40A7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f40A7->then_instructions;

                              body.emit(assign(r40A6, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f40A7->else_instructions;

                              ir_variable *const r40A9 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r40AB = equal(r405D, body.constant(int(2045)));
                              ir_if *f40AA = new(mem_ctx) ir_if(operand(r40AB).val);
                              exec_list *const f40AA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f40AA->then_instructions;

                                 ir_expression *const r40AC = equal(body.constant(2097151u), r405E);
                                 ir_expression *const r40AD = equal(body.constant(4294967295u), r405F);
                                 body.emit(assign(r40A9, logic_and(r40AC, r40AD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f40AA->else_instructions;

                                 body.emit(assign(r40A9, body.constant(false), 0x01));


                              body.instructions = f40AA_parent_instructions;
                              body.emit(f40AA);

                              /* END IF */

                              body.emit(assign(r40A6, logic_and(r40A9, r40A2), 0x01));


                           body.instructions = f40A7_parent_instructions;
                           body.emit(f40A7);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f40AE = new(mem_ctx) ir_if(operand(r40A6).val);
                           exec_list *const f40AE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f40AE->then_instructions;

                              ir_variable *const r40AF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r40AF);
                              ir_expression *const r40B0 = lshift(r3D56, body.constant(int(31)));
                              body.emit(assign(r40AF, add(r40B0, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r40AF, body.constant(0u), 0x01));

                              body.emit(assign(r40A1, r40AF, 0x03));

                              body.emit(assign(r40A0, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f40AE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r40B2 = less(r405D, body.constant(int(0)));
                              ir_if *f40B1 = new(mem_ctx) ir_if(operand(r40B2).val);
                              exec_list *const f40B1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f40B1->then_instructions;

                                 ir_variable *const r40B3 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r40B3, r4060, 0x01));

                                 ir_variable *const r40B4 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r40B4, neg(r405D), 0x01));

                                 ir_variable *const r40B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r40B5);
                                 ir_variable *const r40B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r40B6);
                                 ir_variable *const r40B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r40B7);
                                 ir_variable *const r40B8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r40B9 = neg(r40B4);
                                 body.emit(assign(r40B8, bit_and(r40B9, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r40BB = equal(r40B4, body.constant(int(0)));
                                 ir_if *f40BA = new(mem_ctx) ir_if(operand(r40BB).val);
                                 exec_list *const f40BA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f40BA->then_instructions;

                                    body.emit(assign(r40B5, r4060, 0x01));

                                    body.emit(assign(r40B6, r405F, 0x01));

                                    body.emit(assign(r40B7, r405E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f40BA->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r40BD = less(r40B4, body.constant(int(32)));
                                    ir_if *f40BC = new(mem_ctx) ir_if(operand(r40BD).val);
                                    exec_list *const f40BC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f40BC->then_instructions;

                                       body.emit(assign(r40B5, lshift(r405F, r40B8), 0x01));

                                       ir_expression *const r40BE = lshift(r405E, r40B8);
                                       ir_expression *const r40BF = rshift(r405F, r40B4);
                                       body.emit(assign(r40B6, bit_or(r40BE, r40BF), 0x01));

                                       body.emit(assign(r40B7, rshift(r405E, r40B4), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f40BC->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r40C1 = equal(r40B4, body.constant(int(32)));
                                       ir_if *f40C0 = new(mem_ctx) ir_if(operand(r40C1).val);
                                       exec_list *const f40C0_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f40C0->then_instructions;

                                          body.emit(assign(r40B5, r405F, 0x01));

                                          body.emit(assign(r40B6, r405E, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f40C0->else_instructions;

                                          body.emit(assign(r40B3, bit_or(r4060, r405F), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r40C3 = less(r40B4, body.constant(int(64)));
                                          ir_if *f40C2 = new(mem_ctx) ir_if(operand(r40C3).val);
                                          exec_list *const f40C2_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f40C2->then_instructions;

                                             body.emit(assign(r40B5, lshift(r405E, r40B8), 0x01));

                                             ir_expression *const r40C4 = bit_and(r40B4, body.constant(int(31)));
                                             body.emit(assign(r40B6, rshift(r405E, r40C4), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f40C2->else_instructions;

                                             ir_variable *const r40C5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r40C7 = equal(r40B4, body.constant(int(64)));
                                             ir_if *f40C6 = new(mem_ctx) ir_if(operand(r40C7).val);
                                             exec_list *const f40C6_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f40C6->then_instructions;

                                                body.emit(assign(r40C5, r405E, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f40C6->else_instructions;

                                                ir_expression *const r40C8 = nequal(r405E, body.constant(0u));
                                                ir_expression *const r40C9 = expr(ir_unop_b2i, r40C8);
                                                body.emit(assign(r40C5, expr(ir_unop_i2u, r40C9), 0x01));


                                             body.instructions = f40C6_parent_instructions;
                                             body.emit(f40C6);

                                             /* END IF */

                                             body.emit(assign(r40B5, r40C5, 0x01));

                                             body.emit(assign(r40B6, body.constant(0u), 0x01));


                                          body.instructions = f40C2_parent_instructions;
                                          body.emit(f40C2);

                                          /* END IF */


                                       body.instructions = f40C0_parent_instructions;
                                       body.emit(f40C0);

                                       /* END IF */

                                       body.emit(assign(r40B7, body.constant(0u), 0x01));


                                    body.instructions = f40BC_parent_instructions;
                                    body.emit(f40BC);

                                    /* END IF */

                                    ir_expression *const r40CA = nequal(r40B3, body.constant(0u));
                                    ir_expression *const r40CB = expr(ir_unop_b2i, r40CA);
                                    ir_expression *const r40CC = expr(ir_unop_i2u, r40CB);
                                    body.emit(assign(r40B5, bit_or(r40B5, r40CC), 0x01));


                                 body.instructions = f40BA_parent_instructions;
                                 body.emit(f40BA);

                                 /* END IF */

                                 body.emit(assign(r409D, r40B7, 0x01));

                                 body.emit(assign(r409E, r40B6, 0x01));

                                 body.emit(assign(r409F, r40B5, 0x01));

                                 body.emit(assign(r409C, body.constant(int(0)), 0x01));

                                 body.emit(assign(r40A2, less(r40B5, body.constant(0u)), 0x01));


                              body.instructions = f40B1_parent_instructions;
                              body.emit(f40B1);

                              /* END IF */


                           body.instructions = f40AE_parent_instructions;
                           body.emit(f40AE);

                           /* END IF */


                        body.instructions = f40A4_parent_instructions;
                        body.emit(f40A4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f40CD = new(mem_ctx) ir_if(operand(r40A0).val);
                        exec_list *const f40CD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f40CD->then_instructions;

                           /* IF CONDITION */
                           ir_if *f40CE = new(mem_ctx) ir_if(operand(r40A2).val);
                           exec_list *const f40CE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f40CE->then_instructions;

                              ir_variable *const r40CF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r40CF, add(r409E, body.constant(1u)), 0x01));

                              ir_expression *const r40D0 = less(r40CF, r409E);
                              ir_expression *const r40D1 = expr(ir_unop_b2i, r40D0);
                              ir_expression *const r40D2 = expr(ir_unop_i2u, r40D1);
                              body.emit(assign(r409D, add(r409D, r40D2), 0x01));

                              ir_expression *const r40D3 = equal(r409F, body.constant(0u));
                              ir_expression *const r40D4 = expr(ir_unop_b2i, r40D3);
                              ir_expression *const r40D5 = expr(ir_unop_i2u, r40D4);
                              ir_expression *const r40D6 = add(r409F, r40D5);
                              ir_expression *const r40D7 = bit_and(r40D6, body.constant(1u));
                              ir_expression *const r40D8 = expr(ir_unop_bit_not, r40D7);
                              body.emit(assign(r409E, bit_and(r40CF, r40D8), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f40CE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r40DA = bit_or(r409D, r409E);
                              ir_expression *const r40DB = equal(r40DA, body.constant(0u));
                              ir_if *f40D9 = new(mem_ctx) ir_if(operand(r40DB).val);
                              exec_list *const f40D9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f40D9->then_instructions;

                                 body.emit(assign(r409C, body.constant(int(0)), 0x01));


                              body.instructions = f40D9_parent_instructions;
                              body.emit(f40D9);

                              /* END IF */


                           body.instructions = f40CE_parent_instructions;
                           body.emit(f40CE);

                           /* END IF */

                           ir_variable *const r40DC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r40DC);
                           ir_expression *const r40DD = lshift(r3D56, body.constant(int(31)));
                           ir_expression *const r40DE = expr(ir_unop_i2u, r409C);
                           ir_expression *const r40DF = lshift(r40DE, body.constant(int(20)));
                           ir_expression *const r40E0 = add(r40DD, r40DF);
                           body.emit(assign(r40DC, add(r40E0, r409D), 0x02));

                           body.emit(assign(r40DC, r409E, 0x01));

                           body.emit(assign(r40A1, r40DC, 0x03));

                           body.emit(assign(r40A0, body.constant(false), 0x01));


                        body.instructions = f40CD_parent_instructions;
                        body.emit(f40CD);

                        /* END IF */

                        body.emit(assign(r3D57, r40A1, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4055->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r40E2 = less(swizzle_x(r3D5C), swizzle_x(r3D5A));
                        ir_if *f40E1 = new(mem_ctx) ir_if(operand(r40E2).val);
                        exec_list *const f40E1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f40E1->then_instructions;

                           ir_variable *const r40E3 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r40E4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r40E4, sub(swizzle_x(r3D5A), swizzle_x(r3D5C)), 0x01));

                           ir_expression *const r40E5 = sub(swizzle_y(r3D5A), swizzle_y(r3D5C));
                           ir_expression *const r40E6 = less(swizzle_x(r3D5A), swizzle_x(r3D5C));
                           ir_expression *const r40E7 = expr(ir_unop_b2i, r40E6);
                           ir_expression *const r40E8 = expr(ir_unop_i2u, r40E7);
                           body.emit(assign(r40E3, sub(r40E5, r40E8), 0x01));

                           body.emit(assign(r3D56, bit_xor(r3D56, body.constant(1u)), 0x01));

                           body.emit(assign(r3D5D, add(r3D59, body.constant(int(-1))), 0x01));

                           ir_variable *const r40E9 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r40E9, add(r3D5D, body.constant(int(-10))), 0x01));

                           ir_variable *const r40EA = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r40EA, r40E3, 0x01));

                           ir_variable *const r40EB = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r40EB, r40E4, 0x01));

                           ir_variable *const r40EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r40EC);
                           ir_variable *const r40ED = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r40ED);
                           /* IF CONDITION */
                           ir_expression *const r40EF = equal(r40E3, body.constant(0u));
                           ir_if *f40EE = new(mem_ctx) ir_if(operand(r40EF).val);
                           exec_list *const f40EE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f40EE->then_instructions;

                              body.emit(assign(r40EA, r40E4, 0x01));

                              body.emit(assign(r40EB, body.constant(0u), 0x01));

                              body.emit(assign(r40E9, add(r40E9, body.constant(int(-32))), 0x01));


                           body.instructions = f40EE_parent_instructions;
                           body.emit(f40EE);

                           /* END IF */

                           ir_variable *const r40F0 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r40F0, r40EA, 0x01));

                           ir_variable *const r40F1 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r40F2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r40F2);
                           /* IF CONDITION */
                           ir_expression *const r40F4 = equal(r40EA, body.constant(0u));
                           ir_if *f40F3 = new(mem_ctx) ir_if(operand(r40F4).val);
                           exec_list *const f40F3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f40F3->then_instructions;

                              body.emit(assign(r40F1, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f40F3->else_instructions;

                              body.emit(assign(r40F2, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r40F6 = bit_and(r40EA, body.constant(4294901760u));
                              ir_expression *const r40F7 = equal(r40F6, body.constant(0u));
                              ir_if *f40F5 = new(mem_ctx) ir_if(operand(r40F7).val);
                              exec_list *const f40F5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f40F5->then_instructions;

                                 body.emit(assign(r40F2, body.constant(int(16)), 0x01));

                                 body.emit(assign(r40F0, lshift(r40EA, body.constant(int(16))), 0x01));


                              body.instructions = f40F5_parent_instructions;
                              body.emit(f40F5);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r40F9 = bit_and(r40F0, body.constant(4278190080u));
                              ir_expression *const r40FA = equal(r40F9, body.constant(0u));
                              ir_if *f40F8 = new(mem_ctx) ir_if(operand(r40FA).val);
                              exec_list *const f40F8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f40F8->then_instructions;

                                 body.emit(assign(r40F2, add(r40F2, body.constant(int(8))), 0x01));

                                 body.emit(assign(r40F0, lshift(r40F0, body.constant(int(8))), 0x01));


                              body.instructions = f40F8_parent_instructions;
                              body.emit(f40F8);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r40FC = bit_and(r40F0, body.constant(4026531840u));
                              ir_expression *const r40FD = equal(r40FC, body.constant(0u));
                              ir_if *f40FB = new(mem_ctx) ir_if(operand(r40FD).val);
                              exec_list *const f40FB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f40FB->then_instructions;

                                 body.emit(assign(r40F2, add(r40F2, body.constant(int(4))), 0x01));

                                 body.emit(assign(r40F0, lshift(r40F0, body.constant(int(4))), 0x01));


                              body.instructions = f40FB_parent_instructions;
                              body.emit(f40FB);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r40FF = bit_and(r40F0, body.constant(3221225472u));
                              ir_expression *const r4100 = equal(r40FF, body.constant(0u));
                              ir_if *f40FE = new(mem_ctx) ir_if(operand(r4100).val);
                              exec_list *const f40FE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f40FE->then_instructions;

                                 body.emit(assign(r40F2, add(r40F2, body.constant(int(2))), 0x01));

                                 body.emit(assign(r40F0, lshift(r40F0, body.constant(int(2))), 0x01));


                              body.instructions = f40FE_parent_instructions;
                              body.emit(f40FE);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r4102 = bit_and(r40F0, body.constant(2147483648u));
                              ir_expression *const r4103 = equal(r4102, body.constant(0u));
                              ir_if *f4101 = new(mem_ctx) ir_if(operand(r4103).val);
                              exec_list *const f4101_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f4101->then_instructions;

                                 body.emit(assign(r40F2, add(r40F2, body.constant(int(1))), 0x01));


                              body.instructions = f4101_parent_instructions;
                              body.emit(f4101);

                              /* END IF */

                              body.emit(assign(r40F1, r40F2, 0x01));


                           body.instructions = f40F3_parent_instructions;
                           body.emit(f40F3);

                           /* END IF */

                           body.emit(assign(r40ED, add(r40F1, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r4105 = lequal(body.constant(int(0)), r40ED);
                           ir_if *f4104 = new(mem_ctx) ir_if(operand(r4105).val);
                           exec_list *const f4104_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4104->then_instructions;

                              body.emit(assign(r40EC, body.constant(0u), 0x01));

                              ir_variable *const r4106 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r4106, lshift(r40EB, r40ED), 0x01));

                              ir_variable *const r4107 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r4109 = equal(r40ED, body.constant(int(0)));
                              ir_if *f4108 = new(mem_ctx) ir_if(operand(r4109).val);
                              exec_list *const f4108_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f4108->then_instructions;

                                 body.emit(assign(r4107, r40EA, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f4108->else_instructions;

                                 ir_expression *const r410A = lshift(r40EA, r40ED);
                                 ir_expression *const r410B = neg(r40ED);
                                 ir_expression *const r410C = bit_and(r410B, body.constant(int(31)));
                                 ir_expression *const r410D = rshift(r40EB, r410C);
                                 body.emit(assign(r4107, bit_or(r410A, r410D), 0x01));


                              body.instructions = f4108_parent_instructions;
                              body.emit(f4108);

                              /* END IF */

                              body.emit(assign(r40EA, r4107, 0x01));

                              body.emit(assign(r40EB, r4106, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f4104->else_instructions;

                              ir_variable *const r410E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r410E, body.constant(0u), 0x01));

                              ir_variable *const r410F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r410F, neg(r40ED), 0x01));

                              ir_variable *const r4110 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r4110);
                              ir_variable *const r4111 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r4111);
                              ir_variable *const r4112 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r4112);
                              ir_variable *const r4113 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r4114 = neg(r410F);
                              body.emit(assign(r4113, bit_and(r4114, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r4116 = equal(r410F, body.constant(int(0)));
                              ir_if *f4115 = new(mem_ctx) ir_if(operand(r4116).val);
                              exec_list *const f4115_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f4115->then_instructions;

                                 body.emit(assign(r4110, r410E, 0x01));

                                 body.emit(assign(r4111, r40EB, 0x01));

                                 body.emit(assign(r4112, r40EA, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f4115->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r4118 = less(r410F, body.constant(int(32)));
                                 ir_if *f4117 = new(mem_ctx) ir_if(operand(r4118).val);
                                 exec_list *const f4117_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f4117->then_instructions;

                                    body.emit(assign(r4110, lshift(r40EB, r4113), 0x01));

                                    ir_expression *const r4119 = lshift(r40EA, r4113);
                                    ir_expression *const r411A = rshift(r40EB, r410F);
                                    body.emit(assign(r4111, bit_or(r4119, r411A), 0x01));

                                    body.emit(assign(r4112, rshift(r40EA, r410F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f4117->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r411C = equal(r410F, body.constant(int(32)));
                                    ir_if *f411B = new(mem_ctx) ir_if(operand(r411C).val);
                                    exec_list *const f411B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f411B->then_instructions;

                                       body.emit(assign(r4110, r40EB, 0x01));

                                       body.emit(assign(r4111, r40EA, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f411B->else_instructions;

                                       body.emit(assign(r410E, bit_or(body.constant(0u), r40EB), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r411E = less(r410F, body.constant(int(64)));
                                       ir_if *f411D = new(mem_ctx) ir_if(operand(r411E).val);
                                       exec_list *const f411D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f411D->then_instructions;

                                          body.emit(assign(r4110, lshift(r40EA, r4113), 0x01));

                                          ir_expression *const r411F = bit_and(r410F, body.constant(int(31)));
                                          body.emit(assign(r4111, rshift(r40EA, r411F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f411D->else_instructions;

                                          ir_variable *const r4120 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r4122 = equal(r410F, body.constant(int(64)));
                                          ir_if *f4121 = new(mem_ctx) ir_if(operand(r4122).val);
                                          exec_list *const f4121_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f4121->then_instructions;

                                             body.emit(assign(r4120, r40EA, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f4121->else_instructions;

                                             ir_expression *const r4123 = nequal(r40EA, body.constant(0u));
                                             ir_expression *const r4124 = expr(ir_unop_b2i, r4123);
                                             body.emit(assign(r4120, expr(ir_unop_i2u, r4124), 0x01));


                                          body.instructions = f4121_parent_instructions;
                                          body.emit(f4121);

                                          /* END IF */

                                          body.emit(assign(r4110, r4120, 0x01));

                                          body.emit(assign(r4111, body.constant(0u), 0x01));


                                       body.instructions = f411D_parent_instructions;
                                       body.emit(f411D);

                                       /* END IF */


                                    body.instructions = f411B_parent_instructions;
                                    body.emit(f411B);

                                    /* END IF */

                                    body.emit(assign(r4112, body.constant(0u), 0x01));


                                 body.instructions = f4117_parent_instructions;
                                 body.emit(f4117);

                                 /* END IF */

                                 ir_expression *const r4125 = nequal(r410E, body.constant(0u));
                                 ir_expression *const r4126 = expr(ir_unop_b2i, r4125);
                                 ir_expression *const r4127 = expr(ir_unop_i2u, r4126);
                                 body.emit(assign(r4110, bit_or(r4110, r4127), 0x01));


                              body.instructions = f4115_parent_instructions;
                              body.emit(f4115);

                              /* END IF */

                              body.emit(assign(r40EA, r4112, 0x01));

                              body.emit(assign(r40EB, r4111, 0x01));

                              body.emit(assign(r40EC, r4110, 0x01));


                           body.instructions = f4104_parent_instructions;
                           body.emit(f4104);

                           /* END IF */

                           body.emit(assign(r40E9, sub(r40E9, r40ED), 0x01));

                           ir_variable *const r4128 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r4128, r40E9, 0x01));

                           ir_variable *const r4129 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r4129, r40EA, 0x01));

                           ir_variable *const r412A = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r412A, r40EB, 0x01));

                           ir_variable *const r412B = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r412B, r40EC, 0x01));

                           ir_variable *const r412C = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r412C, body.constant(true), 0x01));

                           ir_variable *const r412D = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r412E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r412E);
                           ir_expression *const r412F = expr(ir_unop_u2i, r40EC);
                           body.emit(assign(r412E, less(r412F, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r4131 = lequal(body.constant(int(2045)), r40E9);
                           ir_if *f4130 = new(mem_ctx) ir_if(operand(r4131).val);
                           exec_list *const f4130_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4130->then_instructions;

                              ir_variable *const r4132 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r4134 = less(body.constant(int(2045)), r40E9);
                              ir_if *f4133 = new(mem_ctx) ir_if(operand(r4134).val);
                              exec_list *const f4133_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f4133->then_instructions;

                                 body.emit(assign(r4132, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f4133->else_instructions;

                                 ir_variable *const r4135 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r4137 = equal(r40E9, body.constant(int(2045)));
                                 ir_if *f4136 = new(mem_ctx) ir_if(operand(r4137).val);
                                 exec_list *const f4136_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f4136->then_instructions;

                                    ir_expression *const r4138 = equal(body.constant(2097151u), r40EA);
                                    ir_expression *const r4139 = equal(body.constant(4294967295u), r40EB);
                                    body.emit(assign(r4135, logic_and(r4138, r4139), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f4136->else_instructions;

                                    body.emit(assign(r4135, body.constant(false), 0x01));


                                 body.instructions = f4136_parent_instructions;
                                 body.emit(f4136);

                                 /* END IF */

                                 body.emit(assign(r4132, logic_and(r4135, r412E), 0x01));


                              body.instructions = f4133_parent_instructions;
                              body.emit(f4133);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f413A = new(mem_ctx) ir_if(operand(r4132).val);
                              exec_list *const f413A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f413A->then_instructions;

                                 ir_variable *const r413B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r413B);
                                 ir_expression *const r413C = lshift(r3D56, body.constant(int(31)));
                                 body.emit(assign(r413B, add(r413C, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r413B, body.constant(0u), 0x01));

                                 body.emit(assign(r412D, r413B, 0x03));

                                 body.emit(assign(r412C, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f413A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r413E = less(r40E9, body.constant(int(0)));
                                 ir_if *f413D = new(mem_ctx) ir_if(operand(r413E).val);
                                 exec_list *const f413D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f413D->then_instructions;

                                    ir_variable *const r413F = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r413F, r40EC, 0x01));

                                    ir_variable *const r4140 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r4140, neg(r40E9), 0x01));

                                    ir_variable *const r4141 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r4141);
                                    ir_variable *const r4142 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r4142);
                                    ir_variable *const r4143 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r4143);
                                    ir_variable *const r4144 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r4145 = neg(r4140);
                                    body.emit(assign(r4144, bit_and(r4145, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r4147 = equal(r4140, body.constant(int(0)));
                                    ir_if *f4146 = new(mem_ctx) ir_if(operand(r4147).val);
                                    exec_list *const f4146_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f4146->then_instructions;

                                       body.emit(assign(r4141, r40EC, 0x01));

                                       body.emit(assign(r4142, r40EB, 0x01));

                                       body.emit(assign(r4143, r40EA, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f4146->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r4149 = less(r4140, body.constant(int(32)));
                                       ir_if *f4148 = new(mem_ctx) ir_if(operand(r4149).val);
                                       exec_list *const f4148_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f4148->then_instructions;

                                          body.emit(assign(r4141, lshift(r40EB, r4144), 0x01));

                                          ir_expression *const r414A = lshift(r40EA, r4144);
                                          ir_expression *const r414B = rshift(r40EB, r4140);
                                          body.emit(assign(r4142, bit_or(r414A, r414B), 0x01));

                                          body.emit(assign(r4143, rshift(r40EA, r4140), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f4148->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r414D = equal(r4140, body.constant(int(32)));
                                          ir_if *f414C = new(mem_ctx) ir_if(operand(r414D).val);
                                          exec_list *const f414C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f414C->then_instructions;

                                             body.emit(assign(r4141, r40EB, 0x01));

                                             body.emit(assign(r4142, r40EA, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f414C->else_instructions;

                                             body.emit(assign(r413F, bit_or(r40EC, r40EB), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r414F = less(r4140, body.constant(int(64)));
                                             ir_if *f414E = new(mem_ctx) ir_if(operand(r414F).val);
                                             exec_list *const f414E_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f414E->then_instructions;

                                                body.emit(assign(r4141, lshift(r40EA, r4144), 0x01));

                                                ir_expression *const r4150 = bit_and(r4140, body.constant(int(31)));
                                                body.emit(assign(r4142, rshift(r40EA, r4150), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f414E->else_instructions;

                                                ir_variable *const r4151 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r4153 = equal(r4140, body.constant(int(64)));
                                                ir_if *f4152 = new(mem_ctx) ir_if(operand(r4153).val);
                                                exec_list *const f4152_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f4152->then_instructions;

                                                   body.emit(assign(r4151, r40EA, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f4152->else_instructions;

                                                   ir_expression *const r4154 = nequal(r40EA, body.constant(0u));
                                                   ir_expression *const r4155 = expr(ir_unop_b2i, r4154);
                                                   body.emit(assign(r4151, expr(ir_unop_i2u, r4155), 0x01));


                                                body.instructions = f4152_parent_instructions;
                                                body.emit(f4152);

                                                /* END IF */

                                                body.emit(assign(r4141, r4151, 0x01));

                                                body.emit(assign(r4142, body.constant(0u), 0x01));


                                             body.instructions = f414E_parent_instructions;
                                             body.emit(f414E);

                                             /* END IF */


                                          body.instructions = f414C_parent_instructions;
                                          body.emit(f414C);

                                          /* END IF */

                                          body.emit(assign(r4143, body.constant(0u), 0x01));


                                       body.instructions = f4148_parent_instructions;
                                       body.emit(f4148);

                                       /* END IF */

                                       ir_expression *const r4156 = nequal(r413F, body.constant(0u));
                                       ir_expression *const r4157 = expr(ir_unop_b2i, r4156);
                                       ir_expression *const r4158 = expr(ir_unop_i2u, r4157);
                                       body.emit(assign(r4141, bit_or(r4141, r4158), 0x01));


                                    body.instructions = f4146_parent_instructions;
                                    body.emit(f4146);

                                    /* END IF */

                                    body.emit(assign(r4129, r4143, 0x01));

                                    body.emit(assign(r412A, r4142, 0x01));

                                    body.emit(assign(r412B, r4141, 0x01));

                                    body.emit(assign(r4128, body.constant(int(0)), 0x01));

                                    body.emit(assign(r412E, less(r4141, body.constant(0u)), 0x01));


                                 body.instructions = f413D_parent_instructions;
                                 body.emit(f413D);

                                 /* END IF */


                              body.instructions = f413A_parent_instructions;
                              body.emit(f413A);

                              /* END IF */


                           body.instructions = f4130_parent_instructions;
                           body.emit(f4130);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f4159 = new(mem_ctx) ir_if(operand(r412C).val);
                           exec_list *const f4159_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4159->then_instructions;

                              /* IF CONDITION */
                              ir_if *f415A = new(mem_ctx) ir_if(operand(r412E).val);
                              exec_list *const f415A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f415A->then_instructions;

                                 ir_variable *const r415B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r415B, add(r412A, body.constant(1u)), 0x01));

                                 ir_expression *const r415C = less(r415B, r412A);
                                 ir_expression *const r415D = expr(ir_unop_b2i, r415C);
                                 ir_expression *const r415E = expr(ir_unop_i2u, r415D);
                                 body.emit(assign(r4129, add(r4129, r415E), 0x01));

                                 ir_expression *const r415F = equal(r412B, body.constant(0u));
                                 ir_expression *const r4160 = expr(ir_unop_b2i, r415F);
                                 ir_expression *const r4161 = expr(ir_unop_i2u, r4160);
                                 ir_expression *const r4162 = add(r412B, r4161);
                                 ir_expression *const r4163 = bit_and(r4162, body.constant(1u));
                                 ir_expression *const r4164 = expr(ir_unop_bit_not, r4163);
                                 body.emit(assign(r412A, bit_and(r415B, r4164), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f415A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r4166 = bit_or(r4129, r412A);
                                 ir_expression *const r4167 = equal(r4166, body.constant(0u));
                                 ir_if *f4165 = new(mem_ctx) ir_if(operand(r4167).val);
                                 exec_list *const f4165_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f4165->then_instructions;

                                    body.emit(assign(r4128, body.constant(int(0)), 0x01));


                                 body.instructions = f4165_parent_instructions;
                                 body.emit(f4165);

                                 /* END IF */


                              body.instructions = f415A_parent_instructions;
                              body.emit(f415A);

                              /* END IF */

                              ir_variable *const r4168 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r4168);
                              ir_expression *const r4169 = lshift(r3D56, body.constant(int(31)));
                              ir_expression *const r416A = expr(ir_unop_i2u, r4128);
                              ir_expression *const r416B = lshift(r416A, body.constant(int(20)));
                              ir_expression *const r416C = add(r4169, r416B);
                              body.emit(assign(r4168, add(r416C, r4129), 0x02));

                              body.emit(assign(r4168, r412A, 0x01));

                              body.emit(assign(r412D, r4168, 0x03));

                              body.emit(assign(r412C, body.constant(false), 0x01));


                           body.instructions = f4159_parent_instructions;
                           body.emit(f4159);

                           /* END IF */

                           body.emit(assign(r3D57, r412D, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f40E1->else_instructions;

                           ir_variable *const r416D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r416D);
                           body.emit(assign(r416D, body.constant(0u), 0x02));

                           body.emit(assign(r416D, body.constant(0u), 0x01));

                           body.emit(assign(r3D57, r416D, 0x03));


                        body.instructions = f40E1_parent_instructions;
                        body.emit(f40E1);

                        /* END IF */


                     body.instructions = f4055_parent_instructions;
                     body.emit(f4055);

                     /* END IF */


                  body.instructions = f3FC9_parent_instructions;
                  body.emit(f3FC9);

                  /* END IF */


               body.instructions = f3F3D_parent_instructions;
               body.emit(f3F3D);

               /* END IF */


            body.instructions = f3F16_parent_instructions;
            body.emit(f3F16);

            /* END IF */


         body.instructions = f3E40_parent_instructions;
         body.emit(f3E40);

         /* END IF */


      body.instructions = f3D6E_parent_instructions;
      body.emit(f3D6E);

      /* END IF */

      body.emit(assign(r3D51, r3D57, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3D54->else_instructions;

      ir_variable *const r416E = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r416E, body.constant(true), 0x01));

      ir_variable *const r416F = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r4170 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r4170);
      ir_variable *const r4171 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r4171);
      ir_variable *const r4172 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r4172);
      ir_variable *const r4173 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r4173);
      ir_variable *const r4174 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r4174);
      ir_variable *const r4175 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r4175);
      body.emit(assign(r4175, body.constant(0u), 0x01));

      body.emit(assign(r4174, body.constant(0u), 0x01));

      ir_variable *const r4176 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r4176);
      body.emit(assign(r4176, bit_and(swizzle_y(r33DD), body.constant(1048575u)), 0x02));

      body.emit(assign(r4176, swizzle_x(r33DD), 0x01));

      body.emit(assign(r4172, r4176, 0x03));

      ir_variable *const r4177 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r4178 = rshift(swizzle_y(r33DD), body.constant(int(20)));
      ir_expression *const r4179 = bit_and(r4178, body.constant(2047u));
      body.emit(assign(r4177, expr(ir_unop_u2i, r4179), 0x01));

      ir_variable *const r417A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r417A);
      body.emit(assign(r417A, bit_and(swizzle_y(r3B9F), body.constant(1048575u)), 0x02));

      body.emit(assign(r417A, swizzle_x(r3B9F), 0x01));

      body.emit(assign(r4171, r417A, 0x03));

      ir_variable *const r417B = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r417C = rshift(swizzle_y(r3B9F), body.constant(int(20)));
      ir_expression *const r417D = bit_and(r417C, body.constant(2047u));
      body.emit(assign(r417B, expr(ir_unop_u2i, r417D), 0x01));

      ir_variable *const r417E = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r417E, sub(r4177, r417B), 0x01));

      body.emit(assign(r4170, r417E, 0x01));

      /* IF CONDITION */
      ir_expression *const r4180 = less(body.constant(int(0)), r417E);
      ir_if *f417F = new(mem_ctx) ir_if(operand(r4180).val);
      exec_list *const f417F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f417F->then_instructions;

         /* IF CONDITION */
         ir_expression *const r4182 = equal(r4177, body.constant(int(2047)));
         ir_if *f4181 = new(mem_ctx) ir_if(operand(r4182).val);
         exec_list *const f4181_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f4181->then_instructions;

            /* IF CONDITION */
            ir_expression *const r4184 = bit_or(swizzle_y(r4176), swizzle_x(r33DD));
            ir_expression *const r4185 = nequal(r4184, body.constant(0u));
            ir_if *f4183 = new(mem_ctx) ir_if(operand(r4185).val);
            exec_list *const f4183_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f4183->then_instructions;

               ir_variable *const r4186 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r4186, swizzle_x(r33DD), 0x01));

               ir_variable *const r4187 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r4187, swizzle_x(r3B9F), 0x01));

               ir_variable *const r4188 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r4189 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r418A = rshift(swizzle_y(r33DD), body.constant(int(19)));
               ir_expression *const r418B = bit_and(r418A, body.constant(4095u));
               ir_expression *const r418C = equal(r418B, body.constant(4094u));
               ir_expression *const r418D = nequal(swizzle_x(r33DD), body.constant(0u));
               ir_expression *const r418E = bit_and(swizzle_y(r33DD), body.constant(524287u));
               ir_expression *const r418F = nequal(r418E, body.constant(0u));
               ir_expression *const r4190 = logic_or(r418D, r418F);
               body.emit(assign(r4189, logic_and(r418C, r4190), 0x01));

               ir_variable *const r4191 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r4192 = lshift(swizzle_y(r3B9F), body.constant(int(1)));
               ir_expression *const r4193 = lequal(body.constant(4292870144u), r4192);
               ir_expression *const r4194 = nequal(swizzle_x(r3B9F), body.constant(0u));
               ir_expression *const r4195 = bit_and(swizzle_y(r3B9F), body.constant(1048575u));
               ir_expression *const r4196 = nequal(r4195, body.constant(0u));
               ir_expression *const r4197 = logic_or(r4194, r4196);
               body.emit(assign(r4191, logic_and(r4193, r4197), 0x01));

               body.emit(assign(r4186, bit_or(swizzle_y(r33DD), body.constant(524288u)), 0x02));

               body.emit(assign(r4187, bit_or(swizzle_y(r3B9F), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r4199 = lshift(swizzle_y(r33DD), body.constant(int(1)));
               ir_expression *const r419A = lequal(body.constant(4292870144u), r4199);
               ir_expression *const r419B = nequal(swizzle_x(r33DD), body.constant(0u));
               ir_expression *const r419C = bit_and(swizzle_y(r33DD), body.constant(1048575u));
               ir_expression *const r419D = nequal(r419C, body.constant(0u));
               ir_expression *const r419E = logic_or(r419B, r419D);
               ir_expression *const r419F = logic_and(r419A, r419E);
               ir_if *f4198 = new(mem_ctx) ir_if(operand(r419F).val);
               exec_list *const f4198_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4198->then_instructions;

                  ir_variable *const r41A0 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r41A2 = logic_and(r4189, r4191);
                  ir_if *f41A1 = new(mem_ctx) ir_if(operand(r41A2).val);
                  exec_list *const f41A1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f41A1->then_instructions;

                     body.emit(assign(r41A0, r4187, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f41A1->else_instructions;

                     body.emit(assign(r41A0, r4186, 0x03));


                  body.instructions = f41A1_parent_instructions;
                  body.emit(f41A1);

                  /* END IF */

                  body.emit(assign(r4188, r41A0, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4198->else_instructions;

                  body.emit(assign(r4188, r4187, 0x03));


               body.instructions = f4198_parent_instructions;
               body.emit(f4198);

               /* END IF */

               body.emit(assign(r416F, r4188, 0x03));

               body.emit(assign(r416E, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f4183->else_instructions;

               body.emit(assign(r416F, r33DD, 0x03));

               body.emit(assign(r416E, body.constant(false), 0x01));


            body.instructions = f4183_parent_instructions;
            body.emit(f4183);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f4181->else_instructions;

            /* IF CONDITION */
            ir_expression *const r41A4 = equal(r417B, body.constant(int(0)));
            ir_if *f41A3 = new(mem_ctx) ir_if(operand(r41A4).val);
            exec_list *const f41A3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f41A3->then_instructions;

               body.emit(assign(r4170, add(r417E, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f41A3->else_instructions;

               body.emit(assign(r4171, bit_or(swizzle_y(r417A), body.constant(1048576u)), 0x02));


            body.instructions = f41A3_parent_instructions;
            body.emit(f41A3);

            /* END IF */

            ir_variable *const r41A5 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r41A5, swizzle_y(r4171), 0x01));

            ir_variable *const r41A6 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r41A6, swizzle_x(r4171), 0x01));

            ir_variable *const r41A7 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r41A7, body.constant(0u), 0x01));

            ir_variable *const r41A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r41A8);
            ir_variable *const r41A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r41A9);
            ir_variable *const r41AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r41AA);
            ir_variable *const r41AB = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r41AC = neg(r4170);
            body.emit(assign(r41AB, bit_and(r41AC, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r41AE = equal(r4170, body.constant(int(0)));
            ir_if *f41AD = new(mem_ctx) ir_if(operand(r41AE).val);
            exec_list *const f41AD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f41AD->then_instructions;

               body.emit(assign(r41A8, r41A7, 0x01));

               body.emit(assign(r41A9, r41A6, 0x01));

               body.emit(assign(r41AA, r41A5, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f41AD->else_instructions;

               /* IF CONDITION */
               ir_expression *const r41B0 = less(r4170, body.constant(int(32)));
               ir_if *f41AF = new(mem_ctx) ir_if(operand(r41B0).val);
               exec_list *const f41AF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f41AF->then_instructions;

                  body.emit(assign(r41A8, lshift(swizzle_x(r417A), r41AB), 0x01));

                  ir_expression *const r41B1 = lshift(swizzle_y(r4171), r41AB);
                  ir_expression *const r41B2 = rshift(swizzle_x(r417A), r4170);
                  body.emit(assign(r41A9, bit_or(r41B1, r41B2), 0x01));

                  body.emit(assign(r41AA, rshift(swizzle_y(r4171), r4170), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f41AF->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r41B4 = equal(r4170, body.constant(int(32)));
                  ir_if *f41B3 = new(mem_ctx) ir_if(operand(r41B4).val);
                  exec_list *const f41B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f41B3->then_instructions;

                     body.emit(assign(r41A8, r41A6, 0x01));

                     body.emit(assign(r41A9, r41A5, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f41B3->else_instructions;

                     body.emit(assign(r41A7, bit_or(body.constant(0u), swizzle_x(r417A)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r41B6 = less(r4170, body.constant(int(64)));
                     ir_if *f41B5 = new(mem_ctx) ir_if(operand(r41B6).val);
                     exec_list *const f41B5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f41B5->then_instructions;

                        body.emit(assign(r41A8, lshift(swizzle_y(r4171), r41AB), 0x01));

                        ir_expression *const r41B7 = bit_and(r4170, body.constant(int(31)));
                        body.emit(assign(r41A9, rshift(swizzle_y(r4171), r41B7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f41B5->else_instructions;

                        ir_variable *const r41B8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r41BA = equal(r4170, body.constant(int(64)));
                        ir_if *f41B9 = new(mem_ctx) ir_if(operand(r41BA).val);
                        exec_list *const f41B9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f41B9->then_instructions;

                           body.emit(assign(r41B8, r41A5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f41B9->else_instructions;

                           ir_expression *const r41BB = nequal(swizzle_y(r4171), body.constant(0u));
                           ir_expression *const r41BC = expr(ir_unop_b2i, r41BB);
                           body.emit(assign(r41B8, expr(ir_unop_i2u, r41BC), 0x01));


                        body.instructions = f41B9_parent_instructions;
                        body.emit(f41B9);

                        /* END IF */

                        body.emit(assign(r41A8, r41B8, 0x01));

                        body.emit(assign(r41A9, body.constant(0u), 0x01));


                     body.instructions = f41B5_parent_instructions;
                     body.emit(f41B5);

                     /* END IF */


                  body.instructions = f41B3_parent_instructions;
                  body.emit(f41B3);

                  /* END IF */

                  body.emit(assign(r41AA, body.constant(0u), 0x01));


               body.instructions = f41AF_parent_instructions;
               body.emit(f41AF);

               /* END IF */

               ir_expression *const r41BD = nequal(r41A7, body.constant(0u));
               ir_expression *const r41BE = expr(ir_unop_b2i, r41BD);
               ir_expression *const r41BF = expr(ir_unop_i2u, r41BE);
               body.emit(assign(r41A8, bit_or(r41A8, r41BF), 0x01));


            body.instructions = f41AD_parent_instructions;
            body.emit(f41AD);

            /* END IF */

            body.emit(assign(r4171, r41AA, 0x02));

            body.emit(assign(r4171, r41A9, 0x01));

            body.emit(assign(r4174, r41A8, 0x01));

            body.emit(assign(r4173, r4177, 0x01));


         body.instructions = f4181_parent_instructions;
         body.emit(f4181);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f417F->else_instructions;

         /* IF CONDITION */
         ir_expression *const r41C1 = less(r4170, body.constant(int(0)));
         ir_if *f41C0 = new(mem_ctx) ir_if(operand(r41C1).val);
         exec_list *const f41C0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f41C0->then_instructions;

            /* IF CONDITION */
            ir_expression *const r41C3 = equal(r417B, body.constant(int(2047)));
            ir_if *f41C2 = new(mem_ctx) ir_if(operand(r41C3).val);
            exec_list *const f41C2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f41C2->then_instructions;

               /* IF CONDITION */
               ir_expression *const r41C5 = bit_or(swizzle_y(r4171), swizzle_x(r4171));
               ir_expression *const r41C6 = nequal(r41C5, body.constant(0u));
               ir_if *f41C4 = new(mem_ctx) ir_if(operand(r41C6).val);
               exec_list *const f41C4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f41C4->then_instructions;

                  ir_variable *const r41C7 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r41C7, swizzle_x(r33DD), 0x01));

                  ir_variable *const r41C8 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r41C8, swizzle_x(r3B9F), 0x01));

                  ir_variable *const r41C9 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r41CA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r41CB = rshift(swizzle_y(r33DD), body.constant(int(19)));
                  ir_expression *const r41CC = bit_and(r41CB, body.constant(4095u));
                  ir_expression *const r41CD = equal(r41CC, body.constant(4094u));
                  ir_expression *const r41CE = nequal(swizzle_x(r33DD), body.constant(0u));
                  ir_expression *const r41CF = bit_and(swizzle_y(r33DD), body.constant(524287u));
                  ir_expression *const r41D0 = nequal(r41CF, body.constant(0u));
                  ir_expression *const r41D1 = logic_or(r41CE, r41D0);
                  body.emit(assign(r41CA, logic_and(r41CD, r41D1), 0x01));

                  ir_variable *const r41D2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r41D3 = lshift(swizzle_y(r3B9F), body.constant(int(1)));
                  ir_expression *const r41D4 = lequal(body.constant(4292870144u), r41D3);
                  ir_expression *const r41D5 = nequal(swizzle_x(r3B9F), body.constant(0u));
                  ir_expression *const r41D6 = bit_and(swizzle_y(r3B9F), body.constant(1048575u));
                  ir_expression *const r41D7 = nequal(r41D6, body.constant(0u));
                  ir_expression *const r41D8 = logic_or(r41D5, r41D7);
                  body.emit(assign(r41D2, logic_and(r41D4, r41D8), 0x01));

                  body.emit(assign(r41C7, bit_or(swizzle_y(r33DD), body.constant(524288u)), 0x02));

                  body.emit(assign(r41C8, bit_or(swizzle_y(r3B9F), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r41DA = lshift(swizzle_y(r33DD), body.constant(int(1)));
                  ir_expression *const r41DB = lequal(body.constant(4292870144u), r41DA);
                  ir_expression *const r41DC = nequal(swizzle_x(r33DD), body.constant(0u));
                  ir_expression *const r41DD = bit_and(swizzle_y(r33DD), body.constant(1048575u));
                  ir_expression *const r41DE = nequal(r41DD, body.constant(0u));
                  ir_expression *const r41DF = logic_or(r41DC, r41DE);
                  ir_expression *const r41E0 = logic_and(r41DB, r41DF);
                  ir_if *f41D9 = new(mem_ctx) ir_if(operand(r41E0).val);
                  exec_list *const f41D9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f41D9->then_instructions;

                     ir_variable *const r41E1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r41E3 = logic_and(r41CA, r41D2);
                     ir_if *f41E2 = new(mem_ctx) ir_if(operand(r41E3).val);
                     exec_list *const f41E2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f41E2->then_instructions;

                        body.emit(assign(r41E1, r41C8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f41E2->else_instructions;

                        body.emit(assign(r41E1, r41C7, 0x03));


                     body.instructions = f41E2_parent_instructions;
                     body.emit(f41E2);

                     /* END IF */

                     body.emit(assign(r41C9, r41E1, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f41D9->else_instructions;

                     body.emit(assign(r41C9, r41C8, 0x03));


                  body.instructions = f41D9_parent_instructions;
                  body.emit(f41D9);

                  /* END IF */

                  body.emit(assign(r416F, r41C9, 0x03));

                  body.emit(assign(r416E, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f41C4->else_instructions;

                  ir_variable *const r41E4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r41E4);
                  ir_expression *const r41E5 = lshift(r3D52, body.constant(int(31)));
                  body.emit(assign(r41E4, add(r41E5, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r41E4, body.constant(0u), 0x01));

                  body.emit(assign(r416F, r41E4, 0x03));

                  body.emit(assign(r416E, body.constant(false), 0x01));


               body.instructions = f41C4_parent_instructions;
               body.emit(f41C4);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f41C2->else_instructions;

               /* IF CONDITION */
               ir_expression *const r41E7 = equal(r4177, body.constant(int(0)));
               ir_if *f41E6 = new(mem_ctx) ir_if(operand(r41E7).val);
               exec_list *const f41E6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f41E6->then_instructions;

                  body.emit(assign(r4170, add(r4170, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f41E6->else_instructions;

                  body.emit(assign(r4172, bit_or(swizzle_y(r4176), body.constant(1048576u)), 0x02));


               body.instructions = f41E6_parent_instructions;
               body.emit(f41E6);

               /* END IF */

               ir_variable *const r41E8 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r41E8, swizzle_y(r4172), 0x01));

               ir_variable *const r41E9 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r41E9, swizzle_x(r4172), 0x01));

               ir_variable *const r41EA = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r41EA, body.constant(0u), 0x01));

               ir_variable *const r41EB = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r41EB, neg(r4170), 0x01));

               ir_variable *const r41EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r41EC);
               ir_variable *const r41ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r41ED);
               ir_variable *const r41EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r41EE);
               ir_variable *const r41EF = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r41F0 = neg(r41EB);
               body.emit(assign(r41EF, bit_and(r41F0, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r41F2 = equal(r41EB, body.constant(int(0)));
               ir_if *f41F1 = new(mem_ctx) ir_if(operand(r41F2).val);
               exec_list *const f41F1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f41F1->then_instructions;

                  body.emit(assign(r41EC, r41EA, 0x01));

                  body.emit(assign(r41ED, r41E9, 0x01));

                  body.emit(assign(r41EE, r41E8, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f41F1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r41F4 = less(r41EB, body.constant(int(32)));
                  ir_if *f41F3 = new(mem_ctx) ir_if(operand(r41F4).val);
                  exec_list *const f41F3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f41F3->then_instructions;

                     body.emit(assign(r41EC, lshift(swizzle_x(r4176), r41EF), 0x01));

                     ir_expression *const r41F5 = lshift(swizzle_y(r4172), r41EF);
                     ir_expression *const r41F6 = rshift(swizzle_x(r4176), r41EB);
                     body.emit(assign(r41ED, bit_or(r41F5, r41F6), 0x01));

                     body.emit(assign(r41EE, rshift(swizzle_y(r4172), r41EB), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f41F3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r41F8 = equal(r41EB, body.constant(int(32)));
                     ir_if *f41F7 = new(mem_ctx) ir_if(operand(r41F8).val);
                     exec_list *const f41F7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f41F7->then_instructions;

                        body.emit(assign(r41EC, r41E9, 0x01));

                        body.emit(assign(r41ED, r41E8, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f41F7->else_instructions;

                        body.emit(assign(r41EA, bit_or(body.constant(0u), swizzle_x(r4176)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r41FA = less(r41EB, body.constant(int(64)));
                        ir_if *f41F9 = new(mem_ctx) ir_if(operand(r41FA).val);
                        exec_list *const f41F9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f41F9->then_instructions;

                           body.emit(assign(r41EC, lshift(swizzle_y(r4172), r41EF), 0x01));

                           ir_expression *const r41FB = bit_and(r41EB, body.constant(int(31)));
                           body.emit(assign(r41ED, rshift(swizzle_y(r4172), r41FB), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f41F9->else_instructions;

                           ir_variable *const r41FC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r41FE = equal(r41EB, body.constant(int(64)));
                           ir_if *f41FD = new(mem_ctx) ir_if(operand(r41FE).val);
                           exec_list *const f41FD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f41FD->then_instructions;

                              body.emit(assign(r41FC, r41E8, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f41FD->else_instructions;

                              ir_expression *const r41FF = nequal(swizzle_y(r4172), body.constant(0u));
                              ir_expression *const r4200 = expr(ir_unop_b2i, r41FF);
                              body.emit(assign(r41FC, expr(ir_unop_i2u, r4200), 0x01));


                           body.instructions = f41FD_parent_instructions;
                           body.emit(f41FD);

                           /* END IF */

                           body.emit(assign(r41EC, r41FC, 0x01));

                           body.emit(assign(r41ED, body.constant(0u), 0x01));


                        body.instructions = f41F9_parent_instructions;
                        body.emit(f41F9);

                        /* END IF */


                     body.instructions = f41F7_parent_instructions;
                     body.emit(f41F7);

                     /* END IF */

                     body.emit(assign(r41EE, body.constant(0u), 0x01));


                  body.instructions = f41F3_parent_instructions;
                  body.emit(f41F3);

                  /* END IF */

                  ir_expression *const r4201 = nequal(r41EA, body.constant(0u));
                  ir_expression *const r4202 = expr(ir_unop_b2i, r4201);
                  ir_expression *const r4203 = expr(ir_unop_i2u, r4202);
                  body.emit(assign(r41EC, bit_or(r41EC, r4203), 0x01));


               body.instructions = f41F1_parent_instructions;
               body.emit(f41F1);

               /* END IF */

               body.emit(assign(r4172, r41EE, 0x02));

               body.emit(assign(r4172, r41ED, 0x01));

               body.emit(assign(r4174, r41EC, 0x01));

               body.emit(assign(r4173, r417B, 0x01));


            body.instructions = f41C2_parent_instructions;
            body.emit(f41C2);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f41C0->else_instructions;

            /* IF CONDITION */
            ir_expression *const r4205 = equal(r4177, body.constant(int(2047)));
            ir_if *f4204 = new(mem_ctx) ir_if(operand(r4205).val);
            exec_list *const f4204_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f4204->then_instructions;

               /* IF CONDITION */
               ir_expression *const r4207 = bit_or(swizzle_y(r4172), swizzle_x(r4172));
               ir_expression *const r4208 = bit_or(swizzle_y(r4171), swizzle_x(r4171));
               ir_expression *const r4209 = bit_or(r4207, r4208);
               ir_expression *const r420A = nequal(r4209, body.constant(0u));
               ir_if *f4206 = new(mem_ctx) ir_if(operand(r420A).val);
               exec_list *const f4206_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4206->then_instructions;

                  ir_variable *const r420B = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r420B, swizzle_x(r33DD), 0x01));

                  ir_variable *const r420C = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r420C, swizzle_x(r3B9F), 0x01));

                  ir_variable *const r420D = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r420E = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r420F = rshift(swizzle_y(r33DD), body.constant(int(19)));
                  ir_expression *const r4210 = bit_and(r420F, body.constant(4095u));
                  ir_expression *const r4211 = equal(r4210, body.constant(4094u));
                  ir_expression *const r4212 = nequal(swizzle_x(r33DD), body.constant(0u));
                  ir_expression *const r4213 = bit_and(swizzle_y(r33DD), body.constant(524287u));
                  ir_expression *const r4214 = nequal(r4213, body.constant(0u));
                  ir_expression *const r4215 = logic_or(r4212, r4214);
                  body.emit(assign(r420E, logic_and(r4211, r4215), 0x01));

                  ir_variable *const r4216 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r4217 = lshift(swizzle_y(r3B9F), body.constant(int(1)));
                  ir_expression *const r4218 = lequal(body.constant(4292870144u), r4217);
                  ir_expression *const r4219 = nequal(swizzle_x(r3B9F), body.constant(0u));
                  ir_expression *const r421A = bit_and(swizzle_y(r3B9F), body.constant(1048575u));
                  ir_expression *const r421B = nequal(r421A, body.constant(0u));
                  ir_expression *const r421C = logic_or(r4219, r421B);
                  body.emit(assign(r4216, logic_and(r4218, r421C), 0x01));

                  body.emit(assign(r420B, bit_or(swizzle_y(r33DD), body.constant(524288u)), 0x02));

                  body.emit(assign(r420C, bit_or(swizzle_y(r3B9F), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r421E = lshift(swizzle_y(r33DD), body.constant(int(1)));
                  ir_expression *const r421F = lequal(body.constant(4292870144u), r421E);
                  ir_expression *const r4220 = nequal(swizzle_x(r33DD), body.constant(0u));
                  ir_expression *const r4221 = bit_and(swizzle_y(r33DD), body.constant(1048575u));
                  ir_expression *const r4222 = nequal(r4221, body.constant(0u));
                  ir_expression *const r4223 = logic_or(r4220, r4222);
                  ir_expression *const r4224 = logic_and(r421F, r4223);
                  ir_if *f421D = new(mem_ctx) ir_if(operand(r4224).val);
                  exec_list *const f421D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f421D->then_instructions;

                     ir_variable *const r4225 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r4227 = logic_and(r420E, r4216);
                     ir_if *f4226 = new(mem_ctx) ir_if(operand(r4227).val);
                     exec_list *const f4226_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4226->then_instructions;

                        body.emit(assign(r4225, r420C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4226->else_instructions;

                        body.emit(assign(r4225, r420B, 0x03));


                     body.instructions = f4226_parent_instructions;
                     body.emit(f4226);

                     /* END IF */

                     body.emit(assign(r420D, r4225, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f421D->else_instructions;

                     body.emit(assign(r420D, r420C, 0x03));


                  body.instructions = f421D_parent_instructions;
                  body.emit(f421D);

                  /* END IF */

                  body.emit(assign(r416F, r420D, 0x03));

                  body.emit(assign(r416E, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4206->else_instructions;

                  body.emit(assign(r416F, r33DD, 0x03));

                  body.emit(assign(r416E, body.constant(false), 0x01));


               body.instructions = f4206_parent_instructions;
               body.emit(f4206);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f4204->else_instructions;

               ir_variable *const r4228 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r4229 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r4229, add(swizzle_x(r4172), swizzle_x(r4171)), 0x01));

               ir_expression *const r422A = add(swizzle_y(r4172), swizzle_y(r4171));
               ir_expression *const r422B = less(r4229, swizzle_x(r4172));
               ir_expression *const r422C = expr(ir_unop_b2i, r422B);
               ir_expression *const r422D = expr(ir_unop_i2u, r422C);
               body.emit(assign(r4228, add(r422A, r422D), 0x01));

               body.emit(assign(r4175, r4228, 0x01));

               /* IF CONDITION */
               ir_expression *const r422F = equal(r4177, body.constant(int(0)));
               ir_if *f422E = new(mem_ctx) ir_if(operand(r422F).val);
               exec_list *const f422E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f422E->then_instructions;

                  ir_variable *const r4230 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r4230);
                  ir_expression *const r4231 = lshift(r3D52, body.constant(int(31)));
                  body.emit(assign(r4230, add(r4231, r4228), 0x02));

                  body.emit(assign(r4230, r4229, 0x01));

                  body.emit(assign(r416F, r4230, 0x03));

                  body.emit(assign(r416E, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f422E->else_instructions;

                  body.emit(assign(r4175, bit_or(r4228, body.constant(2097152u)), 0x01));

                  body.emit(assign(r4173, r4177, 0x01));

                  ir_variable *const r4232 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r4232);
                  ir_variable *const r4233 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r4233);
                  ir_variable *const r4234 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r4234);
                  body.emit(assign(r4232, lshift(r4229, body.constant(int(31))), 0x01));

                  ir_expression *const r4235 = lshift(r4175, body.constant(int(31)));
                  ir_expression *const r4236 = rshift(r4229, body.constant(int(1)));
                  body.emit(assign(r4233, bit_or(r4235, r4236), 0x01));

                  body.emit(assign(r4234, rshift(r4175, body.constant(int(1))), 0x01));

                  body.emit(assign(r4232, bit_or(r4232, body.constant(0u)), 0x01));

                  body.emit(assign(r4175, r4234, 0x01));

                  body.emit(assign(r4174, r4232, 0x01));

                  ir_variable *const r4237 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r4237, r4177, 0x01));

                  ir_variable *const r4238 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r4238, r4234, 0x01));

                  ir_variable *const r4239 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r4239, r4233, 0x01));

                  ir_variable *const r423A = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r423A, r4232, 0x01));

                  ir_variable *const r423B = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r423B, body.constant(true), 0x01));

                  ir_variable *const r423C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r423D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r423D);
                  ir_expression *const r423E = expr(ir_unop_u2i, r4232);
                  body.emit(assign(r423D, less(r423E, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r4240 = lequal(body.constant(int(2045)), r4177);
                  ir_if *f423F = new(mem_ctx) ir_if(operand(r4240).val);
                  exec_list *const f423F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f423F->then_instructions;

                     ir_variable *const r4241 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r4243 = less(body.constant(int(2045)), r4177);
                     ir_if *f4242 = new(mem_ctx) ir_if(operand(r4243).val);
                     exec_list *const f4242_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4242->then_instructions;

                        body.emit(assign(r4241, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4242->else_instructions;

                        ir_variable *const r4244 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r4246 = equal(r4177, body.constant(int(2045)));
                        ir_if *f4245 = new(mem_ctx) ir_if(operand(r4246).val);
                        exec_list *const f4245_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4245->then_instructions;

                           ir_expression *const r4247 = equal(body.constant(2097151u), r4234);
                           ir_expression *const r4248 = equal(body.constant(4294967295u), r4233);
                           body.emit(assign(r4244, logic_and(r4247, r4248), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f4245->else_instructions;

                           body.emit(assign(r4244, body.constant(false), 0x01));


                        body.instructions = f4245_parent_instructions;
                        body.emit(f4245);

                        /* END IF */

                        body.emit(assign(r4241, logic_and(r4244, r423D), 0x01));


                     body.instructions = f4242_parent_instructions;
                     body.emit(f4242);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f4249 = new(mem_ctx) ir_if(operand(r4241).val);
                     exec_list *const f4249_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4249->then_instructions;

                        ir_variable *const r424A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r424A);
                        ir_expression *const r424B = lshift(r3D52, body.constant(int(31)));
                        body.emit(assign(r424A, add(r424B, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r424A, body.constant(0u), 0x01));

                        body.emit(assign(r423C, r424A, 0x03));

                        body.emit(assign(r423B, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4249->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r424D = less(r4177, body.constant(int(0)));
                        ir_if *f424C = new(mem_ctx) ir_if(operand(r424D).val);
                        exec_list *const f424C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f424C->then_instructions;

                           ir_variable *const r424E = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r424E, r4232, 0x01));

                           ir_variable *const r424F = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r424F, neg(r4177), 0x01));

                           ir_variable *const r4250 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r4250);
                           ir_variable *const r4251 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r4251);
                           ir_variable *const r4252 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r4252);
                           ir_variable *const r4253 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r4254 = neg(r424F);
                           body.emit(assign(r4253, bit_and(r4254, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r4256 = equal(r424F, body.constant(int(0)));
                           ir_if *f4255 = new(mem_ctx) ir_if(operand(r4256).val);
                           exec_list *const f4255_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4255->then_instructions;

                              body.emit(assign(r4250, r4232, 0x01));

                              body.emit(assign(r4251, r4233, 0x01));

                              body.emit(assign(r4252, r4234, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f4255->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r4258 = less(r424F, body.constant(int(32)));
                              ir_if *f4257 = new(mem_ctx) ir_if(operand(r4258).val);
                              exec_list *const f4257_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f4257->then_instructions;

                                 body.emit(assign(r4250, lshift(r4233, r4253), 0x01));

                                 ir_expression *const r4259 = lshift(r4234, r4253);
                                 ir_expression *const r425A = rshift(r4233, r424F);
                                 body.emit(assign(r4251, bit_or(r4259, r425A), 0x01));

                                 body.emit(assign(r4252, rshift(r4234, r424F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f4257->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r425C = equal(r424F, body.constant(int(32)));
                                 ir_if *f425B = new(mem_ctx) ir_if(operand(r425C).val);
                                 exec_list *const f425B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f425B->then_instructions;

                                    body.emit(assign(r4250, r4233, 0x01));

                                    body.emit(assign(r4251, r4234, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f425B->else_instructions;

                                    body.emit(assign(r424E, bit_or(r4232, r4233), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r425E = less(r424F, body.constant(int(64)));
                                    ir_if *f425D = new(mem_ctx) ir_if(operand(r425E).val);
                                    exec_list *const f425D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f425D->then_instructions;

                                       body.emit(assign(r4250, lshift(r4234, r4253), 0x01));

                                       ir_expression *const r425F = bit_and(r424F, body.constant(int(31)));
                                       body.emit(assign(r4251, rshift(r4234, r425F), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f425D->else_instructions;

                                       ir_variable *const r4260 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r4262 = equal(r424F, body.constant(int(64)));
                                       ir_if *f4261 = new(mem_ctx) ir_if(operand(r4262).val);
                                       exec_list *const f4261_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f4261->then_instructions;

                                          body.emit(assign(r4260, r4234, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f4261->else_instructions;

                                          ir_expression *const r4263 = nequal(r4234, body.constant(0u));
                                          ir_expression *const r4264 = expr(ir_unop_b2i, r4263);
                                          body.emit(assign(r4260, expr(ir_unop_i2u, r4264), 0x01));


                                       body.instructions = f4261_parent_instructions;
                                       body.emit(f4261);

                                       /* END IF */

                                       body.emit(assign(r4250, r4260, 0x01));

                                       body.emit(assign(r4251, body.constant(0u), 0x01));


                                    body.instructions = f425D_parent_instructions;
                                    body.emit(f425D);

                                    /* END IF */


                                 body.instructions = f425B_parent_instructions;
                                 body.emit(f425B);

                                 /* END IF */

                                 body.emit(assign(r4252, body.constant(0u), 0x01));


                              body.instructions = f4257_parent_instructions;
                              body.emit(f4257);

                              /* END IF */

                              ir_expression *const r4265 = nequal(r424E, body.constant(0u));
                              ir_expression *const r4266 = expr(ir_unop_b2i, r4265);
                              ir_expression *const r4267 = expr(ir_unop_i2u, r4266);
                              body.emit(assign(r4250, bit_or(r4250, r4267), 0x01));


                           body.instructions = f4255_parent_instructions;
                           body.emit(f4255);

                           /* END IF */

                           body.emit(assign(r4238, r4252, 0x01));

                           body.emit(assign(r4239, r4251, 0x01));

                           body.emit(assign(r423A, r4250, 0x01));

                           body.emit(assign(r4237, body.constant(int(0)), 0x01));

                           body.emit(assign(r423D, less(r4250, body.constant(0u)), 0x01));


                        body.instructions = f424C_parent_instructions;
                        body.emit(f424C);

                        /* END IF */


                     body.instructions = f4249_parent_instructions;
                     body.emit(f4249);

                     /* END IF */


                  body.instructions = f423F_parent_instructions;
                  body.emit(f423F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f4268 = new(mem_ctx) ir_if(operand(r423B).val);
                  exec_list *const f4268_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4268->then_instructions;

                     /* IF CONDITION */
                     ir_if *f4269 = new(mem_ctx) ir_if(operand(r423D).val);
                     exec_list *const f4269_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4269->then_instructions;

                        ir_variable *const r426A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r426A, add(r4239, body.constant(1u)), 0x01));

                        ir_expression *const r426B = less(r426A, r4239);
                        ir_expression *const r426C = expr(ir_unop_b2i, r426B);
                        ir_expression *const r426D = expr(ir_unop_i2u, r426C);
                        body.emit(assign(r4238, add(r4238, r426D), 0x01));

                        ir_expression *const r426E = equal(r423A, body.constant(0u));
                        ir_expression *const r426F = expr(ir_unop_b2i, r426E);
                        ir_expression *const r4270 = expr(ir_unop_i2u, r426F);
                        ir_expression *const r4271 = add(r423A, r4270);
                        ir_expression *const r4272 = bit_and(r4271, body.constant(1u));
                        ir_expression *const r4273 = expr(ir_unop_bit_not, r4272);
                        body.emit(assign(r4239, bit_and(r426A, r4273), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4269->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r4275 = bit_or(r4238, r4239);
                        ir_expression *const r4276 = equal(r4275, body.constant(0u));
                        ir_if *f4274 = new(mem_ctx) ir_if(operand(r4276).val);
                        exec_list *const f4274_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4274->then_instructions;

                           body.emit(assign(r4237, body.constant(int(0)), 0x01));


                        body.instructions = f4274_parent_instructions;
                        body.emit(f4274);

                        /* END IF */


                     body.instructions = f4269_parent_instructions;
                     body.emit(f4269);

                     /* END IF */

                     ir_variable *const r4277 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r4277);
                     ir_expression *const r4278 = lshift(r3D52, body.constant(int(31)));
                     ir_expression *const r4279 = expr(ir_unop_i2u, r4237);
                     ir_expression *const r427A = lshift(r4279, body.constant(int(20)));
                     ir_expression *const r427B = add(r4278, r427A);
                     body.emit(assign(r4277, add(r427B, r4238), 0x02));

                     body.emit(assign(r4277, r4239, 0x01));

                     body.emit(assign(r423C, r4277, 0x03));

                     body.emit(assign(r423B, body.constant(false), 0x01));


                  body.instructions = f4268_parent_instructions;
                  body.emit(f4268);

                  /* END IF */

                  body.emit(assign(r416F, r423C, 0x03));

                  body.emit(assign(r416E, body.constant(false), 0x01));


               body.instructions = f422E_parent_instructions;
               body.emit(f422E);

               /* END IF */


            body.instructions = f4204_parent_instructions;
            body.emit(f4204);

            /* END IF */


         body.instructions = f41C0_parent_instructions;
         body.emit(f41C0);

         /* END IF */


      body.instructions = f417F_parent_instructions;
      body.emit(f417F);

      /* END IF */

      /* IF CONDITION */
      ir_if *f427C = new(mem_ctx) ir_if(operand(r416E).val);
      exec_list *const f427C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f427C->then_instructions;

         body.emit(assign(r4172, bit_or(swizzle_y(r4172), body.constant(1048576u)), 0x02));

         ir_variable *const r427D = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r427E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r427E, add(swizzle_x(r4172), swizzle_x(r4171)), 0x01));

         ir_expression *const r427F = add(swizzle_y(r4172), swizzle_y(r4171));
         ir_expression *const r4280 = less(r427E, swizzle_x(r4172));
         ir_expression *const r4281 = expr(ir_unop_b2i, r4280);
         ir_expression *const r4282 = expr(ir_unop_i2u, r4281);
         body.emit(assign(r427D, add(r427F, r4282), 0x01));

         body.emit(assign(r4175, r427D, 0x01));

         body.emit(assign(r4173, add(r4173, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r4284 = less(r427D, body.constant(2097152u));
         ir_if *f4283 = new(mem_ctx) ir_if(operand(r4284).val);
         exec_list *const f4283_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f4283->then_instructions;

            ir_variable *const r4285 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r4285, r4173, 0x01));

            ir_variable *const r4286 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r4286, r427D, 0x01));

            ir_variable *const r4287 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r4287, r427E, 0x01));

            ir_variable *const r4288 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r4288, r4174, 0x01));

            ir_variable *const r4289 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r4289, body.constant(true), 0x01));

            ir_variable *const r428A = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r428B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r428B);
            ir_expression *const r428C = expr(ir_unop_u2i, r4174);
            body.emit(assign(r428B, less(r428C, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r428E = lequal(body.constant(int(2045)), r4173);
            ir_if *f428D = new(mem_ctx) ir_if(operand(r428E).val);
            exec_list *const f428D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f428D->then_instructions;

               ir_variable *const r428F = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r4291 = less(body.constant(int(2045)), r4173);
               ir_if *f4290 = new(mem_ctx) ir_if(operand(r4291).val);
               exec_list *const f4290_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4290->then_instructions;

                  body.emit(assign(r428F, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4290->else_instructions;

                  ir_variable *const r4292 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r4294 = equal(r4173, body.constant(int(2045)));
                  ir_if *f4293 = new(mem_ctx) ir_if(operand(r4294).val);
                  exec_list *const f4293_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4293->then_instructions;

                     ir_expression *const r4295 = equal(body.constant(2097151u), r427D);
                     ir_expression *const r4296 = equal(body.constant(4294967295u), r427E);
                     body.emit(assign(r4292, logic_and(r4295, r4296), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f4293->else_instructions;

                     body.emit(assign(r4292, body.constant(false), 0x01));


                  body.instructions = f4293_parent_instructions;
                  body.emit(f4293);

                  /* END IF */

                  body.emit(assign(r428F, logic_and(r4292, r428B), 0x01));


               body.instructions = f4290_parent_instructions;
               body.emit(f4290);

               /* END IF */

               /* IF CONDITION */
               ir_if *f4297 = new(mem_ctx) ir_if(operand(r428F).val);
               exec_list *const f4297_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4297->then_instructions;

                  ir_variable *const r4298 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r4298);
                  ir_expression *const r4299 = lshift(r3D52, body.constant(int(31)));
                  body.emit(assign(r4298, add(r4299, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r4298, body.constant(0u), 0x01));

                  body.emit(assign(r428A, r4298, 0x03));

                  body.emit(assign(r4289, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4297->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r429B = less(r4173, body.constant(int(0)));
                  ir_if *f429A = new(mem_ctx) ir_if(operand(r429B).val);
                  exec_list *const f429A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f429A->then_instructions;

                     ir_variable *const r429C = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r429C, r4174, 0x01));

                     ir_variable *const r429D = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r429D, neg(r4173), 0x01));

                     ir_variable *const r429E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r429E);
                     ir_variable *const r429F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r429F);
                     ir_variable *const r42A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r42A0);
                     ir_variable *const r42A1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r42A2 = neg(r429D);
                     body.emit(assign(r42A1, bit_and(r42A2, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r42A4 = equal(r429D, body.constant(int(0)));
                     ir_if *f42A3 = new(mem_ctx) ir_if(operand(r42A4).val);
                     exec_list *const f42A3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f42A3->then_instructions;

                        body.emit(assign(r429E, r4174, 0x01));

                        body.emit(assign(r429F, r427E, 0x01));

                        body.emit(assign(r42A0, r427D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f42A3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r42A6 = less(r429D, body.constant(int(32)));
                        ir_if *f42A5 = new(mem_ctx) ir_if(operand(r42A6).val);
                        exec_list *const f42A5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f42A5->then_instructions;

                           body.emit(assign(r429E, lshift(r427E, r42A1), 0x01));

                           ir_expression *const r42A7 = lshift(r427D, r42A1);
                           ir_expression *const r42A8 = rshift(r427E, r429D);
                           body.emit(assign(r429F, bit_or(r42A7, r42A8), 0x01));

                           body.emit(assign(r42A0, rshift(r427D, r429D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f42A5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r42AA = equal(r429D, body.constant(int(32)));
                           ir_if *f42A9 = new(mem_ctx) ir_if(operand(r42AA).val);
                           exec_list *const f42A9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f42A9->then_instructions;

                              body.emit(assign(r429E, r427E, 0x01));

                              body.emit(assign(r429F, r427D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f42A9->else_instructions;

                              body.emit(assign(r429C, bit_or(r4174, r427E), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r42AC = less(r429D, body.constant(int(64)));
                              ir_if *f42AB = new(mem_ctx) ir_if(operand(r42AC).val);
                              exec_list *const f42AB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f42AB->then_instructions;

                                 body.emit(assign(r429E, lshift(r427D, r42A1), 0x01));

                                 ir_expression *const r42AD = bit_and(r429D, body.constant(int(31)));
                                 body.emit(assign(r429F, rshift(r427D, r42AD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f42AB->else_instructions;

                                 ir_variable *const r42AE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r42B0 = equal(r429D, body.constant(int(64)));
                                 ir_if *f42AF = new(mem_ctx) ir_if(operand(r42B0).val);
                                 exec_list *const f42AF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f42AF->then_instructions;

                                    body.emit(assign(r42AE, r427D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f42AF->else_instructions;

                                    ir_expression *const r42B1 = nequal(r427D, body.constant(0u));
                                    ir_expression *const r42B2 = expr(ir_unop_b2i, r42B1);
                                    body.emit(assign(r42AE, expr(ir_unop_i2u, r42B2), 0x01));


                                 body.instructions = f42AF_parent_instructions;
                                 body.emit(f42AF);

                                 /* END IF */

                                 body.emit(assign(r429E, r42AE, 0x01));

                                 body.emit(assign(r429F, body.constant(0u), 0x01));


                              body.instructions = f42AB_parent_instructions;
                              body.emit(f42AB);

                              /* END IF */


                           body.instructions = f42A9_parent_instructions;
                           body.emit(f42A9);

                           /* END IF */

                           body.emit(assign(r42A0, body.constant(0u), 0x01));


                        body.instructions = f42A5_parent_instructions;
                        body.emit(f42A5);

                        /* END IF */

                        ir_expression *const r42B3 = nequal(r429C, body.constant(0u));
                        ir_expression *const r42B4 = expr(ir_unop_b2i, r42B3);
                        ir_expression *const r42B5 = expr(ir_unop_i2u, r42B4);
                        body.emit(assign(r429E, bit_or(r429E, r42B5), 0x01));


                     body.instructions = f42A3_parent_instructions;
                     body.emit(f42A3);

                     /* END IF */

                     body.emit(assign(r4286, r42A0, 0x01));

                     body.emit(assign(r4287, r429F, 0x01));

                     body.emit(assign(r4288, r429E, 0x01));

                     body.emit(assign(r4285, body.constant(int(0)), 0x01));

                     body.emit(assign(r428B, less(r429E, body.constant(0u)), 0x01));


                  body.instructions = f429A_parent_instructions;
                  body.emit(f429A);

                  /* END IF */


               body.instructions = f4297_parent_instructions;
               body.emit(f4297);

               /* END IF */


            body.instructions = f428D_parent_instructions;
            body.emit(f428D);

            /* END IF */

            /* IF CONDITION */
            ir_if *f42B6 = new(mem_ctx) ir_if(operand(r4289).val);
            exec_list *const f42B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f42B6->then_instructions;

               /* IF CONDITION */
               ir_if *f42B7 = new(mem_ctx) ir_if(operand(r428B).val);
               exec_list *const f42B7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f42B7->then_instructions;

                  ir_variable *const r42B8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r42B8, add(r4287, body.constant(1u)), 0x01));

                  ir_expression *const r42B9 = less(r42B8, r4287);
                  ir_expression *const r42BA = expr(ir_unop_b2i, r42B9);
                  ir_expression *const r42BB = expr(ir_unop_i2u, r42BA);
                  body.emit(assign(r4286, add(r4286, r42BB), 0x01));

                  ir_expression *const r42BC = equal(r4288, body.constant(0u));
                  ir_expression *const r42BD = expr(ir_unop_b2i, r42BC);
                  ir_expression *const r42BE = expr(ir_unop_i2u, r42BD);
                  ir_expression *const r42BF = add(r4288, r42BE);
                  ir_expression *const r42C0 = bit_and(r42BF, body.constant(1u));
                  ir_expression *const r42C1 = expr(ir_unop_bit_not, r42C0);
                  body.emit(assign(r4287, bit_and(r42B8, r42C1), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f42B7->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r42C3 = bit_or(r4286, r4287);
                  ir_expression *const r42C4 = equal(r42C3, body.constant(0u));
                  ir_if *f42C2 = new(mem_ctx) ir_if(operand(r42C4).val);
                  exec_list *const f42C2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f42C2->then_instructions;

                     body.emit(assign(r4285, body.constant(int(0)), 0x01));


                  body.instructions = f42C2_parent_instructions;
                  body.emit(f42C2);

                  /* END IF */


               body.instructions = f42B7_parent_instructions;
               body.emit(f42B7);

               /* END IF */

               ir_variable *const r42C5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r42C5);
               ir_expression *const r42C6 = lshift(r3D52, body.constant(int(31)));
               ir_expression *const r42C7 = expr(ir_unop_i2u, r4285);
               ir_expression *const r42C8 = lshift(r42C7, body.constant(int(20)));
               ir_expression *const r42C9 = add(r42C6, r42C8);
               body.emit(assign(r42C5, add(r42C9, r4286), 0x02));

               body.emit(assign(r42C5, r4287, 0x01));

               body.emit(assign(r428A, r42C5, 0x03));

               body.emit(assign(r4289, body.constant(false), 0x01));


            body.instructions = f42B6_parent_instructions;
            body.emit(f42B6);

            /* END IF */

            body.emit(assign(r416F, r428A, 0x03));

            body.emit(assign(r416E, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f4283->else_instructions;

            body.emit(assign(r4173, add(r4173, body.constant(int(1))), 0x01));

            ir_variable *const r42CA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r42CA);
            ir_variable *const r42CB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r42CB);
            ir_variable *const r42CC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r42CC);
            body.emit(assign(r42CA, lshift(r427E, body.constant(int(31))), 0x01));

            ir_expression *const r42CD = lshift(r427D, body.constant(int(31)));
            ir_expression *const r42CE = rshift(r427E, body.constant(int(1)));
            body.emit(assign(r42CB, bit_or(r42CD, r42CE), 0x01));

            body.emit(assign(r42CC, rshift(r427D, body.constant(int(1))), 0x01));

            ir_expression *const r42CF = nequal(r4174, body.constant(0u));
            ir_expression *const r42D0 = expr(ir_unop_b2i, r42CF);
            ir_expression *const r42D1 = expr(ir_unop_i2u, r42D0);
            body.emit(assign(r42CA, bit_or(r42CA, r42D1), 0x01));

            body.emit(assign(r4175, r42CC, 0x01));

            body.emit(assign(r4174, r42CA, 0x01));

            ir_variable *const r42D2 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r42D2, r4173, 0x01));

            ir_variable *const r42D3 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r42D3, r42CC, 0x01));

            ir_variable *const r42D4 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r42D4, r42CB, 0x01));

            ir_variable *const r42D5 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r42D5, r42CA, 0x01));

            ir_variable *const r42D6 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r42D6, body.constant(true), 0x01));

            ir_variable *const r42D7 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r42D8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r42D8);
            ir_expression *const r42D9 = expr(ir_unop_u2i, r42CA);
            body.emit(assign(r42D8, less(r42D9, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r42DB = lequal(body.constant(int(2045)), r4173);
            ir_if *f42DA = new(mem_ctx) ir_if(operand(r42DB).val);
            exec_list *const f42DA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f42DA->then_instructions;

               ir_variable *const r42DC = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r42DE = less(body.constant(int(2045)), r4173);
               ir_if *f42DD = new(mem_ctx) ir_if(operand(r42DE).val);
               exec_list *const f42DD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f42DD->then_instructions;

                  body.emit(assign(r42DC, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f42DD->else_instructions;

                  ir_variable *const r42DF = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r42E1 = equal(r4173, body.constant(int(2045)));
                  ir_if *f42E0 = new(mem_ctx) ir_if(operand(r42E1).val);
                  exec_list *const f42E0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f42E0->then_instructions;

                     ir_expression *const r42E2 = equal(body.constant(2097151u), r42CC);
                     ir_expression *const r42E3 = equal(body.constant(4294967295u), r42CB);
                     body.emit(assign(r42DF, logic_and(r42E2, r42E3), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f42E0->else_instructions;

                     body.emit(assign(r42DF, body.constant(false), 0x01));


                  body.instructions = f42E0_parent_instructions;
                  body.emit(f42E0);

                  /* END IF */

                  body.emit(assign(r42DC, logic_and(r42DF, r42D8), 0x01));


               body.instructions = f42DD_parent_instructions;
               body.emit(f42DD);

               /* END IF */

               /* IF CONDITION */
               ir_if *f42E4 = new(mem_ctx) ir_if(operand(r42DC).val);
               exec_list *const f42E4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f42E4->then_instructions;

                  ir_variable *const r42E5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r42E5);
                  ir_expression *const r42E6 = lshift(r3D52, body.constant(int(31)));
                  body.emit(assign(r42E5, add(r42E6, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r42E5, body.constant(0u), 0x01));

                  body.emit(assign(r42D7, r42E5, 0x03));

                  body.emit(assign(r42D6, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f42E4->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r42E8 = less(r4173, body.constant(int(0)));
                  ir_if *f42E7 = new(mem_ctx) ir_if(operand(r42E8).val);
                  exec_list *const f42E7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f42E7->then_instructions;

                     ir_variable *const r42E9 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r42E9, r42CA, 0x01));

                     ir_variable *const r42EA = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r42EA, neg(r4173), 0x01));

                     ir_variable *const r42EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r42EB);
                     ir_variable *const r42EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r42EC);
                     ir_variable *const r42ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r42ED);
                     ir_variable *const r42EE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r42EF = neg(r42EA);
                     body.emit(assign(r42EE, bit_and(r42EF, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r42F1 = equal(r42EA, body.constant(int(0)));
                     ir_if *f42F0 = new(mem_ctx) ir_if(operand(r42F1).val);
                     exec_list *const f42F0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f42F0->then_instructions;

                        body.emit(assign(r42EB, r42CA, 0x01));

                        body.emit(assign(r42EC, r42CB, 0x01));

                        body.emit(assign(r42ED, r42CC, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f42F0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r42F3 = less(r42EA, body.constant(int(32)));
                        ir_if *f42F2 = new(mem_ctx) ir_if(operand(r42F3).val);
                        exec_list *const f42F2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f42F2->then_instructions;

                           body.emit(assign(r42EB, lshift(r42CB, r42EE), 0x01));

                           ir_expression *const r42F4 = lshift(r42CC, r42EE);
                           ir_expression *const r42F5 = rshift(r42CB, r42EA);
                           body.emit(assign(r42EC, bit_or(r42F4, r42F5), 0x01));

                           body.emit(assign(r42ED, rshift(r42CC, r42EA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f42F2->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r42F7 = equal(r42EA, body.constant(int(32)));
                           ir_if *f42F6 = new(mem_ctx) ir_if(operand(r42F7).val);
                           exec_list *const f42F6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f42F6->then_instructions;

                              body.emit(assign(r42EB, r42CB, 0x01));

                              body.emit(assign(r42EC, r42CC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f42F6->else_instructions;

                              body.emit(assign(r42E9, bit_or(r42CA, r42CB), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r42F9 = less(r42EA, body.constant(int(64)));
                              ir_if *f42F8 = new(mem_ctx) ir_if(operand(r42F9).val);
                              exec_list *const f42F8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f42F8->then_instructions;

                                 body.emit(assign(r42EB, lshift(r42CC, r42EE), 0x01));

                                 ir_expression *const r42FA = bit_and(r42EA, body.constant(int(31)));
                                 body.emit(assign(r42EC, rshift(r42CC, r42FA), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f42F8->else_instructions;

                                 ir_variable *const r42FB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r42FD = equal(r42EA, body.constant(int(64)));
                                 ir_if *f42FC = new(mem_ctx) ir_if(operand(r42FD).val);
                                 exec_list *const f42FC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f42FC->then_instructions;

                                    body.emit(assign(r42FB, r42CC, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f42FC->else_instructions;

                                    ir_expression *const r42FE = nequal(r42CC, body.constant(0u));
                                    ir_expression *const r42FF = expr(ir_unop_b2i, r42FE);
                                    body.emit(assign(r42FB, expr(ir_unop_i2u, r42FF), 0x01));


                                 body.instructions = f42FC_parent_instructions;
                                 body.emit(f42FC);

                                 /* END IF */

                                 body.emit(assign(r42EB, r42FB, 0x01));

                                 body.emit(assign(r42EC, body.constant(0u), 0x01));


                              body.instructions = f42F8_parent_instructions;
                              body.emit(f42F8);

                              /* END IF */


                           body.instructions = f42F6_parent_instructions;
                           body.emit(f42F6);

                           /* END IF */

                           body.emit(assign(r42ED, body.constant(0u), 0x01));


                        body.instructions = f42F2_parent_instructions;
                        body.emit(f42F2);

                        /* END IF */

                        ir_expression *const r4300 = nequal(r42E9, body.constant(0u));
                        ir_expression *const r4301 = expr(ir_unop_b2i, r4300);
                        ir_expression *const r4302 = expr(ir_unop_i2u, r4301);
                        body.emit(assign(r42EB, bit_or(r42EB, r4302), 0x01));


                     body.instructions = f42F0_parent_instructions;
                     body.emit(f42F0);

                     /* END IF */

                     body.emit(assign(r42D3, r42ED, 0x01));

                     body.emit(assign(r42D4, r42EC, 0x01));

                     body.emit(assign(r42D5, r42EB, 0x01));

                     body.emit(assign(r42D2, body.constant(int(0)), 0x01));

                     body.emit(assign(r42D8, less(r42EB, body.constant(0u)), 0x01));


                  body.instructions = f42E7_parent_instructions;
                  body.emit(f42E7);

                  /* END IF */


               body.instructions = f42E4_parent_instructions;
               body.emit(f42E4);

               /* END IF */


            body.instructions = f42DA_parent_instructions;
            body.emit(f42DA);

            /* END IF */

            /* IF CONDITION */
            ir_if *f4303 = new(mem_ctx) ir_if(operand(r42D6).val);
            exec_list *const f4303_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f4303->then_instructions;

               /* IF CONDITION */
               ir_if *f4304 = new(mem_ctx) ir_if(operand(r42D8).val);
               exec_list *const f4304_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4304->then_instructions;

                  ir_variable *const r4305 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r4305, add(r42D4, body.constant(1u)), 0x01));

                  ir_expression *const r4306 = less(r4305, r42D4);
                  ir_expression *const r4307 = expr(ir_unop_b2i, r4306);
                  ir_expression *const r4308 = expr(ir_unop_i2u, r4307);
                  body.emit(assign(r42D3, add(r42D3, r4308), 0x01));

                  ir_expression *const r4309 = equal(r42D5, body.constant(0u));
                  ir_expression *const r430A = expr(ir_unop_b2i, r4309);
                  ir_expression *const r430B = expr(ir_unop_i2u, r430A);
                  ir_expression *const r430C = add(r42D5, r430B);
                  ir_expression *const r430D = bit_and(r430C, body.constant(1u));
                  ir_expression *const r430E = expr(ir_unop_bit_not, r430D);
                  body.emit(assign(r42D4, bit_and(r4305, r430E), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4304->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r4310 = bit_or(r42D3, r42D4);
                  ir_expression *const r4311 = equal(r4310, body.constant(0u));
                  ir_if *f430F = new(mem_ctx) ir_if(operand(r4311).val);
                  exec_list *const f430F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f430F->then_instructions;

                     body.emit(assign(r42D2, body.constant(int(0)), 0x01));


                  body.instructions = f430F_parent_instructions;
                  body.emit(f430F);

                  /* END IF */


               body.instructions = f4304_parent_instructions;
               body.emit(f4304);

               /* END IF */

               ir_variable *const r4312 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r4312);
               ir_expression *const r4313 = lshift(r3D52, body.constant(int(31)));
               ir_expression *const r4314 = expr(ir_unop_i2u, r42D2);
               ir_expression *const r4315 = lshift(r4314, body.constant(int(20)));
               ir_expression *const r4316 = add(r4313, r4315);
               body.emit(assign(r4312, add(r4316, r42D3), 0x02));

               body.emit(assign(r4312, r42D4, 0x01));

               body.emit(assign(r42D7, r4312, 0x03));

               body.emit(assign(r42D6, body.constant(false), 0x01));


            body.instructions = f4303_parent_instructions;
            body.emit(f4303);

            /* END IF */

            body.emit(assign(r416F, r42D7, 0x03));

            body.emit(assign(r416E, body.constant(false), 0x01));


         body.instructions = f4283_parent_instructions;
         body.emit(f4283);

         /* END IF */


      body.instructions = f427C_parent_instructions;
      body.emit(f427C);

      /* END IF */

      body.emit(assign(r3D51, r416F, 0x03));


   body.instructions = f3D54_parent_instructions;
   body.emit(f3D54);

   /* END IF */

   ir_variable *const r4317 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r4318 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r4318);
   ir_variable *const r4319 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r4319);
   ir_variable *const r431A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r431A);
   body.emit(assign(r431A, bit_and(swizzle_y(r3D51), body.constant(1048575u)), 0x02));

   body.emit(assign(r431A, swizzle_x(r3D51), 0x01));

   ir_variable *const r431B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r431B);
   body.emit(assign(r431B, bit_and(swizzle_y(r33DE), body.constant(1048575u)), 0x02));

   body.emit(assign(r431B, swizzle_x(r33DE), 0x01));

   ir_expression *const r431C = rshift(swizzle_y(r3D51), body.constant(int(20)));
   ir_expression *const r431D = bit_and(r431C, body.constant(2047u));
   ir_expression *const r431E = expr(ir_unop_u2i, r431D);
   ir_expression *const r431F = equal(r431E, body.constant(int(2047)));
   ir_expression *const r4320 = bit_or(swizzle_y(r431A), swizzle_x(r3D51));
   ir_expression *const r4321 = nequal(r4320, body.constant(0u));
   body.emit(assign(r4319, logic_and(r431F, r4321), 0x01));

   ir_expression *const r4322 = rshift(swizzle_y(r33DE), body.constant(int(20)));
   ir_expression *const r4323 = bit_and(r4322, body.constant(2047u));
   ir_expression *const r4324 = expr(ir_unop_u2i, r4323);
   ir_expression *const r4325 = equal(r4324, body.constant(int(2047)));
   ir_expression *const r4326 = bit_or(swizzle_y(r431B), swizzle_x(r33DE));
   ir_expression *const r4327 = nequal(r4326, body.constant(0u));
   body.emit(assign(r4318, logic_and(r4325, r4327), 0x01));

   /* IF CONDITION */
   ir_expression *const r4329 = logic_or(r4319, r4318);
   ir_if *f4328 = new(mem_ctx) ir_if(operand(r4329).val);
   exec_list *const f4328_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f4328->then_instructions;

      body.emit(assign(r4317, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f4328->else_instructions;

      ir_expression *const r432A = equal(swizzle_x(r3D51), swizzle_x(r33DE));
      ir_expression *const r432B = equal(swizzle_y(r3D51), swizzle_y(r33DE));
      ir_expression *const r432C = equal(swizzle_x(r3D51), body.constant(0u));
      ir_expression *const r432D = bit_or(swizzle_y(r3D51), swizzle_y(r33DE));
      ir_expression *const r432E = lshift(r432D, body.constant(int(1)));
      ir_expression *const r432F = equal(r432E, body.constant(0u));
      ir_expression *const r4330 = logic_and(r432C, r432F);
      ir_expression *const r4331 = logic_or(r432B, r4330);
      body.emit(assign(r4317, logic_and(r432A, r4331), 0x01));


   body.instructions = f4328_parent_instructions;
   body.emit(f4328);

   /* END IF */

   ir_variable *const r4332 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r4334 = expr(ir_unop_logic_not, r4317);
   ir_if *f4333 = new(mem_ctx) ir_if(operand(r4334).val);
   exec_list *const f4333_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f4333->then_instructions;

      body.emit(assign(r4332, r3D51, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f4333->else_instructions;

      body.emit(assign(r4332, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


   body.instructions = f4333_parent_instructions;
   body.emit(f4333);

   /* END IF */

   body.emit(ret(r4332));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
